owerDevice,
                                        SmbReq,
                                        sizeof(SMB_REQUEST),
                                        NULL,
                                        0,
                                        TRUE,
                                        &Event,
                                        &iosb);
    if (irp != NULL)
    {
        status = IoCallDriver(devext->LowerDevice, irp);
        if (status == STATUS_PENDING)
        {
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            status = iosb.Status;
        }

        if (!NT_SUCCESS(status))
        {
            ERRPRINT(("failed SMB request ioctl (status=%x).\n", status));
        }
    }
    else
    {
        ERRPRINT(("failed to build smb request ioctl request.\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //SMBRequest

/*++
    @doc    INTERNAL

    @func   NTSTATUS | RegQueryDeviceParam | Query the registry for a device
            parameter.

    @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
    @parm   IN PCWSTR | pwstrParamName | Points to the param name string.
    @parm   OUT PVOID | pbBuff | Points to the buffer to hold the result.
    @parm   IN ULONG | dwcbLen | Specifies the length of the buffer.

    @rvalue SUCCESS | Returns STATUS_SUCCESS
    @rvalue FAILURE | Returns NT status code
--*/

NTSTATUS INTERNAL
RegQueryDeviceParam(
    IN  PDEVICE_OBJECT DevObj,
    IN  PCWSTR         pwstrParamName,
    OUT PVOID          pbBuff,
    IN  ULONG          dwcbLen
    )
{
    PROCNAME("RegQueryDeviceParam")
    NTSTATUS status;
    ULONG dwSize;
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;

    PAGED_CODE();
    ENTER(2, ("(DevObj=%p,ParamName=%S,pbBuff=%p,Len=%d)\n",
              DevObj, pwstrParamName, pbBuff, dwcbLen));

    dwSize = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + dwcbLen;
    ValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ExAllocatePoolWithTag(
                                                    NonPagedPool,
                                                    dwSize,
                                                    SMBLITE_POOLTAG);
    if (ValueInfo != NULL)
    {
        HANDLE hkey;

        status = IoOpenDeviceRegistryKey(DevObj,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         STANDARD_RIGHTS_READ,
                                         &hkey);
        if (NT_SUCCESS(status))
        {
            UNICODE_STRING ucKeyName;

            RtlInitUnicodeString(&ucKeyName, pwstrParamName);
            status = ZwQueryValueKey(hkey,
                                     &ucKeyName,
                                     KeyValuePartialInformation,
                                     ValueInfo,
                                     dwSize,
                                     &dwSize);
            if (NT_SUCCESS(status))
            {
                ASSERT(ValueInfo->DataLength == dwcbLen);
                RtlCopyMemory(pbBuff, ValueInfo->Data, dwcbLen);
            }
            else
            {
                WARNPRINT(("failed to read parameter %S (status=%x)\n",
                           pwstrParamName, status));
            }

            ZwClose(hkey);
        }
        else
        {
            ERRPRINT(("failed to open device registry key (status=%x)\n",
                      status));
        }

        ExFreePool(ValueInfo);
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        ERRPRINT(("failed to allocate registry value buffer (size=%d)\n",
                  dwSize));
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //RegQueryDeviceParam

/*++
    @doc    INTERNAL

    @func   NTSTATUS | RegSetDeviceParam | Set a device parameter into the
            registry.

    @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
    @parm   IN PCWSTR | pwstrParamName | Points to the param name string.
    @parm   IN PVOID | pbBuff | Points to the buffer containing data.
    @parm   IN ULONG | dwcbLen | Specifies the length of the buffer.

    @rvalue SUCCESS | Returns STATUS_SUCCESS
    @rvalue FAILURE | Returns NT status code
--*/

NTSTATUS INTERNAL
RegSetDeviceParam(
    IN PDEVICE_OBJECT DevObj,
    IN PCWSTR         pwstrParamName,
    IN PVOID          pbBuff,
    IN ULONG          dwcbLen
    )
{
    PROCNAME("RegSetDeviceParam")
    NTSTATUS status;
    HANDLE hkey;

    ENTER(2, ("(DevObj=%p,ParamName=%S,pbBuff=%p,Len=%d)\n",
              DevObj, pwstrParamName, pbBuff, dwcbLen));

    //
    // Note: this routine must not be pageable because it could be called
    // by SetBackLightBrightness and then PowerStateCallbackProc which could
    // be called at DPC.
    //
    status = IoOpenDeviceRegistryKey(DevObj,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_WRITE,
                                     &hkey);
    if (NT_SUCCESS(status))
    {
        UNICODE_STRING ucKeyName;

        RtlInitUnicodeString(&ucKeyName, pwstrParamName);
        status = ZwSetValueKey(hkey,
                               &ucKeyName,
                               0,
                               REG_BINARY,
                               pbBuff,
                               dwcbLen);
        if (!NT_SUCCESS(status))
        {
            WARNPRINT(("failed to write device parameter %S (status=%x)\n",
                       pwstrParamName, status));
        }

        ZwClose(hkey);
    }
    else
    {
        ERRPRINT(("failed to open device registry key (status=%x)\n",
                  status));
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //RegSetDeviceParam
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\smblite\trace.c ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    trace.c

Abstract:

    This module contains the code for debug tracing.

Author:

    Michael Tsang (MikeTs) 24-Sep-1998

Environment:

    Kernel mode

Revision History:


--*/

#include "pch.h"

#ifdef TRACING
//
// Constants
//

//
// Local Data
//
int giTraceLevel = 0;
int giTraceIndent = 0;
ULONG gdwfTrace = 0;

BOOLEAN
IsTraceOn(
    IN UCHAR   n,
    IN PSZ     ProcName
    )
/*++

Routine Description:
    This routine determines if the given procedure should be traced.

Arguments:
    n - trace level of the procedure
    ProcName - points to the procedure name string

Return Value:
    Success - returns TRUE
    Failure - returns FALSE

--*/
{
    BOOLEAN rc = FALSE;

    if (!(gdwfTrace & TF_CHECKING_TRACE) && (giTraceLevel >= n))
    {
        int i;

        DbgPrint(MODNAME ": ");

        for (i = 0; i < giTraceIndent; ++i)
        {
            DbgPrint("| ");
        }

        DbgPrint(ProcName);

        rc = TRUE;
    }

    return rc;
}       //IsTraceOn

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\smblite\trace.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    trace.h

Abstract:

    This module contains definitions of the trace functions

Author:
    Michael Tsang (MikeTs) 24-Sep-1998

Environment:

    Kernel mode


Revision History:


--*/

#ifndef _TRACE_H
#define _TRACE_H

//
// Constants
//
#define TF_CHECKING_TRACE       0x00000001

//
// Macros
//
#ifdef TRACING
  #ifndef PROCNAME
    #define PROCNAME(s) static PSZ ProcName = s;
  #endif
  #define ENTER(n,p)    {                                               \
                            if (IsTraceOn(n, ProcName))                 \
                            {                                           \
                                gdwfTrace |= TF_CHECKING_TRACE;         \
                                DbgPrint p;                             \
                                gdwfTrace &= ~TF_CHECKING_TRACE;        \
                            }                                           \
                            ++giTraceIndent;                            \
                        }
  #define EXIT(n,p)     {                                               \
                            --giTraceIndent;                            \
                            if (IsTraceOn(n, ProcName))                 \
                            {                                           \
                                gdwfTrace |= TF_CHECKING_TRACE;         \
                                DbgPrint p;                             \
                                gdwfTrace &= ~TF_CHECKING_TRACE;        \
                            }                                           \
                        }
#else
  #define PROCNAME(s)
  #define ENTER(n,p)
  #define EXIT(n,p)
#endif

//
// Exported function prototypes
//
#ifdef TRACING
//
// Exported data
//
extern int giTraceIndent;
extern ULONG gdwfTrace;

BOOLEAN
IsTraceOn(
    IN UCHAR   n,
    IN PSZ     ProcName
    );
#endif

#endif  //ifndef _TRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\mutohpen\trace.c ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    trace.c

Abstract:

    This module contains the code for debug tracing.

Author:

    Michael Tsang (MikeTs) 24-Sep-1998

Environment:

    Kernel mode

Revision History:


--*/

#include "pch.h"

#ifdef TRACING
//
// Constants
//

//
// Local Data
//
int giTraceLevel = 0;
int giTraceIndent = 0;
ULONG gdwfTrace = 0;

BOOLEAN
IsTraceOn(
    IN UCHAR   n,
    IN PSZ     ProcName
    )
/*++

Routine Description:
    This routine determines if the given procedure should be traced.

Arguments:
    n - trace level of the procedure
    ProcName - points to the procedure name string

Return Value:
    Success - returns TRUE
    Failure - returns FALSE

--*/
{
    BOOLEAN rc = FALSE;

    if (!(gdwfTrace & TF_CHECKING_TRACE) && (giTraceLevel >= n))
    {
        int i;

        DbgPrint(MODNAME ": ");

        for (i = 0; i < giTraceIndent; ++i)
        {
            DbgPrint("| ");
        }

        DbgPrint(ProcName);

        rc = TRUE;
    }

    return rc;
}       //IsTraceOn

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\smblite\smblitep.h ===
/*++
    Copyright (c) 2000  Microsoft Corporation

    Module Name:
        smblitep.h

    Abstract:  Contains SMBus Back Light specific definitions.

    Environment:
        Kernel mode

    Author:
        Michael Tsang (MikeTs) 20-Nov-2000

    Revision History:
--*/

#ifndef _SMBLITEP_H
#define _SMBLITEP_H

//
// Constants
//
#define SMBLITEF_DEVICE_STARTED         0x00000001
#define SMBLITEF_DEVICE_REMOVED         0x00000002
#define SMBLITEF_SYM_LINK_CREATED       0x00000004
#define SMBLITEF_SYSTEM_ON_AC           0x00000008

#define SMBLITE_POOLTAG                 'LbmS'
#define SMBADDR_BACKLIGHT               0x2c            //Addr on bus==0x58
#define SMBCMD_BACKLIGHT_NORMAL         0x00
#define SMBCMD_BACKLIGHT_SHUTDOWN       0x80
#define DEF_ACBRIGHTNESS                32
#define DEF_DCBRIGHTNESS                16

typedef struct _SMBLITE_DEVEXT
{
    ULONG              dwfSmbLite;
    SMBLITE_BRIGHTNESS BackLightBrightness;
    PDEVICE_OBJECT     FDO;
    PDEVICE_OBJECT     PDO;
    PDEVICE_OBJECT     LowerDevice;
    PVOID              hPowerStateCallback;
    UNICODE_STRING     SymbolicName;
    IO_REMOVE_LOCK     RemoveLock;
} SMBLITE_DEVEXT, *PSMBLITE_DEVEXT;

//
// Global Data
//
extern const WCHAR gcwstrACBrightness[];
extern const WCHAR gcwstrDCBrightness[];

//
// Function prototypes
//

// smblite.c
NTSTATUS EXTERNAL
DriverEntry(
    IN PDRIVER_OBJECT  DrvObj,
    IN PUNICODE_STRING RegPath
    );

NTSTATUS EXTERNAL
SmbLiteAddDevice(
    IN PDRIVER_OBJECT DrvObj,
    IN PDEVICE_OBJECT DevObj
    );

VOID INTERNAL
RemoveDevice(
    IN PSMBLITE_DEVEXT devext
    );

VOID EXTERNAL
SmbLiteUnload(
    IN PDRIVER_OBJECT DrvObj
    );

NTSTATUS EXTERNAL
SmbLiteCreateClose(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS INTERNAL
HookPowerStateCallback(
    IN PSMBLITE_DEVEXT devext
    );

VOID
PowerStateCallbackProc(
    IN PVOID CallbackContext,
    IN PVOID Arg1,
    IN PVOID Arg2
    );

// pnp.c
NTSTATUS EXTERNAL
SmbLitePnp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

NTSTATUS EXTERNAL
SmbLitePower(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    );

// ioctl.c
NTSTATUS EXTERNAL
SmbLiteIoctl(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    );

NTSTATUS INTERNAL
GetBackLightBrightness(
    IN  PSMBLITE_DEVEXT     devext,
    OUT PSMBLITE_BRIGHTNESS Brightness
    );

NTSTATUS INTERNAL
SetBackLightBrightness(
    IN PSMBLITE_DEVEXT     devext,
    IN PSMBLITE_BRIGHTNESS Brightness,
    IN BOOLEAN             fSaveSettings
    );

NTSTATUS INTERNAL
SMBRequest(
    IN     PSMBLITE_DEVEXT devext,
    IN OUT PSMB_REQUEST    SmbReq
    );

NTSTATUS INTERNAL
RegQueryDeviceParam(
    IN  PDEVICE_OBJECT DevObj,
    IN  PCWSTR         pwstrParamName,
    OUT PVOID          pbBuff,
    IN  ULONG          dwcbLen
    );

NTSTATUS INTERNAL
RegSetDeviceParam(
    IN PDEVICE_OBJECT DevObj,
    IN PCWSTR         pwstrParamName,
    IN PVOID          pbBuff,
    IN ULONG          dwcbLen
    );

#endif  //ifndef _SMBLITEP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\smblite\pnp.c ===
/*++
    Copyright (c) 2000 Microsoft Corporation

    Module Name:
        pnp.c

    Abstract: This module contains code to handle PnP and Power IRPs.

    Environment:
        Kernel mode

    Author:
        Michael Tsang (MikeTs) 20-Nov-2000

    Revision History:
--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
  #pragma alloc_text(PAGE, SmbLitePnp)
  #pragma alloc_text(PAGE, SmbLitePower)
#endif

/*++
    @doc    EXTERNAL

    @func   NTSTATUS | SmbLitePnp |
            Plug and Play dispatch routine for this driver.

    @parm   IN PDEVICE_OBJECT | DevObj | Pointer to the device object.
    @parm   IN PIRP | Irp | Pointer to an I/O request packet.

    @rvalue SUCCESS | returns STATUS_SUCCESS
    @rvalue FAILURE | returns NT status code
--*/

NTSTATUS EXTERNAL
SmbLitePnp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PROCNAME("SmbLitePnp")
    NTSTATUS status;
    PIO_STACK_LOCATION irpsp;
    PSMBLITE_DEVEXT devext;

    PAGED_CODE();

    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(1, ("(DevObj=%p,Irp=%p,IrpSp=%p,Minor=%s)\n",
              DevObj, Irp, irpsp,
              LookupName(irpsp->MinorFunction, PnPMinorFnNames)));

    devext = DevObj->DeviceExtension;
    status = IoAcquireRemoveLock(&devext->RemoveLock, Irp);
    if (NT_SUCCESS(status))
    {
        status = STATUS_NOT_SUPPORTED;
        switch (irpsp->MinorFunction)
        {
            case IRP_MN_QUERY_CAPABILITIES:
            {
                PDEVICE_CAPABILITIES DevCap;

                DevCap = irpsp->Parameters.DeviceCapabilities.Capabilities;
                //
                // Set size and version.
                //
                DevCap->Size = sizeof(DEVICE_CAPABILITIES);
                DevCap->Version = 1;
                //
                // Set capability bits.
                //
                DevCap->LockSupported   = FALSE;
                DevCap->EjectSupported  = FALSE;
                DevCap->Removable       = FALSE;
                DevCap->DockDevice      = FALSE;
                DevCap->UniqueID        = TRUE;
                DevCap->SilentInstall   = TRUE;
                DevCap->RawDeviceOK     = FALSE;
                DevCap->Address         = 0xffffffff;
                DevCap->UINumber        = 0xffffffff;
                DevCap->SystemWake      = PowerSystemUnspecified;
                DevCap->DeviceWake      = PowerSystemUnspecified;
                DevCap->D1Latency       = 0;
                DevCap->D2Latency       = 0;
                DevCap->D3Latency       = 0;

                status = STATUS_SUCCESS;
                break;
            }

            case IRP_MN_START_DEVICE:
                ASSERT(!(devext->dwfSmbLite & SMBLITEF_DEVICE_STARTED));
                devext->dwfSmbLite |= SMBLITEF_DEVICE_STARTED;
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_STOP_DEVICE:
                if (devext->dwfSmbLite & SMBLITEF_DEVICE_STARTED)
                {
                    devext->dwfSmbLite &= ~SMBLITEF_DEVICE_STARTED;
                }
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_REMOVE_DEVICE:
            case IRP_MN_CANCEL_REMOVE_DEVICE:
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_SURPRISE_REMOVAL:
                //
                // This should never happen because the backlight is
                // non-removable.
                //
                ASSERT(FALSE);
                status = STATUS_SUCCESS;

            case IRP_MN_REMOVE_DEVICE:
                devext->dwfSmbLite &= ~SMBLITEF_DEVICE_STARTED;
                devext->dwfSmbLite |= SMBLITEF_DEVICE_REMOVED;
                IoReleaseRemoveLockAndWait(&devext->RemoveLock, Irp);
                RemoveDevice(devext);
                status = STATUS_SUCCESS;
                break;
        }

        if (irpsp->MinorFunction != IRP_MN_REMOVE_DEVICE)
        {
            IoReleaseRemoveLock(&devext->RemoveLock, Irp);
        }
    }

    if (status != STATUS_NOT_SUPPORTED)
    {
        //
        // Only set status if we have something to add.
        //
        Irp->IoStatus.Status = status;
    }

    if (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED))
    {
        //
        // Forward the request to lower drivers.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        ENTER(2, (".IoCallDriver(DevObj=%p,Irp=%p)\n",
                  devext->LowerDevice, Irp));
        status = IoCallDriver(devext->LowerDevice, Irp);
        EXIT(2, (".IoCallDriver=%x\n", status));
    }
    else
    {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    EXIT(1, ("=%x\n", status));
    return status;
}       //SmbLitePnp

/*++
    @doc    EXTERNAL

    @func   NTSTATUS | SmbLitePower |
            The power dispatch routine for this driver.

    @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
    @parm   IN PIRP | Irp | Points to an I/O request packet.

    @rvalue SUCCESS | returns STATUS_SUCCESS
    @rvalue FAILURE | returns NT status code
--*/

NTSTATUS EXTERNAL
SmbLitePower(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PROCNAME("SmbLitePower")
    NTSTATUS status = STATUS_NOT_SUPPORTED;
    PSMBLITE_DEVEXT devext = DevObj->DeviceExtension;

    PAGED_CODE();

    ENTER(1, ("(DevObj=%p,Irp=%p,Minor=%s)\n",
              DevObj, Irp,
              LookupName(IoGetCurrentIrpStackLocation(Irp)->MinorFunction,
                         PowerMinorFnNames)));

    PoStartNextPowerIrp(Irp);
    if (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED))
    {
        //
        // Forward the request to lower drivers.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        ENTER(2, (".PoCallDriver(DevObj=%p,Irp=%p)\n",
                  devext->LowerDevice, Irp));
        status = PoCallDriver(devext->LowerDevice, Irp);
        EXIT(2, (".PoCallDriver=%x\n", status));
    }
    else
    {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    EXIT(1, ("=%x\n", status));
    return status;
}       //SmbLitePower
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\mouse.cpp ===
/*++
    Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

    Module Name:
        mouse.cpp

    Abstract:
        This module contains all the Low Level Mouse functions.

    Author:
        Michael Tsang (MikeTs) 01-Jun-2000

    Environment:
        User mode

    Revision History:
--*/

#include "pch.h"

#ifdef MOUSE_THREAD
//
// Global data
//
HHOOK    ghMouseHook = NULL;
TCHAR    gtszMouseClass[] = TEXT("MouseClass");

/*++
    @doc    INTERNAL

    @func   unsigned | MouseThread | Low Level Mouse thread.

    @parm   IN PVOID | param | Points to the thread structure.

    @rvalue Always returns 0.
--*/

unsigned __stdcall
MouseThread(
    IN PVOID param
    )
{
    TRACEPROC("MouseThread", 2)
    WNDCLASSEX wc;

    TRACEENTER(("(pThread=%p)\n", param));

    // Bump our priority so we can service mouse events ASAP.
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

    memset(&wc, 0, sizeof(wc));
    wc.cbSize = sizeof(wc);
    wc.lpfnWndProc = MouseWndProc;
    wc.hInstance = ghMod;
    wc.lpszClassName = gtszMouseClass;
    RegisterClassEx(&wc);

    while (!(gdwfTabSrv & TSF_TERMINATE))
    {
        if (SwitchThreadToInputDesktop((PTSTHREAD)param))
        {
            BOOL fImpersonate;

            fImpersonate = ImpersonateCurrentUser();
            CoInitialize(NULL);
            DoLowLevelMouse((PTSTHREAD)param);
            CoUninitialize();
            if (fImpersonate)
            {
                RevertToSelf();
            }
        }
        else
        {
            TABSRVERR(("Failed to set current desktop.\n"));
            break;
        }
    }
    TRACEINFO(1, ("Mouse thread exiting...\n"));

    TRACEEXIT(("=0\n"));
    return 0;
}       //MouseThread

/*++
    @doc    INTERNAL

    @func   VOID | DoLowLevelMouse | Do low level mouse instead.

    @parm   IN PTSTHREAD | pThread | Points to the thread structure.

    @rvalue None.
--*/

VOID
DoLowLevelMouse(
    IN PTSTHREAD pThread
    )
{
    TRACEPROC("DoLowLevelMouse", 2)

    TRACEENTER(("()\n"));

    TRACEASSERT(ghwndMouse == NULL);
    ghwndMouse = CreateWindow(gtszMouseClass,
                              gtszMouseClass,
                              WS_POPUP,
                              CW_USEDEFAULT,
                              0,
                              CW_USEDEFAULT,
                              0,
                              NULL,
                              NULL,
                              ghMod,
                              0);

    if (ghwndMouse != NULL)
    {
        pThread->pvSDTParam = ghwndMouse;
        ghMouseHook = SetWindowsHookEx(WH_MOUSE_LL,
                                       LowLevelMouseProc,
                                       ghMod,
                                       0);
        if (ghMouseHook != NULL)
        {
            MSG msg;
            DWORD rcWait;

            while (GetMessage(&msg, NULL, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            UnhookWindowsHookEx(ghMouseHook);
            ghMouseHook = NULL;
        }
        else
        {
            DestroyWindow(ghwndMouse);
            TABSRVERR(("Failed to hook low level mouse events.\n"));
        }

        ghwndMouse = NULL;
    }
    else
    {
        TABSRVERR(("Failed to create mouse window.\n"));
    }

    TRACEEXIT(("!\n"));
    return;
}       //DoLowLevelMouse

/*++
    @doc    EXTERNAL

    @func   LRESULT | LowLevelMouseProc | Low level mouse hook procedure.

    @parm   IN int | nCode | Specifies a code to determine how to process
            the message.
    @parm   IN WPARAM | wParam | Specifies hte mouse message.
    @parm   IN LPARAM | lParam | Points to the MSLLHOOKSTRUCT structure.

    @rvalue Returns non-zero if to prevent others to process.
--*/

LRESULT CALLBACK
LowLevelMouseProc(
    IN int    nCode,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("LowLevelMouseProc", 5)
    LRESULT rc = 0;
    PMSLLHOOKSTRUCT pHookStruct = (PMSLLHOOKSTRUCT)lParam;

    TRACEENTER(("(nCode=%x,wParam=%s,lParam=%x)\n",
                nCode, LookupName(wParam, WMMsgNames), lParam));

    if ((nCode >= 0) && !(pHookStruct->flags & LLMHF_INJECTED))
    {
        WORD wCurrentButtons;

        gInput.mi.dx = SCREEN_TO_NORMAL_X(pHookStruct->pt.x);
        gInput.mi.dy = SCREEN_TO_NORMAL_Y(pHookStruct->pt.y);
        wCurrentButtons = gwLastButtons;
        switch (wParam)
        {
            case WM_LBUTTONDOWN:
                wCurrentButtons |= TIP_SWITCH;
                break;

            case WM_LBUTTONUP:
                wCurrentButtons &= ~TIP_SWITCH;
                break;

            case WM_RBUTTONDOWN:
                wCurrentButtons |= BARREL_SWITCH;
                break;

            case WM_RBUTTONUP:
                wCurrentButtons &= ~BARREL_SWITCH;
                break;
        }

        rc = ProcessMouseEvent((WORD)gInput.mi.dx,
                               (WORD)gInput.mi.dy,
                               wCurrentButtons,
                               pHookStruct->time,
                               TRUE);

        gwLastButtons = wCurrentButtons;

        if (rc == 0)
        {
            rc = CallNextHookEx(ghMouseHook, nCode, wParam, lParam);
        }
    }
    else
    {
        rc = CallNextHookEx(ghMouseHook, nCode, wParam, lParam);
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //LowLevelMouseProc

/*++
    @doc    EXTERNAL

    @func   LRESULT | MouseWndProc | Mouse window proc.

    @parm   IN HWND | hwnd | Window handle.
    @parm   IN UINT | uiMsg | Window message.
    @parm   IN WPARAM | wParam | Param 1.
    @parm   IN LPARAM | lParam | Param 2.

    @rvalue Return code is message specific.
--*/

LRESULT CALLBACK
MouseWndProc(
    IN HWND   hwnd,
    IN UINT   uiMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("MouseWndProc", 5)
    LRESULT rc = 0;

    TRACEENTER(("(hwnd=%x,Msg=%s,wParam=%x,lParam=%x)\n",
                hwnd, LookupName(uiMsg, WMMsgNames), wParam, lParam));

    switch (uiMsg)
    {
        case WM_CREATE:
            giButtonsSwapped = GetSystemMetrics(SM_SWAPBUTTON);
            break;

        case WM_SETTINGCHANGE:
            if (wParam == SPI_SETMOUSEBUTTONSWAP)
            {
                giButtonsSwapped = GetSystemMetrics(SM_SWAPBUTTON);
            }
            break;

        case WM_TIMER:
            //
            // Press and hold expired, enter press and hold mode.
            //
            KillTimer(hwnd, wParam);
            if (gdwPenState == PENSTATE_PENDOWN)
            {
                PressHoldMode(TRUE);
                SetTimer(ghwndMouse,
                         TIMERID_PRESSHOLD,
                         gConfig.GestureSettings.iCancelPressHoldTime,
                         NULL);
            }
            else if (gdwPenState == PENSTATE_PRESSHOLD)
            {
                TRACEINFO(3, ("Simulate a left-down on CancelPressHold timeout.\n"));
                gdwPenState = PENSTATE_NORMAL;
                SetPressHoldCursor(FALSE);
                gInput.mi.dwFlags = MOUSEEVENTF_ABSOLUTE |
                                    MOUSEEVENTF_MOVE |
                                    MOUSEEVENTF_VIRTUALDESK |
                                    SWAPBUTTONS(giButtonsSwapped,
                                                MOUSEEVENTF_LEFTDOWN,
                                                MOUSEEVENTF_RIGHTDOWN);
                gInput.mi.dx = glPenDownX;
                gInput.mi.dy = glPenDownY;
                SendInput(1, &gInput, sizeof(INPUT));
            }
            else if (gdwPenState == PENSTATE_LEFTUP_PENDING)
            {
                TRACEINFO(3, ("Simulate a left-up on timeout.\n"));
                gdwPenState = PENSTATE_NORMAL;
                gInput.mi.dwFlags = MOUSEEVENTF_ABSOLUTE |
                                    MOUSEEVENTF_MOVE |
                                    MOUSEEVENTF_VIRTUALDESK |
                                    SWAPBUTTONS(giButtonsSwapped,
                                                MOUSEEVENTF_LEFTUP,
                                                MOUSEEVENTF_RIGHTUP);
                gInput.mi.dx = glPenUpX;
                gInput.mi.dy = glPenUpY;
                SendInput(1, &gInput, sizeof(INPUT));
            }
            break;

        case WM_CLOSE:
            DestroyWindow(hwnd);
            PostQuitMessage(0);
            break;

        default:
            rc = DefWindowProc(hwnd, uiMsg, wParam, lParam);
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //MouseWndProc

#endif  //ifdef MOUSE_THREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\itellme.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// File :     ITellMe.h
//
// Copyright (C) 2000 Microsoft Corporation. All rights reserved.
// 
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __ITELLME_H_
#define __ITELLME_H_

#ifdef __cplusplus
extern "C" {
#endif  // _cplusplus

//
// Get a few important things defined properly before proceeding
//

#undef EXPORT
#ifdef  WIN32
#define EXPORT __declspec(dllexport)
#else   // WIN32
#define EXPORT __export
#endif  // WIN32

#if defined( _WIN32 ) && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else   // defined( _WIN32 )  && !defined( _NO_COM )
#include "windows.h"
#include "ole2.h"
#define IUnknown	    void
#endif  // defined( _WIN32 )  && !defined( _NO_COM )

//
// GUID definition for the IApplicationManager interface
//
//    CLSID_TellMe = {A087B8F5-B971-4329-AD36-42D75D95A8EF}
//    IID_TellMe = {3E570A89-3E66-493d-813C-6F2013A9F167}
//

DEFINE_GUID(CLSID_TellMe, 0xa087b8f5, 0xb971, 0x4329, 0xad, 0x36, 0x42, 0xd7, 0x5d, 0x95, 0xa8, 0xef);
DEFINE_GUID(IID_TellMe, 0x3e570a89, 0x3e66, 0x493d, 0x81, 0x3c, 0x6f, 0x20, 0x13, 0xa9, 0xf1, 0x67);

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Window information structure
//
//////////////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
  DWORD dwSize;
  DWORD dwCapabilitiesMask;

} WINDOWCAPS, *LPWINDOWCAPS;

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Window cap bits
//
//////////////////////////////////////////////////////////////////////////////////////////////

#define TELLME_CAP_PRESSANDHOLDNOTALLOWED     0x00000001
#define TELLME_CAP_TAKESTESTINPUT             0x00000002

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface definitions
//
//////////////////////////////////////////////////////////////////////////////////////////////

#if defined( _WIN32 ) && !defined( _NO_COM )

//
// ITellMe Interface
//

#undef INTERFACE
#define INTERFACE ITellMe
DECLARE_INTERFACE_( ITellMe, IUnknown )
{
  //
  // IUnknown interfaces
  //

  STDMETHOD (QueryInterface) (THIS_ REFIID, LPVOID *) PURE;
  STDMETHOD_(ULONG, AddRef) (THIS) PURE;
  STDMETHOD_(ULONG, Release) (THIS) PURE;

  //
  // IApplicationEntry interface methods
  //

  STDMETHOD (GetWindowCapabilities) (THIS_ const POINT *, LPWINDOWCAPS) PURE;
  STDMETHOD (GetLastValidFocusHWnd) (THIS_ HWND *) PURE;
};

#endif  // defined( _WIN32 ) && !defined( _NO_COM )

#ifdef __cplusplus
}
#endif  // _cplusplus

#endif // __ITELLME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\gesture.cpp ===
/*++
    Copyright (c) 2000  Microsoft Corporation

    Module Name:
        gesture.cpp

    Abstract:
        This module contains the code to invoke SuperTIP.

    Author:
        Michael Tsang (MikeTs) 11-Jul-2000

    Environment:
        User mode

    Revision History:
--*/

#include "pch.h"

static const int BUFFERSIZE     = 200;	// The maximum number of points to collect while pen is up
	
typedef struct RecogRec
{
    POINT pt;
    DWORD dwTime;
} RECOGREC, *PRECOGREC;

RECOGREC coords[BUFFERSIZE] = {0};      //circular buffer
int index = 0;                          //current buffer insertion point
int startIndex = 0;                     //starting index.  Only the points
                                        //  between startIndex and index are
                                        //  valid.

inline void resetBuffer()       {index = startIndex = 0;}

/*++
    @doc    INTERNAL

    @func   int | RecognizeGesture | Do gesture recognition.

    @parm   IN LONG | x | X position.
    @parm   IN LONG | y | Y position.
    @parm   IN WORD | wButtons | Buttons state.
    @parm   IN DWORD | dwTime | Time stamp.
    @parm   IN BOOL | fLowLevelMouse | TRUE if called by LowLevelMouseProc.

    @rvalue SUCCESS | Returns gesture recognized.
    @rvalue FAILURE | Returns NO_GESTURE.
--*/

int
RecognizeGesture(
    IN LONG  x,
    IN LONG  y,
    IN WORD  wButtons,
    IN DWORD dwTime,
    IN BOOL  fLowLevelMouse
    )
{
    TRACEPROC("RecognizeGesture", 5)
    int gesture = NO_GESTURE;
    static LONG xLast = 0;
    static LONG yLast = 0;
    static WORD wLastButtons = 0;
    static DWORD dwTimeLast = 0;
    int cxScreen = fLowLevelMouse? gcxScreen: gcxPrimary,
        cyScreen = fLowLevelMouse? gcyScreen: gcyPrimary;

    TRACEENTER(("(x=%d,y=%d,Buttons=%x,Time=%d,fLowLevelMouse=%x)\n",
                x, y, wButtons,dwTime, fLowLevelMouse));

    //
    // Scale the coordinate system from 64K back to screen coordinates.
    //
    x = (x*cxScreen) >> 16;
    y = (y*cyScreen) >> 16;

    //
    // After converting back to screen coordinates, we need to coalesce
    // the previous point if they are identical.
    //
    if ((x != xLast) || (y != yLast) || (wButtons != wLastButtons) ||
        (dwTime - dwTimeLast > (DWORD)gConfig.GestureSettings.iStopTime))
    {
        xLast = x;
        yLast = y;
        wLastButtons = wButtons;
        dwTimeLast = dwTime;

        if (wButtons == 0)
        {
            POINT pt;

            pt.x = x;
            pt.y = y;
            gesture = Recognize(pt, dwTime);
            if (gesture == NO_GESTURE)
            {
                AddItem(pt, dwTime);
            }
            else
            {
                resetBuffer();
                NotifyClient(GestureEvent, gesture, 0);
                DoGestureAction(gConfig.GestureSettings.GestureMap[gesture],
                                x + glVirtualDesktopLeft,
                                y + glVirtualDesktopTop);
            }
        }
        else
        {
            resetBuffer();
        }
    }

    TRACEEXIT(("=%d\n", gesture));
    return gesture;
}       //RecognizeGesture

/*++
    @doc    INTERNAL

    @func   int | Recognize | Recognize the gesture.

    @parm   IN POINT& | pt | Current point.
    @parm   IN DWORD | dwTime | Time.

    @rvalue None.
--*/

int
Recognize(
    IN POINT& pt,
    IN DWORD  dwTime
    )
{
    TRACEPROC("Recognize", 5)
    int gesture = NO_GESTURE;

    TRACEENTER(("(x=%d,y=%d,Time=%d)\n", pt.x, pt.y, dwTime));

    if (penStopped(pt, dwTime, index, startIndex))
    {
	bool beenOut = false;
	int numPoints = 0;
	int numOutPoints = 0;
	int xmin = 1000;  //bounding box for points outside the test circle.
	int xmax = -1000;
	int ymin = 1000;
	int ymax = -1000;
	int curIndex = (index > 0)? index - 1: BUFFERSIZE - 1;
	DWORD delt;

	while ((curIndex != startIndex) &&
	       ((delt = dwTime - coords[curIndex].dwTime) <
                (DWORD)gConfig.GestureSettings.iMaxTimeToInspect))
        {
	    //go backwards through the buffer
            numPoints++;
            if (dist(pt, curIndex) >= gConfig.GestureSettings.iRadius)
            {
                //
                // Outside the test circle. Accumulate the bounding box
                // of points.
                //
                numOutPoints++;
                beenOut = true;

                // Positive if coord is east of point
                int relx = coords[curIndex].pt.x - pt.x;
                // Positive if coord is south of point
                int rely = coords[curIndex].pt.y - pt.y;

                // Possibly expand the bounding box
                if (relx < xmin) xmin = relx;
                if (relx > xmax) xmax = relx;
                if (rely < ymin) ymin = rely;
                if (rely > ymax) ymax = rely;
            }
            else
            {
                //
                // Inside the test circle
                //
                gesture = NO_GESTURE;
                if (beenOut)
                {
                    //
                    // Check points and return something
                    //
                    if ((numOutPoints >= gConfig.GestureSettings.iMinOutPts) &&
                        checkEarlierPoints(pt,
                                           coords[curIndex].dwTime,
                                           curIndex,
                                           startIndex))
                    {
                        int bW = xmax - xmin;
                        int bH = ymax - ymin;
                        if (bW >= bH)
                        {
                            //
                            // horizontal spike
                            //
                            if (bW > bH*gConfig.GestureSettings.iAspectRatio)
                            {
                                //
                                // bbox must be wide enough
                                //
                                gesture = (xmin > 0)? RIGHT_SPIKE: LEFT_SPIKE;
                            }
                        }
                        else
                        {
                            //
                            // vertical spike
                            //
                            if (bH > bW*gConfig.GestureSettings.iAspectRatio)
                            {
                                //
                                // bbox must be tall enough
                                //
                                gesture = (ymin < 0)? UP_SPIKE: DOWN_SPIKE;
                            }
                        }
                    }
                    break;
                }
            }
            curIndex = (curIndex > 0)? curIndex - 1: BUFFERSIZE - 1;
        }
    }

    TRACEEXIT(("=%d\n", gesture));
    return gesture;
}       //Recognize

/*++
    @doc    INTERNAL

    @func   void | AddItem | Add an item to the recognize buffer.

    @parm   IN LONG | x | X position.
    @parm   IN LONG | y | Y position.
    @parm   IN DWORD | dwTime | Time.

    @rvalue None.
--*/

void
AddItem(
    IN POINT& pt,
    IN DWORD  dwTime
    )
{
    TRACEPROC("AddItem", 5)

    TRACEENTER(("(x=%d,y=%d,Time=%d)\n", pt.x, pt.y, dwTime));

    coords[index].pt = pt;
    coords[index].dwTime = dwTime;
    index++;
    if (index >= BUFFERSIZE)
    {
        //
        // End of circular buffer, wrap around.
        //
        index = 0;
    }

    if (index == startIndex)
    {
        //
        // The entire buffer is full of valid points.
        //
        startIndex++;
        if (startIndex >= BUFFERSIZE)
        {
            startIndex = 0;
        }
    }

    TRACEEXIT(("!\n"));
    return;
}       //AddItem
	
/*++
    @doc    INTERNAL

    @func   bool | penStopped | The pen is considered stopped if all the
            points within the previous STOPTIME ms are within the STOPDIST
            pixel circle centered on given point.  If the buffer is less
            than STOPTIME ms long, returns false.

    @parm   IN POINT & | pt | The given point.
    @parm   IN DWORD | dwTime | Time.
    @parm   IN int | ci | current index.
    @parm   IN int | li | limiting index.

    @rvalue SUCCESS | Returns TRUE (pen has stopped).
    @rvalue FAILURE | Returns FALSE.
--*/

bool
penStopped(
    IN POINT& pt,
    IN DWORD  dwTime,
    IN int    ci,
    IN int    li
    )
{
    TRACEPROC("penStopped", 5)
    bool rc = false;

    TRACEENTER(("(x=%d,y=%d,time=%d,ci=%d,li=%d\n", pt.x, pt.y, dwTime, ci, li));

    ci = (ci > 0)? ci - 1: BUFFERSIZE - 1;
    while (ci != li)
    {
       	if (dist(pt, ci) > gConfig.GestureSettings.iStopDist)
        {
            break;
        }

       	if ((dwTime - coords[ci].dwTime) >=
            (DWORD)gConfig.GestureSettings.iStopTime)
        {
            rc = true;
            break;
        }

        ci = (ci > 0)? ci - 1: BUFFERSIZE - 1;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //penStopped
	
/*++
    @doc    INTERNAL

    @func   bool | checkEarlierPoints | Called when we have a candidate stroke,
            and the pen has just left the target circle and the point at
            coords[index] for the first time.  Inspects up to pointsToExamine
            earlier points.  They must all be there, must all be within the
            target circle (bigRadius), and they must all have occurred within
            checkTime of the time the pen left the target circle for the first
            time.  This helps to filter out "overshoot" events where the pen
            passes through the target circle quickly, then returns to the final
            touchdown point.

    @parm   IN POINT & | pt | The given point.
    @parm   IN DWORD | dwTime | Time.
    @parm   IN int | ci | current index.
    @parm   IN int | li | limiting index.

    @rvalue SUCCESS | Returns TRUE (pen has stopped).
    @rvalue FAILURE | Returns FALSE.
--*/

bool
checkEarlierPoints(
    IN POINT& pt,
    IN DWORD  dwTime,
    IN int    ci,
    IN int    li
    )
{
    TRACEPROC("checkEarlierPoints", 5)
    bool rc = true;
    int numPoints = 0;

    TRACEENTER(("(x=%d,y=%d,time=%d,ci=%d,li=%d\n",
                pt.x, pt.y, dwTime, ci, li));

    ci = (ci > 0)? ci - 1: BUFFERSIZE - 1;
    while ((ci != li) && (numPoints < gConfig.GestureSettings.iPointsToExamine))
    {
        if (dist(pt, ci) >= gConfig.GestureSettings.iRadius)
        {
            rc = false;
            break;
        }

        if ((dwTime - coords[ci].dwTime) >=
            (DWORD)gConfig.GestureSettings.iCheckTime)
        {
            break;
        }

        numPoints++;
        ci = (ci > 0)? ci - 1: BUFFERSIZE - 1;
    }

    if ((ci == li) && (numPoints < gConfig.GestureSettings.iPointsToExamine))
    {
        rc = false;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //checkEarlierPoints

/*++
    @doc    INTERNAL

    @func   int | dist | Calculates the squared distance between the given pt
            and the point at coords[index].

    @parm   IN POINT & | pt | The given point.
    @parm   IN int index | index into the recog buffer.

    @rvalue Returns the squared distance calculated.
--*/

int
dist(
    IN POINT& pt,
    IN int index
    )
{
    TRACEPROC("dist", 5)
    int dx, dy, d;

    TRACEENTER(("(x=%d,y=%d,index=%d)\n", pt.x, pt.y, index));

    dx = pt.x - coords[index].pt.x;
    dy = pt.y - coords[index].pt.y;
    d = dx*dx + dy*dy;

    TRACEEXIT(("=%d\n", d));
    return d;
}       //dist

/*++
    @doc    INTERNAL

    @func   VOID | DoGestureAction | Do the gesture action.

    @parm   IN GESTURE_ACTION | Action | Gesture action to be performed.
    @parm   IN LONG | x | x coordinate of gesture end-point.
    @parm   IN LONG | y | y coordinate of gesture end-point.

    @rvalue None.
--*/

VOID
DoGestureAction(
    IN GESTURE_ACTION Action,
    IN LONG           x,
    IN LONG           y
    )
{
    TRACEPROC("DoGestureAction", 2)

    TRACEENTER(("(Action=%d,x=%d,y=%d)\n", Action, x, y));

    switch (Action)
    {
        case PopupSuperTIP:
        case PopupMIP:
            if (ghwndSuperTIP != NULL)
            {
                PostMessage(ghwndSuperTIP,
                            WM_GESTURE,
                            (WPARAM)Action,
                            MAKELONG(WORD(x), WORD(y)));
            }
            break;

        case SendHotkey:
            SetEvent(ghHotkeyEvent);
            break;
    }

    TRACEEXIT(("!\n"));
    return;
}       //DoGestureAction
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\smblite\smblite.c ===
/*++

    Copyright (c) 2000 Microsoft Corporation

    Module Name:
        smblite.c

    Abstract:
        SMBus LCD Back Light Driver

    Environment:
        Kernel mode

    Author:
        Michael Tsang (MikeTs) 20-Nov-2000

    Revision History:

--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
  #pragma alloc_text(INIT, DriverEntry)
  #pragma alloc_text(PAGE, SmbLiteAddDevice)
  #pragma alloc_text(PAGE, RemoveDevice)
  #pragma alloc_text(PAGE, SmbLiteUnload)
  #pragma alloc_text(PAGE, SmbLiteCreateClose)
  #pragma alloc_text(PAGE, HookPowerStateCallback)
#endif  //ifdef ALLOC_PRAGMA

const WCHAR gcwstrACBrightness[] = L"ACBrightness";
const WCHAR gcwstrDCBrightness[] = L"DCBrightness";
const WCHAR gcwstrDeviceName[] = L"\\Device\\SMBusBackLight";
const WCHAR gcwstrDosDeviceName[] = L"\\DosDevices\\SMBusBackLight";

NTSYSAPI
NTSTATUS
NTAPI
ZwPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

/*++
    @doc    EXTERNAL

    @func   NTSTATUS | DriverEntry |
            Installable driver initialization entry point.
            This entry point is called directly by the I/O system.

    @parm   IN PDRIVER_OBJECT | DrvObj | Points to the driver object.
    @parm   IN PUNICODE_STRINT | RegPath | Points to the registry path.

    @rvalue SUCCESS | returns STATUS_SUCCESS
    @rvalue FAILURE | returns NT status code
--*/

NTSTATUS EXTERNAL
DriverEntry(
    IN PDRIVER_OBJECT  DrvObj,
    IN PUNICODE_STRING RegPath
    )
{
    PROCNAME("DriverEntry")
    NTSTATUS status = STATUS_SUCCESS;

    ENTER(1, ("(DrvObj=%p,RegPath=%p)\n", DrvObj, RegPath));

    DrvObj->DriverExtension->AddDevice           = SmbLiteAddDevice;
    DrvObj->DriverUnload                         = SmbLiteUnload;
    DrvObj->MajorFunction[IRP_MJ_CREATE]         =
    DrvObj->MajorFunction[IRP_MJ_CLOSE]          = SmbLiteCreateClose;
    DrvObj->MajorFunction[IRP_MJ_PNP]            = SmbLitePnp;
    DrvObj->MajorFunction[IRP_MJ_POWER]          = SmbLitePower;
    DrvObj->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SmbLiteIoctl;

    EXIT(1, ("=%x\n", status));
    return status;
}       //DriverEntry

/*++
    @doc    EXTERNAL

    @func   NTSTATUS | SmbLiteAddDevice |
            Add the new backlite device.

    @parm   IN PDRIVER_OBJECT | DrvObj | Points to the driver object.
    @parm   IN PDEVICE_OBJECT | DevObj |
            Points to a functional device object created by hidclass.

    @rvalue SUCCESS | Returns STATUS_SUCCESS.
    @rvalue FAILURE | Returns NT status code.
--*/

NTSTATUS EXTERNAL
SmbLiteAddDevice(
    IN PDRIVER_OBJECT DrvObj,
    IN PDEVICE_OBJECT DevObj
    )
{
    PROCNAME("SmbLiteAddDevice")
    NTSTATUS status;
    PDEVICE_OBJECT fdo = NULL;
    UNICODE_STRING UnicodeString;
    PSMBLITE_DEVEXT devext = NULL;

    PAGED_CODE ();

    ENTER(1, ("(DrvObj=%p,DevObj=%p)\n", DrvObj, DevObj));

    ASSERT(DevObj != NULL);

    RtlInitUnicodeString(&UnicodeString, gcwstrDeviceName);
    status = IoCreateDevice(DrvObj,
                            sizeof(SMBLITE_DEVEXT),
                            &UnicodeString,
                            FILE_DEVICE_UNKNOWN,
                            0,
                            FALSE,
                            &fdo);

    if (NT_SUCCESS(status))
    {
        devext = (PSMBLITE_DEVEXT)fdo->DeviceExtension;
        RtlZeroMemory(devext, sizeof(*devext));
        fdo->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
        fdo->Flags &= ~DO_DEVICE_INITIALIZING;
        IoInitializeRemoveLock(&devext->RemoveLock,
                               SMBLITE_POOLTAG,
                               1,
                               64);
        devext->FDO = fdo;
        devext->PDO = DevObj;
        devext->LowerDevice = IoAttachDeviceToDeviceStack(fdo, DevObj);
        if (devext->LowerDevice == NULL)
        {
            ERRPRINT(("failed to attach to lower device\n"));
            status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            RtlInitUnicodeString(&devext->SymbolicName, gcwstrDosDeviceName);
            status = IoCreateSymbolicLink(&devext->SymbolicName,
                                          &UnicodeString);
            if (!NT_SUCCESS(status))
            {
                ERRPRINT(("failed to create device symbolic name (status=%x).\n",
                          status));
            }
            else
            {
                devext->dwfSmbLite |= SMBLITEF_SYM_LINK_CREATED;
                status = HookPowerStateCallback(devext);
                if (!NT_SUCCESS(status))
                {
                    ERRPRINT(("failed to hook power state callback (status=%x).\n",
                              status));
                }
                else
                {
                    SYSTEM_BATTERY_STATE BatteryState;

                    status = ZwPowerInformation(SystemBatteryState,
                                                NULL,
                                                0,
                                                &BatteryState,
                                                sizeof(BatteryState));
                    if (!NT_SUCCESS(status))
                    {
                        ERRPRINT(("failed to query power information (status=%x).\n",
                                  status));
                    }
                    else
                    {
                        if (BatteryState.AcOnLine)
                        {
                            devext->dwfSmbLite |= SMBLITEF_SYSTEM_ON_AC;
                            DBGPRINT(1, ("System is on AC.\n"));
                        }
                        else
                        {
                            devext->dwfSmbLite &= ~SMBLITEF_SYSTEM_ON_AC;
                            DBGPRINT(1, ("System is on DC.\n"));
                        }

                        if (RegQueryDeviceParam(
                                    DevObj,
                                    gcwstrACBrightness,
                                    &devext->BackLightBrightness.bACValue,
                                    sizeof(devext->BackLightBrightness.bACValue))
                            != STATUS_SUCCESS)
                        {
                            devext->BackLightBrightness.bACValue =
                                DEF_ACBRIGHTNESS;
                        }

                        if (RegQueryDeviceParam(
                                    DevObj,
                                    gcwstrDCBrightness,
                                    &devext->BackLightBrightness.bDCValue,
                                    sizeof(devext->BackLightBrightness.bDCValue))
                            != STATUS_SUCCESS)
                        {
                            devext->BackLightBrightness.bDCValue =
                                DEF_DCBRIGHTNESS;
                        }

                        status = SetBackLightBrightness(devext,
                                                        &devext->BackLightBrightness,
                                                        FALSE);
                        if (!NT_SUCCESS(status))
                        {
                            ERRPRINT(("failed to set backlight to initial brightness (status=%x).\n",
                                      status));
                        }
                    }
                }
            }
        }
    }
    else
    {
        ERRPRINT(("failed to create FDO (status=%x)\n", status));
    }

    if (!NT_SUCCESS(status) && (fdo != NULL) && (devext != NULL))
    {
        RemoveDevice(devext);
    }

    EXIT(1, ("=%x\n", status));
    return status;
}       //SmbLiteAddDevice

/*++
    @doc    INTERNAL

    @func   VOID | RemoveDevice | Clean up.

    @parm   IN PSMBLITE_DEVEXT | devext | Points to device extension.

    @rvalue None.
--*/

VOID INTERNAL
RemoveDevice(
    IN PSMBLITE_DEVEXT devext
    )
{
    PROCNAME("RemoveDevice")
    NTSTATUS status;

    PAGED_CODE ();

    ENTER(2, ("(devext=%p)\n", devext));
    ASSERT(devext != NULL);

    if (devext->dwfSmbLite & SMBLITEF_SYM_LINK_CREATED)
    {
        status = IoDeleteSymbolicLink(&devext->SymbolicName);
        if (!NT_SUCCESS(status))
        {
            WARNPRINT(("failed to delete device symbolic name (status=%x).\n",
                       status));
        }
    }

    if (devext->hPowerStateCallback)
    {
        ExUnregisterCallback(devext->hPowerStateCallback);
    }

    if (devext->LowerDevice != NULL)
    {
        IoDetachDevice(devext->LowerDevice);
    }

    if (devext->FDO != NULL)
    {
        IoDeleteDevice(devext->FDO);
    }

    EXIT(2, ("!\n"));
    return;
}       //RemoveDevice

/*++
    @doc    EXTERNAL

    @func   void | SmbLiteUnload | Free all the allocated resources, etc.

    @parm   IN PDRIVER_OBJECT | DrvObj | Points to the driver object.

    @rvalue None.
--*/

VOID EXTERNAL
SmbLiteUnload(
    IN PDRIVER_OBJECT DrvObj
    )
{
    PROCNAME("SmbLiteUnload")

    PAGED_CODE();

    ENTER(1, ("(DrvObj=%p)\n", DrvObj));

    ASSERT(DrvObj->DeviceObject == NULL);
    UNREFERENCED_PARAMETER(DrvObj);

    EXIT(1, ("!\n"));
    return;
}       //SmbLiteUnload

/*++
    @doc    EXTERNAL

    @func   NTSTATUS | SmbLiteCreateClose |
            Process the create and close IRPs sent to this device.

    @parm   IN PDEVICE_OBJECT | DevObj | Points to the device object.
    @parm   IN PIRP | Irp | Points to an I/O Request Packet.

    @rvalue SUCCESS | Returns STATUS_SUCCESS
    @rvalue FAILURE | Returns NT status code
--*/

NTSTATUS EXTERNAL
SmbLiteCreateClose(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp
    )
{
    PROCNAME("SmbLiteCreateClose")
    NTSTATUS status;
    PSMBLITE_DEVEXT devext;
    PIO_STACK_LOCATION irpsp;

    PAGED_CODE ();

    devext = DevObj->DeviceExtension;
    irpsp = IoGetCurrentIrpStackLocation(Irp);

    ENTER(1, ("(DevObj=%p,Irp=%p,IrpStack=%p,Major=%s)\n",
              DevObj, Irp, irpsp,
              LookupName(irpsp->MajorFunction, MajorFnNames)));

    if (irpsp->MajorFunction == IRP_MJ_CREATE)
    {
        status = IoAcquireRemoveLock(&devext->RemoveLock,
                                     irpsp->FileObject);
    }
    else
    {
        ASSERT(irpsp->MajorFunction == IRP_MJ_CLOSE);
        IoReleaseRemoveLock(&devext->RemoveLock, irpsp->FileObject);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    EXIT(1, ("=%x\n", status));
    return status;
}       //SmbLiteCreateClose

/*++
    @doc    INTERNAL

    @func   NTSTATUS | HookPowerStateCallback | Hook system power state
            callback to monitor if AC power is plugged in or not.

    @parm   IN PSMBLITE_DEVEXT | devext | Points to the device extension.

    @rvalue SUCCESS | Returns STATUS_SUCCESS
    @rvalue FAILURE | Returns NT status code
--*/

NTSTATUS INTERNAL
HookPowerStateCallback(
    IN PSMBLITE_DEVEXT devext
    )
{
    PROCNAME("HookPowerStateCallback")
    NTSTATUS status;
    UNICODE_STRING CallbackName;
    OBJECT_ATTRIBUTES ObjAttrib;
    PCALLBACK_OBJECT PowerStateCallbackObj;

    PAGED_CODE();
    ENTER(2, ("(devext=%p)\n", devext));

    RtlInitUnicodeString(&CallbackName, L"\\Callback\\PowerState");
    InitializeObjectAttributes(&ObjAttrib,
                               &CallbackName,
                               OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                               NULL,
                               NULL);
    status = ExCreateCallback(&PowerStateCallbackObj,
                              &ObjAttrib,
                              FALSE,
                              TRUE);
    if (NT_SUCCESS(status))
    {
        devext->hPowerStateCallback = ExRegisterCallback(
                                        PowerStateCallbackObj,
                                        PowerStateCallbackProc,
                                        devext);
        if (devext->hPowerStateCallback == NULL)
        {
            ERRPRINT(("failed to register battery power callback function.\n"));
            status = STATUS_UNSUCCESSFUL;
        }
        ObDereferenceObject(PowerStateCallbackObj);
    }
    else
    {
        ERRPRINT(("failed to create battery power callback object (status=%x).\n",
                  status));
    }

    EXIT(2, ("=%x\n", status));
    return status;
}       //HookPowerStateCallback

/*++
    @doc    INTERNAL

    @func   VOID | PowerStateCallbackProc | Power state callback.

    @parm   IN PVOID | CallbackContext | Callback context.
    @parm   IN PVOID | Arg1 | Action.
    @parm   IN PVOID | Arg2 | Value.

    @rvalue None.
--*/

VOID
PowerStateCallbackProc(
    IN PVOID CallbackContext,
    IN PVOID Arg1,
    IN PVOID Arg2
    )
{
    PROCNAME("PowerStateCallback")

    ENTER(2, ("(Context=%p,Arg1=%p,Arg2=%p)\n", CallbackContext, Arg1, Arg2));

    //
    // This callback must be non-pageable because it could be called at
    // DISPATCH level.
    //
    if ((ULONG)Arg1 == PO_CB_AC_STATUS)
    {
        PSMBLITE_DEVEXT devext = (PSMBLITE_DEVEXT)CallbackContext;
        ULONG dwfOnAC = (Arg2 == 0)? 0: SMBLITEF_SYSTEM_ON_AC;

        DBGPRINT(1, ("System is on %s, previous state is %s.\n",
                     dwfOnAC? "AC": "DC",
                     (devext->dwfSmbLite & SMBLITEF_SYSTEM_ON_AC)? "AC": "DC"));
        if ((devext->dwfSmbLite & SMBLITEF_SYSTEM_ON_AC)^dwfOnAC)
        {
            NTSTATUS status;

            //
            // AC/DC status has changed.
            //
            devext->dwfSmbLite &= ~SMBLITEF_SYSTEM_ON_AC;
            devext->dwfSmbLite |= dwfOnAC;
            status = SetBackLightBrightness(devext,
                                            &devext->BackLightBrightness,
                                            FALSE);
            if (!NT_SUCCESS(status))
            {
                WARNPRINT(("failed to set %s backlight brightness (status=%x).\n",
                           dwfOnAC? "AC": "DC", status));
            }
        }
    }

    EXIT(2, ("!\n"));
    return;
}       //PowerStateCallbackProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\buttons.cpp ===
/*++
    Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

    Module Name:
        buttons.cpp

    Abstract:
        This module contains all the tablet pc button functions.

    Author:
        Michael Tsang (MikeTs) 29-Sep-2000

    Environment:
        User mode

    Revision History:
--*/

#include "pch.h"

#define HOTKEY_TIMEOUT          200     //200msec
#define REPEAT_DELAY            500     //500msec
#define PAGEUPDOWN_TIMEOUT      200     //200msec
#define ALTTAB_TIMEOUT          500     //500msec

typedef struct _HOTKEYTIMER
{
    UINT_PTR      TimerID;
    BUTTON_ACTION Action;
    ULONG         dwButtonTag;
    ULONG         dwButtonState;
} HOTKEYTIMER, *PHOTKEYTIMER;

typedef struct _REPEATKEYTIMER
{
    UINT_PTR TimerID;
    UINT     uiRepeatInterval;
    INPUT    KbdInput;
} REPEATKEYTIMER, *PREPEATKEYTIMER;

HOTKEYTIMER    gHotKeyTimer = {0};
REPEATKEYTIMER gPageUpDownTimer = {0};
REPEATKEYTIMER gAltTabTimer = {0};

/*++
    @doc    INTERNAL

    @func   VOID | ProcessButtonsReport | Process a button input report.

    @parm   IN PCHAR | pBuff | Buffer containing report data.

    @rvalue None.
--*/

VOID
ProcessButtonsReport(
    IN PCHAR pBuff
    )
{
    TRACEPROC("ProcessButtonsReport", 3)
    static ULONG dwLastButtons = 0;
    static ULONG dwPendingUpButtons = 0;
    NTSTATUS status;
    ULONG ulLength;

    TRACEENTER(("(pBuff=%p)\n", pBuff));

    ulLength = gdevButtons.dwcButtons;
    status = HidP_GetButtons(HidP_Input,
                             HID_USAGE_PAGE_BUTTON,
                             0,
                             gdevButtons.pDownButtonUsages,
                             &ulLength,
                             gdevButtons.pPreParsedData,
                             pBuff,
                             gdevButtons.hidCaps.InputReportByteLength);

    if (status == HIDP_STATUS_SUCCESS)
    {
        ULONG i, dwMask;
        ULONG dwCurrentButtons = 0;
        ULONG dwChangedButtons, dwButtons;

        for (i = 0; i < ulLength; i++)
        {
            TRACEINFO(3, ("%d: %d\n", i, gdevButtons.pDownButtonUsages[i]));
            dwCurrentButtons |= 1 << (gdevButtons.pDownButtonUsages[i] - 1);
        }

        dwChangedButtons = dwCurrentButtons^dwLastButtons;
        TRACEINFO(1, ("LastButtons=%x,CurrentButtons=%x,ChangedButtons=%x,PendingUpButtons=%x\n",
                      dwLastButtons, dwCurrentButtons, dwChangedButtons,
                      dwPendingUpButtons));

        //
        // If there are any released buttons that are in the PendingUpButtons
        // list, eat them.
        //
        dwButtons = dwChangedButtons & dwPendingUpButtons & ~dwCurrentButtons;
        dwChangedButtons &= ~dwButtons;
        dwPendingUpButtons &= ~dwButtons;
        if (dwButtons)
        {
            TRACEINFO(1, ("Released PendingUpButtons=%x\n", dwButtons));
        }

        if ((gHotKeyTimer.TimerID != 0) &&
            (dwChangedButtons & gConfig.ButtonSettings.dwHotKeyButtons) &&
            (dwCurrentButtons == gConfig.ButtonSettings.dwHotKeyButtons))
        {
            //
            // One of the hotkey buttons changes state and both hotkey
            // buttons are down, so send the hotkey event.
            //
            TRACEINFO(1, ("HotKey buttons pressed, kill HotKey timer.\n"));
            KillTimer(NULL, gHotKeyTimer.TimerID);
            gHotKeyTimer.TimerID = 0;

            SetEvent(ghHotkeyEvent);
            dwPendingUpButtons |= dwCurrentButtons;
            TRACEINFO(1, ("Detected HotKey (PendingUpButtons=%x)\n",
                          dwPendingUpButtons));
        }
        else
        {
            if ((dwCurrentButtons ^ -((long)dwCurrentButtons)) &
                dwCurrentButtons)
            {
                //
                // More than 1 buttons pressed, ignored the new buttons
                // pressed.
                //
                TRACEINFO(1, ("More than 1 buttons pressed (NewPressedButtons=%x)\n",
                              dwChangedButtons & dwCurrentButtons));
                dwPendingUpButtons |= dwChangedButtons & dwCurrentButtons;
                dwChangedButtons &= ~(dwChangedButtons & dwCurrentButtons);
            }

            //
            // Determine which remaining buttons have changed states and do
            // corresponding actions.
            //
            for (i = 0, dwMask = 1; i < NUM_BUTTONS; i++, dwMask <<= 1)
            {
                dwButtons = dwChangedButtons & dwMask;
                if (dwButtons != 0)
                {
                    if (dwButtons & gConfig.ButtonSettings.dwHotKeyButtons)
                    {
                        //
                        // One of the hotkey buttons has changed state.
                        //
                        if (dwButtons & dwCurrentButtons)
                        {
                            //
                            // It's a hotkey button down, we delay the
                            // action for 200msec.  If the second hotkey
                            // button is pressed within the period, it is
                            // a hotkey, otherwise the action will be
                            // performed when the timer expires.
                            //
                            TRACEINFO(1, ("HotKey button is pressed (Button=%x)\n",
                                          dwButtons));
                            gHotKeyTimer.Action =
                                gConfig.ButtonSettings.ButtonMap[i];
                            gHotKeyTimer.dwButtonTag = dwButtons;
                            gHotKeyTimer.dwButtonState = dwCurrentButtons &
                                                         dwButtons;
                            gHotKeyTimer.TimerID = SetTimer(NULL,
                                                            0,
                                                            HOTKEY_TIMEOUT,
                                                            ButtonTimerProc);
                            TRACEASSERT(gHotKeyTimer.TimerID);
                            if (gHotKeyTimer.TimerID == 0)
                            {
                                TABSRVERR(("Failed to set hotkey timer (err=%d).\n",
                                           GetLastError()));
                            }
                        }
                        else
                        {
                            //
                            // The hotkey button is released.
                            //
                            if (gHotKeyTimer.TimerID != 0)
                            {
                                //
                                // It is released before timeout, so kill
                                // the timer and perform the delayed down
                                // action.
                                //
                                KillTimer(NULL, gHotKeyTimer.TimerID);
                                gHotKeyTimer.TimerID = 0;
                                TRACEINFO(1, ("HotKey button released before timeout (Button=%x)\n",
                                              dwButtons));
                                DoButtonAction(gHotKeyTimer.Action,
                                               gHotKeyTimer.dwButtonTag,
                                               gHotKeyTimer.dwButtonState != 0);
                            }
                            //
                            // Do the HotKey button release.
                            //
                            TRACEINFO(1, ("HotKey button released (Button=%x)\n",
                                          dwButtons));
                            DoButtonAction(gConfig.ButtonSettings.ButtonMap[i],
                                           dwButtons,
                                           FALSE);
                        }
                    }
                    else
                    {
                        //
                        // Not a hotkey button, do the normal press/release
                        // action.
                        //
                        TRACEINFO(1, ("Non HotKey buttons (Button=%x,Current=%x)\n",
                                      dwButtons, dwCurrentButtons));
                        DoButtonAction(gConfig.ButtonSettings.ButtonMap[i],
                                       dwButtons,
                                       (dwCurrentButtons & dwButtons) != 0);
                    }
                }
            }
        }
        dwLastButtons = dwCurrentButtons;
    }
    else
    {
        TABSRVERR(("failed getting data (status=%d)\n", status));
    }

    TRACEEXIT(("!\n"));
    return;
}       //ProcessButtonsReport

/*++
    @doc    INTERNAL

    @func   VOID | ButtonTimerProc | Button timer proc.

    @parm   IN HWND | hwnd | Not used.
    @parm   IN UINT | uMsg | WM_TIMER.
    @parm   IN UINT_PTR | idEvent | Not used.
    @parm   IN DWORD | dwTime | Not used.

    @rvalue None.
--*/

VOID
CALLBACK
ButtonTimerProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN UINT_PTR idEvent,
    IN DWORD    dwTime
    )
{
    TRACEPROC("ButtonTimerProc", 3)

    TRACEENTER(("hwnd=%x,Msg=%s,idEvent=%x,Time=%x)\n",
                hwnd, LookupName(uMsg, WMMsgNames), idEvent, dwTime));
    TRACEASSERT(idEvent != 0);

    KillTimer(NULL, idEvent);
    if (idEvent == gHotKeyTimer.TimerID)
    {
        //
        // HotKey timer times out.  So we will do the pending action.
        //
        gHotKeyTimer.TimerID = 0;
        TRACEINFO(3, ("HotKey timer expired, do pending action (Action=%d,Button=%x,fDown=%x).\n",
                      gHotKeyTimer.Action, gHotKeyTimer.dwButtonTag,
                      gHotKeyTimer.dwButtonState != 0));
        DoButtonAction(gHotKeyTimer.Action,
                       gHotKeyTimer.dwButtonTag,
                       gHotKeyTimer.dwButtonState != 0);
    }
    else if (idEvent == gPageUpDownTimer.TimerID)
    {
        TRACEINFO(3, ("Page Up/Down timer expired, send another Page Up/Down.\n"));
        SendInput(1, &gPageUpDownTimer.KbdInput, sizeof(INPUT));
        gPageUpDownTimer.TimerID = SetTimer(NULL,
                                            0,
                                            gPageUpDownTimer.uiRepeatInterval,
                                            ButtonTimerProc);
    }
    else if (idEvent == gAltTabTimer.TimerID)
    {
        TRACEINFO(3, ("Alt-tab timer expired, send another tab.\n"));
        SendInput(1, &gAltTabTimer.KbdInput, sizeof(INPUT));
        gAltTabTimer.TimerID = SetTimer(NULL,
                                        0,
                                        gAltTabTimer.uiRepeatInterval,
                                        ButtonTimerProc);
    }
    else
    {
        TABSRVERR(("Unknown timer (TimerID=%x).\n", idEvent));
    }

    TRACEEXIT(("!\n"));
    return;
}       //ButtonTimerProc

/*++
    @doc    INTERNAL

    @func   BOOL | DoButtonAction | Do the button action.

    @parm   IN BUTTON_ACTION | Action | Button action to be performed.
    @parm   IN DWORD | dwButtonTag | Specifies which button.
    @parm   IN BOOL | fButtonDown | TRUE if the button is in down state.

    @rvalue SUCCESS | Return TRUE.
    @rvalue FAILURE | Return FALSE.
--*/

BOOL
DoButtonAction(
    IN BUTTON_ACTION Action,
    IN DWORD         dwButtonTag,
    IN BOOL          fButtonDown
    )
{
    TRACEPROC("DoButtonAction", 2)
    BOOL rc = TRUE;
    INPUT KbdInput[2];
    WORD wVk;

    TRACEENTER(("(Action=%d,ButtonTag=%x,fDown=%x)\n",
                Action, dwButtonTag, fButtonDown));

    memset(KbdInput, 0, sizeof(KbdInput));
    KbdInput[0].type = INPUT_KEYBOARD;
    KbdInput[1].type = INPUT_KEYBOARD;
    switch (Action)
    {
        case InvokeNoteBook:
            if (!fButtonDown)
            {
                TRACEINFO(1, ("Invoke NoteBook on button down (Button=%x)\n",
                              dwButtonTag));
                rc = DoInvokeNoteBook();
            }
            break;

        case PageUp:
            wVk = VK_PRIOR;
            TRACEINFO(1, ("PageUp (Button=%x,fDown=%x)\n",
                          dwButtonTag, fButtonDown));
            goto PageUpDownCommon;

        case PageDown:
            wVk = VK_NEXT;
            TRACEINFO(1, ("PageDown (Button=%x,fDown=%x)\n",
                          dwButtonTag, fButtonDown));

        PageUpDownCommon:
            if (fButtonDown)
            {
                if (gPageUpDownTimer.TimerID != 0)
                {
                    //
                    // There is an existing Page Up/Down timer, cancel it.
                    //
                    KillTimer(NULL, gPageUpDownTimer.TimerID);
                    gPageUpDownTimer.TimerID = 0;
                }

                //
                // Send PageUpDown-down.
                //
                memset(&gPageUpDownTimer, 0, sizeof(gPageUpDownTimer));
                gPageUpDownTimer.uiRepeatInterval = PAGEUPDOWN_TIMEOUT;
                gPageUpDownTimer.KbdInput.type = INPUT_KEYBOARD;
                gPageUpDownTimer.KbdInput.ki.wVk = wVk;
                SendInput(1, &gPageUpDownTimer.KbdInput, sizeof(INPUT));

                gPageUpDownTimer.TimerID = SetTimer(NULL,
                                                    0,
                                                    REPEAT_DELAY,
                                                    ButtonTimerProc);
                TRACEASSERT(gPageUpDownTimer.TimerID);
                if (gPageUpDownTimer.TimerID == 0)
                {
                    TABSRVERR(("Failed to set Page Up/Down timer (err=%d).\n",
                               GetLastError()));
                    rc = FALSE;
                }
            }
            else
            {
                TRACEASSERT(gPageUpDownTimer.TimerID != 0);
                KillTimer(NULL, gPageUpDownTimer.TimerID);
                gPageUpDownTimer.TimerID = 0;
                //
                // Send PageUpDown-up.
                //
                KbdInput[0].ki.wVk = wVk;
                KbdInput[0].ki.dwFlags = KEYEVENTF_KEYUP;
                SendInput(1, KbdInput, sizeof(INPUT));
            }
            break;

        case AltTab:
            if (fButtonDown)
            {
                TRACEINFO(1, ("AltTab down (Button=%x)\n", dwButtonTag));
                TRACEASSERT(gAltTabTimer.TimerID == 0);
                //
                // Send Alt-down, Tab-down.
                //
                KbdInput[0].ki.wVk = VK_MENU;
                KbdInput[1].ki.wVk = VK_TAB;
                SendInput(2, KbdInput, sizeof(INPUT));


                memset(&gAltTabTimer, 0, sizeof(gAltTabTimer));
                gAltTabTimer.uiRepeatInterval = ALTTAB_TIMEOUT;
                gAltTabTimer.KbdInput.type = INPUT_KEYBOARD;
                gAltTabTimer.KbdInput.ki.wVk = VK_TAB;
                gAltTabTimer.TimerID = SetTimer(NULL,
                                                0,
                                                REPEAT_DELAY,
                                                ButtonTimerProc);
                TRACEASSERT(gAltTabTimer.TimerID);
                if (gAltTabTimer.TimerID == 0)
                {
                    TABSRVERR(("Failed to set Alt-Tab timer (err=%d).\n",
                               GetLastError()));
                    rc = FALSE;
                }
            }
            else
            {
                TRACEINFO(1, ("AltTab up (Button=%x)\n", dwButtonTag));
                TRACEASSERT(gAltTabTimer.TimerID != 0);
                KillTimer(NULL, gAltTabTimer.TimerID);
                gAltTabTimer.TimerID = 0;
                //
                // Send Tab-up, Alt-up.
                //
                KbdInput[0].ki.wVk = VK_TAB;
                KbdInput[0].ki.dwFlags = KEYEVENTF_KEYUP;
                KbdInput[1].ki.wVk = VK_MENU;
                KbdInput[1].ki.dwFlags = KEYEVENTF_KEYUP;
                SendInput(2, KbdInput, sizeof(INPUT));
            }
            break;

        case AltEsc:
            if (fButtonDown)
            {
                //
                // Send Alt-down, Esc-down.
                //
                TRACEINFO(1, ("AltEsc down (Button=%x)\n", dwButtonTag));
                KbdInput[0].ki.wVk = VK_MENU;
                KbdInput[1].ki.wVk = VK_ESCAPE;
                SendInput(2, KbdInput, sizeof(INPUT));
            }
            else
            {
                //
                // Send Esc-up, Alt-up.
                //
                TRACEINFO(1, ("AltEsc up (Button=%x)\n", dwButtonTag));
                KbdInput[0].ki.wVk = VK_ESCAPE;
                KbdInput[0].ki.dwFlags = KEYEVENTF_KEYUP;
                KbdInput[1].ki.wVk = VK_MENU;
                KbdInput[1].ki.dwFlags = KEYEVENTF_KEYUP;
                SendInput(2, KbdInput, sizeof(INPUT));
            }
            break;

        case Enter:
            if (fButtonDown)
            {
                //
                // Send Enter-down.
                //
                TRACEINFO(1, ("Return down (Button=%x)\n", dwButtonTag));
                KbdInput[0].ki.wVk = VK_RETURN;
                SendInput(1, KbdInput, sizeof(INPUT));
            }
            else
            {
                //
                // Send Enter-up.
                //
                TRACEINFO(1, ("Return up (Button=%x)\n", dwButtonTag));
                KbdInput[0].ki.wVk = VK_RETURN;
                KbdInput[0].ki.dwFlags = KEYEVENTF_KEYUP;
                SendInput(1, KbdInput, sizeof(INPUT));
            }
            break;

        case Esc:
            if (fButtonDown)
            {
                //
                // Send Esc-down.
                //
                TRACEINFO(1, ("Escape down (Button=%x)\n", dwButtonTag));
                KbdInput[0].ki.wVk = VK_ESCAPE;
                SendInput(1, KbdInput, sizeof(INPUT));
            }
            else
            {
                //
                // Send Esc-up.
                //
                TRACEINFO(1, ("Escape up (Button=%x)\n", dwButtonTag));
                KbdInput[0].ki.wVk = VK_ESCAPE;
                KbdInput[0].ki.dwFlags = KEYEVENTF_KEYUP;
                SendInput(1, KbdInput, sizeof(INPUT));
            }
            break;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //DoButtonAction

/*++
    @doc    INTERNAL

    @func   BOOL | DoInvokeNoteBook | Invoke the Notebook app.

    @parm   None.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
DoInvokeNoteBook(
    VOID
    )
{
    TRACEPROC("DoInvokeNoteBook", 3)
    BOOL rc = FALSE;
    PTSTHREAD pThread = FindThread(TSF_BUTTONTHREAD);

    TRACEENTER(("()\n"));

    if (!(pThread->dwfThread & THREADF_DESKTOP_WINLOGON))
    {
        TCHAR szNoteBook[MAX_PATH];
        DWORD dwcb = sizeof(szNoteBook);
        HRESULT hr;

        hr = GetRegValueString(HKEY_LOCAL_MACHINE,
                               TEXT("SOFTWARE\\Microsoft\\MSNotebook"),
                               TEXT("InstallDir"),
                               szNoteBook,
                               &dwcb);

        if (SUCCEEDED(hr))
        {
            lstrcat(szNoteBook, "NoteBook.exe");
            rc = RunProcessAsUser(szNoteBook);
        }
        else
        {
            TABSRVERR(("Failed to read MSNoteBook install path from the registry (hr=%d).\n",
                       hr));
        }
    }
    else
    {
        TRACEWARN(("Cannot run NoteBook app. in WinLogon desktop.\n"));
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //DoInvokeNoteBook

/*++
    @doc    INTERNAL

    @func   VOID | UpdateButtonRepeatRate | Update button repeat rate.

    @parm   None.

    @rvalue None.
--*/

VOID
UpdateButtonRepeatRate(
    VOID
    )
{
    TRACEPROC("UpdateButtonRepeatRate", 3)
    static DWORD KbdDelayTime[] = {1000, 750, 500, 250};
    int  iKbdDelay;
    int  iKbdSpeed;

    TRACEENTER(("()\n"));
#if 0
    if (!SystemParametersInfo(SPI_GETKEYBOARDDELAY, 0, &iKbdDelay, 0))
    {
        TRACEWARN(("Get keyboard delay failed (err=%d).\n", GetLastError()));
    }
    else if (!SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, &iKbdSpeed, 0))
    {
        TRACEWARN(("Get keyboard speed failed (err=%d).\n", GetLastError()));
    }
    else
    {
        TRACEASSERT((iKbdDelay >= 0) && (iKbdDelay <= 3));
        gdwKbdDelayTime = KbdDelayTime[iKbdDelay];
        gdwKbdRepeatTime =
    }
#endif

    TRACEEXIT(("!\n"));
    return;
}       //UpdateButtonRepeatRate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\digidev.cpp ===
/*++
    Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

    Module Name:
        digidev.cpp

    Abstract:
        This module contains all the digitizer functions.

    Author:
        Michael Tsang (MikeTs) 01-Jun-2000

    Environment:
        User mode

    Revision History:
--*/

#include "pch.h"

/*++
    @doc    INTERNAL

    @func   BOOL | GetMinMax | Get the logical min & max for a report values.

    @parm   IN USAGE | UsagePage | Specifies the UsagePage of the report.
    @parm   IN USAGE | Usage | Specifies the Usage of the report.
    @parm   OUT PULONG | pulMin | To hold the min value.
    @parm   OUT PULONG | pulMax | To hold the max value.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
GetMinMax(
    IN  USAGE  UsagePage,
    IN  USAGE  Usage,
    OUT PULONG pulMin,
    OUT PULONG pulMax
    )
{
    TRACEPROC("GetMinMax", 3)
    BOOL rc = FALSE;
    NTSTATUS status;
    HIDP_VALUE_CAPS ValueCaps;
    USHORT cValueCaps = 1;

    TRACEENTER(("(UsagePage=%x,Usage=%x,pulMin=%p,pulMax=%p)\n",
                UsagePage, Usage, pulMin, pulMax));

    status = HidP_GetSpecificValueCaps(HidP_Input,
                                       UsagePage,
                                       0,
                                       Usage,
                                       &ValueCaps,
                                       &cValueCaps,
                                       gdevDigitizer.pPreParsedData);

    if ((status == HIDP_STATUS_SUCCESS) && (cValueCaps == 1))
    {
        if ((ValueCaps.LogicalMin >= 0) &&
            (ValueCaps.LogicalMax > ValueCaps.LogicalMin))
        {
            *pulMin = ValueCaps.LogicalMin;
            *pulMax = ValueCaps.LogicalMax;
            rc = TRUE;
        }
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //GetMinMax

/*++
    @doc    INTERNAL

    @func   VOID | ProcessDigitizerReport | Process a digitizer input report.

    @parm   IN PCHAR | pBuff | Buffer containing report data.

    @rvalue None.
--*/

VOID
ProcessDigitizerReport(
    IN PCHAR pBuff
    )
{
    TRACEPROC("ProcessDigitizerReport", 5)
    NTSTATUS StatusX, StatusY, StatusBtn;
    DWORD dwCurrentTime;
    ULONG x, y;
    ULONG ulLength;

    TRACEENTER(("(pBuff=%p)\n", pBuff));

    dwCurrentTime = GetTickCount();
    StatusX = HidP_GetUsageValue(HidP_Input,
                                 HID_USAGE_PAGE_GENERIC,
                                 0,
                                 HID_USAGE_GENERIC_X,
                                 &x,
                                 gdevDigitizer.pPreParsedData,
                                 pBuff,
                                 gdevDigitizer.hidCaps.InputReportByteLength);

    StatusY = HidP_GetUsageValue(HidP_Input,
                                 HID_USAGE_PAGE_GENERIC,
                                 0,
                                 HID_USAGE_GENERIC_Y,
                                 &y,
                                 gdevDigitizer.pPreParsedData,
                                 pBuff,
                                 gdevDigitizer.hidCaps.InputReportByteLength);

    ulLength = gdevDigitizer.dwcButtons;// ulLength == max # possible buttons
    StatusBtn = HidP_GetButtons(HidP_Input,
                                HID_USAGE_PAGE_DIGITIZER,
                                0,
                                gdevDigitizer.pDownButtonUsages,
                                &ulLength,
                                gdevDigitizer.pPreParsedData,
                                pBuff,
                                gdevDigitizer.hidCaps.InputReportByteLength);

    if ((StatusX == HIDP_STATUS_SUCCESS) &&
        (StatusY == HIDP_STATUS_SUCCESS) &&
        (StatusBtn == HIDP_STATUS_SUCCESS))
    {
        ULONG i;
        WORD wCurrentButtons = 0;

        for (i = 0; i < ulLength; i++)
        {
            if (gdevDigitizer.pDownButtonUsages[i] ==
                HID_USAGE_DIGITIZER_TIP_SWITCH)
            {
                wCurrentButtons |= TIP_SWITCH;
            }
            else if (gdevDigitizer.pDownButtonUsages[i] ==
                     HID_USAGE_DIGITIZER_BARREL_SWITCH)
            {
                wCurrentButtons |= BARREL_SWITCH;
            }
        }

        if ((gdwPenState == PENSTATE_PENDOWN) &&
            (dwCurrentTime - gdwPenDownTime >
             (DWORD)gConfig.GestureSettings.iPressHoldTime))
        {
            //
            // PressHold timer has expired, simulate a right down.
            //
            PressHoldMode(TRUE);
        }
        else if ((gdwPenState == PENSTATE_PRESSHOLD) &&
                 (dwCurrentTime - gdwPenDownTime >
                  (DWORD)gConfig.GestureSettings.iPressHoldTime +
                         gConfig.GestureSettings.iCancelPressHoldTime))
        {
            TRACEINFO(3, ("Simulate a left-down on CancelPressHold timeout.\n"));
            gdwPenState = PENSTATE_NORMAL;
            SetPressHoldCursor(FALSE);
            gInput.mi.dwFlags = MOUSEEVENTF_ABSOLUTE |
                                MOUSEEVENTF_MOVE |
                                SWAPBUTTONS(giButtonsSwapped,
                                            MOUSEEVENTF_LEFTDOWN,
                                            MOUSEEVENTF_RIGHTDOWN);
            gInput.mi.dx = glPenDownX;
            gInput.mi.dy = glPenDownY;
            SendInput(1, &gInput, sizeof(INPUT));
        }
        else if ((gdwPenState == PENSTATE_LEFTUP_PENDING) &&
                 (dwCurrentTime - gdwPenUpTime > TIMEOUT_LEFTCLICK))
        {
            //
            // Left up timer has expired, simulate a left up.
            //
            TRACEINFO(3, ("Simulate a left-up on timeout.\n"));
            gdwPenState = PENSTATE_NORMAL;
            gInput.mi.dwFlags = MOUSEEVENTF_ABSOLUTE |
                                MOUSEEVENTF_MOVE |
                                SWAPBUTTONS(giButtonsSwapped,
                                            MOUSEEVENTF_LEFTUP,
                                            MOUSEEVENTF_RIGHTUP);
            gInput.mi.dx = glPenUpX;
            gInput.mi.dy = glPenUpY;
            SendInput(1, &gInput, sizeof(INPUT));
        }

        //
        // If the report is the same as last, skip it.
        //
        if ((x != gLastRawDigiReport.wX) ||
            (y != gLastRawDigiReport.wY) ||
            (wCurrentButtons != gLastRawDigiReport.wButtonState))
        {
            //
            // Generate mouse movement info.
            //
            if (gdwfTabSrv & TSF_HAS_LINEAR_MAP)
            {
                gInput.mi.dx = x;
                gInput.mi.dy = y;
                AdjustLinearity((PUSHORT)&gInput.mi.dx, (PUSHORT)&gInput.mi.dy);
            }
            else
            {
                ULONG t;

                // Since we treat the digitizer as an 'absolute' pointing
                // device, both the X/Y coordinates must be scaled to a range
                // of 0 - 65535.
                // (((t = x - gdwMinX) << 16) - t)  == ((x - gdwMinX) * 65535)
                // In non-raw mode, the pen driver should already be scaled to
                // the range of 0-65535, but in raw mode, we still have to do
                // this work.

                gInput.mi.dx = (x >= gdwMaxX)?
                                MAX_NORMALIZED_X:       // too high
                               ((x <= gdwMinX)?
                                0:                      // too low
                                ((((t = x - gdwMinX) << 16) - t) / gdwRngX));

                gInput.mi.dy = (y >= gdwMaxY)?
                                MAX_NORMALIZED_Y :      // too high
                               ((y <= gdwMinY)?
                                0:                      // too low
                                ((((t = y - gdwMinY) << 16) - t) / gdwRngY));
            }

            gInput.mi.dx = (((gInput.mi.dx > glLongOffset)?
                             gInput.mi.dx - glLongOffset: 0)*NUM_PIXELS_LONG)/
                           max(gcxPrimary, gcyPrimary);
            gInput.mi.dy = (((gInput.mi.dy > glShortOffset)?
                             gInput.mi.dy - glShortOffset: 0)*NUM_PIXELS_SHORT)/
                           min(gcxPrimary, gcyPrimary);

            if (gdwfTabSrv & TSF_PORTRAIT_MODE)
            {
                LONG temp;

                if (gdwfTabSrv & TSF_PORTRAIT_MODE2)
                {
                    temp = gInput.mi.dx;
                    gInput.mi.dx = MAX_NORMALIZED_Y - gInput.mi.dy;
                }
                else
                {
                    temp = MAX_NORMALIZED_X - gInput.mi.dx;
                    gInput.mi.dx = gInput.mi.dy;
                }
                gInput.mi.dy = temp;
            }

            //
            // Pen tilt compensation.
            //
            gInput.mi.dx += gConfig.PenTilt.dx;
            gInput.mi.dy += gConfig.PenTilt.dy;

            NotifyClient(RawPtEvent,
                         wCurrentButtons,
                         (y << 16) | (x & 0xffff));

            ProcessMouseEvent(gInput.mi.dx,
                              gInput.mi.dy,
                              wCurrentButtons,
                              dwCurrentTime,
                              FALSE);

#ifdef DRAW_INK
            if (ghwndDrawInk != NULL)
            {
                static BOOL fPenDown = FALSE;
                static POINT ptPrev = {0, 0};
                static HPEN hpen = NULL;
                HDC hdc;

                if (!(gwLastButtons & TIP_SWITCH) &&
                     (wCurrentButtons & TIP_SWITCH))
                {
                    hpen = CreatePen(PS_SOLID, 0, RGB(255, 255, 255));
                    fPenDown = TRUE;
                    ptPrev.x = NORMAL_TO_SCREEN_X(gInput.mi.dx);
                    ptPrev.y = NORMAL_TO_SCREEN_Y(gInput.mi.dy);
                }
                else if ((gwLastButtons & TIP_SWITCH) &&
                         !(wCurrentButtons & TIP_SWITCH))
                {
                    DeleteObject(hpen);
                    hpen = NULL;
                    fPenDown = FALSE;
                }
                else if (fPenDown)
                {
                    HPEN hpenOld;
                    POINT pt;

                    pt.x = NORMAL_TO_SCREEN_X(gInput.mi.dx);
                    pt.y = NORMAL_TO_SCREEN_Y(gInput.mi.dy);
                    hdc = GetDC(ghwndDrawInk);
                    hpenOld = (HPEN)SelectObject(hdc, hpen);
                    MoveToEx(hdc, ptPrev.x, ptPrev.y, NULL);
                    LineTo(hdc, pt.x, pt.y);
                    SelectObject(hdc, hpenOld);
                    ReleaseDC(ghwndDrawInk, hdc);
                    ptPrev = pt;
                }
            }
#endif

            gwLastButtons = wCurrentButtons;
            gLastRawDigiReport.wX = (WORD)x;
            gLastRawDigiReport.wY = (WORD)y;
            gLastRawDigiReport.wButtonState = wCurrentButtons;
            gLastRawDigiReport.dwTime = dwCurrentTime;
        }
    }
    else
    {
        TABSRVERR(("failed getting data (StatusX=%d,StatusY=%d,StatusBtn=%d,Len=%d)\n",
                   StatusX, StatusY, StatusBtn, ulLength));
    }

    TRACEEXIT(("!\n"));
    return;
}       //ProcessDigitizerReport

/*++
    @doc    INTERNAL

    @func   VOID | AdjustLinearity | Adjust data according to the linearity map.

    @parm   IN OUT PUSHORT | pwX | Points to the X data.
    @parm   IN OUT PUSHORT | pwY | Points to the Y data.

    @rvalue None.
--*/

VOID
AdjustLinearity(
    IN OUT PUSHORT pwX,
    IN OUT PUSHORT pwY
    )
{
    TRACEPROC("AdjustLinearity", 5)
    int ix, iy, dix, diy, n;
    DIGIRECT Rect;
    LONG x, y;

    TRACEENTER(("(x=%d,y=%d)\n", *pwX, *pwY));

    for (n = 0, ix = gixIndex, iy = giyIndex; ; ix += dix, iy += diy, n++)
    {
        //
        // Safe guard from never-ending loop.
        //
        TRACEASSERT(n <= NUM_LINEAR_XPTS + NUM_LINEAR_YPTS);
        if (n > NUM_LINEAR_XPTS + NUM_LINEAR_YPTS)
        {
            TABSRVERR(("AdjustLinearity caught in a loop.\n"));
            break;
        }

        if ((*pwX < gConfig.LinearityMap.Data[iy][ix].wDigiPtX) &&
            (*pwX < gConfig.LinearityMap.Data[iy+1][ix].wDigiPtX))
        {
            dix = ix? -1: 0;
        }
        else if ((*pwX >= gConfig.LinearityMap.Data[iy][ix+1].wDigiPtX) &&
                 (*pwX >= gConfig.LinearityMap.Data[iy+1][ix+1].wDigiPtX))
        {
            dix = (ix + 2 < NUM_LINEAR_XPTS)? 1: 0;
        }
        else
        {
            dix = 0;
        }

        if ((*pwY < gConfig.LinearityMap.Data[iy][ix].wDigiPtY) &&
            (*pwY < gConfig.LinearityMap.Data[iy][ix+1].wDigiPtY))
        {
            diy = iy? -1: 0;
        }
        else if ((*pwY >= gConfig.LinearityMap.Data[iy+1][ix].wDigiPtY) &&
                 (*pwY >= gConfig.LinearityMap.Data[iy+1][ix+1].wDigiPtY))
        {
            diy = (iy + 2 < NUM_LINEAR_YPTS)? 1: 0;
        }
        else
        {
            diy = 0;
        }
        //
        // If delta-X and delta-Y are both zeros, we found the containing
        // rectangle.
        //
        if ((dix == 0) && (diy == 0))
        {
            break;
        }
    }

    TRACEASSERT(gConfig.LinearityMap.Data[iy+1][ix].wDigiPtY -
                gConfig.LinearityMap.Data[iy][ix].wDigiPtY);
    TRACEASSERT(gConfig.LinearityMap.Data[iy+1][ix+1].wDigiPtY -
                gConfig.LinearityMap.Data[iy][ix+1].wDigiPtY);
    Rect.wx0 = gConfig.LinearityMap.Data[iy][ix].wDigiPtX +
               ((*pwY - gConfig.LinearityMap.Data[iy][ix].wDigiPtY)*
                (gConfig.LinearityMap.Data[iy+1][ix].wDigiPtX -
                 gConfig.LinearityMap.Data[iy][ix].wDigiPtX))/
               (gConfig.LinearityMap.Data[iy+1][ix].wDigiPtY -
                gConfig.LinearityMap.Data[iy][ix].wDigiPtY);
    Rect.wx1 = gConfig.LinearityMap.Data[iy][ix+1].wDigiPtX +
               ((*pwY - gConfig.LinearityMap.Data[iy][ix+1].wDigiPtY)*
                (gConfig.LinearityMap.Data[iy+1][ix+1].wDigiPtX -
                 gConfig.LinearityMap.Data[iy][ix+1].wDigiPtX))/
               (gConfig.LinearityMap.Data[iy+1][ix+1].wDigiPtY -
                gConfig.LinearityMap.Data[iy][ix+1].wDigiPtY);

    TRACEASSERT(gConfig.LinearityMap.Data[iy][ix+1].wDigiPtX -
                gConfig.LinearityMap.Data[iy][ix].wDigiPtX);
    TRACEASSERT(gConfig.LinearityMap.Data[iy+1][ix+1].wDigiPtX -
                gConfig.LinearityMap.Data[iy+1][ix].wDigiPtX);
    Rect.wy0 = gConfig.LinearityMap.Data[iy][ix].wDigiPtY +
               ((*pwX - gConfig.LinearityMap.Data[iy][ix].wDigiPtX)*
                (gConfig.LinearityMap.Data[iy][ix+1].wDigiPtY -
                 gConfig.LinearityMap.Data[iy][ix].wDigiPtY))/
               (gConfig.LinearityMap.Data[iy][ix+1].wDigiPtX -
                gConfig.LinearityMap.Data[iy][ix].wDigiPtX);
    Rect.wy1 = gConfig.LinearityMap.Data[iy+1][ix].wDigiPtY +
               ((*pwX - gConfig.LinearityMap.Data[iy+1][ix].wDigiPtX)*
                (gConfig.LinearityMap.Data[iy+1][ix+1].wDigiPtY -
                 gConfig.LinearityMap.Data[iy+1][ix].wDigiPtY))/
               (gConfig.LinearityMap.Data[iy+1][ix+1].wDigiPtX -
                gConfig.LinearityMap.Data[iy+1][ix].wDigiPtX);

    //
    // Remember the upper-left corner of the containing rectangle so that
    // we will start with this rectangle the next time.
    //
    gixIndex = ix;
    giyIndex = iy;

    //
    // Calculate the adjustment:
    // x = x0Ref + (xDigi - x0Digi)*(x1Ref - x0Ref)/(x1Digi - x0Digi)
    // y = y0Ref + (yDigi - y0Digi)*(y1Ref - y0Ref)/(y1Digi - y1Digi)
    //
    TRACEASSERT((Rect.wx1 - Rect.wx0) != 0);
    TRACEASSERT((Rect.wy1 - Rect.wy0) != 0);
    x = gConfig.LinearityMap.Data[iy][ix].wRefPtX +
        ((*pwX - Rect.wx0)*
         (gConfig.LinearityMap.Data[iy][ix + 1].wRefPtX -
          gConfig.LinearityMap.Data[iy][ix].wRefPtX))/
        (Rect.wx1 - Rect.wx0);
    *pwX = (USHORT)((x < 0)? 0:
                    (x > MAX_NORMALIZED_X)? MAX_NORMALIZED_X: x);
    y = gConfig.LinearityMap.Data[iy][ix].wRefPtY +
        ((*pwY - Rect.wy0)*
         (gConfig.LinearityMap.Data[iy + 1][ix].wRefPtY -
          gConfig.LinearityMap.Data[iy][ix].wRefPtY))/
        (Rect.wy1 - Rect.wy0);
    *pwY = (USHORT)((y < 0)? 0:
                    (y > MAX_NORMALIZED_Y)? MAX_NORMALIZED_Y: y);

    TRACEEXIT(("!(x=%d,y=%d)\n", *pwX, *pwY));
    return;
}       //AdjustLinearity

/*++
    @doc    INTERNAL

    @func   LRESULT | ProcessMouseEvent | Process the mouse event.

    @parm   IN LONG | x | Current X.
    @parm   IN LONG | y | Current Y.
    @parm   IN WORD | wButtons | Current buttons state.
    @parm   IN DWORD | dwTime | Current time.
    @parm   IN BOOL | fLowLevelMouse | TRUE if called by LowLevelMouseProc.

    @rvalue SUCCESS | Returns non-zero to eat the mouse event.
    @rvalue FAILURE | Returns 0 to pass along the event to next handler.
--*/

LRESULT
ProcessMouseEvent(
    IN     LONG  x,
    IN     LONG  y,
    IN     WORD  wButtons,
    IN     DWORD dwTime,
    IN     BOOL  fLowLevelMouse
    )
{
    TRACEPROC("ProcessMouseEvent", 5)
    LRESULT rc = 0;
    DWORD dwEvent;

    TRACEENTER(("(x=%d,y=%d,Buttons=%x,Time=%d,fLLMouse=%x)\n",
                x, y, wButtons, dwTime, fLowLevelMouse));

    gInput.mi.dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
    if (fLowLevelMouse)
    {
        gInput.mi.dwFlags |= MOUSEEVENTF_VIRTUALDESK;
    }

    // Has the tip switch changed state?
    if (((gwLastButtons ^ wButtons) & TIP_SWITCH) != 0)
    {
        if (wButtons & TIP_SWITCH)
        {
            //
            // Tip switch is down.
            //
            if (gdwPenState == PENSTATE_LEFTUP_PENDING)
            {
                if (fLowLevelMouse)
                {
                    KillTimer(ghwndMouse, TIMERID_PRESSHOLD);
                }
                TRACEINFO(3, ("Simulate a left up on pen down.\n"));
                gdwPenState = PENSTATE_NORMAL;
                dwEvent = SWAPBUTTONS(giButtonsSwapped,
                                      MOUSEEVENTF_LEFTUP,
                                      MOUSEEVENTF_RIGHTUP);
                gInput.mi.dwFlags |= dwEvent;
                gInput.mi.dx = glPenUpX;
                gInput.mi.dy = glPenUpY;
                SendInput(1, &gInput, sizeof(INPUT));
                gInput.mi.dwFlags &= ~dwEvent;
                gInput.mi.dx = x;
                gInput.mi.dy = y;
            }

            if (gConfig.GestureSettings.dwfFeatures &
                GESTURE_FEATURE_PRESSHOLD_ENABLED)
            {
                if (CanDoPressHold(x, y))
                {
                    TRACEINFO(3, ("Pendown.\n"));
                    //
                    // Press and Hold is enabled, so hold back the left down event.
                    //
                    gdwPenDownTime = dwTime;
                    glPenDownX = x;
                    glPenDownY = y;
                    gdwPenState = PENSTATE_PENDOWN;
                    if (fLowLevelMouse)
                    {
                        SetTimer(ghwndMouse,
                                 TIMERID_PRESSHOLD,
                                 gConfig.GestureSettings.iPressHoldTime,
                                 NULL);
                    }
                    rc = 1;
                }
                else
                {
                    gInput.mi.dwFlags |= SWAPBUTTONS(giButtonsSwapped,
                                                     MOUSEEVENTF_LEFTDOWN,
                                                     MOUSEEVENTF_RIGHTDOWN);
                }
            }
            else
            {
                gInput.mi.dwFlags |= SWAPBUTTONS(giButtonsSwapped,
                                                 MOUSEEVENTF_LEFTDOWN,
                                                 MOUSEEVENTF_RIGHTDOWN);
            }
        }
        else
        {
            //
            // Tip switch is up.
            //
            if (gdwPenState == PENSTATE_PENDOWN)
            {
                //
                // If we still have pendown pending, it means presshold timer
                // has not expired, so we must cancel pendown pending and
                // simulate a left click.
                //
                TRACEINFO(3, ("Simulate a left-down.\n"));
                if (fLowLevelMouse)
                {
                    KillTimer(ghwndMouse, TIMERID_PRESSHOLD);
                }
                gdwPenState = PENSTATE_LEFTUP_PENDING;

                //
                // Simulate a left down.
                //
                gInput.mi.dwFlags |= SWAPBUTTONS(giButtonsSwapped,
                                                 MOUSEEVENTF_LEFTDOWN,
                                                 MOUSEEVENTF_RIGHTDOWN);
                gInput.mi.dx = glPenDownX;
                gInput.mi.dy = glPenDownY;
                SendInput(1, &gInput, sizeof(INPUT));

                gdwPenUpTime = dwTime;
                glPenUpX = x;
                glPenUpY = y;
                rc = 1;

                if (fLowLevelMouse)
                {
                    SetTimer(ghwndMouse,
                             TIMERID_PRESSHOLD,
                             TIMEOUT_LEFTCLICK,
                             NULL);
                }
            }
            else if ((gdwPenState == PENSTATE_PRESSHOLD) ||
                     (gdwPenState == PENSTATE_RIGHTDRAG))
            {
                if (gdwPenState == PENSTATE_PRESSHOLD)
                {
                    TRACEINFO(3, ("Simulate a right click.\n"));
                    SetPressHoldCursor(FALSE);
                    dwEvent = SWAPBUTTONS(giButtonsSwapped,
                                          MOUSEEVENTF_RIGHTDOWN,
                                          MOUSEEVENTF_LEFTDOWN);
                    gInput.mi.dwFlags |= dwEvent;
                    gInput.mi.dx = glPenDownX;
                    gInput.mi.dy = glPenDownY;
                    SendInput(1, &gInput, sizeof(INPUT));

                    gInput.mi.dwFlags &= ~dwEvent;
                    gInput.mi.dx = x;
                    gInput.mi.dy = y;
                }
                else
                {
                    TRACEINFO(3, ("Simulate a right up.\n"));
                }

                gInput.mi.dwFlags |= SWAPBUTTONS(giButtonsSwapped,
                                                 MOUSEEVENTF_RIGHTUP,
                                                 MOUSEEVENTF_LEFTUP);
                if (fLowLevelMouse)
                {
                    SendInput(1, &gInput, sizeof(INPUT));
                    rc = 1;
                }
                PressHoldMode(FALSE);
            }
            else
            {
                TRACEINFO(3, ("Do a left up.\n"));
                gInput.mi.dwFlags |= SWAPBUTTONS(giButtonsSwapped,
                                                 MOUSEEVENTF_LEFTUP,
                                                 MOUSEEVENTF_RIGHTUP);
            }
        }
    }
    else if (gdwPenState == PENSTATE_PENDOWN)
    {
        int cxScreen = fLowLevelMouse? gcxScreen: gcxPrimary,
            cyScreen = fLowLevelMouse? gcyScreen: gcyPrimary;

        if ((((abs(x - glPenDownX)*cxScreen) >> 16) >
             gConfig.GestureSettings.iHoldTolerance) ||
            (((abs(y - glPenDownY)*cyScreen) >> 16) >
             gConfig.GestureSettings.iHoldTolerance))
        {
            TRACEINFO(3, ("Cancel pen down pending, simulate a left down.\n"));
            if (fLowLevelMouse)
            {
                KillTimer(ghwndMouse, 1);
            }
            gdwPenState = PENSTATE_NORMAL;
            dwEvent = SWAPBUTTONS(giButtonsSwapped,
                                  MOUSEEVENTF_LEFTDOWN,
                                  MOUSEEVENTF_RIGHTDOWN);
            gInput.mi.dwFlags |= dwEvent;
            gInput.mi.dx = glPenDownX;
            gInput.mi.dy = glPenDownY;
            SendInput(1, &gInput, sizeof(INPUT));
            gInput.mi.dwFlags &= ~dwEvent;

            gInput.mi.dx = x;
            gInput.mi.dy = y;
        }
    }
    else if (gdwPenState == PENSTATE_PRESSHOLD)
    {
        int cxScreen = fLowLevelMouse? gcxScreen: gcxPrimary,
            cyScreen = fLowLevelMouse? gcyScreen: gcyPrimary;

        if ((((abs(x - glPenDownX)*cxScreen) >> 16) >
             gConfig.GestureSettings.iHoldTolerance) ||
            (((abs(y - glPenDownY)*cyScreen) >> 16) >
             gConfig.GestureSettings.iHoldTolerance))
        {
            KillTimer(ghwndMouse, TIMERID_PRESSHOLD);
            TRACEINFO(3, ("Simulate a right drag.\n"));
            SetPressHoldCursor(FALSE);
            gdwPenState = PENSTATE_RIGHTDRAG;

            dwEvent = SWAPBUTTONS(giButtonsSwapped,
                                  MOUSEEVENTF_RIGHTDOWN,
                                  MOUSEEVENTF_LEFTDOWN);
            gInput.mi.dwFlags |= dwEvent;
            gInput.mi.dx = glPenDownX;
            gInput.mi.dy = glPenDownY;
            SendInput(1, &gInput, sizeof(INPUT));
            gInput.mi.dwFlags &= ~dwEvent;

            gInput.mi.dx = x;
            gInput.mi.dy = y;
        }
    }
    else if (gdwPenState == PENSTATE_LEFTUP_PENDING)
    {
        //
        // Eat any movement before left-up timer expires.
        //
        rc = 1;
    }

    if (gConfig.GestureSettings.dwfFeatures & GESTURE_FEATURE_RECOG_ENABLED)
    {
        RecognizeGesture(gInput.mi.dx,
                         gInput.mi.dy,
                         wButtons,
                         dwTime,
                         fLowLevelMouse);
    }

    if (gdwfTabSrv & TSF_SUPERTIP_SENDINK)
    {
        LONG x, y;

        x = NORMAL_TO_SCREEN_X(gInput.mi.dx);
        y = NORMAL_TO_SCREEN_Y(gInput.mi.dy);
        PostMessage(ghwndSuperTIPInk,
                    guimsgSuperTIPInk,
                    gInput.mi.dwFlags,
                    (LPARAM)((y << 16) | (x & 0xffff)));
        if (gInput.mi.dwFlags & MOUSEEVENTF_LEFTUP)
        {
            gdwfTabSrv &= ~TSF_SUPERTIP_SENDINK;
        }
        rc = 1;
    }
    else if (!fLowLevelMouse && (rc == 0))
    {
        // Convert digitizer input to mouse input
        SendInput(1, &gInput, sizeof(INPUT));
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //ProcessMouseEvent

/*++
    @doc    INTERNAL

    @func   VOID | PressHoldMode | Enable or disable Press and Hold mode.

    @parm   IN BOOL | fEnable | TRUE if entering Press and Hold mode.

    @rvalue None.
--*/

VOID
PressHoldMode(
    IN BOOL fEnable
    )
{
    TRACEPROC("PressHold", 3)
    TRACEENTER(("(fEnable=%x)\n", fEnable));

    if (fEnable)
    {
        TRACEINFO(3, ("Entering Press and Hold mode.\n"));

        SetPressHoldCursor(TRUE);
        gdwPenState = PENSTATE_PRESSHOLD;
    }
    else
    {
        TRACEINFO(3, ("Exiting Press and Hold mode.\n"));
        gdwPenState = PENSTATE_NORMAL;
    }

    TRACEEXIT(("!\n"));
    return;
}       //PressHoldMode

/*++
    @doc    INTERNAL

    @func   VOID | SetPressHoldCursor | Set Press and Hold cursor.

    @parm   IN BOOL | fPressHold | TRUE to set press and hold cursor.

    @rvalue None.
--*/

VOID
SetPressHoldCursor(
    IN BOOL fPressHold
    )
{
    TRACEPROC("SetPressHoldCursor", 3)
//    BOOL rc = FALSE;
//    static HCURSOR hcurPrev = NULL;
    static POINT pt = {0, 0};
    HDC hDC;
    HRGN hrgn;

    TRACEENTER(("(fPressHold=%x)\n", fPressHold));

    if (fPressHold)
    {
        GetCursorPos(&pt);
    }

    hDC = GetDC(NULL);
    TRACEASSERT(hDC != NULL);
    if (hDC != NULL)
    {
        hrgn = CreateEllipticRgn(pt.x - 10, pt.y - 10, pt.x + 10, pt.y + 10);
        TRACEASSERT(hrgn != NULL);
        if (hrgn != NULL)
        {
            InvertRgn(hDC, hrgn);
            DeleteObject(hrgn);
        }
        ReleaseDC(NULL, hDC);
    }

#if 0
    if (fPressHold)
    {
#if 0
        hcurPrev = (HCURSOR)LoadImage(NULL,
                                      MAKEINTRESOURCE(OCR_NORMAL),
                                      IMAGE_CURSOR,
                                      0,
                                      0,
                                      LR_SHARED | LR_DEFAULTSIZE);
        TRACEASSERT(hcurPrev != NULL);
#endif
        rc = SetSystemCursor(CopyCursor(ghcurPressHold), OCR_NORMAL);
        TRACEASSERT(rc == TRUE);
    }
    else
    {
#if 0
        if (hcurPrev != NULL)
        {
            SetCursor(hcurPrev);
            rc = SetSystemCursor(CopyCursor(hcurPrev), OCR_NORMAL);
            TRACEASSERT(rc == TRUE);
            hcurPrev = NULL;
        }
        else
        {
            TABSRVERR(("Failed to restore normal cursor (err=%d.\n",
                       GetLastError()));
        }
#endif
//#if 0
        LONG rcReg;
        HKEY hkUser, hkey;
        HCURSOR hcursor = NULL;

        rcReg = RegOpenCurrentUser(KEY_READ, &hkUser);
        if (rcReg == ERROR_SUCCESS)
        {
            rcReg = RegOpenKey(hkUser, REGSTR_PATH_CURSORS, &hkey);
            if (rcReg == ERROR_SUCCESS)
            {
                TCHAR szFile[MAX_PATH];
                DWORD dwcb = sizeof(szFile);

                rcReg = RegQueryValueEx(hkey,
                                        TEXT("Arrow"),
                                        NULL,
                                        NULL,
                                        (LPBYTE)szFile,
                                        &dwcb);
                if (rcReg == ERROR_SUCCESS)
                {
                    TRACEINFO(1, ("CursorArrow=%s\n", szFile));
                    hcursor = (HCURSOR)LoadImage(NULL,
                                                 MakeFileName(szFile),
                                                 IMAGE_CURSOR,
                                                 0,
                                                 0,
                                                 LR_LOADFROMFILE | LR_DEFAULTSIZE);
                }
                else
                {
                    TRACEWARN(("Failed to read Arrow registry value (rcReg=%x)\n",
                               rcReg));
                }
                RegCloseKey(hkey);
            }
            else
            {
                TRACEWARN(("Failed to open cursor registry key (rcReg=%x).\n",
                           rcReg));
            }
            RegCloseKey(hkUser);
        }
        else
        {
            TRACEWARN(("Failed to open current user (rcReg=%x).\n", rcReg));
        }

        if (hcursor == NULL)
        {
            hcursor = CopyCursor(ghcurNormal);
        }

        TRACEASSERT(hcursor != NULL);
        if (hcursor != NULL)
        {
            rc = SetSystemCursor(hcursor, OCR_NORMAL);
        }
        else
        {
            TABSRVERR(("Failed to restore system cursor.\n"));
        }
//#endif
    }
#endif

    TRACEEXIT(("!\n"));
    return;
}       //SetPressHoldCursor

/*++
    @doc    INTERNAL

    @func   LPTSTR | MakeFileName | Make a valid path by doing environment
            substitution.

    @parm   IN OUT LPTSTR | szFile | Points to the file name string.

    @rvalue returns szFile.
--*/

LPTSTR
MakeFileName(
    IN OUT LPTSTR pszFile
    )
{
    TRACEPROC("MakeFileName", 3)
    TCHAR szTmp[MAX_PATH];

    TRACEENTER(("(File=%s)\n", pszFile));

    ExpandEnvironmentStrings(pszFile, szTmp, ARRAYSIZE(szTmp));
    if ((szTmp[0] == TEXT('\\')) || (szTmp[1] == TEXT(':')))
    {
        lstrcpy(pszFile, szTmp);
    }
    else
    {
        GetSystemDirectory(pszFile, MAX_PATH);
        lstrcat(pszFile, TEXT("\\"));
        lstrcat(pszFile, szTmp);
    }

    TRACEEXIT(("! (File=%s)\n", pszFile));
    return pszFile;
}       //MakeFileName

/*++
    @doc    INTERNAL

    @func   BOOL | CanDoPressHold | Check if we can do press and hold.

    @parm   IN LONG | x | Cursor X.
    @parm   IN LONG | y | Cursor Y.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
CanDoPressHold(
    IN LONG x,
    IN LONG y
    )
{
    TRACEPROC("CanDoPressHold", 3)
    BOOL rc = TRUE;

    TRACEENTER(("(x=%d,y=%d)\n", x, y));

    if (gpISuperTip != NULL)
    {
        __try
        {
            TIP_HIT_TEST_TYPE HitType;
            POINT pt;

            pt.x = NORMAL_TO_SCREEN_X(x);
            pt.y = NORMAL_TO_SCREEN_Y(y);

            if (SUCCEEDED(gpISuperTip->HitTest(pt, &HitType)) &&
                (HitType != TIP_HT_NONE) && (HitType != TIP_HT_STAGE))
            {
                TRACEINFO(3, ("Cursor is on HitType=%x\n", HitType));
                rc = FALSE;
                if ((HitType == TIP_HT_INK_AREA) && (ghwndSuperTIPInk != NULL))
                {
                    gdwfTabSrv |= TSF_SUPERTIP_SENDINK;
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            TABSRVERR(("Exception in SuperTIP HitTest (%x).\n",
                       _exception_code()));
        }
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //CanDoPressHold
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\resource.h ===
#define IDI_SUPERTIP                    101

#define IDC_NORMAL                      102
#define IDC_PRESSHOLD                   103

#define IDR_TRAYMENU                    200

#define IDM_OPEN                        40000
#define IDM_TOGGLE_ROTATION             40001
#ifdef DEBUG
#define IDM_PROPERTIES                  40002
#endif

#define IDS_TABSRV_TITLE                1000
#define IDS_SUPERTIP_TITLE              1001
#define IDS_BALLOON_TEXT                1002
#define IDS_SHOW_SUPERTIP               1003
#define IDS_HIDE_SUPERTIP               1004
#define IDS_SCREEN_PORTRAIT             1005
#define IDS_SCREEN_LANDSCAPE            1006
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\pch.h ===
/*++
    Copyright (c) 2000  Microsoft Corporation.  All rights reserved.

    Module Name:
        pch.h

    Abstract:
        Pre-compile C header file.

    Environment:
        User mode

    Author:
        Michael Tsang (MikeTs) 19-May-2000

    Revision History:
--*/

#ifndef _PCH_H
#define _PCH_H

#define MODNAME                 "TabSrv"

#if DBG
  #define DEBUG
  #define WINTRACE
  #define ALLOW_REMOVE
  #define ALLOW_START
  #define ALLOW_STOP
  #define ALLOW_DEBUG
#endif
#define MOUSE_THREAD
//#define DRAW_INK

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define OEMRESOURCE
#include <windows.h>
#include <regstr.h>
#include <process.h>
#include <stdlib.h>
#include <wintrace.h>
#include <hidsdi.h>
#include <setupapi.h>
#include <smapi.h>
#include "tsrpc.h"
#include <guiddef.h>
#include "SuperTip_Obj.h"       //contains the COM interface definitions
#include "ITellMe.h"            //contains the COM interface definitions
#include "resource.h"

#ifdef __cplusplus
}
#endif

#include "tabsrv.h"

#endif  //ifndef _PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\supertip.cpp ===
/*++
    Copyright (c) 2000  Microsoft Corporation

    Module Name:
        supertip.cpp

    Abstract:
        This module contains the code to invoke SuperTIP.

    Author:
        Michael Tsang (MikeTs) 11-Jul-2000

    Environment:
        User mode

    Revision History:
--*/

#include "pch.h"
#include <cpl.h>
#include <shellapi.h>

static const TCHAR tstrClassName[] = TEXT("SuperTIPWndClass");
UINT  guimsgTaskbarCreated = 0;
UINT  guimsgTrayCallback = 0;
HICON ghSuperTIPIcon = NULL;
HMENU ghmenuTray = NULL;
HMENU ghmenuTrayPopup = NULL;
TCHAR gtszSuperTIPTitle[64] = {0};
TCHAR gtszBalloonTip[256] = {0};

/*++
    @doc    INTERNAL

    @func   unsigned | SuperTIPThread | SuperTIP thread.

    @parm   IN PVOID | param | Points to the thread structure.

    @rvalue Always returns 0.
--*/

unsigned __stdcall
SuperTIPThread(
    IN PVOID param
    )
{
    TRACEPROC("SuperTIPThread", 2)
    WNDCLASSEX wc;
    BOOL fSuccess = TRUE;
    HRESULT hr;

    TRACEENTER(("(pThread=%p)\n", param));
    TRACEASSERT(ghwndSuperTIP == NULL);

    guimsgTaskbarCreated = RegisterWindowMessage(TEXT("TaskbarCreated"));
    guimsgTrayCallback = RegisterWindowMessage(
                            TEXT("{D0061156-D460-4230-AF87-9E7658AB987D}"));
    TRACEINFO(1, ("TaskbarCreateMsg=%x, TrayCallbackMsg=%x\n",
                  guimsgTaskbarCreated, guimsgTrayCallback));

    LoadString(ghMod,
               IDS_SUPERTIP_TITLE,
               gtszSuperTIPTitle,
               ARRAYSIZE(gtszSuperTIPTitle));
    LoadString(ghMod,
               IDS_BALLOON_TEXT,
               gtszBalloonTip,
               ARRAYSIZE(gtszBalloonTip));
    ghSuperTIPIcon = (HICON)LoadImage(ghMod,
                                      MAKEINTRESOURCE(IDI_SUPERTIP),
                                      IMAGE_ICON,
                                      16,
                                      16,
                                      0);
    TRACEASSERT(ghSuperTIPIcon != NULL);

    memset(&wc, 0, sizeof(wc));
    wc.cbSize = sizeof(wc);
    wc.lpfnWndProc = SuperTIPWndProc;
    wc.hInstance = ghMod;
    wc.lpszClassName = tstrClassName;
    RegisterClassEx(&wc);

    //
    // Protect the majority of this thread in a try/except block to catch any
    // faults in the SuperTip object.  If there is a fault, this thread will
    // be destroyed and then recreated.
    //

    __try
    {
        while (fSuccess && !(gdwfTabSrv & TSF_TERMINATE))
        {
            if (SwitchThreadToInputDesktop((PTSTHREAD)param))
            {
                BOOL fImpersonate;

                fImpersonate = ImpersonateCurrentUser();
                CoInitialize(NULL);
                hr = CoCreateInstance(CLSID_SuperTip,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_ISuperTip,
                                      (LPVOID *)&gpISuperTip);
                if (SUCCEEDED(hr))
                {
                    hr = CoCreateInstance(CLSID_TellMe,
                                          NULL,
                                          CLSCTX_INPROC_SERVER,
                                          IID_TellMe,
                                          (LPVOID *)&gpITellMe);
                    if (FAILED(hr))
                    {
                        TABSRVERR(("CoCreateInstance on ITellMe failed (hr=%x)\n", hr));
                    }

                    ghwndSuperTIP = CreateWindow(tstrClassName,
                                                 tstrClassName,
                                                 WS_POPUP,
                                                 CW_USEDEFAULT,
                                                 0,
                                                 CW_USEDEFAULT,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 ghMod,
                                                 0);

                    if (ghwndSuperTIP != NULL)
                    {
                        BOOL rc;
                        MSG msg;

                        PostMessage(ghwndSuperTIP, WM_SUPERTIP_INIT, 0, 0);

                        //
                        // Pump messages for our window until it is destroyed.
                        //
                        ((PTSTHREAD)param)->pvSDTParam = ghwndSuperTIP;
                        while (GetMessage(&msg, NULL, 0, 0))
                        {
                            TranslateMessage(&msg);
                            DispatchMessage(&msg);
                        }
                        ((PTSTHREAD)param)->pvSDTParam = ghwndSuperTIP = NULL;
                        gdwfTabSrv &= ~TSF_TRAYICON_CREATED;
                    }
                    else
                    {
                        TABSRVERR(("Failed to create SuperTIP window.\n"));
                        fSuccess = FALSE;
                    }

                    if (SUCCEEDED(hr))
                    {
                        gpITellMe->Release();
                        gpITellMe = NULL;
                    }
                    gpISuperTip->Release();
                    gpISuperTip = NULL;
                }
                else
                {
                    TABSRVERR(("Failed to create SuperTIP COM instance (hr=%x).\n",
                               hr));
                    fSuccess = FALSE;
                }

                CoUninitialize();
                if (fImpersonate)
                {
                    RevertToSelf();
                }
            }
            else
            {
                TABSRVERR(("Failed to set current desktop.\n"));
                fSuccess = FALSE;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TABSRVERR(("Exception in SuperTIP thread (%X).\n", _exception_code()));
    }

    DestroyIcon(ghSuperTIPIcon);
    ghSuperTIPIcon = NULL;

    TRACEEXIT(("=0\n"));
    return 0;
}       //SuperTIPThread

/*++
    @doc    EXTERNAL

    @func   LRESULT | SuperTIPWndProc | SuperTIP window proc.

    @parm   IN HWND | hwnd | Window handle.
    @parm   IN UINT | uiMsg | Window message.
    @parm   IN WPARAM | wParam | Param 1.
    @parm   IN LPARAM | lParam | Param 2.

    @rvalue Return code is message specific.
--*/

LRESULT CALLBACK
SuperTIPWndProc(
    IN HWND   hwnd,
    IN UINT   uiMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRACEPROC("SuperTIPWndProc", 5)
    LRESULT rc = 0;

    TRACEENTER(("(hwnd=%x,Msg=%s,wParam=%x,lParam=%x)\n",
                hwnd, LookupName(uiMsg, WMMsgNames), wParam, lParam));

    if ((guimsgTaskbarCreated != 0) && (uiMsg == guimsgTaskbarCreated))
    {
        TRACEINFO(1, ("Taskbar created...\n"));

        //
        // If whistler fixes the shell bug, we can restore this code.
        //
        gdwfTabSrv |= TSF_TASKBAR_CREATED;
        if (!CreateTrayIcon(hwnd,
                            guimsgTrayCallback,
                            ghSuperTIPIcon,
                            gtszSuperTIPTitle))
        {
            TABSRVERR(("OnTaskbarCreated: failed to create tray icon.\n"));
        }
    }
    else if ((guimsgTrayCallback != 0) && (uiMsg == guimsgTrayCallback))
    {
        switch (lParam)
        {
            case WM_LBUTTONUP:
            {
                int iDefaultCmd = GetMenuDefaultItem(ghmenuTrayPopup,
                                                     FALSE,
                                                     0);

                //
                // Perform default action.
                //
                if (iDefaultCmd != -1)
                {
                    PostMessage(hwnd, WM_COMMAND, iDefaultCmd, 0);
                }
                break;
            }

            case WM_RBUTTONUP:
            {
                TCHAR tszMenuText[128];
                POINT pt;

                //
                // Do popup menu.
                //
                TRACEASSERT(ghmenuTrayPopup != NULL);
                LoadString(ghMod,
                           gdwfTabSrv & TSF_SUPERTIP_OPENED?
                                IDS_HIDE_SUPERTIP: IDS_SHOW_SUPERTIP,
                           tszMenuText,
                           ARRAYSIZE(tszMenuText));
                ModifyMenu(ghmenuTrayPopup,
                           IDM_OPEN,
                           MF_BYCOMMAND | MF_STRING,
                           IDM_OPEN,
                           tszMenuText);

                LoadString(ghMod,
                           gdwfTabSrv & TSF_PORTRAIT_MODE?
                                IDS_SCREEN_LANDSCAPE: IDS_SCREEN_PORTRAIT,
                           tszMenuText,
                           ARRAYSIZE(tszMenuText));
                ModifyMenu(ghmenuTrayPopup,
                           IDM_TOGGLE_ROTATION,
                           MF_BYCOMMAND | MF_STRING,
                           IDM_TOGGLE_ROTATION,
                           tszMenuText);

                GetCursorPos(&pt);
                //
                // It is necessary to set focus on this window in order to
                // popup the menu.
                //
                SetForegroundWindow(hwnd);
                TrackPopupMenu(ghmenuTrayPopup,
                               TPM_NONOTIFY | TPM_RIGHTBUTTON,
                               pt.x,
                               pt.y,
                               0,
                               hwnd,
                               NULL);
                break;
            }
        }
    }
    else
    {
        HRESULT hr;

        switch (uiMsg)
        {
            case WM_SUPERTIP_INIT:
                hr = gpISuperTip->Activate();
                if (SUCCEEDED(hr))
                {
                    hr = gpISuperTip->SetNotifyHWND(hwnd,
                                                    WM_SUPERTIP_NOTIFY,
                                                    0);
                    if (FAILED(hr))
                    {
                        TABSRVERR(("Failed to set notify hwnd (hr=%x)\n", hr));
                    }

                    //
                    // If we are not on the Winlogon desktop, wait for the
                    // shell's tray notification window to be created so
                    // our tray icon can be added. Keep checking the
                    // Winlogon desktop flag in case the user switches
                    // desktops while this loop is still waiting for the
                    // tray window.
                    //
                    int i;
                    PTSTHREAD SuperTIPThread = FindThread(TSF_SUPERTIPTHREAD);

                    for (i = 0;
                         (i < 30) &&
                         !(SuperTIPThread->dwfThread & THREADF_DESKTOP_WINLOGON);
                         i++)
                    {
                        if (FindWindow(TEXT("Shell_TrayWnd"), NULL))
                        {
                            break;
                        }
                        Sleep(500);
                    }
                    //
                    // At this point we're either on the Winlogon desktop or
                    // we're ready to create our tray icon.
                    //

                    if (SuperTIPThread->dwfThread & THREADF_DESKTOP_WINLOGON)
                    {
                        POINT pt;

                        pt.x = gcxPrimary;
                        pt.y = gcyPrimary;
                        gpISuperTip->Show(TIP_SHOW_KBDONLY, pt);
                        gdwfTabSrv |= TSF_SUPERTIP_OPENED;
                    }
                    else
                    {
                        if (i > 1)
                        {
                            TRACEINFO(1, ("Shell_TrayWnd loop count: %d\n", i));
                        }

                        ghmenuTray = LoadMenu(ghMod,
                                              MAKEINTRESOURCE(IDR_TRAYMENU));
                        TRACEASSERT(ghmenuTray != NULL);
                        ghmenuTrayPopup = GetSubMenu(ghmenuTray, 0);
                        TRACEASSERT(ghmenuTrayPopup != NULL);
                        SetMenuDefaultItem(ghmenuTrayPopup, IDM_OPEN, FALSE);

                        if (!CreateTrayIcon(hwnd,
                                            guimsgTrayCallback,
                                            ghSuperTIPIcon,
                                            gtszSuperTIPTitle))
                        {
                            TABSRVERR(("OnCreate: failed to create tray icon.\n"));
                        }
                    }
                }
                else
                {
                    TABSRVERR(("Failed to activate SuperTIP (hr=%d)\n", hr));
                    rc = -1;
                }
                break;

            case WM_CLOSE:
                ghwndSuperTIPInk = NULL;
                guimsgSuperTIPInk = 0;
                gdwfTabSrv &= ~(TSF_SUPERTIP_OPENED | TSF_SUPERTIP_SENDINK);
                if (gdwfTabSrv & TSF_TRAYICON_CREATED)
                {
                    if (!DestroyTrayIcon(hwnd,
                                         guimsgTrayCallback,
                                         ghSuperTIPIcon))
                    {
                        TABSRVERR(("failed to destroy tray icon.\n"));
                    }
                }

                if (ghmenuTray != NULL)
                {
                    DestroyMenu(ghmenuTray);
                    ghmenuTray = ghmenuTrayPopup = NULL;
                }
                gpISuperTip->Deactivate();
                DestroyWindow(hwnd);
                PostQuitMessage(0);
                break;

            case WM_DISPLAYCHANGE:
                UpdateRotation();
                break;

            case WM_SETTINGCHANGE:
                if ((wParam == SPI_SETKEYBOARDDELAY) ||
                    (wParam == SPI_SETKEYBOARDSPEED))
                {
                    UpdateButtonRepeatRate();
                }
                break;

            case WM_SUPERTIP_NOTIFY:
                if (wParam == 0)
                {
                    gdwfTabSrv &= ~TSF_SUPERTIP_OPENED;
                    if (!(gdwfTabSrv & TSF_SUPERTIP_MINIMIZED_BEFORE))
                    {
                        gdwfTabSrv |= TSF_SUPERTIP_MINIMIZED_BEFORE;
                        if (gdwfTabSrv & TSF_TRAYICON_CREATED)
                        {
                            if (!SetBalloonToolTip(hwnd,
                                                   guimsgTrayCallback,
                                                   gtszSuperTIPTitle,
                                                   gtszBalloonTip,
                                                   TIMEOUT_BALLOON_TIP,
                                                   NIIF_INFO))
                            {
                                TABSRVERR(("failed to popup balloon tip.\n"));
                            }
                        }
                    }
                }
                else if (wParam >= WM_USER)
                {
                    ghwndSuperTIPInk = (HWND)lParam;
                    guimsgSuperTIPInk = (UINT)wParam;
                }
                break;

            case WM_COMMAND:
                switch (LOWORD(wParam))
                {
                    case IDM_OPEN:
                    {
                        if (gpITellMe != NULL)
                        {
                            HWND hwndTarget;

                            __try
                            {
                                if (SUCCEEDED(
                                    gpITellMe->GetLastValidFocusHWnd(&hwndTarget)))
                                {
                                    SetForegroundWindow(hwndTarget);
                                }
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                TABSRVERR(("Exception in TellMe::GetLastValidFocusHWnd (%X).\n",
                                           _exception_code()));
                            }
                        }

                        POINT pt = {0, 0};
                        HRESULT hr = gpISuperTip->Show(TIP_SHOW_TOGGLE, pt);
                        gdwfTabSrv ^= TSF_SUPERTIP_OPENED;
                        break;
                    }

#ifdef DEBUG
                    case IDM_PROPERTIES:
                    {
                        HMODULE hmod;
                        APPLET_PROC pfnCplApplet;
                        LRESULT lrc;

                        hmod = LoadLibrary(TEXT("tabletpc.cpl"));
                        if (hmod != NULL)
                        {
                            pfnCplApplet = (APPLET_PROC)GetProcAddress(
                                                            hmod,
                                                            TEXT("CPlApplet"));
                            if (pfnCplApplet != NULL)
                            {
                                pfnCplApplet(hwnd, CPL_DBLCLK, 0, 0);
                            }
                            else
                            {
                                TABSRVERR(("Failed to get entry point of control panel (err=%d)\n",
                                           GetLastError()));
                            }
                            FreeLibrary(hmod);
                            hmod = NULL;
                        }
                        else
                        {
                            TABSRVERR(("Failed to load control panel (err=%d)\n",
                                       GetLastError()));
                        }
                        break;
                    }
#endif

                    case IDM_TOGGLE_ROTATION:
                    {
#if 0
                        DEVMODE DevMode;
                        LONG rcDisplay;

                        //
                        // To circumvent the dynamic mode tablet problem,
                        // we need to enumerate the display modes table to
                        // force the SMI driver to load a mode table that
                        // supports portrait modes.
                        //
                        EnumDisplayModes();

                        memset(&DevMode, 0, sizeof(DevMode));
                        DevMode.dmSize = sizeof(DevMode);
                        DevMode.dmPelsWidth = gcyPrimary;
                        DevMode.dmPelsHeight = gcxPrimary;
                        DevMode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
                        if (DevMode.dmPelsWidth < DevMode.dmPelsHeight)
                        {
                            //
                            // We are switching to Portrait mode,
                            // make sure our color depth is 16-bit.
                            //
                            DevMode.dmBitsPerPel = 16;
                            DevMode.dmFields |= DM_BITSPERPEL;
                        }
                        rcDisplay = ChangeDisplaySettings(&DevMode,
                                                          CDS_UPDATEREGISTRY);
                        if (rcDisplay < 0)
                        {
                            TABSRVERR(("Failed to toggle rotation (rc=%d)\n",
                                       rcDisplay));
                            //BUGBUG: make this LoadString
                            MessageBox(NULL,
                                       TEXT("Failed to toggle rotation"),
                                       TEXT(MODNAME),
                                       MB_OK);
                        }
#endif
//#if 0
                        typedef BOOL (__stdcall *PFNSETROTATION)(DWORD);
                        HMODULE hmod = LoadLibrary(TEXT("tabletpc.cpl"));
                        PFNSETROTATION pfnSetRotation;
                        LRESULT lrc;

                        if (hmod != NULL)
                        {
                            pfnSetRotation = (PFNSETROTATION)GetProcAddress(
                                                    hmod,
                                                    TEXT("SetRotation"));
                            if (pfnSetRotation != NULL)
                            {
                                if (pfnSetRotation(
                                        (gdwfTabSrv & TSF_PORTRAIT_MODE)?
                                        0: RT_CLOCKWISE))
                                {
                                    //
                                    // Sometimes the system miss sending
                                    // WM_DISPLAYCHANGE, so we will do it
                                    // here just in case.
                                    //
                                    UpdateRotation();
                                }
                            }
                            else
                            {
                                TABSRVERR(("Failed to get entry point of SetRotation (err=%d)\n",
                                           GetLastError()));
                            }
                            FreeLibrary(hmod);
                        }
                        else
                        {
                            TABSRVERR(("Failed to load control panel (err=%d)\n",
                                       GetLastError()));
                        }
//#endif
                        break;
                    }

                    default:
                        rc = DefWindowProc(hwnd, uiMsg, wParam, lParam);
                }
                break;

            case WM_GESTURE:
            {
                POINT pt;

                //
                // Unpack x and y.  Sign extend if necessary.
                //
                pt.x = (LONG)((SHORT)(lParam & 0xffff));
                pt.y = (LONG)((SHORT)(lParam >> 16));

                switch (wParam)
                {
                    case PopupSuperTIP:
                        TRACEINFO(1, ("Popup SuperTIP\n"));
                        gpISuperTip->Show(TIP_SHOW_GESTURE, pt);
                        gdwfTabSrv |= TSF_SUPERTIP_OPENED;
                        break;

                    case PopupMIP:
                        TRACEINFO(1, ("Popup MIP\n"));
                        gpISuperTip->ShowMIP(TIP_SHOW_GESTURE, pt);
                        break;
                }
                break;
            }

            default:
                rc = DefWindowProc(hwnd, uiMsg, wParam, lParam);
        }
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //SuperTIPWndProc

#if 0
/*++
    @doc    INTERNAL

    @func   VOID | EnumDisplayModes | Enumerate display modes to force
            SMI driver to dynamically load a mode table that supports
            Portrait modes.

    @parm   None.

    @rvalue None.
--*/

VOID
EnumDisplayModes(
    VOID
    )
{
    TRACEPROC("EnumDisplayModes", 3)
    DWORD i;
    DEVMODE DevMode;

    TRACEENTER(("()\n"));

    for (i = 0; EnumDisplaySettings(NULL, i, &DevMode); ++i)
    {
        //
        // Don't have to do anything.
        //
    }

    TRACEEXIT(("!\n"));
    return;
}       //EnumDisplayModes
#endif

/*++
    @doc    INTERNAL

    @func   VOID | UpdateRotation | Update the rotation info.

    @parm   None.

    @rvalue None.
--*/

VOID
UpdateRotation(
    VOID
    )
{
    TRACEPROC("UpdateRotation", 3)

    TRACEENTER(("()\n"));

    //
    // Display mode has changed, better recompute everything related
    // to screen.
    //
    glVirtualDesktopLeft   =
    glVirtualDesktopRight  =
    glVirtualDesktopTop    =
    glVirtualDesktopBottom = 0;
    EnumDisplayMonitors(NULL, NULL, MonitorEnumProc, 0);
    gcxPrimary = GetSystemMetrics(SM_CXSCREEN);
    gcyPrimary = GetSystemMetrics(SM_CYSCREEN);
    gcxScreen = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    gcyScreen = GetSystemMetrics(SM_CYVIRTUALSCREEN);
    if (gcxPrimary > gcyPrimary)
    {
        gdwfTabSrv &= ~TSF_PORTRAIT_MODE;
    }
    else
    {
        gdwfTabSrv |= TSF_PORTRAIT_MODE;
    }
    glLongOffset = ((NUM_PIXELS_LONG -
                     max(gcxPrimary, gcyPrimary))*(MAX_NORMALIZED_X + 1))/
                   (2*NUM_PIXELS_LONG);
    glShortOffset = ((NUM_PIXELS_SHORT -
                      min(gcxPrimary, gcyPrimary))*(MAX_NORMALIZED_Y + 1))/
                    (2*NUM_PIXELS_SHORT);

    TRACEEXIT(("!\n"));
    return;
}       //UpdateRotation

/*++
    @doc    EXTERNAL

    @func   BOOL | MonitorEnumProc | The callback function for
            EnumDisplayMonitors.

    @parm   IN HMONITOR | hMon | Handle to display monitor.
    @parm   IN HDC | hdcMon | Handle to monitor DC.
    @parm   IN LPRECT | lprcMon | Monitor intersection rectangle.
    @parm   IN LPARAM | dwData | Unused.

    @rvalue Always return TRUE to continue enumeration.
--*/

BOOL CALLBACK
MonitorEnumProc(
    IN HMONITOR hMon,
    IN HDC      hdcMon,
    IN LPRECT   lprcMon,
    IN LPARAM   dwData
    )
{
    TRACEPROC("MonitorEnumProc", 3)

    TRACEENTER(("(hMon=%x,hdcMon=%x,MonLeft=%d,MonRight=%d,MonTop=%d,MonBottom=%d,dwData=%x)\n",
                hMon, hdcMon, lprcMon->left, lprcMon->right, lprcMon->top,
                lprcMon->bottom, dwData));

    if (lprcMon->left < glVirtualDesktopLeft)
    {
        glVirtualDesktopLeft = lprcMon->left;
    }

    if (lprcMon->right - 1 > glVirtualDesktopRight)
    {
        glVirtualDesktopRight = lprcMon->right - 1;
    }

    if (lprcMon->top < glVirtualDesktopTop)
    {
        glVirtualDesktopTop = lprcMon->top;
    }

    if (lprcMon->bottom - 1> glVirtualDesktopBottom)
    {
        glVirtualDesktopBottom = lprcMon->bottom - 1;
    }

    TRACEEXIT(("=1\n"));
    return TRUE;
}       //MonitorEnumProc

/*++
    @doc    INTERNAL

    @func   BOOL | CreateTrayIcon | Create the tray icon.

    @parm   IN HWND | hwnd | Window handle that the tray can send message to.
    @parm   IN UINT | umsgTray | Message ID that the tray used to send messages.
    @parm   IN HICON | hIcon | Icon handle.
    @parm   IN LPCTSTR | ptszTip | Points to the Tip string.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
CreateTrayIcon(
    IN HWND    hwnd,
    IN UINT    umsgTray,
    IN HICON   hIcon,
    IN LPCTSTR ptszTip
    )
{
    TRACEPROC("CreateTrayIcon", 2)
    BOOL rc;
    NOTIFYICONDATA nid;

    TRACEENTER(("(hwnd=%x,msgTray=%x,hIcon=%x,Tip=%s)\n",
                hwnd, umsgTray, hIcon, ptszTip));
    TRACEASSERT(hIcon != NULL);
    TRACEASSERT(ptszTip != NULL);

    memset(&nid, 0, sizeof(nid));
    nid.cbSize = sizeof(nid);
    nid.hWnd = hwnd;
    nid.uCallbackMessage = umsgTray;
    nid.hIcon = hIcon;
    lstrcpyn(nid.szTip, ptszTip, ARRAYSIZE(nid.szTip));
    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
    rc = Shell_NotifyIcon(NIM_ADD, &nid);
    if (rc == TRUE)
    {
        gdwfTabSrv |= TSF_TRAYICON_CREATED;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //CreateTrayIcon

/*++
    @doc    INTERNAL

    @func   BOOL | DestroyTrayIcon | Destroy the tray icon.

    @parm   IN HWND | hwnd | Window handle that the tray can send message to.
    @parm   IN UINT | umsgTray | Message ID that the tray used to send messages.
    @parm   IN HICON | hIcon | Icon handle.
    @parm   IN LPCTSTR | ptszTip | Points to the Tip string.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
DestroyTrayIcon(
    IN HWND    hwnd,
    IN UINT    umsgTray,
    IN HICON   hIcon
    )
{
    TRACEPROC("DestroyTrayIcon", 2)
    BOOL rc;
    NOTIFYICONDATA nid;

    TRACEENTER(("(hwnd=%x,msgTray=%x,hIcon=%x)\n", hwnd, umsgTray, hIcon));
    TRACEASSERT(hIcon != NULL);
    TRACEASSERT(gdwfTabSrv & TSF_TRAYICON_CREATED);

    memset(&nid, 0, sizeof(nid));
    nid.cbSize = sizeof(nid);
    nid.hWnd = hwnd;
    nid.uCallbackMessage = umsgTray;
    nid.hIcon = hIcon;
    nid.uFlags = NIF_ICON | NIF_MESSAGE;
    rc = Shell_NotifyIcon(NIM_DELETE, &nid);
    if (rc == TRUE)
    {
        gdwfTabSrv &= ~TSF_TRAYICON_CREATED;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //DestroyTrayIcon

/*++
    @doc    INTERNAL

    @func   BOOL | SetBalloonToolTip | Set Balloon Tool Tip on tray icon

    @parm   IN HWND | hwnd | Window handle that the tray can send message to.
    @parm   IN UINT | umsgTray | Message ID that the tray used to send messages.
    @parm   IN LPCTSTR | ptszTitle | Points to the Tip title string.
    @parm   IN LPCTSTR | ptszTip | Points to the Tip text string.
    @parm   IN UINT | uTimeout | Specify how long the balloon tip stays up.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL SetBalloonToolTip(
    IN HWND    hwnd,
    IN UINT    umsgTray,
    IN LPCTSTR ptszTitle,
    IN LPCTSTR ptszTip,
    IN UINT    uTimeout,
    IN DWORD   dwInfoFlags
    )
{
    TRACEPROC("SetBalloonToolTip", 2)
    BOOL rc;
    NOTIFYICONDATA nid;

    TRACEENTER(("(hwnd=%x,TrayMsg=%x,Title=%s,Tip=%s,Timeout=%d,InfoFlags=%x)\n",
                hwnd, umsgTray, ptszTitle, ptszTip, uTimeout, dwInfoFlags));
    TRACEASSERT(gdwfTabSrv & TSF_TRAYICON_CREATED);

    memset(&nid, 0, sizeof(nid));
    nid.cbSize = sizeof(nid);
    nid.hWnd = hwnd;
    nid.uFlags = NIF_INFO;
    nid.uCallbackMessage = umsgTray;
    nid.uTimeout = uTimeout;
    lstrcpyn(nid.szInfo, ptszTip, ARRAYSIZE(nid.szInfo));
    lstrcpyn(nid.szInfoTitle, ptszTitle, ARRAYSIZE(nid.szInfoTitle));
    nid.dwInfoFlags = dwInfoFlags;
    rc = Shell_NotifyIcon(NIM_MODIFY, &nid);

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //SetBalloonToolTip
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\supertip_obj.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Wed Nov 29 09:58:19 2000
 */
/* Compiler settings for D:\NewTip\src\SuperTip.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __SuperTip_Obj_h__
#define __SuperTip_Obj_h__

/* Forward Declarations */ 

#ifndef __ISuperTip_FWD_DEFINED__
#define __ISuperTip_FWD_DEFINED__
typedef interface ISuperTip ISuperTip;
#endif 	/* __ISuperTip_FWD_DEFINED__ */


#ifndef __SuperTip_FWD_DEFINED__
#define __SuperTip_FWD_DEFINED__

#ifdef __cplusplus
typedef class SuperTip SuperTip;
#else
typedef struct SuperTip SuperTip;
#endif /* __cplusplus */

#endif 	/* __SuperTip_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_SuperTip_0000 */
/* [local] */ 

typedef 
enum _TIP_SHOW_TYPE
    {	TIP_SHOW_GESTURE	= 0,
	TIP_SHOW_OTHER	= 1,
	TIP_SHOW_HIDE	= 2,
	TIP_SHOW_TOGGLE	= 3,
	TIP_SHOW_KBDONLY	= 4
    }	TIP_SHOW_TYPE;

typedef enum _TIP_SHOW_TYPE __RPC_FAR *PTIP_SHOW_TYPE;

typedef 
enum _TIP_HIT_TEST_TYPE
    {	TIP_HT_NONE	= 0,
	TIP_HT_MAIN	= 0x1000,
	TIP_HT_STAGE	= 0x1010,
	TIP_HT_INK_AREA	= 0x1020,
	TIP_HT_KEYBOARD	= 0x2000,
	TIP_HT_PENPAD	= 0x4000,
	TIP_HT_MENUPOPUP	= 0x8000,
	TIP_HT_MIPWINDOW	= 0x8001
    }	TIP_HIT_TEST_TYPE;

typedef enum _TIP_HIT_TEST_TYPE __RPC_FAR *PTIP_HIT_TEST_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_SuperTip_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_SuperTip_0000_v0_0_s_ifspec;

#ifndef __ISuperTip_INTERFACE_DEFINED__
#define __ISuperTip_INTERFACE_DEFINED__

/* interface ISuperTip */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISuperTip;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7B87CFE3-1E15-4AE1-90E1-A3B693EA9F1B")
    ISuperTip : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Activate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ TIP_SHOW_TYPE show,
            /* [in] */ POINT pt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsVisible( 
            /* [out] */ BOOL __RPC_FAR *pfIsVisible) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowPropertyPages( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowMIP( 
            /* [in] */ TIP_SHOW_TYPE show,
            /* [in] */ POINT pt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HitTest( 
            /* [in] */ POINT pt,
            /* [out] */ PTIP_HIT_TEST_TYPE phtResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetNotifyHWND( 
            /* [in] */ HWND hWndNotify,
            /* [in] */ UINT uMsgNotify,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISuperTipVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISuperTip __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISuperTip __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISuperTip __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            ISuperTip __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            ISuperTip __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Show )( 
            ISuperTip __RPC_FAR * This,
            /* [in] */ TIP_SHOW_TYPE show,
            /* [in] */ POINT pt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsVisible )( 
            ISuperTip __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfIsVisible);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowPropertyPages )( 
            ISuperTip __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowMIP )( 
            ISuperTip __RPC_FAR * This,
            /* [in] */ TIP_SHOW_TYPE show,
            /* [in] */ POINT pt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HitTest )( 
            ISuperTip __RPC_FAR * This,
            /* [in] */ POINT pt,
            /* [out] */ PTIP_HIT_TEST_TYPE phtResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotifyHWND )( 
            ISuperTip __RPC_FAR * This,
            /* [in] */ HWND hWndNotify,
            /* [in] */ UINT uMsgNotify,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } ISuperTipVtbl;

    interface ISuperTip
    {
        CONST_VTBL struct ISuperTipVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISuperTip_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISuperTip_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISuperTip_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISuperTip_Activate(This)	\
    (This)->lpVtbl -> Activate(This)

#define ISuperTip_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define ISuperTip_Show(This,show,pt)	\
    (This)->lpVtbl -> Show(This,show,pt)

#define ISuperTip_IsVisible(This,pfIsVisible)	\
    (This)->lpVtbl -> IsVisible(This,pfIsVisible)

#define ISuperTip_ShowPropertyPages(This)	\
    (This)->lpVtbl -> ShowPropertyPages(This)

#define ISuperTip_ShowMIP(This,show,pt)	\
    (This)->lpVtbl -> ShowMIP(This,show,pt)

#define ISuperTip_HitTest(This,pt,phtResult)	\
    (This)->lpVtbl -> HitTest(This,pt,phtResult)

#define ISuperTip_SetNotifyHWND(This,hWndNotify,uMsgNotify,lParam)	\
    (This)->lpVtbl -> SetNotifyHWND(This,hWndNotify,uMsgNotify,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISuperTip_Activate_Proxy( 
    ISuperTip __RPC_FAR * This);


void __RPC_STUB ISuperTip_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISuperTip_Deactivate_Proxy( 
    ISuperTip __RPC_FAR * This);


void __RPC_STUB ISuperTip_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISuperTip_Show_Proxy( 
    ISuperTip __RPC_FAR * This,
    /* [in] */ TIP_SHOW_TYPE show,
    /* [in] */ POINT pt);


void __RPC_STUB ISuperTip_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISuperTip_IsVisible_Proxy( 
    ISuperTip __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfIsVisible);


void __RPC_STUB ISuperTip_IsVisible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISuperTip_ShowPropertyPages_Proxy( 
    ISuperTip __RPC_FAR * This);


void __RPC_STUB ISuperTip_ShowPropertyPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISuperTip_ShowMIP_Proxy( 
    ISuperTip __RPC_FAR * This,
    /* [in] */ TIP_SHOW_TYPE show,
    /* [in] */ POINT pt);


void __RPC_STUB ISuperTip_ShowMIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISuperTip_HitTest_Proxy( 
    ISuperTip __RPC_FAR * This,
    /* [in] */ POINT pt,
    /* [out] */ PTIP_HIT_TEST_TYPE phtResult);


void __RPC_STUB ISuperTip_HitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISuperTip_SetNotifyHWND_Proxy( 
    ISuperTip __RPC_FAR * This,
    /* [in] */ HWND hWndNotify,
    /* [in] */ UINT uMsgNotify,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ISuperTip_SetNotifyHWND_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISuperTip_INTERFACE_DEFINED__ */



#ifndef __SUPERTIPLib_LIBRARY_DEFINED__
#define __SUPERTIPLib_LIBRARY_DEFINED__

/* library SUPERTIPLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_SUPERTIPLib;

EXTERN_C const CLSID CLSID_SuperTip;

#ifdef __cplusplus

class DECLSPEC_UUID("6F0CA6B7-947F-4E3C-B7CD-DD905A543648")
SuperTip;
#endif
#endif /* __SUPERTIPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\supertip_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Mon Sep 18 10:30:10 2000
 */
/* Compiler settings for D:\NewTip\src\SuperTip.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISuperTip,0x7B87CFE3,0x1E15,0x4AE1,0x90,0xE1,0xA3,0xB6,0x93,0xEA,0x9F,0x1B);


MIDL_DEFINE_GUID(IID, LIBID_SUPERTIPLib,0xA824378D,0xFA7B,0x4858,0xAA,0x75,0x9B,0x6F,0xD0,0x5C,0x55,0x92);


MIDL_DEFINE_GUID(CLSID, CLSID_SuperTip,0x6F0CA6B7,0x947F,0x4E3C,0xB7,0xCD,0xDD,0x90,0x5A,0x54,0x36,0x48);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\tabsrv.cpp ===
/*++
    Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

    Module Name:
        tabsrv.cpp

    Abstract:
        This is the main module of the Tablet PC Listener service.

    Author:
        Michael Tsang (MikeTs) 01-Jun-2000

    Environment:
        User mode

    Revision History:
--*/

#ifndef INITGUID
#define INITGUID
#endif

#include "pch.h"
#include <userenv.h>

extern "C"
{
    HANDLE GetCurrentUserTokenW(WCHAR Winsta[], DWORD DesiredAccess);
};

//
// Global data
//
HMODULE     ghMod = NULL;
DWORD       gdwfTabSrv = 0;
LIST_ENTRY  glistNotifyClients = {0};
HANDLE      ghDesktopSwitchEvent = NULL;
HANDLE      ghmutNotifyList = NULL;
HANDLE      ghHotkeyEvent = NULL;
HANDLE      ghRefreshEvent = NULL;
HANDLE      ghRPCServerThread = NULL;
HWND        ghwndSuperTIP = NULL;
HWND        ghwndMouse = NULL;
HWND        ghwndSuperTIPInk = NULL;
HCURSOR     ghcurPressHold = NULL;
HCURSOR     ghcurNormal = NULL;
UINT        guimsgSuperTIPInk = 0;
#ifdef DRAW_INK
HWND        ghwndDrawInk = NULL;
#endif
ISuperTip  *gpISuperTip = NULL;
ITellMe    *gpITellMe = NULL;
int         gcxScreen = 0, gcyScreen = 0;
int         gcxPrimary = 0, gcyPrimary = 0;
LONG        glVirtualDesktopLeft   = 0,
            glVirtualDesktopRight  = 0,
            glVirtualDesktopTop    = 0,
            glVirtualDesktopBottom = 0;
LONG        glLongOffset = 0, glShortOffset = 0;
int         giButtonsSwapped = 0;
ULONG       gdwMinX = 0,
            gdwMaxX = MAX_NORMALIZED_X,
            gdwRngX = MAX_NORMALIZED_X;
ULONG       gdwMinY = 0,
            gdwMaxY = MAX_NORMALIZED_Y,
            gdwRngY = MAX_NORMALIZED_Y;
int         gixIndex = 0, giyIndex = 0;
INPUT       gInput = {INPUT_MOUSE};
DWORD       gdwPenState = PENSTATE_NORMAL;
DWORD       gdwPenDownTime = 0;
LONG        glPenDownX = 0;
LONG        glPenDownY = 0;
DWORD       gdwPenUpTime = 0;
LONG        glPenUpX = 0;
LONG        glPenUpY = 0;
WORD        gwLastButtons = 0;
CONFIG      gConfig = {0};
GESTURE_SETTINGS gDefGestureSettings =
{
    sizeof(GESTURE_SETTINGS),
    GESTURE_FEATURE_RECOG_ENABLED |
    GESTURE_FEATURE_PRESSHOLD_ENABLED,
    200,            //iRadius
    6,              //iMinOutPts
    800,            //iMaxTimeToInspect
    3,              //iAspectRatio
    400,            //iCheckTime
    4,              //iPointsToExamine
    50,             //iStopDist
    350,            //iStopTime (was 200)
    500,            //iPressHoldTime
    3,              //iHoldTolerance
    700,            //iCancelPressHoldTime
    PopupSuperTIP,
    PopupMIP,
    GestureNoAction,
    GestureNoAction
};
BUTTON_SETTINGS gDefButtonSettings =
{
    sizeof(BUTTON_SETTINGS),
    Enter,
    PageUp,
    InvokeNoteBook,
    AltEsc,
    PageDown,
    BUTTONSTATE_DEFHOTKEY
};
TSTHREAD    gTabSrvThreads[] =
{
    RPCServerThread, "RPCServer", TSF_RPCTHREAD,
        THREADF_ENABLED,
        0, NULL, NULL, -1, NULL,
    SuperTIPThread,  "SuperTIP",  TSF_SUPERTIPTHREAD,
        THREADF_ENABLED | THREADF_SDT_POSTMSG | THREADF_RESTARTABLE,
        0, NULL, NULL, -1, NULL,
    DeviceThread,    "Digitizer", TSF_DIGITHREAD,
        THREADF_ENABLED | THREADF_SDT_SETEVENT | THREADF_RESTARTABLE,
        0, NULL, NULL, -1, (PVOID)&gdevDigitizer,
#ifdef MOUSE_THREAD
    MouseThread,     "Mouse",     TSF_MOUSETHREAD,
        THREADF_ENABLED | THREADF_SDT_POSTMSG | THREADF_RESTARTABLE,
        0, NULL, NULL, -1, NULL,
#endif
    DeviceThread,    "Buttons",   TSF_BUTTONTHREAD,
        THREADF_ENABLED | THREADF_SDT_SETEVENT | THREADF_RESTARTABLE,
        0, NULL, NULL, -1, (PVOID)&gdevButtons,
};
#define NUM_THREADS             ARRAYSIZE(gTabSrvThreads)

TCHAR       gtszTabSrvTitle[128] = {0};
TCHAR       gtszTabSrvName[] = TEXT(STR_TABSRV_NAME);
TCHAR       gtszGestureSettings[] = TEXT("GestureSettings");
TCHAR       gtszButtonSettings[] = TEXT("ButtonSettings");
TCHAR       gtszPenTilt[] = TEXT("PenTilt");
TCHAR       gtszLinearityMap[] = TEXT(STR_LINEARITY_MAP);
TCHAR       gtszRegPath[] = TEXT(STR_REGPATH_TABSRVPARAM);
TCHAR       gtszPortraitMode2[] = TEXT("PortraitMode2");
TCHAR       gtszInputDesktop[32] = {0};

SERVICE_STATUS_HANDLE ghServStatus = NULL;
SERVICE_STATUS        gServStatus = {0};
DIGITIZER_DATA        gLastRawDigiReport = {0};
DEVICE_DATA           gdevDigitizer = {HID_USAGE_PAGE_DIGITIZER,
                                       HID_USAGE_DIGITIZER_PEN};
DEVICE_DATA           gdevButtons = {HID_USAGE_PAGE_CONSUMER,
                                     HID_USAGE_CONSUMERCTRL};

#ifdef DEBUG
NAMETABLE ServiceControlNames[] =
{
    SERVICE_CONTROL_STOP,               "Stop",
    SERVICE_CONTROL_PAUSE,              "Pause",
    SERVICE_CONTROL_CONTINUE,           "Continue",
    SERVICE_CONTROL_INTERROGATE,        "Interrogate",
    SERVICE_CONTROL_SHUTDOWN,           "Shutdown",
    SERVICE_CONTROL_PARAMCHANGE,        "ParamChange",
    SERVICE_CONTROL_NETBINDADD,         "NetBindAdd",
    SERVICE_CONTROL_NETBINDREMOVE,      "NetBindRemove",
    SERVICE_CONTROL_NETBINDENABLE,      "NetBindEnable",
    SERVICE_CONTROL_NETBINDDISABLE,     "NetBindDisable",
    0,                                  NULL
};
NAMETABLE ConsoleControlNames[] =
{
    CTRL_C_EVENT,                       "CtrlCEvent",
    CTRL_BREAK_EVENT,                   "CtrlBreakEvent",
    CTRL_CLOSE_EVENT,                   "CloseEvent",
    CTRL_LOGOFF_EVENT,                  "LogOffEvent",
    CTRL_SHUTDOWN_EVENT,                "ShutDownEvent",
    0,                                  NULL
};
#endif

/*++
    @doc    EXTERNAL

    @func   int | main | Program entry point.

    @parm   IN int | icArgs | Specifies number of command line arguments.
    @parm   IN PSZ * | apszArgs | Points to the array of argument strings.

    @rvalue SUCCESS | Returns 0.
    @rvalue FAILURE | Returns -1.
--*/

int __cdecl
main(
    IN int     icArgs,
    IN LPTSTR *aptszArgs
    )
{
    TRACEPROC("main", 1)
    int rc = 0;

    TRACEINIT(STR_TABSRV_NAME, 0, 0);
    TRACEENTER(("(icArgs=%d,aptszArgs=%p)\n", icArgs, aptszArgs));

    ghMod = GetModuleHandle(NULL);
    TRACEASSERT(ghMod != NULL);
    LoadString(ghMod,
               IDS_TABSRV_TITLE,
               gtszTabSrvTitle,
               ARRAYSIZE(gtszTabSrvTitle));

    if (icArgs == 1)
    {
        //
        // No command line argument, must be SCM...
        //
        SERVICE_TABLE_ENTRY ServiceTable[] =
        {
            {gtszTabSrvName,        TabSrvMain},
            {NULL,                  NULL}
        };

        if (!StartServiceCtrlDispatcher(ServiceTable))
        {
            TABSRVERR(("Failed to start service dispatcher (err=%d).\n",
                       GetLastError()));
            rc = -1;
        }
    }
    else if (icArgs == 2)
    {
        if ((aptszArgs[1][0] == TEXT('-')) || (aptszArgs[1][0] == TEXT('/')))
        {
            if (lstrcmpi(&aptszArgs[1][1], TEXT("install")) == 0)
            {
                InstallTabSrv();
            }
          #ifdef ALLOW_REMOVE
            else if (lstrcmpi(&aptszArgs[1][1], TEXT("remove")) == 0)
            {
                RemoveTabSrv();
            }
          #endif
          #ifdef ALLOW_START
            else if (lstrcmpi(&aptszArgs[1][1], TEXT("start")) == 0)
            {
                StartTabSrv();
            }
          #endif
          #ifdef ALLOW_STOP
            else if (lstrcmpi(&aptszArgs[1][1], TEXT("stop")) == 0)
            {
                StopTabSrv();
            }
          #endif
          #ifdef ALLOW_DEBUG
            else if (lstrcmpi(&aptszArgs[1][1], TEXT("debug")) == 0)
            {
                gdwfTabSrv |= TSF_DEBUG_MODE;
                SetConsoleCtrlHandler(TabSrvConsoleHandler, TRUE);
                TabSrvMain(0, NULL);
            }
          #endif
            else
            {
                TABSRVERR(("Invalid command line argument \"%s\".\n",
                           aptszArgs[1]));
                rc = -1;
            }
        }
        else
        {
            TABSRVERR(("Invalid command line syntax \"%s\".\n", aptszArgs[1]));
            rc = -1;
        }
    }
    else
    {
        TABSRVERR(("Too many command line arguments.\n"));
        rc = -1;
    }

    TRACEEXIT(("=%d\n", rc));
    TRACETERMINATE();
    return rc;
}       //main

/*++
    @doc    INTERNAL

    @func   VOID | InstallTabSrv | Install TabSrv service.

    @parm   None.

    @rvalue None.
--*/

VOID
InstallTabSrv(
    VOID
    )
{
    TRACEPROC("InstallTabSrv", 2)
    SC_HANDLE hSCM;
    SC_HANDLE hService;

    TRACEENTER(("()\n"));

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    TRACEASSERT(hSCM != NULL);

    hService = CreateService(hSCM,
                             gtszTabSrvName,
                             gtszTabSrvTitle,
                             SERVICE_ALL_ACCESS | SERVICE_CHANGE_CONFIG,
                             SERVICE_WIN32_OWN_PROCESS,
                             SERVICE_AUTO_START,
                             SERVICE_ERROR_NORMAL,
                             TEXT("%SystemRoot%\\system32\\tabsrv.exe"),
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);

    if (hService != NULL)
    {
        SetTabSrvConfig(hService);
        CloseServiceHandle(hService);
    }
    else
    {
        TABSRVERR(("Failed to create TabSrv service (err=%d).\n",
                   GetLastError()));
    }

    CloseServiceHandle(hSCM);

    //
    // Go ahead and start the service for no-reboot install.
    //
    StartTabSrv();

    TRACEEXIT(("!\n"));
    return;
}       //InstallTabSrv

/*++
    @doc    INTERNAL

    @func   VOID | SetTabSrvConfig | Set service configuration.

    @parm   IN SC_HANDLE | hService | Service handle.

    @rvalue None.
--*/

VOID
SetTabSrvConfig(
    IN SC_HANDLE hService
    )
{
    TRACEPROC("SetTabSrvConfig", 2)
    SERVICE_FAILURE_ACTIONS FailActions;
    SC_ACTION Actions = {SC_ACTION_RESTART, 10000}; //restart after 10 sec.

    TRACEENTER(("(hService=%x)\n", hService));

    FailActions.dwResetPeriod = 86400;  //reset failure count after 1 day.
    FailActions.lpRebootMsg = FailActions.lpCommand = NULL;
    FailActions.cActions = 1;
    FailActions.lpsaActions = &Actions;
    if (!ChangeServiceConfig2(hService,
                              SERVICE_CONFIG_FAILURE_ACTIONS,
                              &FailActions))
    {
        TABSRVERR(("Failed to set failure actions (err=%d)\n", GetLastError()));
    }

    TRACEEXIT(("!\n"));
    return;
}       //SetTabSrvConfig

/*++
    @doc    INTERNAL

    @func   VOID | RemoveTabSrv | Remove TabSrv service.

    @parm   None.

    @rvalue None.
--*/

VOID
RemoveTabSrv(
    VOID
    )
{
    TRACEPROC("RemoveTabSrv", 2)
    SC_HANDLE hSCM;
    SC_HANDLE hService;

    TRACEENTER(("()\n"));

    //
    // Stop the service first
    //
    StopTabSrv();

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    TRACEASSERT(hSCM != NULL);

    hService = OpenService(hSCM, gtszTabSrvName, DELETE);
    if (hService != NULL)
    {
        DeleteService(hService);
        CloseServiceHandle(hService);
    }
    else
    {
        TABSRVERR(("Failed to open service for delete.\n"));
    }

    CloseServiceHandle(hSCM);

    TRACEEXIT(("!\n"));
    return;
}       //RemoveTabSrv

/*++
    @doc    INTERNAL

    @func   VOID | StartTabSrv | Start TabSrv service.

    @parm   None.

    @rvalue None.
--*/

VOID
StartTabSrv(
    VOID
    )
{
    TRACEPROC("StartTabSrv", 2)
    SC_HANDLE hSCM;
    SC_HANDLE hService;

    TRACEENTER(("()\n"));

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    TRACEASSERT(hSCM != NULL);

    hService = OpenService(hSCM, gtszTabSrvName, SERVICE_START);
    if (hService != NULL)
    {
        if (!StartService(hService, 0, NULL))
        {
            TABSRVERR(("Failed to start service (err=%d).\n", GetLastError()));
        }
        CloseServiceHandle(hService);
    }
    else
    {
        TABSRVERR(("Failed to open service for start.\n"));
    }

    CloseServiceHandle(hSCM);

    TRACEEXIT(("!\n"));
    return;
}       //StartTabSrv

/*++
    @doc    INTERNAL

    @func   VOID | StopTabSrv | Stop TabSrv service.

    @parm   None.

    @rvalue None.
--*/

VOID
StopTabSrv(
    VOID
    )
{
    TRACEPROC("StopTabSrv", 2)
    SC_HANDLE hSCM;
    SC_HANDLE hService;
    SERVICE_STATUS Status;

    TRACEENTER(("()\n"));

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    TRACEASSERT(hSCM != NULL);

    hService = OpenService(hSCM, gtszTabSrvName, SERVICE_STOP);
    if (hService != NULL)
    {
        if (!ControlService(hService, SERVICE_CONTROL_STOP, &Status))
        {
            TABSRVERR(("Failed to stop service (err=%d).\n", GetLastError()));
        }
        CloseServiceHandle(hService);
    }
    else
    {
        TABSRVERR(("Failed to open service for stop.\n"));
    }

    CloseServiceHandle(hSCM);

    TRACEEXIT(("!\n"));
    return;
}       //StopTabSrv

/*++
    @doc    EXTERNAL

    @func   VOID | TabSrvServiceHandler | Service handler.

    @parm   IN DWORD | dwControl | Control code.

    @rvalue None.
--*/

VOID WINAPI
TabSrvServiceHandler(
    IN DWORD dwControl
    )
{
    TRACEPROC("TabSrvServiceHandler", 3)

    TRACEENTER(("(Control=%s)\n", LookupName(dwControl, ServiceControlNames)));

    switch (dwControl)
    {
        case SERVICE_CONTROL_INTERROGATE:
            SetServiceStatus(ghServStatus, &gServStatus);
            break;

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            SET_SERVICE_STATUS(SERVICE_STOP_PENDING);
            TabSrvTerminate(TRUE);
            break;

        default:
            TRACEWARN(("Unhandled control code (%s).\n",
                       LookupName(dwControl, ServiceControlNames)));
    }

    TRACEEXIT(("!\n"));
    return;
}       //TabSrvServiceHandler

#ifdef ALLOW_DEBUG
/*++
    @doc    EXTERNAL

    @func   BOOL | TabSrvConsoleHandler | Console control handler.

    @parm   IN DWORD | dwControl | Control code.

    @rvalue SUCCESS | Returns TRUE - handle the event.
    @rvalue FAILURE | Returns FALSE - do not handle the event.
--*/

BOOL WINAPI
TabSrvConsoleHandler(
    IN DWORD dwControl
    )
{
    TRACEPROC("TabSrvConsoleHandler", 3)
    BOOL rc = FALSE;

    TRACEENTER(("(Control=%s)\n", LookupName(dwControl, ConsoleControlNames)));

    switch (dwControl)
    {
        case CTRL_C_EVENT:
        case CTRL_BREAK_EVENT:
        case CTRL_CLOSE_EVENT:
            SET_SERVICE_STATUS(SERVICE_STOP_PENDING);
            TabSrvTerminate(TRUE);
            rc = TRUE;
            break;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //TabSrvConsoleHandler
#endif

/*++
    @doc    EXTERNAL

    @func   VOID | TabSrvMain | Service entry point.

    @parm   IN int | icArgs | Specifies number of command line arguments.
    @parm   IN PSZ * | apszArgs | Points to the array of argument strings.

    @rvalue None.
--*/

VOID WINAPI
TabSrvMain(
    IN DWORD   icArgs,
    IN LPTSTR *aptszArgs
    )
{
    TRACEPROC("TabSrvMain", 2)

    TRACEENTER(("(icArgs=%d,aptszArgs=%p)\n", icArgs, aptszArgs));

    if ((icArgs == 2) && (lstrcmpi(aptszArgs[1], TEXT("/config")) == 0))
    {
        SC_HANDLE hSCM;
        SC_HANDLE hService;

        hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
        TRACEASSERT(hSCM != NULL);

        hService = OpenService(hSCM,
                               gtszTabSrvName,
                               SERVICE_ALL_ACCESS | SERVICE_CHANGE_CONFIG);
        if (hService != NULL)
        {
            SetTabSrvConfig(hService);
            CloseServiceHandle(hService);
        }
        else
        {
            TABSRVERR(("Failed to open service for config.\n"));
        }
        CloseServiceHandle(hSCM);
    }

    InitializeListHead(&glistNotifyClients);

    ghcurPressHold = LoadCursor(ghMod, MAKEINTRESOURCE(IDC_PRESSHOLD));
    TRACEASSERT(ghcurPressHold != NULL);
    ghcurNormal = LoadCursor(ghMod, MAKEINTRESOURCE(IDC_NORMAL));
    TRACEASSERT(ghcurNormal != NULL);

    ghDesktopSwitchEvent = OpenEvent(SYNCHRONIZE,
                                     FALSE,
                                     TEXT("WinSta0_DesktopSwitch"));
    TRACEASSERT(ghDesktopSwitchEvent != NULL);

    ghmutNotifyList = CreateMutex(NULL, FALSE, NULL);
    TRACEASSERT(ghmutNotifyList != NULL);

    gdevDigitizer.hStopDeviceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    TRACEASSERT(gdevDigitizer.hStopDeviceEvent != NULL);
    FindThread(TSF_DIGITHREAD)->pvSDTParam = gdevDigitizer.hStopDeviceEvent;
    gdevButtons.hStopDeviceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    TRACEASSERT(gdevButtons.hStopDeviceEvent != NULL);
    FindThread(TSF_BUTTONTHREAD)->pvSDTParam = gdevButtons.hStopDeviceEvent;
    ghHotkeyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    TRACEASSERT(ghHotkeyEvent != NULL);
    ghRefreshEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    TRACEASSERT(ghRefreshEvent != NULL);

    gServStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    gServStatus.dwCurrentState = SERVICE_START_PENDING;
    gServStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                     SERVICE_ACCEPT_SHUTDOWN;
    gServStatus.dwWin32ExitCode = NO_ERROR;
    gServStatus.dwServiceSpecificExitCode = NO_ERROR;
    gServStatus.dwCheckPoint = 0;
    gServStatus.dwWaitHint = 0;
    UpdateRotation();

    if (!(gdwfTabSrv & TSF_DEBUG_MODE))
    {
        ghServStatus = RegisterServiceCtrlHandler(gtszTabSrvName,
                                                  TabSrvServiceHandler);
        TRACEASSERT(ghServStatus != NULL);
        SetServiceStatus(ghServStatus, &gServStatus);
    }

    //
    // For a noninteractive service application to interact with the user,
    // it must open the user's window station ("WinSta0") and desktop
    // ("Default").
    //
    HWINSTA hwinstaSave = GetProcessWindowStation();
    HWINSTA hwinsta = OpenWindowStation(TEXT("WinSta0"),
                                        FALSE,
                                        MAXIMUM_ALLOWED);
    TRACEASSERT(hwinstaSave != NULL);
    if (hwinsta != NULL)
    {
        SetProcessWindowStation(hwinsta);
        InitConfigFromReg();
        GetInputDesktopName(gtszInputDesktop, sizeof(gtszInputDesktop));
        if (InitThreads(gTabSrvThreads, NUM_THREADS))
        {
            SET_SERVICE_STATUS(SERVICE_RUNNING);
            WaitForTermination();
            SET_SERVICE_STATUS(SERVICE_STOPPED);
        }
        else
        {
            TabSrvTerminate(TRUE);
        }

        if (hwinstaSave != NULL)
        {
            SetProcessWindowStation(hwinstaSave);
        }
        CloseWindowStation(hwinsta);
    }
    else
    {
        TABSRVERR(("Failed to open window station.\n"));
    }

    DWORD rcWait = WaitForSingleObject(ghmutNotifyList, INFINITE);
    if (rcWait == WAIT_OBJECT_0)
    {
        PLIST_ENTRY plist;
        PNOTIFYCLIENT NotifyClient;

        while (!IsListEmpty(&glistNotifyClients))
        {
            plist = RemoveHeadList(&glistNotifyClients);
            NotifyClient = CONTAINING_RECORD(plist, NOTIFYCLIENT, list);
            free(NotifyClient);
        }
        ReleaseMutex(ghmutNotifyList);
    }
    else
    {
        TABSRVERR(("Failed to wait for RawPtList Mutex (rcWait=%x,err=%d).\n",
                   rcWait, GetLastError()));
    }

    CloseHandle(ghRefreshEvent);
    CloseHandle(ghHotkeyEvent);
    CloseHandle(gdevDigitizer.hStopDeviceEvent);
    CloseHandle(gdevButtons.hStopDeviceEvent);
    ghHotkeyEvent = NULL;
    gdevDigitizer.hStopDeviceEvent = NULL;
    gdevButtons.hStopDeviceEvent = NULL;
    CloseHandle(ghmutNotifyList);
    ghmutNotifyList = NULL;
    CloseHandle(ghDesktopSwitchEvent);
    ghDesktopSwitchEvent = NULL;
    DestroyCursor(ghcurNormal);
    ghcurNormal = NULL;
    DestroyCursor(ghcurPressHold);
    ghcurPressHold = NULL;
    gdwfTabSrv = 0;
    TRACEINFO(1, ("Out of here.\n"));

    TRACEEXIT(("!\n"));
    return;
}       //TabSrvMain

/*++
    @doc    INTERNAL

    @func   VOID | InitConfigFromReg | Initialize configuration from registry.

    @parm   None.

    @rvalue None.
--*/

VOID
InitConfigFromReg(
    VOID
    )
{
    TRACEPROC("InitConfigFromReg", 2)
    LONG rcCfg;
    LPTSTR lptstrPenTilt;
    PTSTHREAD MouseThread;

    TRACEENTER(("()\n"));

    rcCfg = ReadConfig(gtszGestureSettings,
                       (LPBYTE)&gConfig.GestureSettings,
                       sizeof(gConfig.GestureSettings));
    if ((rcCfg != ERROR_SUCCESS) ||
        (gConfig.GestureSettings.dwcbLen != sizeof(gConfig.GestureSettings)))
    {
        if (rcCfg == ERROR_SUCCESS)
        {
            TABSRVERR(("Incorrect size on GestureSettings, use default.\n"));
        }
        gConfig.GestureSettings = gDefGestureSettings;
    }

    MouseThread = FindThread(TSF_MOUSETHREAD);
    if (MouseThread != NULL)
    {
        if (gConfig.GestureSettings.dwfFeatures & GESTURE_FEATURE_MOUSE_ENABLED)
        {
            MouseThread->dwfThread |= THREADF_ENABLED;
        }
        else
        {
            MouseThread->dwfThread &= ~THREADF_ENABLED;
        }
    }

    lptstrPenTilt = (gdwfTabSrv & TSF_PORTRAIT_MODE)?
                    TEXT("PenTilt_Portrait"): TEXT("PenTilt_Landscape"),
    rcCfg = ReadConfig(lptstrPenTilt,
                       (LPBYTE)&gConfig.PenTilt,
                       sizeof(gConfig.PenTilt));

    rcCfg = ReadConfig(gtszLinearityMap,
                       (LPBYTE)&gConfig.LinearityMap,
                       sizeof(gConfig.LinearityMap));
    if ((rcCfg == ERROR_SUCCESS) &&
        (gConfig.LinearityMap.dwcbLen == sizeof(gConfig.LinearityMap)))
    {
        gdwfTabSrv |= TSF_HAS_LINEAR_MAP;
    }

    rcCfg = ReadConfig(gtszButtonSettings,
                       (LPBYTE)&gConfig.ButtonSettings,
                       sizeof(gConfig.ButtonSettings));
    if ((rcCfg != ERROR_SUCCESS) ||
        (gConfig.ButtonSettings.dwcbLen != sizeof(gConfig.ButtonSettings)))
    {
        if (rcCfg == ERROR_SUCCESS)
        {
            TABSRVERR(("Incorrect size on ButtonSettings, use default.\n"));
        }
        gConfig.ButtonSettings = gDefButtonSettings;
    }

    BOOL fPortraitMode2 = FALSE;
    rcCfg = ReadConfig(gtszPortraitMode2,
                       (LPBYTE)&fPortraitMode2,
                       sizeof(fPortraitMode2));
    if ((rcCfg == ERROR_SUCCESS) && fPortraitMode2)
    {
        gdwfTabSrv |= TSF_PORTRAIT_MODE2;
    }

    TRACEEXIT(("!\n"));
    return;
}       //InitConfigFromReg

/*++
    @doc    INTERNAL

    @func   BOOL | InitThreads | Initialize various threads.

    @parm   PTSTHREAD | pThreads | Points to the thread array for the threads
            to start.
    @parm   int | nThreads | Specifies the number of threads in the array.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
InitThreads(
    IN PTSTHREAD pThreads,
    IN int       nThreads
    )
{
    TRACEPROC("InitThreads", 2)
    BOOL rc = TRUE;
    int i;
    unsigned uThreadID;

    TRACEENTER(("(pThreads=%p,NumThreads=%d)\n", pThreads, nThreads));

    for (i = 0; i < nThreads; ++i)
    {
        if (pThreads[i].dwfThread & THREADF_ENABLED)
        {
            pThreads[i].hThread = (HANDLE)_beginthreadex(
                                                    NULL,
                                                    0,
                                                    pThreads[i].pfnThread,
                                                    pThreads[i].pvParam?
                                                        pThreads[i].pvParam:
                                                        &pThreads[i],
                                                    0,
                                                    &uThreadID);
            if (pThreads[i].hThread != NULL)
            {
                gdwfTabSrv |= pThreads[i].dwThreadTag;
            }
            else
            {
                TABSRVERR(("Failed to create %s thread, LastError=%d.\n",
                           pThreads[i].pszThreadName, GetLastError()));
                rc = FALSE;
                break;
            }
        }
    }
    SetEvent(ghRefreshEvent);

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //InitThreads

/*++
    @doc    INTERNAL

    @func   PTSTHREAD | FindThread | Find a thread in the thread table.

    @parm   DWORD | dwThreadTag | Specifies the thread to look for.

    @rvalue SUCCESS | Returns pointer to the thread entry in table.
    @rvalue FAILURE | Returns NULL.
--*/

PTSTHREAD
FindThread(
    IN DWORD dwThreadTag
    )
{
    TRACEPROC("FindThread", 2)
    PTSTHREAD Thread = NULL;
    int i;

    TRACEENTER(("(ThreadTag=%x)\n", dwThreadTag));

    for (i = 0; i < NUM_THREADS; ++i)
    {
        if (gTabSrvThreads[i].dwThreadTag == dwThreadTag)
        {
            Thread = &gTabSrvThreads[i];
            break;
        }
    }

    TRACEEXIT(("=%p\n", Thread));
    return Thread;
}       //FindThread

/*++
    @doc    INTERNAL

    @func   VOID | WaitForTermination | Wait for termination.

    @parm   None.

    @rvalue None.
--*/

VOID
WaitForTermination(
    VOID
    )
{
    TRACEPROC("WaitForTermination", 2)
    HANDLE ahWait[NUM_THREADS + 3];
    DWORD rcWait;
    int i;

    TRACEENTER(("()\n"));

    ahWait[0] = ghDesktopSwitchEvent;
    ahWait[1] = ghHotkeyEvent;
    ahWait[2] = ghRefreshEvent;

    //
    // Wait for termination.
    //
    for (;;)
    {
        DWORD n = 3;

        for (i = 0; i < NUM_THREADS; ++i)
        {
            if (gTabSrvThreads[i].hThread != NULL)
            {
                ahWait[n] = gTabSrvThreads[i].hThread;
                gTabSrvThreads[i].iThreadStatus = WAIT_OBJECT_0 + n;
                n++;
            }
            else
            {
                gTabSrvThreads[i].iThreadStatus = -1;
            }
        }

        rcWait = WaitForMultipleObjects(n, ahWait, FALSE, INFINITE);
        if ((rcWait == WAIT_OBJECT_0) || (rcWait == WAIT_OBJECT_0 + 1))
        {
            TCHAR tszDesktop[32];
            BOOL fDoSwitch = TRUE;

            if (rcWait == WAIT_OBJECT_0 + 1)
            {
                //
                // Send hot key event and tell all threads to switch.
                //
                TRACEINFO(1, ("Send Hotkey.\n"));
                SendAltCtrlDel();
                if (GetInputDesktopName(tszDesktop, sizeof(tszDesktop)))
                {
                    TRACEINFO(1, ("[CAD] New input desktop=%s\n", tszDesktop));
                    lstrcpyn(gtszInputDesktop,
                             tszDesktop,
                             ARRAYSIZE(gtszInputDesktop));
                }
            }
            else if (GetInputDesktopName(tszDesktop, sizeof(tszDesktop)))
            {
                if (lstrcmpi(tszDesktop, gtszInputDesktop) == 0)
                {
                    //
                    // It seems that when the user logs off, two desktop
                    // switches are signaled in quick succession.  The
                    // desktop is still 'Default' after the first switch
                    // is signaled.  So we don't really want to switch
                    // all threads to the same desktop.
                    //
                    TRACEINFO(1, ("Same desktop, don't switch (Desktop=%s).\n",
                                  tszDesktop));
                    fDoSwitch = FALSE;
                }
                else
                {
                    TRACEINFO(1, ("New input desktop=%s\n", tszDesktop));
                    lstrcpyn(gtszInputDesktop,
                             tszDesktop,
                             ARRAYSIZE(gtszInputDesktop));
                }
            }

            if (fDoSwitch)
            {
                //
                // We are swtiching, tell all threads that need to switch
                // desktop to switch.
                //
                TabSrvTerminate(FALSE);
            }
        }
        else if (rcWait != WAIT_OBJECT_0 + 2)
        {
            for (i = 0; i < NUM_THREADS; ++i)
            {
                if (rcWait == (DWORD)gTabSrvThreads[i].iThreadStatus)
                {
                    CloseHandle(gTabSrvThreads[i].hThread);
                    gTabSrvThreads[i].hThread = NULL;
                    gdwfTabSrv &= ~gTabSrvThreads[i].dwThreadTag;
                    TRACEINFO(1, ("%s thread is killed.\n",
                                  gTabSrvThreads[i].pszThreadName));
                    //
                    // If a thread died unexpectedly and it is marked
                    // restartable, restart it.
                    //
                    if (!(gdwfTabSrv & TSF_TERMINATE) &&
                        (gTabSrvThreads[i].dwfThread & THREADF_RESTARTABLE))
                    {
                        if (gTabSrvThreads[i].dwcRestartTries < MAX_RESTARTS)
                        {
                            TRACEINFO(1, ("%s thread died unexpectedly, restarting (count=%d)\n",
                                          gTabSrvThreads[i].pszThreadName,
                                          gTabSrvThreads[i].dwcRestartTries));
                            InitThreads(&gTabSrvThreads[i], 1);
                            gTabSrvThreads[i].dwcRestartTries++;
                        }
                        else
                        {
                            TABSRVERR(("%s thread exceeds restart maximum.\n",
                                       gTabSrvThreads[i].pszThreadName));
                        }
                    }
                    break;
                }
            }

            if (i == NUM_THREADS)
            {
                TABSRVERR(("WaitForMultipleObjects failed (rcWait=%x,err=%d).\n",
                           rcWait, GetLastError()));
                break;
            }
        }

        if (!(gdwfTabSrv & TSF_ALLTHREAD))
        {
            //
            // All threads are dead, we can quit now.
            //
            break;
        }
    }

    TRACEEXIT(("!\n"));
    return;
}       //WaitForTermination

/*++
    @doc    INTERNAL

    @func   VOID | TabSrvTerminate | Do clean up.

    @parm   IN BOOL | fTerminate | TRUE if real termination, otherwise
            switching desktop.

    @rvalue None.
--*/

VOID
TabSrvTerminate(
    IN BOOL fTerminate
    )
{
    TRACEPROC("TabSrvTerminate", 2)
    int i;

    TRACEENTER(("(fTerminate=%x)\n", fTerminate));

    if (fTerminate)
    {
        gdwfTabSrv |= TSF_TERMINATE;
    }

    for (i = 0; i < NUM_THREADS; ++i)
    {
        if (gTabSrvThreads[i].dwfThread &
            (THREADF_SDT_POSTMSG | THREADF_SDT_SETEVENT))
        {
            if (gdwfTabSrv & gTabSrvThreads[i].dwThreadTag)
            {
                TRACEINFO(1, (fTerminate? "Kill %s thread.\n":
                                          "Switch %s thread desktop.\n",
                              gTabSrvThreads[i].pszThreadName));
                TRACEASSERT(gTabSrvThreads[i].pvSDTParam != NULL);

                if (gTabSrvThreads[i].dwfThread & THREADF_SDT_POSTMSG)
                {
                    if (IsWindow((HWND)gTabSrvThreads[i].pvSDTParam))
                    {
                        PostMessage((HWND)gTabSrvThreads[i].pvSDTParam,
                                    WM_CLOSE,
                                    0,
                                    0);
                    }
                    else
                    {
                        TRACEINFO(1, ("%s thread window handle (%x) is not valid.\n",
                                      gTabSrvThreads[i].pszThreadName,
                                      gTabSrvThreads[i].pvSDTParam));
                    }
                }
                else
                {
                    SetEvent((HANDLE)gTabSrvThreads[i].pvSDTParam);
                }
            }
            else if (!fTerminate &&
                     (gTabSrvThreads[i].dwcRestartTries >= MAX_RESTARTS))
            {
                TRACEINFO(1, ("Retrying to start %s thread.\n",
                              gTabSrvThreads[i].pszThreadName));
                InitThreads(&gTabSrvThreads[i], 1);
                gTabSrvThreads[i].dwcRestartTries = 1;
            }
        }
    }

    if (fTerminate && (gdwfTabSrv & TSF_RPCTHREAD))
    {
        RpcMgmtStopServerListening(NULL);
    }

    TRACEEXIT(("!\n"));
    return;
}       //TabSrvTerminate

/*++
    @doc    INTERNAL

    @func   VOID | TabSrvLogError | Log the error in the event log.

    @parm   IN PSZ | pszFormat | Points to the format string.
    @parm   ... | String arguments.

    @rvalue None.
--*/

VOID
TabSrvLogError(
    IN PSZ pszFormat,
    ...
    )
{
    TRACEPROC("TabSrvLogError", 5)

    TRACEENTER(("(Format=%s,...)\n", pszFormat));

    if (!(gdwfTabSrv & TSF_DEBUG_MODE))
    {
        HANDLE hEventLog;

        hEventLog = RegisterEventSource(NULL, TEXT(STR_TABSRV_NAME));
        if (hEventLog != NULL)
        {
            char szMsg[256];
            LPCSTR psz = szMsg;
            va_list arglist;

            va_start(arglist, pszFormat);
            wvsprintfA(szMsg, pszFormat, arglist);
            va_end(arglist);

            ReportEventA(hEventLog,             //handle of event source
                         EVENTLOG_ERROR_TYPE,   //event type
                         0,                     //event category
                         0,                     //event ID
                         NULL,                  //current user's SID
                         1,                     //number of strings
                         0,                     //size of raw data
                         &psz,                  //array of strings
                         NULL);                 //no raw data
            DeregisterEventSource(hEventLog);
        }
    }

    TRACEEXIT(("!\n"));
    return;
}       //TabSrvLogError

/*++
    @doc    INTERNAL

    @func   LONG | ReadConfig | Read TabSrv configuration from registry.

    @parm   IN LPCTSTR | lptstrValueName | Points to the registry value
            name string.
    @parm   OUT LPBYTE | lpbData | Points to the buffer to hold the value
            read.
    @parm   IN DWORD | dwcb | Specifies the size of the buffer.

    @rvalue SUCCESS | Returns ERROR_SUCCESS.
    @rvalue FAILURE | Returns registry error code.
--*/

LONG
ReadConfig(
    IN  LPCTSTR lptstrValueName,
    OUT LPBYTE  lpbData,
    IN  DWORD   dwcb
    )
{
    TRACEPROC("ReadConfig", 3)
    LONG rc;
    HKEY hkey;

    TRACEENTER(("(Name=%s,pData=%p,Len=%d)\n", lptstrValueName, lpbData, dwcb));

    rc = RegCreateKey(HKEY_LOCAL_MACHINE,
                      gtszRegPath,
                      &hkey);
    if (rc == ERROR_SUCCESS)
    {
        rc = RegQueryValueEx(hkey,
                             lptstrValueName,
                             NULL,
                             NULL,
                             lpbData,
                             &dwcb);
        if (rc != ERROR_SUCCESS)
        {
            TRACEWARN(("Failed to read \"%s\" from registry (rc=%d).\n",
                       lptstrValueName, rc));
        }

        RegCloseKey(hkey);
    }
    else
    {
        TABSRVERR(("Failed to open registry key to read configuration (rc=%d).\n",
                   rc));
    }

    TRACEEXIT(("=%d\n", rc));
    return rc;
}       //ReadConfig

/*++
    @doc    INTERNAL

    @func   LONG | WriteConfig | Write TabSrv configuration to registry.

    @parm   IN LPCTSTR | lptstrValueName | Points to the registry value
            name string.
    @parm   IN DWORD | dwType | Specifies the registry value type.
            name string.
    @parm   IN LPBYTE | lpbData | Points to the buffer to hold the value
            read.
    @parm   IN DWORD | dwcb | Specifies the size of the buffer.

    @rvalue SUCCESS | Returns ERROR_SUCCESS.
    @rvalue FAILURE | Returns registry error code.
--*/

LONG
WriteConfig(
    IN LPCTSTR lptstrValueName,
    IN DWORD   dwType,
    IN LPBYTE  lpbData,
    IN DWORD   dwcb
    )
{
    TRACEPROC("WriteConfig", 3)
    LONG rc;
    HKEY hkey;

    TRACEENTER(("(Name=%s,Type=%d,pData=%p,Len=%d)\n",
                lptstrValueName, dwType, lpbData, dwcb));

    rc = RegCreateKey(HKEY_LOCAL_MACHINE,
                      gtszRegPath,
                      &hkey);
    if (rc == ERROR_SUCCESS)
    {
        rc = RegSetValueEx(hkey,
                           lptstrValueName,
                           0,
                           dwType,
                           lpbData,
                           dwcb);
        if (rc != ERROR_SUCCESS)
        {
            TRACEWARN(("Failed to write \"%s\" to registry (rc=%d).\n",
                       lptstrValueName, rc));
        }
        RegCloseKey(hkey);
    }
    else
    {
        TABSRVERR(("Failed to create registry key to write configuration (rc=%d).\n",
                   rc));
    }

    TRACEEXIT(("=%d\n", rc));
    return rc;
}       //WriteConfig

/*++
    @doc    INTERNAL

    @func   HRESULT | GetRegValueString | Get registry string value.

    @parm   IN HKEY | hkeyTopLevel | Top level registry key.
    @parm   IN LPCTSTR | pszSubKey | Subkey string.
    @parm   IN LPCTSTR | pszValueName | Value name string.
    @parm   OUT LPTSTR | pszValueString | To hold value string.
    @parm   IN OUT LPDWORD | lpdwcb | Specify size of ValueString and to hold
            result string size.

    @rvalue SUCCESS | Returns ERROR_SUCCESS.
    @rvalue FAILURE | Returns registry error code.
--*/

LONG
GetRegValueString(
    IN     HKEY    hkeyTopLevel,
    IN     LPCTSTR pszSubKey,
    IN     LPCTSTR pszValueName,
    OUT    LPTSTR  pszValueString,
    IN OUT LPDWORD lpdwcb
    )
{
    TRACEPROC("GetRegValueString", 3)
    LONG rc;
    HKEY hkey;

    TRACEASSERT(lpdwcb != NULL);
    TRACEASSERT((pszValueString != NULL) || (*lpdwcb == 0));
    TRACEENTER(("(hkTop=%x,SubKey=%s,ValueName=%s,ValueString=%p,Len=%d)\n",
                hkeyTopLevel, pszSubKey, pszValueName, pszValueString,
                *lpdwcb));

    if (pszValueString != NULL)
    {
        pszValueString[0] = TEXT('\0');
    }

    rc = RegOpenKeyEx(hkeyTopLevel, pszSubKey, 0, KEY_READ, &hkey);
    if (rc == ERROR_SUCCESS)
    {
        DWORD dwType = 0;

        rc = RegQueryValueEx(hkey,
                             pszValueName,
                             0,
                             &dwType,
                             (LPBYTE)pszValueString,
                             lpdwcb);
        if (rc == ERROR_SUCCESS)
        {
            if (dwType != REG_SZ)
            {
                TABSRVERR(("Invalid registry data type (type=%x).\n", dwType));
                rc = ERROR_INVALID_DATATYPE;
            }
        }
        else
        {
            TABSRVERR(("Failed to read registry value %s\\%s (rc=%x).\n",
                       pszSubKey, pszValueName, rc));
        }
        RegCloseKey(hkey);
    }
    else
    {
        TABSRVERR(("Failed to open registry key %s (rc=%x).\n",
                   pszSubKey, rc));
    }

    TRACEEXIT(("=%d\n", rc));
    return rc;
}       //GetRegValueString

/*++
    @doc    INTERNAL

    @func   BOOL | SwitchThreadToInputDesktop | Switch thread to current
            input desktop.

    @parm   IN PTSTHREAD | pThread | Points to the thread structure.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
SwitchThreadToInputDesktop(
    IN PTSTHREAD pThread
    )
{
    TRACEPROC("SwitchThreadToInputDesktop", 2)
    BOOL rc = TRUE;
    HDESK hdesk;

    TRACEENTER(("(pThread=%p)\n", pThread));

    hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (hdesk == NULL)
    {
        TRACEWARN(("Failed to open input desktop (err=%d), try Winlogon ...\n",
                   GetLastError()));

        hdesk = OpenDesktop(TEXT("Winlogon"), 0, FALSE, MAXIMUM_ALLOWED);
        if (hdesk == NULL)
        {
            TABSRVERR(("Failed to open winlogon desktop (err=%d).\n",
                       GetLastError()));
            rc = FALSE;
        }
    }

    if (rc == TRUE)
    {
        CloseDesktop(GetThreadDesktop(GetCurrentThreadId()));

        rc = SetThreadDesktop(hdesk);
        if (rc)
        {
            TCHAR tszDesktop[32];
            DWORD dwcb;

            if (GetUserObjectInformation(hdesk,
                                         UOI_NAME,
                                         tszDesktop,
                                         sizeof(tszDesktop),
                                         &dwcb))
            {
                TRACEINFO(1, ("Switch to Input desktop %s.\n", tszDesktop));
                if (lstrcmpi(tszDesktop, TEXT("Winlogon")) == 0)
                {
                    pThread->dwfThread |= THREADF_DESKTOP_WINLOGON;
                }
                else
                {
                    pThread->dwfThread &= ~THREADF_DESKTOP_WINLOGON;
                }

                if (lstrcmpi(tszDesktop, gtszInputDesktop) != 0)
                {
                    TRACEINFO(1, ("Input desktop name out of sync (old=%s, new=%s).\n",
                                  gtszInputDesktop, tszDesktop));
                    lstrcpyn(gtszInputDesktop,
                             tszDesktop,
                             ARRAYSIZE(gtszInputDesktop));
                }
            }
        }
        else
        {
            TABSRVERR(("Failed to set thread desktop (err=%d)\n",
                       GetLastError()));
        }
    }
    else
    {
        TABSRVERR(("Failed to open input desktop (err=%d)\n", GetLastError()));
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //SwitchThreadToInputDesktop

/*++
    @doc    INTERNAL

    @func   BOOL | GetInputDesktopName | Get current input desktop name.

    @parm   OUT LPTSTR | pszDesktopName | Point to a buffer to hold the desktop
            name.
    @parm   IN DWORD | dwcbLen | Specifies length of buffer.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
GetInputDesktopName(
    OUT LPTSTR pszDesktopName,
    IN  DWORD  dwcbLen
    )
{
    TRACEPROC("GetInputDesktopName", 2)
    BOOL rc = FALSE;
    HDESK hdesk;

    TRACEENTER(("(pszDesktopName=%p,Len=%d)\n", pszDesktopName, dwcbLen));

    hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (hdesk == NULL)
    {
        TRACEWARN(("Failed to open input desktop (err=%d), try Winlogon ...\n",
                   GetLastError()));

        hdesk = OpenDesktop(TEXT("Winlogon"), 0, FALSE, MAXIMUM_ALLOWED);
        if (hdesk == NULL)
        {
            TABSRVERR(("Failed to open winlogon desktop (err=%d).\n",
                       GetLastError()));
        }
    }

    if (hdesk != NULL)
    {
        if (GetUserObjectInformation(hdesk,
                                     UOI_NAME,
                                     pszDesktopName,
                                     dwcbLen,
                                     &dwcbLen))
        {
            rc = TRUE;
        }
        else
        {
            TRACEWARN(("Failed to get desktop name (err=%d).\n",
                       GetLastError()));
        }
        CloseDesktop(hdesk);
    }
    else
    {
        TRACEWARN(("failed to open input desktop (err=%d)\n", GetLastError()));
    }

    TRACEEXIT(("=%x (DeskTopName=%s)\n", rc, pszDesktopName));
    return rc;
}       //GetInputDesktopName

/*++
    @doc    INTERNAL

    @func   VOID | SendAltCtrlDel | Send Alt+Ctrl+Del

    @parm   None.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
SendAltCtrlDel(
    VOID
    )
{
    TRACEPROC("SendAltCtrlDel", 2)
    BOOL rc = FALSE;
    HWINSTA hwinstaSave;
    HDESK hdeskSave;

    TRACEENTER(("()\n"));

    hwinstaSave = GetProcessWindowStation();
    hdeskSave = GetThreadDesktop(GetCurrentThreadId());

    if ((hwinstaSave != NULL) && (hdeskSave != NULL))
    {
        HWINSTA hwinsta;
        HDESK hdesk;

        hwinsta = OpenWindowStation(TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);
        if (hwinsta != NULL)
        {
            SetProcessWindowStation(hwinsta);
            hdesk = OpenDesktop(TEXT("Winlogon"), 0, FALSE, MAXIMUM_ALLOWED);
            if (hdesk != NULL)
            {
                HWND hwndSAS;

                SetThreadDesktop(hdesk);
                hwndSAS = FindWindow(NULL, TEXT("SAS window"));
                if (hwndSAS != NULL)
                {
                    SendMessage(hwndSAS, WM_HOTKEY, 0, 0);
                    rc = TRUE;
                }
                else
                {
                    TABSRVERR(("Failed to find SAS window (err=%d).\n",
                               GetLastError()));
                }
                SetThreadDesktop(hdeskSave);
                CloseDesktop(hdesk);
            }
            else
            {
                TABSRVERR(("Failed to open Winlogon (err=%d).\n",
                           GetLastError()));
            }
            SetProcessWindowStation(hwinsta);
            CloseWindowStation(hwinsta);
        }
        else
        {
            TABSRVERR(("Failed to open WinSta0 (err=%d).\n", GetLastError()));
        }
    }
    else
    {
        TABSRVERR(("GetProcessWindowStation or GetThreadDesktop failed (err=%d,hwinsta=%x,hdesk=%x).\n",
                   GetLastError(), hwinstaSave, hdeskSave));
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //SendAltCtrlDel

/*++
    @doc    INTERNAL

    @func   VOID | NotifyClient | Check if we need to notify anybody.

    @parm   IN EVTNOTIFY | Event | Event to broadcast.
    @parm   IN WPARAM | wParam | wParam to send in the message.
    @parm   IN LPARAM | lParam | lParam to send in the message.

    @rvalue None.
--*/

VOID
NotifyClient(
    IN EVTNOTIFY Event,
    IN WPARAM    wParam,
    IN LPARAM    lParam
    )
{
    TRACEPROC("NotifyClient", 5)

    TRACEENTER(("(Event=%x,wParam=%x,lParam=%x)\n", Event, wParam, lParam));

    if (!IsListEmpty(&glistNotifyClients))
    {
        DWORD rcWait;
        PLIST_ENTRY plist;
        PNOTIFYCLIENT Client;

        rcWait = WaitForSingleObject(ghmutNotifyList, INFINITE);
        if (rcWait == WAIT_OBJECT_0)
        {
            for (plist = glistNotifyClients.Flink;
                 plist != &glistNotifyClients; plist = plist->Flink)
            {
                Client = CONTAINING_RECORD(plist,
                                           NOTIFYCLIENT,
                                           list);
                if (Client->Event == Event)
                {
                    PostMessage(Client->hwnd,
                                Client->uiMsg,
                                wParam,
                                lParam);
                }
            }
            ReleaseMutex(ghmutNotifyList);
        }
        else
        {
            TABSRVERR(("failed to wait for Notify list mutex (rcWait=%x,err=%d).\n",
                       rcWait, GetLastError()));
        }
    }

    TRACEEXIT(("!\n"));
    return;
}       //NotifyClient

/*++
    @doc    INTERNAL

    @func   BOOL | ImpersonateCurrentUser | Impersonate current logged on user.

    @parm   None.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
ImpersonateCurrentUser(
    VOID
    )
{
    TRACEPROC("ImpersonateCurrentUser", 3)
    BOOL rc = FALSE;
    HANDLE hToken;

    TRACEENTER(("()\n"));

    hToken = GetCurrentUserTokenW(L"WinSta0", TOKEN_ALL_ACCESS);
    if (hToken != NULL)
    {
        rc = ImpersonateLoggedOnUser(hToken);

        if (rc == FALSE)
        {
            TABSRVERR(("Failed to impersonate logged on user (err=%d).\n",
                       GetLastError()));
        }
        CloseHandle(hToken);
    }
    else
    {
        DWORD dwError = GetLastError();

        if (dwError != ERROR_NOT_LOGGED_ON)
        {
            TABSRVERR(("Failed to get current user token (err=%d)\n",
                       dwError));
        }
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //ImpersonateCurrentUser

/*++
    @doc    INTERNAL

    @func   BOOL | RunProcessAsUser | Run a process as the logged on user.

    @parm   IN LPTSTR | pszCmd | Process command.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
RunProcessAsUser(
    IN LPTSTR pszCmd
    )
{
    TRACEPROC("RunProcessAsUser", 3)
    BOOL rc = FALSE;
    HANDLE hImpersonateToken;
    HANDLE hPrimaryToken;

    TRACEENTER(("(Cmd=%s)\n", pszCmd));

    if (OpenThreadToken(GetCurrentThread(),
                        TOKEN_QUERY |
                        TOKEN_DUPLICATE |
                        TOKEN_ASSIGN_PRIMARY,
                        TRUE,
                        &hImpersonateToken))
    {
        if (DuplicateTokenEx(hImpersonateToken,
                             TOKEN_IMPERSONATE |
                             TOKEN_READ |
                             TOKEN_ASSIGN_PRIMARY |
                             TOKEN_DUPLICATE |
                             TOKEN_ADJUST_PRIVILEGES,
                             NULL,
                             SecurityImpersonation,
                             TokenPrimary,
                             &hPrimaryToken))
        {
            STARTUPINFO si;
            PROCESS_INFORMATION pi;
            LPVOID lpEnv = NULL;

            if (!CreateEnvironmentBlock(&lpEnv, hImpersonateToken, TRUE))
            {
                TABSRVERR(("Failed to create environment block (err=%d).\n",
                           GetLastError()));
                lpEnv = NULL;
            }

            memset(&si, 0, sizeof(si));
            si.cb = sizeof(si);
            si.lpDesktop = TEXT("WinSta0\\Default");

            if (CreateProcessAsUser(hPrimaryToken,
                                    NULL,
                                    pszCmd,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    NORMAL_PRIORITY_CLASS |
                                    CREATE_UNICODE_ENVIRONMENT,
                                    lpEnv,
                                    NULL,
                                    &si,
                                    &pi))
            {
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
                rc = TRUE;
            }
            else
            {
                TABSRVERR(("Failed to create process as user (err=%d).\n",
                           GetLastError()));
            }
            if (lpEnv != NULL)
            {
                DestroyEnvironmentBlock(lpEnv);
            }
            CloseHandle(hPrimaryToken);
        }
        else
        {
            TABSRVERR(("Failed to duplicate token (err=%d).\n",
                       GetLastError()));
        }
        CloseHandle(hImpersonateToken);
    }
    else
    {
        TABSRVERR(("Failed to open thread token (err=%d).\n",
                   GetLastError()));
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //RunProcessAsUser

/*++
    @doc    EXTERNAL

    @func   void __RPC_FAR * | MIDL_user_allocate | MIDL allocate.

    @parm   IN size_t | len | size of allocation.

    @rvalue SUCCESS | Returns the pointer to the memory allocated.
    @rvalue FAILURE | Returns NULL.
--*/

void __RPC_FAR * __RPC_USER
MIDL_user_allocate(
    IN size_t len
    )
{
    TRACEPROC("MIDL_user_allocate", 5)
    void __RPC_FAR *ptr;

    TRACEENTER(("(len=%d)\n", len));

    ptr = malloc(len);

    TRACEEXIT(("=%p\n", ptr));
    return ptr;
}       //MIDL_user_allocate

/*++
    @doc    EXTERNAL

    @func   void | MIDL_user_free | MIDL free.

    @parm   IN void __PRC_FAR * | ptr | Points to the memory to be freed.

    @rvalue None.
--*/

void __RPC_USER
MIDL_user_free(
    IN void __RPC_FAR *ptr
    )
{
    TRACEPROC("MIDL_user_free", 5)

    TRACEENTER(("(ptr=%p)\n", ptr));

    free(ptr);

    TRACEEXIT(("!\n"));
    return;
}       //MIDL_user_free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\tabdev.cpp ===
/*++
    Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

    Module Name:
        tabdev.cpp

    Abstract:
        This module contains tablet device functions.

    Author:
        Michael Tsang (MikeTs) 01-Jun-2000

    Environment:
        User mode

    Revision History:
--*/

#include "pch.h"

/*++
    @doc    INTERNAL

    @func   unsigned | DeviceThread | Device thread.

    @parm   IN OUT PDEVICE_DATA | pdevdata | Points to device data.

    @rvalue Always returns 0.
--*/

unsigned __stdcall
DeviceThread(
    IN PVOID param
    )
{
    TRACEPROC("DeviceThread", 2)
    PDEVICE_DATA pdevdata = (PDEVICE_DATA)param;
    BOOL fDigitizer = (pdevdata == &gdevDigitizer);
    BOOL fSuccess = TRUE;

    TRACEENTER(("(pdevdata=%p,Thread=%s)\n",
                pdevdata, fDigitizer? "Digitizer": "Buttons"));

    // Bump our priority so we can service device data ASAP.
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

    if (OpenTabletDevice(pdevdata))
    {
        OVERLAPPED overLapped;
        HANDLE ahWait[2];
        PCHAR apBuf[2];

        // Initialize the OVERLAPPED structure for ReadFile
        overLapped.Offset = overLapped.OffsetHigh = 0;
        overLapped.hEvent = CreateEvent(NULL,       // default security
                                        FALSE,      // auto-reset event
                                        FALSE,      // initially unset
                                        NULL);      // no name
        TRACEASSERT(overLapped.hEvent != NULL);

        // Create the array of event handles to wait upon (below)
        ahWait[0] = pdevdata->hStopDeviceEvent;
        ahWait[1] = overLapped.hEvent;

        // Allocate and zero-init a couple of buffers for device reports
        apBuf[0] = (PCHAR)calloc(pdevdata->hidCaps.InputReportByteLength,
                                 sizeof(CHAR));
        apBuf[1] = (PCHAR)calloc(pdevdata->hidCaps.InputReportByteLength,
                                 sizeof(CHAR));
        TRACEASSERT(apBuf[0] && apBuf[1]);

        // Allocate a buffer for HID report button states
        pdevdata->dwcButtons = HidP_MaxUsageListLength(HidP_Input,
                                                       0,
                                                       pdevdata->pPreParsedData);
        if (pdevdata->dwcButtons > 0)
        {
            pdevdata->pDownButtonUsages = (PUSAGE)malloc(pdevdata->dwcButtons*
                                                         sizeof(USAGE));
            TRACEASSERT(pdevdata->pDownButtonUsages);
        }
        else
        {
            pdevdata->pDownButtonUsages = NULL;
        }

        if (fDigitizer)
        {
            // Determine the digitizer's (default) max X & Y values for scaling
            // the reports later
            GetMinMax(HID_USAGE_PAGE_GENERIC,
                      HID_USAGE_GENERIC_X,
                      &gdwMinX,
                      &gdwMaxX);
            gdwRngX = gdwMaxX - gdwMinX;

            GetMinMax(HID_USAGE_PAGE_GENERIC,
                      HID_USAGE_GENERIC_Y,
                      &gdwMinY, &gdwMaxY);
            gdwRngY = gdwMaxY - gdwMinY;
#ifdef DRAW_INK
            ghwndDrawInk = GetDesktopWindow();
#endif
        }

        PTSTHREAD pThread = FindThread(fDigitizer?
                                        TSF_DIGITHREAD: TSF_BUTTONTHREAD);
        while (fSuccess && !(gdwfTabSrv & TSF_TERMINATE))
        {
            if (SwitchThreadToInputDesktop(pThread))
            {
                BOOL fImpersonate = FALSE;
                int iBufIdx = 0;
                DWORD dwBytesRead;

                fImpersonate = ImpersonateCurrentUser();

                // Issue an overlapped read to get a device (input) report
                if (ReadReportOverlapped(pdevdata,
                                         apBuf[iBufIdx],
                                         &dwBytesRead,
                                         &overLapped))
                {
                    DWORD rcWait;
                    MSG Msg;

                    for (;;)
                    {
                        // Wait for the read to complete, or for the termination
                        // event to be set
                        if (fDigitizer)
                        {
                            rcWait = WaitForMultipleObjectsEx(2,
                                                              ahWait,
                                                              FALSE,
                                                              INFINITE,
                                                              FALSE);
                        }
                        else
                        {
                            rcWait = MsgWaitForMultipleObjects(2,
                                                               ahWait,
                                                               FALSE,
                                                               INFINITE,
                                                               QS_TIMER);
                        }

                        if (rcWait == WAIT_OBJECT_0)
                        {
                            // The terminate device event was set.
                            break;
                        }
                        else if (rcWait == WAIT_OBJECT_0 + 1)
                        {
                            DWORD dwcb;
                            // Previous read has completed, swap the buffer
                            // pointer and issue another overlapped read
                            // before processing this report.
                            PCHAR pBufLast = apBuf[iBufIdx];
                            iBufIdx ^= 1;

                            if (!GetOverlappedResult(pdevdata->hDevice,
                                                     &overLapped,
                                                     &dwcb,
                                                     FALSE))
                            {
                                TRACEWARN(("GetOverlappedResult failed (err=%d).\n",
                                           GetLastError()));
                                fSuccess = FALSE;
                            }
                            else
                            {
                                if (!ReadReportOverlapped(pdevdata,
                                                          apBuf[iBufIdx],
                                                          &dwBytesRead,
                                                          &overLapped))
                                {
                                    TABSRVERR(("Read error getting device report (err=%d)",
                                               GetLastError()));
                                    fSuccess = FALSE;
                                    break;
                                }

                                if (fDigitizer)
                                {
                                    ProcessDigitizerReport(pBufLast);
                                }
                                else
                                {
                                    ProcessButtonsReport(pBufLast);
                                }
                            }
                        }
                        else if (!fDigitizer &&
                                 PeekMessage(&Msg,
                                             NULL,
                                             WM_TIMER,
                                             WM_TIMER,
                                             PM_REMOVE | PM_NOYIELD))
                        {
                            ((TIMERPROC)Msg.lParam)(Msg.hwnd,
                                                    Msg.message,
                                                    Msg.wParam,
                                                    Msg.time);
                        }
                        else
                        {
                            TRACEWARN(("WaitForMultipleObject failed (rcWait=%d,err=%d)\n",
                                       rcWait, GetLastError()));
                        }
                    }
                    CancelIo(pdevdata->hDevice);
                }
                else
                {
                    TABSRVERR(("Read error getting device report (err=%d)",
                               GetLastError()));
                    fSuccess = FALSE;
                }

                if (fImpersonate)
                {
                    RevertToSelf();
                }
            }
            else
            {
                TABSRVERR(("Failed to set current desktop.\n"));
                fSuccess = FALSE;
            }
        }

        if (pdevdata->pDownButtonUsages)
        {
            free(pdevdata->pDownButtonUsages);
            pdevdata->pDownButtonUsages = NULL;
        }
        free(apBuf[0]);
        free(apBuf[1]);
        CloseHandle(overLapped.hEvent);
        CloseTabletDevice(pdevdata);
    }
    else
    {
        TABSRVERR(("Failed to open %s device.\n",
                   fDigitizer? "Digitizer": "Buttons"));
    }

    TRACEEXIT(("=0\n"));
    return 0;
}       //DeviceThread

/*++
    @doc    INTERNAL

    @func   BOOL | OpenTabletDevice | Open and initialize the tablet device.

    @parm   IN OUT PDEVICE_DATA | pDevData | Points to the tablet device data.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
OpenTabletDevice(
    IN OUT PDEVICE_DATA pDevData
    )
{
    TRACEPROC("OpenTabletDevice", 2)
    BOOL     rc = FALSE;
    GUID     hidGuid;
    HDEVINFO hDevInfo;

    TRACEENTER(("(pDevData=%p,UsagePage=%x,Usage=%x)\n",
                pDevData, pDevData->UsagePage, pDevData->Usage));

    pDevData->hDevice = INVALID_HANDLE_VALUE;

    // Get the GUID for HID devices
    HidD_GetHidGuid(&hidGuid);

    // Get handle to present HID devices
    hDevInfo = SetupDiGetClassDevs(&hidGuid,
                                   NULL,
                                   NULL,
                                   (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));

    if (hDevInfo != INVALID_HANDLE_VALUE)
    {
        ULONG i;

        // Enumerate the HID devices, looking for the digitizer and button devices
        for (i = 0; ; ++i)
        {
            SP_DEVICE_INTERFACE_DATA devInterface;
            devInterface.cbSize = sizeof(devInterface);

            // First we have to enumerate the device interfaces
            if (SetupDiEnumDeviceInterfaces(hDevInfo,
                                            0,
                                            &hidGuid,
                                            i,
                                            &devInterface))
            {
                // Then we get the interface detail information (including device pathname)
                PSP_DEVICE_INTERFACE_DETAIL_DATA pIfDetail;

                pIfDetail = GetDeviceInterfaceDetail(hDevInfo, &devInterface);
                TRACEASSERT(pIfDetail != 0);

                if (pIfDetail != 0)
                {
                    DEVICE_DATA thisDev;

                    TRACEINFO(2, ("HID DEVICE: %s\n", pIfDetail->DevicePath));

                    // Finally we get specific device info to determine
                    // if it's one of ours
                    thisDev = *pDevData;
                    if (GetDeviceData(pIfDetail->DevicePath, &thisDev))
                    {
                        TRACEINFO(2, ("Usage Page: %d, Usage: %d\n",
                                      thisDev.hidCaps.UsagePage,
                                      thisDev.hidCaps.Usage));

                        // Is this is a device we want?
                        if ((pDevData->UsagePage == thisDev.hidCaps.UsagePage) &&
                            (pDevData->Usage == thisDev.hidCaps.Usage))
                        {
                            *pDevData = thisDev;
                            break;
                        }
                        else
                        {
                            // Not one of our devices, clean-up and try again
                            CloseTabletDevice(&thisDev);
                        }
                    }

                    free(pIfDetail);
                }
            }
            else
            {
                DWORD dwLastError = GetLastError();

                // SetupDiEnumDeviceInterfaces() failed, hopefull with
                // ERROR_NO_MORE_ITEMS
                if (dwLastError != ERROR_NO_MORE_ITEMS)
                {
                    TABSRVERR(("SetupDiEnumDeviceInterfaces failed (err=%d)\n",
                               dwLastError));
                }
                break;
            }
        }

        // Clean-up from SetupDiGetClassDevs()
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
    else
    {
        TABSRVERR(("SetupDiGetClassDevs failed (err=%d)\n", GetLastError()));
    }

    rc = pDevData->hDevice != INVALID_HANDLE_VALUE;

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //OpenTabletDevice

/*++
    @doc    INTERNAL

    @func   VOID | CloseTabletDevice | Close and clean up the tablet device.

    @parm   IN PDEVICE_DATA | pDevData | Points to the tablet device data.

    @rvalue None.
--*/

VOID
CloseTabletDevice(
    IN PDEVICE_DATA pDevData
    )
{
    TRACEPROC("CloseTabletDevice", 2)
    TRACEENTER(("(pDevData=%p)\n", pDevData));

    if (pDevData->hDevice != INVALID_HANDLE_VALUE)
    {
        CloseHandle(pDevData->hDevice);
        HidD_FreePreparsedData(pDevData->pPreParsedData);

        pDevData->hDevice = INVALID_HANDLE_VALUE;
    }

    TRACEEXIT(("!\n"));
}       //CloseTabletDevice

/*++
    @doc    INTERNAL

    @func   PSP_DEVICE_INTERFACE_DETAIL_DATA | GetDeviceInterfaceDetail |
            Gets interface details for a specific device.

    @parm   IN HDEVINFO | hDevInfo | Handle to HID device info.
    @parm   IN PSP_DEVICE_INTERFACE_DATA | pDevInterface |
            Points to device interface data.

    @rvalue SUCCESS | Returns pointer to SP_DEVICE_INTERFACE_DETAIL_DATA.
    @rvalue FAILURE | Returns NULL.

    @note   Caller is responsible for freeing the returned memory.
--*/

PSP_DEVICE_INTERFACE_DETAIL_DATA
GetDeviceInterfaceDetail(
    IN HDEVINFO                  hDevInfo,
    IN PSP_DEVICE_INTERFACE_DATA pDevInterface
    )
{
    TRACEPROC("GetDeviceInterfaceDetail", 3)
    PSP_DEVICE_INTERFACE_DETAIL_DATA pDetails;
    ULONG ulLen = 0;

    TRACEENTER(("(hDevInfo=%x,pDevInterface=%p)\n", hDevInfo, pDevInterface));

    // Make a call to get the required buffer length
    SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                    pDevInterface,
                                    NULL,
                                    0,
                                    &ulLen,
                                    NULL);
    TRACEASSERT(ulLen > 0);

    // Allocate a sufficiently large buffer
    pDetails = (PSP_DEVICE_INTERFACE_DETAIL_DATA)malloc(ulLen);
    TRACEASSERT(pDetails != 0);

    if (pDetails != NULL)
    {
        // Now that we have a buffer, get the details
        pDetails->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        if (!SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                             pDevInterface,
                                             pDetails,
                                             ulLen,
                                             &ulLen,
                                             NULL))
        {
            TABSRVERR(("SetupDiGetDeviceInterfaceDetail failed (err=%d)\n",
                       GetLastError()));
            free(pDetails);
            pDetails = NULL;
        }
    }

    TRACEEXIT(("=%p\n", pDetails));
    return pDetails;
}       //GetDeviceInterfaceDetail

/*++
    @doc    INTERNAL

    @func   BOOL | GetDeviceData | Opens a HID device and retrieves the
            'preparsed' data and HID capabilities.

    @parm   IN LPCTSTR | pszDevPath | Points to the device path name.
    @parm   OUT PDEVICE_DATA | pDevData | Points to the DEVICE_DATA structure.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
GetDeviceData(
    IN  LPCTSTR      pszDevPath,
    OUT PDEVICE_DATA pDevData
    )
{
    TRACEPROC("GetDeviceData", 3)
    BOOL rc = FALSE;

    TRACEENTER(("(pszDevPath=%s,pDevData=%p)\n", pszDevPath, pDevData));

    // First, open the device for read/write, exclusive access
    pDevData->hDevice = CreateFile(pszDevPath,
                                   GENERIC_READ | GENERIC_WRITE,// access mode
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,// sharing flags
                                   NULL,                        // security attributes
                                   OPEN_EXISTING,
                                   FILE_FLAG_OVERLAPPED,        // flags & attributes
                                   NULL);                       // template file

    if (pDevData->hDevice != INVALID_HANDLE_VALUE)
    {
        // Then get the preparsed data and capabilities
        if (HidD_GetPreparsedData(pDevData->hDevice,
                                  &pDevData->pPreParsedData) &&
            (HidP_GetCaps(pDevData->pPreParsedData, &pDevData->hidCaps) ==
             HIDP_STATUS_SUCCESS))
        {
#ifdef DEBUG
          #if !defined(_UNICODE)
            char szAnsi[512];
          #endif

            TCHAR szBuff[256];
            if (HidD_GetManufacturerString(pDevData->hDevice,
                                           szBuff,
                                           sizeof(szBuff)))
            {
              #if !defined(_UNICODE)
                WideCharToMultiByte(CP_ACP,
                                    0,
                                    (LPWSTR)szBuff,
                                    -1,
                                    szAnsi,
                                    sizeof(szAnsi),
                                    NULL,
                                    NULL);
                strcpy(szBuff, szAnsi);
              #endif
                TRACEINFO(2, ("ManufacturerStr: %s\n", szBuff));
            }

            if (HidD_GetProductString(pDevData->hDevice,
                                      szBuff,
                                      sizeof(szBuff)))
            {
              #if !defined(_UNICODE)
                WideCharToMultiByte(CP_ACP,
                                    0,
                                    (LPWSTR)szBuff,
                                    -1,
                                    szAnsi,
                                    sizeof(szAnsi),
                                    NULL,
                                    NULL);
                strcpy(szBuff, szAnsi);
              #endif
                TRACEINFO(2, ("ProductStr: %s\n", szBuff));
            }
#endif
            rc = TRUE;
        }
        else
        {
            TABSRVERR(("HidD_GetPreparsedData/HidP_GetCaps failed (err=%d)\n",
                       GetLastError()));
            CloseHandle(pDevData->hDevice);
            pDevData->hDevice = INVALID_HANDLE_VALUE;
        }
    }
    else
    {
        TRACEWARN(("failed to open %s (err=%d)\n", pszDevPath, GetLastError()));
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //GetDeviceData

/*++
    @doc    INTERNAL

    @func   BOOL | ReadReportOverlapped | Get a device input report using
            overlapped ReadFile.

    @parm   IN PDEVICE_DATA | pDevData | Device to read.
    @parm   OUT LPVOID | lpvBuffer | Data buffer.
    @parm   OUT LPDWORD | lpdwcBytesRead | To hold number of bytes read.
    @parm   IN LPOVERLAPPED | lpOverlapped | Overlapped buffer

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
ReadReportOverlapped(
    IN  PDEVICE_DATA pDevData,
    OUT LPVOID       lpvBuffer,
    OUT LPDWORD      lpdwcBytesRead,
    IN  LPOVERLAPPED lpOverlapped
    )
{
    TRACEPROC("ReadReportOverlapped", 5)
    BOOL rc = TRUE;

    TRACEENTER(("(pDevData=%p,lpvBuffer=%p,lpdwcBytesRead=%p,lpOverlapped=%p)\n",
                pDevData, lpvBuffer, lpdwcBytesRead, lpOverlapped));

    rc = ReadFile(pDevData->hDevice,
                  lpvBuffer,
                  pDevData->hidCaps.InputReportByteLength,
                  lpdwcBytesRead,
                  lpOverlapped);

    if (rc == TRUE)
    {
        // ReadFile completed synchronously. Set our completion event
        // so this case can be handled by without special checking by
        // our caller.
        SetEvent(lpOverlapped->hEvent);
    }
    else
    {
        DWORD dwLastError = GetLastError();

        if (dwLastError == ERROR_IO_PENDING)
        {
            rc = TRUE;
        }
        else
        {
            TABSRVERR(("Error reading device report (err=%d)\n",
                       dwLastError));
        }
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //ReadReportOverlapped
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\tray.cpp ===
// Tray.cpp

#include "pch.h"
#include "tray.h"

#define LEFT_MENU	(0)
#define RIGHT_MENU	(1)

/////////////////////////////////////////////////////////////////////////////

CTrayIcon::CTrayIcon(HWND hWnd, HICON hIcon, LPCTSTR pszText, UINT uID) :
	m_iDefaultCmd(-1)
{
    TRACEPROC("CTrayIcon::CTrayIcon", 2)

    TRACEENTER(("(hwnd=%x,hIcon=%x,Text=%s,ID=%x)\n",
                hWnd, hIcon, pszText, uID));

    m_hMenu[LEFT_MENU] = m_hSubMenu[LEFT_MENU] = 0;
    m_hMenu[RIGHT_MENU] = m_hSubMenu[RIGHT_MENU] = 0;
    m_msgTaskbarCreated = RegisterWindowMessage(TEXT("TaskbarCreated"));

    memset(&m_nid, 0, sizeof(m_nid));

    m_nid.cbSize = sizeof(NOTIFYICONDATA);
    m_nid.hWnd = hWnd;
    m_nid.uID = uID;

    m_nid.uFlags = NIF_MESSAGE;
    m_nid.uCallbackMessage = RegisterWindowMessage(TEXT("{D0061156-D460-4230-AF87-9E7658AB987D}"));

    if (hIcon)
    {
	m_nid.uFlags |= NIF_ICON;
	m_nid.hIcon = hIcon;
    }

    if (pszText)
    {
	m_nid.uFlags |= NIF_TIP;
	lstrcpyn(m_nid.szTip, pszText, sizeof(m_nid.szTip));
    }

    if (!Shell_NotifyIcon(NIM_ADD, &m_nid))
    {
        TABSRVERR(("CTrayIcon::CTrayIcon: Shell_NotifyIcon failed (err=%d)\n",
                   GetLastError()));
    }

    TRACEEXIT(("!\n"));
    return;
}

/////////////////////////////////////////////////////////////////////////////

void CTrayIcon::Delete()
{
    TRACEPROC("CTrayIcon::Delete", 2)

    TRACEENTER(("()\n"));

    if (m_nid.uFlags & NIF_ICON)
    {
	m_nid.uFlags = NIF_ICON;
	if (!Shell_NotifyIcon(NIM_DELETE, &m_nid))
            SetLastError(::GetLastError());

        m_nid.uFlags = 0;

	// Cleanup the icon...
	if (m_nid.hIcon)
	{
            DestroyIcon(m_nid.hIcon);
            m_nid.hIcon = 0;
	}

	// ...and the menus
	HMENU hmLeft = m_hMenu[LEFT_MENU];
	if (m_hMenu[LEFT_MENU])
	{
            DestroyMenu(m_hMenu[LEFT_MENU]);
            m_hMenu[LEFT_MENU] = m_hSubMenu[LEFT_MENU] = 0;
	}

	// watch for right & left menus being the same
	if (m_hMenu[RIGHT_MENU] && m_hMenu[RIGHT_MENU] != hmLeft)
	{
            DestroyMenu(m_hMenu[RIGHT_MENU]);
            m_hMenu[RIGHT_MENU] = m_hSubMenu[RIGHT_MENU] = 0;
	}
    }

    TRACEEXIT(("!\n"));
    return;
}

#if 0
/////////////////////////////////////////////////////////////////////////////

HICON CTrayIcon::SetIcon(HICON hIcon)
{
    TRACEPROC("CTrayIcon::SetIcon", 2)
    HICON hOldIcon = m_nid.hIcon;

    TRACEENTER(("(hIcon=%x)\n", hIcon));

    if (hIcon)
    {
        m_nid.hIcon = hIcon;
        m_nid.uFlags |= NIF_ICON;

        if (!Shell_NotifyIcon(NIM_MODIFY, &m_nid))
            SetLastError(::GetLastError());
    }
    else
    {
        Delete();
    }

    TRACEEXIT(("=%x\n", hOldIcon));
    return hOldIcon;
}

/////////////////////////////////////////////////////////////////////////////

void CTrayIcon::SetText(LPCTSTR pszText)
{
    TRACEPROC("CTrayIcon::SetText", 2)

    TRACEENTER(("(Text=%s)\n", pszText));

    if (pszText)
    {
        m_nid.uFlags |= NIF_TIP;
        lstrcpyn(m_nid.szTip, pszText, sizeof(m_nid.szTip));

        if (!Shell_NotifyIcon(NIM_MODIFY, &m_nid))
            SetLastError(::GetLastError());
    }

    TRACEEXIT(("!\n"));
    return;
}
#endif

/////////////////////////////////////////////////////////////////////////////

void CTrayIcon::BalloonToolTip(
    LPCTSTR pszTitle,
    LPCTSTR pszText,
    UINT uTimeout,
    DWORD dwFlags)
{
    TRACEPROC("CTrayIcon::BalloonToolTip", 2)
    UINT uFlags = m_nid.uFlags;

    TRACEENTER(("(Title=%s,Text=%s,Timeout=%d,Flags=%x)\n",
                pszTitle, pszText, uTimeout, dwFlags));

    m_nid.uFlags = NIF_INFO;
    m_nid.uTimeout = uTimeout;
    lstrcpyn(m_nid.szInfo, pszText, ARRAYSIZE(m_nid.szInfo));
    lstrcpyn(m_nid.szInfoTitle, pszTitle, ARRAYSIZE(m_nid.szInfoTitle));
    m_nid.dwInfoFlags = dwFlags;

    if (!Shell_NotifyIcon(NIM_MODIFY, &m_nid))
    {
        TABSRVERR(("CTrayIcon::BalloonToolTip: Shell_NotifyIcon failed (err=%d)\n",
                   GetLastError()));
    }

    m_nid.uFlags = uFlags;

    TRACEEXIT(("!\n"));
    return;
}

/////////////////////////////////////////////////////////////////////////////

#if 0
static VOID CALLBACK TimerProc(HWND hWnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    TRACEPROC("TimerProc", 5)

    TRACEENTER(("(hwnd=%x,Msg=%s,EventId=%x,Time=%x)\n",
                hWnd, LookupName(uMsg, WMMsgNames), idEvent, dwTime));

    KillTimer(hWnd, idEvent);
    CTrayIcon* This = reinterpret_cast<CTrayIcon*>(idEvent);

    if (This->m_hSubMenu[LEFT_MENU])
        This->DoMenu(This->m_hSubMenu[LEFT_MENU]);

    TRACEEXIT(("!\n"));
    return;
}
#endif

/////////////////////////////////////////////////////////////////////////////

BOOL CTrayIcon::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
						LRESULT& lResult)
{
    TRACEPROC("CTrayIcon::WndProc", 5)
    BOOL rc = FALSE;

    TRACEENTER(("(hwnd=%x,Msg=%s,wParam=%x,lParam=%x)\n",
                hWnd, LookupName(uMsg, WMMsgNames), wParam, lParam));

    if (uMsg == m_msgTaskbarCreated)
    {
       	lResult = OnTaskbarCreated();
       	rc = TRUE;
    }
    else if (uMsg == m_nid.uCallbackMessage)
    {
    	lResult = OnNotify(lParam);
       	rc = TRUE;
    }
    else if (uMsg == WM_DESTROY)
    {
       	// Our controlling window is being destroyed.  Clean up if we
       	// haven't already, then pass on the WM_DESTROY
       	Delete();
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}

/////////////////////////////////////////////////////////////////////////////

LRESULT CTrayIcon::OnNotify(LPARAM lParam)
{
    TRACEPROC("CTrayIcon::OnNotify", 2)
    TRACEENTER(("(lParam=%x)\n", lParam));

    switch (lParam)
    {
        case WM_LBUTTONUP:
	    if (m_iDefaultCmd != -1)
	       	PostMessage(m_nid.hWnd, WM_COMMAND, m_iDefaultCmd, 0);
            break;

#if 0
        case WM_LBUTTONDOWN:
	    SetTimer(m_nid.hWnd, (UINT_PTR)this, GetDoubleClickTime(), TimerProc);
	    break;

	case WM_LBUTTONDBLCLK:
	    KillTimer(m_nid.hWnd, (UINT_PTR)this);

	    if (m_iDefaultCmd != -1)
	       	PostMessage(m_nid.hWnd, WM_COMMAND, m_iDefaultCmd, 0);
	    break;
#endif

        case WM_RBUTTONUP:
	    if (m_hSubMenu[RIGHT_MENU])
	       	DoMenu(m_hSubMenu[RIGHT_MENU]);
            break;
    }

    TRACEEXIT(("=0\n"));
    return 0;
}

/////////////////////////////////////////////////////////////////////////////

LRESULT CTrayIcon::OnTaskbarCreated()
{
    TRACEPROC("CTrayIcon::OnTaskbarCreated", 2)
    TRACEENTER(("()\n"));

    if (m_nid.hWnd && m_nid.hIcon && (m_nid.uFlags & NIF_ICON))
    {
       	if (!Shell_NotifyIcon(NIM_ADD, &m_nid))
        {
            TABSRVERR(("CTrayIcon::OnTaskbarCreated: Shell_NotifyIcon failed (err=%d)\n",
                       GetLastError()));
        }
    }

    TRACEEXIT(("=0\n"));
    return 0;
}

/////////////////////////////////////////////////////////////////////////////

HMENU CTrayIcon::SetSubMenu(BOOL fLeftMenu, HMENU hMenu, int nPos)
{
    TRACEPROC("CTrayIcon::SetSubMenu", 2)
    int idx = (fLeftMenu) ? LEFT_MENU : RIGHT_MENU;
    HMENU hOldMenu = m_hMenu[idx];

    TRACEENTER(("(fLeftMenu=%d,hMenu=%x,Pos=%d)\n", fLeftMenu, hMenu, nPos));

    m_hMenu[idx] = m_hSubMenu[idx] = hMenu;

    if (hMenu && nPos >= 0)
    {
       	m_hSubMenu[idx] = GetSubMenu(hMenu, nPos);  //NO TYPO
    }

    if (idx == LEFT_MENU)
    {
       	m_iDefaultCmd = -1;

       	if (hMenu && m_hSubMenu[idx])
            m_iDefaultCmd = GetMenuDefaultItem(m_hSubMenu[idx], FALSE, 0);
    }

    TRACEEXIT(("=%x\n", hOldMenu));
    return hOldMenu;
}

/////////////////////////////////////////////////////////////////////////////

void CTrayIcon::DoMenu(HMENU hMenu)
{
    TRACEPROC("CTrayIcon::DoMenu", 2)
    POINT pt;
    UINT iCmd;
    TCHAR tszMenuText[128];

    TRACEENTER(("(hMenu=%x)\n", hMenu));
    GetCursorPos(&pt);

    SetForegroundWindow(m_nid.hWnd);		// necessary?

    LoadString(ghMod,
               gdwfTabSrv & TSF_SUPERTIP_OPENED?
                    IDS_HIDE_SUPERTIP: IDS_SHOW_SUPERTIP,
               tszMenuText,
               ARRAYSIZE(tszMenuText));
    ModifyMenu(hMenu,
               IDM_OPEN,
               MF_BYCOMMAND | MF_STRING,
               IDM_OPEN,
               tszMenuText);

    LoadString(ghMod,
               gdwfTabSrv & TSF_PORTRAIT_MODE?
                    IDS_SCREEN_LANDSCAPE: IDS_SCREEN_PORTRAIT,
               tszMenuText,
               ARRAYSIZE(tszMenuText));
    ModifyMenu(hMenu,
               IDM_TOGGLE_ROTATION,
               MF_BYCOMMAND | MF_STRING,
               IDM_TOGGLE_ROTATION,
               tszMenuText);

    iCmd = TrackPopupMenu(hMenu, /* TPM_RETURNCMD | */ TPM_NONOTIFY | TPM_RIGHTBUTTON,
	                  pt.x, pt.y, 0, m_nid.hWnd, NULL);

    PostMessage(m_nid.hWnd, WM_NULL, 0, 0); // MS doucmented work-around for taskbar menu
					    // problem with TrackPopupMenu - still needed?

    //PostMessage(m_nid.hWnd, WM_COMMAND, iCmd, 0);

    TRACEEXIT(("!\n"));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\tabsrv.h ===
/*++
    Copyright (c) 2000  Microsoft Corporation.  All rights reserved.

    Module Name:
        tabsrv.h

    Abstract:
        This module contains private definitions of the TabletPC Listener
        Service.

    Author:
        Michael Tsang (MikeTs) 01-Jun-2000

    Environment:
        User mode

    Revision History:
--*/

#ifndef _TABSRV_H
#define _TABSRV_H

//
// Constants
//
#define STR_TABSRV_NAME         MODNAME
#define STR_REGPATH_TABSRVPARAM "System\\CurrentControlSet\\Services\\TabSrv\\Parameters";
#define STR_LINEARITY_MAP       "LinearityMap"

// gdwfTabSrv flags
#define TSF_RPCTHREAD                   0x00000001
#define TSF_SUPERTIPTHREAD              0x00000002
#define TSF_DIGITHREAD                  0x00000004
#define TSF_MOUSETHREAD                 0x00000008
#define TSF_BUTTONTHREAD                0x00000010
#define TSF_ALLTHREAD                   (TSF_RPCTHREAD |        \
                                         TSF_SUPERTIPTHREAD |   \
                                         TSF_DIGITHREAD |       \
                                         TSF_MOUSETHREAD |      \
                                         TSF_BUTTONTHREAD)
#define TSF_TERMINATE                   0x00000020
#define TSF_HAS_LINEAR_MAP              0x00000040
#define TSF_PORTRAIT_MODE               0x00000080
#define TSF_SUPERTIP_MINIMIZED_BEFORE   0x00000100
#define TSF_SUPERTIP_OPENED             0x00000200
#define TSF_SUPERTIP_SENDINK            0x00000400
#define TSF_TASKBAR_CREATED             0x00000800
#define TSF_TRAYICON_CREATED            0x00001000
#define TSF_PORTRAIT_MODE2              0x40000000
#define TSF_DEBUG_MODE                  0x80000000

// dwfThread flags
#define THREADF_ENABLED                 0x00000001
#define THREADF_RESTARTABLE             0x00000002
#define THREADF_SDT_POSTMSG             0x00000004
#define THREADF_SDT_SETEVENT            0x00000008
#define THREADF_DESKTOP_WINLOGON        0x00000010

// HID USAGE DIGITIZER defines (BUGBUG: move to ddk\inc\hidusage.h someday?)
#define HID_USAGE_DIGITIZER_PEN         ((USAGE)0x02)
#define HID_USAGE_DIGITIZER_IN_RANGE    ((USAGE)0x32)
#define HID_USAGE_DIGITIZER_TIP_SWITCH  ((USAGE)0x42)
#define HID_USAGE_DIGITIZER_BARREL_SWITCH ((USAGE)0x44)
#define HID_USAGE_CONSUMERCTRL          ((USAGE)0x01)

// gdwPenState values
#define PENSTATE_NORMAL                 0x00000000
#define PENSTATE_PENDOWN                0x00000001
#define PENSTATE_LEFTUP_PENDING         0x00000002
#define PENSTATE_PRESSHOLD              0x00000003
#define PENSTATE_RIGHTDRAG              0x00000004

#define MAX_RESTARTS                    5
#define MAX_NORMALIZED_X                65535
#define MAX_NORMALIZED_Y                65535
#define NUM_PIXELS_LONG                 1024
#define NUM_PIXELS_SHORT                768
#define TIMERID_PRESSHOLD               1
#define TIMEOUT_LEFTCLICK               20              //20 msec.
#define TIMEOUT_BALLOON_TIP             (10*1000)       //10 sec.

// Button constants
#define BUTTONSTATE_BUTTON_1    0x00000004
#define BUTTONSTATE_BUTTON_2    0x00000002
#define BUTTONSTATE_BUTTON_3    0x00000001
#define BUTTONSTATE_BUTTON_4    0x00000010
#define BUTTONSTATE_BUTTON_5    0x00000008
#define BUTTONSTATE_DEFHOTKEY   (BUTTONSTATE_BUTTON_1 | BUTTONSTATE_BUTTON_5)

// Gesture related constants
#define WM_GESTURE              (WM_APP)
#define WM_SUPERTIP_NOTIFY      (WM_APP + 1)
#define WM_SUPERTIP_INIT        (WM_APP + 2)

#define TIP_SWITCH              (1)     // bit flag in wButtonState
#define BARREL_SWITCH           (2)     // bit flag in wButtonState

#define DEF_RADIUS              200     // The pen must have been outside sqrt(Radius) for a while
#define DEF_MINOUTPTS           6
#define DEF_MAXTIMETOINSPECT    800
#define DEF_ASPECTRATIO         3
#define DEF_CHECKTIME           400
#define DEF_PTSTOEXAMINE        4
#define DEF_STOPDIST            50      // The pen is considered stopped if all points during the last STOPTIME ms
					//  are within this distance of the current point.
#define DEF_STOPTIME            200
#define DEF_PRESSHOLD_TIME      500
#define DEF_HOLD_TOLERANCE      3

//
// Macros
//
#define InitializeListHead(lh)  ((lh)->Flink = (lh)->Blink = (lh))
#define IsListEmpty(lh)         ((lh)->Flink == (lh))
#define RemoveHeadList(lh)      (lh)->Flink;                            \
                                {RemoveEntryList((lh)->Flink)}
#define RemoveEntryList(e)      {                                       \
                                    (e)->Blink->Flink = (e)->Flink;     \
                                    (e)->Flink->Blink = (e)->Blink;     \
                                }
#define InsertTailList(lh,e)    {                                       \
                                    (e)->Flink = (lh);                  \
                                    (e)->Blink = (lh)->Blink;           \
                                    (lh)->Blink->Flink = (e);           \
                                    (lh)->Blink = (e);                  \
                                }
#define SET_SERVICE_STATUS(s)   if (ghServStatus) {                     \
                                    gServStatus.dwCurrentState = s;     \
                                    SetServiceStatus(ghServStatus,      \
                                                     &gServStatus);     \
                                }
#define TABSRVERR(p)            {                                       \
                                    TRACEERROR(p);                      \
                                    TabSrvLogError p;                   \
                                }
#define SWAPBUTTONS(c,e1,e2)    (((c) == 0)? (e1): (e2))
#define ARRAYSIZE(x)            (sizeof(x)/sizeof(x[0]))
#define SCREEN_TO_NORMAL_X(x)   ((((x) - glVirtualDesktopLeft)*         \
                                  (MAX_NORMALIZED_X + 1) +              \
                                  (MAX_NORMALIZED_X + 1)/2)/            \
                                 gcxScreen)
#define SCREEN_TO_NORMAL_Y(y)   ((((y) - glVirtualDesktopTop)*          \
                                  (MAX_NORMALIZED_Y + 1) +              \
                                  (MAX_NORMALIZED_Y + 1) /2)/           \
                                 gcyScreen)
#define NORMAL_TO_SCREEN_X(x)   (((x)*gcxScreen + gcxScreen/2)/         \
                                 (MAX_NORMALIZED_X + 1) +               \
                                 glVirtualDesktopLeft)
#define NORMAL_TO_SCREEN_Y(y)   (((y)*gcyScreen + gcyScreen/2)/         \
                                 (MAX_NORMALIZED_Y + 1) +               \
                                 glVirtualDesktopTop)

//
// Type definitions
//
typedef struct _PEN_TILT
{
    LONG dx;
    LONG dy;
} PEN_TILT, *PPEN_TILT;

typedef struct _CONFIG
{
    GESTURE_SETTINGS GestureSettings;
    PEN_TILT         PenTilt;
    LINEAR_MAP       LinearityMap;
    BUTTON_SETTINGS  ButtonSettings;
} CONFIG, *PCONFIG;

typedef unsigned (__stdcall *PFNTHREAD)(void *);
typedef struct _TSTHREAD
{
    PFNTHREAD pfnThread;
    PSZ       pszThreadName;
    DWORD     dwThreadTag;
    DWORD     dwfThread;
    DWORD     dwcRestartTries;
    PVOID     pvSDTParam;
    HANDLE    hThread;
    int       iThreadStatus;
    PVOID     pvParam;
} TSTHREAD, *PTSTHREAD;

typedef struct _DEVICE_DATA
{
    USAGE                UsagePage;
    USAGE                Usage;
    HANDLE               hStopDeviceEvent;
    HANDLE               hDevice;
    ULONG                dwcButtons;
    PUSAGE               pDownButtonUsages;
    PHIDP_PREPARSED_DATA pPreParsedData;
    HIDP_CAPS            hidCaps;
} DEVICE_DATA, *PDEVICE_DATA;

typedef struct _DIGITIZER_DATA
{
    WORD  wButtonState;
    WORD  wX;
    WORD  wY;
    DWORD dwTime;
} DIGITIZER_DATA, *PDIGITIZER_DATA;

typedef struct _DIGIRECT
{
    USHORT wx0;
    USHORT wy0;
    USHORT wx1;
    USHORT wy1;
} DIGIRECT, *PDIGIRECT;

typedef struct _NOTIFYCLIENT
{
    DWORD      dwSig;
    LIST_ENTRY list;
    EVTNOTIFY  Event;
    HWND       hwnd;
    UINT       uiMsg;
} NOTIFYCLIENT, *PNOTIFYCLIENT;

#define SIG_NOTIFYCLIENT        'tnlC'

//
// Global data
//
extern HMODULE     ghMod;
extern DWORD       gdwfTabSrv;
extern LIST_ENTRY  glistNotifyClients;
extern HANDLE      ghDesktopSwitchEvent;
extern HANDLE      ghmutNotifyList;
extern HANDLE      ghHotkeyEvent;
extern HANDLE      ghRefreshEvent;
extern HANDLE      ghRPCServerThread;
extern HWND        ghwndSuperTIP;
extern HWND        ghwndMouse;
extern HWND        ghwndSuperTIPInk;
extern HCURSOR     ghcurPressHold;
extern HCURSOR     ghcurNormal;
extern UINT        guimsgSuperTIPInk;
#ifdef DRAW_INK
extern HWND        ghwndDrawInk;
#endif
extern ISuperTip  *gpISuperTip;
extern ITellMe    *gpITellMe;
extern int         gcxScreen, gcyScreen;
extern int         gcxPrimary, gcyPrimary;
extern LONG        glVirtualDesktopLeft,
                   glVirtualDesktopRight,
                   glVirtualDesktopTop,
                   glVirtualDesktopBottom;
extern LONG        glLongOffset, glShortOffset;
extern int         giButtonsSwapped;
extern ULONG       gdwMinX, gdwMaxX, gdwRngX;
extern ULONG       gdwMinY, gdwMaxY, gdwRngY;
extern int         gixIndex, giyIndex;
extern INPUT       gInput;
extern DWORD       gdwPenState;
extern DWORD       gdwPenDownTime;
extern LONG        glPenDownX;
extern LONG        glPenDownY;
extern DWORD       gdwPenUpTime;
extern LONG        glPenUpX;
extern LONG        glPenUpY;
extern WORD        gwLastButtons;
extern CONFIG      gConfig;
extern TSTHREAD    gTabSrvThreads[];
extern TCHAR       gtszTabSrvTitle[];
extern TCHAR       gtszTabSrvName[];
extern TCHAR       gtszGestureSettings[];
extern TCHAR       gtszButtonSettings[];
extern TCHAR       gtszPenTilt[];
extern TCHAR       gtszLinearityMap[];
extern TCHAR       gtszRegPath[];
extern TCHAR       gtszInputDesktop[];

extern SERVICE_STATUS_HANDLE ghServStatus;
extern SERVICE_STATUS        gServStatus;
extern DIGITIZER_DATA        gLastRawDigiReport;
extern DEVICE_DATA           gdevDigitizer;
extern DEVICE_DATA           gdevButtons;

#ifdef DEBUG
extern NAMETABLE ServiceControlNames[];
extern NAMETABLE ConsoleControlNames[];
#endif

//
// Function prototypes
//

// tabsrv.cpp
VOID
InstallTabSrv(
    VOID
    );

VOID
SetTabSrvConfig(
    IN SC_HANDLE hService
    );

VOID
RemoveTabSrv(
    VOID
    );

VOID
StartTabSrv(
    VOID
    );

VOID
StopTabSrv(
    VOID
    );

VOID WINAPI
TabSrvServiceHandler(
    IN DWORD dwControl
    );

#ifdef ALLOW_DEBUG
BOOL WINAPI
TabSrvConsoleHandler(
    IN DWORD dwControl
    );
#endif

VOID WINAPI
TabSrvMain(
    IN DWORD   icArgs,
    IN LPTSTR *aptszArgs
    );

VOID
InitConfigFromReg(
    VOID
    );

BOOL
InitThreads(
    IN PTSTHREAD pThreads,
    IN int       nThreads
    );

PTSTHREAD
FindThread(
    IN DWORD dwThreadTag
    );

VOID
WaitForTermination(
    VOID
    );

VOID
TabSrvTerminate(
    IN BOOL fTerminate
    );

VOID
TabSrvLogError(
    IN LPTSTR ptszFormat,
    ...
    );

LONG
ReadConfig(
    IN  LPCTSTR lptstrValueName,
    OUT LPBYTE  lpbData,
    IN  DWORD   dwcb
    );

LONG
WriteConfig(
    IN LPCTSTR lptstrValueName,
    IN DWORD   dwType,
    IN LPBYTE  lpbData,
    IN DWORD   dwcb
    );

LONG
GetRegValueString(
    IN     HKEY    hkeyTopLevel,
    IN     LPCTSTR pszSubKey,
    IN     LPCTSTR pszValueName,
    OUT    LPTSTR  pszValueString,
    IN OUT LPDWORD lpdwcb
    );

BOOL
SwitchThreadToInputDesktop(
    IN PTSTHREAD pThread
    );

BOOL
GetInputDesktopName(
    OUT LPTSTR pszDesktopName,
    IN  DWORD  dwcbLen
    );

BOOL
SendAltCtrlDel(
    VOID
    );

VOID
NotifyClient(
    IN EVTNOTIFY Event,
    IN WPARAM    wParam,
    IN LPARAM    lParam
    );

BOOL
ImpersonateCurrentUser(
    VOID
    );

BOOL
RunProcessAsUser(
    IN LPTSTR pszCmd
    );

// tabdev.cpp
unsigned __stdcall
DeviceThread(
    IN PVOID param
    );

BOOL
OpenTabletDevice(
    IN OUT PDEVICE_DATA pDevData
    );

VOID
CloseTabletDevice(
    IN PDEVICE_DATA pDevData
    );

PSP_DEVICE_INTERFACE_DETAIL_DATA
GetDeviceInterfaceDetail(
    IN HDEVINFO                  hDevInfo,
    IN PSP_DEVICE_INTERFACE_DATA pDevInterface
    );

BOOL
GetDeviceData(
    IN  LPCTSTR      pszDevPath,
    OUT PDEVICE_DATA pDevData
    );

BOOL
ReadReportOverlapped(
    IN  PDEVICE_DATA pDevData,
    OUT LPVOID       lpvBuffer,
    OUT LPDWORD      lpdwcBytesRead,
    IN  LPOVERLAPPED lpOverlapped
    );

// digidev.cpp
BOOL
GetMinMax(
    IN  USAGE  UsagePage,
    IN  USAGE  Usage,
    OUT PULONG pulMin,
    OUT PULONG pulMax
    );

VOID
ProcessDigitizerReport(
    IN PCHAR pBuff
    );

VOID
AdjustLinearity(
    IN OUT PUSHORT pwX,
    IN OUT PUSHORT pwY
    );

LRESULT
ProcessMouseEvent(
    IN     LONG  x,
    IN     LONG  y,
    IN     WORD  wButtons,
    IN     DWORD dwTime,
    IN     BOOL  fLowLevelMouse
    );

VOID
PressHoldMode(
    IN BOOL fEnable
    );

VOID
SetPressHoldCursor(
    IN BOOL fPressHold
    );

LPTSTR
MakeFileName(
    IN OUT LPTSTR pszFile
    );

BOOL
CanDoPressHold(
    IN LONG x,
    IN LONG y
    );

// buttons.cpp
VOID
ProcessButtonsReport(
    IN PCHAR pBuff
    );

VOID
CALLBACK
ButtonTimerProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN UINT_PTR idEvent,
    IN DWORD    dwTime
    );

BOOL
DoButtonAction(
    IN BUTTON_ACTION Action,
    IN DWORD         dwButtonTag,
    IN BOOL          fButtonDown
    );

BOOL
DoInvokeNoteBook(
    VOID
    );

VOID
UpdateButtonRepeatRate(
    VOID
    );

#ifdef MOUSE_THREAD
// mouse.cpp
unsigned __stdcall
MouseThread(
    IN PVOID param
    );

VOID
DoLowLevelMouse(
    IN PTSTHREAD pThread
    );

LRESULT CALLBACK
LowLevelMouseProc(
    IN int    nCode,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

LRESULT CALLBACK
MouseWndProc(
    IN HWND   hwnd,
    IN UINT   uiMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );
#endif

// butdev.cpp
unsigned __stdcall
ButtonsThread(
    PVOID param
    );

// gesture.cpp
int
RecognizeGesture(
    IN LONG  x,
    IN LONG  y,
    IN WORD  wButtons,
    IN DWORD dwTime,
    IN BOOL  fLowLevelMouse
    );

int
Recognize(
    IN POINT& pt,
    IN DWORD  dwTime
    );

void
AddItem(
    IN POINT& pt,
    IN DWORD  dwTime
    );

bool
penStopped(
    IN POINT& pt,
    IN DWORD  dwTime,
    IN int    ci,
    IN int    li
    );

bool
checkEarlierPoints(
    IN POINT& pt,
    IN DWORD  dwTime,
    IN int    ci,
    IN int    li
    );

int
dist(
    IN POINT& pt,
    IN int index
    );

VOID
DoGestureAction(
    IN GESTURE_ACTION Action,
    IN LONG           x,
    IN LONG           y
    );

// tsrpc.cpp
unsigned __stdcall
RPCServerThread(
    IN PVOID param
    );

// Supertip.cpp
unsigned __stdcall
SuperTIPThread(
    IN PVOID param
    );

LRESULT CALLBACK
SuperTIPWndProc(
    IN HWND   hwnd,
    IN UINT   uiMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

#if 0
VOID
EnumDisplayModes(
    VOID
    );
#endif

VOID
UpdateRotation(
    VOID
    );

BOOL CALLBACK
MonitorEnumProc(
    IN HMONITOR hMon,
    IN HDC      hdcMon,
    IN LPRECT   lprcMon,
    IN LPARAM   dwData
    );

BOOL
CreateTrayIcon(
    IN HWND    hwnd,
    IN UINT    umsgTray,
    IN HICON   hIcon,
    IN LPCTSTR ptszTip
    );

BOOL
DestroyTrayIcon(
    IN HWND    hwnd,
    IN UINT    umsgTray,
    IN HICON   hIcon
    );

BOOL SetBalloonToolTip(
    IN HWND    hwnd,
    IN UINT    umsgTray,
    IN LPCTSTR ptszTitle,
    IN LPCTSTR ptszTip,
    IN UINT    uTimeout,
    IN DWORD   dwInfoFlags
    );

#endif  //ifndef _TABSRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tabsrv\tsrpc.cpp ===
/*++
    Copyright (c) 2000  Microsoft Corporation.  All rights reserved.

    Module Name:
        tsrpc.cpp

    Abstract:
        This module contains the TabSrv RPC services.

    Author:
        Michael Tsang (MikeTs) 05-Jun-2000

    Environment:
        User mode

    Revision History:
--*/

#include "pch.h"

/*++
    @doc    INTERNAL

    @func   unsigned | RPCServerThread | RPC Server thread.

    @parm   IN PVOID | param | Not used.

    @rvalue Always returns 0.
--*/

unsigned __stdcall
RPCServerThread(
    IN PVOID param
    )
{
    TRACEPROC("RPCServerThread", 2)
    RPC_STATUS status;
    RPC_BINDING_VECTOR *BindingVector = NULL;

    TRACEENTER(("(param=%p)\n", param));

    if ((status = RpcServerUseProtseq((unsigned char *)"ncalrpc",
                                      RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                      NULL)) != RPC_S_OK)
    {
        TABSRVERR(("RpcServerUseProtSeqEp failed (status=%d)\n", status));
    }
    else if ((status = RpcServerRegisterIf(TabSrv_v1_0_s_ifspec,
                                           NULL,
                                           NULL)) != RPC_S_OK)
    {
        TABSRVERR(("RpcServerRegisterIf failed (status=%d)\n", status));
    }
    else if ((status = RpcServerInqBindings(&BindingVector)) != RPC_S_OK)
    {
        TABSRVERR(("RpcServerInqBindings failed (status=%d)\n", status));
    }
    else if ((status = RpcEpRegister(TabSrv_v1_0_s_ifspec,
                                     BindingVector,
                                     NULL,
                                     NULL)) != RPC_S_OK)
    {
        RpcBindingVectorFree(&BindingVector);
        TABSRVERR(("RpcEpRegister failed (status=%d)\n", status));
    }
    else if ((status = RpcServerRegisterAuthInfo(NULL,
                                                 RPC_C_AUTHN_WINNT,
                                                 NULL,
                                                 NULL)) != RPC_S_OK)
    {
        RpcEpUnregister(TabSrv_v1_0_s_ifspec, BindingVector, NULL);
        RpcBindingVectorFree(&BindingVector);
        TABSRVERR(("RpcServerRegisterAuthInfo failed (status=%d)\n", status));
    }
    else
    {
        status = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, FALSE);
        TRACEASSERT(status == RPC_S_OK);
        RpcEpUnregister(TabSrv_v1_0_s_ifspec, BindingVector, NULL);
        RpcBindingVectorFree(&BindingVector);
    }
    TRACEINFO(1, ("RPC thread exiting...\n"));

    TRACEEXIT(("=0\n"));
    return 0;
}       //RPCServerThread

/*++
    @doc    EXTERNAL

    @func   HEVTNOTIFY | TabSrvRegisterEventNotify |
            Register event notification.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN EVTNOTIFY | Notify event.
    @parm   IN HWIN | hwnd | Handle to window to be notified.
    @parm   IN UINT | uiMsg | Notification message used.

    @rvalue SUCCESS | Returns notification handle.
    @rvalue FAILURE | Returns NULL.
--*/

HEVTNOTIFY
TabSrvRegisterEventNotify(
    IN handle_t  hBinding,
    IN EVTNOTIFY Event,
    IN HWIN      hwnd,
    IN UINT      uiMsg
    )
{
    TRACEPROC("TabSrvRegisterEventNotify", 2)
    PNOTIFYCLIENT Client;

    TRACEENTER(("(hBinding=%x,Event=%x,hwnd=%x,Msg=%d)\n",
                hBinding, Event, hwnd, uiMsg));

    Client = (PNOTIFYCLIENT)malloc(sizeof(NOTIFYCLIENT));
    if (Client != NULL)
    {
        DWORD rcWait;

        Client->dwSig = SIG_NOTIFYCLIENT;
        Client->Event = Event;
        Client->hwnd = (HWND)hwnd;
        Client->uiMsg = uiMsg;
        rcWait = WaitForSingleObject(ghmutNotifyList, INFINITE);
        if (rcWait == WAIT_OBJECT_0)
        {
            InsertTailList(&glistNotifyClients, &Client->list);
            ReleaseMutex(ghmutNotifyList);
        }
        else
        {
            TABSRVERR(("failed to wait for client list Mutex (rcWait=%x,err=%d).\n",
                       rcWait, GetLastError()));
        }
    }
    else
    {
        TABSRVERR(("Failed to allocate notification client.\n"));
    }

    TRACEEXIT(("=%p\n", Client));
    return (HEVTNOTIFY)Client;
}       //TabSrvRegisterEventNotify

/*++
    @doc    EXTERNAL

    @func   VOID | TabSrvDeregisterEventNotify | Deregister event notification.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN HEVTNOTIFY | Notification handle.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
TabSrvDeregisterEventNotify(
    IN handle_t   hBinding,
    IN HEVTNOTIFY hEventNotify
    )
{
    TRACEPROC("TabSrvRegisterEventNotify", 2)
    BOOL rc;
    PNOTIFYCLIENT Client = (PNOTIFYCLIENT)hEventNotify;
    DWORD rcWait;

    TRACEENTER(("(hBinding=%x,NotifyClient=%p)\n", Client));

    __try
    {
        rc = (Client->dwSig == SIG_NOTIFYCLIENT);
    }
    __except(1)
    {
        TABSRVERR(("Invalid Notify Client handle.\n"));
        rc = FALSE;
    }

    if (rc == TRUE)
    {
        rcWait = WaitForSingleObject(ghmutNotifyList, INFINITE);
        if (rcWait == WAIT_OBJECT_0)
        {
            RemoveEntryList(&Client->list);
            ReleaseMutex(ghmutNotifyList);
            free(Client);
        }
        else
        {
            TABSRVERR(("failed to wait for notify list Mutex (rcWait=%x,err=%d).\n",
                       rcWait, GetLastError()));
            rc = FALSE;
        }
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //TabSrvDeregisterEventNotify

/*++
    @doc    EXTERNAL

    @func   VOID | TabSrvGetLastRawDigiReport | Get the last raw digitizer
            report.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   OUT PWORD | pwButtonState | To hold the button state data.
    @parm   OUT PWORD | pwX | To hold the X data.
    @parm   OUT PWORD | pwY | To hold the Y data.

    @rvalue None.
--*/

VOID
TabSrvGetLastRawDigiReport(
    IN  handle_t hBinding,
    OUT PWORD    pwButtonState,
    OUT PWORD    pwX,
    OUT PWORD    pwY
    )
{
    TRACEPROC("TabSrvGetLastRawDigiReport", 2)

    TRACEENTER(("(hBinding=%x,pwButtonState=%p,pwX=%p,pwY=%p)\n",
                hBinding, pwButtonState, pwX, pwY));

    *pwButtonState = gLastRawDigiReport.wButtonState;
    *pwX = gLastRawDigiReport.wX;
    *pwY = gLastRawDigiReport.wY;

    TRACEEXIT(("!\n"));
    return;
}       //TabSrvGetLastRawDigiReport

/*++
    @doc    EXTERNAL

    @func   VOID | TabSrvSetPenTilt | Set pen tilt compensation.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN LONG | dx | x compensation.
    @parm   IN LONG | dy | y compensation.

    @rvalue None.
--*/

VOID
TabSrvSetPenTilt(
    IN handle_t hBinding,
    IN LONG     dx,
    IN LONG     dy
    )
{
    TRACEPROC("TabSrvSetPenTilt", 2)
    LPTSTR lptstrPenTilt;

    TRACEENTER(("(hBinding=%x,dx=%d,dy=%d)\n", hBinding, dx, dy));

    lptstrPenTilt = (gdwfTabSrv & TSF_PORTRAIT_MODE)? TEXT("PenTilt_Portrait"):
                                                      TEXT("PenTilt_Landscape");
    gConfig.PenTilt.dx = dx;
    gConfig.PenTilt.dy = dy;
    WriteConfig(lptstrPenTilt,
                REG_BINARY,
                (LPBYTE)&gConfig.PenTilt,
                sizeof(gConfig.PenTilt));

    TRACEEXIT(("!\n"));
    return;
}       //TabSrvSetPenTilt

/*++
    @doc    EXTERNAL

    @func   BOOL | TabSrvGetLinearityMap | Get linearity map.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   OUT PLINEARITY_MAP | LinearityMap | Points to the linearity map.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
TabSrvGetLinearityMap(
    IN  handle_t    hBinding,
    OUT PLINEAR_MAP LinearityMap
    )
{
    TRACEPROC("TabSrvGetLinearityMap", 2)
    BOOL rc;

    TRACEENTER(("(hBinding=%x,pLinearityMap=%p)\n", hBinding, LinearityMap));

    if (gdwfTabSrv & TSF_HAS_LINEAR_MAP)
    {
        *LinearityMap = gConfig.LinearityMap;
        rc = TRUE;
    }
    else
    {
        rc = FALSE;
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //TabSrvGetLinearityMap

/*++
    @doc    EXTERNAL

    @func   VOID | TabSrvSetLinearityMap | Set linearity map.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN PLINEARITY_MAP | LinearityMap | Points to the linearity map.

    @rvalue None.
--*/

VOID
TabSrvSetLinearityMap(
    IN handle_t    hBinding,
    IN PLINEAR_MAP LinearityMap
    )
{
    TRACEPROC("TabSrvSetLinearityMap", 2)
    TRACEENTER(("(hBinding=%x,pLinearityMap=%p)\n", hBinding, LinearityMap));

    gConfig.LinearityMap = *LinearityMap;

    WriteConfig(gtszLinearityMap,
                REG_BINARY,
                (LPBYTE)&gConfig.LinearityMap,
                sizeof(gConfig.LinearityMap));
    gdwfTabSrv |= TSF_HAS_LINEAR_MAP;

    TRACEEXIT(("!\n"));
    return;
}       //TabSrvSetLinearityMap

/*++
    @doc    EXTERNAL

    @func   BOOL | TabSrvGetPenFeatures | Get digitizer feature report.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN WORD | wReportID | Report ID of the feature report.
    @parm   IN WORD | wUsagePage | Usage page of the digitizer.
    @parm   IN WORD | wUsage | Usage of the digitizer page.
    @parm   OUT DWORD * | pdwFeature | To hold the feature value.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
TabSrvGetPenFeatures(
    IN handle_t hBinding,
    IN  WORD    wReportID,
    IN  WORD    wUsagePage,
    IN  WORD    wUsage,
    OUT DWORD  *pdwFeature
    )
{
    TRACEPROC("TabSrvGetPenFeatures", 2)
    BOOL rc = FALSE;
    PCHAR buff;

    TRACEENTER(("(hBinding=%x,ReportID=%d,UsagePage=%d,Usage=%d,pdwFeature=%p)\n",
                hBinding, wReportID, wUsagePage, wUsage, pdwFeature));

    if (gdevDigitizer.hDevice != INVALID_HANDLE_VALUE)
    {
        buff = (PCHAR)calloc(gdevDigitizer.hidCaps.FeatureReportByteLength,
                             sizeof(CHAR));
        TRACEASSERT(buff != NULL);

        *buff = (CHAR)wReportID;
        rc = HidD_GetFeature(gdevDigitizer.hDevice,
                             buff,
                             gdevDigitizer.hidCaps.FeatureReportByteLength);
        if (rc == TRUE)
        {
            NTSTATUS status;

            status = HidP_GetUsageValue(
                        HidP_Feature,
                        wUsagePage,
                        0,
                        wUsage,
                        pdwFeature,
                        gdevDigitizer.pPreParsedData,
                        buff,
                        gdevDigitizer.hidCaps.FeatureReportByteLength);
            if (status != HIDP_STATUS_SUCCESS)
            {
                rc = FALSE;
                TABSRVERR(("Failed to get feature value (status=%x).\n",
                           status));
            }
        }
        else
        {
            TABSRVERR(("Failed to get device feature.\n"));
        }

        if (buff != NULL)
        {
            free(buff);
        }
    }

    TRACEEXIT(("=%x (Feature=%x)\n", *pdwFeature));
    return rc;
}       //TabSrvGetPenFeatures

/*++
    @doc    EXTERNAL

    @func   BOOL | TabSrvSetPenFeatures | Set digitizer feature report.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN WORD | wReportID | Report ID of the feature report.
    @parm   IN WORD | wUsagePage | Usage page of the digitizer.
    @parm   IN WORD | wUsage | Usage of the digitizer page.
    @parm   IN DWORD | dwFeature | Feature value.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
TabSrvSetPenFeatures(
    IN handle_t hBinding,
    IN WORD     wReportID,
    IN WORD     wUsagePage,
    IN WORD     wUsage,
    IN DWORD    dwFeature
    )
{
    TRACEPROC("TabSrvSetPenFeatures", 2)
    BOOL rc = FALSE;
    PCHAR buff;
    NTSTATUS status;

    TRACEENTER(("(hBinding=%x,ReportID=%d,UsagePage=%d,Usage=%d,Feature=%x)\n",
                hBinding, wReportID, wUsagePage, wUsage, dwFeature));

    if (gdevDigitizer.hDevice != INVALID_HANDLE_VALUE)
    {
        buff = (PCHAR)calloc(gdevDigitizer.hidCaps.FeatureReportByteLength,
                             sizeof(CHAR));
        TRACEASSERT(buff != NULL);

        *buff = (CHAR)wReportID;
        status = HidP_SetUsageValue(
                        HidP_Feature,
                        wUsagePage,
                        0,
                        wUsage,
                        dwFeature,
                        gdevDigitizer.pPreParsedData,
                        buff,
                        gdevDigitizer.hidCaps.FeatureReportByteLength);
        if (status == HIDP_STATUS_SUCCESS)
        {
            rc = HidD_SetFeature(gdevDigitizer.hDevice,
                                 buff,
                                 gdevDigitizer.hidCaps.FeatureReportByteLength);
            if (rc == FALSE)
            {
                TABSRVERR(("Failed to set device feature.\n"));
            }
        }
        else
        {
            TABSRVERR(("Failed to set feature value (status=%x).\n", status));
        }

        if (buff != NULL)
        {
            free(buff);
        }
    }

    TRACEEXIT(("=%x\n", rc));
    return rc;
}       //TabSrvSetPenFeatures

/*++
    @doc    EXTERNAL

    @func   BOOL | TabSrvGetGestureSettings | Get gesture settings.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   OUT PGESTURE_SETTINGS | GestureSettings | To hold the gesture
            settings.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
TabSrvGetGestureSettings(
    IN handle_t           hBinding,
    OUT PGESTURE_SETTINGS GestureSettings
    )
{
    TRACEPROC("TabSrvGetGestureSettings", 2)
    TRACEENTER(("(hBinding=%x,pSettings=%p)\n", hBinding, GestureSettings));

    *GestureSettings = gConfig.GestureSettings;

    TRACEEXIT(("=1 (Features=%x,Radius=%d,StopDist=%d,StopTime=%d)\n",
               GestureSettings->dwfFeatures, GestureSettings->iRadius,
               GestureSettings->iStopDist, GestureSettings->iStopTime));
    return TRUE;
}       //TabSrvGetGestureSettings

/*++
    @doc    EXTERNAL

    @func   BOOL | TabSrvSetGestureSettings | Set gesture settings.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN PGESTURE_SETTINGS | GestureSettings | Point to the gesture
            settings to set.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
TabSrvSetGestureSettings(
    IN handle_t          hBinding,
    IN PGESTURE_SETTINGS GestureSettings
    )
{
    TRACEPROC("TabSrvSetGestureSettings", 2)
    BOOL rc = FALSE;
    PTSTHREAD MouseThread;

    TRACEENTER(("(hBinding=%x,pSettings=%p,Features=%x,Radius=%d,StopDist=%d,StopTime=%d)\n",
                hBinding, GestureSettings, GestureSettings->dwfFeatures,
                GestureSettings->iRadius, GestureSettings->iStopDist,
                GestureSettings->iStopTime));

    gConfig.GestureSettings = *GestureSettings;

    WriteConfig(gtszGestureSettings,
                REG_BINARY,
                (LPBYTE)&gConfig.GestureSettings,
                sizeof(gConfig.GestureSettings));

    MouseThread = FindThread(TSF_MOUSETHREAD);
    if (MouseThread != NULL)
    {
        if (gConfig.GestureSettings.dwfFeatures & GESTURE_FEATURE_MOUSE_ENABLED)
        {
            MouseThread->dwfThread |= THREADF_ENABLED;
        }
        else
        {
            MouseThread->dwfThread &= ~THREADF_ENABLED;
        }

        if ((MouseThread->dwfThread & THREADF_ENABLED) &&
            (MouseThread->hThread == NULL))
        {
            //
            // Mouse thread is enabled but not running, so start it.
            //
            if (!InitThreads(MouseThread, 1))
            {
                TABSRVERR(("failed to start mouse thread.\n"));
            }
        }
        else if (!(MouseThread->dwfThread & THREADF_ENABLED) &&
                 (MouseThread->hThread != NULL))
        {
            //
            // Mouse thread is disabled but it is currently running, so kill it.
            //
            if (ghwndMouse != NULL)
            {
                DWORD rcWait;

                gdwfTabSrv |= TSF_TERMINATE;
                PostMessage(ghwndMouse, WM_CLOSE, 0, 0);
                rcWait = WaitForSingleObject(MouseThread->hThread, 1000);
                if (rcWait != WAIT_OBJECT_0)
                {
                    TABSRVERR(("failed to kill mouse thread (rcWait=%x,err=%d)\n",
                               rcWait, GetLastError()));
                }
                gdwfTabSrv &= ~TSF_TERMINATE;
            }
        }
    }

    TRACEEXIT(("=1\n"));
    return TRUE;
}       //TabSrvSetGestureSettings

/*++
    @doc    EXTERNAL

    @func   BOOL | TabSrvGetButtonSettings | Get button settings.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   OUT PBUTTON_SETTINGS | ButtonSettings | To hold the button
            settings.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
TabSrvGetButtonSettings(
    IN  handle_t         hBinding,
    OUT PBUTTON_SETTINGS ButtonSettings
    )
{
    TRACEPROC("TabSrvGetButtonSettings", 2)
    TRACEENTER(("(hBinding=%x,pSettings=%p)\n", hBinding, ButtonSettings));

    *ButtonSettings = gConfig.ButtonSettings;

    TRACEEXIT(("=1\n"));
    return TRUE;
}       //TabSrvGetButtonSettings

/*++
    @doc    EXTERNAL

    @func   BOOL | TabSrvSetButtonSettings | Set button settings.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN PBUTTON_SETTINGS | ButtonSettings | Point to the button
            settings to set.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
TabSrvSetButtonSettings(
    IN handle_t         hBinding,
    IN PBUTTON_SETTINGS ButtonSettings
    )
{
    TRACEPROC("TabSrvSetButtonSettings", 2)
    BOOL rc = FALSE;
    PTSTHREAD MouseThread;

    TRACEENTER(("(hBinding=%x,pSettings=%p)\n", hBinding, ButtonSettings));

    gConfig.ButtonSettings = *ButtonSettings;

    WriteConfig(gtszButtonSettings,
                REG_BINARY,
                (LPBYTE)&gConfig.ButtonSettings,
                sizeof(gConfig.ButtonSettings));

    TRACEEXIT(("=1\n"));
    return TRUE;
}       //TabSrvSetGestureSettings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tracer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ttt.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tracer\resid.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    resid.h

Abstract:  Contains definitions of all resource IDs.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 02-May-2000

Revision History:

--*/

#ifndef _RESID_H
#define _RESID_H

//
// Global Resources
//
#define IDS_ERRSPACE                    1
#define IDS_GETSAVEFILENAME_FAILED      2
#define IDS_CREATEFILE_FAILED           3
#define IDS_WRITEFILE_FAILED            4
#define IDS_CHOOSEFONT_FAILED           5
#define IDSERR_PROP_SHEET               6

#define IDI_TRACER                      100
#define IDD_MENU                        101
#define IDD_GLOBALSETTINGS              102
#define IDD_CLIENTSETTINGS              103

#define IDC_GLOBALTRACE                 200
#define IDC_GLOBALTRACESPIN             201
#define IDC_GLOBALTRACETEXT             202
#define IDC_GLOBALTRACEDEBUGGER         203
#define IDC_GLOBALVERBOSE               204
#define IDC_GLOBALVERBOSESPIN           205
#define IDC_GLOBALVERBOSETEXT           206

#define IDC_CLIENTTRACE                 300
#define IDC_CLIENTTRACESPIN             301
#define IDC_CLIENTTRACETEXT             302
#define IDC_CLIENTTRACEDEBUGGER         303
#define IDC_CLIENTVERBOSE               304
#define IDC_CLIENTVERBOSESPIN           305
#define IDC_CLIENTVERBOSETEXT           306
#define IDC_CLIENTTRIGGERTRACE          307
#define IDC_CLIENTTRIGPTGROUPBOX        308

#define IDC_TRIGPT1_TEXT                310
#define IDC_TRIGPT1_TRACE_TEXT          311
#define IDC_TRIGPT1_BREAK_TEXT          312
#define IDC_TRIGPT1                     313
#define IDC_TRIGPT1_TRACE               314
#define IDC_TRIGPT1_BREAK               315

#define IDC_TRIGPT2_TEXT                316
#define IDC_TRIGPT2_TRACE_TEXT          317
#define IDC_TRIGPT2_BREAK_TEXT          318
#define IDC_TRIGPT2                     319
#define IDC_TRIGPT2_TRACE               320
#define IDC_TRIGPT2_BREAK               321

#define IDC_TRIGPT3_TEXT                322
#define IDC_TRIGPT3_TRACE_TEXT          323
#define IDC_TRIGPT3_BREAK_TEXT          324
#define IDC_TRIGPT3                     325
#define IDC_TRIGPT3_TRACE               326
#define IDC_TRIGPT3_BREAK               327

#define IDC_TRIGPT4_TEXT                328
#define IDC_TRIGPT4_TRACE_TEXT          329
#define IDC_TRIGPT4_BREAK_TEXT          330
#define IDC_TRIGPT4                     331
#define IDC_TRIGPT4_TRACE               332
#define IDC_TRIGPT4_BREAK               333

#define IDC_TRIGPT5_TEXT                334
#define IDC_TRIGPT5_TRACE_TEXT          335
#define IDC_TRIGPT5_BREAK_TEXT          336
#define IDC_TRIGPT5                     337
#define IDC_TRIGPT5_TRACE               338
#define IDC_TRIGPT5_BREAK               339

#define IDC_TRIGPT6_TEXT                340
#define IDC_TRIGPT6_TRACE_TEXT          341
#define IDC_TRIGPT6_BREAK_TEXT          342
#define IDC_TRIGPT6                     343
#define IDC_TRIGPT6_TRACE               344
#define IDC_TRIGPT6_BREAK               345

#define IDC_TRIGPT7_TEXT                346
#define IDC_TRIGPT7_TRACE_TEXT          347
#define IDC_TRIGPT7_BREAK_TEXT          348
#define IDC_TRIGPT7                     349
#define IDC_TRIGPT7_TRACE               350
#define IDC_TRIGPT7_BREAK               351

#define IDC_TRIGPT8_TEXT                352
#define IDC_TRIGPT8_TRACE_TEXT          353
#define IDC_TRIGPT8_BREAK_TEXT          354
#define IDC_TRIGPT8                     355
#define IDC_TRIGPT8_TRACE               356
#define IDC_TRIGPT8_BREAK               357

#define IDC_TRIGPT9_TEXT                358
#define IDC_TRIGPT9_TRACE_TEXT          359
#define IDC_TRIGPT9_BREAK_TEXT          360
#define IDC_TRIGPT9                     361
#define IDC_TRIGPT9_TRACE               362
#define IDC_TRIGPT9_BREAK               363

#define IDC_TRIGPT10_TEXT               364
#define IDC_TRIGPT10_TRACE_TEXT         365
#define IDC_TRIGPT10_BREAK_TEXT         366
#define IDC_TRIGPT10                    367
#define IDC_TRIGPT10_TRACE              368
#define IDC_TRIGPT10_BREAK              369

#define M_SAVE                          500
#define M_SAVEAS                        501
#define M_PRINT                         502
#define M_EXIT                          503
#define M_CLEAR                         504
#define M_FIND                          505
#define M_FINDNEXT                      506
#define M_GOTO                          507
#define M_WORDWRAP                      508
#define M_SETFONT                       509
#define M_CLIENTS                       510
#define M_HELP                          511
#define M_ABOUT                         512

#define IDS_APP                         1000
#define IDS_TITLE                       1001
#define IDS_UNTITLED                    1002
#define IDS_SAVEAS                      1003
#define IDS_TEXTFILES                   1004
#define IDS_ALLFILES                    1005
#define IDS_CLIENT_SETTINGS             1006

#endif  //ifndef _RESID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tracer\pch.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pch.h

Abstract:  Pre-compile C header file.


Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#ifndef _PCH_H
#define _PCH_H

#define MODNAME                 "TRACER"

#if DBG
  #define TRDEBUG
  #define TRTRACE
#endif

#include <malloc.h>
#include <process.h>
#include <windows.h>
#include <shellapi.h>
#include <commdlg.h>
#include <commctrl.h>
#include <prsht.h>
#include <wintrace.h>
#include "wtrace.h"
#include "tracer.h"
#include "trdebug.h"
#include "trtrace.h"
#include "resid.h"

#endif  //ifndef _PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tracer\server.c ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:
    server.c

Abstract:
    This module contains the server code for dealing with clients.

Author:
    Michael Tsang (MikeTs) 02-May-2000

Environment:
    User mode

Revision History:

--*/

#include "pch.h"

/*++
    @doc    INTERNAL

    @func   VOID | ServerThread | Server thread procedure.

    @parm   IN PVOID | pv | (Not Used).

    @rvalue None.
--*/

VOID __cdecl
ServerThread(
    IN PVOID pv
    )
{
    TRTRACEPROC("ServerThread", 1)
    RPC_STATUS status;
    RPC_BINDING_VECTOR *BindingVector = NULL;

    TRENTER(("(pv=%p)\n", pv));

    if ((status = RpcServerUseProtseq("ncalrpc",
                                      RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
//                                        "\\pipe\\tracer",
                                      NULL)) != RPC_S_OK)
    {
        TRERRPRINT(("RpcServerUseProtseq failed (status=%d)\n", status));
    }
    else if ((status = RpcServerRegisterIf(WTServer_v1_0_s_ifspec, NULL, NULL))
             != RPC_S_OK)
    {
        TRERRPRINT(("RpcServerRegisterIf failed (status=%d)\n", status));
    }
    else if ((status = RpcServerInqBindings(&BindingVector)) != RPC_S_OK)
    {
        TRERRPRINT(("RpcServerInqBindings failed (status=%d)\n", status));
    }
    else if ((status = RpcEpRegister(WTServer_v1_0_s_ifspec,
                                     BindingVector,
                                     NULL,
                                     NULL)) != RPC_S_OK)
    {
        RpcBindingVectorFree(&BindingVector);
        TRERRPRINT(("RpcEpRegister failed (status=%d)\n", status));
    }
    else if ((status = RpcServerRegisterAuthInfo(NULL,
                                                 RPC_C_AUTHN_WINNT,
                                                 NULL,
                                                 NULL)) != RPC_S_OK)
    {
        RpcEpUnregister(WTServer_v1_0_s_ifspec, BindingVector, NULL);
        RpcBindingVectorFree(&BindingVector);
        TRERRPRINT(("RpcServerRegisterAuthInfo failed (status=%d)\n", status));
    }
    else
    {
        status = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, FALSE);
        TRASSERT(status == RPC_S_OK);
        RpcEpUnregister(WTServer_v1_0_s_ifspec, BindingVector, NULL);
        RpcBindingVectorFree(&BindingVector);
    }
    _endthread();

    TREXIT(("!\n"));
    return;
}       //ServerThread

/*++
    @doc    EXTERNAL

    @func   HCLIENT | WTRegisterClient | Register a new client.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN unsigned char * | pszClientName |
            Points to the client name string.

    @rvalue SUCCESS | Returns new client handle.
    @rvalue FAILURE | Returns NULL.
--*/

HCLIENT
WTRegisterClient(
    IN handle_t       hBinding,
    IN unsigned char *pszClientName
    )
{
    TRTRACEPROC("WTRegisterClient", 1)
    PCLIENT_ENTRY ClientEntry;

    TRENTER(("(hBinding=%p,ClientName=%s)\n", hBinding, pszClientName));

    ClientEntry = (PCLIENT_ENTRY)malloc(sizeof(CLIENT_ENTRY));
    if (ClientEntry != NULL)
    {
        memset(ClientEntry, 0, sizeof(*ClientEntry));
        lstrcpynA(ClientEntry->szClientName,
                  pszClientName,
                  sizeof(ClientEntry->szClientName));
        InsertTailList(&glistClients, &ClientEntry->list);
        WTGetClientInfo(&ClientEntry->ClientInfo);
        if ((ClientEntry->ClientInfo.Settings.iVerboseLevel +
             ClientEntry->ClientInfo.Settings.iTraceLevel +
             ClientEntry->ClientInfo.Settings.dwfSettings == 0) &&
            (gDefGlobalSettings.iVerboseLevel +
             gDefGlobalSettings.iTraceLevel +
             gDefGlobalSettings.dwfSettings != 0))
        {
            ClientEntry->ClientInfo.Settings = gDefGlobalSettings;
            WTSetClientInfo(&ClientEntry->ClientInfo);
        }

        if (ghwndPropSheet != NULL)
        {
            PROPSHEETPAGEA psp;
            HPROPSHEETPAGE hpsp;

            psp.dwSize = sizeof(psp);
            psp.dwFlags = PSP_USETITLE;
            psp.hInstance = ghInstance;
            psp.pszTitle = ClientEntry->szClientName;
            psp.lParam = (LPARAM)ClientEntry;
            psp.pszTemplate = (LPSTR)MAKEINTRESOURCE(IDD_CLIENTSETTINGS);
            psp.pfnDlgProc = ClientSettingsDlgProc;
            hpsp = CreatePropertySheetPageA(&psp);

            ClientEntry->hPage = hpsp;
            PropSheet_AddPage(ghwndPropSheet, hpsp);
        }
    }
    else
    {
        TRERRPRINT(("failed to allocate client entry for %s\n", pszClientName));
    }

    TREXIT(("=%p\n", ClientEntry));
    return (HCLIENT)ClientEntry;
}       //WTRegisterClient

/*++
    @doc    EXTERNAL

    @func   VOID | WTDeregisterClient | Deregister a client.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN HCLIENT | hClient | Client handle.

    @rvalue None.
--*/

VOID
WTDeregisterClient(
    IN handle_t hBinding,
    IN HCLIENT  hClient
    )
{
    TRTRACEPROC("WTDeregisterClient", 1)
    PCLIENT_ENTRY ClientEntry = (PCLIENT_ENTRY)hClient;

    TRENTER(("(hBinding=%p,hClient=%p)\n", hBinding, hClient));

    RemoveEntryList(&ClientEntry->list);
    if (ghwndPropSheet != NULL)
    {
        PropSheet_RemovePage(ghwndPropSheet, 0, ClientEntry->hPage);
    }
    SendServerRequest(ClientEntry, SRVREQ_TERMINATE, NULL);
    free(ClientEntry);

    TREXIT(("!\n"));
    return;
}       //WTDeregisterClient

/*++
    @doc    EXTERNAL

    @func   VOID | WTTraceProc | Print the TraceProc text.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN HCLIENT | hClient | Client handle.
    @parm   IN DWORD | dwThreadId | Thread ID.
    @parm   IN int | iIndentLevel | Specifies the level of indentation.
    @parm   IN unsigned char * | pszText | Points to the TraceProc text.

    @rvalue None.
--*/

VOID
WTTraceProc(
    IN handle_t       hBinding,
    IN HCLIENT        hClient,
    IN DWORD          dwThreadId,
    IN int            iIndentLevel,
    IN unsigned char *pszText
    )
{
    TRTRACEPROC("WTTraceProc", 1)
    PCLIENT_ENTRY ClientEntry = (PCLIENT_ENTRY)hClient;
    static char szText[1024];
    int i;
    LONG lSel;

    TRENTER(("(hBinding=%p,hClient=%p,ThreadId=%x,IndentLevel=%d,Text=%s)\n",
             hBinding, hClient, dwThreadId, iIndentLevel, pszText));

    wsprintfA(szText, "[%08x]%s: ", dwThreadId, ClientEntry->szClientName);
    for (i = 0; i < iIndentLevel; ++i)
    {
        lstrcpyA(&szText[lstrlenA(szText)], "| ");
    }
    CopyStr(&szText[lstrlenA(szText)], pszText);
    lSel = (LONG)SendMessage(ghwndEdit, WM_GETTEXTLENGTH, 0, 0);
    SendMessage(ghwndEdit, EM_SETSEL, lSel, lSel);
    SendMessage(ghwndEdit, EM_REPLACESEL, 0, (LPARAM)szText);

    TREXIT(("!\n"));
    return;
}       //WTTraceProc

/*++
    @doc    EXTERNAL

    @func   VOID | WTTraceMsg | Print the TraceMsg text.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN HCLIENT | hClient | Client handle.
    @parm   IN unsigned char * | pszMsg | Points to the TraceMsg text.

    @rvalue None.
--*/

VOID
WTTraceMsg(
    IN handle_t       hBinding,
    IN HCLIENT        hClient,
    IN unsigned char *pszMsg
    )
{
    TRTRACEPROC("WTTraceMsg", 1)
    PCLIENT_ENTRY ClientEntry = (PCLIENT_ENTRY)hClient;
    static char szText[1024];
    LONG lSel;

    TRENTER(("(hBinding=%p,hClient=%p,Msg=%s)\n", hBinding, hClient, pszMsg));

    CopyStr(szText, pszMsg);
    lSel = (LONG)SendMessage(ghwndEdit, WM_GETTEXTLENGTH, 0, 0);
    SendMessage(ghwndEdit, EM_SETSEL, lSel, lSel);
    SendMessage(ghwndEdit, EM_REPLACESEL, 0, (LPARAM)szText);

    TREXIT(("!\n"));
    return;
}       //WTTraceMsg

/*++
    @doc    EXTERNAL

    @func   VOID | WTDispatchServerRequests | Dispatch server requests to the
            client.

    @parm   IN handle_t | hBinding | RPC binding handle.
    @parm   IN HCLIENT | hClient | Client handle.

    @rvalue None.
--*/

VOID
WTDispatchServerRequests(
    IN handle_t hBinding,
    IN HCLIENT  hClient
    )
{
    TRTRACEPROC("WTDispatchServerRequests", 1)
    PCLIENT_ENTRY ClientEntry = (PCLIENT_ENTRY)hClient;

    TRENTER(("(hBinding=%p,hClient=%p)\n", hBinding, hClient));

    TRASSERT(ClientEntry->hSrvReqEvent == 0);
    ClientEntry->hSrvReqEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (ClientEntry->hSrvReqEvent == NULL)
    {
        TRERRPRINT(("failed to create server request event (err=%d)\n",
                    GetLastError()));
    }
    else
    {
        BOOL fDone = FALSE;
        LONG Req;
        DWORD rcWait;

        while (!fDone)
        {
            Req = InterlockedExchange(&ClientEntry->SrvReq.lRequest,
                                      SRVREQ_BUSY);
            switch (Req)
            {
                case SRVREQ_NONE:
                    Req = InterlockedExchange(&ClientEntry->SrvReq.lRequest,
                                              Req);
                    TRASSERT(Req == SRVREQ_BUSY);
                    rcWait = WaitForSingleObject(ClientEntry->hSrvReqEvent,
                                                 INFINITE);
                    if (rcWait != WAIT_OBJECT_0)
                    {
                        TRERRPRINT(("failed waiting for server request event (err=%d)\n",
                                    GetLastError));
                    }
                    break;

                case SRVREQ_BUSY:
                    //
                    // Try again.
                    //
                    break;

                case SRVREQ_GETCLIENTINFO:
                    WTGetClientInfo((PCLIENTINFO)ClientEntry->SrvReq.Context);
                    Req = InterlockedExchange(&ClientEntry->SrvReq.lRequest,
                                              SRVREQ_NONE);
                    TRASSERT(Req == SRVREQ_BUSY);
                    break;

                case SRVREQ_SETCLIENTINFO:
                    WTSetClientInfo((PCLIENTINFO)ClientEntry->SrvReq.Context);
                    Req = InterlockedExchange(&ClientEntry->SrvReq.lRequest,
                                              SRVREQ_NONE);
                    TRASSERT(Req == SRVREQ_BUSY);
                    break;

                case SRVREQ_TERMINATE:
                    fDone = TRUE;
                    Req = InterlockedExchange(&ClientEntry->SrvReq.lRequest,
                                              SRVREQ_NONE);
                    TRASSERT(Req == SRVREQ_BUSY);
                    break;

                default:
                    TRERRPRINT(("unexpected server request %x.\n", Req));
                    Req = InterlockedExchange(&ClientEntry->SrvReq.lRequest,
                                              SRVREQ_NONE);
                    TRASSERT(Req == SRVREQ_BUSY);
            }
        }

        CloseHandle(ClientEntry->hSrvReqEvent);
        ClientEntry->hSrvReqEvent = 0;
    }

    TREXIT(("!\n"));
    return;
}       //WTDispatchServerRequests

/*++
    @doc    INTERNAL

    @func   VOID | SendServerRequest | Send a server request to the client.

    @parm   IN PCLIENT_ENTRY | ClientEntry | Points to the client entry.
    @parm   IN LONG | lRequest | Request.
    @parm   IN PVOID | Context | Request context.

    @rvalue None.
--*/

VOID
SendServerRequest(
    IN PCLIENT_ENTRY ClientEntry,
    IN LONG          lRequest,
    IN PVOID         Context
    )
{
    TRTRACEPROC("SendServerRequest", 1)
    LONG Req;

    TRENTER(("(ClientEntry=%p,Request=%x,Context=%p)\n",
             ClientEntry, lRequest, Context));

    while (InterlockedCompareExchange(&ClientEntry->SrvReq.lRequest,
                                      SRVREQ_BUSY,
                                      SRVREQ_NONE) != SRVREQ_NONE)
        ;
    ClientEntry->SrvReq.Context = Context;
    Req = InterlockedExchange(&ClientEntry->SrvReq.lRequest, lRequest);
    TRASSERT(Req == SRVREQ_BUSY);
    SetEvent(ClientEntry->hSrvReqEvent);

    TREXIT(("!\n"));
    return;
}       //SendServerRequest

/*++
    @doc    INTERNAL

    @func   LPSTR | CopyStr | Copy string from source to destination and
            replaces all the '\n' to '\r\n'.

    @parm   OUT LPSTR | pszDest | Points to the destination string.
    @parm   IN LPCSTR | pszSrc | Points to the source string.

    @rvalue Returns pointer to the destination string.
--*/

LPSTR
CopyStr(
    OUT LPSTR  pszDest,
    IN  LPCSTR pszSrc
    )
{
    TRTRACEPROC("CopyStr", 3)
    LPSTR psz;

    TRENTER(("(Dest=%p,Src=%s)\n", pszDest, pszSrc));

    for (psz = pszDest; *pszSrc != '\0'; psz++, pszSrc++)
    {
        if (*pszSrc != '\n')
        {
            *psz = *pszSrc;
        }
        else
        {
            *psz = '\r';
            psz++;
            *psz = '\n';
        }
    }
    *psz = '\0';

    TREXIT(("=%p (Dest=%s)\n", pszDest, pszDest));
    return pszDest;
}       //CopyStr

/*++
    @doc    EXTERNAL

    @func   void __RPC_FAR * | MIDL_user_allocate | MIDL allocate.

    @parm   IN size_t | len | size of allocation.

    @rvalue SUCCESS | Returns the pointer to the memory allocated.
    @rvalue FAILURE | Returns NULL.
--*/

void __RPC_FAR * __RPC_USER
MIDL_user_allocate(
    IN size_t len
    )
{
    TRTRACEPROC("MIDL_user_allocate", 5)
    void __RPC_FAR *ptr;

    TRENTER(("(len=%d)\n", len));

    ptr = malloc(len);

    TREXIT(("=%p\n", ptr));
    return ptr;
}       //MIDL_user_allocate

/*++
    @doc    EXTERNAL

    @func   void | MIDL_user_free | MIDL free.

    @parm   IN void __PRC_FAR * | ptr | Points to the memory to be freed.

    @rvalue None.
--*/

void __RPC_USER
MIDL_user_free(
    IN void __RPC_FAR *ptr
    )
{
    TRTRACEPROC("MIDL_user_free", 5)

    TRENTER(("(ptr=%p)\n", ptr));

    free(ptr);

    TREXIT(("!\n"));
    return;
}       //MIDL_user_free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tracer\trdebug.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    trdebug.c

Abstract: This module contains all the debug functions.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#include "pch.h"

#ifdef TRDEBUG

int giTRVerboseLevel = 0;
NAMETABLE WMMsgNames[] =
{
    WM_NULL,                            "Null",
    WM_CREATE,                          "Create",
    WM_DESTROY,                         "Destroy",
    WM_MOVE,                            "Move",
    WM_SIZE,                            "Size",
    WM_ACTIVATE,                        "Activate",
    WM_SETFOCUS,                        "SetFocus",
    WM_KILLFOCUS,                       "KillFocus",
    WM_ENABLE,                          "Enable",
    WM_SETREDRAW,                       "SetRedraw",
    WM_SETTEXT,                         "SetText",
    WM_GETTEXT,                         "GetText",
    WM_GETTEXTLENGTH,                   "GetTextLen",
    WM_PAINT,                           "Paint",
    WM_CLOSE,                           "Close",
    WM_QUERYENDSESSION,                 "QueryEndSession",
    WM_QUERYOPEN,                       "QueryOpen",
    WM_ENDSESSION,                      "EndSession",
    WM_QUIT,                            "Quit",
    WM_ERASEBKGND,                      "EraseBackground",
    WM_SYSCOLORCHANGE,                  "SysColorChange",
    WM_SHOWWINDOW,                      "ShowWindow",
    WM_WININICHANGE,                    "WinIniChange",
    WM_SETTINGCHANGE,                   "SettingChange",
    WM_DEVMODECHANGE,                   "DevModeChange",
    WM_ACTIVATEAPP,                     "ActivateApp",
    WM_FONTCHANGE,                      "FontChange",
    WM_TIMECHANGE,                      "TimeChange",
    WM_CANCELMODE,                      "CancelMode",
    WM_SETCURSOR,                       "SetCursor",
    WM_MOUSEACTIVATE,                   "MouseActivate",
    WM_CHILDACTIVATE,                   "ChildActivate",
    WM_QUEUESYNC,                       "QueueSync",
    WM_GETMINMAXINFO,                   "GetMinMaxInfo",
    WM_PAINTICON,                       "PaintIcon",
    WM_ICONERASEBKGND,                  "IconEraseBackground",
    WM_NEXTDLGCTL,                      "NextDialogControl",
    WM_SPOOLERSTATUS,                   "SpoolerStatus",
    WM_DRAWITEM,                        "DrawItem",
    WM_MEASUREITEM,                     "MeasureItem",
    WM_DELETEITEM,                      "DeleteItem",
    WM_VKEYTOITEM,                      "VKeyToItem",
    WM_CHARTOITEM,                      "CharToItem",
    WM_SETFONT,                         "SetFont",
    WM_GETFONT,                         "GetFont",
    WM_SETHOTKEY,                       "SetHotKey",
    WM_GETHOTKEY,                       "GetHotKey",
    WM_QUERYDRAGICON,                   "QueryDragIcon",
    WM_COMPAREITEM,                     "CompareItem",
    WM_GETOBJECT,                       "GetObject",
    WM_COMPACTING,                      "Compacting",
    WM_COMMNOTIFY,                      "CommNotify",
    WM_WINDOWPOSCHANGING,               "WindowPosChanging",
    WM_WINDOWPOSCHANGED,                "WindowPosChanged",
    WM_POWER,                           "Power",
    WM_COPYDATA,                        "CopyData",
    WM_CANCELJOURNAL,                   "CancelJournal",
    WM_NOTIFY,                          "Notify",
    WM_INPUTLANGCHANGEREQUEST,          "InputLangChangeRequest",
    WM_INPUTLANGCHANGE,                 "InputLangChange",
    WM_TCARD,                           "TCard",
    WM_HELP,                            "Help",
    WM_USERCHANGED,                     "UserChanged",
    WM_NOTIFYFORMAT,                    "NotifyFormat",
    WM_CONTEXTMENU,                     "ContextMenu",
    WM_STYLECHANGING,                   "StyleChanging",
    WM_STYLECHANGED,                    "StyleChanged",
    WM_DISPLAYCHANGE,                   "DisplayChange",
    WM_GETICON,                         "GetIcon",
    WM_SETICON,                         "SetIcon",
    WM_NCCREATE,                        "NCCreate",
    WM_NCDESTROY,                       "NCDestroy",
    WM_NCCALCSIZE,                      "NCCalcSize",
    WM_NCHITTEST,                       "NCHitTest",
    WM_NCPAINT,                         "NCPaint",
    WM_NCACTIVATE,                      "NCActivate",
    WM_GETDLGCODE,                      "GetDialogCode",
    WM_SYNCPAINT,                       "SyncPaint",
    WM_NCMOUSEMOVE,                     "NCMouseMove",
    WM_NCLBUTTONDOWN,                   "NCLeftButtonDown",
    WM_NCLBUTTONUP,                     "NCLeftButtonUp",
    WM_NCLBUTTONDBLCLK,                 "NCLeftButtonDoubleClick",
    WM_NCRBUTTONDOWN,                   "NCRightButtonDown",
    WM_NCRBUTTONUP,                     "NCRightButtonUp",
    WM_NCRBUTTONDBLCLK,                 "NCRightButtonDoubleClick",
    WM_NCMBUTTONDOWN,                   "NCMiddleButtonDown",
    WM_NCMBUTTONUP,                     "NCMiddleButtonUp",
    WM_NCMBUTTONDBLCLK,                 "NCMiddleButtonDoubleClick",
    WM_NCXBUTTONDOWN,                   "NCXButtonDown",
    WM_NCXBUTTONUP,                     "NCXButtonUp",
    WM_NCXBUTTONDBLCLK,                 "NCXButtonDoubleClick",
    WM_KEYFIRST,                        "KeyFirst",
    WM_KEYDOWN,                         "KeyDown",
    WM_KEYUP,                           "KeyUp",
    WM_CHAR,                            "Char",
    WM_DEADCHAR,                        "DeadChar",
    WM_SYSKEYDOWN,                      "SysKeyDown",
    WM_SYSKEYUP,                        "SysKeyUp",
    WM_SYSCHAR,                         "SysChar",
    WM_SYSDEADCHAR,                     "SysDeadChar",
    WM_KEYLAST,                         "KeyLast",
    WM_IME_STARTCOMPOSITION,            "IMEStartComposition",
    WM_IME_ENDCOMPOSITION,              "IMEEndComposition",
    WM_IME_COMPOSITION,                 "IMEComposition",
    WM_IME_KEYLAST,                     "IMEKeyLast",
    WM_INITDIALOG,                      "InitDialog",
    WM_COMMAND,                         "Command",
    WM_SYSCOMMAND,                      "SysCommand",
    WM_TIMER,                           "Timer",
    WM_HSCROLL,                         "HScroll",
    WM_VSCROLL,                         "VScroll",
    WM_INITMENU,                        "InitMenu",
    WM_INITMENUPOPUP,                   "InitMenuPopup",
    WM_MENUSELECT,                      "MenuSelect",
    WM_MENUCHAR,                        "MenuChar",
    WM_ENTERIDLE,                       "EnterIdle",
    WM_MENURBUTTONUP,                   "MenuRightButtonUp",
    WM_MENUDRAG,                        "MenuDrag",
    WM_MENUGETOBJECT,                   "MenuGetObject",
    WM_UNINITMENUPOPUP,                 "UninitMenuPopup",
    WM_MENUCOMMAND,                     "MenuCommand",
    WM_CHANGEUISTATE,                   "ChangeUIState",
    WM_UPDATEUISTATE,                   "UpdateUIState",
    WM_QUERYUISTATE,                    "QueryUIState",
    WM_CTLCOLORMSGBOX,                  "CtlColorMsgBox",
    WM_CTLCOLOREDIT,                    "CtlColorEdit",
    WM_CTLCOLORLISTBOX,                 "CtlColorListBox",
    WM_CTLCOLORBTN,                     "CtlColorButton",
    WM_CTLCOLORDLG,                     "CtlColorDialog",
    WM_CTLCOLORSCROLLBAR,               "CtlColorScrollBar",
    WM_CTLCOLORSTATIC,                  "CtlColorStatic",
    WM_MOUSEFIRST,                      "MouseFirst",
    WM_MOUSEMOVE,                       "MouseMove",
    WM_LBUTTONDOWN,                     "LeftButtonDown",
    WM_LBUTTONUP,                       "LeftButtonUp",
    WM_LBUTTONDBLCLK,                   "LeftButtonDoubleClick",
    WM_RBUTTONDOWN,                     "RightButtonDown",
    WM_RBUTTONUP,                       "RightButtonUp",
    WM_RBUTTONDBLCLK,                   "RightButtonDoubleClick",
    WM_MBUTTONDOWN,                     "MiddleButtonDown",
    WM_MBUTTONUP,                       "MiddleButtonUp",
    WM_MBUTTONDBLCLK,                   "MiddleButtonDoubleClick",
    WM_MOUSEWHEEL,                      "MouseWheel",
    WM_XBUTTONDOWN,                     "XButtonDown",
    WM_XBUTTONUP,                       "XButtonUp",
    WM_XBUTTONDBLCLK,                   "XButtonDoubleClick",
    WM_MOUSELAST,                       "MouseLast",
    WM_PARENTNOTIFY,                    "ParentNotify",
    WM_ENTERMENULOOP,                   "EnterMenuLoop",
    WM_EXITMENULOOP,                    "ExitMenuLoop",
    WM_NEXTMENU,                        "NextMenu",
    WM_SIZING,                          "Sizing",
    WM_CAPTURECHANGED,                  "CaptureChanged",
    WM_MOVING,                          "Moving",
    WM_POWERBROADCAST,                  "PowerBroadcast",
    WM_DEVICECHANGE,                    "DeviceChange",
    WM_MDICREATE,                       "MDICreate",
    WM_MDIDESTROY,                      "MDIDestroy",
    WM_MDIACTIVATE,                     "MDIActivate",
    WM_MDIRESTORE,                      "MDIRestore",
    WM_MDINEXT,                         "MDINext",
    WM_MDIMAXIMIZE,                     "MDIMaximize",
    WM_MDITILE,                         "MDITitle",
    WM_MDICASCADE,                      "MDICascade",
    WM_MDIICONARRANGE,                  "MDIIconArrange",
    WM_MDIGETACTIVE,                    "MDIGetActive",
    WM_MDISETMENU,                      "MDISetMenu",
    WM_ENTERSIZEMOVE,                   "EnterSizeMove",
    WM_EXITSIZEMOVE,                    "ExitSizeMove",
    WM_DROPFILES,                       "DropFiles",
    WM_MDIREFRESHMENU,                  "MDIRefreshMenu",
    WM_IME_SETCONTEXT,                  "IMESetContext",
    WM_IME_NOTIFY,                      "IMENotify",
    WM_IME_CONTROL,                     "IMEControl",
    WM_IME_COMPOSITIONFULL,             "IMECompositionFull",
    WM_IME_SELECT,                      "IMESelect",
    WM_IME_CHAR,                        "IMEChar",
    WM_IME_REQUEST,                     "IMERequest",
    WM_IME_KEYDOWN,                     "IMEKeyDown",
    WM_IME_KEYUP,                       "IMEKeyUp",
    WM_MOUSEHOVER,                      "MouseHover",
    WM_MOUSELEAVE,                      "MouseLeave",
    WM_NCMOUSEHOVER,                    "NCMouseHover",
    WM_NCMOUSELEAVE,                    "NCMouseLeave",
    WM_CUT,                             "Cut",
    WM_COPY,                            "Copy",
    WM_PASTE,                           "Paste",
    WM_CLEAR,                           "Clear",
    WM_UNDO,                            "Undo",
    WM_RENDERFORMAT,                    "RenderFormat",
    WM_RENDERALLFORMATS,                "RenderAllFormats",
    WM_DESTROYCLIPBOARD,                "DestroyClipboard",
    WM_DRAWCLIPBOARD,                   "DrawClipboard",
    WM_PAINTCLIPBOARD,                  "PaintClipboard",
    WM_VSCROLLCLIPBOARD,                "VScrollClipboard",
    WM_SIZECLIPBOARD,                   "SizeClipboard",
    WM_ASKCBFORMATNAME,                 "AskCBFormatName",
    WM_CHANGECBCHAIN,                   "ChangeCBChain",
    WM_HSCROLLCLIPBOARD,                "HScrollClipboard",
    WM_QUERYNEWPALETTE,                 "QueryNewPalette",
    WM_PALETTEISCHANGING,               "PaletteIsChanging",
    WM_PALETTECHANGED,                  "PaletteChanged",
    WM_HOTKEY,                          "HotKey",
    WM_PRINT,                           "Print",
    WM_PRINTCLIENT,                     "PrintClient",
    WM_APPCOMMAND,                      "AppCommand",
    WM_HANDHELDFIRST,                   "HandHeldFirst",
    WM_HANDHELDLAST,                    "HandHeldLast",
    WM_AFXFIRST,                        "AFXFirst",
    WM_AFXLAST,                         "AFXLast",
    WM_PENWINFIRST,                     "PenWinFirst",
    WM_PENWINLAST,                      "PenWinLast",
    WM_USER,                            "User",
    WM_APP,                             "App",
    0x00,                               NULL
};
NAMETABLE SrvReqNames[] =
{
    SRVREQ_NONE,                        "None",
    SRVREQ_BUSY,                        "Busy",
    SRVREQ_GETCLIENTINFO,               "GetClientInfo",
    SRVREQ_SETCLIENTINFO,               "SetClientInfo",
    SRVREQ_TERMINATE,                   "Terminate",
    0x00,                               NULL
};

/*++
    @doc    INTERNAL

    @func   VOID | TRDebugPrint | Print to system debugger.

    @parm   IN LPCSTR | format | Points to the format string.
    @parm   ... | Arguments.

    @rvalue SUCCESS | returns the number of chars stored in the buffer not
            counting the terminating null characters.
    @rvalue FAILURE | returns less than the length of the expected output.
--*/

int
TRDebugPrint(
    IN LPCSTR format,
    ...
    )
{
    int n;
    static char szMessage[256] = {0};
    va_list arglist;

    va_start(arglist, format);
    n = wvsprintfA(szMessage, format, arglist);
    va_end(arglist);
    OutputDebugStringA(szMessage);

    return n;
}       //TRDebugPrint

/*++
    @doc    INTERNAL

    @func   PSZ | LookupName |
            Look up name string of a code in the given name table.

    @parm   IN ULONG | Code | The given code to lookup.
    @parm   IN PNAMETABLE | NameTable | The name table to look into.

    @rvalue SUCCESS - Returns pointer to the minor function name string.
    @rvalue FAILURE - Returns "unknown".
--*/

PSZ
LookupName(
    IN ULONG      Code,
    IN PNAMETABLE NameTable
    )
{
    PSZ pszName = NULL;
    static char szUnknown[64];

    while (NameTable->pszName != NULL)
    {
        if (Code == NameTable->Code)
        {
            pszName = NameTable->pszName;
            break;
        }
        NameTable++;
    }

    if (pszName == NULL)
    {
        wsprintfA(szUnknown, "unknown[0x%x(%d)]", Code, Code);
        pszName = szUnknown;
    }

    return pszName;
}       //LookupName

#endif  //ifdef TRDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tracer\trdebug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    trdebug.h

Abstract:  Contains debug related definitions.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#ifndef _TRDEBUG_H
#define _TRDEBUG_H

//
// Macros
//
#ifdef TRDEBUG
  #define TRASSERT(x)           if (!(x))                                      \
                                {                                              \
                                    TRDebugPrint("Assertion failed in file "   \
                                                 "%s at line %d\n",            \
                                                 __FILE__, __LINE__);          \
                                }
  #define TRDBGPRINT(n,x)       if ((n) <= giTRVerboseLevel)                   \
                                {                                              \
                                    TRDebugPrint(MODNAME ": %s: ", ProcName);  \
                                    TRDebugPrint x;                            \
                                }
  #define TRWARNPRINT(x)        {                                              \
                                    TRDebugPrint(MODNAME "_WARN: %s: ",        \
                                                 ProcName);                    \
                                    TRDebugPrint x;                            \
                                }
  #define TRERRPRINT(x)         {                                              \
                                    TRDebugPrint(MODNAME "_ERR: %s: ",         \
                                                 ProcName);                    \
                                    TRDebugPrint x;                            \
                                    DebugBreak();                              \
                                }
#else
  #define TRASSERT(x)
  #define TRDBGPRINT(n,x)
  #define TRWARNPRINT(x)
  #define TRERRPRINT(x)
#endif  //ifdef TRDEBUG

//
// Exported Data Declarations
//
#ifdef TRDEBUG
extern int giTRVerboseLevel;
extern NAMETABLE WMMsgNames[];
extern NAMETABLE WinTraceMsgNames[];
#endif

//
// Exported function prototypes
//
#ifdef TRDEBUG
int
TRDebugPrint(
    IN LPCSTR format,
    ...
    );

PSZ
LookupName(
    IN ULONG      Code,
    IN PNAMETABLE NameTable
    );
#endif  //ifdef TRDEBUG

#endif  //ifndef _TRDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tracer\tracer.c ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:
    tracer.c

Abstract:
    This module contains the code for debug tracing of a windows app.

Author:
    Michael Tsang (MikeTs) 02-May-2000

Environment:
    User mode

Revision History:

--*/

#include "pch.h"

//
// Global Data
//
HANDLE     ghServerThread = NULL;
HINSTANCE  ghInstance = 0;
PSZ        gpszWinTraceClass = "WinTrace_Class";
HWND       ghwndTracer = 0;
HWND       ghwndEdit = 0;
HWND       ghwndPropSheet = 0;
HFONT      ghFont = 0;
HCURSOR    ghStdCursor = 0;
HCURSOR    ghWaitCursor = 0;
DWORD      gdwfTracer = 0;
LIST_ENTRY glistClients = {0};
char       gszApp[16] = {0};
char       gszSearchText[128] = {0}; //BUGBUG
char       gszFileName[MAX_PATH + 1] = {0};
char       gszSaveFilterSpec[80] = {0};
int        giPointSize = 120;
LOGFONT    gLogFont = {0};
SETTINGS   gDefGlobalSettings = {0, 0, 0};
const int  gTrigPtCtrlMap[NUM_TRIGPTS] =
           {
                IDC_TRIGPT1, IDC_TRIGPT2, IDC_TRIGPT3, IDC_TRIGPT4, IDC_TRIGPT5,
                IDC_TRIGPT6, IDC_TRIGPT7, IDC_TRIGPT8, IDC_TRIGPT9, IDC_TRIGPT10
           };
const int  gTrigPtTraceMap[NUM_TRIGPTS] =
           {
                IDC_TRIGPT1_TRACE, IDC_TRIGPT2_TRACE, IDC_TRIGPT3_TRACE,
                IDC_TRIGPT4_TRACE, IDC_TRIGPT5_TRACE, IDC_TRIGPT6_TRACE,
                IDC_TRIGPT7_TRACE, IDC_TRIGPT8_TRACE, IDC_TRIGPT9_TRACE,
                IDC_TRIGPT10_TRACE
           };
const int  gTrigPtBreakMap[NUM_TRIGPTS] =
           {
                IDC_TRIGPT1_BREAK, IDC_TRIGPT2_BREAK, IDC_TRIGPT3_BREAK,
                IDC_TRIGPT4_BREAK, IDC_TRIGPT5_BREAK, IDC_TRIGPT6_BREAK,
                IDC_TRIGPT7_BREAK, IDC_TRIGPT8_BREAK, IDC_TRIGPT9_BREAK,
                IDC_TRIGPT10_BREAK
           };
const int  gTrigPtTextMap[NUM_TRIGPTS] =
           {
                IDC_TRIGPT1_TEXT, IDC_TRIGPT2_TEXT, IDC_TRIGPT3_TEXT,
                IDC_TRIGPT4_TEXT, IDC_TRIGPT5_TEXT, IDC_TRIGPT6_TEXT,
                IDC_TRIGPT7_TEXT, IDC_TRIGPT8_TEXT, IDC_TRIGPT9_TEXT,
                IDC_TRIGPT10_TEXT
           };
const int  gTrigPtTraceTextMap[NUM_TRIGPTS] =
           {
                IDC_TRIGPT1_TRACE_TEXT, IDC_TRIGPT2_TRACE_TEXT,
                IDC_TRIGPT3_TRACE_TEXT, IDC_TRIGPT4_TRACE_TEXT,
                IDC_TRIGPT5_TRACE_TEXT, IDC_TRIGPT6_TRACE_TEXT,
                IDC_TRIGPT7_TRACE_TEXT, IDC_TRIGPT8_TRACE_TEXT,
                IDC_TRIGPT9_TRACE_TEXT, IDC_TRIGPT10_TRACE_TEXT
           };
const int  gTrigPtBreakTextMap[NUM_TRIGPTS] =
           {
                IDC_TRIGPT1_BREAK_TEXT, IDC_TRIGPT2_BREAK_TEXT,
                IDC_TRIGPT3_BREAK_TEXT, IDC_TRIGPT4_BREAK_TEXT,
                IDC_TRIGPT5_BREAK_TEXT, IDC_TRIGPT6_BREAK_TEXT,
                IDC_TRIGPT7_BREAK_TEXT, IDC_TRIGPT8_BREAK_TEXT,
                IDC_TRIGPT9_BREAK_TEXT, IDC_TRIGPT10_BREAK_TEXT
           };

/*++
    @doc    EXTERNAL

    @func   int | WinMain | Program entry point.

    @parm   IN HINSTANCE | hInstance | Instance handle.
    @parm   IN HINSTANCE | hPrevInstance | Handle of previous instance.
    @parm   IN LPSTR | pszCmdLine | Points to the command line string.
    @parm   IN int | nCmdShow | Show state.

    @rvalue Always returns 0.
--*/

int WINAPI
WinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE hPrevInstance,
    IN LPSTR     pszCmdLine,
    IN int       nCmdShow
    )
{
    TRTRACEPROC("WinMain", 1)
    int rc = -1;

    TRENTER(("(hInstance=%x,hPrevInstance=%x,CmdLine=%s,CmdShow=%x)\n",
             hInstance, hPrevInstance, pszCmdLine, nCmdShow));

    if (TracerInit(hInstance, nCmdShow))
    {
        MSG msg;

        //
        // Message pump.
        //
        while (GetMessage(&msg, NULL, 0, 0))
        {
//            if ((ghDlgSettings == 0) || !IsDialogMessage(ghDlgSettings, &msg))
            {
//                if (TranslateAccelerator(ghwndTracer, )
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        rc = (int)msg.wParam;
    }

    TREXIT(("=%x\n", rc));
    return rc;
}       //WinMain

/*++
    @doc    INTERNAL

    @func   BOOL | TracerInit | Initialize tracer.

    @parm   IN HINSTANCE | hInstance | Instance handle.
    @parm   IN int | nCmdShow | Show state.

    @rvalue Always returns 0.
--*/

BOOL
TracerInit(
    IN HINSTANCE hInstance,
    IN int       nCmdShow
    )
{
    TRTRACEPROC("TracerInit", 2)
    BOOL rc = FALSE;

    TRENTER(("(hInstance=%x,CmdShow=%x)\n", hInstance, nCmdShow));

    if ((rc = RegisterTracerClass(hInstance)) == FALSE)
    {
        TRERRPRINT(("Failed to register tracer class.\n"));
    }
    else
    {
        InitializeListHead(&glistClients);
        ghServerThread = (HANDLE)_beginthread(ServerThread,
                                              0,
                                              0);
        if (ghServerThread != (HANDLE)-1)
        {
            ghInstance = hInstance;
            LoadStringA(hInstance, IDS_APP, gszApp, sizeof(gszApp));
            ghStdCursor = LoadCursorA(NULL,
                                      (LPSTR)MAKEINTRESOURCE(IDC_IBEAM));
            ghWaitCursor = LoadCursorA(NULL,
                                       (LPSTR)MAKEINTRESOURCE(IDC_WAIT));
            ghwndTracer = CreateWindowA(gpszWinTraceClass,
                                        "",
                                        WS_OVERLAPPEDWINDOW,
                                        //BUGBUG: get/save location from reg.
                                        CW_USEDEFAULT,
                                        CW_USEDEFAULT,
                                        CW_USEDEFAULT,
                                        CW_USEDEFAULT,
                                        NULL,
                                        NULL,
                                        hInstance,
                                        NULL);
            if (ghwndTracer != 0)
            {
                int size, len;
                PSZ psz;

                psz = gszSaveFilterSpec;
                size = sizeof(gszSaveFilterSpec);
                len = LoadStringA(ghInstance, IDS_TEXTFILES, psz, size) + 1;

                psz += len;
                size -= len;
                lstrcpyA(psz, "*.txt");
                len = lstrlenA(psz) + 1;

                psz += len;
                size -= len;
                len = LoadStringA(ghInstance, IDS_ALLFILES, psz, size) + 1;

                psz += len;
                size -= len;
                lstrcpyA(psz, "*.*");
                len = lstrlenA(psz) + 1;
                psz += len;
                *psz = '\0';

                gdwfTracer = TF_UNTITLED;
                SetTitle(NULL);

                ShowWindow(ghwndTracer, nCmdShow);
            }
            else
            {
                rc = FALSE;
                TRERRPRINT(("Failed to create tracer window.\n"));
            }
            rc = TRUE;
        }
        else
        {
            ghServerThread = NULL;
            TRERRPRINT(("Failed to create server thread.\n"));
        }
    }

    TREXIT(("=%x\n", rc));
    return rc;
}       //TracerInit

/*++
    @doc    INTERNAL

    @func   BOOL | RegisterTracerClass | Register tracer window class.

    @parm   IN HINSTANCE | hInstance | Instance handle.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue SUCCESS | Returns FALSE.
--*/

BOOL
RegisterTracerClass(
    IN HINSTANCE hInstance
    )
{
    TRTRACEPROC("RegisterTracerClass", 2)
    BOOL rc;
    WNDCLASSEXA wcex;

    TRENTER(("(hInstance=%x)\n", hInstance));

    wcex.cbSize = sizeof(wcex);
    wcex.style = 0;
    wcex.lpfnWndProc = TracerWndProc;
    wcex.cbClsExtra = 0;
    wcex.cbWndExtra = 0;
    wcex.hInstance = hInstance;
    wcex.hIcon = LoadIconA(hInstance, (LPSTR)MAKEINTRESOURCE(IDI_TRACER));
    wcex.hCursor = LoadCursorA(NULL, (LPSTR)MAKEINTRESOURCE(IDC_ARROW));
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcex.lpszMenuName = (LPSTR)MAKEINTRESOURCE(IDD_MENU);
    wcex.lpszClassName = gpszWinTraceClass;
    wcex.hIconSm = NULL;

    rc = RegisterClassExA(&wcex) != 0;

    TREXIT(("=%x\n", rc));
    return rc;
}       //RegisterTracerClass

/*++
    @doc    EXTERNAL

    @func   LRESULT | TracerWndProc | Window procedure for Tracer.

    @parm   IN HWND | hwnd | Window handle.
    @parm   IN UINT | uiMsg | Message ID.
    @parm   IN WPARAM | wParam | First message parameter.
    @parm   IN LPARAM | lParam | Second message parameter.

    @rvalue Return value is message specific.
--*/

LRESULT CALLBACK
TracerWndProc(
    IN HWND   hwnd,
    IN UINT   uiMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRTRACEPROC("TracerWndProc", 3)
    LRESULT rc = 0;

    TRENTER(("(hwnd=%x,Msg=%s,wParam=%x,lParam=%x)\n",
             hwnd, LookupName(uiMsg, WMMsgNames), wParam, lParam));

    switch (uiMsg)
    {
        case WM_CREATE:
        {
            ghwndEdit = CreateWindowExA(WS_EX_CLIENTEDGE,
                                        "Edit",
                                        "",
                                        (gdwfTracer & TF_LINEWRAP)?
                                            ES_STD:
                                            (ES_STD | WS_HSCROLL),
                                        0,
                                        0,
                                        0,
                                        0,
                                        hwnd,
                                        NULL,
                                        ghInstance,
                                        NULL);
            if (ghwndEdit != NULL)
            {
                HDC hDC;

                hDC = GetDC(NULL);
                if (hDC != NULL)
                {
                    INITCOMMONCONTROLSEX ComCtrl;

                    SendMessage(ghwndEdit, EM_LIMITTEXT, 0, 0);
                    ghFont = GetStockObject(SYSTEM_FIXED_FONT);
                    GetObject(ghFont, sizeof(gLogFont), &gLogFont);
                    gLogFont.lfHeight = -MulDiv(giPointSize,
                                                GetDeviceCaps(hDC,
                                                              LOGPIXELSY),
                                                720);
                    ghFont = CreateFontIndirect(&gLogFont);
                    TRASSERT(ghFont != 0);
                    SendMessage(ghwndEdit,
                                WM_SETFONT,
                                (WPARAM)ghFont,
                                MAKELONG(FALSE, 0));
                    ReleaseDC(NULL, hDC);

                    ComCtrl.dwSize = sizeof(ComCtrl);
                    ComCtrl.dwICC = ICC_BAR_CLASSES | ICC_USEREX_CLASSES;
                    if (!InitCommonControlsEx(&ComCtrl))
                    {
                        DestroyWindow(ghwndEdit);
                        TRERRPRINT(("Failed to initialize Common Control\n"));
                        rc = -1;
                    }
                }
                else
                {
                    DestroyWindow(ghwndEdit);
                    TRERRPRINT(("Failed to get display DC\n"));
                    rc = -1;
                }
            }
            else
            {
                TRERRPRINT(("Failed to create edit window.\n"));
                rc = -1;
            }
            break;
        }

        case WM_DESTROY:
        {
            PLIST_ENTRY plist;
            PCLIENT_ENTRY ClientEntry;

            while (!IsListEmpty(&glistClients))
            {
                plist = glistClients.Flink;
                ClientEntry = CONTAINING_RECORD(plist,
                                                CLIENT_ENTRY,
                                                list);
                WTDeregisterClient(NULL, (HCLIENT)ClientEntry);
            }
            DeleteObject(ghFont);
            DestroyWindow(ghwndEdit);
            PostQuitMessage(0);
            break;
        }

        case WM_COMMAND:
            if ((HWND)lParam == ghwndEdit)
            {
                switch (HIWORD(wParam))
                {
                    case EN_ERRSPACE:
                    case EN_MAXTEXT:
                        ErrorMsg(IDS_ERRSPACE);
                        break;
                }
            }
            else if (!TracerCmdProc(hwnd, wParam, lParam))
            {
                rc = DefWindowProc(hwnd, uiMsg, wParam, lParam);
            }
            break;

        case WM_SETFOCUS:
            SetFocus(ghwndEdit);
            break;

        case WM_SIZE:
            MoveWindow(ghwndEdit,
                       0,
                       0,
                       LOWORD(lParam),
                       HIWORD(lParam),
                       TRUE);
            break;

        default:
            rc = DefWindowProc(hwnd, uiMsg, wParam, lParam);
    }

    TREXIT(("=%x\n", rc));
    return rc;
}       //TracerWndProc

/*++
    @doc    INTERNAL

    @func   LRESULT | TracerCmdProc | Process the WM_COMMAND message.

    @parm   IN HWND | hwnd | Window handle.
    @parm   IN WPARAM | wParam | First message parameter.
    @parm   IN LPARAM | lParam | Second message parameter.

    @rvalue Return value is message specific.
--*/

LRESULT
TracerCmdProc(
    IN HWND   hwnd,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRTRACEPROC("TracerCmdProc", 3)
    LRESULT rc = 0;

    TRENTER(("(hwnd=%x,wParam=%x,lParam=%x)\n", hwnd, wParam, lParam));

    switch (LOWORD(wParam))
    {
        case M_SAVE:
            if (!(gdwfTracer & TF_UNTITLED) &&
                SaveFile(hwnd, gszFileName, FALSE))
            {
                break;
            }
            //
            // Otherwise, fall through.
            //
        case M_SAVEAS:
        {
            OPENFILENAMEA ofn;
            char szFileName[MAX_PATH + 1] = "";
            char szSaveAs[16];

            memset(&ofn, 0, sizeof(ofn));
            LoadStringA(ghInstance, IDS_SAVEAS, szSaveAs, sizeof(szSaveAs));
            ofn.lStructSize = sizeof(ofn);
            ofn.hwndOwner = ghwndTracer;
            ofn.hInstance = ghInstance;
            ofn.lpstrFilter = gszSaveFilterSpec;
            ofn.nFilterIndex = 1;
            ofn.lpstrFile = szFileName;
            ofn.nMaxFile = sizeof(szFileName);
            if (gdwfTracer & TF_UNTITLED)
            {
                lstrcpyA(szFileName, "*.txt");
            }
            else
            {
                lstrcpynA(szFileName, gszFileName, MAX_PATH);
                szFileName[MAX_PATH] = '\0';
            }
            ofn.lpstrTitle = szSaveAs;
            ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT |
                        OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST;
            ofn.lpstrDefExt = "txt";
            if (GetSaveFileNameA(&ofn))
            {
                if (SaveFile(hwnd, szFileName, TRUE))
                {
                    lstrcpynA(gszFileName, szFileName, MAX_PATH);
                    gdwfTracer &= ~TF_UNTITLED;
                    SetTitle(NULL);
                }
            }
            else
            {
                DWORD dwErr = CommDlgExtendedError();

                if (dwErr != 0)
                {
                    ErrorMsg(IDS_GETSAVEFILENAME_FAILED, dwErr);
                }
            }
            break;
        }

        case M_PRINT:
            //
            // BUGBUG
            //
            break;

        case M_EXIT:
            PostMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case M_CLEAR:
            SendMessage(ghwndEdit, EM_SETSEL, 0, -1);
            SendMessage(ghwndEdit, EM_REPLACESEL, 0, (LPARAM)"");
            break;

        case M_FIND:
            if (gszSearchText[0])
            {
//BUGBUG                SearchText(gszSearchText);
                break;
            }
            //
            // Otherwise, fall through.
            //
        case M_FINDNEXT:
            //
            // BUGBUG
            //
        case M_GOTO:
            //BUGBUG
            break;

        case M_WORDWRAP:
            //BUGBUG
            break;

        case M_SETFONT:
        {
            HDC hDC;

            hDC = GetDC(NULL);
            if (hDC != NULL)
            {
                CHOOSEFONT cf;

                memset(&cf, 0, sizeof(cf));
                cf.lStructSize = sizeof(cf);
                cf.hwndOwner = hwnd;
                cf.lpLogFont = &gLogFont;
                gLogFont.lfHeight = -MulDiv(giPointSize,
                                            GetDeviceCaps(hDC, LOGPIXELSY),
                                           720);
                cf.Flags = CF_SCREENFONTS | CF_NOVERTFONTS |
                           CF_INITTOLOGFONTSTRUCT;
                cf.nFontType = SCREEN_FONTTYPE;
                ReleaseDC(NULL, hDC);

                if (ChooseFont(&cf))
                {
                    HFONT hfontNew;

                    SetCursor(ghWaitCursor);
                    hfontNew = CreateFontIndirect(&gLogFont);
                    if (hfontNew != NULL)
                    {
                        DeleteObject(ghFont);
                        ghFont = hfontNew;
                        SendMessage(ghwndEdit,
                                    WM_SETFONT,
                                    (WPARAM)ghFont,
                                    MAKELONG(TRUE, 0));
                        giPointSize = cf.iPointSize;
                    }
                    SetCursor(ghStdCursor);
                }
                else
                {
                    DWORD dwErr = CommDlgExtendedError();

                    if (dwErr != 0)
                    {
                        ErrorMsg(IDS_CHOOSEFONT_FAILED, dwErr);
                    }
                }
            }
            break;
        }

        case M_CLIENTS:
        {
            PROPSHEETHEADER psh;
            PLIST_ENTRY plist;

            psh.dwSize = sizeof(psh);
            psh.dwFlags = 0;
            psh.hwndParent = hwnd;
            psh.hInstance = ghInstance;
            psh.pszCaption = MAKEINTRESOURCE(IDS_CLIENT_SETTINGS);

            psh.nPages = 1;
            for (plist = glistClients.Flink;
                 plist != &glistClients;
                 plist = plist->Flink)
            {
                psh.nPages++;;
            }

            psh.phpage = LocalAlloc(LMEM_FIXED,
                                    sizeof(HPROPSHEETPAGE)*psh.nPages);
            psh.nStartPage = 0;
            CreatePropertyPages(psh.phpage);
            if (PropertySheet(&psh) < 0)
            {
                ErrorMsg(IDSERR_PROP_SHEET, GetLastError());
            }
            LocalFree(psh.phpage);
            break;
        }

        case M_HELP:
            //BUGBUG
            break;

        case M_ABOUT:
            ShellAboutA(hwnd,
                        gszApp,
                        "",
                        LoadIconA(ghInstance,
                                  (LPCSTR)MAKEINTRESOURCE(IDI_TRACER)));
            break;
    }

    TREXIT(("=%x\n", rc));
    return rc;
}       //TracerCmdProc

/*++
    @doc    EXTERNAL

    @func   INT_PTR | GlobalSettingsDlgProc | Global setting dialog procedure.

    @parm   IN HWND | hwnd | Window handle.
    @parm   IN UINT | uiMsg | Message ID.
    @parm   IN WPARAM | wParam | First message parameter.
    @parm   IN LPARAM | lParam | Second message parameter.

    @rvalue Return value is message specific.
--*/

INT_PTR APIENTRY
GlobalSettingsDlgProc(
    IN HWND   hwnd,
    IN UINT   uiMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRTRACEPROC("GlobalSettingsDlgProc", 3)
    INT_PTR rc = 0;
    static SETTINGS GlobalSettings = {0};

    TRENTER(("(hwnd=%x,Msg=%s,wParam=%x,lParam=%x)\n",
             hwnd, LookupName(uiMsg, WMMsgNames), wParam, lParam));

    switch (uiMsg)
    {
        case WM_INITDIALOG:
        {
            ghwndPropSheet = GetParent(hwnd);
            GlobalSettings = gDefGlobalSettings;
            SendDlgItemMessage(hwnd,
                               IDC_GLOBALVERBOSESPIN,
                               UDM_SETRANGE,
                               0,
                               MAKELONG(MAX_LEVELS, 0));
            SendDlgItemMessage(hwnd,
                               IDC_GLOBALTRACESPIN,
                               UDM_SETRANGE,
                               0,
                               MAKELONG(MAX_LEVELS, 0));
            SendDlgItemMessage(hwnd,
                               IDC_GLOBALVERBOSESPIN,
                               UDM_SETPOS,
                               0,
                               MAKELONG(GlobalSettings.iVerboseLevel, 0));
            SendDlgItemMessage(hwnd,
                               IDC_GLOBALTRACESPIN,
                               UDM_SETPOS,
                               0,
                               MAKELONG(GlobalSettings.iTraceLevel, 0));
            CheckDlgButton(hwnd,
                           IDC_GLOBALTRACEDEBUGGER,
                           (GlobalSettings.dwfSettings &
                            SETTINGS_TRACE_TO_DEBUGGER) != 0);

            rc = TRUE;
            break;
        }

        case WM_DESTROY:
            ghwndPropSheet = NULL;
            break;

        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *)lParam;

            switch (lpnm->code)
            {
                case PSN_APPLY:
                    gDefGlobalSettings = GlobalSettings;
                    break;
            }
            break;
        }

        case WM_COMMAND:
        {
            BOOL fChanged = FALSE;

            switch (LOWORD(wParam))
            {
                case IDC_GLOBALVERBOSE:
                case IDC_GLOBALTRACE:
                {
                    switch (HIWORD(wParam))
                    {
                        BOOL fOK;
                        int n;

                        case EN_UPDATE:
                            n = GetDlgItemInt(hwnd,
                                              LOWORD(wParam),
                                              &fOK,
                                              FALSE);
                            if (fOK && (n <= MAX_LEVELS))
                            {
                                if (LOWORD(wParam) == IDC_GLOBALVERBOSE)
                                {
                                    GlobalSettings.iVerboseLevel = n;
                                }
                                else
                                {
                                    GlobalSettings.iTraceLevel = n;
                                }
                                fChanged = TRUE;
                            }
                            else
                            {
                                SetDlgItemInt(hwnd,
                                              LOWORD(wParam),
                                              (LOWORD(wParam) ==
                                               IDC_GLOBALVERBOSE)?
                                                GlobalSettings.iVerboseLevel:
                                                GlobalSettings.iTraceLevel,
                                              FALSE);
                                SendMessage((HWND)lParam,
                                            EM_SETSEL,
                                            0,
                                            -1);
                            }
                            break;
                    }
                    break;
                }

                case IDC_GLOBALTRACEDEBUGGER:
                    if (IsDlgButtonChecked(hwnd, IDC_GLOBALTRACEDEBUGGER))
                    {
                        GlobalSettings.dwfSettings |=
                                SETTINGS_TRACE_TO_DEBUGGER;
                    }
                    else
                    {
                        GlobalSettings.dwfSettings &=
                                ~SETTINGS_TRACE_TO_DEBUGGER;
                    }
                    fChanged = TRUE;
                    break;
            }

            if (fChanged)
            {
                SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
            }
            break;
        }
    }

    TREXIT(("=%x\n", rc));
    return rc;
}       //GlobalSettingsDlgProc

/*++
    @doc    EXTERNAL

    @func   INT_PTR | ClientSettingsDlgProc | Client setting dialog procedure.

    @parm   IN HWND | hwnd | Window handle.
    @parm   IN UINT | uiMsg | Message ID.
    @parm   IN WPARAM | wParam | First message parameter.
    @parm   IN LPARAM | lParam | Second message parameter.

    @rvalue Return value is message specific.
--*/

INT_PTR APIENTRY
ClientSettingsDlgProc(
    IN HWND   hwnd,
    IN UINT   uiMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TRTRACEPROC("ClientSettingsDlgProc", 3)
    INT_PTR rc = 0;

    TRENTER(("(hwnd=%x,Msg=%s,wParam=%x,lParam=%x)\n",
             hwnd, LookupName(uiMsg, WMMsgNames), wParam, lParam));

    switch (uiMsg)
    {
        case WM_INITDIALOG:
        {
            PCLIENT_ENTRY ClientEntry =
                (PCLIENT_ENTRY)((LPPROPSHEETPAGE)lParam)->lParam;
            int i;

            ghwndPropSheet = GetParent(hwnd);
            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)ClientEntry);

            SendServerRequest(ClientEntry,
                              SRVREQ_GETCLIENTINFO,
                              &ClientEntry->ClientInfo);

            SendDlgItemMessage(hwnd,
                               IDC_CLIENTVERBOSESPIN,
                               UDM_SETRANGE,
                               0,
                               MAKELONG(MAX_LEVELS, 0));
            SendDlgItemMessage(hwnd,
                               IDC_CLIENTTRACESPIN,
                               UDM_SETRANGE,
                               0,
                               MAKELONG(MAX_LEVELS, 0));

            SendDlgItemMessage(hwnd,
                               IDC_CLIENTVERBOSESPIN,
                               UDM_SETPOS,
                               0,
                               MAKELONG(ClientEntry->ClientInfo.Settings.iVerboseLevel,
                                        0));
            SendDlgItemMessage(hwnd,
                               IDC_CLIENTTRACESPIN,
                               UDM_SETPOS,
                               0,
                               MAKELONG(ClientEntry->ClientInfo.Settings.iTraceLevel,
                                        0));

            CheckDlgButton(hwnd,
                           IDC_CLIENTTRACEDEBUGGER,
                           (ClientEntry->ClientInfo.Settings.dwfSettings &
                            SETTINGS_TRACE_TO_DEBUGGER) != 0);
            CheckDlgButton(hwnd,
                           IDC_CLIENTTRIGGERTRACE,
                           (ClientEntry->ClientInfo.Settings.dwfSettings &
                            SETTINGS_TRIGMODE_ENABLED) != 0);

            for (i = 0; i < NUM_TRIGPTS; ++i)
            {
                SetDlgItemText(hwnd,
                               gTrigPtCtrlMap[i],
                               ClientEntry->ClientInfo.TrigPts[i].szProcName);
                CheckDlgButton(hwnd,
                               gTrigPtTraceMap[i],
                               (ClientEntry->ClientInfo.TrigPts[i].dwfTrigPt &
                                TRIGPT_TRACE_ENABLED) != 0);
                CheckDlgButton(hwnd,
                               gTrigPtBreakMap[i],
                               (ClientEntry->ClientInfo.TrigPts[i].dwfTrigPt &
                                TRIGPT_BREAK_ENABLED) != 0);
            }

            EnableTrigPts(hwnd,
                          (ClientEntry->ClientInfo.Settings.dwfSettings &
                           SETTINGS_TRIGMODE_ENABLED) != 0);

            rc = TRUE;
            break;
        }

        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *)lParam;

            switch (lpnm->code)
            {
                case PSN_APPLY:
                {
                    PCLIENT_ENTRY ClientEntry;

                    ClientEntry = (PCLIENT_ENTRY)GetWindowLongPtr(hwnd,
                                                                  DWLP_USER);
                    if (ClientEntry != NULL)
                    {
                        ClientEntry->ClientInfo.Settings =
                            ClientEntry->TempSettings;
                        RtlCopyMemory(ClientEntry->ClientInfo.TrigPts,
                                      ClientEntry->TempTrigPts,
                                      sizeof(ClientEntry->ClientInfo.TrigPts));

                        SendServerRequest(ClientEntry,
                                          SRVREQ_SETCLIENTINFO,
                                          &ClientEntry->ClientInfo);
                    }
                    else
                    {
                        TRWARNPRINT(("Notify: Failed to get Client Entry\n"));
                    }
                    break;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            BOOL fChanged = FALSE;
            PCLIENT_ENTRY ClientEntry;
            BOOL fTrace = FALSE;

            switch (LOWORD(wParam))
            {
                case IDC_CLIENTVERBOSE:
                case IDC_CLIENTTRACE:
                    switch (HIWORD(wParam))
                    {
                        case EN_UPDATE:
                        {
                            BOOL fOK;
                            int n;

                            ClientEntry = (PCLIENT_ENTRY)GetWindowLongPtr(
                                                                hwnd,
                                                                DWLP_USER);
                            if (ClientEntry != NULL)
                            {
                                n = GetDlgItemInt(hwnd,
                                                  LOWORD(wParam),
                                                  &fOK,
                                                  FALSE);
                                if (fOK && (n <= MAX_LEVELS))
                                {
                                    if (LOWORD(wParam) == IDC_CLIENTVERBOSE)
                                    {
                                        ClientEntry->TempSettings.iVerboseLevel
                                            = n;
                                    }
                                    else
                                    {
                                        ClientEntry->TempSettings.iTraceLevel
                                            = n;
                                    }
                                    fChanged = TRUE;
                                }
                                else
                                {
                                    SetDlgItemInt(
                                        hwnd,
                                        LOWORD(wParam),
                                        (LOWORD(wParam) == IDC_CLIENTVERBOSE)?
                                          ClientEntry->TempSettings.iVerboseLevel:
                                          ClientEntry->TempSettings.iTraceLevel,
                                        FALSE);
                                    SendMessage((HWND)lParam,
                                                EM_SETSEL,
                                                0,
                                                -1);
                                }
                            }
                            else
                            {
                                TRWARNPRINT(("Verbose/Trace: Failed to get Client Entry\n"));
                            }
                            break;
                        }
                    }
                    break;

                case IDC_CLIENTTRACEDEBUGGER:
                case IDC_CLIENTTRIGGERTRACE:
                    ClientEntry = (PCLIENT_ENTRY)GetWindowLongPtr(hwnd,
                                                                  DWLP_USER);
                    if (ClientEntry != NULL)
                    {
                        DWORD dwf = (LOWORD(wParam) ==
                                     IDC_CLIENTTRACEDEBUGGER)?
                                        SETTINGS_TRACE_TO_DEBUGGER:
                                        SETTINGS_TRIGMODE_ENABLED;
                        BOOL fChecked = IsDlgButtonChecked(hwnd,
                                                           LOWORD(wParam));

                        if (fChecked)
                        {
                            ClientEntry->TempSettings.dwfSettings |= dwf;
                        }
                        else
                        {
                            ClientEntry->TempSettings.dwfSettings &= ~dwf;
                        }

                        if (LOWORD(wParam) == IDC_CLIENTTRIGGERTRACE)
                        {
                            EnableTrigPts(hwnd, fChecked);
                        }

                        fChanged = TRUE;
                    }
                    else
                    {
                        TRWARNPRINT(("TraceToDebugger/TrigModeEnabled: Failed to get Client Entry\n"));
                    }
                    break;

                case IDC_TRIGPT1:
                case IDC_TRIGPT2:
                case IDC_TRIGPT3:
                case IDC_TRIGPT4:
                case IDC_TRIGPT5:
                case IDC_TRIGPT6:
                case IDC_TRIGPT7:
                case IDC_TRIGPT8:
                case IDC_TRIGPT9:
                case IDC_TRIGPT10:
                    switch (HIWORD(wParam))
                    {
                        case EN_UPDATE:
                        {
                            int n;
                            int iTrigPt;

                            ClientEntry = (PCLIENT_ENTRY)GetWindowLongPtr(
                                                                hwnd,
                                                                DWLP_USER);
                            if (ClientEntry != NULL)
                            {
                                iTrigPt = FindTrigPtIndex(LOWORD(wParam),
                                                          gTrigPtCtrlMap);
                                n = GetDlgItemTextA(
                                        hwnd,
                                        LOWORD(wParam),
                                        ClientEntry->TempTrigPts[iTrigPt].szProcName,
                                        MAX_PROCNAME_LEN - 1);
                                if ((n > 0) ||
                                    (GetLastError() == ERROR_SUCCESS))
                                {
                                    fChanged = TRUE;
                                }
                                else
                                {
                                    TRWARNPRINT(("Failed to get trigger point text (err=%x)\n",
                                                 GetLastError()));
                                }
                            }
                            else
                            {
                                TRWARNPRINT(("TrigPt: Failed to get Client Entry\n"));
                            }
                            break;
                        }
                    }
                    break;

                case IDC_TRIGPT1_TRACE:
                case IDC_TRIGPT2_TRACE:
                case IDC_TRIGPT3_TRACE:
                case IDC_TRIGPT4_TRACE:
                case IDC_TRIGPT5_TRACE:
                case IDC_TRIGPT6_TRACE:
                case IDC_TRIGPT7_TRACE:
                case IDC_TRIGPT8_TRACE:
                case IDC_TRIGPT9_TRACE:
                case IDC_TRIGPT10_TRACE:
                    fTrace = TRUE;
                    //
                    // Fall through ...
                    //
                case IDC_TRIGPT1_BREAK:
                case IDC_TRIGPT2_BREAK:
                case IDC_TRIGPT3_BREAK:
                case IDC_TRIGPT4_BREAK:
                case IDC_TRIGPT5_BREAK:
                case IDC_TRIGPT6_BREAK:
                case IDC_TRIGPT7_BREAK:
                case IDC_TRIGPT8_BREAK:
                case IDC_TRIGPT9_BREAK:
                case IDC_TRIGPT10_BREAK:
                {
                    int iTrigPt;

                    ClientEntry = (PCLIENT_ENTRY)GetWindowLongPtr(hwnd,
                                                                  DWLP_USER);
                    if (ClientEntry != NULL)
                    {
                        DWORD dwf = fTrace? TRIGPT_TRACE_ENABLED:
                                            TRIGPT_BREAK_ENABLED;

                        iTrigPt = FindTrigPtIndex(LOWORD(wParam),
                                                  fTrace? gTrigPtTraceMap:
                                                          gTrigPtBreakMap);
                        if (IsDlgButtonChecked(hwnd, LOWORD(wParam)))
                        {
                            ClientEntry->TempTrigPts[iTrigPt].dwfTrigPt |= dwf;
                        }
                        else
                        {
                            ClientEntry->TempTrigPts[iTrigPt].dwfTrigPt &=
                                ~dwf;
                        }
                        fChanged = TRUE;
                    }
                    else
                    {
                        TRWARNPRINT(("TrigPtEnable: Failed to get Client Entry\n"));
                    }
                    break;
                }
            }

            if (fChanged)
            {
                SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
            }
            break;
        }
    }

    TREXIT(("=%x\n", rc));
    return rc;
}       //ClientSettingsDlgProc

/*++
    @doc    INTERNAL

    @func   VOID | EnableTrigPts | Enable trigger points controls.

    @parm   IN HWND | hDlg | Dialog box handle.
    @parm   IN BOOL | fEnable | TRUE if enable.

    @rvalue None.
--*/

VOID
EnableTrigPts(
    IN HWND hDlg,
    IN BOOL fEnable
    )
{
    TRTRACEPROC("EnableTrigPts", 3)
    int i;

    TRENTER(("(hDlg=%x,fEnable=%x)\n", hDlg, fEnable));

    EnableWindow(GetDlgItem(hDlg, IDC_CLIENTTRIGPTGROUPBOX), fEnable);
    for (i = 0; i < NUM_TRIGPTS; ++i)
    {
        EnableWindow(GetDlgItem(hDlg, gTrigPtTextMap[i]), fEnable);
        EnableWindow(GetDlgItem(hDlg, gTrigPtTraceTextMap[i]), fEnable);
        EnableWindow(GetDlgItem(hDlg, gTrigPtBreakTextMap[i]), fEnable);
        EnableWindow(GetDlgItem(hDlg, gTrigPtCtrlMap[i]), fEnable);
        EnableWindow(GetDlgItem(hDlg, gTrigPtTraceMap[i]), fEnable);
        EnableWindow(GetDlgItem(hDlg, gTrigPtBreakMap[i]), fEnable);
    }

    TREXIT(("!\n"));
    return;
}       //EnableTrigPts

/*++
    @doc    INTERNAL

    @func   BOOL | SaveFile | Save the text buffer to a file.

    @parm   IN HWND | hwndParent | Window handle parent.
    @parm   IN PSZ | pszFileName | Points to the file name string to save.
    @parm   IN BOOL | fSaveAs | TRUE if called from SaveAs.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL
SaveFile(
    IN HWND hwndParent,
    IN PSZ  pszFileName,
    IN BOOL fSaveAs
    )
{
    TRTRACEPROC("SaveFile", 3)
    BOOL rc = FALSE;
    HANDLE hFile;

    TRENTER(("(hwnd=%x,File=%s,fSaveAs=%x)\n",
             hwndParent, pszFileName, fSaveAs));

    hFile = CreateFileA(pszFileName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        fSaveAs? OPEN_ALWAYS: OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        BOOL fNew;
        UINT uiTextSize;
        HLOCAL hlText;
        LPSTR lpch;
        DWORD dwcbWritten;

        fNew = (GetLastError() != ERROR_ALREADY_EXISTS);
        uiTextSize = (UINT)SendMessage(ghwndEdit, WM_GETTEXTLENGTH, 0, 0);
        hlText = (HLOCAL)SendMessage(ghwndEdit, EM_GETHANDLE, 0, 0);
        if ((hlText != NULL) && ((lpch = (LPSTR)LocalLock(hlText)) != NULL))
        {
            rc = WriteFile(hFile,
                           lpch,
                           uiTextSize,
                           &dwcbWritten,
                           NULL);
            if (rc == FALSE)
            {
                ErrorMsg(IDS_WRITEFILE_FAILED, pszFileName);
            }
            LocalUnlock(hlText);
        }
        else
        {
            TRERRPRINT(("Failed to get text length or get text handle\n"));
        }
        CloseHandle(hFile);

        if ((rc == FALSE) && fNew)
        {
            DeleteFileA(pszFileName);
        }
    }
    else
    {
        ErrorMsg(IDS_CREATEFILE_FAILED, pszFileName);
    }

    TREXIT(("=%x\n", rc));
    return rc;
}       //SaveFile

/*++
    @doc    INTERNAL

    @func   UINT | CreatePropertyPages | Create the global setting page as
            well as a property page for each registered clients.

    @parm   OUT HPROPSHEETPAGE *| hPages | Points to the array to hold all
            the created property sheet handles.

    @rvalue SUCCESS | Returns number of pages created.
    @rvalue FAILURE | Returns 0.
--*/

UINT
CreatePropertyPages(
    OUT HPROPSHEETPAGE *hPages
    )
{
    TRTRACEPROC("CreatePropertyPages", 3)
    UINT nPages = 0;
    PROPSHEETPAGEA psp;
    PLIST_ENTRY plist;
    PCLIENT_ENTRY ClientEntry;

    TRENTER(("(hPages=%p)\n", hPages));

    psp.dwSize = sizeof(psp);
    psp.dwFlags = 0;
    psp.hInstance = ghInstance;
    psp.pszTitle = NULL;
    psp.lParam = 0;

    psp.pszTemplate = (LPSTR)MAKEINTRESOURCE(IDD_GLOBALSETTINGS);
    psp.pfnDlgProc = GlobalSettingsDlgProc;
    hPages[nPages] = CreatePropertySheetPageA(&psp);
    if (hPages[nPages] != NULL)
    {
        nPages++;
    }

    psp.dwFlags = PSP_USETITLE;
    psp.pszTemplate = (LPSTR)MAKEINTRESOURCE(IDD_CLIENTSETTINGS);
    psp.pfnDlgProc = ClientSettingsDlgProc;
    for (plist = glistClients.Flink;
         plist != &glistClients;
         plist = plist->Flink)
    {
        ClientEntry = CONTAINING_RECORD(plist, CLIENT_ENTRY, list);
        psp.pszTitle = ClientEntry->szClientName;
        psp.lParam = (LPARAM)ClientEntry;
        hPages[nPages] = CreatePropertySheetPageA(&psp);
        if (hPages[nPages] != NULL)
        {
            ClientEntry->hPage = hPages[nPages];
            nPages++;
        }
    }

    TREXIT(("=%d\n", nPages));
    return nPages;
}       //CreatePropertyPages

/*++
    @doc    INTERNAL

    @func   VOID | SetTitle | Set the title bar text.

    @parm   IN PSZ | pszTitle | Points to title text string.  If NULL, set
            title to current file name.

    @rvalue None.
--*/

VOID
SetTitle(
    IN PSZ pszTitle OPTIONAL
    )
{
    TRTRACEPROC("SetTitle", 3)
    char szWindowText[MAX_PATH + 16];

    TRENTER(("(Title=%s)\n", pszTitle));

    if (pszTitle != NULL)
    {
        lstrcpyA(szWindowText, pszTitle);
    }
    else
    {
        int len;

        if (gdwfTracer & TF_UNTITLED)
        {
            LoadStringA(ghInstance,
                        IDS_UNTITLED,
                        szWindowText,
                        sizeof(szWindowText));
        }
        else
        {
            lstrcpynA(szWindowText, gszFileName, sizeof(szWindowText));
        }

        len = lstrlenA(szWindowText);
        LoadStringA(ghInstance,
                    IDS_TITLE,
                    &szWindowText[len],
                    sizeof(szWindowText) - len);
    }
    SetWindowTextA(ghwndTracer, szWindowText);

    TREXIT(("!\n"));
    return;
}       //SetTitle

/*++
    @doc    INTERNAL

    @func   int | FindTrigPtIndex | Find the trigger point index by its
            control ID.

    @parm   IN int | iID | Dialog object control ID.
    @parm   IN const int * | IDTable | Points to the ID map.

    @rvalue SUCCESS | Returns the trigger point index.
    @rvalue FAILURE | Returns -1.
--*/

int
FindTrigPtIndex(
    IN int  iID,
    IN const int *IDTable
    )
{
    TRTRACEPROC("FindTrigPtIndex", 3)
    int i;

    TRENTER(("(ID=%d,IDTable=%p)\n", iID, IDTable));

    for (i = 0; i < NUM_TRIGPTS; ++i)
    {
        if (iID == IDTable[i])
        {
            break;
        }
    }

    if (i == NUM_TRIGPTS)
    {
        i = -1;
    }

    TREXIT(("=%d\n", i));
    return i;
}       //FindTrigPtIndex

/*++
    @doc    INTERNAL

    @func   VOID | ErrorMsg | Put out an error message box.

    @parm   IN ULONG | ErrCode | The given error code.
    @parm   ... | Substituting arguments for the error message.

    @rvalue Returns the number of chars in the message.
--*/

int
ErrorMsg(
    IN ULONG      ErrCode,
    ...
    )
{
    static char szFormat[1024];
    static char szErrMsg[1024];
    int n;
    va_list arglist;

    LoadStringA(ghInstance, ErrCode, szFormat, sizeof(szFormat));
    va_start(arglist, ErrCode);
    n = wvsprintfA(szErrMsg, szFormat, arglist);
    va_end(arglist);
    MessageBoxA(NULL, szErrMsg, gszApp, MB_OK | MB_ICONERROR);

    return n;
}       //ErrorMsg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tracer\tracer.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:
    tracer.h

Abstract:
    This module contains the global definitions of Tracer.

Author:
    Michael Tsang (MikeTs) 02-May-2000

Environment:
    User mode

Revision History:

--*/

#ifndef _TRACER_H
#define _TRACER_H

//
// Constants
//
#define ES_STD                  (WS_CHILD | WS_VSCROLL | WS_VISIBLE |   \
                                 ES_MULTILINE | ES_READONLY)
#define MAX_LEVELS              255

// gdwfTracer flag values
#define TF_UNTITLED             0x00000001
#define TF_LINEWRAP             0x00000002
#define TF_TERMINATING          0x80000000

//
// Macors
//
#define InitializeListHead(lh)  ((lh)->Flink = (lh)->Blink = (lh))
#define IsListEmpty(lh)         ((lh)->Flink == (lh))
#define RemoveHeadList(lh)      (lh)->Flink;                            \
                                {RemoveEntryList((lh)->Flink)}
#define RemoveEntryList(e)      {                                       \
                                    (e)->Blink->Flink = (e)->Flink;     \
                                    (e)->Flink->Blink = (e)->Blink;     \
                                }
#define InsertTailList(lh,e)    {                                       \
                                    (e)->Flink = (lh);                  \
                                    (e)->Blink = (lh)->Blink;           \
                                    (lh)->Blink->Flink = (e);           \
                                    (lh)->Blink = (e);                  \
                                }


//
// Type definitions
//
typedef struct _SRVREQ
{
    LONG  lRequest;
    PVOID Context;
} SRVREQ, *PSRVREQ;

typedef struct _CLIENT_ENTRY
{
    CLIENTINFO     ClientInfo;
    SRVREQ         SrvReq;
    HANDLE         hSrvReqEvent;
    HPROPSHEETPAGE hPage;
    SETTINGS       TempSettings;
    TRIGPT         TempTrigPts[NUM_TRIGPTS];
    LIST_ENTRY     list;
    char           szClientName[MAX_CLIENTNAME_LEN];
} CLIENT_ENTRY, *PCLIENT_ENTRY;

#define SRVREQ_NONE             0x00000000
#define SRVREQ_BUSY             0x00000001
#define SRVREQ_GETCLIENTINFO    0x00000002
#define SRVREQ_SETCLIENTINFO    0x00000003
#define SRVREQ_TERMINATE        0x00000004

//
// Global Data
//
extern HANDLE     ghServerThread;
extern HINSTANCE  ghInstance;
extern PSZ        gpszWinTraceClass;
extern HWND       ghwndTracer;
extern HWND       ghwndEdit;
extern HWND       ghwndPropSheet;
extern HFONT      ghFont;
extern HCURSOR    ghStdCursor;
extern HCURSOR    ghWaitCursor;
extern DWORD      gdwfTracer;
extern LIST_ENTRY glistClients;
extern char       gszApp[16];
extern char       gszSearchText[128];
extern char       gszFileName[MAX_PATH + 1];
extern char       gszSaveFilterSpec[80];
extern int        giPointSize;
extern LOGFONT    gLogFont;
extern SETTINGS   gDefGlobalSettings;
extern const int  gTrigPtCtrlMap[NUM_TRIGPTS];
extern const int  gTrigPtTraceMap[NUM_TRIGPTS];
extern const int  gTrigPtBreakMap[NUM_TRIGPTS];
extern const int  gTrigPtTextMap[NUM_TRIGPTS];
extern const int  gTrigPtTraceTextMap[NUM_TRIGPTS];
extern const int  gTrigPtBreakTextMap[NUM_TRIGPTS];

//
// Function prototypes
//

// tracer.c
BOOL
TracerInit(
    IN HINSTANCE hInstance,
    IN int       nCmdShow
    );

BOOL
RegisterTracerClass(
    IN HINSTANCE hInstance
    );

LRESULT CALLBACK
TracerWndProc(
    IN HWND   hwnd,
    IN UINT   uiMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

LRESULT
TracerCmdProc(
    IN HWND   hwnd,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR APIENTRY
GlobalSettingsDlgProc(
    IN HWND   hwnd,
    IN UINT   uiMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR APIENTRY
ClientSettingsDlgProc(
    IN HWND   hwnd,
    IN UINT   uiMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

VOID
EnableTrigPts(
    IN HWND hDlg,
    IN BOOL fEnable
    );

BOOL
SaveFile(
    IN HWND hwndParent,
    IN PSZ  pszFileName,
    IN BOOL fSaveAs
    );

UINT
CreatePropertyPages(
    OUT HPROPSHEETPAGE *hPages
    );

VOID
SetTitle(
    IN PSZ pszTitle OPTIONAL
    );

int
FindTrigPtIndex(
    IN int        iID,
    IN const int *IDTable
    );

int
ErrorMsg(
    IN ULONG      ErrCode,
    ...
    );

// server.c
VOID __cdecl
ServerThread(
    PVOID pv
    );

VOID
SendServerRequest(
    IN PCLIENT_ENTRY ClientEntry,
    IN LONG          lRequest,
    IN PVOID         Context
    );

LPSTR
CopyStr(
    OUT LPSTR  pszDest,
    IN  LPCSTR pszSrc
    );

#endif  //ifndef _TRACER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tracer\trtrace.c ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    trtrace.c

Abstract:

    This module contains the code for debug tracing.

Author:

    Michael Tsang (MikeTs) 24-Sep-1998

Environment:

    User mode

Revision History:


--*/

#include "pch.h"

#ifdef TRTRACE
//
// Local Data
//
int giTRTraceLevel = 0;
int giTRTraceIndent = 0;
ULONG gdwfTRTrace = 0;

/*++

Routine Description:
    This routine determines if the given procedure should be traced.

Arguments:
    n - trace level of the procedure
    ProcName - points to the procedure name string

Return Value:
    Success - returns TRUE
    Failure - returns FALSE

--*/

BOOLEAN
TRIsTraceOn(
    IN int n,
    IN PSZ ProcName
    )
{
    BOOLEAN rc = FALSE;

    if (!(gdwfTRTrace & TF_CHECKING_TRACE) && (giTRTraceLevel >= n))
    {
        int i;

        TRDebugPrint(MODNAME ": ");

        for (i = 0; i < giTRTraceIndent; ++i)
        {
            TRDebugPrint("| ");
        }

        TRDebugPrint(ProcName);

        rc = TRUE;
    }

    return rc;
}       //TRIsTraceOn

#endif  //ifdef TRTRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\wintrace\client.c ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    client.c

Abstract:

    This module contains the message client code.

Author:

    Michael Tsang (MikeTs) 25-May-2000

Environment:

    User mode

Revision History:

--*/

#include "pch.h"

//
// Global Data
//
DWORD      gdwfWinTrace = 0;
CLIENTINFO gClientInfo = {0};
char       gszClientName[MAX_CLIENTNAME_LEN] = {0};
HANDLE     ghTraceMutex = NULL;
HANDLE     ghClientThread = (HANDLE)-1;
HCLIENT    ghClient = 0;
PSZ        gpszProcName = NULL;
RPC_BINDING_HANDLE ghTracerBinding = NULL;

/*++
    @doc    INTERNAL

    @func   VOID | ClientThread | Client thread procedure.

    @parm   IN PSZ | pszClientName | Points to client name string.

    @rvalue None.
--*/

VOID __cdecl
ClientThread(
    IN PSZ pszClientName
    )
{
    WTTRACEPROC("ClientThread", 1)
    BOOL fDone = FALSE;
    RPC_STATUS status;
    unsigned char *StringBinding = NULL;

    WTENTER(("(ClientName=%s)\n", pszClientName));

    while (!fDone)
    {
        if ((status = RpcStringBindingCompose(NULL,
                                              TEXT("ncalrpc"),
                                              NULL,
                                              NULL,
                                              NULL,
                                              &StringBinding)) != RPC_S_OK)
        {
            WTERRPRINT(("RpcStringBindingCompose failed (status=%d)\n",
                        status));
            break;
        }
        else if ((status = RpcBindingFromStringBinding(StringBinding,
                                                       &ghTracerBinding)) !=
                 RPC_S_OK)
        {
            WTERRPRINT(("RpcBindingFromStringBinding failed (status=%d)\n",
                        status));
            break;
        }
        else if ((status = RpcBindingSetAuthInfo(ghTracerBinding,
                                                 NULL,
                                                 RPC_C_AUTHN_LEVEL_NONE,
                                                 RPC_C_AUTHN_WINNT,
                                                 NULL,
                                                 0)) != RPC_S_OK)
        {
            WTERRPRINT(("RpcBindingSetAuthInfo failed (status=%d)\n", status));
            break;
        }
        else
        {
            RPC_TRY("WTRegisterClient",
                    ghClient = WTRegisterClient(ghTracerBinding,
                                                pszClientName));
            if (ghClient == 0)
            {
                WTWARNPRINT(("Failed to register client \"%s\", try again later...\n",
                             pszClientName));
            }
            else
            {
                //
                // Service server callback requests.  This call does not
                // come back until the server terminates the link.
                //
                gdwfWinTrace |= WTF_CLIENT_READY;
                RPC_TRY("WTDispatchServerRequests",
                        WTDispatchServerRequests(ghTracerBinding, ghClient));
                gdwfWinTrace &= ~WTF_CLIENT_READY;
            }
        }

        if (StringBinding != NULL)
        {
            RpcStringFree(&StringBinding);
            StringBinding = NULL;
        }

        if (gdwfWinTrace & WTF_TERMINATING)
        {
            break;
        }

        Sleep(TIMEOUT_WAIT_SERVER);
    }
    _endthread();

    WTEXIT(("!\n"));
    return;
}       //ClientThread

/*++
    @doc    EXTERNAL

    @func   VOID | WTGetClientInfo | Get client info.

    @parm   IN PCLIENTINFO | ClientInfo | Points to the buffer to hold client
            info.

    @rvalue None.
--*/

VOID
WTGetClientInfo(
    IN PCLIENTINFO ClientInfo
    )
{
    WTTRACEPROC("WTGetClientInfo", 1)

    WTENTER(("(ClientInfo=%p)\n", ClientInfo));

    *ClientInfo = gClientInfo;

    WTEXIT(("!\n"));
    return;
}       //WTGetClientInfo

/*++
    @doc    EXTERNAL

    @func   VOID | WTSetClientInfo | Set client info.

    @parm   IN PCLIENTINFO | ClientInfo | Points to the client info.
            info.

    @rvalue None.
--*/

VOID
WTSetClientInfo(
    IN PCLIENTINFO ClientInfo
    )
{
    WTTRACEPROC("WTSetClientInfo", 1)

    WTENTER(("(ClientInfo=%p)\n", ClientInfo));

    gClientInfo = *ClientInfo;

    WTEXIT(("!\n"));
    return;
}       //WTSetClientInfo

/*++
    @doc    INTERNAL

    @func   PTRIGPT | FindTrigPt |
            Determine if the given procedure is a trigger point.

    @parm   IN PSZ | pszProcName | Points to procedure name string.

    @rvalue SUCCESS | Returns the trigger point found.
    @rvalue FAILURE | Returns NULL.
--*/

PTRIGPT LOCAL
FindTrigPt(
    IN PSZ  pszProcName
    )
{
    WTTRACEPROC("FindTrigPt", 3)
    PTRIGPT TrigPt = NULL;
    int i;

    WTENTER(("(ProcName=%s)\n", pszProcName));

    for (i = 0; i < NUM_TRIGPTS; ++i)
    {
        if ((gClientInfo.TrigPts[i].dwfTrigPt &
             (TRIGPT_TRACE_ENABLED | TRIGPT_BREAK_ENABLED)) &&
            strstr(pszProcName, gClientInfo.TrigPts[i].szProcName))
        {
            TrigPt = &gClientInfo.TrigPts[i];
            break;
        }
    }

    WTEXIT(("=%p\n", TrigPt));
    return TrigPt;
}       //FindTrigPt

/*++
    @doc    EXTERNAL

    @func   void __RPC_FAR * | MIDL_alloc | MIDL allocate.

    @parm   IN size_t | len | size of allocation.

    @rvalue SUCCESS | Returns the pointer to the memory allocated.
    @rvalue FAILURE | Returns NULL.
--*/

void __RPC_FAR * __RPC_USER
MIDL_alloc(
    IN size_t len
    )
{
    WTTRACEPROC("MIDL_alloc", 5)
    void __RPC_FAR *ptr;

    WTENTER(("(len=%d)\n", len));

    ptr = malloc(len);

    WTEXIT(("=%p\n", ptr));
    return ptr;
}       //MIDL_alloc

/*++
    @doc    EXTERNAL

    @func   void | MIDL_free | MIDL free.

    @parm   IN void __PRC_FAR * | ptr | Points to the memory to be freed.

    @rvalue None.
--*/

void __RPC_USER
MIDL_free(
    IN void __RPC_FAR *ptr
    )
{
    WTTRACEPROC("MIDL_free", 5)

    WTENTER(("(ptr=%p)\n", ptr));

    free(ptr);

    WTEXIT(("!\n"));
    return;
}       //MIDL_free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\tracer\trtrace.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    trtrace.h

Abstract:

    This module contains definitions of the trace functions

Author:
    Michael Tsang (MikeTs) 24-Sep-1998

Environment:

    User mode


Revision History:


--*/

#ifndef _TRTRACE_H
#define _TRTRACE_H

//
// Constants
//
#define TF_CHECKING_TRACE       0x00000001

//
// Macros
//
#ifdef TRTRACE
  #define TRTRACEPROC(s,n)      static PSZ ProcName = s;                    \
                                static int ProcLevel = n;
  #define TRENTER(p)            {                                           \
                                    if (TRIsTraceOn(ProcLevel, ProcName))   \
                                    {                                       \
                                        gdwfTRTrace |= TF_CHECKING_TRACE;   \
                                        TRDebugPrint p;                     \
                                        gdwfTRTrace &= ~TF_CHECKING_TRACE;  \
                                    }                                       \
                                    ++giTRTraceIndent;                      \
                                }
  #define TREXIT(p)             {                                           \
                                    --giTRTraceIndent;                      \
                                    if (TRIsTraceOn(ProcLevel, ProcName))   \
                                    {                                       \
                                        gdwfTRTrace |= TF_CHECKING_TRACE;   \
                                        TRDebugPrint p;                     \
                                        gdwfTRTrace &= ~TF_CHECKING_TRACE;  \
                                    }                                       \
                                }
#else
  #define TRTRACEPROC(s,n)
  #define TRENTER(p)
  #define TREXIT(p)
#endif

//
// Exported data
//
#ifdef TRTRACE
extern int giTRTraceIndent;
extern ULONG gdwfTRTrace;
#endif

//
// Exported function prototypes
//
#ifdef TRTRACE
BOOLEAN
TRIsTraceOn(
    IN int n,
    IN PSZ ProcName
    );
#endif

#endif  //ifndef _TRTRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\wintrace\pch.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pch.h

Abstract:  Pre-compile C header file.


Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 01-May-2000

Revision History:

--*/

#ifndef _PCH_H
#define _PCH_H

#define WINTRACE
#define MODNAME                 "WinTrace"

#if DBG
  #define WTDEBUG
  #define WTTRACE
#endif

#define MIDL_user_allocate      MIDL_alloc
#define MIDL_user_free          MIDL_free

#include <malloc.h>
#include <process.h>
#include <windows.h>
#include <wintrace.h>
#include "wtrace.h"
#include "wtracep.h"
#include "wtdebug.h"
#include "wttrace.h"

#endif  //ifndef _PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\wintrace\wtdebug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    wtdebug.h

Abstract:
    Contains debug related definitions.

Environment:
    User mode

Author:
    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#ifndef _WTDEBUG_H
#define _WTDEBUG_H

//
// Macros
//
#ifdef WTDEBUG
  #define WTASSERT(x)           if (!(x))                                      \
                                {                                              \
                                    WTDebugPrint("Assertion failed in file "   \
                                                 "%s at line %d\n",            \
                                                 __FILE__, __LINE__);          \
                                }
  #define WTDBGPRINT(n,x)       if ((n) <= giWTVerboseLevel)                   \
                                {                                              \
                                    WTDebugPrint(MODNAME ": %s: ", ProcName);  \
                                    WTDebugPrint x;                            \
                                }
  #define WTWARNPRINT(x)        {                                              \
                                    WTDebugPrint(MODNAME "_WARN: %s: ",        \
                                                 ProcName);                    \
                                    WTDebugPrint x;                            \
                                }
  #define WTERRPRINT(x)         {                                              \
                                    WTDebugPrint(MODNAME "_ERR: %s: ",         \
                                                 ProcName);                    \
                                    WTDebugPrint x;                            \
                                    DebugBreak();                              \
                                }
#else
  #define WTASSERT(x)
  #define WTDBGPRINT(n,x)
  #define WTWARNPRINT(x)
  #define WTERRPRINT(x)
#endif  //ifdef WTDEBUG

//
// Exported Data Declarations
//
extern int giWTVerboseLevel;

//
// Exported Function prototypes
//
#ifdef WTDEBUG
int LOCAL
WTDebugPrint(
    IN LPCSTR format,
    ...
    );

#endif  //ifdef WTDEBUG

#endif  //ifndef _WTDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\wintrace\wtdebug.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wtdebug.c

Abstract: This module contains all the debug functions.

Environment:

    User mode

Author:

    Michael Tsang (MikeTs) 13-Mar-2000

Revision History:

--*/

#include "pch.h"

#ifdef WTDEBUG

int giWTVerboseLevel = 0;

/*++
    @doc    INTERNAL

    @func   VOID | WTDebugPrint | Print to system debugger.

    @parm   IN LPCSTR | format | Points to the format string.
    @parm   ... | Arguments.

    @rvalue SUCCESS | returns the number of chars stored in the buffer not
            counting the terminating null characters.
    @rvalue FAILURE | returns less than the length of the expected output.
--*/

int LOCAL
WTDebugPrint(
    IN LPCSTR format,
    ...
    )
{
    int n;
    static char szMessage[256] = {0};
    va_list arglist;

    va_start(arglist, format);
    n = wvsprintfA(szMessage, format, arglist);
    va_end(arglist);
    OutputDebugStringA(szMessage);

    return n;
}       //WTDebugPrint

#endif  //ifdef WTDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\wintrace\wtracep.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    wtracep.h

Abstract:

    This module contains private definitions of the wintrace debug system.

Author:

    Michael Tsang (MikeTs) 01-May-2000

Environment:

    User mode

Revision History:

--*/

#ifndef _WTRACEP_H
#define _WTRACEP_H

//
// Constants
//
#define TIMEOUT_WAIT_SERVER             2000            //2 secs
#define TIMEOUT_TRACEMUTEX              1000            //1 sec

// gdwfWinTrace values
#define WTF_CLIENT_READY                0x00000001
#define WTF_TRACE_INPROGRESS            0x00000002
#define WTF_TERMINATING                 0x80000000

#define SRVREQ_TERMINATE                1

//
// Macros
//
#define RPC_TRY(n,s)            {                                           \
                                    RpcTryExcept                            \
                                    {                                       \
                                        s;                                  \
                                    }                                       \
                                    RpcExcept(1)                            \
                                    {                                       \
                                        ULONG dwCode = RpcExceptionCode();  \
                                        if (dwCode != EPT_S_NOT_REGISTERED) \
                                        {                                   \
                                            WTERRPRINT(("%s failed with "   \
                                                        "exception code "   \
                                                        "%d.\n",            \
                                                        n,                  \
                                                        dwCode));           \
                                        }                                   \
                                    }                                       \
                                    RpcEndExcept                            \
                                }

//
// Type definitions
//

//
// Global Data
//
extern DWORD      gdwfWinTrace;
extern CLIENTINFO gClientInfo;
extern char       gszClientName[MAX_CLIENTNAME_LEN];
extern HANDLE     ghTraceMutex;
extern HANDLE     ghClientThread;
extern HCLIENT    ghClient;
extern PSZ        gpszProcName;
extern RPC_BINDING_HANDLE ghTracerBinding;

//
// Function prototypes
//

// client.c
VOID __cdecl
ClientThread(
    IN PSZ pszClientName
    );

PTRIGPT LOCAL
FindTrigPt(
    IN PSZ  pszProcName
    );

#endif  //ifndef _WTRACEP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\wintrace\wttrace.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    wttrace.h

Abstract:

    This module contains definitions of the trace functions

Author:
    Michael Tsang (MikeTs) 24-Sep-1998

Environment:

    User mode


Revision History:


--*/

#ifndef _WTTRACE_H
#define _WTTRACE_H

//
// Constants
//
#define TF_CHECKING_TRACE       0x00000001

//
// Macros
//
#ifdef WTTRACE
  #define WTTRACEPROC(s,n)      static PSZ ProcName = s;                   \
                                static int ProcLevel = n;
  #define WTENTER(p)            {                                          \
                                    if (WTIsTraceOn(ProcLevel, ProcName))  \
                                    {                                      \
                                        gdwfWTTrace |= TF_CHECKING_TRACE;  \
                                        WTDebugPrint p;                    \
                                        gdwfWTTrace &= ~TF_CHECKING_TRACE; \
                                    }                                      \
                                    ++giWTTraceIndent;                     \
                                }
  #define WTEXIT(p)             {                                          \
                                    --giWTTraceIndent;                     \
                                    if (WTIsTraceOn(ProcLevel, ProcName))  \
                                    {                                      \
                                        gdwfWTTrace |= TF_CHECKING_TRACE;  \
                                        WTDebugPrint p;                    \
                                        gdwfWTTrace &= ~TF_CHECKING_TRACE; \
                                    }                                      \
                                }
#else
  #define WTTRACEPROC(s,n)
  #define WTENTER(p)
  #define WTEXIT(p)
#endif

//
// Exported data
//
#ifdef WTTRACE
extern int giWTTraceIndent;
extern ULONG gdwfWTTrace;
#endif

//
// Exported function prototypes
//
#ifdef WTTRACE
BOOLEAN LOCAL
WTIsTraceOn(
    IN int n,
    IN PSZ ProcName
    );
#endif

#endif  //ifndef _WTTRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\wintrace\wintrace.c ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    wintrace.c

Abstract:

    This module contains the code for the wintrace APIs.

Author:

    Michael Tsang (MikeTs) 01-May-2000

Environment:

    User mode

Revision History:

--*/

#include "pch.h"

int   giIndentLevel = 0;
DWORD gdwfTraceTxt = 0;
NAMETABLE  WMMsgNames[] =
{
    WM_NULL,                            "Null",
    WM_CREATE,                          "Create",
    WM_DESTROY,                         "Destroy",
    WM_MOVE,                            "Move",
    WM_SIZE,                            "Size",
    WM_ACTIVATE,                        "Activate",
    WM_SETFOCUS,                        "SetFocus",
    WM_KILLFOCUS,                       "KillFocus",
    WM_ENABLE,                          "Enable",
    WM_SETREDRAW,                       "SetRedraw",
    WM_SETTEXT,                         "SetText",
    WM_GETTEXT,                         "GetText",
    WM_GETTEXTLENGTH,                   "GetTextLen",
    WM_PAINT,                           "Paint",
    WM_CLOSE,                           "Close",
    WM_QUERYENDSESSION,                 "QueryEndSession",
    WM_QUERYOPEN,                       "QueryOpen",
    WM_ENDSESSION,                      "EndSession",
    WM_QUIT,                            "Quit",
    WM_ERASEBKGND,                      "EraseBackground",
    WM_SYSCOLORCHANGE,                  "SysColorChange",
    WM_SHOWWINDOW,                      "ShowWindow",
    WM_WININICHANGE,                    "WinIniChange",
    WM_SETTINGCHANGE,                   "SettingChange",
    WM_DEVMODECHANGE,                   "DevModeChange",
    WM_ACTIVATEAPP,                     "ActivateApp",
    WM_FONTCHANGE,                      "FontChange",
    WM_TIMECHANGE,                      "TimeChange",
    WM_CANCELMODE,                      "CancelMode",
    WM_SETCURSOR,                       "SetCursor",
    WM_MOUSEACTIVATE,                   "MouseActivate",
    WM_CHILDACTIVATE,                   "ChildActivate",
    WM_QUEUESYNC,                       "QueueSync",
    WM_GETMINMAXINFO,                   "GetMinMaxInfo",
    WM_PAINTICON,                       "PaintIcon",
    WM_ICONERASEBKGND,                  "IconEraseBackground",
    WM_NEXTDLGCTL,                      "NextDialogControl",
    WM_SPOOLERSTATUS,                   "SpoolerStatus",
    WM_DRAWITEM,                        "DrawItem",
    WM_MEASUREITEM,                     "MeasureItem",
    WM_DELETEITEM,                      "DeleteItem",
    WM_VKEYTOITEM,                      "VKeyToItem",
    WM_CHARTOITEM,                      "CharToItem",
    WM_SETFONT,                         "SetFont",
    WM_GETFONT,                         "GetFont",
    WM_SETHOTKEY,                       "SetHotKey",
    WM_GETHOTKEY,                       "GetHotKey",
    WM_QUERYDRAGICON,                   "QueryDragIcon",
    WM_COMPAREITEM,                     "CompareItem",
    WM_GETOBJECT,                       "GetObject",
    WM_COMPACTING,                      "Compacting",
    WM_COMMNOTIFY,                      "CommNotify",
    WM_WINDOWPOSCHANGING,               "WindowPosChanging",
    WM_WINDOWPOSCHANGED,                "WindowPosChanged",
    WM_POWER,                           "Power",
    WM_COPYDATA,                        "CopyData",
    WM_CANCELJOURNAL,                   "CancelJournal",
    WM_NOTIFY,                          "Notify",
    WM_INPUTLANGCHANGEREQUEST,          "InputLangChangeRequest",
    WM_INPUTLANGCHANGE,                 "InputLangChange",
    WM_TCARD,                           "TCard",
    WM_HELP,                            "Help",
    WM_USERCHANGED,                     "UserChanged",
    WM_NOTIFYFORMAT,                    "NotifyFormat",
    WM_CONTEXTMENU,                     "ContextMenu",
    WM_STYLECHANGING,                   "StyleChanging",
    WM_STYLECHANGED,                    "StyleChanged",
    WM_DISPLAYCHANGE,                   "DisplayChange",
    WM_GETICON,                         "GetIcon",
    WM_SETICON,                         "SetIcon",
    WM_NCCREATE,                        "NCCreate",
    WM_NCDESTROY,                       "NCDestroy",
    WM_NCCALCSIZE,                      "NCCalcSize",
    WM_NCHITTEST,                       "NCHitTest",
    WM_NCPAINT,                         "NCPaint",
    WM_NCACTIVATE,                      "NCActivate",
    WM_GETDLGCODE,                      "GetDialogCode",
    WM_SYNCPAINT,                       "SyncPaint",
    WM_NCMOUSEMOVE,                     "NCMouseMove",
    WM_NCLBUTTONDOWN,                   "NCLeftButtonDown",
    WM_NCLBUTTONUP,                     "NCLeftButtonUp",
    WM_NCLBUTTONDBLCLK,                 "NCLeftButtonDoubleClick",
    WM_NCRBUTTONDOWN,                   "NCRightButtonDown",
    WM_NCRBUTTONUP,                     "NCRightButtonUp",
    WM_NCRBUTTONDBLCLK,                 "NCRightButtonDoubleClick",
    WM_NCMBUTTONDOWN,                   "NCMiddleButtonDown",
    WM_NCMBUTTONUP,                     "NCMiddleButtonUp",
    WM_NCMBUTTONDBLCLK,                 "NCMiddleButtonDoubleClick",
    WM_NCXBUTTONDOWN,                   "NCXButtonDown",
    WM_NCXBUTTONUP,                     "NCXButtonUp",
    WM_NCXBUTTONDBLCLK,                 "NCXButtonDoubleClick",
    WM_KEYFIRST,                        "KeyFirst",
    WM_KEYDOWN,                         "KeyDown",
    WM_KEYUP,                           "KeyUp",
    WM_CHAR,                            "Char",
    WM_DEADCHAR,                        "DeadChar",
    WM_SYSKEYDOWN,                      "SysKeyDown",
    WM_SYSKEYUP,                        "SysKeyUp",
    WM_SYSCHAR,                         "SysChar",
    WM_SYSDEADCHAR,                     "SysDeadChar",
    WM_KEYLAST,                         "KeyLast",
    WM_IME_STARTCOMPOSITION,            "IMEStartComposition",
    WM_IME_ENDCOMPOSITION,              "IMEEndComposition",
    WM_IME_COMPOSITION,                 "IMEComposition",
    WM_IME_KEYLAST,                     "IMEKeyLast",
    WM_INITDIALOG,                      "InitDialog",
    WM_COMMAND,                         "Command",
    WM_SYSCOMMAND,                      "SysCommand",
    WM_TIMER,                           "Timer",
    WM_HSCROLL,                         "HScroll",
    WM_VSCROLL,                         "VScroll",
    WM_INITMENU,                        "InitMenu",
    WM_INITMENUPOPUP,                   "InitMenuPopup",
    WM_MENUSELECT,                      "MenuSelect",
    WM_MENUCHAR,                        "MenuChar",
    WM_ENTERIDLE,                       "EnterIdle",
    WM_MENURBUTTONUP,                   "MenuRightButtonUp",
    WM_MENUDRAG,                        "MenuDrag",
    WM_MENUGETOBJECT,                   "MenuGetObject",
    WM_UNINITMENUPOPUP,                 "UninitMenuPopup",
    WM_MENUCOMMAND,                     "MenuCommand",
    WM_CHANGEUISTATE,                   "ChangeUIState",
    WM_UPDATEUISTATE,                   "UpdateUIState",
    WM_QUERYUISTATE,                    "QueryUIState",
    WM_CTLCOLORMSGBOX,                  "CtlColorMsgBox",
    WM_CTLCOLOREDIT,                    "CtlColorEdit",
    WM_CTLCOLORLISTBOX,                 "CtlColorListBox",
    WM_CTLCOLORBTN,                     "CtlColorButton",
    WM_CTLCOLORDLG,                     "CtlColorDialog",
    WM_CTLCOLORSCROLLBAR,               "CtlColorScrollBar",
    WM_CTLCOLORSTATIC,                  "CtlColorStatic",
    WM_MOUSEFIRST,                      "MouseFirst",
    WM_MOUSEMOVE,                       "MouseMove",
    WM_LBUTTONDOWN,                     "LeftButtonDown",
    WM_LBUTTONUP,                       "LeftButtonUp",
    WM_LBUTTONDBLCLK,                   "LeftButtonDoubleClick",
    WM_RBUTTONDOWN,                     "RightButtonDown",
    WM_RBUTTONUP,                       "RightButtonUp",
    WM_RBUTTONDBLCLK,                   "RightButtonDoubleClick",
    WM_MBUTTONDOWN,                     "MiddleButtonDown",
    WM_MBUTTONUP,                       "MiddleButtonUp",
    WM_MBUTTONDBLCLK,                   "MiddleButtonDoubleClick",
    WM_MOUSEWHEEL,                      "MouseWheel",
    WM_XBUTTONDOWN,                     "XButtonDown",
    WM_XBUTTONUP,                       "XButtonUp",
    WM_XBUTTONDBLCLK,                   "XButtonDoubleClick",
    WM_MOUSELAST,                       "MouseLast",
    WM_PARENTNOTIFY,                    "ParentNotify",
    WM_ENTERMENULOOP,                   "EnterMenuLoop",
    WM_EXITMENULOOP,                    "ExitMenuLoop",
    WM_NEXTMENU,                        "NextMenu",
    WM_SIZING,                          "Sizing",
    WM_CAPTURECHANGED,                  "CaptureChanged",
    WM_MOVING,                          "Moving",
    WM_POWERBROADCAST,                  "PowerBroadcast",
    WM_DEVICECHANGE,                    "DeviceChange",
    WM_MDICREATE,                       "MDICreate",
    WM_MDIDESTROY,                      "MDIDestroy",
    WM_MDIACTIVATE,                     "MDIActivate",
    WM_MDIRESTORE,                      "MDIRestore",
    WM_MDINEXT,                         "MDINext",
    WM_MDIMAXIMIZE,                     "MDIMaximize",
    WM_MDITILE,                         "MDITitle",
    WM_MDICASCADE,                      "MDICascade",
    WM_MDIICONARRANGE,                  "MDIIconArrange",
    WM_MDIGETACTIVE,                    "MDIGetActive",
    WM_MDISETMENU,                      "MDISetMenu",
    WM_ENTERSIZEMOVE,                   "EnterSizeMove",
    WM_EXITSIZEMOVE,                    "ExitSizeMove",
    WM_DROPFILES,                       "DropFiles",
    WM_MDIREFRESHMENU,                  "MDIRefreshMenu",
    WM_IME_SETCONTEXT,                  "IMESetContext",
    WM_IME_NOTIFY,                      "IMENotify",
    WM_IME_CONTROL,                     "IMEControl",
    WM_IME_COMPOSITIONFULL,             "IMECompositionFull",
    WM_IME_SELECT,                      "IMESelect",
    WM_IME_CHAR,                        "IMEChar",
    WM_IME_REQUEST,                     "IMERequest",
    WM_IME_KEYDOWN,                     "IMEKeyDown",
    WM_IME_KEYUP,                       "IMEKeyUp",
    WM_MOUSEHOVER,                      "MouseHover",
    WM_MOUSELEAVE,                      "MouseLeave",
    WM_NCMOUSEHOVER,                    "NCMouseHover",
    WM_NCMOUSELEAVE,                    "NCMouseLeave",
    WM_CUT,                             "Cut",
    WM_COPY,                            "Copy",
    WM_PASTE,                           "Paste",
    WM_CLEAR,                           "Clear",
    WM_UNDO,                            "Undo",
    WM_RENDERFORMAT,                    "RenderFormat",
    WM_RENDERALLFORMATS,                "RenderAllFormats",
    WM_DESTROYCLIPBOARD,                "DestroyClipboard",
    WM_DRAWCLIPBOARD,                   "DrawClipboard",
    WM_PAINTCLIPBOARD,                  "PaintClipboard",
    WM_VSCROLLCLIPBOARD,                "VScrollClipboard",
    WM_SIZECLIPBOARD,                   "SizeClipboard",
    WM_ASKCBFORMATNAME,                 "AskCBFormatName",
    WM_CHANGECBCHAIN,                   "ChangeCBChain",
    WM_HSCROLLCLIPBOARD,                "HScrollClipboard",
    WM_QUERYNEWPALETTE,                 "QueryNewPalette",
    WM_PALETTEISCHANGING,               "PaletteIsChanging",
    WM_PALETTECHANGED,                  "PaletteChanged",
    WM_HOTKEY,                          "HotKey",
    WM_PRINT,                           "Print",
    WM_PRINTCLIENT,                     "PrintClient",
    WM_APPCOMMAND,                      "AppCommand",
    WM_HANDHELDFIRST,                   "HandHeldFirst",
    WM_HANDHELDLAST,                    "HandHeldLast",
    WM_AFXFIRST,                        "AFXFirst",
    WM_AFXLAST,                         "AFXLast",
    WM_PENWINFIRST,                     "PenWinFirst",
    WM_PENWINLAST,                      "PenWinLast",
    WM_USER,                            "User",
    WM_APP,                             "App",
    0x00,                               NULL
};

/*++
    @doc    EXTERNAL

    @func   VOID | TraceInit | Initialize the tracing component.

    @parm   IN PSZ | pszClientName | Points to the client name string.
    @parm   IN int | iDefTraceLevel | Specifies default trace level.
    @parm   IN int | iDefVerboseLevel | Specifies default verbose level.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL EXPORT
TraceInit(
    IN PSZ pszClientName,
    IN int iDefTraceLevel,
    IN int iDefVerboseLevel
    )
{
    WTTRACEPROC("TraceInit", 1)
    BOOL rc = FALSE;
    char szMsg[128];

    WTENTER(("(ClientName=%s,DefTraceLevel=%d,DefVerboseLevel=%d)\n",
             pszClientName, iDefTraceLevel, iDefVerboseLevel));

    if (ghClientThread == (HANDLE)-1)
    {
        gdwfWinTrace = 0;
        gdwfTraceTxt = 0;
        giIndentLevel = 0;
        memset(&gClientInfo, 0, sizeof(gClientInfo));
        memset(gszClientName, 0, sizeof(gszClientName));
        lstrcpynA(gszClientName, pszClientName, sizeof(gszClientName));
        gClientInfo.Settings.iTraceLevel = iDefTraceLevel;
        gClientInfo.Settings.iVerboseLevel = iDefVerboseLevel;
        ghTraceMutex = CreateMutex(NULL, FALSE, NULL);
        if (ghTraceMutex == NULL)
        {
            WTERRPRINT(("Failed to create trace mutex (err=%d).\n",
                        GetLastError()));
        }
        else
        {
            ghClientThread = (HANDLE)_beginthread(ClientThread,
                                                  0,
                                                  pszClientName);
            if (ghClientThread != (HANDLE)-1)
            {
                rc = TRUE;
            }
            else
            {
                CloseHandle(ghTraceMutex);
                ghTraceMutex = 0;
                WTERRPRINT(("Failed to create client thread.\n"));
            }
        }
    }
    else
    {
        WTERRPRINT(("Client is already initialized\n"));
    }

    WTEXIT(("=%x\n", rc));
    return rc;
}       //TraceInit

/*++
    @doc    EXTERNAL

    @func   VOID | TraceTerminate | Terminating trace, clean up.

    @parm   VOID | None.

    @rvalue None
--*/

VOID EXPORT
TraceTerminate(
    VOID
    )
{
    WTTRACEPROC("TraceTerminate", 1)

    WTENTER(("()\n"));

    if (ghClientThread != (HANDLE)-1)
    {
        DWORD rc;

        gdwfWinTrace |= WTF_TERMINATING;
        if (ghClient != 0)
        {
            RPC_TRY("WTDeregisterClient",
                    WTDeregisterClient(ghTracerBinding, ghClient));
            ghClient = 0;
        }
        rc = WaitForSingleObject(ghClientThread, INFINITE);
        WTASSERT(rc == WAIT_OBJECT_0);
        gdwfWinTrace = 0;
        gdwfTraceTxt = 0;
        giIndentLevel = 0;
    }

    if (ghTraceMutex != NULL)
    {
        CloseHandle(ghTraceMutex);
        ghTraceMutex = 0;
    }

    WTEXIT(("!\n"));
    return;
}       //TraceTerminate

/*++
    @doc    EXTERNAL

    @func   BOOL | IsTraceProcOn |
            Determine if the given procedure should be traced.

    @parm   IN PSZ | pszProcName | Points to procedure name string.
    @parm   IN int | iProcLevel |  Specifies the procedure trace level.
    @parm   IN BOOL | fEnter | TRUE if called from ENTERPROC.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL EXPORT
IsTraceProcOn(
    IN PSZ  pszProcName,
    IN int  iProcLevel,
    IN BOOL fEnter
    )
{
    WTTRACEPROC("IsTraceProcOn", 2)
    BOOL rc = FALSE;
    DWORD rcWait;
    static int icTriggers = 0;

    WTENTER(("(ProcName=%s,ProcLevel=%d,fEnter=%x)\n",
             pszProcName, iProcLevel, fEnter));

    if (giIndentLevel < 0)
    {
        giIndentLevel = 0;
    }

    gdwfTraceTxt &= ~TRACETXT_BREAK;
    if (ghTraceMutex != 0)
    {
        rcWait = WaitForSingleObject(ghTraceMutex, TIMEOUT_TRACEMUTEX);
        if (rcWait == WAIT_OBJECT_0)
        {
            if (!(gdwfWinTrace & WTF_TRACE_INPROGRESS))
            {
                PTRIGPT TrigPt;

                if ((gClientInfo.Settings.dwfSettings &
                     SETTINGS_TRIGMODE_ENABLED) &&
                    ((TrigPt = FindTrigPt(pszProcName)) != NULL))
                {
                    if (TrigPt->dwfTrigPt & TRIGPT_TRACE_ENABLED)
                    {
                        if (fEnter)
                        {
                            icTriggers++;
                        }
                        else
                        {
                            icTriggers--;
                        }
                        rc = TRUE;
                    }

                    if (TrigPt->dwfTrigPt & TRIGPT_BREAK_ENABLED)
                    {
                        gdwfTraceTxt |= TRACETXT_BREAK;
                    }
                }
                else if ((iProcLevel <= gClientInfo.Settings.iTraceLevel) &&
                         (!(gClientInfo.Settings.dwfSettings &
                            SETTINGS_TRIGMODE_ENABLED) || (icTriggers > 0)))
                {
                    rc = TRUE;
                }

                if (rc == TRUE)
                {
                    gpszProcName = pszProcName;
                    gdwfWinTrace |= WTF_TRACE_INPROGRESS;
                }
            }

            if (rc == FALSE)
            {
                ReleaseMutex(ghTraceMutex);
            }
        }
        else
        {
            WTERRPRINT(("Failed to wait for trace mutex (rc=%x).\n", rcWait));
        }
    }

    WTEXIT(("=%x\n", rc));
    return rc;
}       //IsTraceProcOn

/*++
    @doc    EXTERNAL

    @func   VOID | TraceProc | Trace procedure.

    @parm   IN PSZ | pszFormat | Points to format string.
    @parm   ... | Substituting arguments for the format string.

    @rvalue None.
--*/

VOID EXPORT
TraceProc(
    IN PSZ  pszFormat,
    ...
    )
{
    WTTRACEPROC("TraceProc", 2)
    BOOL fToDebugger;
    char szTraceTxt[MAX_TRACETXT_LEN];
    va_list arglist;

    WTENTER(("(Format=%s,...)\n", pszFormat));

    if (!(gdwfWinTrace & WTF_CLIENT_READY) ||
        (gClientInfo.Settings.dwfSettings & SETTINGS_TRACE_TO_DEBUGGER))
    {
        int i;

        fToDebugger = TRUE;
        wsprintfA(szTraceTxt, "[%08x]%s: ",
                  GetCurrentThreadId(), gszClientName);
        for (i = 0; i < giIndentLevel; ++i)
        {
            lstrcatA(szTraceTxt, "| ");
        }
    }
    else
    {
        fToDebugger = FALSE;
        szTraceTxt[0] = '\0';
    }

    lstrcatA(szTraceTxt, gpszProcName);
    va_start(arglist, pszFormat);
    wvsprintfA(&szTraceTxt[lstrlenA(szTraceTxt)], pszFormat, arglist);
    va_end(arglist);

    if (fToDebugger)
    {
        OutputDebugStringA(szTraceTxt);
    }
    else
    {
        RPC_TRY("WTTraceProc",
                WTTraceProc(ghTracerBinding,
                            ghClient,
                            GetCurrentThreadId(),
                            giIndentLevel,
                            szTraceTxt));
    }

    gdwfWinTrace &= ~WTF_TRACE_INPROGRESS;
    ReleaseMutex(ghTraceMutex);

    WTEXIT(("!\n"));
    return;
}       //TraceProc

/*++
    @doc    EXTERNAL

    @func   BOOL | IsTraceMsgOn | Determine if the message should be printed.

    @parm   IN PSZ | pszProcName | Points to procedure name string.
    @parm   IN int | iVerboseLevel |  Specifies the verbose level of the message.

    @rvalue SUCCESS | Returns TRUE.
    @rvalue FAILURE | Returns FALSE.
--*/

BOOL EXPORT
IsTraceMsgOn(
    IN PSZ pszProcName,
    IN int iVerboseLevel
    )
{
    WTTRACEPROC("IsTraceMsgOn", 2)
    BOOL rc = FALSE;
    DWORD rcWait;

    WTENTER(("(ProcName=%s,VerboseLevel=%d)\n", pszProcName, iVerboseLevel));

    gdwfTraceTxt &= ~TRACETXT_MSGTYPE_MASK;
    if (ghTraceMutex != 0)
    {
        rcWait = WaitForSingleObject(ghTraceMutex, TIMEOUT_TRACEMUTEX);
        if (rcWait == WAIT_OBJECT_0)
        {
            if (iVerboseLevel <= gClientInfo.Settings.iVerboseLevel)
            {
                gpszProcName = pszProcName;
                rc = TRUE;
            }

            if (rc == FALSE)
            {
                ReleaseMutex(ghTraceMutex);
            }
        }
        else
        {
            WTERRPRINT(("Failed to wait for trace mutex (rc=%x).\n", rcWait));
        }
    }

    WTEXIT(("=%x\n", rc));
    return rc;
}       //IsTraceMsgOn

/*++
    @doc    EXTERNAL

    @func   VOID | TraceMsg | Print a message.

    @parm   IN PSZ | pszFormat | Points to format string.
    @parm   ... | Substituting arguments for the format string.

    @rvalue None.
--*/

VOID EXPORT
TraceMsg(
    IN PSZ  pszFormat,
    ...
    )
{
    WTTRACEPROC("TraceMsg", 2)
    DWORD MsgType = gdwfTraceTxt & TRACETXT_MSGTYPE_MASK;
    char szTraceTxt[MAX_TRACETXT_LEN];
    va_list arglist;

    WTENTER(("(Format=%s,...)\n", pszFormat));

    wsprintfA(szTraceTxt, "[%08x]%s.%s%s: ",
              GetCurrentThreadId(),
              gszClientName, gpszProcName,
              (MsgType == TRACETXT_MSGTYPE_ERROR)? "_ERR":
              (MsgType == TRACETXT_MSGTYPE_WARN)?  "_WARN":
              (MsgType == TRACETXT_MSGTYPE_INFO)?  "_INFO": "");

    va_start(arglist, pszFormat);
    wvsprintfA(&szTraceTxt[lstrlenA(szTraceTxt)], pszFormat, arglist);
    va_end(arglist);

    if (!(gdwfWinTrace & WTF_CLIENT_READY) ||
        (gClientInfo.Settings.dwfSettings & SETTINGS_TRACE_TO_DEBUGGER))
    {
        OutputDebugStringA(szTraceTxt);
    }
    else
    {
        RPC_TRY("WTTraceMsg",
                WTTraceMsg(ghTracerBinding, ghClient, szTraceTxt));
    }

    ReleaseMutex(ghTraceMutex);

    WTEXIT(("!\n"));
    return;
}       //TraceMsg

/*++
    @doc    EXTERNAL

    @func   PSZ | LookupName |
            Look up name string of a code in the given name table.

    @parm   IN ULONG | Code | The given code to lookup.
    @parm   IN PNAMETABLE | NameTable | The name table to look into.

    @rvalue SUCCESS - Returns pointer to the minor function name string.
    @rvalue FAILURE - Returns "unknown".
--*/

PSZ EXPORT
LookupName(
    IN ULONG      Code,
    IN PNAMETABLE NameTable
    )
{
    PSZ pszName = NULL;
    static char szUnknown[64];

    while (NameTable->pszName != NULL)
    {
        if (Code == NameTable->Code)
        {
            pszName = NameTable->pszName;
            break;
        }
        NameTable++;
    }

    if (pszName == NULL)
    {
        wsprintfA(szUnknown, "unknown [0x%x (%d)]", Code, Code);
        pszName = szUnknown;
    }

    return pszName;
}       //LookupName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\dll\binfile.c ===
#include <windows.h>
#include <string.h>
#include <assert.h>
#include "item.h"
#include "binfile.h"

/*
// ReportFile operation definitions
*/

BOOL fNewBINFile(LPCSTR lpFileName, PBIN_FILE pBf)
{
    BOOL fStatus;
    DWORD dwBytesWritten;
    
    pBf -> hFileHandle = CreateFile(lpFileName,
                                    GENERIC_WRITE, 
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    0,
                                    NULL);

    if (INVALID_HANDLE_VALUE == pBf -> hFileHandle) {
        return FALSE;
    }


    /*
    // To save complictations, do no internal buffering for now.
    */

    pBf -> pbBuffer = NULL;

    /*
    // Write out the report header
    */

    fStatus = WriteFile(pBf -> hFileHandle,
                        BINFILE_HEADER,
                        BINFILE_HEADER_LENGTH,
                        &dwBytesWritten,
                        NULL);

    if (!fStatus || BINFILE_HEADER_LENGTH != dwBytesWritten) {
        CloseHandle(pBf -> hFileHandle);
        return FALSE;
    }


    pBf -> fIsRead = FALSE;
    
    return TRUE;
}

BOOL fOpenBINFile(LPCSTR lpFileName, PBIN_FILE pBf)
{
    
    BOOL fStatus;
    DWORD dwBytesRead;
    BYTE  bHeader[BINFILE_HEADER_LENGTH];
        
    pBf -> hFileHandle = CreateFile(lpFileName,
                                    GENERIC_READ, 
                                    0,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL);

    if (INVALID_HANDLE_VALUE == pBf -> hFileHandle) {
        return FALSE;
    }

    /*
    // Read the header and ignore
    */

    fStatus = ReadFile(pBf -> hFileHandle,
                       bHeader,
                       BINFILE_HEADER_LENGTH,
                       &dwBytesRead,
                       NULL);

    if (!fStatus || BINFILE_HEADER_LENGTH != dwBytesRead) {
        CloseHandle(pBf -> hFileHandle);
        return FALSE;
    }

    pBf -> fIsRead = TRUE;
    pBf -> pbBuffer = NULL;

    return TRUE;
}
  
BOOL fBINReadItem(PBIN_FILE pBf, PITEM pi)
{
    BOOL fStatus;
    DWORD dwBytesRead;
    DWORD dwDataSize;

    assert (pBf -> hFileHandle != INVALID_HANDLE_VALUE);
    assert (pBf -> fIsRead);
    
    fStatus = ReadFile(pBf -> hFileHandle,
                       &(pi -> bItemTag),
                       1,
                       &dwBytesRead,
                       NULL);

    if (!fStatus) {
        return FALSE;
    }

    if (fStatus && 0 == dwBytesRead) {
        SetLastError(ERROR_HANDLE_EOF);
        return FALSE;
    }
    
    dwDataSize = (DWORD) ITEM_DATA_SIZE(*pi);
    if (0 != dwDataSize) {
        fStatus = ReadFile(pBf -> hFileHandle,
                           pi -> bItemData,
                           dwDataSize,
                           &dwBytesRead,
                           NULL);
        if (!fStatus || dwBytesRead != dwDataSize) {
            return FALSE;
        }
    }
    return TRUE;
}

BOOL fBINReadItemBuffer(PBIN_FILE pBf, PITEM pi, PULONG pulNumItems)
{
    BOOL fStatus = TRUE;
    ULONG ulNum;

    ulNum = *pulNumItems;
  
    while (TRUE == (fStatus = fBINReadItem(pBf, pi++)) && ulNum > 0)
        ulNum--;
     
    *pulNumItems -= ulNum;

    return fStatus;
}

BOOL fBINWriteItem(PBIN_FILE pBf, ITEM i)
{
    DWORD dwItemSize;
    BYTE bData[5];
    DWORD dwBytesWritten;
    UINT uiIndex;
    BOOL fStatus;

    assert (INVALID_HANDLE_VALUE != pBf -> hFileHandle);
    assert (!pBf -> fIsRead);
    
    dwItemSize = ITEM_DATA_SIZE(i) + 1;
    bData[0] = i.bItemTag;
    for (uiIndex = 1; uiIndex <= dwItemSize; uiIndex++)
        bData[uiIndex] = i.bItemData[uiIndex-1];
    
    fStatus = WriteFile(pBf -> hFileHandle,
                        bData,
                        dwItemSize,
                        &dwBytesWritten,
                        NULL);
    return (fStatus && dwItemSize == dwBytesWritten);
}

BOOL fBINWriteItemBuffer(PBIN_FILE pBf, PITEM pi, ULONG ulNumItems)
{
    BOOL fStatus = TRUE;

    while (fStatus && (ulNumItems > 0)) {
        fStatus = fBINWriteItem(pBf, *(pi++));
        ulNumItems--;
    }
    
    return fStatus;
}

BOOL 
fBINWriteBuffer(
    IN  PBIN_FILE   pBf, 
    IN  PUCHAR      Buffer, 
    ULONG           BufferLength
)
{
    DWORD   dwBytesWritten;
    BOOL    fStatus;
     
    /*
    // If the file pointed to by pBf was opened using fNewBINFile, the header
    //    should already be written.  All that needs to be done is write the
    //    buffer to disk
    */

    fStatus = WriteFile(pBf -> hFileHandle,
                        Buffer,
                        BufferLength,
                        &dwBytesWritten,
                        NULL
                       );

    return (fStatus && BufferLength == dwBytesWritten);
}
    
void vCloseBINFile(PBIN_FILE pBf)
{

    /*
    // No buffer is currently being done on the file so we just
    //   need to close the file handle.
    */

    assert(pBf -> hFileHandle != INVALID_HANDLE_VALUE);
    
    CloseHandle(pBf -> hFileHandle);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tabletpc\wintrace\wttrace.c ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    wttrace.c

Abstract:

    This module contains the code for debug tracing.

Author:

    Michael Tsang (MikeTs) 24-Sep-1998

Environment:

    User mode

Revision History:


--*/

#include "pch.h"

#ifdef WTTRACE
//
// Local Data
//
int   giWTTraceLevel = 0;
int   giWTTraceIndent = 0;
ULONG gdwfWTTrace = 0;

/*++

Routine Description:
    This routine determines if the given procedure should be traced.

Arguments:
    n - trace level of the procedure
    ProcName - points to the procedure name string

Return Value:
    Success - returns TRUE
    Failure - returns FALSE

--*/

BOOLEAN LOCAL
WTIsTraceOn(
    IN int n,
    IN PSZ ProcName
    )
{
    BOOLEAN rc = FALSE;

    if (!(gdwfWTTrace & TF_CHECKING_TRACE) && (n <= giWTTraceLevel))
    {
        int i;

        WTDebugPrint(MODNAME ": ");

        for (i = 0; i < giWTTraceIndent; ++i)
        {
            WTDebugPrint("| ");
        }

        WTDebugPrint(ProcName);

        rc = TRUE;
    }

    return rc;
}       //WTIsTraceOn

#endif  //ifdef WTTRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\dll\binfile.h ===
#ifndef __BINFILE_H__
#define __BINFILE_H__

#define BINFILE_BUFFER_SIZE 1024
#define BINFILE_HEADER_LENGTH 11
#define BINFILE_HEADER "REPORT   \x00d\x00a"

typedef struct tagReportFile {
    HANDLE hFileHandle;
    BOOL fIsRead;
    ULONG ulBufferSize;
    BYTE *pbBuffer;
    BYTE *pbNextByte;
} BIN_FILE, *PBIN_FILE;

BOOL fNewBINFile(LPCSTR lpFileName, PBIN_FILE pBf);
BOOL fOpenBINFile(LPCSTR lpFileName, PBIN_FILE pBf);
BOOL fBINWriteItem(PBIN_FILE pBf, ITEM i);
BOOL fBINWriteItemBuffer(PBIN_FILE pBf, PITEM pi, ULONG ulNumItems);
BOOL fBINReadItem(PBIN_FILE pBf, PITEM pi);
BOOL fBINReadItemBuffer(PBIN_FILE pBf, PITEM pi, PULONG pulNumItems);
BOOL fBINWriteBuffer(PBIN_FILE pBf, PUCHAR Buffer, ULONG BufferLength);
void vCloseBINFile(PBIN_FILE pBf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\dll\datatbl.h ===
#ifndef __DATATBL_H__
#define __DATATBL_H__

/*
// This file contains all the definitions, structures and prototypes for
//     public functions that are to be used in tracking the data sizes for
//     a given report ID and report type.  The data table is currently
//     implemented as a hash table that uses chaining.  
*/

/*
// Prototype the functions that are public to other modules
*/

VOID
DataTable_InitTable(
    VOID
);

BOOL
DataTable_UpdateReportSize(
    IN ULONG            ReportID,
    IN HIDP_REPORT_TYPE ReportType,
    IN ULONG            AddedSize
);

BOOL
DataTable_UpdateAllReportSizes(
    IN ULONG            ReportID,
    IN ULONG            InputSize,
    IN ULONG            OutputSize,
    IN ULONG            FeatureSize
);

BOOL
DataTable_LookupReportSize(
    IN  ULONG            ReportID,
    IN  HIDP_REPORT_TYPE ReportType,
    OUT PULONG           ReportSize
);

BOOL    
DataTable_LookupReportID(
    IN  ULONG           ReportID,
    OUT PULONG          InputSize,
    OUT PULONG          OutputSize,
    OUT PULONG          FeatureSize,
    OUT PBOOL           IsClose
);

BOOL
DataTable_AddReportID(
    IN  ULONG   ReportID
);


ULONG
DataTable_CountOpenReportIDs(
    VOID
);

ULONG
DataTable_CountClosedReportIDs(
    VOID
);

VOID
DataTable_CloseReportID(
    IN  ULONG   ReportID
);

BOOL
DataTable_GetFirstReportID(
    OUT PULONG  ReportID,           
    OUT PULONG  InputSize,
    OUT PULONG  OutputSize,
    OUT PULONG  FeatureSize,
    OUT PBOOL   IsClosed
);

BOOL
DataTable_GetNextReportID(
    OUT PULONG  ReportID,           
    OUT PULONG  InputSize,
    OUT PULONG  OutputSize,
    OUT PULONG  FeatureSize,
    OUT PBOOL   IsClosed
);

VOID
DataTable_DestroyTable(
    VOID
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\dll\bingen.c ===
#define __BINGEN_C__

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>
#include <time.h>
#include <limits.h>
#include <math.h>
#include <assert.h>
#include <hidusage.h>
#include <hidsdi.h>
#include <hidpi.h>
#include <bingen.h>
#include "local.h"
#include "item.h"
#include "binfile.h"
#include "datatbl.h"

/*
// This is the one global variable that is used by multiple modules in the DLL..
//   It exists because we need to use the instance value of this DLL to retrieve
//   the resources for the settins
*/

HINSTANCE               g_DLLInstance;

static GENERATE_OPTIONS generate_opts;
static PUCHAR           g_ReportBuffer = NULL;
static ULONG            g_MaxBufferLength = 0;
static ULONG            g_CurrBufferLength = 0;

#define BUFFER_INIT_SIZE            256
#define BUFFER_INCREMENT_SIZE       128

#define OPTIONS_COLL_DEPTH          generate_opts.copts.ulMaxCollectionDepth
#define OPTIONS_COLL_TOP            generate_opts.copts.ulTopLevelCollections
#define OPTIONS_COLL_ITEMS_MIN      generate_opts.copts.ulMinCollectionItems
#define OPTIONS_COLL_ITEMS_MAX      generate_opts.copts.ulMaxCollectionItems
#define OPTIONS_REPORT_ID_MAX       generate_opts.copts.ulMaxReportIDs
#define OPTIONS_USE_REPORT_IDS      generate_opts.copts.fUseReportIDs

#define OPTIONS_USAGEPAGE_MIN       generate_opts.uopts.ulMinUsagePage
#define OPTIONS_USAGEPAGE_MAX       generate_opts.uopts.ulMaxUsagePage

#define OPTIONS_USAGE_MIN           generate_opts.uopts.ulMinUsage
#define OPTIONS_USAGE_MAX           generate_opts.uopts.ulMaxUsage

#define OPTIONS_CREATE_FIELDS       generate_opts.ropts.fCreateDataFields
#define OPTIONS_REPORT_SIZE_MIN     generate_opts.ropts.ulMinReportSize
#define OPTIONS_REPORT_SIZE_MAX     generate_opts.ropts.ulMaxReportSize
#define OPTIONS_REPORT_COUNT_MIN    generate_opts.ropts.ulMinReportCount
#define OPTIONS_REPORT_COUNT_MAX    generate_opts.ropts.ulMaxReportCount

#define OPTIONS_CREATE_BUTTONS      generate_opts.ropts.fCreateButtonBitmaps
#define OPTIONS_BUTTONS_MIN         generate_opts.ropts.ulMinNumButtons
#define OPTIONS_BUTTONS_MAX         generate_opts.ropts.ulMaxNumButtons

#define OPTIONS_CREATE_ARRAYS       generate_opts.ropts.fCreateArrays
#define OPTIONS_ARRAY_SIZE_MIN      generate_opts.ropts.ulMinArraySize
#define OPTIONS_ARRAY_SIZE_MAX      generate_opts.ropts.ulMaxArraySize
#define OPTIONS_ARRAY_COUNT_MIN     generate_opts.ropts.ulMinArrayCount
#define OPTIONS_ARRAY_COUNT_MAX     generate_opts.ropts.ulMaxArrayCount
#define OPTIONS_ARRAY_USAGES_MIN    generate_opts.ropts.ulMinArrayUsages
#define OPTIONS_ARRAY_USAGES_MAX    generate_opts.ropts.ulMaxArrayUsages

#define OPTIONS_CREATE_BUFFER       generate_opts.ropts.fCreateBufferedBytes
#define OPTIONS_BUFFER_MIN          generate_opts.ropts.ulMinBufferSize
#define OPTIONS_BUFFER_MAX          generate_opts.ropts.ulMaxBufferSize

/*
// Added definition since changing function SelectOption to SelectUlongNum but
//   don't want to change all references in code
*/

#define SelectOption(o1, o2)           SelectUlongNum(o1, o2)


#define IN_USAGE_RANGE(u, umin, umax)   (((umin) <= (u)) && ((u) <= (umax)))
#define IS_VALUE_ITEM(it)               ((MI_DATA == ((it) -> miType)) && \
                                         ((FD_DATA == ((it) -> fType)) || \
                                          (FD_BUFFER == ((it) -> fType))  \
                                         )                                \
                                        )

#define IS_BUTTON_ITEM(it)             ((MI_DATA == ((it) -> miType)) &&  \
                                        ((FD_ARRAY == ((it) -> fType)) || \
                                         (FD_BUTTONS == ((it) -> fType))  \
                                        )                                 \
                                       )                                        

#define INIT_LINK_COLL_INDICES()        (NextCollIndex = 0)
#define GET_LINK_COLL_INDEX()           (NextCollIndex++)

static  USHORT  NextCollIndex;

/*
// This array maps the index values for each tag index defined in bingen.h to
//    the corresponding tag value that is written to the disk.  This structure
//    is VERY dependent on the order of indices that is defined in bingen.h
*/

    static BYTE TagValues[NUM_INDICES] = {  ITEM_TAG_USAGE_PAGE,                
                                            ITEM_TAG_LOGICAL_MIN,               
                                            ITEM_TAG_LOGICAL_MAX,               
                                            ITEM_TAG_PHYSICAL_MIN,              
                                            ITEM_TAG_PHYSICAL_MAX,              
                                            ITEM_TAG_UNIT,                      
                                            ITEM_TAG_EXPONENT,                  
                                            ITEM_TAG_REPORT_SIZE,               
                                            ITEM_TAG_REPORT_COUNT,              
                                            ITEM_TAG_REPORT_ID,                 
                                            ITEM_TAG_USAGE,                     
                                            ITEM_TAG_USAGE_MIN,                 
                                            ITEM_TAG_USAGE_MAX,                 
                                            ITEM_TAG_DESIGNATOR,          
                                            ITEM_TAG_DESIGNATOR_MIN,            
                                            ITEM_TAG_DESIGNATOR_MAX,            
                                            ITEM_TAG_STRING,              
                                            ITEM_TAG_STRING_MIN,                
                                            ITEM_TAG_STRING_MAX,                
                                            ITEM_TAG_INPUT,                     
                                            ITEM_TAG_OUTPUT,                    
                                            ITEM_TAG_FEATURE,                   
                                            ITEM_TAG_COLLECTION,                
                                            ITEM_TAG_END_COLLECTION,            
                                            ITEM_TAG_DELIMITER_OPEN,            
                                            ITEM_TAG_DELIMITER_CLOSE,           
                                            ITEM_TAG_PUSH,                      
                                            ITEM_TAG_POP                       
                                         };   

/*
// All the global structures used in tracking the use of ReportIDs between
//   and the generation of collections.
*/

static  BOOL    fUseReportIDs;
static  ULONG   nApplColls;
static  ULONG   nTotalAvailIDs;
static  ULONG   nMaxAvailCollIDs;

BOOLEAN __stdcall
DllMain(
    HINSTANCE hinst,
    DWORD dwReason,
    LPVOID lpReserved
)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_DLLInstance = hinst;
            
        default: 
            return TRUE;
   }
}


/*
// GenerateBIN is the main entry routine for the binary generator.  It 
//  takes the opts argument which contains all the user specified options
//  for generating binaries including the filename for the binary.
*/

BOOL __stdcall
BINGEN_GenerateReportDescriptor(
    IN  GENERATE_OPTIONS *opts,     
    OUT PREPORT_DESC     *ReportDesc
)
{
    ULONG       MaxColls;   
    ULONG       Index;

    static BOOL fFirstSeed = TRUE;

    /*
    // Save the options that were passed in.
    */
    
    generate_opts = *opts;

    /*
    // Initialize the data table that tracks the reportIDs/ReportTypes
    */
    
    DataTable_InitTable();
    
    /*
    // Set the random generators seen if need be
    */
    
    if (fFirstSeed) {
        srand ( (unsigned) time(NULL));
        fFirstSeed = FALSE;
    }

    /*
    // Next step is to determine exactly how many top level collections
    //   will be created for this report descriptor.  If more than one top 
    //   level collection is to be generated, we MUST use report IDs.  If 
    //   only one such collection will be output, we can then decide whether
    //   or not we will use ReportIDs.  We must also consider the possibility
    //   that all ReportIDs will be closed after creating one or more top-level
    //   collections.  In that case, we must bail because we cannot create
    //   any data items within that collection.
    */

    /*
    // To determine the number of application collections we need to implement,
    //    we need to base it off of both the OPTION_COLL_TOP that the user set
    //    and the number of ReportIDs they said to use.  If there # report IDs is
    //    less that OPTIONS_COLL_TOP, that value must used instead since each report
    //    ID then must be used for each collection
    */
    
    if (!OPTIONS_USE_REPORT_IDS) {
        MaxColls = 1;
    }
    else {
        MaxColls = (OPTIONS_REPORT_ID_MAX < OPTIONS_COLL_TOP) ? OPTIONS_REPORT_ID_MAX 
                                                              : OPTIONS_COLL_TOP;
    }

    nApplColls = SelectUlongNum(1, MaxColls);

    assert (1 <= nApplColls && OPTIONS_COLL_TOP >= nApplColls);

    if (1 < nApplColls) {
        fUseReportIDs = TRUE;
    }
    else {
        fUseReportIDs = SelectOption(FALSE, 1 != nApplColls);
    }

    nTotalAvailIDs = fUseReportIDs ? OPTIONS_REPORT_ID_MAX : 1;

    /*
    // Now that it has been decided how many Application level collections
    //   will be created and whether or not ReportIDs will be used, we can
    //   start generating and outputting the top level collections
    */

    /*
    // Begin by allocating the space for our report descriptor structure that
    //    was passed in, we will attempt to allocate space to hold nApplColls
    //    structures.
    */

    *ReportDesc = (PREPORT_DESC) malloc(sizeof(REPORT_DESC)+nApplColls*sizeof(PMAIN_ITEM));
    if (NULL == *ReportDesc) {
        return (FALSE);
    }
       
    
    for (Index = 0; Index < nApplColls; Index++) {

        (*ReportDesc) -> Collections[Index] = GenerateCollection(TRUE);
            
        if (NULL == (*ReportDesc) -> Collections[Index]) {
            break;
        }
        
    }

    (*ReportDesc) -> NumberCollections = Index;

    DataTable_DestroyTable();

    return (TRUE);
}

BOOL __stdcall
BINGEN_GenerateBIN(LPCSTR filename, GENERATE_OPTIONS *opts)
{
    PREPORT_DESC    pRD;

    BOOL        fStatus;

    fStatus = BINGEN_GenerateReportDescriptor(opts, &pRD);

    if (fStatus) {

        fStatus = BINGEN_OutputReportDescriptorToDisk(pRD, filename);
        BINGEN_FreeReportDescriptor(pRD);
    
    }

    return (fStatus);
}  

PMAIN_ITEM GenerateMainItem(void)
{
    PMAIN_ITEM pMI;
    MAINITEM_TYPE miType;
    
    /*
    // Determine randomly if this option is going to be a collection or a 
    //   data item
    */
    
    miType = (MAINITEM_TYPE) SelectOption(MI_COLLECTION, MI_DATA);

    switch (miType) {
        case MI_COLLECTION:
                        
                        /*
                        // Attempt to create a collection.  If NULL is returned, it's for
                        //   one of two reason, either collection level is too deep or out
                        //   of memory.  If NULL is returned, we'll try to create a data field
                        //   instead.  If this is also NULL, it was out of memory not collection
                        //   level depth for GenerateCollection failure.  Doing this means that
                        //   a NULL returned from this function indicates out of memory so calling
                        //   functions can process accordingly.
                        */

                        if (NULL != (pMI = GenerateCollection(FALSE))) {
                                break;
                        }

        case MI_DATA:
            pMI = GenerateDataField(SelectOption(HidP_Input, HidP_Feature));
            break;

        default:
            assert(0);
            pMI = NULL;
            break;
    }
    return (pMI);
}
            
PMAIN_ITEM 
GenerateConstant(
    ULONG                ConstantSize,
    ULONG                ReportID,
    HIDP_REPORT_TYPE     ReportType
)
{
    PMAIN_ITEM pMI;

    pMI = (PMAIN_ITEM) malloc(sizeof(MAIN_ITEM));

    if (NULL != pMI) {

        pMI -> ReportType = ReportType;
        pMI -> fType = FD_CONSTANT;
        pMI -> ulReportID = ReportID;

        /*
        // NOTE: Possible improvement here...It'd be interesting to
        //       see what effect the breaking down of this constant
        //       size into multiple ReportSize fields would have but
        //       all have the same constants.  Will worry about how
        //       to do that at a future date.
        */
        
        pMI -> ulReportSize = ConstantSize;
        pMI -> ulReportCount = 1;
        pMI -> miType = MI_DATA;

        pMI -> fWrap = FALSE;
        pMI -> fNull = FALSE;
        pMI -> fPreferred = FALSE;
        pMI -> fVolatile = FALSE;
        pMI -> fBuffered = FALSE;
        pMI -> fAbsolute = FALSE;
    }
    
    return (pMI);
}
        
PMAIN_ITEM GenerateDataField(HIDP_REPORT_TYPE ReportType)
{
    PMAIN_ITEM  pMI;
    BOOL        fStatus;
    FIELD_TYPE  OptionList[4];
    ULONG       OptionListLength;
    
    /*
    // Allocate space for our main item structure.  If successful, we'll
    //  fill in those fields that are common in all data field types
    */
    
    pMI = (PMAIN_ITEM) malloc(sizeof(MAIN_ITEM));

    if (NULL != pMI) {

        /*
        // In creating a data field, there are a couple of fields which are not
        //   unique to the field being created, miType, ReportType, fType and 
        //   reportID.  We will generate those here and then call the corresponding
        //   field generation routine base on fType.
        */
        
        pMI -> miType = MI_DATA;
        pMI -> ReportType = ReportType;


        OptionListLength = 0;

        if (OPTIONS_CREATE_FIELDS) {
            OptionList[OptionListLength++] = FD_DATA;
        }

        if (OPTIONS_CREATE_ARRAYS) {
            OptionList[OptionListLength++] = FD_ARRAY;
        }

        if (OPTIONS_CREATE_BUFFER) {
            OptionList[OptionListLength++] = FD_BUFFER;
        }

        if (OPTIONS_CREATE_BUTTONS) {
            OptionList[OptionListLength++] = FD_BUTTONS;
        }

        /*
        // If there are no data types that can be create, we just leave
        */
        
        if (0 == OptionListLength) {

            free(pMI);
            return (NULL);

        }

        pMI -> fType = OptionList[SelectOption(0, OptionListLength-1)];
        
        /*
        // Get a reportID from the application collection routines...This
        */
        
        pMI -> ulReportID = GetCollectionID();

        /*
        // Determine which data routine to call...
        */

        switch (pMI -> fType) {
            case FD_DATA:
                fStatus = GenerateData(pMI);
                break;

            case FD_ARRAY:
                fStatus = GenerateArray(pMI);
                break;

            case FD_BUFFER:
                fStatus = GenerateBufferedBytes(pMI);
                break;

            case FD_BUTTONS:
                fStatus = GenerateButtons(pMI);
                break;
                
            default:
                assert(0);

        }                
                
        if (!fStatus) {

            free(pMI);
            return(NULL);

        }

       
        }
    return (pMI);
}

BOOL
GenerateData(
    IN  PMAIN_ITEM  pMI
)
{
    ULONG   AbsBoundary;
    ULONG   GoodBitOffset;
    ULONG   UsageCount;
    BOOL    CreateUsage;

    /*
    // Select the report count and report size...We need to verify that
    //   at this point that the size of the field we select will actually
    //   be alignable at some bit offset.  We'll repeat the selection process
    //   until we come up with something alignable
    */

    do {

        pMI -> ulReportSize = SelectOption(OPTIONS_REPORT_SIZE_MIN, OPTIONS_REPORT_SIZE_MAX);
        pMI -> ulReportCount = SelectOption(OPTIONS_REPORT_COUNT_MIN, OPTIONS_REPORT_COUNT_MAX);

    } while (!IsAlignmentPossible(0,
                                  pMI -> ulReportSize,
                                  pMI -> ulReportCount,
                                  &GoodBitOffset
                                  ));



    /*
    // When determining the usages that will be use for the given data field
    //   we need to base this off our report count and cannot generate
    //   more usages than report count.  In fact, we will randomly determine
    //   between 1 and ReportCount exactly how many usages we will create
    */

    UsageCount = SelectUlongNum(1, pMI -> ulReportCount);

    assert (1 <= UsageCount && UsageCount <= pMI -> ulReportCount);

    CreateUsage = GetUsages(UsageCount,
                            16,
                            TRUE,
                            &(pMI -> CommonUsagePage),
                            &(pMI -> UsageListLength),
                            &(pMI -> UsageList)
                           );

    if (!CreateUsage) {
        return (FALSE);
    }      

        /*
        // Determine the logical minimum and maximum values for this data field
        //    To do so, we need pick a number that will fit into the bits provided
        //    that are available with this data field.  2^(pMI -> ulReportSize-1)
        //    From the absolute boundary, we pick a number to be our logical minimum.
        //    However, since logical minimum must be less than logical maximum, the upper
        //    bound on the range of logical minimum is 1 less than the maximum bound.
        //    For example, if ReportSize is 8, are absolute boundary is 2^7 or 127 which
        //      means our logical min/max range is -127 to 126 and our logical maximum is.
        //      between logMin+1 and 127.
        */

        pMI -> IsLogMinSigned = (BOOL) SelectOption(FALSE, TRUE);
        assert(TRUE == pMI -> IsLogMinSigned || FALSE == pMI -> IsLogMinSigned);

        if (pMI -> IsLogMinSigned) {

            AbsBoundary = (LONG) ((1 << (pMI -> ulReportSize - 1)) - 1);

            assert ((LONG) AbsBoundary == (LONG) (pow(2, pMI -> ulReportSize-1)) - 1);

            pMI -> lLogicalMinimum = SelectLongNum(-((LONG) AbsBoundary), (LONG) AbsBoundary-1);
            pMI -> lLogicalMaximum = SelectLongNum(pMI -> lLogicalMinimum+1, (LONG) AbsBoundary);        

        }
        
        else {

            if (sizeof(ULONG)*8 == pMI -> ulReportSize) {
                AbsBoundary = ULONG_MAX;
            }
            else {
                AbsBoundary = ((1 << pMI -> ulReportSize) - 1);
            }

            assert (AbsBoundary == ( (sizeof(ULONG)*8 == pMI -> ulReportSize) ? ULONG_MAX
                                                                             : (ULONG) (pow(2, pMI -> ulReportSize) - 1)));
            pMI -> ulLogicalMinimum = SelectUlongNum(0, AbsBoundary-1);
            pMI -> ulLogicalMaximum = SelectUlongNum(pMI -> ulLogicalMinimum+1, AbsBoundary);
        }
        

        /*
        // Decide whether or not to use PhysicalMin/Max
        */

        if (SelectOption(FALSE, FALSE)) {

            /*
            // Do Physical Minimum/Maximum generation code here
            */

        }
        else {

            /*
            // Set physical max to be less than physical min to tell the item
            //   generator that no value was chosen for these fields.
            */
        
            pMI -> lPhysicalMinimum = 0;
            pMI -> lPhysicalMaximum = -1;
    
        }


        /*
        // Decide whether or not to use unit fields
        */

        if (SelectOption(FALSE, FALSE)) {

            /*
            // Do picking of Unit and UnitExp fields
            */

        }
        else {

            /*
            // Zero out the unit fields
            */

            pMI -> lUnit = 0;
            pMI -> lExponent = 0;

        }
        
        /*
        // Generate the flag fields.  Begin by setting them all initially to FALSE
        */

        /*
        // Randomize the settings of the different options.  Simply need to 
        //  randomly choose between TRUE and FALSE
        */
        
        pMI -> fWrap = (BOOL) SelectOption(FALSE, TRUE);
        pMI -> fLinear = (BOOL) SelectOption(FALSE, TRUE);
        pMI -> fNull = (BOOL) SelectOption(FALSE, TRUE);
        pMI -> fPreferred = (BOOL) SelectOption(FALSE, TRUE);
        pMI -> fVolatile = (BOOL) SelectOption(FALSE, TRUE);
        pMI -> fAbsolute = (BOOL) SelectOption(FALSE, TRUE);

        /*
        // This field will always be set to FALSE because there is a special
        //      routine for creating buffered byte data fields.
        */
        
        pMI -> fBuffered = FALSE;
        
        return (TRUE);
}

BOOL
GenerateArray(
    IN  PMAIN_ITEM  pMI
)
{
    ULONG   AbsBoundary;
    ULONG   GoodBitOffset;
    ULONG   UsageCount;
    BOOL    CreateUsage;

    /*
    // An array field is not all that different from a data field.  The difference
    //  is that it reports usage values instead of actual values in it's fields.
    //  Therefore, we can actually have more usages than the ReportCount we generate
    //    but the usages must be no bigger than can be supported by ReportSize
    //    structure.
    */

    /*
    // Here's an interesting point about arrays that I had not noticed/understood 
    //    before.  An array actually reports an Indexed value which corresponds
    //    the to LogicalMinimum/Maximum.  The indices that are returned refer to
    //    to the order in which usages are applied.  So if the following is described
    //      LogicalMinimum(0)
    //      LogicalMaximum(16)
    //      UsageMin(1)
    //      UsageMax(17) 
    //      
    //    index 0 --> Usage 1, index 1 --> usage 2
    */

    /*
    // Selecting the report count and report size for arrays is the same
    //   as selecting them for data fields.  We just need to verify that
    //   the size/count combination we select is an alignable one.
    */

    do {

        pMI -> ulReportSize = SelectOption(OPTIONS_ARRAY_SIZE_MIN, OPTIONS_ARRAY_SIZE_MAX);
        pMI -> ulReportCount = SelectOption(OPTIONS_ARRAY_COUNT_MIN, OPTIONS_ARRAY_COUNT_MAX);

    } while (!IsAlignmentPossible(0,
                                  pMI -> ulReportSize,
                                  pMI -> ulReportCount,
                                  &GoodBitOffset
                                  ));


    /*
    // The next step in creating an array is to determine the indexing values
    //  which are done through the logical minimum and logical maximum value
    //  range.  The range of index values is based on the ReportSize.  The
    //  code is duplicate of that within the data field generation.  For now,
    //  however, we will limit the number of indices to 2^16 to compensate
    //  for 16-bit usages.  We an probably relax this restriction later on but
    //  my understanding is not complete at this point.  Perhaps later...
    //  What we'll actually do is determine how many usages we will report with
    //  this array and then determine a logical minimum and then the logical
    //  maximum will be set to LogMin + UsageCount.
    */

    /*
    // The usage count that is allowed is limited by 2^16.  Theoretically, this
    //  is not so, but for now, we're making it so.
    */

    UsageCount = SelectUlongNum(OPTIONS_ARRAY_USAGES_MIN, OPTIONS_ARRAY_USAGES_MAX);

    /*
    // Next we determine how our logical minimum/maximum range will be
    //  defined (signed or unsigned), then the upper and lower boundaries for
    //  that range and then choose the lower number within that boundary.  Our
    //  usage count amount will then determine the upper boundary
    */
    
    pMI -> IsLogMinSigned = (BOOL) SelectOption(FALSE, TRUE);
    assert(TRUE == pMI -> IsLogMinSigned || FALSE == pMI -> IsLogMinSigned);

    if (pMI -> IsLogMinSigned) {

        AbsBoundary = (LONG) ((1 << (pMI -> ulReportSize - 1)) - 1);

        assert ((LONG) AbsBoundary == (LONG) (pow(2, pMI -> ulReportSize-1)) - 1);

        pMI -> lLogicalMinimum = SelectLongNum(-((LONG) AbsBoundary), (LONG) AbsBoundary-UsageCount+1);
        pMI -> lLogicalMaximum = pMI -> lLogicalMinimum + UsageCount - 1;

    }
    
    else {

        if (sizeof(ULONG)*8 == pMI -> ulReportSize) {
            AbsBoundary = ULONG_MAX;
        }
        else {
            AbsBoundary = ((1 << pMI -> ulReportSize) - 1);
        }

        assert (AbsBoundary == ( (sizeof(ULONG)*8 == pMI -> ulReportSize) ? ULONG_MAX
                                                                         : (ULONG) (pow(2, pMI -> ulReportSize) - 1)));
        pMI -> ulLogicalMinimum = SelectUlongNum(0, AbsBoundary-UsageCount+1);
        pMI -> ulLogicalMaximum = pMI -> ulLogicalMinimum + UsageCount - 1;
        
    }    

    /*
    // Now we need to generate the usages that correspond to the indices we
    //    generated above.
    */

    CreateUsage = GetUsages(UsageCount,
                            16,
                            TRUE,
                            &(pMI -> CommonUsagePage),
                            &(pMI -> UsageListLength),
                            &(pMI -> UsageList)
                           );

    if (!CreateUsage) {
        return (FALSE);
    }      

    /*
    // Decide whether or not to use PhysicalMin/Max.  Not sure if
    //    arrays can even use these fields.
    */

    if (SelectOption(FALSE, FALSE)) {

        /*
        // Do Physical Minimum/Maximum generation code here
        */

    }
    else {

        /*
        // Set physical max to be less than physical min to tell the item
        //   generator that no value was chosen for these fields.
        */
    
        pMI -> lPhysicalMinimum = 0;
        pMI -> lPhysicalMaximum = -1;

    }

    /*
    // Decide whether or not to use unit fields.  Like Physical Stuff, i'm
    //     not sure we can use unit stuff for arrays.
    */

    if (SelectOption(FALSE, FALSE)) {

        /*
        // Do picking of Unit and UnitExp fields
        */

    }
    else {

        /*
        // Zero out the unit fields
        */

        pMI -> lUnit = 0;
        pMI -> lExponent = 0;

    }
        
    /*
    // Generate the flag fields.  Begin by setting them all initially to FALSE. 
    //  TRUE only should apply to data fields.  Any other values should be
    //  ignored when dealing with arrays.  It'll be interesting though to see
    //  how the parser deals with these flags set and arrays.  However, by setting
    //  them to TRUE, we may be overstepping the bounds of the HID spec.
    */
    
    pMI -> fWrap = (BOOL) SelectOption(FALSE, TRUE );
    pMI -> fNull = (BOOL) SelectOption(FALSE, TRUE );
    pMI -> fPreferred = (BOOL) SelectOption(FALSE, TRUE);
    pMI -> fVolatile = (BOOL) SelectOption(FALSE, TRUE );
    pMI -> fAbsolute = (BOOL) SelectOption(FALSE, TRUE );

    /*
    // Again, this field should be ignored, so we'll randomize it's usage as well
    */
        
    pMI -> fBuffered = FALSE;
        
    return (TRUE);
}
   
BOOL
GenerateButtons(
    IN  PMAIN_ITEM  pMI
)
{
    BOOL    CreateUsage;

    /*
    // Select the report count and report size...For button bitmaps, the
    //  report size is always one and the report count is simply selected
    //  from the range specified by the user.  There is no need to check for
    //  alignment because something of size 1 bit can spread across more than
    //  one bit, yet alone 32.
    */

    pMI -> ulReportSize = 1;
    pMI -> ulReportCount = SelectOption(OPTIONS_BUTTONS_MIN, OPTIONS_BUTTONS_MAX);

    /*
    // The UsageCount for the button bitmaps must be equal to the report count, 
    //    since there must be a defined usage per button within the list box
    */

    CreateUsage = GetUsages(pMI -> ulReportCount,
                            16,
                            TRUE,
                            &(pMI -> CommonUsagePage),
                            &(pMI -> UsageListLength),
                            &(pMI -> UsageList)
                           );

    if (!CreateUsage) {
        return (FALSE);
    }      


    /*
    // The logical Min/MAx for these fields is also very simple to determine
    //   its simply 0 and 1.
    */

    pMI -> IsLogMinSigned = FALSE;

    pMI -> ulLogicalMinimum = 0;
    pMI -> ulLogicalMaximum = 1;

    /*
    // Will not use PhysicalMinimums/Maximums within buttons.  Might want to 
    //     try to do so at a later date.
    */

    pMI -> lPhysicalMinimum = 0;
    pMI -> lPhysicalMaximum = -1;

    pMI -> lUnit = 0;
    pMI -> lExponent = 0;
    
    /*
    // Randomly determien all the other flags.  They might have an effect on 
    //   on list box
    */
    
    pMI -> fWrap = (BOOL) SelectOption(FALSE, TRUE);
    pMI -> fLinear = (BOOL) SelectOption(FALSE, TRUE);
    pMI -> fNull = (BOOL) SelectOption(FALSE, TRUE);
    pMI -> fPreferred = (BOOL) SelectOption(FALSE, TRUE);
    pMI -> fVolatile = (BOOL) SelectOption(FALSE, TRUE);
    pMI -> fAbsolute = (BOOL) SelectOption(FALSE, TRUE);

    /*
    // This field will always be set to FALSE because there is a special
    //      routine for creating buffered byte data fields.
    */
    
    pMI -> fBuffered = FALSE;
        
    return (TRUE);
}

BOOL
GenerateBufferedBytes(
    IN  PMAIN_ITEM  pMI
)
{
    ULONG   AbsBoundary;
    ULONG   UsageCount;
    BOOL    CreateUsage;

    /*
    //  Need to only randomly select the report count since the report size for
    //      buffered bytes is always 8.  Therefore, we need not worry about
    //      alignment either.
    */

    pMI -> ulReportSize = 8;
    pMI -> ulReportCount = SelectOption(OPTIONS_BUFFER_MIN, OPTIONS_BUFFER_MAX);

    /*
    // When determining the usages that will be use for the given data field
    //   we need to base this off our report count and cannot generate
    //   more usages than report count.  In fact, we will randomly determine
    //   between 1 and ReportCount exactly how many usages we will create
    */

    UsageCount = SelectUlongNum(1, pMI -> ulReportCount);

    assert (1 <= UsageCount && UsageCount <= pMI -> ulReportCount);

    CreateUsage = GetUsages(UsageCount,
                            16,
                            TRUE,
                            &(pMI -> CommonUsagePage),
                            &(pMI -> UsageListLength),
                            &(pMI -> UsageList)
                           );

    if (!CreateUsage) {
        return (FALSE);
    }      

    /*
    // The logical minimum/maximum for a buffered bytes array corresponds to
    //  limits allowed within each of the slots.  We'll choose these just like
    //  we chose all the logical minimum/maximum's in the data fields
    */


    pMI -> IsLogMinSigned = (BOOL) SelectOption(FALSE, TRUE);
    assert(TRUE == pMI -> IsLogMinSigned || FALSE == pMI -> IsLogMinSigned);

    if (pMI -> IsLogMinSigned) {

        AbsBoundary = (LONG) ((1 << (pMI -> ulReportSize - 1)) - 1);

        assert ((LONG) AbsBoundary == (LONG) (pow(2, pMI -> ulReportSize-1)) - 1);

        pMI -> lLogicalMinimum = SelectLongNum(-((LONG) AbsBoundary), (LONG) AbsBoundary-1);
        pMI -> lLogicalMaximum = SelectLongNum(pMI -> lLogicalMinimum+1, (LONG) AbsBoundary);        

    }
    
    else {

        if (sizeof(ULONG)*8 == pMI -> ulReportSize) {
            AbsBoundary = ULONG_MAX;
        }
        else {
            AbsBoundary = ((1 << pMI -> ulReportSize) - 1);
        }

        assert (AbsBoundary == ( (sizeof(ULONG)*8 == pMI -> ulReportSize) ? ULONG_MAX
                                                                         : (ULONG) (pow(2, pMI -> ulReportSize) - 1)));
        pMI -> ulLogicalMinimum = SelectUlongNum(0, AbsBoundary-1);
        pMI -> ulLogicalMaximum = SelectUlongNum(pMI -> ulLogicalMinimum+1, AbsBoundary);
    }
    

    /*
    // Decide whether or not to use PhysicalMin/Max
    */

    if (SelectOption(FALSE, FALSE)) {

        /*
        // Do Physical Minimum/Maximum generation code here
        */

    }
    else {

        /*
        // Set physical max to be less than physical min to tell the item
        //   generator that no value was chosen for these fields.
        */
    
        pMI -> lPhysicalMinimum = 0;
        pMI -> lPhysicalMaximum = -1;

    }


    /*
    // Decide whether or not to use unit fields
    */

    if (SelectOption(FALSE, FALSE)) {

        /*
        // Do picking of Unit and UnitExp fields
        */

    }
    else {

        /*
        // Zero out the unit fields
        */

        pMI -> lUnit = 0;
        pMI -> lExponent = 0;

    }

    /*
    // Randomize the settings of the different options.  Simply need to 
    //  randomly choose between TRUE and FALSE
    */
    
    pMI -> fWrap = (BOOL) SelectOption(FALSE, TRUE);
    pMI -> fLinear = (BOOL) SelectOption(FALSE, TRUE);
    pMI -> fNull = (BOOL) SelectOption(FALSE, TRUE);
    pMI -> fPreferred = (BOOL) SelectOption(FALSE, TRUE);
    pMI -> fVolatile = (BOOL) SelectOption(FALSE, TRUE);
    pMI -> fAbsolute = (BOOL) SelectOption(FALSE, TRUE);

    /*
    // This field will always be set to FALSE because there is a special
    //      routine for creating buffered byte data fields.
    */
    
    pMI -> fBuffered = TRUE;
        
    return (TRUE);
}

PMAIN_ITEM GenerateCollection(BOOL fIsApplication)
{
    PMAIN_ITEM pMI;
    BOOL       CreateUsage;
    ULONG ulNumItems;
    ULONG ulIndex;
        static ULONG ulCollDepth = 0;

    ulCollDepth++;

    if (ulCollDepth > OPTIONS_COLL_DEPTH) {
        ulCollDepth--;
        return (NULL);
    }

    /*
    // Start off with between 1 and 10 possible items in the collections
    */
    
    ulNumItems = SelectOption(OPTIONS_COLL_ITEMS_MIN, OPTIONS_COLL_ITEMS_MAX);
    assert (ulNumItems >= OPTIONS_COLL_ITEMS_MIN && ulNumItems <= OPTIONS_COLL_ITEMS_MAX);

    /*
    // Allocate space for the main item structure and the pointers to its 
    //  composed items
    */

    pMI = (PMAIN_ITEM) malloc(sizeof(MAIN_ITEM) + ulNumItems*sizeof(PMAIN_ITEM));
    
    if (NULL != pMI) {

        pMI -> miType = MI_COLLECTION;

        /*
        // Determine the UsagePage and Usage for this collection
        */

        CreateUsage = GetUsages(1,
                                sizeof(USAGE),
                                FALSE,              // Must set to FALSE since HIDPARSE
                                                    // Currently doesn't support 
                                                    //  ExtUsages in Collections
                                &(pMI -> CommonUsagePage),                                
                                &(pMI -> UsageListLength),
                                &(pMI -> UsageList)
                               );

        if (!CreateUsage) {
            free(pMI);
            return (NULL);
        }
        
        /*
        // Determine the type of the collection if fIsApplication is false
        */

        if (!fIsApplication) {
            pMI -> cType = (COLLECTION_TYPE) SelectOption(CT_PHYSICAL, CT_LOGICAL);
        }
        else {
            pMI -> cType = CT_APPLICATION;
            OpenApplCollection();
        }

        for (ulIndex = 0; ulIndex < ulNumItems; ulIndex++) {
                         if (NULL == (pMI -> ComposedItems[ulIndex] = GenerateMainItem())) {
                                break;
                         }
        }
        pMI -> ulNumCompositeItems = ulIndex;

        if (fIsApplication) {

            CloseApplCollection();

        }
            
    }
    ulCollDepth--;
    return (pMI);
}

void FreeReportStructure(PMAIN_ITEM pMI) 
{
    ULONG ulIndex;

    if (MI_COLLECTION == pMI -> miType) {
        for (ulIndex = 0; ulIndex < pMI -> ulNumCompositeItems; ulIndex++) {
             FreeReportStructure(pMI -> ComposedItems[ulIndex]);
        }
    }
    free(pMI -> UsageList);
    free(pMI);
    return;
}

VOID __stdcall
BINGEN_FreeReportDescriptor(
    PREPORT_DESC    pRD
) 
{
    ULONG Index;

    for (Index = 0; Index < pRD -> NumberCollections; Index++) {

        FreeReportStructure(pRD -> Collections[Index]);

    }

    free( pRD );
    return;
}

VOID __stdcall
BINGEN_FreeReportBuffer(
    PUCHAR          ReportBuffer
)
{
    if (NULL != ReportBuffer)
        free(ReportBuffer);

    return;
}

BOOL 
OutputUsages(
    IN  USAGE       CommonUsagePage,
    IN  PUSAGE_LIST UsageList,
    IN  ULONG       UsageListLength
)
{
    PUSAGE_LIST  CurrUsage;
    BOOL         fStatus;
    ULONG        ExtendedUsage;
    /*
    // When generating the Usage information, we need to do the following steps:
    //  1) Generate the common usage page tag if the value is not 0.
    //  2) Output each of the usages in the list.  If the usagepage is 0 or it's
    //      equal to the CommonUsagePage, then don't output a usagePage tag.
    //  3) Otherwise, this is an extended and an extended usage must be generated
    //          An extended usage is one of the form, 
    //              USAGE (XXXX:YYYY) where XXXX is the USAGE_PAGE and
    //                                      YYYY is the USAGE
    */                                   
                                            
    CurrUsage = UsageList;
    fStatus = TRUE;
    
    if (0 != CommonUsagePage) {
        fStatus &= OutputItem( TAG_INDEX_USAGE_PAGE,
                               DetermineULongSize(CommonUsagePage),
                               CommonUsagePage
                             );
    }                        
    
    while (UsageListLength--) {

        if (CommonUsagePage != CurrUsage -> UsagePage) {

            ExtendedUsage = ((CurrUsage -> UsagePage) << 16);

            if (CurrUsage -> IsMinMax) {
                fStatus &= OutputItem (TAG_INDEX_USAGE_MIN,
                                       sizeof(ULONG),
                                       ExtendedUsage | CurrUsage -> UsageMin
                                      );

                fStatus &= OutputItem (TAG_INDEX_USAGE_MAX,
                                       sizeof(ULONG),
                                       ExtendedUsage | CurrUsage -> UsageMax
                                      );
  
            }
            else {
                fStatus &= OutputItem(  TAG_INDEX_USAGE,
                                        sizeof(ULONG),
                                        ExtendedUsage | CurrUsage -> Usage
                                     );
            }
        }
        else {

            if (CurrUsage -> IsMinMax) {
                fStatus &= OutputItem(  TAG_INDEX_USAGE_MIN,
                                        DetermineULongSize(CurrUsage -> UsageMin),
                                        CurrUsage -> UsageMin
                                     );

                fStatus &= OutputItem(  TAG_INDEX_USAGE_MAX,
                                        DetermineULongSize(CurrUsage -> UsageMax),
                                        CurrUsage -> UsageMax
                                     );

            }
            else {

                fStatus &= OutputItem(  TAG_INDEX_USAGE,
                                        DetermineULongSize(CurrUsage -> Usage),
                                        CurrUsage -> Usage
                                     );
                
            }
        }
        CurrUsage++;
    }
    return (fStatus);
}    
        
BOOL
OutputReportStructure(
    PMAIN_ITEM  pMI
)
{
    if (MI_COLLECTION == pMI -> miType) {
        return(OutputCollection(pMI));
    }
    else {
        return(OutputDataField(pMI));

    }   
}

BOOL __stdcall
BINGEN_OutputReportDescriptorToMemory(
    IN  PREPORT_DESC    pRD,
    OUT PUCHAR          *ReportBuffer,
    OUT PULONG          ReportBufferLength
)
{
    BOOL  fStatus;
    ULONG Index;

    assert (NULL != pRD);

    /*
    // Attempt to allocate memory for the report buffer.  If we can't then
    //   must fail this call
    */
    
    if (!InitializeReportBuffer()) {
        *ReportBuffer = NULL;
        *ReportBufferLength = 0;
        return (FALSE);
    }

    /*
    // Initialize the data table so that we can track the sizes of report IDs
    */

    DataTable_InitTable();
   
    /*
    //  Output each one of the collections in the structure
    */
    
    fStatus = TRUE;
    for (Index = 0; Index < pRD -> NumberCollections; Index++) {

        fStatus = OutputCollection(pRD -> Collections[Index]) && fStatus;

    }

    if (!fStatus) {

        free(g_ReportBuffer);
        *ReportBuffer = NULL;
        *ReportBufferLength = 0;

    }
    else {  

        *ReportBuffer = g_ReportBuffer;
        *ReportBufferLength = g_CurrBufferLength;

    }

    DataTable_DestroyTable();
    
    return (fStatus);
}

BOOL __stdcall
BINGEN_OutputReportDescriptorToDisk(
    IN  PREPORT_DESC    pRD,
    OUT LPCSTR          filename
)
{
    BIN_FILE outfile;
    PUCHAR   buffer;
    ULONG    bufferLength;
    BOOL     fStatus;

    /*
    // In order to write the report descriptor to disk, we'll perform
    //   two steps.
    //
    //  1) Output the report descriptor to a buffer in memory
    //  2) If this succeeds, we'll create a binary file in which to output
    //      the structure to and then we'll block write that data buffer into
    //      memory.
    */
    
    fStatus = FALSE;
    if (BINGEN_OutputReportDescriptorToMemory(pRD, &buffer, &bufferLength)) {

        /*
        // Output the report descriptor in memory to our binary file.
        //   We will use external routines to write the file to disk since
        //   in other places we may already have a descriptor in memory and
        //   also want to write that memory buffer to disk.  No sense 
        //   duplicating ourselves.  This routine will probably be located
        //   in the standard BIN generation routines.  All we need to do
        //   is open up the bin file, write the buffer, close the binfile and
        //   go 
        */

        /*
        // Open the file
        */

        fStatus = fNewBINFile(filename, &outfile);

        /*
        // Write the block of memory
        */

        if (fStatus) {

            fStatus = fBINWriteBuffer(&outfile, buffer, bufferLength);

        }
        
        /*
        // Close the file
        */

        vCloseBINFile(&outfile);
    }

    /*
    // Free the buffer that was allocated
    */
    
    if (NULL != buffer) {
        BINGEN_FreeReportBuffer(buffer);
    }
    
    return (fStatus);
}



BOOL __stdcall
BINGEN_GenerateCaps(
    IN  PREPORT_DESC    pRD,
    IN  ULONG           TLCNum,
    OUT PHIDP_CAPS      Caps
)
{
    PMAIN_ITEM  CurrCollection;
    BOOL        Status;
    
    /*
    // To generate the caps structure, we need to calculate each of the fields
    //   in the HIDP_CAPS structure using the support routines defined below
    */

    if (TLCNum > pRD -> NumberCollections) 
        return (FALSE);
        
    CurrCollection = pRD -> Collections[TLCNum-1];

    /*
    // The usage for a application collection should be not be a range
    */

    assert (!CurrCollection -> UsageList -> IsMinMax);
    
    Caps -> UsagePage = CurrCollection -> UsageList -> UsagePage;
    Caps -> Usage = CurrCollection -> UsageList -> Usage;
    
    /*
    // Calculate the report lengths
    */

    Status = CalcReportLengths(CurrCollection,
                               &(Caps -> InputReportByteLength),
                               &(Caps -> OutputReportByteLength),
                               &(Caps -> FeatureReportByteLength)
                              );

    
    /*
    // Calcluate the number of LinkCollectionNodes
    */
    
    CountLinkCollNodes(CurrCollection,
                       &(Caps -> NumberLinkCollectionNodes)
                      );

    /*
    // Calculate the number of ValueCaps and ButtonCaps for each ReportType
    */

    CountValueAndButtonCaps(CurrCollection,
                            HidP_Input,
                            &(Caps -> NumberInputValueCaps),
                            &(Caps -> NumberInputButtonCaps)
                           );


    CountValueAndButtonCaps(CurrCollection,
                            HidP_Output,
                            &(Caps -> NumberOutputValueCaps),
                            &(Caps -> NumberOutputButtonCaps)
                           );
                           
 
    CountValueAndButtonCaps(CurrCollection,
                            HidP_Feature,
                            &(Caps -> NumberFeatureValueCaps),
                            &(Caps -> NumberFeatureButtonCaps)
                           );
                           

    return (Status);
}

BOOL __stdcall
BINGEN_GenerateValueCaps(
    IN  PREPORT_DESC        pRD,
    IN  ULONG               TLCNum,
    IN  HIDP_REPORT_TYPE    ReportType,
    OUT PHIDP_VALUE_CAPS    *ValueCaps,
    OUT PUSHORT             NumValueCaps
)
/*++

Routine Description:

        This allocates space for and fills in a value caps list that
           corresponds to the report descriptor structure that is input.  A 
           caller of this routine must use BINGEN_FreeValueCaps to
           insure the use of the proper corresponding freeing routine.

Arguments:

    pRD   - Report descriptor structure from which the value caps list is to 
                be generated
    
    TLCNum - A one-based index of the top-level collection to generate the list from
             Remember a report descriptor structure can have have multiple TLCs
             where each one would be treated as a separate device by HIDCLASS and
             so there exists a unique value caps list per TLC

    ReportType - Report type for which to generate the value caps structure

    ValueCaps  - Function allocated list of value caps structures

    NumCaps - Number of value caps structures in the list

Return Value: 
    TRUE  if list creation succeeded
    FALSE otherwise - ValueCaps = NULL and NumCaps = 0 in this case

--*/
{
    USHORT                      ButtonCount;
    USHORT                      ValueCount;
    USHORT                      nFilled;
    
    /*
    // Check to insure that the TLCNumber requested is within the number
    //    of TLCs for this report descriptor
    */
    
    if (TLCNum > pRD -> NumberCollections) {
        return (FALSE);
    }

    CountValueAndButtonCaps(pRD -> Collections[TLCNum-1],
                            ReportType,
                            &ValueCount,
                            &ButtonCount
                           );

    *NumValueCaps = 0;
    *ValueCaps = (PHIDP_VALUE_CAPS) calloc(ValueCount, sizeof(HIDP_VALUE_CAPS));

    /*
    // If the memory allocation succeeds, fill in the value caps structures
    */
    
    if (NULL != *ValueCaps) {

        FillValueCaps( pRD -> Collections[TLCNum-1],
                       0,
                       ReportType,
                       *ValueCaps,
                       &nFilled
                     );

        assert (nFilled == ValueCount);

        *NumValueCaps = ValueCount;

    }

    return (NULL != *ValueCaps);
}

VOID __stdcall
BINGEN_FreeValueCaps(
    IN  PHIDP_VALUE_CAPS    ValueCaps
)
/*++

Routine Description:

        This routine frees a list of value caps that that was allocated by 
           the BINGEN_GenerateValueCaps routine since the DLL may use a
           different set of allocation routines than the application which 
           uses the DLL.

Arguments:

    ValueCaps - The list of value caps to free

Return Value: 
--*/
{
    if (NULL != ValueCaps) {
        free(ValueCaps);
    }

    return;
}

BOOL __stdcall
BINGEN_GenerateButtonCaps(
    IN  PREPORT_DESC        pRD,
    IN  ULONG               TLCNum,
    IN  HIDP_REPORT_TYPE    ReportType,
    OUT PHIDP_BUTTON_CAPS   *ButtonCaps,
    OUT PUSHORT             NumButtonCaps
)
/*++

Routine Description:

        This allocates space for and fills in a HIDP_BUTTON_CAPS list that
           corresponds to the report descriptor structure that is input.  A 
           caller of this routine must use BINGEN_FreeButtonCaps to
           insure the use of the proper corresponding freeing routine.

Arguments:

    pRD   - Report descriptor structure from which the button caps list is to 
                be generated
    
    TLCNum - A one-based index of the top-level collection to generate the list from
             Remember a report descriptor structure can have have multiple TLCs
             where each one would be treated as a separate device by HIDCLASS and
             so there exists a unique button caps list per TLC

    ReportType - Report type for which to generate the button caps structure

    ValueCaps  - Function allocated list of button caps structures

    NumCaps - Number of button caps structures in the list

Return Value: 
    TRUE  if list creation succeeded
    FALSE otherwise - ButtonCaps = NULL and NumCaps = 0 in this case

--*/
{
    USHORT                      ButtonCount;
    USHORT                      ValueCount;
    USHORT                      nFilled;
    USHORT                      CollNum;
    
    /*
    // Check to insure that the TLCNumber requested is within the number
    //    of TLCs for this report descriptor
    */
    
    if (TLCNum > pRD -> NumberCollections) {
        return (FALSE);
    }

    CountValueAndButtonCaps(pRD -> Collections[TLCNum-1],
                            ReportType,
                            &ValueCount,
                            &ButtonCount
                           );

    *NumButtonCaps = 0;
    *ButtonCaps = (PHIDP_BUTTON_CAPS) calloc(ButtonCount, sizeof(HIDP_BUTTON_CAPS));

    /*
    // If the memory allocation succeeds, fill in the button caps structures
    */
    
    if (NULL != *ButtonCaps) {

        CollNum = 0;
        FillButtonCaps(pRD -> Collections[TLCNum-1],
                       &CollNum,
                       ReportType,
                       *ButtonCaps,
                       &nFilled
                      );

        assert (nFilled == ButtonCount);

        *NumButtonCaps = ButtonCount;

    }

    return (NULL != *ButtonCaps);
}

VOID __stdcall
BINGEN_FreeButtonCaps(
    IN  PHIDP_BUTTON_CAPS   ButtonCaps
)
/*++

Routine Description:

        This routine frees a list of value caps that that was allocated by 
           the BINGEN_GenerateButtonCaps routine since the DLL may use a
           different set of allocation routines than the application which 
           uses the DLL.

Arguments:

    ButtonCaps - The list of button caps to free

Return Value: 
--*/
{
    if (NULL != ButtonCaps) {
        free(ButtonCaps);
    }

    return;
}

BOOL __stdcall
BINGEN_GenerateLinkCollectionNodes(
    IN  PREPORT_DESC                pRD,
    IN  ULONG                       TLCNum,
    OUT PHIDP_LINK_COLLECTION_NODE *Nodes,
    OUT PUSHORT                     NumNodes
)
/*++

Routine Description:

        This allocates space for and fills in a link collection node list that
           corresponds to the report descriptor structure that is input.  A 
           caller of this routine must use Bingen_FreeLinkCollectionNodes to
           insure the use of the proper corresponding freeing routine.

Arguments:

    pRD   - Report descriptor structure from which the node list is to be
                generated
    
    TLCNum - A one-based index of the top-level collection to generate the list from
             Remember a report descriptor structure can have have multiple TLCs
             where each one would be treated as a separate device by HIDCLASS and
             so there exists a unique LinkCollectionNode list per TLC

    Nodes  - Function allocated list of link collection node structures

    NumNodes - Number of link collection nodes in the list

Return Value: 
    TRUE  if list creation succeeded
    FALSE otherwise - Nodes == NULL and NumNodes == 0 in this case

--*/
{
    USHORT                      NumLC;
    USHORT                      nFilled;
    
    /*
    // Check to insure that the TLCNumber requested is within the number
    //    of TLCs for this report descriptor
    */
    
    if (TLCNum > pRD -> NumberCollections) {
        return (FALSE);
    }

    CountLinkCollNodes(pRD -> Collections[TLCNum-1],
                       &NumLC
                      );
    
    *NumNodes = 0;
    *Nodes = (PHIDP_LINK_COLLECTION_NODE) calloc(NumLC, sizeof(HIDP_LINK_COLLECTION_NODE));

    /*
    // If the memory allocation succeeds, fill in the node structure
    */
    
    if (NULL != *Nodes) {

        FillLinkNodes(pRD -> Collections[TLCNum-1],
                      *Nodes,
                      0,
                      0,
                      &nFilled
                     );

        assert (nFilled == (ULONG) NumLC);                     

        *NumNodes = NumLC;                       

    }

    return (NULL != *Nodes);
}    

VOID __stdcall
BINGEN_FreeLinkCollectionNodes(
    IN  PHIDP_LINK_COLLECTION_NODE Nodes
)
/*++

Routine Description:

        This routine frees a list of link collection nodes that was allocated
           by Bingen_GenerateLinkCollectionNodes.  There is a separate free
           routine since the DLL may use a different set of allocation routines
           than the application which uses the DLL.

Arguments:

    Nodes - The list of collection nodes to free up

Return Value: 

--*/
{
    /*
     * Make no assumptions that the node list is not NULL
     */

    if (NULL != Nodes) {
        free(Nodes);
    }
    
    return;
}

    
BOOL 
OutputCollection(PMAIN_ITEM pMI) 
{
    ULONG ulIndex;
    BOOL fStatus = TRUE;

    fStatus &= OutputUsages(pMI -> CommonUsagePage,
                            pMI -> UsageList,
                            pMI -> UsageListLength
                           );

    fStatus &= OutputItem(TAG_INDEX_COLLECTION,
                            1,
                            CT_APPLICATION == pMI -> cType ? ITEM_COLLECTION_APPLICATION :
                            CT_PHYSICAL == pMI -> cType ? ITEM_COLLECTION_PHYSICAL : 
                            ITEM_COLLECTION_LOGICAL
                            );

    for (ulIndex = 0; ulIndex < pMI -> ulNumCompositeItems; ulIndex++) {
        fStatus &= OutputReportStructure(pMI -> ComposedItems[ulIndex]);
    }
    
    /*
    // If we are generating an application collection, we need to align all
    //    data sizes, close all report IDs associated with this collection and
    //    then, output and end collection item
    */
    
        if (CT_APPLICATION == pMI -> cType) {
                fStatus &= AlignDataSizes();
        }

        fStatus &= OutputItem(TAG_INDEX_END_COLLECTION,
                              0,
                              0
                             );

        return (fStatus);
}

BOOL 
OutputDataField(PMAIN_ITEM pMI) 
{
    BOOL        fStatus = TRUE;
    DWORD       dwDataFlags;
    BYTE        bTagIndex;
    INT         GoodBitOffset;
    INT         CurrBitOffset;
    BOOL        InTable;

    /*
    // So far, the code path for outputting data items is not significantly 
    //    different between regular data fields, arrays, and buffered bytes.
    //    Should they become more independent, probably want to them them up
    //    into their own output routines
    */

    /*
    // Begin by looking up the current report size/offset for the report ID
    //   and report type.
    */
    
    InTable = DataTable_LookupReportSize(pMI -> ulReportID,
                                         pMI -> ReportType,
                                         &CurrBitOffset
                                        );

     
    CurrBitOffset &= 7;

    /*
    // Here's where the one difference exists.  A buffered byte array
    //   must be aligned on Bit 0.  Otherwise, we can find the first
    //   good offset to align it on.
    */

    if (FD_BUFFER == pMI -> fType) {

        GoodBitOffset = 0;
    }

    else {

        /*
        // Don't need the result of this operation.  We already know this
        //  field will align because we won't have gotten this far if it didn't.
        */
        
        IsAlignmentPossible(CurrBitOffset, 
                            pMI -> ulReportSize,
                            pMI -> ulReportCount,
                            &GoodBitOffset
                           );

    }

    if (CurrBitOffset != GoodBitOffset) {

        fStatus = AlignData(pMI -> ulReportID,
                            pMI -> ReportType,
                            CurrBitOffset,
                            GoodBitOffset
                           );
    }

    if (!fStatus) {
        return (FALSE);
    }

    /*
    // Output the list of usages
    */
    
    fStatus &= OutputUsages(pMI -> CommonUsagePage,
                            pMI -> UsageList,
                            pMI -> UsageListLength
                           );


    if (pMI -> ulReportID) {
        fStatus &= OutputItem(TAG_INDEX_REPORT_ID,
                              DetermineULongSize(pMI -> ulReportID),
                              pMI -> ulReportID
                             );
    }
    
    #pragma warning(disable:4761)

    fStatus &= OutputItem(TAG_INDEX_LOGICAL_MIN,
                            (pMI -> IsLogMinSigned ? DetermineLongSize(pMI -> lLogicalMinimum)
                                                   : DetermineULongSize(pMI -> ulLogicalMinimum)),
                            (pMI -> IsLogMinSigned ? (DWORD) pMI -> lLogicalMinimum
                                                   : (DWORD) pMI -> ulLogicalMinimum)
                            );

    fStatus &= OutputItem(TAG_INDEX_LOGICAL_MAX,
                            (pMI -> IsLogMinSigned ? DetermineLongSize(pMI -> lLogicalMaximum)
                                                   : DetermineULongSize(pMI -> ulLogicalMaximum)),
                            (DWORD) (pMI -> IsLogMinSigned ? pMI -> lLogicalMaximum
                                                           : pMI -> ulLogicalMaximum)                            
                           );

    #pragma warning(default:4761)

    fStatus &= OutputItem(TAG_INDEX_REPORT_SIZE,
                          DetermineULongSize(pMI -> ulReportSize),
                          pMI -> ulReportSize
                         );
    
    fStatus &= OutputItem(TAG_INDEX_REPORT_COUNT,
                            DetermineULongSize(pMI -> ulReportCount),
                            pMI -> ulReportCount
                         );
    
    dwDataFlags = CreateDataBitField(pMI);

    if (HidP_Input == pMI -> ReportType) {
        bTagIndex = TAG_INDEX_INPUT;
    }
    else if (HidP_Output == pMI -> ReportType) {
        bTagIndex = TAG_INDEX_OUTPUT;
    }
    else {
        bTagIndex = TAG_INDEX_FEATURE;
    }

    fStatus &= OutputItem(bTagIndex,
                          DetermineULongSize(dwDataFlags),
                          dwDataFlags
                         );

    DataTable_UpdateReportSize( pMI -> ulReportID, 
                                pMI -> ReportType, 
                                pMI -> ulReportCount * pMI -> ulReportSize
                              );
                            
    return (fStatus);
}    
                         

BOOL OutputConstant(PMAIN_ITEM pMI) 
{
    BOOL        fStatus = TRUE;
    DWORD       dwDataFlags;
    BYTE        bTagIndex;
    
    assert (FD_CONSTANT == pMI -> fType);

        fStatus &= OutputItem(TAG_INDEX_REPORT_SIZE,
                                                        DetermineULongSize(pMI -> ulReportSize),
                                                        pMI -> ulReportSize
                                                   );
        
        fStatus &= OutputItem(TAG_INDEX_REPORT_COUNT,
                                                1,
                                                        1
                                             );

    if (pMI -> ulReportID) {

        fStatus &= OutputItem(TAG_INDEX_REPORT_ID,
                              DetermineULongSize(pMI -> ulReportID),
                              pMI -> ulReportID
                             );
    }                             
                              
    
        dwDataFlags = ITEM_REPORT_CONSTANT;

    if (HidP_Input == pMI -> ReportType) {
        bTagIndex = TAG_INDEX_INPUT;
    }
    else if (HidP_Output == pMI -> ReportType) {
        bTagIndex = TAG_INDEX_OUTPUT;
    }
    else {
        bTagIndex = TAG_INDEX_FEATURE;
    }

    DataTable_UpdateReportSize( pMI -> ulReportID, 
                                pMI -> ReportType, 
                                pMI -> ulReportCount * pMI -> ulReportSize
                              );
                     
        fStatus &= OutputItem(bTagIndex,
                          DetermineULongSize(dwDataFlags),
                          dwDataFlags
                         );
                            
    return (fStatus);
}    

BOOL OutputItem(BYTE bItemIndex, BYTE bItemSize, DWORD dwItemValue)
{
    /*
    // This procedure takes the item information that is passed in and attempts
    //    to write it into the current ReportBuffer if it can.
    */

    /*
    // 1) Determine how much space in the buffer is needed.
    // 2) If not enough space attempt to resize buffer
    // 3) If success, copy data into buffer, return (TRUE);
    // 4) If not success, return (FALSE);
    */

    assert (0 == bItemSize || 1 == bItemSize || 2 == bItemSize || 4 == bItemSize);
    
    /*
    // Set bItemSize = 3 when size is 4 since 11 represents the value for 4 in the item's field
    //   structure
    */

    if ((g_MaxBufferLength - g_CurrBufferLength) < (ULONG) (bItemSize+1)) {

        if (!ResizeReportBuffer()) {
            return (FALSE);
        }
    }
    
    /*
    // Add the Item tag to the current report buffer and increment the current
    //   report buffer length
    */
    
    *(g_ReportBuffer + g_CurrBufferLength++) = TagValues[bItemIndex] | ((bItemSize != 4) ? bItemSize : 3);

    /*
    // Copy the relevant data in to the report buffer
    */
    
    memcpy(g_ReportBuffer + g_CurrBufferLength, &dwItemValue, bItemSize);

    g_CurrBufferLength += bItemSize;

    return (TRUE);
}

BOOL
AlignData(
    IN  ULONG            ReportID,
    IN  HIDP_REPORT_TYPE ReportType,
    IN  ULONG            CurrOffset,
    IN  ULONG            AlignOffset
)
{
    INT         PadSize;
    PMAIN_ITEM  ConstantItem;
    BOOL        Status;

    PadSize = AlignOffset - CurrOffset + (AlignOffset > CurrOffset ? 0 : 8);

    ConstantItem = GenerateConstant(PadSize, 
                                    ReportID,
                                    ReportType
                                   );

    Status = FALSE;

    if (NULL != ConstantItem) {
    
        Status = OutputConstant(ConstantItem);
        free(ConstantItem);

    }

    return (Status);
}

BOOL 
AlignDataSizes(
    VOID
)
{
        BOOL            TraverseStatus;
        BOOL            AlignStatus;
    BOOL            IsClosed;
    ULONG           DataSizes[3];
    ULONG           ReportID;
    ULONG           Index;
    

    AlignStatus = TRUE;
  
    TraverseStatus = DataTable_GetFirstReportID(&ReportID,
                                                &DataSizes[HidP_Input-HidP_Input],
                                                &DataSizes[HidP_Output-HidP_Input],
                                                &DataSizes[HidP_Feature-HidP_Input],
                                                &IsClosed
                                               );

    while (TraverseStatus) {

       
        for (Index = HidP_Input-HidP_Input; Index <= HidP_Feature-HidP_Input; Index++) {

            if (0 != (DataSizes[Index] % 8)) {

                AlignStatus &= AlignData(ReportID,
                                         Index+HidP_Input,
                                         DataSizes[Index] % 8,
                                         0
                                        );
            }
        }

        TraverseStatus = DataTable_GetNextReportID(&ReportID,
                                                   &DataSizes[HidP_Input-HidP_Input],
                                                   &DataSizes[HidP_Output-HidP_Input],
                                                   &DataSizes[HidP_Feature-HidP_Input],
                                                   &IsClosed
                                                  );
                                                   
    }

        return (AlignStatus);
}
                                
DWORD
CreateDataBitField(
    IN PMAIN_ITEM   pMI
)
{
    DWORD   dwDataFlags;
    
    dwDataFlags = ITEM_REPORT_DATA;

    dwDataFlags |= ((FD_ARRAY == pMI -> fType) ? ITEM_REPORT_ARRAY : ITEM_REPORT_VARIABLE);
    dwDataFlags |= (pMI -> fAbsolute  ? ITEM_REPORT_ABSOLUTE  : ITEM_REPORT_RELATIVE);
    dwDataFlags |= (pMI -> fWrap      ? ITEM_REPORT_WRAP      : ITEM_REPORT_NO_WRAP);
    dwDataFlags |= (pMI -> fLinear    ? ITEM_REPORT_LINEAR    : ITEM_REPORT_NONLINEAR);
    dwDataFlags |= (pMI -> fPreferred ? ITEM_REPORT_PREFERRED : ITEM_REPORT_NOT_PREFERRED);
    dwDataFlags |= (pMI -> fNull      ? ITEM_REPORT_NULL      : ITEM_REPORT_NO_NULL);
    dwDataFlags |= (pMI -> fVolatile  ? ITEM_REPORT_VOLATILE  : ITEM_REPORT_NONVOLATILE);
    dwDataFlags |= (pMI -> fBuffered  ? ITEM_REPORT_BUFFERED  : ITEM_REPORT_BITFIELD);   
             
    return (dwDataFlags);
}

BYTE DetermineLongSize(long lValue)
{
    if (lValue >= SCHAR_MIN && lValue <= SCHAR_MAX) {
        return (1);
    }
    else if (lValue >= SHRT_MIN && lValue <= SHRT_MAX) {
        return (2);
    }
    else {
        return (4);
    }
}

BYTE DetermineULongSize(ULONG ulValue)
{
    if (ulValue <= UCHAR_MAX) {
        return (1);
    }
    else if (ulValue <= USHRT_MAX) {
        return (2);
    }
    else {
        return (4);
    }
}
        
/*
// This function determines whether the current ReportSize/ReportCount combination
//   will correctly align given the BitOffset.  I like this problem a lot!
//   The current implementation will use recursion to verify that all report fields
//   will not span more than 4-bytes given the current offset.  This is more 
//   or less a brute force method.  Unfortunately, it is on the order of magnitude
//   (ReportCount) to currently determine.  I think some sort of dynamic programming
//   technique can get this down to a constant O(8).  However, N will never be all THAT
//   large so even 0(N) when N <= 32 is not bad performance.   
*/


BOOL
IsAlignmentProblem(
    IN INT      BitOffset,
    IN ULONG    ReportSize,
    IN ULONG    ReportCount
)
{

    INT         NextOffset;
    
    /*
    // Steps to do this...
    //
    //  1) Determine if given current offset and report size, will it span more
    //     than four bytes...
    //  2) If yes, return TRUE
    //  3) If no, calculate the new bit offset and loop again
    */

    NextOffset = BitOffset;
    while (ReportCount-- > 0) {
         if (ReportSize + NextOffset > 32) {
             return (TRUE);
         }
         NextOffset = (NextOffset + ReportSize) % 8;
    }
    
    return (FALSE);
}

/*
// The other interesting part to the above problem is being able to determine
//   if alignment is even possible...This is actually a relatively simple 
//   problem given we have the above function.  
*/

BOOL
IsAlignmentPossible(
    IN  INT     BitOffset,
    IN  ULONG   ReportSize,
    IN  ULONG   ReportCount,
    OUT INT     *GoodOffset
)
{
    INT NextOffset;

    /*
    // Since we are given the above function, this problem is not all that difficult...
    //    We'll simply loop through the eight different indices beginning with
    //    BitOffset and call IsAlignmentProblem for each of the given indices.  
    //    Since the goal is to minimize the number of bits used in the constant
    //    value, will begin with BitOffset, then BitOffset+1, loop back around until
    //    BitOffset-1 if necesary.  Simple eh?  
    */

    for (NextOffset = 0; NextOffset < 8; NextOffset++) {

        if (!IsAlignmentProblem((BitOffset+NextOffset) % 8,
                                ReportSize,
                                ReportCount)) {

            *GoodOffset = (BitOffset + NextOffset) % 8;
            return (TRUE);
        }
    }
    return (FALSE);
}

ULONG SelectUlongNum(ULONG ulMin, ULONG ulMax)
{
    ULONG ulRandNum;
    ULONG ulSelectRange;

    assert (ulMax >= ulMin);
    
    /*
    // If we're passed in a ulMin that equals a ulMax, just return that number since this
    //    is the only possible choice.
    */

    if (ulMin == ulMax) {
        return (ulMin);
    }
    
        ulSelectRange = ulMax - ulMin;

        if (ULONG_MAX == ulSelectRange) {
                ulRandNum = rand();
        }
        else {
                ulRandNum = rand () % (ulSelectRange+1);
        }
    return (ulRandNum + ulMin);
}

long SelectLongNum(long lMin, long lMax)
{
    ULONG ulSelectRange;
    ULONG ulSelection;

    ulSelectRange = lMax - lMin;
        assert (ulSelectRange >= 0);

        if (ULONG_MAX == ulSelectRange)
                ulSelection = rand();
        else 
                ulSelection = (rand() % (ulSelectRange+1));

    return (lMin + ulSelection);
}

VOID
OpenApplCollection(
    VOID
)
{
    ULONG   nClosedIDs;
    
    /*
    // In opening an application, we need to figure exactly how many report
    //   IDs can be used by the given collection.  Then the other structures
    //   involved must be initialized so that those report IDs that have be "allocted"
    //   can be tracked.  The value of this variable below is irrelevant if
    //   we're not using report IDs.  We'll calculate and go to save space and a 
    //   comparison
    */

    assert (0 == DataTable_CountOpenReportIDs());
    
    
    /*
    // Determine the maximum number of report IDs that can be used for this
    //   given application collection
    //
    */
    
    nClosedIDs = DataTable_CountClosedReportIDs();
    
    nMaxAvailCollIDs = nTotalAvailIDs - nClosedIDs - nApplColls;

    /*
    // That's all we need to do at this point...We may have to add some functionality
    //    later to track the current collection number.  We'll worry about that when we
    //    get to outputting collections and stuff
    */

    return;
}

VOID
CloseApplCollection(
    VOID
)
{
    BOOL    Status;
    ULONG   ReportID;

    ULONG   InputSize;
    ULONG   OutputSize;
    ULONG   FeatureSize;
    BOOL    IsClosed;
    
    
    /*
    // To close an application collection, all we have to do is loop through
    //    the open report IDs and close them all.  Remember, there must 
    //    be at least open ID.
    */

    assert (1 <= DataTable_CountOpenReportIDs());

    
    Status = DataTable_GetFirstReportID(&ReportID,
                                        &InputSize,
                                        &OutputSize,
                                        &FeatureSize,
                                        &IsClosed
                                       );

    assert (Status);
    
    while (Status) {

        if (!IsClosed) {
            DataTable_CloseReportID(ReportID);
        }

        Status = DataTable_GetNextReportID( &ReportID,
                                            &InputSize,
                                            &OutputSize,
                                            &FeatureSize,
                                            &IsClosed
                                           );

    }


    /*
    // So far, that's all that needs to be done when closing an application 
    //    collection...Again, there may be the need for added functionality
    //    somewhere down the road
    */
    
    return;
}

ULONG
GetCollectionID(
    VOID
)
{

    BOOL    CreateNewID;
    ULONG   IDNumber;
    ULONG   ReportID;
    ULONG   IDsInUse;
    BOOL    InTable;

    ULONG   InputSize;
    ULONG   OutputSize;
    ULONG   FeatureSize;
    BOOL    IsClosed;
    
    
    /* 
    // This function is to used to determine a ReportID for a given application
    //   collection when a field generator makes a request for a new report ID.
    //   It must perform the following steps.
    //
    //   1) Check to see if we are using report IDs.  If we're not, then return 
    //      0, the default report ID
    //
    //   2) If we are, we will determine whether to generate a new report ID or
    //          whether to use a currently open one.  To start with, we'll use
    //          a 50/50 determination, however, this might want to be changed in 
    //          the future to give a better distribution.  There's a good chance
    //          with deep collection that we may take up the majority of available
    //          IDs with the first application collection and leave only 1 apiece
    //          for subsequent collections.  
    //
    //   3) If using a new report ID, generate a random number between 1 and 255
    //          because report IDs are only one byte long.  If that number is currently
    //          in the table, oh well, we'll use it anyway, just don't decrement the
    //          number of available IDs then.
    //
    //   4) If using an existing ID, choose one from the open IDs stored in the data
    //         table and return it.
    //
    // Not too hard, eh?
    */

    if (!fUseReportIDs) {

        DataTable_AddReportID(0);
        return (0);
    }

    IDsInUse = DataTable_CountOpenReportIDs();

    if (0 == IDsInUse) {
        CreateNewID = TRUE;
    }
    else {
        CreateNewID = SelectOption(FALSE, (IDsInUse != nMaxAvailCollIDs));
    }

    if (CreateNewID) {

        while (1) {
        
            ReportID = SelectUlongNum(1, 255);

            InTable = DataTable_LookupReportID(ReportID,
                                              &InputSize,
                                              &OutputSize,
                                              &FeatureSize,
                                              &IsClosed
                                             );
            /*
            // If it's not in the table, we need to increment the
            //      number of IDs 
            */

            if (!InTable || (InTable && !IsClosed)) {
                break;
            }
        }
        
        DataTable_AddReportID(ReportID);
    }
    else {

        IDNumber = SelectUlongNum(1, IDsInUse);

        InTable = DataTable_GetFirstReportID(&ReportID, 
                                             &InputSize,
                                             &OutputSize,
                                             &FeatureSize,
                                             &IsClosed
                                            );

        while (1) {

            assert (InTable);

            if (!IsClosed) {
                
                if (0 == --IDNumber) {
                    break;
                }

            }

            InTable = DataTable_GetNextReportID(&ReportID, 
                                                &InputSize,
                                                &OutputSize,
                                                &FeatureSize,
                                                &IsClosed
                                               );
        } 
    }

    return (ReportID);
}    

BOOL
GetUsages(
    IN  ULONG       UsageCount,
    IN  ULONG       BitLimit,
    IN  BOOL        UseExtendedUsages,
    OUT PUSAGE      CommonUsagePage,
    OUT PULONG      UsageListLength,
    OUT PUSAGE_LIST *UsageList
)
{
    USAGE       UsageMin;
    USAGE       UsageMax;
    ULONG       UsagesGenerated;
    BOOL        AreDups;
    BOOL        UsingCommonPage;
    USAGE_LIST  CurrUsage;
    PUSAGE_LIST MasterList;    
    PUSAGE_LIST NewList;
    ULONG       MaxListLength;
    ULONG       MasterListLength;
    BOOL        Status;

    /*
    // To define our list of usages we need to do the following steps
    //    until we have defined all the necessary usages.  But first,
    //    a description of the parameters.
    //
    //  UsageCount -- The number of usages we need to come up with
    //  BitLimit   -- Any limits on the max usage value we can use do
    //                  to a small field size,  (ie. arrays report
    //                  actual usage values, if each array slot is only
    //                  seven bits, the values this function generates
    //                  cannot be more than seven bits
    //
    //  UsageList -- This is a pointer to a list allocated by this routine
    //                 which describes all the usages that have been generate
    //                  see the USAGE_LIST structure
    //
    */

    /*
    // Here's how this usage thing will be done:
    //
    //  1) Determine our max/min range for usages (1..(2^BitLimit)-1))
    //      BitLimit should never be more than 16 bits
    //
    //  2) If UsageCount is 1, we generate a simple usage (not a range)
    //  3) If UsageCount > 1, we'll determine by some algorithm whether
    //        to create a Usage range or a simple Usage
    //  4) In generating a UsagePage, two things will be done.  First, the
    //        CommonUsagePage is chosen, all other usages in the list will
    //        either use the CommonUsagePage or generate their own usage page
    //  5) Next generate a UsagePage to be used by either the range or
    //      the simple usage
    //  6) If simple Usage, pick a usage within the bounds establish in 1
    //      check to see if the UsagePage/Usage combo has already been used
    //      If so, go back to step 2
    //
    //  7) If Usage range is to be generated, determine first how big the
    //       range will be (2..UsageCount).  Generate the range.  See if any
    //       usage in this range has been generated already in this list of
    //       usages.  If not, it's a good range.  If yes, go back to step two
    //       and try again.
    //  8) We've generated one set of usages, determine how many usages were
    //          generated and decrement usage count by that amount.  If usage
    //          count is 0, we can bolt.  If not repeat step 2 until 0.
    */

    /*
    // NOTE: We may have to look into tracking Usages usage for each RepID/ReportType
    //          combo as well.  This is really becoming annoying.
    */
    
    assert (1 <= UsageCount);
    assert (sizeof(USAGE)*8 >= BitLimit && 1 < BitLimit);

    /*
    // These may get set later to deal with possible usage limits set in the user
    //      options.  We'll get this up and running first however,
    */
    
    UsageMin = (USAGE) OPTIONS_USAGE_MIN; 
    UsageMax = ((ULONG) ((1 << BitLimit)-1) < OPTIONS_USAGE_MAX ? (USAGE) ((1 << BitLimit)-1) : (USAGE) OPTIONS_USAGE_MAX);

    /*
    // Cannot have our usage range be less than our UsageCount
    */
    
    assert((ULONG) (UsageMax - UsageMin + 1) >= UsageCount);
    
    /*
    // Try to initialize the master list.  Initially start at four or UsageCount
    //  whichever is smaller.
    */

    MaxListLength = (UsageCount < 4) ? UsageCount : 4;

    MasterList = (PUSAGE_LIST) calloc(MaxListLength, sizeof(USAGE_LIST));
    MasterListLength = 0;

    if (NULL == MasterList) {

        *UsageList = NULL;
        *UsageListLength = 0;
        return (FALSE);
    }
    

    /*
    // Before generating all the usages we need, we need to create the
    //     CommonUsagePage.  
    */

    *CommonUsagePage = (USAGE) SelectUlongNum(OPTIONS_USAGEPAGE_MIN, OPTIONS_USAGEPAGE_MAX);
    UsingCommonPage = FALSE;
        
    /*
    // Loop until we have found all the usages we need
    */
    
    Status = TRUE;
    while (UsageCount > 0) {
        
        /*
        // We can only possibly create a range when the usage count is greater
        //     than one.  If 1 == UsageCount, the second parameter to 
        //     SelectOption will be false and will get false back.
        */
        
        CurrUsage.IsMinMax = SelectOption(FALSE, 1 < UsageCount);

        assert (1 == UsageCount ? !CurrUsage.IsMinMax : TRUE);

        /*
        // Select the UsagePage to use for this set of usages.  We'll use either
        //      the CommonUsagePage or an extended usage page if UseEx
        */

        if (SelectOption(FALSE, UseExtendedUsages)) {

           CurrUsage.UsagePage = (USAGE) SelectUlongNum(OPTIONS_USAGEPAGE_MIN, OPTIONS_USAGEPAGE_MAX);
        }
        else {
            CurrUsage.UsagePage = *CommonUsagePage;
            UsingCommonPage = TRUE;
        }
        
        /*
        // Now select our usages
        */

        if (CurrUsage.IsMinMax) {

            /*
            // Determine our range here
            */

            UsagesGenerated = SelectUlongNum(2, UsageCount);
            
            CurrUsage.UsageMin = (USAGE) SelectUlongNum(UsageMin, UsageMax-UsagesGenerated+1);
            CurrUsage.UsageMax = (USAGE) CurrUsage.UsageMin + (USAGE) UsagesGenerated - 1;
            
        }
        else {

            CurrUsage.Usage = (USAGE) SelectUlongNum(UsageMin, UsageMax);
            UsagesGenerated = 1;

        }

        /*
        // Now we're going to need to check for duplicate usages
        //   If there are no duplicates, then we decrement the usage count
        //   and loop again
        */

        AreDups = SearchForUsageDups(MasterList, MasterListLength, &CurrUsage);
        
        if (!AreDups) {

            UsageCount -= UsagesGenerated;

            /*
            // If we've extended the bounds of our usage list, we need
            //    to resize the darn thing.  If we fail on resizing we must
            //    break out of our loop and return FALSE
            */
            
            if (MasterListLength == MaxListLength) {

                NewList = (PUSAGE_LIST) realloc(MasterList, MaxListLength*2*sizeof(USAGE_LIST));

                if (NULL == NewList) {

                    free(MasterList);
                    MasterList = NULL;
                    MasterListLength = 0;
                    Status = FALSE;
                    break;

                }

                MaxListLength *= 2;
                MasterList = NewList;

            }
            *(MasterList+MasterListLength++) = CurrUsage;
        }
    }

    /*
    // If we don't actually use the CommonUsagePage, we may decide to clear the
    //      page or not.  In theory, even if all extended usages are used, the parse
    //      should not choke when there is a common page. If the CommonUsagePage
    //      is not 0, then usage generation routine should output that usage page
    //      first when outputting a data field.
    */

    if (!UsingCommonPage) {
        *CommonUsagePage = (SelectOption(FALSE, TRUE) ? 0 : *CommonUsagePage);
    }
    
    *UsageList = MasterList;
    *UsageListLength = MasterListLength;

    return (TRUE);
}

BOOL
SearchForUsageDups(
    IN  PUSAGE_LIST MasterList,
    IN  ULONG       MasterListLength,
    IN  PUSAGE_LIST Usage
)
{
    /*
    // To search for duplicates in the list we need to search through
    //     every USAGE_LIST structure in the list and determine if the
    //     passed in Usage overlaps.  This is relatively quite simple to 
    //     do.  
    //
    //  1) Check to see if the usage pages match.
    //  2) If no, move on.
    //  3) If yes, if Usage is a single usage see if it either falls in
    //      the range of the current structure or is equal to the usage
    //      of the current structure depending on whether the structure
    //      is a range or not.
    //
    //  4) If yes and Usage is range, need to make sure that two ranges
    //      don't overlapped or that a single usage doesn't fall within the
    //      range.
    */

    ULONG       Index;
    PUSAGE_LIST CurrUsage;
    BOOL        Status;

    Status = FALSE;

    for (CurrUsage = MasterList, Index = 0; Index < MasterListLength; Index++, CurrUsage++) {

        if (CurrUsage -> UsagePage == Usage -> UsagePage) {

            if (!Usage -> IsMinMax) {

                if (!CurrUsage -> IsMinMax) {

                    if (CurrUsage -> Usage == Usage -> Usage) {

                        Status = TRUE;
                        break;

                    }
                }

                else {

                    if (IN_USAGE_RANGE(Usage -> Usage, CurrUsage -> UsageMin, CurrUsage -> UsageMax)) {

                        Status = TRUE;
                        break;

                    }
                }
            }
            else {
            
                if (!CurrUsage -> IsMinMax) {

                    if (IN_USAGE_RANGE(CurrUsage -> Usage, Usage -> UsageMin, Usage -> UsageMax)) {

                        Status = TRUE;
                        break;

                    }
                }
                else {

                    if (IN_USAGE_RANGE(CurrUsage -> UsageMin, Usage -> UsageMin, Usage -> UsageMax) || 
                        IN_USAGE_RANGE(CurrUsage -> UsageMax, Usage -> UsageMin, Usage -> UsageMax) ||
                        IN_USAGE_RANGE(Usage -> UsageMin, CurrUsage -> UsageMin, CurrUsage -> UsageMax) ||
                        IN_USAGE_RANGE(Usage -> UsageMax, CurrUsage -> UsageMin, CurrUsage -> UsageMax)) {

                        Status = TRUE;
                        break;
                    }
                }                    
            }
        }

    }
    return (Status);
}

BOOL
InitializeReportBuffer(
    VOID
)
{
    g_ReportBuffer = (PUCHAR) malloc(BUFFER_INIT_SIZE);
    g_CurrBufferLength = 0;

    g_MaxBufferLength = ((NULL != g_ReportBuffer) ? BUFFER_INIT_SIZE : 0);
    
    return (NULL != g_ReportBuffer);
}

BOOL
ResizeReportBuffer(
    VOID
)
{
    PUCHAR  OldBuffer;

    OldBuffer = g_ReportBuffer;

    g_ReportBuffer = (PUCHAR) realloc(OldBuffer, g_MaxBufferLength+BUFFER_INCREMENT_SIZE);

    if (NULL == g_ReportBuffer) {

        g_ReportBuffer = OldBuffer;
        return (FALSE);
    }

    g_MaxBufferLength += BUFFER_INCREMENT_SIZE;
    return (TRUE);
}

VOID
CountLinkCollNodes(
    IN  PMAIN_ITEM  Collection,
    OUT PUSHORT     NumLinkCollNodes
)
{
    USHORT  LinkNodes;
    USHORT  TempNodes;
    ULONG   Index;
    PMAIN_ITEM CurrItem;

    LinkNodes = 1;

    for (Index = 0; Index < Collection -> ulNumCompositeItems; Index++) {

        CurrItem = Collection -> ComposedItems[Index];

        if (MI_COLLECTION == CurrItem -> miType) {

            CountLinkCollNodes(CurrItem,
                               &TempNodes
                              );

            LinkNodes += TempNodes;
        }
    }
    
    *NumLinkCollNodes = LinkNodes;
    return;
}
    
VOID
CountValueAndButtonCaps(
    IN  PMAIN_ITEM       Collection,
    IN  HIDP_REPORT_TYPE ReportType,
    OUT PUSHORT          NumValueCaps,
    OUT PUSHORT          NumButtonCaps
)
{
    USHORT      ValueCount;
    USHORT      ButtonCount;
    USHORT      TempValueCount;
    USHORT      TempButtonCount;
    ULONG       Index;
    ULONG       i;
    ULONG       ReportCount;
    PMAIN_ITEM  CurrItem;
    
    assert (MI_COLLECTION == Collection -> miType);

    ValueCount = 0;
    ButtonCount = 0;

    for (Index = 0; Index < Collection -> ulNumCompositeItems; Index++) {

        CurrItem = Collection -> ComposedItems[Index];
        
        if (MI_COLLECTION == CurrItem -> miType) {

            CountValueAndButtonCaps(CurrItem,
                                    ReportType,
                                    &TempValueCount,
                                    &TempButtonCount
                                   );

            ValueCount += TempValueCount;
            ButtonCount += TempButtonCount;
            

        }
        else if (ReportType == CurrItem -> ReportType) {

            switch (CurrItem -> fType) {
                case FD_ARRAY:
                case FD_BUTTONS:
                    ButtonCount += (USHORT) CurrItem -> UsageListLength;
                    break;

                case FD_BUFFER:
                case FD_DATA:
                
                    /*
                    // To correctly determine the number of value caps for a given
                    //    main item, the ReportCount of the given main item along
                    //    with the UsageList has to be examined.  We'll use 
                    //    the following algorithm for counting value caps
                    //
                    // 1) Loop through the UsageList until we hit no more usages
                    //      a) If not a range usage, add 1 to our value cap count
                    //           Decrement ReportCount by 1
                    //
                    //      b) If a range usage, add 1 to the value cap count
                    //            and decrement report count by the number of usages
                    //            in the range
                    //    
                    // 2) If there are no more usages left but the ReportCount > 0, need
                    //      to take the last usage.  If that last usage is not a range, 
                    //      we're done as that usage will actually be included with the
                    //      last value cap.  
                    //
                    //      In theory, if it is a range, however, we take the usage
                    //      maximum and assume another usage of ReportCount with that maximum.
                    //      However, that is not the HIDPARSE implementation and it won't
                    //      get fixed.  To meet the HIDPARSE implementation, we need to 
                    //      just ignore these unusaged values.  
                    //      
                    // NOTE: The above algorithm actually shows a little more detail than
                    //          is necessary for counting value caps but we this will be
                    //          the basic format once the actual structures start getting 
                    //          generated as well.
                    */
                    
                    ReportCount = CurrItem -> ulReportCount;
                    
                    for (i = 0; i < CurrItem -> UsageListLength; i++) {

                        if (CurrItem -> UsageList[i].IsMinMax) {

                            ValueCount++;
                            ReportCount -= (CurrItem -> UsageList[i].UsageMax - CurrItem -> UsageList[i].UsageMin + 1);

                        }
                        else {

                            ValueCount++;
                            ReportCount--;

                        }
                     }
                     break;
            }
        }    
    }            
    
    *NumValueCaps = ValueCount;
    *NumButtonCaps = ButtonCount;
    return;
}

BOOL
BuildReportSizes(
    IN  PMAIN_ITEM  Collection
)
{
    BOOL        Status;
    PMAIN_ITEM  CurrItem;
    ULONG       Index;
    ULONG       ReportSize;
    BOOL        CanAlign;
    ULONG       AlignOffset;
    LONG        PadSize;

    assert (MI_COLLECTION == Collection -> miType);

    Status = TRUE;
    for (Index = 0; (Index < Collection -> ulNumCompositeItems && Status); Index++) {

        CurrItem = Collection -> ComposedItems[Index];

        if (MI_COLLECTION == CurrItem -> miType) {

            Status = BuildReportSizes(CurrItem);

        }
        else {

            /*
            // Determine if we need to perform some alignment on this report
            //   item.
            */

            (VOID) DataTable_LookupReportSize(CurrItem -> ulReportID,
                                              CurrItem -> ReportType,
                                              &ReportSize
                                             );

            /*
            // Don't really care about the size, just the offset so we'll MOD by
            //   8 which is bitwise & with 7
            */

            ReportSize &= 7;

            /*
            // Call the IsAlignmentPossible function.  This should always return 
            //    TRUE but it will also determine if we need to put in some padding
            //    bits to this thing as well.
            */

            CanAlign = IsAlignmentPossible(ReportSize,
                                           CurrItem -> ulReportSize,
                                           CurrItem -> ulReportCount,
                                           &AlignOffset
                                          );

            assert (CanAlign);

            PadSize = AlignOffset - ReportSize;
 
            if (PadSize < 0) PadSize += 8;

            /*
            // PadSize should be somewhere between 0 and 7 at this point
            */
            
            assert (0 <= PadSize && 8 > PadSize);

            /*
            // Update the report size if padding of this report will need to be done
            */

            Status = DataTable_UpdateReportSize(CurrItem -> ulReportID,
                                                CurrItem -> ReportType,
                                                (ULONG) PadSize
                                               );

            
            /*
            // Then, add the actual report size to the list as well.
            */

            if (Status) {
                
                Status = DataTable_UpdateReportSize(CurrItem -> ulReportID,
                                                    CurrItem -> ReportType,
                                                    CurrItem -> ulReportSize * CurrItem -> ulReportCount
                                                   );
            }
        }
        
    }

    return (Status);
} 

BOOL
CalcReportLengths(
    IN  PMAIN_ITEM  Collection,
    OUT PUSHORT     InputReportLength,
    OUT PUSHORT     OutputReportLength,
    OUT PUSHORT     FeatureReportLength
)
{
    ULONG   InputSize;
    ULONG   OutputSize;
    ULONG   FeatureSize;
    ULONG   ReportID;
    ULONG   ByteOffset;
    BOOL    IDFound;
    BOOL    IsClosed;
    BOOL    Status;
    
    /*
    // To determine the maximum report size, we need to take in to account the
    //    following items:
    //  1) If there is no items for the given report type then the length is
    //      zero, otherwise the minimum is 2.  There can be no 1 byte buffer since
    //      if a data item exists, there is a minimum of one byte for the data value
    //      and one byte for the required report ID (even if it might be zero)
    //
    //  2) Must consider the alignment of data structures.  Therefore, this routine
    //      will take advantage of the DataTable routines that are used in
    //      generating the report descriptor and used in outputting the report 
    //      descriptor to track the current alignment situation.
    */

    /*
    // Initialize the data table and the output parameters
    */

    DataTable_InitTable();

    *InputReportLength = 0;
    *OutputReportLength = 0;
    *FeatureReportLength = 0;

    /*
    // The whole process is relatively simple.  We need to traverse all the items
    //    under the given TopLevelCollection and update the field for the given
    //    ReportID/ReportType combo if it is a data item.  If it's not a data
    //    item, we need to traverse the given collection.  This will use a recursive
    //    function to easily traverse this structure.  Once this function
    //    has completed it's task, we'll query all the ReportIDs in the datatable
    //    and look for the greatest of the reportIDs for Input/Output/Feature reports
    */

    Status = BuildReportSizes(Collection);

    if (Status) {

        /*
        // Retrieve all the ReportIDs stored in the data structure
        */

        IDFound = DataTable_GetFirstReportID(&ReportID,
                                             &InputSize,
                                             &OutputSize,
                                             &FeatureSize,
                                             &IsClosed
                                            );

        while (IDFound) {

            *InputReportLength   = InputSize > *InputReportLength ? (USHORT) InputSize : *InputReportLength;
            *OutputReportLength  = OutputSize > *OutputReportLength ? (USHORT) OutputSize : *OutputReportLength;
            *FeatureReportLength = FeatureSize > *FeatureReportLength ? (USHORT) FeatureSize : *FeatureReportLength;
            
            IDFound = DataTable_GetNextReportID(&ReportID,
                                                &InputSize,
                                                &OutputSize,
                                                &FeatureSize,
                                                &IsClosed
                                               );
        }
    }

    /*
    // The data that was retrieved is stored in bits for the report, not bytes.
    //   Now we need to look at each of the report lengths and round up to the
    //   nearest byte
    */

    ByteOffset = *InputReportLength & 7;
    *InputReportLength = (*InputReportLength >> 3) + (ByteOffset ? 1 : 0);

    ByteOffset = *OutputReportLength & 7;
    *OutputReportLength = (*OutputReportLength >> 3) + (ByteOffset ? 1 : 0);

    ByteOffset = *FeatureReportLength & 7;
    *FeatureReportLength = (*FeatureReportLength >> 3) + (ByteOffset ? 1 : 0);    
    
    /*
    // If the length that was determined to store the data is > 0, then increment
    //   the size by one to make room for the reportID.
    */
    
    if (*InputReportLength) (*InputReportLength)++;
    if (*OutputReportLength) (*OutputReportLength)++;
    if (*FeatureReportLength) (*FeatureReportLength)++;

    /*
    // Destroy the data table and return the status we received from the
    //    BuildReportSize routine
    */
    
    DataTable_DestroyTable();
    
    return (Status);
}
  
VOID
FillLinkNodes(
    IN  PMAIN_ITEM                  Collection,
    IN  PHIDP_LINK_COLLECTION_NODE  NodeList,
    IN  USHORT                      FirstNodeIndex,
    IN  USHORT                      ParentIndex,
    OUT PUSHORT                     NumFilled
)
{
    PHIDP_LINK_COLLECTION_NODE  CurrNode;
    PMAIN_ITEM                  CurrItem;
    USHORT                      NextNodeIndex;
    USHORT                      nFilled;
    ULONG                       Index;

    
    /*
    // To fill in the node structure involves the following steps
    //
    //  1) Initialize the first node in the index to the initial value
    //  2) Loop through the number of composed items in the collection
    //        and recursively call itself to fill in the nodes for each
    //        collection in the list
    //
    //  3) Update the values of the current collection based on what was
    //      filled in by the recursive call
    */

    CurrNode = NodeList;

    /*
    // Step 1: Initialization of node
    */
    
    CurrNode -> LinkUsagePage = Collection -> UsageList -> UsagePage;
    CurrNode -> LinkUsage = Collection -> UsageList -> Usage;

    CurrNode -> Parent = ParentIndex;
    CurrNode -> NumberOfChildren = 0;
    CurrNode -> NextSibling = 0;
    CurrNode -> FirstChild = 0;

    /*
    // Initialization of local variables
    */

    NextNodeIndex = 1;
    
    /*
    // Step 2: Loop through all the composed items of the current collection
    */

    for (Index = 0; Index < Collection -> ulNumCompositeItems; Index++) {

        CurrItem = Collection -> ComposedItems[Index];

        if (IS_COLLECTION(CurrItem)) {

            FillLinkNodes(  CurrItem,
                            NodeList+NextNodeIndex,
                            (USHORT) (FirstNodeIndex+NextNodeIndex),
                            FirstNodeIndex,
                            &nFilled
                         );
                                     
            /*
            // Step 3: Update the local variables based on what was found
            //          filled in by the previous call.  We need to update
            //          the following three things.  
            //          a) The next sibling of the node that just got filled in
            //          b) The first child of the current node.  
            //          c) The next node in our list
            */

            (NodeList+NextNodeIndex) -> NextSibling = CurrNode -> FirstChild;
            CurrNode -> FirstChild = NextNodeIndex+FirstNodeIndex;
            NextNodeIndex += (USHORT) nFilled;
            CurrNode -> NumberOfChildren++;

        }

    }

    *NumFilled = NextNodeIndex;
    
    return;
}

VOID
FillButtonCaps(
    IN  PMAIN_ITEM                  Collection,
    IN  PUSHORT                     LinkCollNum,
    IN  HIDP_REPORT_TYPE            ReportType,
    IN  PHIDP_BUTTON_CAPS           ButtonCapsList,
    OUT PUSHORT                     NumFilled
)
{
    PMAIN_ITEM          CurrItem;
    USHORT              nFilled;
    ULONG               Index;
    ULONG               UsageIndex;
    PHIDP_BUTTON_CAPS   CurrCaps;
    USHORT              CapsAdded;
    PUSAGE_LIST         CurrUsage;
    USHORT              CurrCollNum;
    
    /*
    // Filling the button caps is relatively easy.  For each non-collection
    //    in the collection, the
    */

    CurrCaps = ButtonCapsList;
    CapsAdded = 0;
    CurrCollNum = *LinkCollNum;
    
    for (Index = 0; Index < Collection -> ulNumCompositeItems; Index++) {

        CurrItem = Collection -> ComposedItems[Index];

        if (IS_COLLECTION(CurrItem)) {

            (*LinkCollNum)++;
            FillButtonCaps(CurrItem,
                           LinkCollNum,
                           ReportType,
                           CurrCaps,
                           &nFilled
                          );

            CapsAdded += nFilled;
            CurrCaps += nFilled;
        }

        else {

            if (CurrItem -> ReportType == ReportType && IS_BUTTON_ITEM(CurrItem)) {

                CurrUsage = CurrItem -> UsageList;
                
                for (UsageIndex = 0; UsageIndex < CurrItem -> UsageListLength; UsageIndex++, CurrUsage++, CurrCaps++) {

                    if (0 == CurrUsage -> UsagePage) {
                        CurrCaps -> UsagePage = CurrItem -> CommonUsagePage;
                    }
                    else {
                        CurrCaps -> UsagePage = CurrUsage -> UsagePage;
                    }

                    CurrCaps -> ReportID = (UCHAR) CurrItem -> ulReportID;
                    CurrCaps -> BitField = (USHORT) CreateDataBitField(CurrItem);
                    CurrCaps -> LinkCollection = CurrCollNum;
                    CurrCaps -> LinkUsage = Collection -> UsageList -> Usage;
                    CurrCaps -> LinkUsagePage = Collection -> UsageList -> UsagePage;

                    CurrCaps -> IsAbsolute = CurrItem -> fAbsolute;
                    
                    CurrCaps -> IsRange = CurrUsage -> IsMinMax;
                    CurrCaps -> IsStringRange = FALSE;
                    CurrCaps -> IsDesignatorRange = FALSE;

                    if (CurrCaps -> IsRange) {

                        CurrCaps -> Range.UsageMin = CurrUsage -> UsageMin;
                        CurrCaps -> Range.UsageMax = CurrUsage -> UsageMax;

                        CurrCaps -> Range.StringMin = 0;
                        CurrCaps -> Range.StringMax = 0;

                        CurrCaps -> Range.DesignatorMin = 0;
                        CurrCaps -> Range.DesignatorMax = 0;

                    }
                    
                    else {

                        CurrCaps -> NotRange.Usage = CurrUsage -> Usage;

                        CurrCaps -> NotRange.StringIndex = 0;

                        CurrCaps -> NotRange.DesignatorIndex = 0;
                        
                    }
                    CapsAdded++;
                }
            }
        }

    }        
    *NumFilled = CapsAdded;
    return;
}

VOID
FillValueCaps(
    IN  PMAIN_ITEM                  Collection,
    IN  USHORT                      LinkCollNum,
    IN  HIDP_REPORT_TYPE            ReportType,
    IN  PHIDP_VALUE_CAPS            ValueCapsList,
    OUT PUSHORT                     NumFilled
)
{
    PMAIN_ITEM          CurrItem;
    USHORT              nFilled;
    ULONG               Index;
    PHIDP_VALUE_CAPS    CurrCaps;
    USHORT              CapsAdded;
    ULONG               ReportCount;
    ULONG               i;
    
    CurrCaps = ValueCapsList;
    CapsAdded = 0;
    
    for (Index = 0; Index < Collection -> ulNumCompositeItems; Index++) {

        CurrItem = Collection -> ComposedItems[Index];

        if (IS_COLLECTION(CurrItem)) {

            FillValueCaps(CurrItem,
                          (USHORT) (LinkCollNum+1),
                          ReportType,
                          CurrCaps,
                          &nFilled
                         );

            LinkCollNum++;
            CapsAdded += nFilled;
            CurrCaps += nFilled;
        }

        else {

            /*
            // See note in CountValueAndButtonCaps on how the value caps structures
            //     will be determined based on the given data item
            */

            /*
            // If this item matches the report type we are filling in caps for
            //    add this item to our list of Caps structures
            */
            
            if (CurrItem -> ReportType == ReportType && IS_VALUE_ITEM(CurrItem)) {
            
                ReportCount = CurrItem -> ulReportCount;
                
                for (i = 0; i < CurrItem -> UsageListLength; i++, CurrCaps++) {

                    if (0 == CurrItem -> UsageList[i].UsagePage) {
                        CurrCaps -> UsagePage = CurrItem -> CommonUsagePage;
                    }
                    else {
                        CurrCaps -> UsagePage = CurrItem -> UsageList[i].UsagePage;
                    }

                    CurrCaps -> ReportID = (UCHAR) CurrItem -> ulReportID;
                    CurrCaps -> BitField = (USHORT) CreateDataBitField(CurrItem);
                    CurrCaps -> LinkCollection = LinkCollNum;
                    CurrCaps -> LinkUsage = Collection -> UsageList -> Usage;
                    CurrCaps -> LinkUsagePage = Collection -> UsageList -> UsagePage;
                    
                    CurrCaps -> IsRange = CurrItem -> UsageList[i].IsMinMax;
                    CurrCaps -> IsStringRange = FALSE;
                    CurrCaps -> IsDesignatorRange = FALSE;

                    CurrCaps -> IsAbsolute = CurrItem -> fAbsolute;

                    /*
                    // NOTE: Currently we must set HasNull to 0x40 instead
                    //         of one due to a bug in HIDParse
                    */
                    
                    CurrCaps -> HasNull = CurrItem -> fNull ? 0x40 : 0;

                    CurrCaps -> BitSize = (USHORT) CurrItem -> ulReportSize;

                    CurrCaps -> LogicalMin = CurrItem -> lLogicalMinimum;
                    CurrCaps -> LogicalMax = CurrItem -> lLogicalMaximum;

                    if (CurrCaps -> IsRange) {

                        CurrCaps -> Range.UsageMin = CurrItem -> UsageList[i].UsageMin;
                        CurrCaps -> Range.UsageMax = CurrItem -> UsageList[i].UsageMax;

                        CurrCaps -> Range.StringMin = 0;
                        CurrCaps -> Range.StringMax = 0;

                        CurrCaps -> Range.DesignatorMin = 0;
                        CurrCaps -> Range.DesignatorMax = 0;
                        
                        CurrCaps -> ReportCount = 1;
                        ReportCount -= (CurrCaps -> Range.UsageMax - CurrCaps -> Range.UsageMin + 1);

                    }
                    else {

                        CurrCaps -> NotRange.Usage = CurrItem -> UsageList[i].Usage;
                        CurrCaps -> NotRange.StringIndex = 0;
                        CurrCaps -> NotRange.DesignatorIndex = 0;
                        
                        CurrCaps -> ReportCount = 1;
                        ReportCount--;

                    }
                    CapsAdded++;
                }

                /*
                // If we've run out of usages but still have a values that haven't
                //    been counted yet.  In theory, iff the last usagelist value was a range
                //    then we need to add a new value caps with the usage max as 
                //    the Usage of the new caps and the ReportCount value will be
                //    be the ReportCount value for that new caps.  However, the HIDPARSE
                //    implementation doesn't do this and just leaves the previous value caps
                //    and basically the other values cannot be touched.  Since this implementation
                //    won't be fixed, we must compensate for it and do as it does.
                //
                //    If the last UsageList value was not a range, we simply need
                //      to increment the ReportCount value of the last caps structure
                //      we dealt with
                */
                
                if (ReportCount > 0) {

                    if (!CurrItem -> UsageList[i-1].IsMinMax) {

                        (CurrCaps-1) -> ReportCount += (USHORT) ReportCount;

                    }
                }
            }
        }            
    }                
        
             
    *NumFilled = CapsAdded;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by bingen.rc
//
#define ID_ACCEPT                       113
#define IDC_TAB1                        1000
#define IDC_PD_USAGES                   1100
#define IDC_USAGEPAGE_MIN               1101
#define IDC_USAGEPAGE_MAX               1102
#define IDC_USAGE_MIN                   1103
#define IDC_USAGE_MAX                   1104
#define IDC_DEFAULT_USAGES              1105
#define IDC_COLLECTION_DEPTH            1200
#define IDC_TOP_COLLECTIONS             1201
#define IDC_ITEMS_MIN                   1202
#define IDC_ITEMS_MAX                   1203
#define IDC_DEFAULT_COLLECTION          1204
#define IDC_DEFAULT_REPORT              1300
#define IDC_CREATE_BUTTONS              1301
#define IDC_CREATE_DATA_FIELDS          1302
#define IDC_CREATE_ARRAYS               1303
#define IDC_CREATE_BUFFERED_BYTES       1304
#define IDC_REPORT_SIZE_MIN             1305
#define IDC_REPORT_SIZE_MAX             1306
#define IDC_REPORT_COUNT_MIN            1307
#define IDC_REPORT_COUNT_MAX            1308
#define IDC_BUTTONS_MIN                 1309
#define IDC_BUTTONS_MAX                 1310
#define IDC_ARRAY_SIZE_MIN              1311
#define IDC_ARRAY_SIZE_MAX              1312
#define IDC_ARRAY_USAGES_MIN            1313
#define IDC_ARRAY_USAGES_MAX            1314
#define IDC_ARRAY_COUNT_MIN             1315
#define IDC_ARRAY_COUNT_MAX             1316
#define IDC_BUFFER_MIN                  1317
#define IDC_BUFFER_MAX                  1318
#define IDC_USE_REPORT_IDS              1319
#define IDC_REPORT_ID_MAX               1320
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\dll\datatbl.c ===
#define __DATATBL_C__

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>
#include <limits.h>
#include <assert.h>
#include <hidusage.h>
#include <hidsdi.h>
#include <hidpi.h>
#include <bingen.h>
#include "datatbl.h"


/*
// This file contains all the implementation details for the data size table
//    structure.  
*/

/*
// Define the maximum size for the data hash table
*/

#define DATA_TABLE_SIZE 8

/*
// Define the hashing function to be used to determine the index: 
//   Very simplistic for now...Can deal with coming up with a better
//   hash function when I have time and the appropriate references
*/

#define HASH(rid)    ((rid) % DATA_TABLE_SIZE)

/*
// Typedef the structure that is used in the hash tables chaining branches
*/

typedef struct _datachain {
    LIST_ENTRY  ListEntry;
    
    ULONG   ReportID;
    ULONG   InputSize;
    ULONG   OutputSize;
    ULONG   FeatureSize;
    BOOL    IsClosed;

} DATA_TABLE_ENTRY, *PDATA_TABLE_ENTRY;

#define FORWARD_ENTRY(Curr)     ((PDATA_TABLE_ENTRY) (Curr) -> ListEntry.Flink)
#define BACKWARD_ENTRY(Curr)    ((PDATA_TABLE_ENTRY) (Curr) -> ListEntry.Blink)

#define FREE_ENTRY(Entry) \
{ \
    assert(NULL != (Entry)); \
    free((Entry)); \
}

#define ALLOC_ENTRY()          (malloc(sizeof(DATA_TABLE_ENTRY)))

/*
// Declare the data table structure
*/

static PDATA_TABLE_ENTRY  DataSizeTable[DATA_TABLE_SIZE];

/*
// Variables to deal with traversing through the table
*/

static ULONG                TraverseIndex;
static PDATA_TABLE_ENTRY    TraverseEntry;
static BOOL                 TraverseEnd = TRUE;

static BOOL                 UseBP = FALSE;
/*
// Declare the prototypes for any local functions.
*/

BOOL
DataTable_SearchHashChain(
    IN  PDATA_TABLE_ENTRY   Chain,
    IN  ULONG               ReportID,
    OUT PDATA_TABLE_ENTRY   *Entry
);

BOOL
DataTable_SearchDataTable(
    IN  ULONG               ReportID,
    OUT PULONG              Index,
    OUT PDATA_TABLE_ENTRY   *Entry
);

PDATA_TABLE_ENTRY
DataTable_AddNewEntry(
    IN  ULONG   ReportID
);

/*
// Definitions of the publically available functions
*/

VOID
DataTable_InitTable(
    VOID
)
{
    LONG    Index;

    /*
    // Using Index as a for loop, let's make sure we don't ever overrun
    //   our for loop bounds -- catch the error now not later...In reality
    //   this check is useless since a hash table of LONG_MAX entries is
    //   ridiculous especially given this implementation (255 report IDS * 
    //   3 report types) << LONG_MAX) but it's a good habit to follow.
    */

    assert (DATA_TABLE_SIZE < LONG_MAX);

    /*
    // Simply initialize all the pointers to NULL
    */

    for (Index = 0; Index < DATA_TABLE_SIZE; Index++) {

        DataSizeTable[Index] = NULL;
    
    }

    return;
}

BOOL
DataTable_UpdateReportSize(
    IN ULONG             ReportID,
    IN HIDP_REPORT_TYPE  ReportType,
    IN ULONG             AddedSize
)
{
    PDATA_TABLE_ENTRY   CurrEntry;
    LONG                Index;
    BOOL                InTable;

    /*
    // Validate the two parameters (reportID and ReportType) using asserts
    */

    assert(256 > ReportID);
    assert(HidP_Input <= ReportType && HidP_Feature >= ReportType);
      
    /*
    // Get the index for our hash table
    */

    InTable = DataTable_SearchDataTable(ReportID,
                                        &Index,
                                        &CurrEntry
                                       );
                                        

    if (!InTable) {

        CurrEntry = DataTable_AddNewEntry(ReportID);

        if (NULL == CurrEntry) {
            return (FALSE);
        }
    }


    switch (ReportType) {
        case HidP_Input:
            CurrEntry -> InputSize += AddedSize;
            break;

        case HidP_Output:
            CurrEntry -> OutputSize += AddedSize;
            break;

        case HidP_Feature:
            CurrEntry -> FeatureSize += AddedSize;
            break;

    }
    return (TRUE);
}
    
BOOL
DataTable_UpdateAllReportSizes(
    IN ULONG            ReportID,
    IN ULONG            InputSize,
    IN ULONG            OutputSize,
    IN ULONG            FeatureSize
)
{
    BOOL    ReturnStatus;
    
    ReturnStatus = DataTable_UpdateReportSize(ReportID, HidP_Input, InputSize);

    /*
    // If we have a true returnStatus, in theory the next two calls should complete
    //   because the only time ReturnStatus would be FALSE is if the UpdateDataSize
    //   had to create a new node and couldn't due to memory considerations.
    //   Therefore, we should be able to just ignore the return value of 
    //   subsequent UpdateDataSize calls.
    */
    
    if (ReturnStatus) {
        DataTable_UpdateReportSize(ReportID, HidP_Output, OutputSize);
        DataTable_UpdateReportSize(ReportID, HidP_Feature, FeatureSize);
    }

    return (ReturnStatus);
}

BOOL
DataTable_LookupReportSize(
    IN  ULONG                ReportID,
    IN  HIDP_REPORT_TYPE     ReportType,
    OUT PULONG               ReportSize
)
{
    BOOL    ReturnStatus;

    ULONG   InputSize;
    ULONG   OutputSize;
    ULONG   FeatureSize;

    BOOL    IsClosed;

    ReturnStatus = DataTable_LookupReportID(ReportID,
                                            &InputSize,
                                            &OutputSize,
                                            &FeatureSize,
                                            &IsClosed
                                           );

    if (ReturnStatus) {
    
        switch (ReportType) {
            case HidP_Input:
                *ReportSize = InputSize;
                break;

            case HidP_Output:
                *ReportSize = OutputSize;
                break;
                
                                            
            case HidP_Feature:
                *ReportSize = FeatureSize;
                break;
                                        
            
            default:
                assert(0);

        }
    }
    else {  
        *ReportSize = 0;
    }

    return (ReturnStatus);
}

BOOL    
DataTable_LookupReportID(
    IN  ULONG           ReportID,
    OUT PULONG          InputSize,
    OUT PULONG          OutputSize,
    OUT PULONG          FeatureSize,
    OUT PBOOL           IsClosed
)    
{
    PDATA_TABLE_ENTRY   CurrEntry;
    ULONG               Index;
    BOOL                InTable;

    /*
    // Validate the two parameters (reportID and ReportType) using asserts
    */

    assert(256 > ReportID);

    InTable = DataTable_SearchDataTable(ReportID,
                                        &Index,
                                        &CurrEntry
                                       );

    if (InTable) {
        *InputSize = CurrEntry -> InputSize;
        *OutputSize = CurrEntry -> OutputSize;
        *FeatureSize = CurrEntry -> FeatureSize;
        *IsClosed = CurrEntry -> IsClosed;
    }
    
    return (InTable);
}    
    
BOOL
DataTable_AddReportID(
    IN  ULONG   ReportID
)
{
    BOOL                InTable;
    ULONG               Index;
    PDATA_TABLE_ENTRY   CurrEntry;
    
    InTable = DataTable_SearchDataTable(ReportID,
                                        &Index,
                                        &CurrEntry
                                       );

    if (InTable) {
        return (TRUE);
    }

    CurrEntry = DataTable_AddNewEntry(ReportID);

    return (NULL != CurrEntry);

}

ULONG
DataTable_CountOpenReportIDs(
    VOID
)
{
    ULONG               Index;
    ULONG               OpenCount;
    PDATA_TABLE_ENTRY   CurrEntry;
    
    OpenCount = 0;
    for (Index = 0; Index < DATA_TABLE_SIZE; Index++) {

        CurrEntry = DataSizeTable[Index];

        while (NULL != CurrEntry) {

            if (!CurrEntry -> IsClosed) {
                OpenCount++;
            }

            CurrEntry = FORWARD_ENTRY(CurrEntry);
        }
    }

    return (OpenCount);
}
    
ULONG
DataTable_CountClosedReportIDs(
    VOID
)
{
    ULONG               Index;
    ULONG               ClosedCount;
    PDATA_TABLE_ENTRY   CurrEntry;
    
    ClosedCount = 0;
    for (Index = 0; Index < DATA_TABLE_SIZE; Index++) {

        CurrEntry = DataSizeTable[Index];

        while (NULL != CurrEntry) {

            if (CurrEntry -> IsClosed) {
                ClosedCount++;
            }

            CurrEntry = FORWARD_ENTRY(CurrEntry);
        }
    }

    return (ClosedCount);
}    
        
/*
// This function assumes that the report ID is in the given table.
*/

VOID
DataTable_CloseReportID(
    IN  ULONG   ReportID
)
{
    BOOL                InTable;
    ULONG               Index;
    PDATA_TABLE_ENTRY   CurrEntry;

    UseBP = TRUE;

    InTable = DataTable_SearchDataTable(ReportID,
                                        &Index,
                                        &CurrEntry
                                       );

    UseBP = FALSE;

    assert (InTable);
    assert (NULL != CurrEntry);

    CurrEntry -> IsClosed = TRUE;

    return;
}

BOOL
DataTable_GetFirstReportID(
    OUT PULONG  ReportID,
    OUT PULONG  InputSize,
    OUT PULONG  OutputSize,
    OUT PULONG  FeatureSize,
    OUT PBOOL   IsClosed
)
{

    /*
    // Set the traversal index to the first index in the table...The first
    //   goal is to find the first non-NULL chain in the table
    */
    
    TraverseIndex = 0;
    
    while (NULL == DataSizeTable[TraverseIndex] && TraverseIndex < DATA_TABLE_SIZE) {
        TraverseIndex++;
    }

    /*
    // If the index is less than the size of the data table, then we found a valid
    //    chain.  Let's get the first entry and return the value and set traverse
    //    end to FALSE
    */
    
    if (TraverseIndex < DATA_TABLE_SIZE) {

        TraverseEntry = DataSizeTable[TraverseIndex];
        TraverseEnd   = FALSE;

        *ReportID = TraverseEntry -> ReportID;
        *InputSize = TraverseEntry -> InputSize;
        *OutputSize = TraverseEntry -> OutputSize;
        *FeatureSize = TraverseEntry -> FeatureSize;    
        *IsClosed = TraverseEntry -> IsClosed;
    }

    return (!TraverseEnd);
}

BOOL
DataTable_GetNextReportID(
    PULONG  ReportID,
    PULONG  InputSize,
    PULONG  OutputSize,
    PULONG  FeatureSize,
    PBOOL   IsClosed
)
{
    if (!TraverseEnd) {

        if (NULL == FORWARD_ENTRY(TraverseEntry)) {

            do {

                TraverseIndex++;

            } while (NULL == DataSizeTable[TraverseIndex] && TraverseIndex < DATA_TABLE_SIZE);
            
            if (TraverseIndex < DATA_TABLE_SIZE) {

                TraverseEntry = DataSizeTable[TraverseIndex];
            }
            else {
                TraverseEnd = TRUE;
            }
        }
        else {
            TraverseEntry = FORWARD_ENTRY(TraverseEntry);
        }
    }     

    *ReportID = TraverseEntry -> ReportID;
    *InputSize = TraverseEntry -> InputSize;
    *OutputSize = TraverseEntry -> OutputSize;
    *FeatureSize = TraverseEntry -> FeatureSize;    
    *IsClosed = TraverseEntry -> IsClosed;
                 
    return (!TraverseEnd);
}


VOID
DataTable_DestroyTable(
    VOID
)
{
    LONG              Index;
    PDATA_TABLE_ENTRY CurrEntry;
    PDATA_TABLE_ENTRY NextEntry;

    /*
    // Ditto the comment in Init regarding this assert but good habits are
    //    hard to break
    */

    assert (DATA_TABLE_SIZE < LONG_MAX);

    for (Index = 0; Index < DATA_TABLE_SIZE; Index++) {

        CurrEntry = DataSizeTable[Index];

        while (NULL != CurrEntry) {

            NextEntry = FORWARD_ENTRY(CurrEntry);
            FREE_ENTRY(CurrEntry);
            CurrEntry = NextEntry;

        }

        DataSizeTable[Index] = NULL;
    }
    return;
}

/*
// Local function definitions
*/

BOOL
DataTable_SearchDataTable(
    IN  ULONG               ReportID,
    OUT PULONG              Index,
    OUT PDATA_TABLE_ENTRY   *Entry
)
{
    *Index = HASH(ReportID);

    if (NULL == DataSizeTable[*Index]) {
        *Entry = NULL;
        return (FALSE);
    }
    else {

        return (DataTable_SearchHashChain(DataSizeTable[*Index],
                                          ReportID,
                                          Entry
                                         ));
    }
}
    

BOOL
DataTable_SearchHashChain(
    IN  PDATA_TABLE_ENTRY   Chain,
    IN  ULONG               ReportID,
    OUT PDATA_TABLE_ENTRY   *Entry
)
{
    BOOL              Found;

    /*
    // We'll make the assumption that chain has at least one item in it.  This
    //   is for two reasons:
    //   
    //   1) It makes the below search code much easier
    //   2) It makes sense since why would a caller pass in a NULL pointer 
    //         just to find out the chain is empty
    */
 
    assert (NULL != Chain);

    /*
    // Initalize variables and then go...
    */

    Found     = FALSE;
    *Entry    = BACKWARD_ENTRY(Chain);

    do {

        /*
        // Put in this assert to verify the union in the DATA_TABLE_ENTRY
        //     structure is correct
        */

        if (ReportID == Chain -> ReportID) {
            Found = TRUE;
            *Entry = Chain;
            break;
        }

        else if (ReportID > Chain -> ReportID) {
            break;
        }

        *Entry = Chain;
        Chain = FORWARD_ENTRY(Chain);

    } while (NULL != Chain);
    
    return (Found);
}

/*
// This function assumes that the given report ID value has already been
//   scanned and is not in the table.  If this is called and the ReportID is in
//   the table, we'll probably see problems.
*/

PDATA_TABLE_ENTRY
DataTable_AddNewEntry(
    IN ULONG    ReportID
)
{
    ULONG               Index;
    PDATA_TABLE_ENTRY   NewEntry;
    PDATA_TABLE_ENTRY   PrevEntry;
    BOOL                InTable;

    InTable = DataTable_SearchDataTable(ReportID,
                                        &Index,
                                        &PrevEntry
                                       );

    assert (!InTable);

    /*
    // If we've gotten this far, then we need to create a new entry into
    //    the list.  PrevEntry should point to the entry before where we
    //    need to add the new entry.  One of the following three conditions
    //    will exist at this point:
    //    
    //    1) Current chain is empty -- DataSizeTable[Index] == NULL
    //                                 PrevEntry == NULL
    //
    //    2) NewEntry is first element in existing chain -- DataSizeTable[Index] != NULL
    //                                                   -- PrevEntry == NULL;
    //
    //    3) NewEntry is not first element -- DataSizeTable[Index] != NULL
    //                                     -- PrevEntry != NULL 
    */

    NewEntry = ALLOC_ENTRY();

    if (NULL != NewEntry) {

        NewEntry -> ReportID = ReportID;
        NewEntry -> InputSize = 0;
        NewEntry -> OutputSize = 0;
        NewEntry -> FeatureSize = 0;

        NewEntry -> IsClosed = FALSE;

    }
        

    /*
    // The links will be set in the following order
    //   1) Update the links in the new entry
    //   2) Change the forward link in the previous entry
    //   3) Change the backward link in the following entry
    */

    /*
    // NewEntry's back link is simply CurrEntry no matter which of the
    //    above conditions
    */

    BACKWARD_ENTRY(NewEntry) = PrevEntry;

    /*
    // NewEntry's forward link is dependent on the above conditions
    */

    if (NULL != PrevEntry) {
        FORWARD_ENTRY(NewEntry) = FORWARD_ENTRY(PrevEntry);
        FORWARD_ENTRY(PrevEntry) = NewEntry;
    }
    else {
        FORWARD_ENTRY(NewEntry) = DataSizeTable[Index];
        DataSizeTable[Index] = NewEntry;
    }

    /*
    // Adjust the back link in the entry following the new entry
    */

    if (NULL != FORWARD_ENTRY(NewEntry)) {
        BACKWARD_ENTRY(FORWARD_ENTRY(NewEntry)) = NewEntry;
    }    
    
    return (NewEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\dll\item.h ===
#ifndef __ITEM_H__
#define __ITEM_H__

#define ITEM_DATA_SIZE(n) ((3 == (((n).bItemTag) & (BYTE) 0x03)) ? 4 : (((n).bItemTag) & (BYTE) 0x03))
#define ITEM_TYPE(n)  (((n).bItemTag) & (BYTE) 0x0C)
#define ITEM_TAG(n)   (((n).bItemTag) & (BYTE) 0xFC)

#define ITEM_TAG_USAGE_PAGE         0x04
#define ITEM_TAG_USAGE              0x08
#define ITEM_TAG_LOGICAL_MIN        0x14
#define ITEM_TAG_USAGE_MIN          0x18
#define ITEM_TAG_LOGICAL_MAX        0x24
#define ITEM_TAG_USAGE_MAX          0x28
#define ITEM_TAG_PHYSICAL_MIN       0x34
#define ITEM_TAG_DESIGNATOR         0x38
#define ITEM_TAG_PHYSICAL_MAX       0x44
#define ITEM_TAG_DESIGNATOR_MIN     0x48
#define ITEM_TAG_EXPONENT           0x54
#define ITEM_TAG_DESIGNATOR_MAX     0x58
#define ITEM_TAG_UNIT               0x64
#define ITEM_TAG_STRING             0x68
#define ITEM_TAG_REPORT_SIZE        0x74
#define ITEM_TAG_STRING_MIN         0x78
#define ITEM_TAG_REPORT_ID          0x84
#define ITEM_TAG_STRING_MAX         0x88
#define ITEM_TAG_REPORT_COUNT       0x94
#define ITEM_TAG_DELIMITER_CLOSE    0xA8
#define ITEM_TAG_DELIMITER_OPEN     0xA9
#define ITEM_TAG_PUSH               0xA4
#define ITEM_TAG_POP                0xB4

#define ITEM_TAG_INPUT              0x80
#define ITEM_TAG_OUTPUT             0x90
#define ITEM_TAG_COLLECTION         0xA0
#define ITEM_TAG_FEATURE            0xB0
#define ITEM_TAG_END_COLLECTION     0xC0

#define ITEM_REPORT_DATA            0x00
#define ITEM_REPORT_CONSTANT        0x01
#define ITEM_REPORT_ARRAY           0x00
#define ITEM_REPORT_VARIABLE        0x02
#define ITEM_REPORT_ABSOLUTE        0x00
#define ITEM_REPORT_RELATIVE        0x04
#define ITEM_REPORT_NO_WRAP         0x00
#define ITEM_REPORT_WRAP            0x08
#define ITEM_REPORT_LINEAR          0x00
#define ITEM_REPORT_NONLINEAR       0x10
#define ITEM_REPORT_PREFERRED       0x00
#define ITEM_REPORT_NOT_PREFERRED   0x20
#define ITEM_REPORT_NO_NULL         0x00
#define ITEM_REPORT_NULL            0x40
#define ITEM_REPORT_NONVOLATILE     0x00
#define ITEM_REPORT_VOLATILE        0x80
#define ITEM_REPORT_BUFFERED        0x100
#define ITEM_REPORT_BITFIELD        0x00

#define ITEM_COLLECTION_PHYSICAL    0x00
#define ITEM_COLLECTION_APPLICATION 0x01
#define ITEM_COLLECTION_LOGICAL     0x02

#define ITEM_MIN_USAGEPAGE          0x0000
#define ITEM_MAX_USAGEPAGE          0xFF

#define ITEM_MIN_USAGE              0x0000
#define ITEM_MAX_USAGE              0xFF

#define ITEM_MIN_REPORT_SIZE        0x0001
#define ITEM_MAX_REPORT_SIZE        0x0020

#define ITEM_MIN_REPORT_COUNT       0x0001
#define ITEM_MAX_REPORT_COUNT       0x0008

typedef struct tagReportItem {
	BYTE bItemTag;
	BYTE bItemData[4];
} ITEM, *PITEM;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\dll\local.h ===
#ifndef __LOCAL_H__
#define __LOCAL_H__

/*
// Define an index for each possible tag that is supported by generator.  
//    Keeping the order of GLOBAL, LOCAL, MAIN, OTHER is important since
//    the state tables sizes are dependent on this order.  However, they
//    are not dependent on the number of items so new GLOBAL/LOCAL items 
//    can be added without causing problems as long as the definitions 
//    that follow the indices are properly maintained.
*/

#define TAG_INDEX_USAGE_PAGE                0x00
#define TAG_INDEX_LOGICAL_MIN               0x01
#define TAG_INDEX_LOGICAL_MAX               0x02
#define TAG_INDEX_PHYSICAL_MIN              0x03
#define TAG_INDEX_PHYSICAL_MAX              0x04
#define TAG_INDEX_UNIT                      0x05
#define TAG_INDEX_EXPONENT                  0x06
#define TAG_INDEX_REPORT_SIZE               0x07
#define TAG_INDEX_REPORT_COUNT              0x08
#define TAG_INDEX_REPORT_ID                 0x09
#define TAG_INDEX_USAGE                     0x0A
#define TAG_INDEX_USAGE_MIN                 0x0B
#define TAG_INDEX_USAGE_MAX                 0x0C
#define TAG_INDEX_DESIGNATOR_INDEX          0x0D
#define TAG_INDEX_DESIGNATOR_MIN            0x0E
#define TAG_INDEX_DESIGNATOR_MAX            0x0F
#define TAG_INDEX_STRING_INDEX              0x10
#define TAG_INDEX_STRING_MIN                0x11
#define TAG_INDEX_STRING_MAX                0x12
#define TAG_INDEX_INPUT                     0x13
#define TAG_INDEX_OUTPUT                    0x14
#define TAG_INDEX_FEATURE                   0x15
#define TAG_INDEX_COLLECTION                0x16
#define TAG_INDEX_END_COLLECTION            0x17
#define TAG_INDEX_OPEN_DELIMITER            0x18
#define TAG_INDEX_CLOSE_DELIMITER           0x19
#define TAG_INDEX_PUSH                      0x1A
#define TAG_INDEX_POP                       0x1B

/*
// Definitions that are useful to files that use the above indices
*/

#define FIRST_GLOBAL_INDEX                  TAG_INDEX_USAGE_PAGE
#define LAST_GLOBAL_INDEX                   TAG_INDEX_REPORT_ID

#define FIRST_LOCAL_INDEX                   TAG_INDEX_USAGE
#define LAST_LOCAL_INDEX                    TAG_INDEX_STRING_MAX

#define FIRST_MAIN_INDEX                    TAG_INDEX_INPUT
#define LAST_MAIN_INDEX                     TAG_INDEX_END_COLLECTION


#define FIRST_OTHER_INDEX                   TAG_INDEX_OPEN_DELIMITER
#define LAST_OTHER_INDEX                    TAG_INDEX_POP

#define NUM_INDICES                         LAST_OTHER_INDEX+1

#define IS_COLLECTION(item)                 (MI_COLLECTION == (item) -> miType)

#ifndef __BINGEN_C__

    extern HINSTANCE    g_DLLInstance;

#endif

/*
// Function definitions that are local to the bingen.c file
*/

PMAIN_ITEM GenerateMainItem(void);
PMAIN_ITEM GenerateDataField(HIDP_REPORT_TYPE ReportType);
BOOL
GenerateData(
    IN  PMAIN_ITEM  pMI
);


BOOL
GenerateArray(
    IN  PMAIN_ITEM  pMI
);


BOOL
GenerateBufferedBytes(
    IN  PMAIN_ITEM  pMI
);

BOOL
GenerateButtons(
    IN  PMAIN_ITEM  pMI
);

PMAIN_ITEM GenerateCollection(BOOL IsApplication);
PMAIN_ITEM 
GenerateConstant(
    ULONG               ConstantSize,
    ULONG               ReportID,
    HIDP_REPORT_TYPE    ReportType
);

void FreeReportStructure(PMAIN_ITEM pMI);


BOOL OutputDataField(PMAIN_ITEM pMI);
BOOL OutputCollection(PMAIN_ITEM pMI);
BOOL OutputReportStructure(PMAIN_ITEM pMI);
BOOL OutputItem(BYTE bItemIndex, BYTE bItemSize, DWORD dwItemValue);

DWORD
CreateDataBitField(
    IN PMAIN_ITEM   pMI
);

BOOL 
OutputUsages(
    IN  USAGE       CommonUsagePage,
    IN  PUSAGE_LIST UsageList,
    IN  ULONG       UsageListLength
);

BOOL 
AlignDataSizes(
    VOID
);

VOID
OpenApplCollection(
    VOID
);

VOID
CloseApplCollection(
    VOID
);


ULONG
GetCollectionID(
    VOID
);

BOOL
GetUsages(
    IN  ULONG       UsageCount,
    IN  ULONG       BitLimit,
    IN  BOOL        UseExtendedUsages,
    OUT PUSAGE      CommonUsagePage,
    OUT PULONG      UsageListLength,
    OUT PUSAGE_LIST *UsageList
);

BOOL
SearchForUsageDups(
    IN  PUSAGE_LIST MasterList,
    IN  ULONG       MasterListLength,
    IN  PUSAGE_LIST Usage
);





ULONG SelectUlongNum(ULONG ulMin, ULONG ulMax);
long SelectLongNum(long lMin, long lMax);
BOOL IsTagDefinable(DWORD dwTagIndex);
BYTE DetermineLongSize(long lValue);
BYTE DetermineULongSize(ULONG ulValue);

BOOL
AlignData(
    IN  ULONG               ReportID,
    IN  HIDP_REPORT_TYPE    ReportType,
    IN  ULONG               CurrOffset,
    IN  ULONG               AlignOffset
);

BOOL
IsAlignmentPossible(
    IN  INT     BitOffset,
    IN  ULONG   ReportSize,
    IN  ULONG   ReportCount,
    OUT INT     *GoodOffset
);

BOOL
IsAlignmentProblem(
    IN INT      BitOffset,
    IN ULONG    ReportSize,
    IN ULONG    ReportCount
);

BOOL
InitializeReportBuffer(
    VOID
);

BOOL
ResizeReportBuffer(
    VOID
);

VOID
CountLinkCollNodes(
    IN  PMAIN_ITEM  Collection,
    OUT PUSHORT     NumLinkCollNodes
);

VOID
CountValueAndButtonCaps(
    IN  PMAIN_ITEM          Collection,
    IN  HIDP_REPORT_TYPE    ReportType,
    OUT PUSHORT             NumValueCaps,
    OUT PUSHORT             NumButtonCaps
);

BOOL
BuildReportSizes(
    IN  PMAIN_ITEM  Collection
);

BOOL
CalcReportLengths(
    IN  PMAIN_ITEM  Collection,
    OUT PUSHORT     InputReportLength,
    OUT PUSHORT     OutputReportLength,
    OUT PUSHORT     FeatureReportLength
);

VOID
FillLinkNodes(
    IN  PMAIN_ITEM                  Collection,
    IN  PHIDP_LINK_COLLECTION_NODE  NodeList,
    IN  USHORT                      FirstNodeIndex,
    IN  USHORT                      ParentIndex,
    OUT PUSHORT                     NumFilled
);

VOID
FillButtonCaps(
    IN  PMAIN_ITEM                  Collection,
    IN  PUSHORT                     LinkCollNum,
    IN  HIDP_REPORT_TYPE            ReportType,
    IN  PHIDP_BUTTON_CAPS           ButtonCapsList,
    OUT PUSHORT                     NumFilled
);

VOID
FillValueCaps(
    IN  PMAIN_ITEM                  Collection,
    IN  USHORT                      LinkCollNum,
    IN  HIDP_REPORT_TYPE            ReportType,
    IN  PHIDP_VALUE_CAPS            ValueCapsList,
    OUT PUSHORT                     NumFilled
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\dll\settings.c ===
#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>
#include <commctrl.h>
#include <math.h>
#include <assert.h>
#include "hidsdi.h"
#include "hidusage.h"
#include "bingen.h"
#include "settings.h"
#include "resource.h"

#define NUM_SETTINGS_PAGES  3 
#define HEX_LIMIT_16BITS    6
#define HEX_LIMIT_32BITS    10

#define OUTERROR(msg) \
{ \
    MessageBox(NULL, \
               (msg), \
               "Settings error", \
               MB_ICONEXCLAMATION | MB_OK \
              ); \
}

BOOL CALLBACK
bCollectionOptionsProc(
    HWND    hDlg,
    UINT    mMsg,
    WPARAM  wParam,
    LPARAM  LParam
);

BOOL CALLBACK
bUsageOptionsProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  LParam
);

BOOL CALLBACK
bReportOptionsProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  LParam
);

INT CALLBACK 
iDialogCallProc(
    HWND             hWnd,
    UINT             uMsg,
    LPPROPSHEETPAGE  ppsp
);

INT CALLBACK
iSettingsDlgProc(
    HWND    hwndDlg,
    UINT    uMsg,
    LPARAM  lParam
);

VOID
InitPropertySheet(
    PROPSHEETHEADER  *ppsh,
    HANDLE           hInst
);

VOID
InitPropertyPages(
    PROPSHEETPAGE  psp[],    
    HINSTANCE      hInstance
);

VOID
InitPropertyPage(
    PROPSHEETPAGE   *ppsp,
    HINSTANCE       hInstance,
    PCHAR           pszTemplate,
    DLGPROC         pfnDlgProc,
    LPFNPSPCALLBACK pfnDlgCallback
);
BOOL
SetDlgItemIntHex(
    HWND    hDlg,
    INT     nIDDlgItem,
    UINT    uValue,
    INT     nBytes
);

UINT
GetDlgItemIntHex(
    HWND    hDlg,
    INT     nIDDlgItem,
    BOOL    *lpTranslated
);

struct { 

    PCHAR           pszTemplate;
    DLGPROC         pfnDlgProc;
    LPFNPSPCALLBACK pfnDlgCallback;

} PageInfo[NUM_SETTINGS_PAGES] = { 
                                   "IDD_COLLECTION_OPTIONS", 
                                   bCollectionOptionsProc, 
                                   iDialogCallProc,
                                   "IDD_USAGE_OPTIONS",     
                                   bUsageOptionsProc,      
                                   iDialogCallProc,
                                   "IDD_REPORT_OPTIONS",     
                                   bReportOptionsProc,     
                                   iDialogCallProc 
                                 };

BOOL fCollectionDefault = TRUE;

COLLECTION_OPTIONS DefaultCollection = { 1, 1, 1, 10, 4, FALSE };

BOOL fUsageDefault = TRUE;
BOOL fUsagePredefined;

USAGE_OPTIONS DefaultUsage = { 0x01, 0xFFFF, 0x01, 0xFFFF };
USAGE_OPTIONS PredefinedUsage = { 0x00, 0x05, 0x00, 0x07 };

BOOL fReportDefault = TRUE;

REPORT_OPTIONS DefaultReport = { TRUE,  TRUE,  TRUE,  TRUE,
                                 0x02,  0x20,  0x01,  0x20,
                                 0x02,  0x20,  0x01,  0x20,
                                 0x01,  0xFF,  0x01,  0x10,
                                 0x02,  0xFF
                               };

BOOL fFirstSet = TRUE;

COLLECTION_OPTIONS ActualCollection;
COLLECTION_OPTIONS InputCollection;

USAGE_OPTIONS ActualUsage;
USAGE_OPTIONS InputUsage;

REPORT_OPTIONS ActualReport;
REPORT_OPTIONS InputReport;

BOOL fOptionsSet;

PROPSHEETPAGE   pages[NUM_SETTINGS_PAGES];

extern HANDLE g_DLLInstance;

BOOL __stdcall
BINGEN_SetOptions(
    VOID
)
{
    PROPSHEETHEADER psh;
    
    if (fFirstSet) {

        ActualCollection = DefaultCollection;
        ActualUsage = DefaultUsage;
        ActualReport = DefaultReport;

        InputCollection = ActualCollection;
        InputUsage = ActualUsage;
        InputReport = ActualReport;

        fFirstSet = FALSE;
    }

    /*
    // Initialize the property sheet data structure
    */
    
    InitCommonControls();

    InitPropertySheet(&psh, g_DLLInstance);

  
    /*
    // Call PropertySheet to get the values. Upon return fOptionsSet will be
    //   set to TRUE or FALSE to indicate that new options were set.
    */
                                                                              
    fOptionsSet = PropertySheet(&psh);
    {
        DWORD ErrorCode;


        ErrorCode = GetLastError();

    }

    if (fOptionsSet) {

        if (fCollectionDefault) {

            ActualCollection = DefaultCollection;
        }
        else {

            ActualCollection = InputCollection;

        }

        if (fUsageDefault) {

            ActualUsage = DefaultUsage;

        }
        else if (fUsagePredefined) {

            ActualUsage = PredefinedUsage;

        } else {

            ActualUsage = InputUsage;
        }

        if (fReportDefault) {
            ActualReport = DefaultReport;
        }
        else { 
            ActualReport = InputReport;
        }
        return (fOptionsSet);

    }
    return (FALSE);
}

VOID __stdcall
BINGEN_GetDefaultOptions(
    OUT PGENERATE_OPTIONS   options
)
{
    options -> copts = DefaultCollection;
    options -> uopts = DefaultUsage;
    options -> ropts = DefaultReport;

    return;
}

VOID __stdcall
BINGEN_GetOptions(
    OUT  PGENERATE_OPTIONS   options
)
{
    options -> copts = ActualCollection;
    options -> uopts = ActualUsage;
    options -> ropts = ActualReport;

    return;
}

VOID
InitPropertySheet(
    PROPSHEETHEADER  *ppsh,
    HANDLE           hInst
)
{
    InitPropertyPages(pages, hInst);

    ppsh -> dwSize = sizeof(PROPSHEETHEADER);
    ppsh -> dwFlags = PSH_NOAPPLYNOW | PSH_PROPSHEETPAGE | PSH_USECALLBACK;
    ppsh -> hwndParent = NULL;
    ppsh -> hInstance = hInst;
    ppsh -> pszCaption = "BinGen Settings";
    ppsh -> nPages = NUM_SETTINGS_PAGES;
    ppsh -> nStartPage = 0;
    ppsh -> ppsp = pages;
    ppsh -> pfnCallback = iSettingsDlgProc;

    return;
}

VOID
InitPropertyPages(
    PROPSHEETPAGE  psp[],    
    HINSTANCE      hInstance
)
{
    UINT uiIndex;

    for (uiIndex = 0; uiIndex < NUM_SETTINGS_PAGES; uiIndex++) {

         InitPropertyPage(&psp[uiIndex], 
                          hInstance,
                          PageInfo[uiIndex].pszTemplate,
                          PageInfo[uiIndex].pfnDlgProc,
                          PageInfo[uiIndex].pfnDlgCallback
                         );

    }
    return;
}

VOID
InitPropertyPage(
    PROPSHEETPAGE   *ppsp,
    HINSTANCE       hInstance,
    PCHAR           pszTemplate,
    DLGPROC         pfnDlgProc,
    LPFNPSPCALLBACK pfnDlgCallback
)
{
    memset(ppsp, 0x00, sizeof(PROPSHEETPAGE));

    ppsp -> dwSize = sizeof(PROPSHEETPAGE);
    ppsp -> dwFlags =  PSP_USECALLBACK;
    ppsp -> hInstance = hInstance;
    ppsp -> pszTemplate = pszTemplate;
    ppsp -> pfnDlgProc = pfnDlgProc;
    ppsp -> pfnCallback =  pfnDlgCallback;

    return;
}

INT CALLBACK 
iDialogCallProc(
    HWND             hWnd,
    UINT             uMsg,
    LPPROPSHEETPAGE  ppsp
)
{
    switch (uMsg) {

        case PSPCB_CREATE:
            return (TRUE);
            break;

         case PSPCB_RELEASE:
             return (TRUE);
    }
    return (0);
}

INT CALLBACK
iSettingsDlgProc(
    HWND    hwndDlg,
    UINT    uMsg,
    LPARAM  lParam
)
{
    switch (uMsg) {
    }
    return (0);
}

BOOL CALLBACK
bCollectionOptionsProc(
    HWND    hDlg,
    UINT    mMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LPNMHDR pnmh;
 
    switch (mMsg) {

        case WM_INITDIALOG:
                        
            /*
            // Limit the size of the text boxes to two characters
            */
            
            SendDlgItemMessage(hDlg, IDC_COLLECTION_DEPTH, EM_SETLIMITTEXT, (WPARAM) 2, 0);
            SendDlgItemMessage(hDlg, IDC_TOP_COLLECTIONS, EM_SETLIMITTEXT, (WPARAM) 2, 0);                  
            SendDlgItemMessage(hDlg, IDC_ITEMS_MIN, EM_SETLIMITTEXT, (WPARAM) 2, 0);
            SendDlgItemMessage(hDlg, IDC_ITEMS_MAX, EM_SETLIMITTEXT, (WPARAM) 2, 0);                        

            CheckDlgButton(hDlg, IDC_USE_REPORT_IDS, InputCollection.fUseReportIDs);

            SendDlgItemMessage(hDlg, IDC_REPORT_ID_MAX, EM_SETLIMITTEXT, 3, 0);

            SetDlgItemInt(hDlg, IDC_COLLECTION_DEPTH, InputCollection.ulMaxCollectionDepth, FALSE);
            SetDlgItemInt(hDlg, IDC_TOP_COLLECTIONS, InputCollection.ulTopLevelCollections, FALSE);
            SetDlgItemInt(hDlg, IDC_ITEMS_MIN, InputCollection.ulMinCollectionItems, FALSE);
            SetDlgItemInt(hDlg, IDC_ITEMS_MAX, InputCollection.ulMaxCollectionItems, FALSE);
            SetDlgItemInt(hDlg, IDC_REPORT_ID_MAX, InputCollection.ulMaxReportIDs, FALSE);          
 
            /*
            // Switch state of default button because we'll send a message to the
            //   the dialog box that the button has been clicked which will put it
            //   back in it's correct state.
            */

            fCollectionDefault = !fCollectionDefault;

            SendMessage(hDlg, WM_COMMAND, (BN_CLICKED << 16) | IDC_DEFAULT_COLLECTION, 0);
            return (TRUE);

        case WM_COMMAND:         
            switch (HIWORD(wParam)) {

                case BN_CLICKED:
                    switch (LOWORD(wParam)) {
                        case IDC_DEFAULT_COLLECTION:
                            fCollectionDefault = !fCollectionDefault;
                            CheckDlgButton(hDlg, IDC_DEFAULT_COLLECTION, fCollectionDefault);

                            EnableWindow(GetDlgItem(hDlg, IDC_REPORT_ID_MAX), !fCollectionDefault && InputCollection.fUseReportIDs);
                            EnableWindow(GetDlgItem(hDlg, IDC_USE_REPORT_IDS), !fCollectionDefault);

                            EnableWindow(GetDlgItem(hDlg, IDC_COLLECTION_DEPTH), !fCollectionDefault);

                            EnableWindow(GetDlgItem(hDlg, IDC_TOP_COLLECTIONS), !fCollectionDefault);
                            EnableWindow(GetDlgItem(hDlg, IDC_ITEMS_MIN), !fCollectionDefault);

                            EnableWindow(GetDlgItem(hDlg, IDC_ITEMS_MAX), !fCollectionDefault);

                            break;

                        case IDC_USE_REPORT_IDS:
                            InputCollection.fUseReportIDs = !InputCollection.fUseReportIDs;
                            CheckDlgButton(hDlg, IDC_USE_REPORT_IDS, InputCollection.fUseReportIDs);
                            EnableWindow(GetDlgItem(hDlg, IDC_REPORT_ID_MAX), InputCollection.fUseReportIDs);
                            break;

                        default:
                            assert(0);

                    }
            }
            return (TRUE);

        case WM_NOTIFY:
            pnmh = (LPNMHDR) lParam;

            switch (pnmh -> code) {

                case PSN_KILLACTIVE:
                            
                    /*
                    // On changing focus, check the values of the field that have been entered
                    */
                    
                    InputCollection.ulMaxCollectionDepth = GetDlgItemInt(hDlg, IDC_COLLECTION_DEPTH, NULL, FALSE);
                    InputCollection.ulTopLevelCollections = GetDlgItemInt(hDlg, IDC_TOP_COLLECTIONS, NULL, FALSE);
                    InputCollection.ulMinCollectionItems = GetDlgItemInt(hDlg, IDC_ITEMS_MIN, NULL, FALSE);
                    InputCollection.ulMaxCollectionItems = GetDlgItemInt(hDlg, IDC_ITEMS_MAX, NULL, FALSE);

                    /*
                    // If any of the fields are 0 and we are not using the defaults, generate
                    //    a warning.
                    */

                    if ((0 == InputCollection.ulMaxCollectionDepth ||
                            0 == InputCollection.ulTopLevelCollections ||
                            0 == InputCollection.ulMinCollectionItems  ||
                            0 == InputCollection.ulMaxCollectionItems) && (!fCollectionDefault)) {

                        OUTERROR("One or more data fields are in error");

                        SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);
                    }

                    else {
                        SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
                    }
             }
             return (TRUE);
    }
    return (FALSE);
}

BOOL CALLBACK
bUsageOptionsProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LPNMHDR pnmh;
    BOOL fTranslated;
    BOOL fError = FALSE;

    switch (uMsg) {

        case WM_INITDIALOG:
  
            /*
            // Limit the size of the text boxes to two characters
            */

            CheckDlgButton(hDlg, IDC_PD_USAGES, fUsagePredefined);

            SendDlgItemMessage(hDlg, IDC_USAGEPAGE_MIN, EM_SETLIMITTEXT, (WPARAM) HEX_LIMIT_16BITS, 0);
            SendDlgItemMessage(hDlg, IDC_USAGEPAGE_MAX, EM_SETLIMITTEXT, (WPARAM) HEX_LIMIT_16BITS, 0);                     
            SendDlgItemMessage(hDlg, IDC_USAGE_MIN, EM_SETLIMITTEXT, (WPARAM) HEX_LIMIT_16BITS, 0);
            SendDlgItemMessage(hDlg, IDC_USAGE_MAX, EM_SETLIMITTEXT, (WPARAM) HEX_LIMIT_16BITS, 0);                 

            SetDlgItemIntHex(hDlg, IDC_USAGEPAGE_MIN, InputUsage.ulMinUsagePage, 2);
            SetDlgItemIntHex(hDlg, IDC_USAGEPAGE_MAX, InputUsage.ulMaxUsagePage, 2);

            SetDlgItemIntHex(hDlg, IDC_USAGE_MIN, InputUsage.ulMinUsage, 2);
            SetDlgItemIntHex(hDlg, IDC_USAGE_MAX, InputUsage.ulMaxUsage, 2);

            /*
            // Switch state of default button because we'll send a message to the
            //   the dialog box that the button has been clicked which will put it
            //   back in it's correct state.
            */

            fUsageDefault = !fUsageDefault;
            SendMessage(hDlg, WM_COMMAND, (BN_CLICKED << 16) | IDC_DEFAULT_USAGES, 0);
            return (TRUE);           

        case WM_COMMAND:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    switch (LOWORD(wParam)) {
                        case IDC_DEFAULT_USAGES:
                            fUsageDefault = !fUsageDefault;

                            CheckDlgButton(hDlg, IDC_DEFAULT_USAGES, fUsageDefault);
  
                            EnableWindow(GetDlgItem(hDlg, IDC_PD_USAGES), !fUsageDefault);
                            EnableWindow(GetDlgItem(hDlg, IDC_USAGEPAGE_MIN), !fUsageDefault && !fUsagePredefined);
                            EnableWindow(GetDlgItem(hDlg, IDC_USAGEPAGE_MAX), !fUsageDefault && !fUsagePredefined);
                            EnableWindow(GetDlgItem(hDlg, IDC_USAGE_MIN), !fUsageDefault && !fUsagePredefined);
                            EnableWindow(GetDlgItem(hDlg, IDC_USAGE_MAX), !fUsageDefault && !fUsagePredefined);
                            break;

                        case IDC_PD_USAGES:
                            fUsagePredefined = !fUsagePredefined;
                            CheckDlgButton(hDlg, IDC_PD_USAGES, fUsagePredefined);
 
                            EnableWindow(GetDlgItem(hDlg, IDC_USAGEPAGE_MIN), !fUsagePredefined);
                            EnableWindow(GetDlgItem(hDlg, IDC_USAGEPAGE_MAX), !fUsagePredefined);
                            EnableWindow(GetDlgItem(hDlg, IDC_USAGE_MIN), !fUsagePredefined);
                            EnableWindow(GetDlgItem(hDlg, IDC_USAGE_MAX), !fUsagePredefined);
                            break;

                        default:
                            assert (0);
                    }
            }
            return (TRUE);
           
        case WM_NOTIFY:
            pnmh = (LPNMHDR) lParam;
            switch (pnmh -> code) {
                case PSN_KILLACTIVE:

                    /*
                    // On changing focus, check the values of the field that have been entered
                    */

                    InputUsage.ulMinUsagePage = GetDlgItemIntHex(hDlg, IDC_USAGEPAGE_MIN, &fTranslated);
                    fError = fError || !fTranslated;
                    
                    InputUsage.ulMaxUsagePage = GetDlgItemIntHex(hDlg, IDC_USAGEPAGE_MAX, &fTranslated);
                    fError = fError || !fTranslated;

                    InputUsage.ulMinUsage = GetDlgItemIntHex(hDlg, IDC_USAGE_MIN, &fTranslated);
                    fError = fError || !fTranslated;

                    InputUsage.ulMaxUsage = GetDlgItemIntHex(hDlg, IDC_USAGE_MAX, &fTranslated);
                    fError = fError || !fTranslated;
                                        
                                        
                    /*
                    // If any of the fields are 0 and we are not using the defaults, generate
                    //    a warning.
                    */
  
                    fError = fError || (InputUsage.ulMinUsagePage > InputUsage.ulMaxUsagePage ||
                                        InputUsage.ulMinUsage > InputUsage.ulMaxUsage);
  
                    if (fError) {
                                OUTERROR("One or more data fields are in error");
                                SetWindowLong(hDlg, DWL_MSGRESULT, fError);
                    }
            }
            return (TRUE);
    }
    return (FALSE);
}

BOOL CALLBACK
bReportOptionsProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LPNMHDR pnmh;
    BOOL fError = FALSE;
    
    switch (uMsg) {
        case WM_INITDIALOG:

            /*
            // Limit the size of the text boxes to two characters
            */
            
            CheckDlgButton(hDlg, IDC_PD_USAGES, fUsagePredefined);

            SendDlgItemMessage(hDlg, IDC_REPORT_SIZE_MIN, EM_SETLIMITTEXT, 2, 0);
            SendDlgItemMessage(hDlg, IDC_REPORT_SIZE_MAX, EM_SETLIMITTEXT, 2, 0);                   
            SendDlgItemMessage(hDlg, IDC_REPORT_COUNT_MIN, EM_SETLIMITTEXT, 2, 0);
            SendDlgItemMessage(hDlg, IDC_REPORT_COUNT_MAX, EM_SETLIMITTEXT, 2, 0);

            SendDlgItemMessage(hDlg, IDC_BUTTONS_MIN, EM_SETLIMITTEXT, 2, 0);                       
            SendDlgItemMessage(hDlg, IDC_BUTTONS_MAX, EM_SETLIMITTEXT, 2, 0);                       

            SendDlgItemMessage(hDlg, IDC_ARRAY_SIZE_MIN, EM_SETLIMITTEXT, 2, 0);                    
            SendDlgItemMessage(hDlg, IDC_ARRAY_SIZE_MAX, EM_SETLIMITTEXT, 2, 0);                
            SendDlgItemMessage(hDlg, IDC_ARRAY_COUNT_MIN, EM_SETLIMITTEXT, 2, 0);                   
            SendDlgItemMessage(hDlg, IDC_ARRAY_COUNT_MAX, EM_SETLIMITTEXT, 2, 0);
            SendDlgItemMessage(hDlg, IDC_ARRAY_USAGES_MIN, EM_SETLIMITTEXT, 2, 0);  
            SendDlgItemMessage(hDlg, IDC_ARRAY_USAGES_MAX, EM_SETLIMITTEXT, 2, 0);  

            SendDlgItemMessage(hDlg, IDC_BUFFER_MIN, EM_SETLIMITTEXT, 2, 0);                        
            SendDlgItemMessage(hDlg, IDC_BUFFER_MAX, EM_SETLIMITTEXT, 2, 0);        

            CheckDlgButton(hDlg, IDC_CREATE_DATA_FIELDS, InputReport.fCreateDataFields);
            CheckDlgButton(hDlg, IDC_CREATE_BUTTONS, InputReport.fCreateButtonBitmaps);
            CheckDlgButton(hDlg, IDC_CREATE_ARRAYS, InputReport.fCreateArrays);
            CheckDlgButton(hDlg, IDC_CREATE_BUFFERED_BYTES, InputReport.fCreateBufferedBytes);

            SetDlgItemInt(hDlg, IDC_REPORT_SIZE_MIN, InputReport.ulMinReportSize, FALSE);
            SetDlgItemInt(hDlg, IDC_REPORT_SIZE_MAX, InputReport.ulMaxReportSize, FALSE);
            SetDlgItemInt(hDlg, IDC_REPORT_COUNT_MIN, InputReport.ulMinReportCount, FALSE);
            SetDlgItemInt(hDlg, IDC_REPORT_COUNT_MAX, InputReport.ulMaxReportCount, FALSE);

            SetDlgItemInt(hDlg, IDC_BUTTONS_MIN, InputReport.ulMinNumButtons, FALSE);
            SetDlgItemInt(hDlg, IDC_BUTTONS_MAX, InputReport.ulMaxNumButtons, FALSE);

            SetDlgItemInt(hDlg, IDC_ARRAY_SIZE_MIN, InputReport.ulMinArraySize, FALSE);
            SetDlgItemInt(hDlg, IDC_ARRAY_SIZE_MAX, InputReport.ulMaxArraySize, FALSE);
            SetDlgItemInt(hDlg, IDC_ARRAY_COUNT_MIN, InputReport.ulMinArrayCount, FALSE);
            SetDlgItemInt(hDlg, IDC_ARRAY_COUNT_MAX, InputReport.ulMaxArrayCount, FALSE);
            SetDlgItemInt(hDlg, IDC_ARRAY_USAGES_MIN, InputReport.ulMinArrayUsages, FALSE);
            SetDlgItemInt(hDlg, IDC_ARRAY_USAGES_MAX, InputReport.ulMaxArrayUsages, FALSE);

            SetDlgItemInt(hDlg, IDC_BUFFER_MIN, InputReport.ulMinBufferSize, FALSE);
            SetDlgItemInt(hDlg, IDC_BUFFER_MAX, InputReport.ulMaxBufferSize, FALSE);                        
           
            /*
            // Switch state of default button because we'll send a message to the
            //   the dialog box that the button has been clicked which will put it
            //   back in it's correct state.
            */

            fReportDefault = !fReportDefault;
                            
            SendMessage(hDlg, WM_COMMAND, (BN_CLICKED << 16) | IDC_DEFAULT_REPORT, 0);                      return (TRUE);
            return (TRUE);
          
        case WM_COMMAND:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    switch (LOWORD(wParam)) {
                        case IDC_DEFAULT_REPORT:
                            fReportDefault = !fReportDefault;
                            CheckDlgButton(hDlg, IDC_DEFAULT_REPORT, fReportDefault);

                            EnableWindow(GetDlgItem(hDlg, IDC_CREATE_DATA_FIELDS), !fReportDefault);
                            EnableWindow(GetDlgItem(hDlg, IDC_CREATE_BUTTONS), !fReportDefault);
                            EnableWindow(GetDlgItem(hDlg, IDC_CREATE_ARRAYS), !fReportDefault);
                            EnableWindow(GetDlgItem(hDlg, IDC_USE_REPORT_IDS), !fReportDefault);                            
                            EnableWindow(GetDlgItem(hDlg, IDC_CREATE_BUFFERED_BYTES), !fReportDefault);

                            EnableWindow(GetDlgItem(hDlg, IDC_REPORT_SIZE_MIN), !fReportDefault && InputReport.fCreateDataFields);
                            EnableWindow(GetDlgItem(hDlg, IDC_REPORT_SIZE_MAX), !fReportDefault && InputReport.fCreateDataFields);
                            EnableWindow(GetDlgItem(hDlg, IDC_REPORT_COUNT_MIN), !fReportDefault && InputReport.fCreateDataFields);
                            EnableWindow(GetDlgItem(hDlg, IDC_REPORT_COUNT_MAX), !fReportDefault && InputReport.fCreateDataFields);

                            EnableWindow(GetDlgItem(hDlg, IDC_BUTTONS_MIN), !fReportDefault && InputReport.fCreateButtonBitmaps);
                            EnableWindow(GetDlgItem(hDlg, IDC_BUTTONS_MAX), !fReportDefault && InputReport.fCreateButtonBitmaps);

                            EnableWindow(GetDlgItem(hDlg, IDC_ARRAY_SIZE_MIN), !fReportDefault && InputReport.fCreateArrays);
                            EnableWindow(GetDlgItem(hDlg, IDC_ARRAY_SIZE_MAX), !fReportDefault && InputReport.fCreateArrays);
                            EnableWindow(GetDlgItem(hDlg, IDC_ARRAY_COUNT_MIN), !fReportDefault && InputReport.fCreateArrays);
                            EnableWindow(GetDlgItem(hDlg, IDC_ARRAY_COUNT_MAX), !fReportDefault && InputReport.fCreateArrays);
                            EnableWindow(GetDlgItem(hDlg, IDC_ARRAY_USAGES_MIN), !fReportDefault && InputReport.fCreateArrays);
                            EnableWindow(GetDlgItem(hDlg, IDC_ARRAY_USAGES_MAX), !fReportDefault && InputReport.fCreateArrays);

                            EnableWindow(GetDlgItem(hDlg, IDC_BUFFER_MIN), !fReportDefault && InputReport.fCreateBufferedBytes);
                            EnableWindow(GetDlgItem(hDlg, IDC_BUFFER_MAX), !fReportDefault && InputReport.fCreateBufferedBytes);
                            
                            break;

                        case IDC_CREATE_DATA_FIELDS:
                            InputReport.fCreateDataFields = !InputReport.fCreateDataFields;
                            CheckDlgButton(hDlg, IDC_CREATE_DATA_FIELDS, InputReport.fCreateDataFields);

                            EnableWindow(GetDlgItem(hDlg, IDC_REPORT_SIZE_MIN), InputReport.fCreateDataFields);
                            EnableWindow(GetDlgItem(hDlg, IDC_REPORT_SIZE_MAX), InputReport.fCreateDataFields);
                            EnableWindow(GetDlgItem(hDlg, IDC_REPORT_COUNT_MIN), InputReport.fCreateDataFields);
                            EnableWindow(GetDlgItem(hDlg, IDC_REPORT_COUNT_MAX), InputReport.fCreateDataFields);
                            break;
                            
                        case IDC_CREATE_BUTTONS:
                            InputReport.fCreateButtonBitmaps = !InputReport.fCreateButtonBitmaps;
                            CheckDlgButton(hDlg, IDC_CREATE_BUTTONS, InputReport.fCreateButtonBitmaps);

                            EnableWindow(GetDlgItem(hDlg, IDC_BUTTONS_MIN), InputReport.fCreateButtonBitmaps);
                            EnableWindow(GetDlgItem(hDlg, IDC_BUTTONS_MAX), InputReport.fCreateButtonBitmaps);
                            break;

                        case IDC_CREATE_ARRAYS:
                            InputReport.fCreateArrays = !InputReport.fCreateArrays;
                            CheckDlgButton(hDlg, IDC_CREATE_ARRAYS, InputReport.fCreateArrays);

                            EnableWindow(GetDlgItem(hDlg, IDC_ARRAY_SIZE_MIN), InputReport.fCreateArrays);
                            EnableWindow(GetDlgItem(hDlg, IDC_ARRAY_SIZE_MAX), InputReport.fCreateArrays);
                            EnableWindow(GetDlgItem(hDlg, IDC_ARRAY_COUNT_MIN), InputReport.fCreateArrays);
                            EnableWindow(GetDlgItem(hDlg, IDC_ARRAY_COUNT_MAX), InputReport.fCreateArrays);
                            EnableWindow(GetDlgItem(hDlg, IDC_ARRAY_USAGES_MIN), InputReport.fCreateArrays);
                            EnableWindow(GetDlgItem(hDlg, IDC_ARRAY_USAGES_MAX), InputReport.fCreateArrays);
                            break;                            

                        case IDC_CREATE_BUFFERED_BYTES:
                            InputReport.fCreateBufferedBytes = !InputReport.fCreateBufferedBytes;
                            CheckDlgButton(hDlg, IDC_CREATE_BUFFERED_BYTES, InputReport.fCreateBufferedBytes);

                            EnableWindow(GetDlgItem(hDlg, IDC_BUFFER_MIN), InputReport.fCreateBufferedBytes);
                            EnableWindow(GetDlgItem(hDlg, IDC_BUFFER_MAX), InputReport.fCreateBufferedBytes);
                            break;     

                        default:
                            assert(0);
                    }
            }
            return (TRUE);

        case WM_NOTIFY:
            pnmh = (LPNMHDR) lParam;
            switch (pnmh -> code) {
                case PSN_KILLACTIVE:
                            
                    /*
                    // On changing focus, check the values of the field that have been entered
                    */
                    
                    InputReport.ulMinReportSize = GetDlgItemInt(hDlg, IDC_REPORT_SIZE_MIN, NULL, FALSE);
                    InputReport.ulMaxReportSize = GetDlgItemInt(hDlg, IDC_REPORT_SIZE_MAX, NULL, FALSE);
                    InputReport.ulMinReportCount = GetDlgItemInt(hDlg, IDC_REPORT_COUNT_MIN, NULL, FALSE);
                    InputReport.ulMaxReportSize = GetDlgItemInt(hDlg, IDC_REPORT_COUNT_MAX, NULL, FALSE);

                    InputReport.ulMinNumButtons = GetDlgItemInt(hDlg, IDC_BUTTONS_MIN, NULL, FALSE);
                    InputReport.ulMaxNumButtons = GetDlgItemInt(hDlg, IDC_BUTTONS_MAX, NULL, FALSE);
                    
                    InputReport.ulMinArraySize = GetDlgItemInt(hDlg, IDC_ARRAY_SIZE_MIN, NULL, FALSE);
                    InputReport.ulMaxArraySize = GetDlgItemInt(hDlg, IDC_ARRAY_SIZE_MAX, NULL, FALSE);
                    InputReport.ulMinArrayCount = GetDlgItemInt(hDlg, IDC_ARRAY_COUNT_MIN, NULL, FALSE);
                    InputReport.ulMaxArrayCount = GetDlgItemInt(hDlg, IDC_ARRAY_COUNT_MAX, NULL, FALSE);
                    InputReport.ulMinArrayUsages = GetDlgItemInt(hDlg, IDC_ARRAY_USAGES_MIN, NULL, FALSE);
                    InputReport.ulMaxArrayUsages = GetDlgItemInt(hDlg, IDC_ARRAY_USAGES_MAX, NULL, FALSE);

                    InputReport.ulMinBufferSize = GetDlgItemInt(hDlg, IDC_BUFFER_MIN, NULL, FALSE);
                    InputReport.ulMaxBufferSize = GetDlgItemInt(hDlg, IDC_BUFFER_MAX, NULL, FALSE);
                            
                    /*
                    // If any of the fields are 0 and we are not using the defaults, generate
                    //    a warning.
                    */

                    fError = (InputReport.ulMinReportSize > InputReport.ulMaxReportSize || 
                              InputReport.ulMaxReportSize > 32) && (InputReport.fCreateDataFields);

                    fError = fError || (InputReport.ulMinArraySize > InputReport.ulMaxArraySize || 
                                        InputReport.ulMaxArraySize > 32) && (InputReport.fCreateArrays);
        
                    fError = fError || (InputReport.ulMinReportCount > InputReport.ulMaxReportCount) && (InputReport.fCreateDataFields);
                    fError = fError || (InputReport.ulMinNumButtons > InputReport.ulMaxNumButtons) && (InputReport.fCreateButtonBitmaps);
                    fError = fError || (InputReport.ulMinArraySize  > InputReport.ulMaxArraySize) && (InputReport.fCreateArrays);
                    fError = fError || (InputReport.ulMinArrayCount  > InputReport.ulMaxArrayCount) && (InputReport.fCreateArrays);
                    fError = fError || (InputReport.ulMinArrayUsages > InputReport.ulMaxArrayUsages) && (InputReport.fCreateArrays);

                    fError = fError || (InputReport.ulMinBufferSize > InputReport.ulMaxBufferSize) && (InputReport.fCreateBufferedBytes);

                    if (fError) {
                        OUTERROR("One or more data fields are in error");
                        SetWindowLong(hDlg, DWL_MSGRESULT, fError);
                    }
            }
            return (TRUE);
    }
    return (FALSE);
}

BOOL
SetDlgItemIntHex(
    HWND    hDlg,
    INT     nIDDlgItem,
    UINT    uValue,
    INT     nBytes
)
{
    char szTempBuffer[] = "0x00000000";
    int  iEndIndex, iWidth;

    assert (1 == nBytes || 2 == nBytes || 4 == nBytes);

    /*
    // Determine the width necessary to store the value
    */

    iWidth = ((int) floor(log(uValue)/log(16))) + 1;
    
    assert (iWidth <= 2*nBytes);

    iEndIndex = 2+2*nBytes;

    wsprintf(&(szTempBuffer[iEndIndex-iWidth]), "%X", uValue);

    SetDlgItemText(hDlg, nIDDlgItem, szTempBuffer);
    return (TRUE);
}

UINT
GetDlgItemIntHex(
    HWND    hDlg,
    INT     nIDDlgItem,
    BOOL    *lpTranslated
)
{
    char szTempBuffer[HEX_LIMIT_32BITS+1];
    char *nptr;
    UINT uiValue;

    GetDlgItemText(hDlg, nIDDlgItem, szTempBuffer, HEX_LIMIT_32BITS+1);
    uiValue = (UINT) strtol(szTempBuffer, &nptr, 16);
    *lpTranslated = (*nptr == '\0');
    return (uiValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\dll\settings.h ===
#ifndef __SETTINGS_H__
#define __SETTINGS_H__

#define NUM_SETTINGS_PAGES 3

/*
// These are the three functions which are exported in the DLL and available
//    to clients who use the DLL for setting and retrieving options
*/

BOOL __stdcall
BINGEN_SetOptions(
    VOID
);

VOID __stdcall
BINGEN_GetOptions(
    OUT PGENERATE_OPTIONS   options
);

VOID __stdcall
BINGEN_GetDefaultOptions(
    OUT PGENERATE_OPTIONS   options
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\dt\dt.c ===
/*******************************************************************************
**
**      MODULE: "DT.C".
**
**
** DESCRIPTION: iPostit Notes.
**
**
**      AUTHOR: Daniel Dean.
**
**
**
**     CREATED: 12/18/1995.
**
**	   HISTORY:
**
**		Date		Author					Reason
**    ----------------------------------------------------------------------
**		12/18/95	Daniel Dean	(a-Danld)	Created
**		02/29/96	John Pierce (johnpi)	Took over dev from Dan
**
**
**  (C) C O P Y R I G H T   M I C R O S O F T   C O R P   1 9 9 5 - 1 9 9 6.
**
**                 A L L   R I G H T S   R E S E R V E D .
**
*******************************************************************************/
#include <windows.h>
#include <commctrl.h>               // for spin control       
#include <string.h>
#include <stdio.h>                  // for sscanf

#define DEFINE_GLOBALS
#include "..\include\DT.H"
#undef  DEFINE_GLOBALS

#include "..\include\dtrc.h"
#include "..\include\public.h"        // include file for test driver test.sys

#define VK_A 0x41
#define VK_F 0x46
#define VK_Z 0x5A

//
// Uncomment this line to build a version of the app which does not
//  have the SendDescriptor button. This is for versions that ship
//  to the public
#define EXTERNAL_BUILD

#define KEYBORAD_MESSAGE (Message.message == WM_KEYDOWN || Message.message == WM_CHAR || Message.message == WM_KEYUP)


//#define LISTSTYLE (LBS_WANTKEYBOARDINPUT | LBS_EXTENDEDSEL | LBS_NOTIFY | WS_BORDER | WS_VSCROLL | WS_VISIBLE | WS_CHILD)
#define LISTSTYLE (LBS_WANTKEYBOARDINPUT | LBS_HASSTRINGS | LBS_NOTIFY | WS_BORDER | WS_VSCROLL | WS_VISIBLE | WS_CHILD )
#define DESCSTYLE (LBS_WANTKEYBOARDINPUT | LBS_USETABSTOPS | LBS_NOTIFY | WS_BORDER | WS_VSCROLL | WS_VISIBLE | WS_CHILD)
#define HEXSTYLE  (LBS_WANTKEYBOARDINPUT | LBS_NOTIFY | WS_BORDER | WS_VSCROLL | WS_VISIBLE | WS_CHILD)
//#define EDIT_STYLE (WS_CHILD | WS_VISIBLE | WS_BORDER | ES_UPPERCASE)


#define SPACERTOP       10
#define SPACERBOTTOM    5
#define TEXTSIZE        12

// Entity list box positions
#define ENTITY_TEXT_X   10
#define ENTITY_TEXT_Y   SPACERTOP
#define ENTITY_X        ENTITY_TEXT_X
#define ENTITY_Y        ENTITY_TEXT_Y + SPACERBOTTOM + TEXTSIZE
#define ENTITY_SIZE_X   193
#define ENTITY_SIZE_Y   315
// Descriptor list box positions
//  replacing Hex listbox with one tabbed Descr listbox
#define DESC_TEXT_X     ENTITY_X + ENTITY_SIZE_X + SPACERTOP
#define DESC_TEXT_Y     SPACERTOP
#define DESC_X          DESC_TEXT_X
#define DESC_Y          ENTITY_Y
#define DESC_SIZE_X     ENTITY_SIZE_X * 2 + SPACERTOP 
#define DESC_SIZE_Y     ENTITY_SIZE_Y
// Manual Data Entry button positions
#define MANUAL_X        CLEAR_X - CLEAR_SIZE_X - SPACERTOP//ENTITY_TEXT_X + ((ENTITY_SIZE_X - MANUAL_SIZE_X)/2)
#define MANUAL_Y        ENTITY_Y + ENTITY_SIZE_Y + SPACERBOTTOM
#define MANUAL_SIZE_X   150
#define MANUAL_SIZE_Y   25
// Clear Descriptor button positions
#define CLEAR_X        	(((ENTITY_SIZE_X * 3)+(SPACERTOP*5))/2) - (CLEAR_SIZE_X/2)
#define CLEAR_Y        	DESC_Y + DESC_SIZE_Y + SPACERBOTTOM
#define CLEAR_SIZE_X   	150
#define CLEAR_SIZE_Y   	25
// Send Descriptor button positions
#define BUTTON_X        CLEAR_X + CLEAR_SIZE_X + SPACERTOP // + (((DESC_SIZE_X/2) - BUTTON_SIZE_X) / 2)
#define BUTTON_Y        DESC_Y + DESC_SIZE_Y + SPACERBOTTOM
#define BUTTON_SIZE_X   150
#define BUTTON_SIZE_Y   25


//
// Child window ID's
#define ID_ENTITY       0


HANDLE hInst;

#define NUMBER_WINDOWS  5
HWND    hWindow[NUMBER_WINDOWS];
#define ENTITY_WINDOW   hWindow[0]
#define DESC_WINDOW     hWindow[1]
#define SEND_BUTTON     hWindow[2]
#define MANUAL_BUTTON   hWindow[3]
#define CLEAR_BUTTON	hWindow[4]
ULONG   Focus = 0;


//
// Storage for address of original ListBox window proc
//
WNDPROC gOrgListBoxProc=NULL;
//
// Machinery for getting ItemTag values from users
//
#define USAGEP_FUNC         0
#define EDIT_SIGNED_FUNC    1
#define EDIT_UNSIGNED_FUNC  2
#define COLL_FUNC           3
#define END_COLL_FUNC       4
#define INPUT_FUNC          5
#define OUTPUT_FUNC         6
#define FEAT_FUNC           7
#define EXP_FUNC            8
#define UNIT_FUNC           9
#define PUSH_FUNC           10
#define POP_FUNC            11
#define DELIMIT_FUNC        12
#define BOGUS_FUNC          13

//
// Array of pointers to input functions taking 
//  a Handles and an int and returning void
//
void (*arGetItemVal[])(HANDLE,int) = {
    GetUsagePageVal,
    GetInputFromEditBoxSigned,
    GetInputFromEditBoxUnSigned,
    GetCollectionVal,
    GetEndCollectionVal,
    GetInputVal,
    GetOutputVal,
    GetFeatVal,
    GetExponentVal,
    GetUnitsVal,
    GetPushVal,
    GetPopVal, 
    GetSetDelimiterVal,
    GetBogusVal
    };

//
// An array of offsets into the arGetItemVal[] function
//  pointer array. This array is arranged in the same
//  order that the items appear in the Entity ListBox.
//  So, when we click on an item we can programatically
//  call the input routine associated with it.

UCHAR EntityInputIndex[] = {
                  EDIT_UNSIGNED_FUNC,   //USAGE,
                  USAGEP_FUNC,          //USAGE_PAGE,
                  EDIT_UNSIGNED_FUNC,   //USAGE_MIN,
                  EDIT_UNSIGNED_FUNC,   //USAGE_MAX,
                  EDIT_UNSIGNED_FUNC,   //DESIGNATOR_INDEX,
                  EDIT_UNSIGNED_FUNC,   //DESIGNATOR_MIN,
                  EDIT_UNSIGNED_FUNC,   //DESIGNATOR_MAX,
                  EDIT_UNSIGNED_FUNC,   //STRING_INDEX,
                  EDIT_UNSIGNED_FUNC,   //STRING_MIN,
                  EDIT_UNSIGNED_FUNC,   //STRING_MAX,
                  COLL_FUNC,            //COLLECTION,
                  END_COLL_FUNC,        //END_COLLECTION,
                  INPUT_FUNC,           //INPUT,
                  OUTPUT_FUNC,          //OUTPUT,
                  FEAT_FUNC,            //FEATURE,
                  EDIT_SIGNED_FUNC,     //LOGICAL_EXTENT_MIN,
                  EDIT_SIGNED_FUNC,     //LOGICAL_EXTENT_MAX,
                  EDIT_SIGNED_FUNC,     //PHYSICAL_EXTENT_MIN,
                  EDIT_SIGNED_FUNC,     //PHYSICAL_EXTENT_MAX,
                  EXP_FUNC,             //UNIT_EXPONENT,
                  UNIT_FUNC,            //UNIT
                  EDIT_UNSIGNED_FUNC,   //REPORT_SIZE,
                  EDIT_SIGNED_FUNC,     //REPORT_ID,
                  EDIT_UNSIGNED_FUNC,   //REPORT_COUNT,
                  PUSH_FUNC,            //PUSH,
                  POP_FUNC,             //POP
                  DELIMIT_FUNC,         //SET_DELIMITER  
                  BOGUS_FUNC            //BOGUS
                  };          


//
// Misc. Globals
//
char gszFileName[MAX_PATH];

ULONG   InitializationFLAG = 1;

HFONT	hFontControl;
HFONT	hFontText;



/*******************************************************************************
**
** WinMain.
**
** DESCRIPTION:
**              
**              
**  PARAMETERS: HANDLE hInstance, Current Instance handle.
**              HANDLE hPrevInstance, Last instance handle.
**              LPSTR  lpszCmParam, Comand line parameter.
**              INT    WindowState, Show window state.
**
**     RETURNS:
**
*******************************************************************************/
INT PASCAL WinMain(HANDLE hInstance,
                   HANDLE hPrevInstance,
                   LPSTR  lpszCmParam,
                   INT    WindowState)
{
    MSG     Message;
    HWND    hWnd;

    hInst = hInstance;

    if(WindowRegistration(hInstance, hPrevInstance))
        return ERROR;

    // Main Window
    hWnd = CreateWindowEx(0,
                          (LPCSTR) APPCLASS,
                          (LPCSTR) APPTITLE,
                          WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | 
                          WS_DLGFRAME | CS_DBLCLKS,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          (ENTITY_SIZE_X * 3) + (SPACERTOP *5),
                          450,
                          (HWND) NULL,
                          LoadMenu(hInstance,MAKEINTRESOURCE(IDM_MAIN_MENU)),
                          hInstance,
                          (LPSTR) NULL);
    if(!hWnd)
        return ERROR;

    //
    // Save the instance in a global
    ghInst = hInstance;

    ShowWindow(hWnd, WindowState);
    UpdateWindow(hWnd);
   
    while(GetMessage(&Message, NULL, 0, 0))
    {
        TranslateMessage(&Message);
        DispatchMessage(&Message);
    }

    return Message.lParam;
}



/*******************************************************************************
**
** WindowProc.
**
** DESCRIPTION:
**              
**              
**  PARAMETERS: HWND hWnd, Window handle. 
**              UINT Message, Window Message.
**              UINT uParam, Unsigned message parameter.
**              LPARAM lParam, Signed message parameter.
**
**     RETURNS:
**
*******************************************************************************/
LPARAM WINAPI WindowProc(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam)
{
    //
    // Save the MainWindow handle in a global
    //
	ghWnd = hWnd;
   	
    switch(Message)
    {
        case WM_VKEYTOITEM:
            switch(LOWORD(uParam))
            {
                case VK_DELETE:
                    if(lParam == (LPARAM) DESC_WINDOW)
                    {
                        int Number,nBytes;
                        PITEM_INFO pII;

                        Number = SendMessage(DESC_WINDOW, LB_GETCURSEL, 0, 0);

                        pII = (PITEM_INFO)SendMessage(DESC_WINDOW,LB_GETITEMDATA,Number,0);
                        if(pII)
                        {
                            if( (nBytes = (pII->bTag & ITEM_SIZE_MASK)) == 0x03)
                                gwReportDescLen -= 5; // 4 data bytes + 1 Tag byte
                            else
                                gwReportDescLen -= nBytes + 1;
                            
                            GlobalFree(pII);
                        }
                        SendMessage(DESC_WINDOW, LB_DELETESTRING, Number, 0); 
                        SendMessage(DESC_WINDOW, LB_SETCURSEL, Number, 0);
                        
                    }
                    break;

                case VK_RETURN:
                    if(lParam == (LPARAM) ENTITY_WINDOW)
                        SendMessage(hWnd,WM_COMMAND,(WPARAM)MAKEWPARAM(0,LBN_DBLCLK),(LPARAM)ENTITY_WINDOW);
                    break;                                  

                case VK_TAB:
                    if(lParam == (LPARAM) DESC_WINDOW)
                        Focus = 0;
                    if(lParam == (LPARAM) ENTITY_WINDOW)
                        Focus = 1;
                    SetFocus(hWindow[Focus]);
                    break;
            }
            return -1;

        case WM_SETFOCUS:
            SetFocus(hWindow[Focus]);
            return SUCCESS;


        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:           return WMKey(hWnd, Message, uParam, lParam);


        case WM_RESTORE:
        {
            ULONG Index;
            
            Focus = 0;
            for(Index=0; Index<5; Index++) 
                ShowWindow(hWindow[Index], SW_SHOW);
            return SUCCESS;
        }

        case WM_CREATE:         return WMCreate(hWnd, lParam);
        case WM_SIZE:           return WMSize(hWnd, lParam);
        case WM_PAINT:          return WMPaint(hWnd, Message, uParam, lParam);
        case WM_COMMAND:        return WMCommand(hWnd, Message, uParam, lParam);
        //case WM_SYSCOMMAND:     return WMSysCommand(hWnd, Message, uParam, lParam);
        case WM_CLOSE:          return WMClose(hWnd);
        case WM_DESTROY:        return WMClose(hWnd);
        default:                return DefWindowProc(hWnd, Message, uParam, lParam);
    }
}


/*******************************************************************************
**
** WMCommand.
**
** DESCRIPTION:
**              
**              
**  PARAMETERS: HWND hWnd, Window handle. 
**              UINT Message, Window Message.
**              UINT uParam, Unsigned message parameter.
**              LPARAM lParam, Signed message parameter.
**
**
**     RETURNS:
**
*******************************************************************************/
LPARAM WMCommand(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam)
{
#define MAX_STRING 64
    
    
    switch( uParam )
    {
        case IDM_OPEN:
            DoFileOpen(hWnd);
            return SUCCESS;
        
        case IDM_SAVE:
            DoFileSave(hWnd);
            return SUCCESS;
        
        case IDM_PRINT:
            DoFilePrint(hWnd);
            return SUCCESS;

        case IDM_EXIT:
            SendMessage(ghWnd,WM_CLOSE,0,0);
            return SUCCESS;
    
        case IDM_COPY:
            DoCopyDescriptor(hWnd);
            return SUCCESS;
    
        case IDM_PARSE:
            DoParseDescriptor(hWnd);
            return SUCCESS;
    }


    //////////////////////////////////////////////////
    //
    // Clear Descriptor button was pressed
    //
    if(lParam == (LPARAM) CLEAR_BUTTON && uParam == 0)
    {
        PITEM_INFO pItemInfo;
        LRESULT Index,Count;
		
		Count = SendMessage(DESC_WINDOW,LB_GETCOUNT,0,0);

		for( Index = Count-1; Index >= 0; Index-- )
		{
		
			pItemInfo = (PITEM_INFO) SendMessage(DESC_WINDOW,LB_GETITEMDATA,0,0);
			if( pItemInfo )
				GlobalFree(pItemInfo);
			SendMessage(DESC_WINDOW,LB_DELETESTRING,Index,0);
	    }
        gwReportDescLen = 0;
		return SUCCESS;
	}
	

	//////////////////////////////////////////////////
    //
    // Mouse was DBL_CLICKED in the Entity window
    //
    if( (lParam == (LPARAM) ENTITY_WINDOW) && (HIWORD(uParam) == LBN_DBLCLK) )
	{

        ULONG Item;

        Item = SendMessage(ENTITY_WINDOW,LB_GETCURSEL,0,0);
        (*arGetItemVal[EntityInputIndex[Item]])( DESC_WINDOW, Item );

        return SUCCESS;
	}
	
    //////////////////////////////////////////////////
    //
    // Mouse was DBL_CLICKED in the Descriptor Window
    //
	if( (lParam == (LPARAM) DESC_WINDOW) && (HIWORD(uParam) == LBN_DBLCLK) )
	{

        ULONG Item;

        Item = SendMessage(DESC_WINDOW,LB_GETCURSEL,0,0);


        return SUCCESS;
	}



    //////////////////////////////////////////////////
    //
    // Manual Entry button was pressed
    //
    if(lParam == (LPARAM) MANUAL_BUTTON && uParam == 0)
    {
        PITEM_INFO pItemInfo;
        char szBuff[128],szTmp[3];
        int Index,rc,i;
        BYTE *pb;

        rc = DialogBox( ghInst,"EditBoxDlg",ghWnd , EditBoxDlgProc);
        
        if( rc == TRUE )
        {
            Index = SendMessage(ENTITY_WINDOW,LB_GETCURSEL,0,0);
            if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
            {
                int NumBytes=0;

                pItemInfo->bTag = Entity[Index];
                            
                if( gEditVal < 0 )  // Handle negative numbers differently
                {
                    if( gEditVal > -0x100 )
                    {
                        pItemInfo->bTag |= 0x01;
                        NumBytes = 1;
                    }
                    else if (gEditVal > -0x10000 )
                    {                                     
                        pItemInfo->bTag |= 0x02;      
                        NumBytes = 2;
                    }
                    else
                    {
                        pItemInfo->bTag |= 0x03;
                        NumBytes = 4;
                    }      
            
                }
            
                else    // Number is not negative
                {
                    if( (DWORD)gEditVal < 0x80 )
                    {
                        pItemInfo->bTag |= 0x01;
                        NumBytes = 1;
                    }
                    else if ( (DWORD)gEditVal < 0x8000 )
                    {
                        pItemInfo->bTag |= 0x02;      
                        NumBytes = 2;
                    }
                    else
                    {
                        pItemInfo->bTag |= 0x03;
                        NumBytes = 4;
                    }      
            
                }

                wsprintf(szBuff,"%s (%d)\t%02X ",szEntity[Index],gEditVal,pItemInfo->bTag);
                pb = (BYTE *) &gEditVal;
                for( i=0;i<NumBytes;i++ ) 
                {
                    pItemInfo->bParam[i] = *pb++;
                    wsprintf(szTmp,"%02X ",pItemInfo->bParam[i]);
                    strcat(szBuff,szTmp);
                }     
                Index = AddString(DESC_WINDOW,szBuff);
                rc = SendMessage(DESC_WINDOW,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);
            }
            
        }
        return SUCCESS;
    }
    
    //////////////////////////////////////////////////
    //
    // Send Descriptor button was pressed
    //
    if(lParam == (LPARAM) SEND_BUTTON && uParam == 0)
    {
        ULONG   Number;
        ULONG   DescLBIndex;
        ULONG   BufferIndex = 0;
        PUCHAR  pBuffer;

        DWORD   dwDevID;                // Device ID returned from SendHIDDescriptor
        ULONG   hDevHandle;             // Device handle returned from SendHIDDescriptor
        
        PITEM_INFO pItemInfo;
        PDEVICEINFO pdiDlgInstanceInfo; // Instance info for SendData dialogs

        int     rc;

        static int nDialogIndex=0;


        // Get number of Items in Descriptor list box
        Number = SendMessage(DESC_WINDOW, LB_GETCOUNT, 0, 0);

		// Descriptor must have at least 2 items
		if( Number < 2 )
			return FAILURE;

        if( (pBuffer = (PUCHAR) GlobalAlloc(GPTR, Number*5*sizeof(UCHAR)) ) )
        {
            // Read through Descriptor
            for(DescLBIndex=0; DescLBIndex<Number; DescLBIndex++)
            {
                // Get Pointer to Descriptor Info struct
                pItemInfo = (PITEM_INFO) SendMessage(DESC_WINDOW, LB_GETITEMDATA, DescLBIndex, 0 );
               
                if( !pItemInfo )
                {
                    GlobalFree(pBuffer);
                    return FAILURE;
                }

                pBuffer[BufferIndex++] = pItemInfo->bTag;
                switch( pItemInfo->bTag & DATA_SIZE_MASK )
                {
                    case 0:
                        break;
                    case 1:
                        pBuffer[BufferIndex++] = pItemInfo->bParam[0];
                        break;
                    case 2:
                        pBuffer[BufferIndex++] = pItemInfo->bParam[0];
                        pBuffer[BufferIndex++] = pItemInfo->bParam[1];
                        break;
                    case 3:
                        pBuffer[BufferIndex++] = pItemInfo->bParam[0];
                        pBuffer[BufferIndex++] = pItemInfo->bParam[1];
                        pBuffer[BufferIndex++] = pItemInfo->bParam[2];
                        pBuffer[BufferIndex++] = pItemInfo->bParam[3];
                        break;
                }


            }
            //
            // Send the descriptor to the HID driver. 
            // SendHIDDescriptor returns 0 if called worked
            //  or ERR_CREATEDEVICE if device creation failed  
            //
            rc = SendHIDDescriptor(pBuffer, &BufferIndex, &dwDevID, &hDevHandle); 
            GlobalFree(pBuffer);
        
            //
            // If the descriptor was not sent OK or there was an error 
            //  creating the device, inform the user.
            //
            if( !rc )
            {
                MessageBox(hWnd,"Error Creating Device","DT Error",MB_OK);
                return 0;
            }

            //
            // Else, create modeless dialog for the device
            //
            pdiDlgInstanceInfo = (PDEVICEINFO) GlobalAlloc(GPTR,sizeof(DEVICEINFO));
            pdiDlgInstanceInfo->nDeviceID = dwDevID;
            pdiDlgInstanceInfo->hDevice = hDevHandle;

            CreateDialogParam(ghInst,"SendData",hWnd,SendDataDlgProc,(LONG)pdiDlgInstanceInfo);

        }
        else
            MessageBox(hWnd, "Cant allocate memory!", "ERROR", MB_OK);
    
    
    }

	return 0; 

}

/*******************************************************************************
**
** WMCreate.
**
** DESCRIPTION:
**
**
**  PARAMETERS: HWND hWnd, Window handle.
**              UINT uParam, Unsigned message parameter.
**
**     RETURNS:
**
*******************************************************************************/
LPARAM WMCreate(HWND hWnd, UINT uParam)
{
    ULONG   Index;
	static LOGFONT	LogFont;
	
	//
    // Create a font for the ListBoxes and buttons
	LogFont.lfHeight = -14;
	strcpy(LogFont.lfFaceName,"Lucida Console");

	hFontControl = CreateFontIndirect(&LogFont);

   	// Create ListBox of Entity Descriptor Tags
	ENTITY_WINDOW = CreateWindow("LISTBOX",
                                 NULL,
                                 LISTSTYLE,
                                 ENTITY_X,
                                 ENTITY_Y,
                                 ENTITY_SIZE_X,
                                 ENTITY_SIZE_Y,
                                 hWnd,
                                 ID_ENTITY, //NULL
                                 hInst,
                                 NULL);
    if(!ENTITY_WINDOW)
        return EXITERROR;
    for(Index=0; Index < ENTITY_INDEX; Index++)
        SendMessage(ENTITY_WINDOW, LB_ADDSTRING, 0, (LPARAM) szEntity[Index]);              
    SendMessage(ENTITY_WINDOW, LB_SETSEL, TRUE, 0);              
	SendMessage(ENTITY_WINDOW, WM_SETFONT,(WPARAM)hFontControl,TRUE);

    //
	// Create a list box to display Item tags and their values
	DESC_WINDOW = CreateWindow("LISTBOX",
                              NULL,
                              DESCSTYLE,
                              DESC_X,
                              DESC_Y,
                              DESC_SIZE_X,
                              DESC_SIZE_Y,
                              hWnd,
                              NULL,
                              hInst,
                              NULL);
    if(!DESC_WINDOW)
        return EXITERROR;

    //
    // Subclass this window!
    //
    gOrgListBoxProc = (WNDPROC)GetWindowLong( DESC_WINDOW, GWL_WNDPROC );
    SetWindowLong( DESC_WINDOW, GWL_WNDPROC,(LONG) ListBoxWindowProc);
    SendMessage(DESC_WINDOW, WM_SETFONT,(WPARAM)hFontControl,TRUE); 
   {
    int TabStops[1] = {138};
    
    SendMessage(DESC_WINDOW, LB_SETTABSTOPS,1,(LPARAM)TabStops);
   }
	
	
	//
	//Create a button for manually entering item data
	//
	MANUAL_BUTTON = CreateWindow("BUTTON",
                                NULL,
                                WS_CHILD | WS_VISIBLE | WS_BORDER,
                                MANUAL_X,
                                MANUAL_Y,
                                MANUAL_SIZE_X,
                                MANUAL_SIZE_Y,
                                hWnd,
                                NULL,
                                hInst,
                                NULL);
    if(!MANUAL_BUTTON)
        return EXITERROR;
    SendMessage(MANUAL_BUTTON, WM_SETTEXT, TRUE, (LPARAM) "Manual Entry");              
    SendMessage(MANUAL_BUTTON, WM_SETFONT,(WPARAM)hFontControl,TRUE); 

	//
	//Create a button for clearing Descriptor entries
	//
	CLEAR_BUTTON = CreateWindow("BUTTON",
                                NULL,
                                WS_CHILD | WS_VISIBLE | WS_BORDER,
                                CLEAR_X,
                                CLEAR_Y,
                                CLEAR_SIZE_X,
                                CLEAR_SIZE_Y,
                                hWnd,
                                NULL,
                                hInst,
                                NULL);
    if(!CLEAR_BUTTON)
        return EXITERROR;
    SendMessage(CLEAR_BUTTON, WM_SETTEXT, TRUE, (LPARAM) "Clear Descriptor");              
    SendMessage(CLEAR_BUTTON, WM_SETFONT,(WPARAM)hFontControl,TRUE); 



#ifndef EXTERNAL_BUILD

    //
	// Create a button for sending descriptor to HID driver
	SEND_BUTTON = CreateWindow("BUTTON",
                                 NULL,
                                 WS_CHILD | WS_VISIBLE | WS_BORDER,
                                 BUTTON_X,
                                 BUTTON_Y,
                                 BUTTON_SIZE_X,
                                 BUTTON_SIZE_Y,
                                 hWnd,
                                 NULL,
                                 hInst,
                                 NULL);
    if(!SEND_BUTTON)
        return EXITERROR;
    SendMessage(SEND_BUTTON, WM_SETTEXT, TRUE, (LPARAM) "Send Descriptor");              
    SendMessage(SEND_BUTTON, WM_SETFONT,(WPARAM)hFontControl,TRUE); 

#endif
    
    return SUCCESS;
}

/*******************************************************************************
**
** WMClose.
**
** DESCRIPTION:
**              
**              
**  PARAMETERS: HWND hWnd, Window handle. 
**
**
**     RETURNS:
**
*******************************************************************************/
LPARAM WMClose(HWND hWnd)
{
    ULONG Index;
    ULONG Number;
    PITEM_INFO pItemInfo;

    Number = SendMessage(DESC_WINDOW, LB_GETCOUNT, 0, 0);

    // Free all the memory pointed to by LB_GETITEMDATA
    for(Index=0; Index<Number; Index++)
    {
        // Get Pointer to Descriptor Info struct
        pItemInfo = (PITEM_INFO) SendMessage(DESC_WINDOW, LB_GETITEMDATA, Index, 0 );
        GlobalFree(pItemInfo);
    }       
	DeleteObject(hFontControl);
    PostQuitMessage(0);
          
    return SUCCESS;
}


/*******************************************************************************
**
** WMSize.
**
** DESCRIPTION:
**              
**              
**  PARAMETERS: HWND hWnd, Window handle.
**              LPARAM lParam, Signed message parameter.
**
**
**     RETURNS:
**
*******************************************************************************/
LPARAM WMSize(HWND hWnd, LPARAM lParam)
{
    return SUCCESS;
}

/*******************************************************************************
**
** WMPaint.
**
** DESCRIPTION:
**              
**              
**  PARAMETERS: HWND hWnd, Window handle. 
**              UINT Message, Window Message.
**              UINT uParam, Unsigned message parameter.
**              LPARAM lParam, Signed message parameter.
**
**     RETURNS:
**
*******************************************************************************/
LPARAM WMPaint(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam)
{
    HDC         hDC;
    PAINTSTRUCT PaintS;
	static LOGFONT LF;

    hDC=BeginPaint(hWnd, &PaintS);
	
    LF.lfHeight = -12;
	hFontText = CreateFontIndirect(&LF);
	SelectObject(hDC,hFontText);

    // Set Window Texts
    //SetBkColor(hDC, BACKGROUND_BRUSH);
    SetBkMode(hDC,TRANSPARENT);
    TextOut(hDC, ENTITY_TEXT_X, ENTITY_TEXT_Y, "Items",sizeof("Items")-1);
    TextOut(hDC, DESC_TEXT_X, DESC_TEXT_Y, "Report Descriptor", sizeof("Report Descriptor")-1);
	//TextOut(hDC, HEX_TEXT_X, HEX_TEXT_Y, "HID Descriptor (Binary)", 23);
    
    DeleteObject(hFontText);
    
    EndPaint(hWnd, &PaintS);

    return SUCCESS;
}

/*******************************************************************************
**
** WMKey.
**
** DESCRIPTION:
**              
**              
**  PARAMETERS: HWND hWnd, Window handle.
**
**
**     RETURNS:
**
*******************************************************************************/
INT WMKey(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam)
{
    // Do some checking for ALPHA NUMERIC
    if(uParam > VK_F && uParam <= VK_Z)
        return SUCCESS;    

    if(uParam == VK_RETURN)
        Focus = 0;
    else if(uParam == VK_TAB)
        Focus = 2;
//    else
//       return SendMessage(DATA_WINDOW, Message, uParam, lParam);

    if(Message == WM_KEYUP || Message == WM_CHAR)  
        return SUCCESS;

    SetFocus(hWindow[Focus]);


    return SUCCESS;
}



/*******************************************************************************
**
** WindowRegistration.
**
** DESCRIPTION:
**              
**              
**  PARAMETERS: HANDLE hInstance, Current Instance handle.
**              HANDLE hPrevInstance, Last instance handle.
**
**     RETURNS:
**
*******************************************************************************/
BOOL WindowRegistration(HANDLE hInstance, HANDLE hPrevInstance)
{
    WNDCLASS WndClass;
   
   
    if(!hPrevInstance)
    {
        WndClass.style         = CS_DBLCLKS | CS_PARENTDC | CS_HREDRAW | CS_VREDRAW | CS_SAVEBITS | CS_BYTEALIGNCLIENT | CS_BYTEALIGNWINDOW;
        WndClass.lpfnWndProc   = WindowProc;
        WndClass.cbClsExtra    = 0;
        WndClass.cbWndExtra    = 0;
        WndClass.hInstance     = hInstance;
        WndClass.hIcon         = LoadIcon(hInstance,MAIN_ICON);
        WndClass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        WndClass.hbrBackground = (HBRUSH) (COLOR_MENU+1);
        WndClass.lpszMenuName  = MAKEINTRESOURCE(IDM_MAIN_MENU);
        WndClass.lpszClassName = (LPSTR) APPCLASS;
       
        if(!RegisterClass(&WndClass))
            return FAILURE;
    }
    return SUCCESS;
}


/***************************************************************************************************
**
** DoParseDescriptor()
**
** DESCRIPTION: Parses the current Descriptor
**
**  PARAMETERS: HANDLE  - handle the main window
**
**     RETURNS:
**
***************************************************************************************************/
void DoParseDescriptor(HANDLE hWnd)
{
    LRESULT rc;
    LRESULT lines;
    HGLOBAL hTextBuff;
    char *  pTextBuff;
    int i;
    char tmpBuff[128];


        //
        // Create a buffer big enough for all the Item strings
        lines = SendMessage(DESC_WINDOW,LB_GETCOUNT,0,0);
        if( !lines )
            return;
        hTextBuff = GlobalAlloc(GHND, lines * MAX_DESC_ENTRY );

        //
        // Copy the current entry into the buffer after appending
        // a new line to it.
        //
        pTextBuff = (char *)GlobalLock(hTextBuff);
        for(i=0;i<lines;i++)
        {
            SendMessage(DESC_WINDOW,LB_GETTEXT,i,(LPARAM)tmpBuff);
            SendMessage(DESC_WINDOW,LB_GETTEXTLEN,i,0);
            strcat(tmpBuff,"\n");
            strcat(pTextBuff,tmpBuff);
        } 

        strcat(pTextBuff,"END\0\0");

        GlobalUnlock(hTextBuff);
    
        rc = yy_scan_string( pTextBuff );
        rc = yyparse();

        GlobalFree(hTextBuff);


}




/***************************************************************************************************
**
** DoCopyDescriptor()
**
** DESCRIPTION: Copies the current descriptor to the Clip Board 
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
void DoCopyDescriptor(HANDLE hWnd)
{
    HGLOBAL hTextBuff;
    char *  pTextBuff;
    LRESULT lines,len;
    char tmpBuff[MAX_DESC_ENTRY];
    int i;

    //
    // Calculate the size of, and create a memory block for
    //  transfering the descriptor to the ClipBoard
    //
    lines = SendMessage(DESC_WINDOW,LB_GETCOUNT,0,0);
    hTextBuff = GlobalAlloc(GHND, lines * MAX_DESC_ENTRY );
    
    //
    // Copy the current entry into the buffer after appending
    // a new line to it.
    //
    pTextBuff = (char *)GlobalLock(hTextBuff);
    for(i=0;i<lines;i++)
    {
        SendMessage(DESC_WINDOW,LB_GETTEXT,i,(LPARAM)tmpBuff);
        len = SendMessage(DESC_WINDOW,LB_GETTEXTLEN,i,0);
        strcat(tmpBuff,"\n");
        strcat(pTextBuff,tmpBuff);
    } 
    
    GlobalUnlock(hTextBuff);
    
    //
    // Copy the text to the Clipboard
    //
    OpenClipboard(hWnd);
    EmptyClipboard();
    SetClipboardData(CF_TEXT,hTextBuff);
    CloseClipboard();

}
/***************************************************************************************************
**
** DoFileOPen()
**
** DESCRIPTION: Opens file specified by user from common dialog FileOpen, and the fills in 
**              the descriptor listbox with saved values 
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
void DoFileOpen(HANDLE hwnd)
{
    static OPENFILENAME of;
    HANDLE hOpenFile;
    UINT nItems;
    DWORD dwBytesRead;
    LRESULT nIndex;
    BYTE bTag,bNumBytes;
    PITEM_INFO pItemInfo;
    DWORD rc;


    of.lStructSize = sizeof(OPENFILENAME);
    of.hwndOwner = hwnd;
    of.hInstance = NULL;
    of.lpstrFilter = "HID Descriptor Files(*.hid)\0*.hid\0\0";
    of.lpstrCustomFilter = NULL;
    of.nMaxCustFilter = 0;
    of.nFilterIndex = 1;
    of.lpstrFile = gszFileName;
    of.nMaxFile = MAX_PATH;
    of.lpstrFileTitle = NULL;
    of.lpstrInitialDir = NULL;
    of.lpstrTitle = NULL;
    of.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST; 
    of.lpstrDefExt = "*.hid";
    of.lpTemplateName = NULL;


    if(rc = GetOpenFileName(&of) )
    {
        hOpenFile = CreateFile(gszFileName,GENERIC_READ,0,NULL,
                           OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL); 
        if( hOpenFile )
        {
            char szBuff[128],szTmp[64];
            int i;

            // Clear any current descriptor
            SendMessage(hwnd,WM_COMMAND,0,(LPARAM) CLEAR_BUTTON);


            // Get number of items in file from Header
            ReadFile(hOpenFile,&nItems,sizeof(DWORD),&dwBytesRead,NULL);    
            
            
            // Get the Items
            while( nItems-- )
            {
                
                if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
                {
                    ReadFile(hOpenFile,pItemInfo,sizeof(ITEM_INFO),&dwBytesRead,NULL);    
                    
                    //
                    // Now read in the data
                    //
                    // Mask off all but the tag bits
                    //
                    bTag = pItemInfo->bTag & ITEM_TAG_MASK;
                    gwReportDescLen++;
                    //
                    // Locate the tag in the Entity array. nIndex will equall offset
                    //  into the szEntity string array when found
                    for( nIndex =0; nIndex < ENTITY_INDEX; nIndex++ )
                        if( Entity[nIndex] == bTag )
                            break;
                     
                    //
                    // Create the textual representation of the Item
                    wsprintf(szBuff,"%s (%d)\t%02X ",szEntity[nIndex],(DWORD)pItemInfo->bParam[0],pItemInfo->bTag);

                    //
                    // Create the Hex portion of the display
                    
                    // Mask off all but number of bytes bits
                    bNumBytes = pItemInfo->bTag & ITEM_SIZE_MASK;
                    // a bit value of 3 (11) means we have 4 bytes of data
                    if( bNumBytes == 3 )
                        bNumBytes = 4;
                    for( i=0;i<bNumBytes;i++)
                    {
                        wsprintf(szTmp,"%02X ",pItemInfo->bParam[i]);
                        strcat(szBuff,szTmp);    
                    }
                    gwReportDescLen += bNumBytes;

                    nIndex = AddString(DESC_WINDOW,szBuff);
                    SendMessage(DESC_WINDOW,LB_SETITEMDATA,nIndex,(LPARAM) pItemInfo);
                }
                            
            }
      
            CloseHandle(hOpenFile);

        }//end if( hOpenFile )

    }//end If(GetOpenFileName)
    else
       rc =  CommDlgExtendedError();
            

}

/***************************************************************************************************
**
** DoFileSave()
**
** DESCRIPTION: Saves values from the descriptor list box to a file specified by the user from
**              common dialog FileSave
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
#define HID_FILE    1
#define LAVA_FILE   2
#define TXT_FILE    3

void DoFileSave(HANDLE hwnd)
{
    static OPENFILENAME of;
    HANDLE hSaveFile;
    PITEM_INFO pIF;
    DWORD dwBytesWritten;
    UINT nItems=0,nIndex=0;
    
    
    of.lStructSize = sizeof(OPENFILENAME);
    of.hwndOwner = hwnd;
    of.hInstance = NULL;
    of.lpstrFilter = "HID Descriptor File\0*.hid\0Intel LAVA Data File\0*.dcd\0Text File\0*.txt\0\0";
    of.lpstrCustomFilter = NULL;
    of.nMaxCustFilter = 0;
    of.nFilterIndex = 1;
    of.lpstrFile = gszFileName;
    of.nMaxFile = MAX_PATH;
    of.lpstrFileTitle = NULL;
    of.lpstrInitialDir = NULL;
    of.lpstrTitle = NULL;
    of.Flags = OFN_SHOWHELP ;//| OFN_PATHMUSTEXIST; //| OFN_FILEMUSTEXIST; 
    of.lpstrDefExt = "*.hid";
    of.lpTemplateName = NULL;
    

    if( GetSaveFileName(&of) )
    {

        hSaveFile = CreateFile(gszFileName,GENERIC_WRITE,0,NULL,
                           CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL); 
        
        if( hSaveFile != INVALID_HANDLE_VALUE )
        {
            
            if(nItems = SendMessage(DESC_WINDOW,LB_GETCOUNT,0,0))
            {
                
                
                switch( of.nFilterIndex )
                {
                    case HID_FILE:
                        // Header
                        WriteFile(hSaveFile,&nItems,sizeof(UINT),&dwBytesWritten,NULL);    
                        // Data
                        for(nIndex=0; nIndex < nItems; nIndex++)
                        {
                            pIF = (PITEM_INFO) SendMessage(DESC_WINDOW,LB_GETITEMDATA,nIndex,0);
                            WriteFile(hSaveFile,pIF,sizeof(ITEM_INFO),&dwBytesWritten,NULL);    
                        }
                        break;

                    case LAVA_FILE:
                        WriteLavaConfigFile(hSaveFile,nItems);
                        break;

                    case TXT_FILE:
                    {
                        char buff[80];  // width of a page
 
                        for(nIndex=0; nIndex < nItems; nIndex++)
                        {
                            SendMessage(DESC_WINDOW,LB_GETTEXT,nIndex,(LPARAM)buff);
                            strcat(buff,"\n");
                            WriteFile(hSaveFile,buff,strlen(buff),&dwBytesWritten,NULL);    
                        }
                        break;
                    }
            
                }// end switch()
            
            }// end if(nItems=)
      
            CloseHandle(hSaveFile);

        }//end if( hSaveFile )

        //
        // CreatFile failed form some reason, find out why
        else 
        {
            LPVOID lpErrorMessage;
            
                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,GetLastError(),
                              MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
                              (LPSTR) &lpErrorMessage,
                              0,NULL );
                MessageBox(NULL,lpErrorMessage,"File Save Error",MB_OK);
        }
    }//end If(GetOpenFileName)



}
/***************************************************************************************************
**
** WriteLavaConfigFile(HANDLE hSaveFile, int nItems)
**
** DESCRIPTION: Writes the Report desriptor in the Intle Lava .cfg format. This is done
**               in a seperate routine so that we can use it in more than one place.
**
**  PARAMETERS: HANDLE      - Handle to the file to write to
**              int         - Number of items in the list box
** 
**     RETURNS:
**
***************************************************************************************************/
char szLAVAHEADER[] = "00 00 DC DC 00 00 00 00 01 00 00 00\n";


void WriteLavaConfigFile(HANDLE hSaveFile, UINT nItems)
{
    PITEM_INFO  pIF;
    char        szBuff[30],szTmp[4];
    UINT        bNumBytes,i;
    DWORD       dwBytesWritten;
    UINT        nIndex=0;
    int         nByteCount=0;
    int         remainder;
        //
        // Write out the header info. 
        //
        // First line is FileIndex line. Static at this time
        //
        WriteFile(hSaveFile,szLAVAHEADER,strlen(szLAVAHEADER), &dwBytesWritten,NULL);

        //
        // Second line is Lava ConfigurationIndex. The only non static items (in this
        //  release) will be the ReportDescriptor size. 
        //
        wsprintf(szBuff,"14 00 09 00 %02X %02X 00 00\n",LOBYTE(gwReportDescLen),HIBYTE(gwReportDescLen));
        WriteFile(hSaveFile,szBuff,strlen(szBuff),&dwBytesWritten,NULL);

        //
        // Third line is the HIDDescriptor. The only item that will change is the ReportDescriptor
        //  length field. All the other fields should be the same for MOST devices.
        //
        wsprintf(szBuff,"09 01 00 01 00 01 02 %02X %02X\n",LOBYTE(gwReportDescLen),HIBYTE(gwReportDescLen));
        WriteFile(hSaveFile,szBuff,strlen(szBuff),&dwBytesWritten,NULL);
        //
        // Rest of the file is the ReportDescriptor
        //
        for(nIndex=0; nIndex < nItems; nIndex++)
        {
            pIF = (PITEM_INFO) SendMessage(DESC_WINDOW,LB_GETITEMDATA,nIndex,0);
            wsprintf(szBuff,"%02X ",pIF->bTag);
            nByteCount++;
            if( (remainder = nByteCount % 16) == 0 )
                strcat(szBuff,"\n");
            // Mask off all but number of bytes bits
            bNumBytes = pIF->bTag & ITEM_SIZE_MASK;
            // a bit value of 3 (11 binary) means we have 4 bytes of data
            if( bNumBytes == 3 )
                bNumBytes = 4;


            for( i=0;i<bNumBytes;i++)
            {
                nByteCount++;
                wsprintf(szTmp,"%02X ",pIF->bParam[i]);
                strcat(szBuff,szTmp);    
                if((remainder = nByteCount % 16)==0)
                    strcat(szBuff,"\n");
                
            }
            //if((remainder = nByteCount % 16)==0)
            //    strcat(szBuff,"\n");
            strcat(szBuff,"\0");
            WriteFile(hSaveFile,szBuff,strlen(szBuff),&dwBytesWritten,NULL);    
        }



}
/***************************************************************************************************
**
** DoFilePrint()
**
** DESCRIPTION: Prints the current contents of the DESC_WINDOW list box
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
void DoFilePrint(HANDLE hwnd)
{
    PRINTDLG pd;
    DOCINFO  di;
    TEXTMETRIC tm;

    int  nNumItems,i,y;
    int  nLineHeight, nDescColumn, nHexColumn;
    char szDescBuff[64],szTextBuff[64];

        pd.lStructSize  = sizeof(PRINTDLG);
        pd.hwndOwner    = hwnd;
        pd.hDevMode     = NULL;
        pd.hDevNames    = NULL;
        pd.hDC          = NULL;
        pd.Flags        = PD_NOPAGENUMS | PD_NOSELECTION | PD_RETURNDC;
        pd.nCopies      = 1;

        PrintDlg(&pd);

        GetTextMetrics(pd.hDC,&tm);
    
        nLineHeight = tm.tmHeight + tm.tmExternalLeading; 
        nHexColumn  = 40 * tm.tmAveCharWidth;
        nDescColumn = 5  * tm.tmAveCharWidth;

        di.cbSize      = sizeof(DOCINFO);
        di.lpszDocName = "HID";
        di.lpszOutput  = NULL;

        StartDoc(pd.hDC,&di); 
        StartPage(pd.hDC);

        nNumItems = SendMessage(DESC_WINDOW,LB_GETCOUNT,0,0);
    
    
        for(i=0; i< nNumItems; i++)
        {
            SendMessage(DESC_WINDOW,LB_GETTEXT,i,(LPARAM)szDescBuff);
        
            y = i*nLineHeight;
        
            strcpy(szTextBuff,strtok(szDescBuff,"\t"));
            TextOut(pd.hDC,nDescColumn,y+40,szTextBuff,strlen(szTextBuff));
            strcpy(szTextBuff,strtok(NULL,"\t"));
            TextOut(pd.hDC,nHexColumn,y+40,szTextBuff,strlen(szTextBuff));
        }    

        EndPage   (pd.hDC);
        EndDoc    (pd.hDC);
        DeleteDC  (pd.hDC);


}

/*******************************************************************************
**
** SendHIDDescriptor.
**
** DESCRIPTION: Sends the current HID descriptor to the HID driver.
**              
**              
**  PARAMETERS: pHID    -   Pointer to a memory block which contains the HID
**                          descriptor bytes
**              pSize   -   Size of the memory block (in bytes)
**
**              pDevID      - Variable to recievce device ID
**
**              pDevHandle  - Variable to recieve device handle
** 
**     RETURNS: int     -   Ordinal of device HID driver created
**                          or ERR_CREATEDEVICE if device could not
**                          be created
**
*******************************************************************************/
int SendHIDDescriptor(PUCHAR pHID, PULONG pSize, DWORD *pDevID, ULONG *pDevHandle) 
{ 
    ULONG   Status = FALSE; 
    HANDLE  hHIDDevice; 
    ULONG   dwDeviceID_and_Handle[2];


// TESTING TESTING TESTING !!!!   
    static DWORD i=1;
    static DWORD handle;
    *pDevID = i++;
    *pDevHandle = (HANDLE) handle++;
    return TRUE;

// TESTING TESTING TESTING !!!!

	dwDeviceID_and_Handle[0]=0;
	dwDeviceID_and_Handle[1]=0;



    //
	// Open the HID pump Device
	//
	hHIDDevice = CreateFile(TEST_DEVICE, 
                         0,
                         FILE_SHARE_READ | FILE_SHARE_WRITE, 
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL);
                         
    if( hHIDDevice == INVALID_HANDLE_VALUE )
        MessageBox(NULL,"CreatFile(HID_DEVICE) Failed!","DT Error",MB_ICONEXCLAMATION | MB_OK);

    //
	// Send	the descriptor 
	//
	else 
    {
        Status = DeviceIoControl(hHIDDevice, 
                                  (ULONG)IOCTL_ADD_DEVICE,
                                  pHID,
                                  *pSize,
                                  &dwDeviceID_and_Handle,
                                  sizeof(dwDeviceID_and_Handle), 
                                  pSize,
                                  (LPOVERLAPPED) NULL); 
        if( !Status ) 
        {
			char buff[128];

			wsprintf(buff, "DeviceIoControl(IOCTL_ADD_DEVICE) Failed! Error: %d",GetLastError() );
			MessageBox(NULL,buff,"DT Error",MB_ICONEXCLAMATION | MB_OK);
		}

		//
		// Save the DeviceID and Handle of the device created by the HID.
		// 
		else
        {
            char buff[128];

            *pDevID = dwDeviceID_and_Handle[0];
            *pDevHandle = dwDeviceID_and_Handle[1];
        
            //wsprintf(buff,"DevID = %d DevObj=%08X",dwDeviceID_and_Handle[0],dwDeviceID_and_Handle[1]);
            //MessageBox(NULL,buff,"SendHIDDescriptor()",MB_OK);
        
        }
        
        CloseHandle(hHIDDevice); 


    }
    
    return Status;
}

/*******************************************************************************
**
** SendHIDData(BYTE *pPacket, ULONG SizeIn, PULONG pSizeOut)
**
** DESCRIPTION: Send Data to the HID driver via IOCTL's
**              
**  PARAMETERS: pPacket	- Pointer to the data
**				SizeIn	- Number of bytes in the packet
**				pSizeOut- Varaible to receive number of bytes actually sent
**              hDevice - Handle to device data is meant for
**
**     RETURNS:
**
*******************************************************************************/
ULONG SendHIDData(SENDDATA_PACKET *pPacket, ULONG SizeIn, DWORD *pSizeOut) 
{ 
    ULONG   Status = TRUE; 
    HANDLE  hHIDDevice; 
 

//TESTING!!!!!!!!
    return TRUE;
//TESTING!!!!!!!!

    hHIDDevice = CreateFile(TEST_DEVICE,
                         0,
                         FILE_SHARE_READ | FILE_SHARE_WRITE, 
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL); 

    if( hHIDDevice == INVALID_HANDLE_VALUE )
    {
        MessageBox(NULL,"CreatFile(HID_DEVICE) Failed!","DT Error",MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }
    if(hHIDDevice) 
    {
        Status = DeviceIoControl(hHIDDevice, 
                                  (ULONG)IOCTL_SET_DATA,
                                  pPacket,
                                  SizeIn,
                                  NULL,
                                  0, 
                                  pSizeOut,
                                  (LPOVERLAPPED) NULL); 
        if( !Status ) 
            MessageBox(NULL,"DeviceIoControl(IOCTL_SET_DATA) Failed!","DT Error",MB_ICONEXCLAMATION | MB_OK);

        CloseHandle(hHIDDevice); 

    }
    return Status;
}

/*******************************************************************************
**
** KillHIDDevice(int nDeviceID)
**
** DESCRIPTION: Kill a HID device
**              
**  PARAMETERS: hDevice - Handle to device to kill
**
**     RETURNS: TRUE    - All went as planned
**              FALSE   - Error occured
**
*******************************************************************************/
ULONG KillHIDDevice(SENDDATA_PACKET *pPacket)
{

    ULONG   Status = TRUE; 
    HANDLE  hHIDDevice; 
    DWORD   dwBytesReturned;

    //TESTING!!!!!!!
    return TRUE;

    hHIDDevice = CreateFile(TEST_DEVICE,
                         0,
                         FILE_SHARE_READ | FILE_SHARE_WRITE, 
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL); 

    if( hHIDDevice == INVALID_HANDLE_VALUE )
    {
        MessageBox(NULL,"CreatFile(HID_DEVICE) Failed!","DT Error",MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }

    if(hHIDDevice) 
    {
        Status = DeviceIoControl(hHIDDevice, 
                                  (ULONG)IOCTL_DELETE_DEVICE,
                                  pPacket,
                                  sizeof(SENDDATA_PACKET),
                                  NULL,
                                  0,
                                  &dwBytesReturned,
                                  (LPOVERLAPPED) NULL); 
        if( !Status ) 
            MessageBox(NULL,"DeviceIoControl(IOCTL_DELETE_DEVICE) Failed!","DT Error",MB_ICONEXCLAMATION | MB_OK);

        CloseHandle(hHIDDevice); 

    }

    return Status;

}



/*******************************************************************************
**
** SendDataDlgProc
**
** DESCRIPTION: Dialog procedure for the Device Data dialogs
**
**
**  PARAMETERS: lParam - Pointer to a DeviceInfo structure. 
**              
**
**     RETURNS:
**
*******************************************************************************/

                    
BOOL WINAPI SendDataDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PDEVICEINFO pdiInstance;

    switch( msg )
    {

        case WM_INITDIALOG:
        {
            char szBuff[128];
            int i;

            //
            // Save instance information
            pdiInstance = (PDEVICEINFO) lParam;
            SetWindowLong(hDlg, DWL_USER, lParam);
            
            //
            // Set the Window title
            wsprintf( szBuff,"Device%d Handle=%08X",pdiInstance->nDeviceID,pdiInstance->hDevice);
            SetWindowText(hDlg,szBuff);
            
            //
            // Set up the spin control
            SendMessage(GetDlgItem(hDlg,IDC_BYTESLIDER),UDM_SETRANGE,0,MAKELONG(10,1));
            SetWindowText(GetDlgItem(hDlg,IDC_NUMBYTES),"1");
            //
            // Set all of the edit controls to 0
            //  and limit text to two hex characters
            for(i=IDC_BYTE0;i<=IDC_BYTE9;i++)
            {
               HWND hwndEdit;
                hwndEdit = GetDlgItem(hDlg,i);
                SetWindowText(hwndEdit,"0");
                SendMessage(hwndEdit,EM_LIMITTEXT,2,0);
            }

            return TRUE;
        }

        case WM_NOTIFY:
        {
            //
			// Depending on whether or not the UP or DOWN arrow of
            //  the UPDOWN control was pressed, set the attribute
            //  of the byte entry EditWindows to Read only or Read/Write.
			// 
			case IDC_BYTESLIDER:
            {
                NM_UPDOWN *nmud = (NM_UPDOWN *) lParam;

		        ///
				// If the DOWN arrow was pressed set the attribute of the
                //  EditWindow who's ID corresponds to the base EditWindow ID (IDC_BYTE0)
                //  plus the current position of the UPDOWN control - 1 to Read only. 
				//
				if( nmud->iDelta < 0 )
                {
                    //
                    // Only deal with Edit Controls greater than 1. We always want to 
                    //  be able to send at least 1 byte.
                    if( nmud->iPos > 1 )
                    {
                        SendMessage(GetDlgItem(hDlg,IDC_BYTE0+nmud->iPos-1),EM_SETREADONLY,TRUE,0);
                        SetWindowText(GetDlgItem(hDlg,IDC_BYTE0+nmud->iPos-1),"0");
                    }
                }
                //
                // Else UP arrow was pressed, so set the EditWindow who's ID corresponds to the base
                //  EditWindow ID (IDC_BYTE0) plus the current position of the UPDOWN control to 
                //  Read/Write. 
                else
                    SendMessage(GetDlgItem(hDlg,IDC_BYTE0+nmud->iPos),EM_SETREADONLY,FALSE,0);

                return TRUE;
            }

        } // end WM_NOTIFY
            
        case WM_COMMAND:
        {
            PDEVICEINFO pdiInfo;

            pdiInfo = (PDEVICEINFO) GetWindowLong(hDlg,DWL_USER);
  
            switch( LOWORD(wParam))
            {
                
                case IDC_KILL:
                {    
                    SENDDATA_PACKET HIDDataPacket;
                    
                    // Kill the device
                    HIDDataPacket.hDevice = pdiInfo->hDevice;
                    memset(HIDDataPacket.bData,0,MAX_DATA);
                    KillHIDDevice(&HIDDataPacket);
                     
                    // Free the instance info
                    GlobalFree((HANDLE)GetWindowLong(hDlg,DWL_USER));

                    DestroyWindow(hDlg);
                    return TRUE;
                }
                case IDC_SEND:
                {
                    int i;
                    char szHexNumber[4];
           			DWORD Sent;
                    SENDDATA_PACKET SendDataPacket;

                    //TESTING!!!!
                    char buff[128];

                    //
                    // The first element in the packet is the DeviceObject handle.
                    //
                    SendDataPacket.hDevice = pdiInfo->hDevice;
                    
					//
					// Get the bytes from the Edit windows
					//
					for(i=0;i<MAX_DATA;i++)
                    {
                        GetDlgItemText(hDlg,IDC_BYTE0+i,szHexNumber,sizeof(szHexNumber));
                        // Convert from ASCII HEX to binary
                        sscanf(szHexNumber,"%2x",(unsigned)&SendDataPacket.bData[i]);
                    }

					//
					//Send it
					//
					SendHIDData(&SendDataPacket,sizeof(SENDDATA_PACKET),&Sent); 
				    
                    //wsprintf(buff,"DeviceID: %d PacketSize: %d",pdiInfo->nDeviceID,i);
                    //MessageBox(NULL,buff,"Testing",MB_OK);

                    return TRUE;
				
			    }


                case IDC_GETDATA:
                {
            	    BYTE    bData[MAX_DATA];
                    ULONG   Status = TRUE; 
                    DWORD   SizeOut = MAX_DATA;
                    HANDLE  hHIDDevice; 
                    ULONG   hDevice;
                    int     nPacketSize;
                    SENDDATA_PACKET HIDDataPacket;
                    SENDDATA_PACKET *pHIDDataPacket;
					
                    
                    pHIDDataPacket = &HIDDataPacket;
                    //
                    // Get the handle to the DeviceObject
                    HIDDataPacket.hDevice = pdiInfo->hDevice;
                    memset(HIDDataPacket.bData,0,MAX_DATA);
                    
                    //
					// Get the number of bytes in a packet
					//
					nPacketSize = SendMessage(GetDlgItem(hDlg,IDC_BYTESLIDER),UDM_GETPOS,0,0);
                    

                    hHIDDevice = CreateFile(TEST_DEVICE,
                                         0,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE, 
                                         NULL,
                                         OPEN_EXISTING,
                                         0,
                                         NULL); 

                    if( hHIDDevice == INVALID_HANDLE_VALUE )
                    {
                        MessageBox(NULL,"CreatFile(HID_DEVICE) Failed!","DT Error",MB_ICONEXCLAMATION | MB_OK);
                        return FALSE;
                    }
                    else //if(hHIDDevice) 
                    {
                        Status = DeviceIoControl(hHIDDevice, 
                                                  (ULONG)IOCTL_GET_DATA,
                                                  pHIDDataPacket,
                                                  sizeof(SENDDATA_PACKET),
                                                  &bData,
                                                  nPacketSize, 
                                                  &SizeOut,
                                                  (LPOVERLAPPED) NULL); 
                        if( !Status ) 
                            MessageBox(NULL,"DeviceIoControl(IOCTL_GET_DATA) Failed!","DT Error",MB_ICONEXCLAMATION | MB_OK);

                        CloseHandle(hHIDDevice); 

                        if( Status )
                        {
                            char Buff[(MAX_DATA*3)+1];
                            char tmpbuff[4];
                            DWORD i;
                            

                            memset(Buff,'\0',sizeof(Buff));

                            for(i=1;i<SizeOut;i++)
                            {
                                                              
                                wsprintf(tmpbuff,"%02X ",bData[i]);
                                strcat(Buff,tmpbuff);
                            }
                            
                            SetWindowText(GetDlgItem(hDlg,IDC_GETDATA_TEXT),Buff);
                        
                        }    
                    
                    }
                    return Status;
                
                }//edn CASE IDC_GETDATA
                    

            }// end switch(lParam)

        
        }// end WM_COMMAND

    }// end switch(msg)

    return FALSE;
}





/*******************************************************************************
**
** ListBoxWindowProc.
**
** DESCRIPTION: Subclass window procedure for the HID Descriptor Text window.
**              We want to able to recognize right mouse button events when the 
**              mouse is over this particular window.
**              
**              
**  PARAMETERS: HWND hWnd, Window handle. 
**              UINT Message, Window Message.
**              UINT uParam, Unsigned message parameter.
**              LPARAM lParam, Signed message parameter.
**
**     RETURNS:
**
*******************************************************************************/
LPARAM WINAPI ListBoxWindowProc(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam)
{

    POINT p;
    LRESULT item;
    static HMENU hMenu;
    static BOOL fMenuOpen=FALSE;

    switch(Message)
    {
        
        //
        // On RightButton Down, set the focus to the 
        //  item under the cursor, and display a popup menu
        case WM_RBUTTONDOWN:
        {
  
            p.x = LOWORD(lParam);
            p.y = HIWORD(lParam);
            

            item = SendMessage(DESC_WINDOW,LB_ITEMFROMPOINT,0,MAKELPARAM(p.x,p.y));
            SendMessage(DESC_WINDOW,LB_SETCURSEL,item,0);
            
            ClientToScreen(ghWnd,&p);
            hMenu = CreatePopupMenu();                        
        
            fMenuOpen = TRUE;

            //
            // Set the Insert menu item to be checked or unchecked depending
            //  on the state of gfInsert
            if( !gfInsert )
                AppendMenu(hMenu,MF_ENABLED,IDM_INSERT,"Insert Mode");
            else
                AppendMenu(hMenu,MF_CHECKED,IDM_INSERT,"Insert Mode");
                 
            AppendMenu(hMenu,MF_ENABLED,IDM_DELETE,"Delete Item"); 

            TrackPopupMenu(hMenu,                             
                           TPM_LEFTBUTTON | TPM_RIGHTBUTTON,    
                           p.x+DESC_X,                    
                           p.y+DESC_Y,                    
                           0,                                 
                           hWnd,                              
                           NULL);                             
            
            break;
        }
        
        case WM_COMMAND:
        	switch(LOWORD(uParam))
            {
                case IDM_INSERT:
                    gfInsert ^= TRUE; // Toggle the state of the gfInsert flag
                    DestroyMenu(hMenu);                               
                    fMenuOpen = FALSE;
                    hMenu = NULL;
                    return TRUE;

                case IDM_DELETE:
                    PostMessage(ghWnd,WM_VKEYTOITEM,VK_DELETE,(LPARAM)hWnd);
                    DestroyMenu(hMenu);                               
                    fMenuOpen = FALSE;
                    hMenu = NULL;
                    return TRUE;

            }

            break;
    }

    return( CallWindowProc(gOrgListBoxProc, hWnd,Message, uParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\inc\bingen.h ===
#ifndef __BINGEN_H__
#define __BINGEN_H__

/*
// Disable the warning telling us that a conversion is being performed.  Only way to 
//   get a clean compile after many attempts with type casts to resolve the issue
*/

#pragma warning(disable: 4200)

/*
// Typedefs and functions that are to be visible to outside routines
*/

#include <pshpack4.h>

typedef struct tagCollectionOptions {

    ULONG ulMaxCollectionDepth;
    ULONG ulTopLevelCollections;
    ULONG ulMinCollectionItems;
    ULONG ulMaxCollectionItems;
    ULONG ulMaxReportIDs;
    BOOL fUseReportIDs;

} COLLECTION_OPTIONS;

typedef struct tagUsageOptions {

    ULONG ulMinUsagePage;
    ULONG ulMaxUsagePage;
    ULONG ulMinUsage;
    ULONG ulMaxUsage;

} USAGE_OPTIONS;

typedef struct tagReportOptions {

    BOOL fCreateDataFields;
    BOOL fCreateButtonBitmaps;
    BOOL fCreateArrays;
    BOOL fCreateBufferedBytes;
    
    ULONG ulMinReportSize;
    ULONG ulMaxReportSize;
    ULONG ulMinReportCount;
    ULONG ulMaxReportCount;
    
    ULONG ulMinNumButtons;
    ULONG ulMaxNumButtons;

    ULONG ulMinArraySize;
    ULONG ulMaxArraySize;
    ULONG ulMinArrayCount;
    ULONG ulMaxArrayCount;
    ULONG ulMinArrayUsages;
    ULONG ulMaxArrayUsages;

    ULONG ulMinBufferSize;
    ULONG ulMaxBufferSize;

} REPORT_OPTIONS;

typedef struct tagGenOptions {

    LPCSTR filename;

    COLLECTION_OPTIONS copts;
    USAGE_OPTIONS uopts;
    REPORT_OPTIONS ropts;

} GENERATE_OPTIONS, *PGENERATE_OPTIONS;

/*
// ENUM typedef for the report types.  This is used by files other than
//    generate.c so it needs to be defined globally
*/

typedef enum {CT_APPLICATION, CT_PHYSICAL, CT_LOGICAL } COLLECTION_TYPE;
typedef enum {FD_DATA, FD_ARRAY, FD_BUFFER, FD_BUTTONS, FD_CONSTANT } FIELD_TYPE;
typedef enum {MI_COLLECTION, MI_DATA } MAINITEM_TYPE;


typedef struct _usageList {
    USAGE   UsagePage;
    BOOL    IsMinMax;

    union {

        struct {
            USAGE   UsageMin;
            USAGE   UsageMax;
        };

        USAGE   Usage;
    };
} USAGE_LIST, *PUSAGE_LIST;

typedef struct tagMainItem {
    MAINITEM_TYPE miType;
    USAGE       CommonUsagePage;
    PUSAGE_LIST UsageList;
    ULONG       UsageListLength;
    union {
        struct {
            COLLECTION_TYPE cType;
            ULONG ulNumCompositeItems;
            struct tagMainItem *ComposedItems[];
        };

        struct { 
            HIDP_REPORT_TYPE ReportType;
            FIELD_TYPE  fType;
            ULONG       ulReportID;
            ULONG       ulReportSize;
            ULONG       ulReportCount;
            BOOL        IsLogMinSigned;
            union {
                LONG    lLogicalMinimum;
                ULONG   ulLogicalMinimum;
            };

            union {
                LONG    lLogicalMaximum;
                ULONG   ulLogicalMaximum;
            };

            LONG        lPhysicalMinimum;
            LONG        lPhysicalMaximum;
            LONG        lUnit;
            LONG        lExponent;
            BOOL        fAbsolute;
            BOOL        fWrap;
            BOOL        fLinear;
            BOOL        fPreferred;
            BOOL        fNull;
            BOOL        fVolatile;
            BOOL        fBuffered;
        };
    };
} MAIN_ITEM, *PMAIN_ITEM;


typedef struct _RepDesc {

    ULONG               NumberCollections;
    struct tagMainItem  *Collections[];

} REPORT_DESC, *PREPORT_DESC;

#include <poppack.h>

/*
// Typedefs to our exported functions so that a exe that gets the procedure
//    addresses at run-time has variable types that it can declare to get those
//    addresses.
*/

typedef BOOL  (__stdcall *SETOPTIONS)(VOID);
typedef VOID  (__stdcall *GETOPTIONS)(PGENERATE_OPTIONS);
typedef VOID  (__stdcall *GETDEFOPTIONS)(PGENERATE_OPTIONS);
typedef BOOL  (__stdcall *GENBIN)(LPCSTR, PGENERATE_OPTIONS);
typedef BOOL  (__stdcall *GENREP)(PGENERATE_OPTIONS, PREPORT_DESC *);
typedef VOID  (__stdcall *FREEREP)(PREPORT_DESC);
typedef VOID  (__stdcall *FREEMEM)(PUCHAR);
typedef BOOL  (__stdcall *OUTTOMEM)(PREPORT_DESC, PUCHAR *, PULONG);
typedef BOOL  (__stdcall *OUTTODISK)(PREPORT_DESC, LPCSTR);
typedef BOOL  (__stdcall *GENCAPS)(PREPORT_DESC, ULONG, PHIDP_CAPS);

typedef BOOL  (__stdcall *GENVCAPS)(PREPORT_DESC, ULONG, HIDP_REPORT_TYPE, PHIDP_VALUE_CAPS *, PUSHORT);
typedef VOID  (__stdcall *FREEVCAPS)(PHIDP_VALUE_CAPS);

typedef BOOL  (__stdcall *GENBCAPS)(PREPORT_DESC, ULONG, HIDP_REPORT_TYPE, PHIDP_BUTTON_CAPS *, PUSHORT);
typedef VOID  (__stdcall *FREEBCAPS)(PHIDP_BUTTON_CAPS);

typedef BOOL  (__stdcall *GENLNODES)(PREPORT_DESC, ULONG, PHIDP_LINK_COLLECTION_NODE *, PUSHORT);
typedef VOID  (__stdcall *FREELNODES)(PHIDP_LINK_COLLECTION_NODE);


/*
// Exported functions
*/

BOOL __stdcall
BINGEN_GenerateBIN(
    IN LPCSTR           filename, 
    IN GENERATE_OPTIONS *opts
);

BOOL __stdcall
BINGEN_GenerateReportDescriptor(
    IN  GENERATE_OPTIONS *opts,     
    OUT PREPORT_DESC     *ReportDesc
);

BOOL __stdcall
BINGEN_OutputReportDescriptorToMemory(
    IN  PREPORT_DESC    pRD,
    OUT PUCHAR          *ReportBuffer,
    OUT PULONG          ReportBufferLength
);

BOOL __stdcall
BINGEN_OutputReportDescriptorToDisk(
    IN  PREPORT_DESC    pRD,
    OUT LPCSTR          filename
);

VOID __stdcall
BINGEN_FreeReportDescriptor(
    PREPORT_DESC    pRD
);

VOID __stdcall
BINGEN_FreeReportBuffer(
    PUCHAR  ReportBuffer
);

BOOL __stdcall
BINGEN_SetOptions(
    VOID
);

VOID __stdcall
BINGEN_GetOptions(
    OUT PGENERATE_OPTIONS   options
);

VOID __stdcall
BINGEN_GetDefaultOptions(
    OUT PGENERATE_OPTIONS   options
);

BOOL __stdcall
BINGEN_GenerateCaps(
    IN  PREPORT_DESC    pRD,
    IN  ULONG           TLCNum,
    OUT PHIDP_CAPS      Caps
);

BOOL __stdcall
BINGEN_GenerateValueCaps(
    IN  PREPORT_DESC        pRD,
    IN  ULONG               TLCNum,
    IN  HIDP_REPORT_TYPE    ReportType,
    OUT PHIDP_VALUE_CAPS    *ValueCaps,
    OUT PUSHORT             NumValueCaps
);
/*++

Routine Description:

        This allocates space for and fills in a value caps list that
           corresponds to the report descriptor structure that is input.  A 
           caller of this routine must use BINGEN_FreeValueCaps to
           insure the use of the proper corresponding freeing routine.

Arguments:

    pRD   - Report descriptor structure from which the value caps list is to 
                be generated
    
    TLCNum - A one-based index of the top-level collection to generate the list from
             Remember a report descriptor structure can have have multiple TLCs
             where each one would be treated as a separate device by HIDCLASS and
             so there exists a unique value caps list per TLC

    ReportType - Report type for which to generate the value caps structure

    ValueCaps  - Function allocated list of value caps structures

    NumCaps - Number of value caps structures in the list

Return Value: 
    TRUE  if list creation succeeded
    FALSE otherwise - ValueCaps = NULL and NumCaps = 0 in this case

--*/

VOID __stdcall
BINGEN_FreeValueCaps(
    IN  PHIDP_VALUE_CAPS    ValueCaps
);
/*++

Routine Description:

        This routine frees a list of value caps that that was allocated by 
           the BINGEN_GenerateValueCaps routine since the DLL may use a
           different set of allocation routines than the application which 
           uses the DLL.

Arguments:

    ValueCaps - The list of value caps to free

Return Value: 
--*/

BOOL __stdcall
BINGEN_GenerateButtonCaps(
    IN  PREPORT_DESC        pRD,
    IN  ULONG               TLCNum,
    IN  HIDP_REPORT_TYPE    ReportType,
    OUT PHIDP_BUTTON_CAPS   *ButtonCaps,
    OUT PUSHORT             NumButtonCaps
);
/*++

Routine Description:

        This allocates space for and fills in a HIDP_BUTTON_CAPS list that
           corresponds to the report descriptor structure that is input.  A 
           caller of this routine must use BINGEN_FreeButtonCaps to
           insure the use of the proper corresponding freeing routine.

Arguments:

    pRD   - Report descriptor structure from which the button caps list is to 
                be generated
    
    TLCNum - A one-based index of the top-level collection to generate the list from
             Remember a report descriptor structure can have have multiple TLCs
             where each one would be treated as a separate device by HIDCLASS and
             so there exists a unique button caps list per TLC

    ReportType - Report type for which to generate the button caps structure

    ValueCaps  - Function allocated list of button caps structures

    NumCaps - Number of button caps structures in the list

Return Value: 
    TRUE  if list creation succeeded
    FALSE otherwise - ButtonCaps = NULL and NumCaps = 0 in this case

--*/

VOID __stdcall
BINGEN_FreeButtonCaps(
    IN  PHIDP_BUTTON_CAPS   ButtonCaps
);
/*++

Routine Description:

        This routine frees a list of value caps that that was allocated by 
           the BINGEN_GenerateButtonCaps routine since the DLL may use a
           different set of allocation routines than the application which 
           uses the DLL.

Arguments:

    ButtonCaps - The list of button caps to free

Return Value: 
--*/

BOOL __stdcall
BINGEN_GenerateLinkCollectionNodes(
    IN  PREPORT_DESC                pRD,
    IN  ULONG                       TLCNum,
    OUT PHIDP_LINK_COLLECTION_NODE *Nodes,
    OUT PUSHORT                     NumNodes
);
/*++

Routine Description:

        This allocates space for and fills in a link collection node list that
           corresponds to the report descriptor structure that is input.  A 
           caller of this routine must use Bingen_FreeLinkCollectionNodes to
           insure the use of the proper corresponding freeing routine.

Arguments:

    pRD   - Report descriptor structure from which the node list is to be
                generated
    
    TLCNum - A one-based index of the top-level collection to generate the list from
             Remember a report descriptor structure can have have multiple TLCs
             where each one would be treated as a separate device by HIDCLASS and
             so there exists a unique LinkCollectionNode list per TLC

    Nodes  - Function allocated list of link collection node structures

    NumNodes - Number of link collection nodes in the list

Return Value: 
    TRUE  if list creation succeeded
    FALSE otherwise - Nodes == NULL and NumNodes == 0 in this case

--*/

VOID __stdcall
BINGEN_FreeLinkCollectionNodes(
    IN  PHIDP_LINK_COLLECTION_NODE Nodes
);
/*++

Routine Description:

        This routine frees a list of link collection nodes that was allocated
           by Bingen_GenerateLinkCollectionNodes.  There is a separate free
           routine since the DLL may use a different set of allocation routines
           than the application which uses the DLL.

Arguments:

    Nodes - The list of collection nodes to free up

Return Value: 

--*/


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\dt\dt.h ===
/*******************************************************************************
**
**      MODULE: "DT.H".
**
**
** DESCRIPTION: Include file for DT.C.
**
**
**      AUTHOR: Daniel Dean, John Pierce.
**
**
**
**     CREATED:
**
**
**
**
** (C) C O P Y R I G H T   D A N I E L   D E A N   1 9 9 6.
*******************************************************************************/
#ifndef __DT_H__
#define __DT_H__

#define SUCCESS            0
#define FAILURE            1
#define EXITERROR          -1


#define IDM_PAGES          (WM_USER + 2371)


#define APPCLASS           "DT"
#define APPTITLE           "HID Report Descriptor Tool"
#define MAIN_ICON          "DT"
#define BACKGROUND_BRUSH   COLOR_MENU+1//RGB(128,128,128)

#define DEBUGSTOP _asm  int 3

#define WM_RESTORE  (WM_USER +1763)



LRESULT WINAPI WndProc(HWND, UINT, WPARAM, LPARAM);



#define ITEM(x, y) (x | y)

#define ITEM_SIZE_MASK      0x3
#define ITEM_TAG_MASK       0xFC

#define MAX_DESC_ENTRY		64				// Max characters for a descriptor entry in the list box

// Entity item tags
#define COLLECTION                  0xA0
#define END_COLLECTION              0xC0
#define INPUT                       0x80
#define OUTPUT                      0x90
#define FEATURE                     0xB0
// Entity Attribute item tags
#define USAGE_PAGE                  0x04
#define LOGICAL_EXTENT_MIN          0x14
#define LOGICAL_EXTENT_MAX          0x24
#define PHYSICAL_EXTENT_MIN         0x34
#define PHYSICAL_EXTENT_MAX         0x44
#define UNIT_EXPONENT               0x54
#define UNIT                        0x64
#define REPORT_SIZE                 0x74
#define REPORT_ID                   0x84
#define REPORT_COUNT                0x94
#define PUSH                        0xA4
#define POP                         0xB4

// Control attribute item tags
#define USAGE                       0x08
#define USAGE_MIN                   0x18
#define USAGE_MAX                   0x28
#define DESIGNATOR_INDEX            0x38
#define DESIGNATOR_MIN              0x48
#define DESIGNATOR_MAX              0x58
#define STRING_INDEX                0x68
#define STRING_MIN                  0x78
#define STRING_MAX                  0x88

#define SET_DELIMITER				0xA9
// A bogus item tag
#define UNDEFINED_TAG               0xFF


// Bit masks
#define DATA_SIZE_MASK 0x03

// Flag used by AddString() to indicate we insert at index gotten
//  from LB_GETCURSEL
#define DONT_CARE   -1

//
// ID's for popup memnu
#define IDM_INSERT                  0x9000
#define IDM_ADD                     0x9001
#define IDM_DELETE                  0x9002



//
// Structure created in the GetXXXVal() functions below and stored
//  in the ITEMDATA area for the list box member associated with the
//  hex representation of a Descriptor Entity.
typedef struct tagItemStruct{
    BYTE bTag;              // the built up tag
    BYTE bParam[4];         // up to 4 bytes of parameter info

}ITEM_INFO,* PITEM_INFO;


typedef struct tagDeviceInfo{

	ULONG	nDeviceID;		// Number appended to device string in reg
	ULONG   hDevice;		// Handle of the device

}DEVICEINFO,*PDEVICEINFO;


//
// Maximum data bytes in a packet
#define MAX_DATA 10

//
// Structure defining a packet sent to the SendData IOCTL
//
typedef struct tagSendData{

    ULONG   hDevice;
    BYTE    bData[MAX_DATA];

}SENDDATA_PACKET, *PSENDDATA_PACKET;


typedef struct _LAVAConfigIndexInfo{
    
    WORD wStartOffset;
    WORD wHIDLen;
    WORD wReportLen;
    WORD wPhysicalLen;
    
} LAVA_CONFIG,*PLAVA_CONFIG;


//
// Globals
//
#ifdef DEFINE_GLOBALS

HANDLE  ghInst = NULL;
HWND    ghWnd  = NULL;

PCHAR szEntity[] = {"USAGE",                // 0
                    "USAGE_PAGE",           // 1
                    "USAGE_MINIMUM",        // 2
                    "USAGE_MAXIMUM",        // 3
                    "DESIGNATOR_INDEX",     // 4
                    "DESIGNATOR_MINIMUM",   // 5
                    "DESIGNATOR_MAXIMUM",   // 6
                    "STRING_INDEX",         // 7
                    "STRING_MINIMUM",       // 8 
                    "STRING_MAXIMUM",       // 9
                    "COLLECTION",           // 10
                    "END_COLLECTION",       // 11
                    "INPUT",                // 12
                    "OUTPUT",               // 13
                    "FEATURE",              // 14
                    "LOGICAL_MINIMUM",      // 15
                    "LOGICAL_MAXIMUM",      // 16
                    "PHYSICAL_MINIMUM",     // 17
                    "PHYSICAL_MAXIMUM",     // 18
                    "UNIT_EXPONENT",        // 19
                    "UNIT",                 // 20
                    "REPORT_SIZE",          // 21
                    "REPORT_ID",            // 22
                    "REPORT_COUNT",         // 23
                    "PUSH",                 // 24
                    "POP",                  // 25
                    "SET_DELIMITER",	    // 26
					"UNDEFINED_TAG"};       // 27

UCHAR Entity[] = {USAGE,
                  USAGE_PAGE,
                  USAGE_MIN,
                  USAGE_MAX,
                  DESIGNATOR_INDEX,
                  DESIGNATOR_MIN,
                  DESIGNATOR_MAX,
                  STRING_INDEX,
                  STRING_MIN,
                  STRING_MAX,
                  COLLECTION,
                  END_COLLECTION,
                  INPUT,
                  OUTPUT,
                  FEATURE,
                  LOGICAL_EXTENT_MIN,
                  LOGICAL_EXTENT_MAX,
                  PHYSICAL_EXTENT_MIN,
                  PHYSICAL_EXTENT_MAX,
                  UNIT_EXPONENT,
                  UNIT,
                  REPORT_SIZE,
                  REPORT_ID,
                  REPORT_COUNT,
                  PUSH,
                  POP,
				  SET_DELIMITER,
                  UNDEFINED_TAG};

#define ENTITY_INDEX 27
             
                    
UINT    gEditVal=0;         // Value returned from EditBox
BYTE    gCollectionVal=0;   // Value returned from Collection dialog
WORD    gUnitVal=0;         // Value returned from Unit dialog
BYTE    gExpVal=0;          // Value returned from Exponent dialog
BYTE    gUsagePageVal=0;    // Value returned from UsagePage dialog
BYTE	gSetDelimiterVal=0;	// Value returned from GetSetDelimiter dialog
WORD    gMainItemVal=0;     // Value returned from Input dialog

int     gfInsert = FALSE;   // Flag to tell whether we insert ot add strings
                            //  to the ListBoxes
WORD    gwReportDescLen=0;  // Length in bytes of the ReportDescriptor;

#else

extern HANDLE   ghInst;
extern HWND     ghWnd;
extern PCHAR    szEntity[];
extern UCHAR    Entity[];

extern int      gEditVal;        
extern BYTE     gCollectionVal;   
extern WORD     gUnitVal;
extern BYTE     gExpVal;
extern BYTE     gUsagePageVal;
extern BYTE		gSetDelimiterVal;
extern WORD		gMainItemVal;    

extern int      gfInsert;

extern WORD     gwReportDescLen; 

#endif


////////////////////////////////////////////////////////////////////////////////
//
// Function Proto's
//
LPARAM  WINAPI WindowProc(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam);
LPARAM  WMCommand(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam);
LPARAM  WMSysCommand(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam);
LPARAM  WMCreate(HWND hWnd, UINT uParam);
LPARAM  WMClose(HWND hWnd);
LPARAM  WMSize(HWND hWnd, LPARAM lParam);
int     SendHIDDescriptor(PUCHAR pHID, PULONG pSize, DWORD *pDevID, ULONG *pDevHandle); 
ULONG   SendHIDData(SENDDATA_PACKET *pPacket, ULONG SizeIn, DWORD *pSizeOut) ;
ULONG   KillHIDDevice(SENDDATA_PACKET *pPacket);
LPARAM  WMPaint(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam);
INT     WMKey(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam);
VOID    MoveEntityItems(VOID);
BOOL    WindowRegistration(HANDLE hInstance, HANDLE hPrevInstance);

BOOL WINAPI SendDataDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
LPARAM WINAPI ListBoxWindowProc(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam);


void DoFileOpen(HANDLE);
void DoFileSave(HANDLE);
void DoFilePrint(HANDLE);
void WriteLavaConfigFile(HANDLE,UINT);
void DoCopyDescriptor(HANDLE hWnd);
void DoParseDescriptor(HANDLE hWnd);


// Dialog box proc proto's
BOOL CALLBACK EditBoxDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK CollectionDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK MainItemDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK UnitDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK ExponentDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK UsagePageDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK SetDelimiterDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

LRESULT AddString(HANDLE hListBox,char * szString);

void GetBogusVal( HANDLE,int);
void GetUsageVal( HANDLE,int );
void GetUsagePageVal( HANDLE,int );
void GetInputFromEditBoxSigned( HANDLE,int );
void GetInputFromEditBoxUnSigned( HANDLE,int );
void GetCollectionVal( HANDLE,int );
void GetEndCollectionVal( HANDLE,int );
void GetInputVal( HANDLE,int );
void GetOutputVal( HANDLE,int );
void GetFeatVal( HANDLE,int );
void GetExponentVal( HANDLE,int );
void GetUnitsVal( HANDLE,int );
void GetPushVal( HANDLE,int );
void GetPopVal( HANDLE,int );
void GetSetDelimiterVal( HANDLE hDescListBox, int nEntity);





#endif// __DT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\exe\makebins.h ===
#ifndef __MAKEBINS_H__
#define __MAKEBINS_H__

#define MAX_FILEPATH_LENGTH 1023

typedef struct {
    char szDirectory[MAX_FILEPATH_LENGTH];
    UINT nIterations;
    UINT uiFirstFilenum;
} OUTPUT_OPTIONS;    

typedef struct {
    OUTPUT_OPTIONS oopts;
    GENERATE_OPTIONS genopts;
} BINGEN_OPTIONS;


void ReportError(char *errmsg);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\exe\makebins.c ===
#include <windows.h>
#include <wtypes.h>
#include <stdio.h>
#include <assert.h>
#include <limits.h>
#include <hidusage.h>
#include <hidsdi.h>
#include <hidpi.h>
#include <bingen.h>
#include "makebins.h"

BOOL 
StartGeneration(
    BINGEN_OPTIONS *opts
);

VOID 
StopGeneration(
    VOID
);

DWORD WINAPI 
DoGenerate(
     LPVOID lpvParam
);

static BOOL fAbortGeneration = FALSE;
static HANDLE hGenerateThread;

#ifdef _CONSOLE

    #define OUTPUT_ERROR(n)     fprintf(stderr, n)
    #define OUTPUT_TO_LOG(n)    fprintf(stdout, n); fprintf(stdout, "\n")

    INT 
    main (
        INT     argc, 
        PCHAR   argv[]
    )
    {
        GENERATE_OPTIONS gen_opts;
        
        gen_opts.copts.ulMaxCollectionDepth = 1;
        if (!GenerateBIN("test.bin", &gen_opts)) {
                return (1);
        }
        return (0);
    }

#else 

    #include "resource.h"

    #define OUTPUT_ERROR(n)     MessageBox(NULL, n, "BinGen Error", MB_ICONERROR)
    #define OUTPUT_TO_LOG(n)    AddToLogBox(n)

    #define MAX_LOGBOX_STRINGS  512

BOOL CALLBACK 
fMainDlgProc(
    HWND hwnd, 
    UINT mMsg, 
    WPARAM wParam, 
    LPARAM lParam
);

VOID
EnableGenerationControls(
    HWND hDlg,  
    BOOL fState
);


VOID AddToLogBox(
    PCHAR   str
);

static BINGEN_OPTIONS bg_opts;
static BOOL fUserOptionsSet;
static BOOL fUseDefaults;
static HINSTANCE hThisInstance;
static BOOL fGenerating = FALSE;
static HWND hLogBox;

/*
// WinMain: This is the entry point for the GUI interface to BinGen
*/

int WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR     lpCmdLine,
                   int       nCmdShow)
{
    MSG msg;

    hThisInstance = hInstance;
        
    DialogBox(hThisInstance, "IDD_OUTPUT_OPTIONS", NULL, fMainDlgProc);
        
    while (GetMessage(&msg, NULL, 0, 0)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
    }

    return 0;
}

BOOL CALLBACK fMainDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
        case WM_INITDIALOG:
            SetDlgItemText(hDlg, IDC_FILEPATH, ".\\");
            SetDlgItemInt(hDlg, IDC_FILENUM, 0, 0);
            SetDlgItemInt(hDlg, IDC_NUM_ITERATIONS, 1, 0);

            SendDlgItemMessage(hDlg, IDC_FILEPATH, EM_SETLIMITTEXT, (WPARAM) MAX_FILEPATH_LENGTH, 0);
            
            hLogBox = GetDlgItem(hDlg, IDC_LOGBOX);
            
            /*
            // Set fUseDefaults initially to FALSE since a message will be sent to 
            //    the dialog box that the button had been clicked.  Doing so will 
            //    allow the code to enable/disable buttons to be in only one place
            */
            
            fUseDefaults = FALSE;
            fUserOptionsSet = FALSE;
            EnableWindow(GetDlgItem(hDlg, IDC_LOGBOX), FALSE);

            SendMessage(hDlg, WM_COMMAND, (WPARAM) (BN_CLICKED << 16) | IDC_DEFAULT_SETTINGS, 0);
            
            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_DEFAULT_SETTINGS:
                    switch (HIWORD(wParam)) {
                        case BN_CLICKED:
                            fUseDefaults = !fUseDefaults;
                            CheckDlgButton(hDlg, IDC_DEFAULT_SETTINGS, fUseDefaults);
                                            
                            EnableWindow(GetDlgItem(hDlg, IDC_SET_OPTIONS), !fUseDefaults);
                            EnableWindow(GetDlgItem(hDlg, IDC_START_STOP), fUseDefaults || fUserOptionsSet);
                            break;

                        default:
                            assert(0);
                   }
                   break;

                case IDC_SET_OPTIONS:
                    fUserOptionsSet = BINGEN_SetOptions() || fUserOptionsSet;
                    EnableWindow(GetDlgItem(hDlg, IDC_START_STOP), fUserOptionsSet);
                        
                    break;

                case IDC_START_STOP:

                    /*
                    // If already generating then we need to stop the test and reenable
                    //    the controls
                    */
                    
                    if (fGenerating) {
                        fGenerating = FALSE;
                        StopGeneration();
                        EnableGenerationControls(hDlg, TRUE);
                        SetWindowText(GetDlgItem(hDlg, IDC_START_STOP), "Start Generation");

                    }
                    else {

                        /*
                        // Get all the options from the dialog box
                        */

                        GetDlgItemText(hDlg, IDC_FILEPATH, bg_opts.oopts.szDirectory, MAX_FILEPATH_LENGTH);
                        bg_opts.oopts.uiFirstFilenum = GetDlgItemInt(hDlg, IDC_FILENUM, NULL, FALSE);
                        bg_opts.oopts.nIterations = GetDlgItemInt(hDlg, IDC_NUM_ITERATIONS, NULL, FALSE);
                        
                        if (fUseDefaults) {
                            BINGEN_GetDefaultOptions(&(bg_opts.genopts));
                        }
                        else {
                            BINGEN_GetOptions(&(bg_opts.genopts));
                        }

                        if (StartGeneration(&bg_opts)) {
                            fGenerating = TRUE;
                            SetWindowText(GetDlgItem(hDlg, IDC_START_STOP), "Stop Generation");
                            EnableGenerationControls(hDlg, FALSE);
                        }
                   }
                   break;
            }       
            break;
            
        case WM_CLOSE:
            if (fGenerating) {
                fGenerating = FALSE;
                StopGeneration();

            }
            DestroyWindow(hDlg);
            return (TRUE);

        case WM_DESTROY:
            PostQuitMessage(0);
            return (TRUE);
            
    }
    return (FALSE);
}

void EnableGenerationControls(HWND hDlg, BOOL fState)
{
    EnableWindow(GetDlgItem(hDlg, IDC_FILEPATH), fState);
    EnableWindow(GetDlgItem(hDlg, IDC_FILENUM), fState);
    EnableWindow(GetDlgItem(hDlg, IDC_NUM_ITERATIONS), fState);
    EnableWindow(GetDlgItem(hDlg, IDC_DEFAULT_SETTINGS), fState);
    if (!IsDlgButtonChecked(hDlg, IDC_DEFAULT_SETTINGS))  {
        EnableWindow(GetDlgItem(hDlg, IDC_SET_OPTIONS), TRUE);
    }
    return;
}   
    
void AddToLogBox(char *str)
{
    static int iLogBoxCount = 0;
        int iIndex;

    if (MAX_LOGBOX_STRINGS == iLogBoxCount) {
        SendMessage(hLogBox, LB_DELETESTRING, 0, 0);
        iLogBoxCount--;
    }
    assert (iLogBoxCount < MAX_LOGBOX_STRINGS);

    iIndex = SendMessage(hLogBox, LB_ADDSTRING, 0, (LPARAM) str);
    SendMessage(hLogBox, LB_SETCURSEL, iIndex, 0);
        return;
}

#endif


/*
// Functions that are common to both the console UI and the GUI.
*/

void ReportError(char *errmsg)
{
    char szTempBuffer[1024];

    wsprintf(szTempBuffer, "ERROR: %s", errmsg);
    OUTPUT_ERROR(szTempBuffer);

    return;
}

BOOL StartGeneration(BINGEN_OPTIONS *opts)
{
    DWORD dwThreadID;

    OUTPUT_TO_LOG("Starting generation");

    fAbortGeneration = FALSE;
    hGenerateThread = CreateThread(NULL,
                                   0,
                                   DoGenerate,
                                   (LPVOID) opts, 
                                   0,
                                   &dwThreadID);

    return (TRUE);
}

void StopGeneration(void)
{
    fAbortGeneration = TRUE;
    WaitForSingleObject(hGenerateThread, INFINITE);

    CloseHandle(hGenerateThread);
    OUTPUT_TO_LOG("Stopped generation");
    return;
}

DWORD WINAPI DoGenerate(LPVOID lpvParam)
{
    BINGEN_OPTIONS *opts;


    /*
    // Filename length -- add 17 to account for directory addition of the following
    //                     output along with the ending NULL.
    //                      \repXXXXXXXX.bin
    */
    
    char filename[MAX_FILEPATH_LENGTH+17];
    int iPathLength;
    UINT nIterations;
    UINT uiFilenum;

    opts = (BINGEN_OPTIONS *) lpvParam;
    iPathLength = strlen(opts -> oopts.szDirectory);
    strcpy(filename, opts -> oopts.szDirectory);

    /*
    // If the path was not terminated with a backslash character, add the backslash
    //    character and increment the path length
    */
 
    if (filename[iPathLength-1] != '\\') {
        filename[iPathLength++] = '\\';
    }

    /*
    // Determine the maximum number of iterations that can be performed
    */

    if (0 == opts -> oopts.nIterations || 
        (UINT_MAX - opts -> oopts.nIterations < opts -> oopts.uiFirstFilenum)) {
              
        nIterations = UINT_MAX - opts->oopts.uiFirstFilenum;
    }
    else {
        nIterations = opts -> oopts.nIterations;
    }
    uiFilenum = opts -> oopts.uiFirstFilenum;
    
    while (!fAbortGeneration && (nIterations-- > 0)) {
       wsprintf(&(filename[iPathLength]), "rep%X.bin", uiFilenum++);

      BINGEN_GenerateBIN(filename, &(opts -> genopts));
    }

 
    return(0);
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\bingen\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by makebins.rc
//
#define ID_ACCEPT                       113
#define IDC_TAB1                        1000
#define IDC_FILEPATH                    1001
#define IDC_FILENUM                     1002
#define IDC_NUM_ITERATIONS              1003
#define IDC_DEFAULT_SETTINGS            1004
#define IDC_SET_OPTIONS                 1005
#define IDC_START_STOP                  1006
#define IDC_LOGBOX                      1007
#define IDC_PD_USAGES                   1100
#define IDC_USAGEPAGE_MIN               1101
#define IDC_USAGEPAGE_MAX               1102
#define IDC_USAGE_MIN                   1103
#define IDC_USAGE_MAX                   1104
#define IDC_DEFAULT_USAGES              1105
#define IDC_COLLECTION_DEPTH            1200
#define IDC_TOP_COLLECTIONS             1201
#define IDC_ITEMS_MIN                   1202
#define IDC_ITEMS_MAX                   1203
#define IDC_DEFAULT_COLLECTION          1204
#define IDC_DEFAULT_REPORT              1300
#define IDC_CREATE_BUTTONS              1301
#define IDC_CREATE_DATA_FIELDS          1302
#define IDC_CREATE_ARRAYS               1303
#define IDC_CREATE_BUFFERED_BYTES       1304
#define IDC_REPORT_SIZE_MIN             1305
#define IDC_REPORT_SIZE_MAX             1306
#define IDC_REPORT_COUNT_MIN            1307
#define IDC_REPORT_COUNT_MAX            1308
#define IDC_BUTTONS_MIN                 1309
#define IDC_BUTTONS_MAX                 1310
#define IDC_ARRAY_SIZE_MIN              1311
#define IDC_ARRAY_SIZE_MAX              1312
#define IDC_ARRAY_USAGES_MIN            1313
#define IDC_ARRAY_USAGES_MAX            1314
#define IDC_ARRAY_COUNT_MIN             1315
#define IDC_ARRAY_COUNT_MAX             1316
#define IDC_BUFFER_MIN                  1317
#define IDC_BUFFER_MAX                  1318
#define IDC_USE_REPORT_IDS              1319
#define IDC_REPORT_ID_MAX               1320

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        122
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1175
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\dt\dtrc.h ===
// FILE:    DTRC.H
//          Include file for DT tool resource identifiers
//


#define IDC_NV_TEXT                     0xf000
#define IDC_SINGULAR                    0xf001

#define IDC_STATIC                      -1



//
// HID menu identifiers
//
#define IDM_MAIN_MENU                   9000
#define IDM_OPEN                        9001
#define IDM_SAVE                        9002
#define IDM_PRINT                       9003
#define IDM_EXIT                        9004

#define IDM_COPY                        9005

#define IDM_PARSE                       9006

//
// HID dialog IDs
//
#define IDD_EDITBOX                     101
#define IDD_USAGEPAGE                   102
#define IDD_INPUT                       103
#define IDD_OUTPUT                      104
#define IDD_COLLECTION                  105
#define IDD_UNIT                        106
#define IDD_EXPONENT                    107
#define IDD_SETDELIMITER                108
#define IDD_PARSE                       109

//
// Ensure that the high order word is 0 so that we can use this
//  directly in calls to FindResource()
#define IDD_SENDDATA                    0x0000006C


//
// ID for EditBox dialog proc  edit field
//
#define IDC_EDIT1                       1000

//
// ID for Usage dialog proc list box
#define IDC_LIST1                       1002

//
// ID for the edit box in the Parse dialog
//
#define IDC_PARSEEDIT                   1003

//
// ID's for base radio buttons
#define IDC_BASE10                      1091
#define IDC_BASE16                      1092


//
// IDs for Collection Dialog
//
#define IDC_LINKED                      1019
#define IDC_APPLICATION                 1020
#define IDC_DATALINK                    1021
//
// IDs for Input, output and Feature dialog proc's
//
// ID-0x1000 = bit mask for setting (OR)
#define IDC_CONST                       0x1001
#define IDC_VARIABLE                    0x1002
#define IDC_RELATIVE                    0x1004
#define IDC_WRAP                        0x1008
#define IDC_NONLINEAR                   0x1010
#define IDC_NOPREF                      0x1020
#define IDC_NONULL                      0x1040
#define IDC_VOL                         0x1080
#define IDC_BUFFERED                    0x1100

// ID-0x1000 = bit mask for clearing (AND)
#define IDC_BITFIELD                    0x1EFF
#define IDC_NONVOL                      0x1FBF
#define IDC_NULL                        0x1FCF
#define IDC_PREFSTATE                   0x1FDF
#define IDC_LINEAR                      0x1FEF
#define IDC_NOWRAP                      0x1FFB
#define IDC_ABSOLUTE                    0x1FFC
#define IDC_ARRAY                       0x1FFD
#define IDC_DATA                        0x1FFE


//
// ID's for the Unit dialog proc
//
// System nibble
//  ID-0x2000 = lo byte lo nibble value
#define IDC_SYSNONE                     0x2000
#define IDC_SILIN                       0x2001
#define IDC_SIROT                       0x2002
#define IDC_ENGLIN                      0x2003
#define IDC_ENGROT                      0x2004
#define IDC_ELECTRIC                    0x2005
#define IDC_TEMP                        0x2006
#define IDC_LUMINOSITY                  0x2007
#define IDC_TBD                         0x2008
#define IDC_VENDOR                      0x2009
#define IDC_TBD1                        0x200A
#define IDC_TBD2                        0x200B
#define IDC_TBD3                        0x200C
#define IDC_TBD4                        0x200D
#define IDC_TBD5                        0x200E
#define IDC_TBD6                        0x200F

// Length nibble
//  (ID-0x3000)<<4 = lo byte hi nibble
#define IDC_ZERO1                       0x3000
#define IDC_ONE1                        0x3001
#define IDC_TWO1                        0x3002
#define IDC_THREE1                      0x3003
#define IDC_FOUR1                       0x3004
#define IDC_FIVE1                       0x3005
#define IDC_SIX1                        0x3006
#define IDC_SEVEN1                      0x3007
#define IDC_NEGEIGHT1                   0x3008
#define IDC_NEGSEVEN1                   0x3009
#define IDC_NEGSIX1                     0x300A
#define IDC_NEGFIVE1                    0x300B
#define IDC_NEGFOUR1                    0x300C
#define IDC_NEGTHREE1                   0x300D
#define IDC_NEGTWO1                     0x300E
#define IDC_NEGONE1                     0x300F

// Mass nibble
// (ID-0x4000)<<8 = hi byte lo nibble
#define IDC_ZERO2                       0x4000
#define IDC_ONE2                        0x4001
#define IDC_TWO2                        0x4002
#define IDC_THREE2                      0x4003
#define IDC_FOUR2                       0x4004
#define IDC_FIVE2                       0x4005
#define IDC_SIX2                        0x4006
#define IDC_SEVEN2                      0x4007
#define IDC_NEGEIGHT2                   0x4008
#define IDC_NEGSEVEN2                   0x4009
#define IDC_NEGSIX2                     0x400A
#define IDC_NEGFIVE2                    0x400B
#define IDC_NEGFOUR2                    0x400C
#define IDC_NEGTHREE2                   0x400D
#define IDC_NEGTWO2                     0x400E
#define IDC_NEGONE2                     0x400F

// Time nibble
// (ID-0x5000)<<12 = hi byte hi nibble
#define IDC_ZERO3                       0x5000
#define IDC_ONE3                        0x5001
#define IDC_TWO3                        0x5002
#define IDC_THREE3                      0x5003
#define IDC_FOUR3                       0x5004
#define IDC_FIVE3                       0x5005
#define IDC_SIX3                        0x5006
#define IDC_SEVEN3                      0x5007
#define IDC_NEGEIGHT3                   0x5008
#define IDC_NEGSEVEN3                   0x5009
#define IDC_NEGSIX3                     0x500A
#define IDC_NEGFIVE3                    0x500B
#define IDC_NEGFOUR3                    0x500C
#define IDC_NEGTHREE3                   0x500D
#define IDC_NEGTWO3                     0x500E
#define IDC_NEGONE3                     0x500F

// 
//Exponent dialog ID's
//
// ID-0x4000 = value
#define IDC_ZERO                        0x4000
#define IDC_ONE                         0x4001
#define IDC_TWO                         0x4002
#define IDC_THREE                       0x4003
#define IDC_FOUR                        0x4004
#define IDC_FIVE                        0x4005
#define IDC_SIX                         0x4006
#define IDC_SEVEN                       0x4007
#define IDC_NEGEIGHT                    0x4008
#define IDC_NEGSEVEN                    0x4009
#define IDC_NEGSIX                      0x400A
#define IDC_NEGFIVE                     0x400B
#define IDC_NEGFOUR                     0x400C
#define IDC_NEGTHREE                    0x400D
#define IDC_NEGTWO                      0x400E
#define IDC_NEGONE                      0x400F


//
// ID's for the SETDELIMITER dialog box
#define IDC_DELIMITOPEN                 0x5000
#define IDC_DELIMITCLOSE                0x5001

//
// Send Data Dialog ID's
//
#define IDC_BYTE0                       0x1000
#define IDC_BYTE1                       0x1001
#define IDC_BYTE2                       0x1002
#define IDC_BYTE3                       0x1003
#define IDC_BYTE4                       0x1004
#define IDC_BYTE5                       0x1005
#define IDC_BYTE6                       0x1006
#define IDC_BYTE7                       0x1007
#define IDC_BYTE8                       0x1008
#define IDC_BYTE9                       0x1009
#define IDC_BYTESLIDER                  0x100A
#define IDC_NUMBYTES                    0x100B
#define IDC_SEND                        0x100C
#define IDC_KILL                        0x100D
#define IDC_GETDATA                     0x100E
#define IDC_GETDATA_TEXT                0x100F
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\dt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hid.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\dt\user.c ===
/*******************************************************************************
**
**      MODULE: USER.C
**
** DESCRIPTION: Routines for getting user input for the different Entities
**              
**              
**
**      AUTHOR: John Pierce.
**
**
**
**     CREATED: 02/29/96
**
**	   HISTORY:
**
**		Date		Author			    		Reason
**    ----------------------------------------------------------------------
**		02/29/96	John Pierce (johnpi)	Took over dev from Dan
**
**
**  (C) C O P Y R I G H T   M I C R O S O F T   C O R P   1 9 9 5 - 1 9 9 6.
**
**                 A L L   R I G H T S   R E S E R V E D .
**
*******************************************************************************/
#include <windows.h>
#include <string.h>
#include <stdio.h>              // for sscanf()
#include "..\include\dt.h"
#include "..\include\dtrc.h"

#define MAX_USAGE_PAGES 8
char szUsagePage[MAX_USAGE_PAGES][20] = {
                                        "Undefiend",        // 0
                                        "GenericDesktop",   // 1
                                        "Vehicle",          // 2
                                        "VR",               // 3
                                        "Sport",            // 4
                                        "Game",             // 5
                                        "Consumer",         // 6
                                        "Keyboard"   };     // 7


/*******************************************************************************
**
** UINT AddString( HANDLE hListBox, char * szString, int Index )
**
** DESCRIPTION: Add string "string" to list box hListBox. If flag gfInsert 
**               is TRUE, insert string at current position in hListBox
**              
**              
**  PARAMETERS: hListBox    Handle to the Desc window
**              szString    String to add
**              Index       Pos. to add string. If = DONT_CARE get Pos. from
**                          Current Selection, otherwise insert at Index
**              
**     RETURNS: Index of string that was added to hListbox
**
*******************************************************************************/
LRESULT AddString(HANDLE hListBox,char * szString)
{
    int Index=-1;
               
        if( gfInsert )
        {
           Index = SendMessage(hListBox,LB_GETCURSEL,0,0);
           SendMessage(hListBox,LB_INSERTSTRING,(WPARAM)Index,(LPARAM)szString);
           return Index;
        }
        else
        {
            Index = SendMessage(hListBox,LB_INSERTSTRING,(WPARAM)Index,(LPARAM)szString);
            SendMessage(hListBox,LB_SETCURSEL,Index,0);
            return Index;
        }

}

/*******************************************************************************
**
** void GetBogusVal( HANDLE hDescListBox, int nEntity
**                                                             
** DESCRIPTION: Get user input for a bogus Item
**              
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Not used
**
**     RETURNS:
**
*******************************************************************************/
void GetBogusVal( HANDLE hDescListBox, int nEntity)
{
    PITEM_INFO pItemInfo;
    char szBuff[128],szTmp[4];
    LRESULT Index,rc;
    BYTE *pb;
    int i,NumBytes;

    rc = DialogBox( ghInst,"EditBoxDlg",ghWnd , EditBoxDlgProc);
    
    if( rc == TRUE )
    {
        if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
        {
            pItemInfo->bTag = (BYTE)gEditVal;

            rc = DialogBox( ghInst,"EditBoxDlg",ghWnd , EditBoxDlgProc);
            if( rc == TRUE )
            {
                pItemInfo->bTag = Entity[nEntity];
                        
                if( gEditVal < 0 )  // Handle negative numbers differently
                {
                    if( gEditVal > -0x100 )
                    {
                        pItemInfo->bTag |= 0x01;
                        NumBytes = 1;
                    }
                    else if (gEditVal > -0x10000 )
                    {                                     
                        pItemInfo->bTag |= 0x02;      
                        NumBytes = 2;
                    }
                    else
                    {
                        pItemInfo->bTag |= 0x03;
                        NumBytes = 4;
                    }      
            
                }
            
                else    // Number is not negative
                {
                    if( (DWORD)gEditVal < 0x80 )
                    {
                        pItemInfo->bTag |= 0x01;
                        NumBytes = 1;
                    }
                    else if ( (DWORD)gEditVal < 0x8000 )
                    {
                        pItemInfo->bTag |= 0x02;      
                        NumBytes = 2;
                    }
                    else
                    {
                        pItemInfo->bTag |= 0x03;
                        NumBytes = 4;
                    }      
            
                }
            }
            gwReportDescLen += NumBytes + 1;    // +1 for Item tag byte

            wsprintf(szBuff,"UNDEFINED_TAG\t%02X ",pItemInfo->bTag);
            pb = (BYTE *) &gEditVal;
            for( i=0;i<NumBytes;i++ ) 
            {
                pItemInfo->bParam[i] = *pb++;
                wsprintf(szTmp,"%02X ",pItemInfo->bParam[i]);
                strcat(szBuff,szTmp);
            }     
            Index = AddString(hDescListBox,szBuff);
            rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);
    
        }
        else
            MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);
    
    }

 }

/*******************************************************************************
**
** void GetUsagePageVal( HANDLE hDescListBox, int nEntity
**                                                             
** DESCRIPTION: Get user input for a UsagePage Tag
**              
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Not used
**
**     RETURNS:
**
*******************************************************************************/
void GetUsagePageVal( HANDLE hDescListBox, int nEntity)
{
    PITEM_INFO pItemInfo;
    char szBuff[128];
    LRESULT Index,rc;

    rc = DialogBox( ghInst,MAKEINTRESOURCE(IDD_USAGEPAGE),ghWnd , UsagePageDlgProc);
    
    if( rc == TRUE )
    {
        if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
        {
        
            pItemInfo->bTag = USAGE_PAGE;
            pItemInfo->bTag |= 0x01;        // 1 BYTE of param info
            pItemInfo->bParam[0] = gUsagePageVal;

            wsprintf(szBuff,"USAGE_PAGE (%s)\t%02X %02X",szUsagePage[gUsagePageVal],
                                                         pItemInfo->bTag,gUsagePageVal);
            
            Index = AddString(hDescListBox,szBuff);
            rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);
            
            gwReportDescLen += 2;           // Tag + Data

        }
        else
            MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);
    
    }

}
/*******************************************************************************
**
** void GetInputFromEditBoxSigned( HANDLE hDescListBox, int nEntity
**
** DESCRIPTION: Generic routine to get signed numeric user input from an edit field
**              
**              
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Entity that we are getting value for
**
**     RETURNS:
**
*******************************************************************************/
void GetInputFromEditBoxSigned( HANDLE hDescListBox, int nEntity)
{
    PITEM_INFO pItemInfo;
    char szBuff[128],szTmp[3];
    int i;
    LRESULT Index,rc;
    BYTE *pb;

    rc = DialogBox( ghInst,"EditBoxDlg",ghWnd , EditBoxDlgProc);
    
    if( rc == TRUE )
    {
        if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
        {

            int NumBytes=0;

            pItemInfo->bTag = Entity[nEntity];
                        
            if( gEditVal < 0 )  // Handle negative numbers differently
            {
                if( gEditVal > 0xffffff01 )
                {
                    pItemInfo->bTag |= 0x01;
                    NumBytes = 1;
                }
                else if (gEditVal > 0xffff0001 )
                {                                     
                    pItemInfo->bTag |= 0x02;      
                    NumBytes = 2;
                }
                else
                {
                    pItemInfo->bTag |= 0x03;
                    NumBytes = 4;
                }      
            
            }
            
            else    // Number is not negative
            {
                if( (DWORD)gEditVal < 0x80 )            // if the hi bit is set, we must
                {                                       // add an upper byte of 0 so the 
                    pItemInfo->bTag |= 0x01;            // numbers remain positive
                    NumBytes = 1;
                }
                else if ( (DWORD)gEditVal < 0x8000 )
                {
                    pItemInfo->bTag |= 0x02;      
                    NumBytes = 2;
                }
                else
                {
                    pItemInfo->bTag |= 0x03;
                    NumBytes = 4;
                }      
            
            }
            gwReportDescLen += NumBytes + 1;            // +1 for Item Tag byte

            wsprintf(szBuff,"%s (%d)\t%02X ",szEntity[nEntity],gEditVal,pItemInfo->bTag);
            pb = (BYTE *) &gEditVal;
            for( i=0;i<NumBytes;i++ ) 
            {
                pItemInfo->bParam[i] = *pb++;
                wsprintf(szTmp,"%02X ",pItemInfo->bParam[i]);
                strcat(szBuff,szTmp);
            }     
            
            Index = AddString(hDescListBox,szBuff);
            rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);
    
        }
        else
            MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);
    
    }//end if(rc == TRUE)


}

/*******************************************************************************
**
** void GetInputFromEditBoxUnSigned( HANDLE hDescListBox, int nEntity
**
** DESCRIPTION: Generic routine to get unsigned numeric user input from 
**               an edit field
**              
**              
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Entity that we are getting value for
**
**     RETURNS:
**
*******************************************************************************/
void GetInputFromEditBoxUnSigned( HANDLE hDescListBox, int nEntity)
{
    PITEM_INFO pItemInfo;
    char szBuff[128],szTmp[3];
    int i;
    LRESULT Index,rc;
    BYTE *pb;

    rc = DialogBox( ghInst,"EditBoxDlg",ghWnd , EditBoxDlgProc);
    
    if( rc == TRUE )
    {
        if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
        {

            int NumBytes=0;

            pItemInfo->bTag = Entity[nEntity];
                        
            if( (DWORD)gEditVal < 0x100 )           
            {                                       
                pItemInfo->bTag |= 0x01;            
                NumBytes = 1;
            }
            else if ( (DWORD)gEditVal < 0x10000 )
            {
                pItemInfo->bTag |= 0x02;      
                NumBytes = 2;
            }
            else
            {
                pItemInfo->bTag |= 0x03;
                NumBytes = 4;
            }      
        
            gwReportDescLen += NumBytes + 1;            // +1 for Item Tag byte

            wsprintf(szBuff,"%s (%d)\t%02X ",szEntity[nEntity],gEditVal,pItemInfo->bTag);
            pb = (BYTE *) &gEditVal;
            for( i=0;i<NumBytes;i++ ) 
            {
                pItemInfo->bParam[i] = *pb++;
                wsprintf(szTmp,"%02X ",pItemInfo->bParam[i]);
                strcat(szBuff,szTmp);
            }     
            
            Index = AddString(hDescListBox,szBuff);
            rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);
    
        }
        else
            MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);
    
    }//end if(rc == TRUE)


}

/*******************************************************************************
**
** void GetCollectionVal( HANDLE hDescListBox,int nEntity)
**
** DESCRIPTION: Get user input for a Collection Tag
**              
**              
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Not used
**
**     RETURNS:
**
*******************************************************************************/
void GetCollectionVal( HANDLE hDescListBox, int nEntity)
{
    PITEM_INFO pItemInfo;
    char szBuff[128];
    LRESULT Index,rc;

    rc = DialogBox( ghInst,MAKEINTRESOURCE(IDD_COLLECTION),ghWnd , CollectionDlgProc);
    
    if( rc == TRUE )
    {
        if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
        {
            pItemInfo->bTag = COLLECTION;
            pItemInfo->bTag |= 0x01;                // Collection has 1 parm
            pItemInfo->bParam[0] = gCollectionVal;
            
            wsprintf(szBuff,"COLLECTION (%s)\t%02X %02X",(pItemInfo->bParam[0]) ? "Application" : "Linked",
                                                         pItemInfo->bTag,pItemInfo->bParam[0]);
            Index = AddString(hDescListBox,szBuff);
            rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);
            
            gwReportDescLen += 2;   // Tag + Data


        }
        else
            MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);
    
        

    
    }//end if(rc == TRUE)


}
/*******************************************************************************
**
** void GetEndCollectionVal( HANDLE hDescListBox, int nEntity)
**
** DESCRIPTION: Fills in the PITEM_INFO struct with a EndCollection tag value
**              
**              
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Not used
**
**     RETURNS:
**
*******************************************************************************/
void GetEndCollectionVal( HANDLE hDescListBox, int nEntity)
{
    PITEM_INFO pItemInfo;
    char szBuff[128];
    LRESULT Index,rc;

    if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
    {
        pItemInfo->bTag = END_COLLECTION;

        wsprintf(szBuff,"END_COLLECTION\t%02X",END_COLLECTION);
        Index = AddString(hDescListBox,szBuff);
        rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);
    
        gwReportDescLen++;  // +1 for Item Tag byte
    }
    else
        MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);

    
    

}
/*******************************************************************************
**
** void GetInputVal( HANDLE hDescListBox, int nEntity)
**
** DESCRIPTION: Get user input for a Input tag
**              
**              
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Not used
**
**     RETURNS:
**
*******************************************************************************/
void GetInputVal( HANDLE hDescListBox, int nEntity)
{

    PITEM_INFO pItemInfo;
    char szBuff[128];
    LRESULT Index,rc;

    rc = DialogBox( ghInst,MAKEINTRESOURCE(IDD_OUTPUT),ghWnd , MainItemDlgProc);
    
    if( rc == TRUE )
    {
        if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
        {
        
            pItemInfo->bTag = INPUT;

            if( HIBYTE(gMainItemVal) )
                pItemInfo->bTag |= 0x02;        
            else
                pItemInfo->bTag |= 0x01;
                        
            pItemInfo->bParam[0] = LOBYTE(gMainItemVal);
            pItemInfo->bParam[1] = HIBYTE(gMainItemVal);
 
            if( HIBYTE(gMainItemVal))
            {
                wsprintf(szBuff,"INPUT (%d)\t%02X %02X %02X",gMainItemVal,pItemInfo->bTag,pItemInfo->bParam[1],
                                                                                          pItemInfo->bParam[0] );
                gwReportDescLen += 3;
            }
            else
            {
                wsprintf(szBuff,"INPUT (%d)\t%02X %02X",gMainItemVal,pItemInfo->bTag,pItemInfo->bParam[0]);
                gwReportDescLen += 2;
            }                                                                           

            Index = AddString(hDescListBox,szBuff);                                
            rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);

        }
        else
            MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);
    
    
    }



}
/*******************************************************************************
**
** void GetOutputVal( HANDLE hDescListBox, int nEntity)
**
** DESCRIPTION: Get user input for a Output Tag
**              
**              
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Not used
**
**     RETURNS:
**
*******************************************************************************/
void GetOutputVal( HANDLE hDescListBox, int nEntity)
{
    PITEM_INFO pItemInfo;
    char szBuff[128];
    LRESULT Index,rc;

    rc = DialogBox( ghInst,MAKEINTRESOURCE(IDD_OUTPUT),ghWnd , MainItemDlgProc);
    
    if( rc == TRUE )
    {
        if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
        {
        
            pItemInfo->bTag = OUTPUT;

            if( HIBYTE(gMainItemVal) )
                pItemInfo->bTag |= 0x02;        
            else
                pItemInfo->bTag |= 0x01;

            pItemInfo->bParam[0] = LOBYTE(gMainItemVal);
            pItemInfo->bParam[1] = HIBYTE(gMainItemVal);

            if( HIBYTE(gMainItemVal))
            {
                wsprintf(szBuff,"OUTPUT (%d)\t%02X %02X %02X",gMainItemVal,pItemInfo->bTag,pItemInfo->bParam[1],
                                                                                           pItemInfo->bParam[0] );
                gwReportDescLen += 3;
            }

            else
            {
                wsprintf(szBuff,"OUTPUT (%d)\t%02X %02X",gMainItemVal,pItemInfo->bTag,pItemInfo->bParam[0]);
                gwReportDescLen += 2;
            }
                                                                                       

            Index = AddString(hDescListBox,szBuff);
            rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);

        }
        else
            MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);
    
    }



}
/*******************************************************************************
**
** void GetFeatVal( HANDLE hDescListBox, int nEntity)
**
** DESCRIPTION: Get user input for a Feature Tag
**              
**              
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Not used
**
**     RETURNS:
**
*******************************************************************************/
void GetFeatVal( HANDLE hDescListBox, int nEntity)
{                                                           
    PITEM_INFO pItemInfo;
    char szBuff[128];
    LRESULT Index,rc;

    rc = DialogBox( ghInst,MAKEINTRESOURCE(IDD_OUTPUT),ghWnd , MainItemDlgProc);
    
    if( rc == TRUE )
    {
        if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
        {
        
            pItemInfo->bTag = FEATURE;

            if( HIBYTE(gMainItemVal) )
                pItemInfo->bTag |= 0x02;        
            else
                pItemInfo->bTag |= 0x01;

            pItemInfo->bParam[0] = LOBYTE(gMainItemVal);
            pItemInfo->bParam[1] = HIBYTE(gMainItemVal);
            
            if( HIBYTE(gMainItemVal))
            {
                wsprintf(szBuff,"FEATURE (%d)\t%02X %02X %02X",gMainItemVal,pItemInfo->bTag,pItemInfo->bParam[1],
                                                                                            pItemInfo->bParam[0] );   
                gwReportDescLen += 3;
            }
            else
            {    
                wsprintf(szBuff,"FEATURE (%d)\t%02X %02X",gMainItemVal,pItemInfo->bTag,pItemInfo->bParam[0]);
                gwReportDescLen += 2;
            }

            Index = AddString(hDescListBox,szBuff);
            rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);

        }
        else
            MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);
    
    }



}
/*******************************************************************************
**
** void GetExponentVal( HANDLE hDescListBox, HANDLE hHexListBox int nEntity)
**
** DESCRIPTION: Get user input for a Exponent Tag
**              
**              
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Not used
**
**     RETURNS:
**
*******************************************************************************/
void GetExponentVal( HANDLE hDescListBox, int nEntity)
{
    PITEM_INFO pItemInfo;
    char szBuff[128];                                                                     
    LRESULT Index,rc;                                                                   

    rc = DialogBox( ghInst,MAKEINTRESOURCE(IDD_EXPONENT),ghWnd , ExponentDlgProc);
    
    if( rc == TRUE )
    {
        if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
        {
        
            pItemInfo->bTag = UNIT_EXPONENT;
            pItemInfo->bTag |= 0x01;        // 1 BYTE of param info
            pItemInfo->bParam[0] = gExpVal;
            
            wsprintf(szBuff,"UNIT_EXPONENT (%d)\t%02X %02X",gExpVal,pItemInfo->bTag,pItemInfo->bParam[0]);
            Index = AddString(hDescListBox,szBuff);
            rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);

            gwReportDescLen += 2;
        }
        else
            MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);
    
        
    }

}
/*******************************************************************************
**
** void GetUnitsVal( HANDLE hDescListBox, int nEntity)
**
** DESCRIPTION: Get user input for a Units Tag
**              
**              
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Not used
**
**     RETURNS:
**
*******************************************************************************/
void GetUnitsVal( HANDLE hDescListBox, int nEntity)
{
    PITEM_INFO pItemInfo;
    char szBuff[128];
    LRESULT Index,rc;

    rc = DialogBox( ghInst,MAKEINTRESOURCE(IDD_UNIT),ghWnd , UnitDlgProc);
    
    if( rc == TRUE )
    {
        if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
        {
        
            pItemInfo->bTag = UNIT;
            pItemInfo->bTag |= 0x02;        // 2 BYTE of param info
            pItemInfo->bParam[0] = LOBYTE(gUnitVal);
            pItemInfo->bParam[1] = HIBYTE(gUnitVal);


            wsprintf(szBuff,"UNIT (%d)\t%02X %02X %02X",gExpVal,pItemInfo->bTag,pItemInfo->bParam[0],
                                                                                pItemInfo->bParam[1] );
            Index = AddString(hDescListBox,szBuff);
            rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);

            gwReportDescLen += 2;
        }
        else
            MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);
    
    }

}
/*******************************************************************************
**
** void GetPushVal( HANDLE hDescListBox, HANDLE hHexListBox int nEntity)
**
** DESCRIPTION: Creates a ITEM_INFO struct, fills it with a tag value for
**               PUSH, Send a textual representation to the Desc Window, and
**               and a Hex representation to the Hex Window. Store the pointer
**               to the structure in column 2 of the Hex Window.
**
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Not used
**              
**  
**     RETURNS:
**
*******************************************************************************/
void GetPushVal( HANDLE hDescListBox, int nEntity)
{
    PITEM_INFO pItemInfo;
    char szBuff[128];
    LRESULT Index,rc;

    if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
    {
        pItemInfo->bTag = PUSH;
        
        wsprintf(szBuff,"PUSH\t%02X",PUSH);
        Index = AddString(hDescListBox,szBuff);
        rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);
        gwReportDescLen++;
    }
    else
        MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);

    
}
/*******************************************************************************
**
** void GetPopVal( HANDLE hDescListBox, int nEntity)
**
** DESCRIPTION: Creates a ITEM_INFO struct, fills it with a tag value for
**               POP, Send a textual representation to the Desc Window, and
**               and a Hex representation to the Hex Window. Store the pointer
**               to the structure in the ItemData for the item.
**
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              hHexListBox     Handle to the Hex window
**              nEntity         Not used
**
**     RETURNS:
**
*******************************************************************************/
void GetPopVal( HANDLE hDescListBox, int Entity )
{
    PITEM_INFO pItemInfo;
    char szBuff[128];
    LRESULT Index,rc;

    if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
    {
        pItemInfo->bTag = POP;

        wsprintf(szBuff,"POP\t%02X",POP);
        Index = AddString(hDescListBox,szBuff);
        rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);
        gwReportDescLen++;
    }
    else
        MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);

    
    
}

/*******************************************************************************
**
** void GetSetDelimiterVal( HANDLE hDescListBox,int nEntity)
**
** DESCRIPTION: Get user input for a SetDelimiter Tag
**              
**              
**  PARAMETERS: hDescListBox    Handle to the Desc window
**              nEntity         Not used
**
**     RETURNS:
**
*******************************************************************************/
void GetSetDelimiterVal( HANDLE hDescListBox, int nEntity)
{
    PITEM_INFO pItemInfo;
    char szBuff[128];
    LRESULT Index,rc;

    rc = DialogBox( ghInst,MAKEINTRESOURCE(IDD_SETDELIMITER),ghWnd , SetDelimiterDlgProc);
    
    if( rc == TRUE )
    {
        if( pItemInfo = (PITEM_INFO) GlobalAlloc(GPTR,sizeof(ITEM_INFO)) )
        {
            pItemInfo->bTag = SET_DELIMITER;
            pItemInfo->bTag |= 0x01;                // SetDelimiter has 1 param
            pItemInfo->bParam[0] = gSetDelimiterVal;
            
            wsprintf(szBuff,"SET_DELIMITER (%s)\t%02X %02X",(pItemInfo->bParam[0]) ? "Close" : "Open",
                                                             pItemInfo->bTag,pItemInfo->bParam[0]);
            Index = AddString(hDescListBox,szBuff);
            rc = SendMessage(hDescListBox,LB_SETITEMDATA,Index,(LPARAM) pItemInfo);
    
            gwReportDescLen += 2;
        }
        else
            MessageBox(NULL,"GlobalAlloc() Failed!","DT Error",MB_OK);
    
    }//end if(rc == TRUE)


}


/********************************************************************************
 **                    D I A L O G   B O X   P R O C's                         **
 ********************************************************************************/


/*******************************************************************************
**
** BOOL APIENTRY SetDelimiterDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARM lPram)
**
** DESCRIPTION: Dialog box proc for SetDelimiter items
**              
**
**  PARAMETERS: Your standard Dialog box proc parms, plus....
**              
**
**     RETURNS:
**
*******************************************************************************/
BOOL CALLBACK SetDelimiterDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_INITDIALOG:
            gSetDelimiterVal = 0;
            SendMessage(GetDlgItem(hDlg,IDC_DELIMITOPEN),BM_SETCHECK,TRUE,0);
            return TRUE;

        case WM_COMMAND:
            switch( wParam )
            {
                case IDC_DELIMITOPEN:
                    gSetDelimiterVal = 0x00;
                    return TRUE;

                case IDC_DELIMITCLOSE:
                    gSetDelimiterVal = 0x01;
                    return TRUE;

                case IDOK:
                    EndDialog(hDlg,TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    return TRUE;
            }
        default:
            return FALSE;

    }

    return FALSE;



}


/*******************************************************************************
**
** BOOL APIENTRY EditBoxDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARM lPram)
**
** DESCRIPTION: Dialog box proc for Edit box input
**              
**              
**              
**
**  PARAMETERS: Your standard Dialog box proc parms, plus....
**              
**
**     RETURNS:
**
*******************************************************************************/
#define MAX_INTEGER 12 //"-2147483648\0"
#define MAX_HEX      9 // Number bits in a DWORD + \0

int INT_MAX =  2147483647;
int INT_MIN = -2147483647;

BOOL CALLBACK EditBoxDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL Status;
    static HWND hwndEdit;
    char szNumber[MAX_INTEGER];
    static int nBase = IDC_BASE10;
    static int nStringLen = MAX_INTEGER;

    switch(msg)
    {
        case WM_INITDIALOG:
            gEditVal = 0;
            hwndEdit = GetDlgItem(hDlg,IDC_EDIT1);
            SendDlgItemMessage(hDlg,nBase,BM_SETCHECK,TRUE,0);
            SetFocus(hwndEdit);
            return FALSE;


        case WM_COMMAND:
            switch( wParam )
            {
                case IDOK:
                    Status = GetDlgItemText(hDlg,IDC_EDIT1,szNumber,nStringLen);
                    if( Status <= nStringLen - 1 )
                    {
                        if( nBase == IDC_BASE10 )
                            gEditVal = atoi(szNumber);
                        else
                            sscanf(szNumber,"%8x",&gEditVal);

                        if( (gEditVal <= INT_MAX) && (gEditVal >= INT_MIN) )
                        {
                            EndDialog(hDlg,TRUE);
                            return TRUE;
                        }
                    }       
                    SetFocus(hwndEdit);
                    SendMessage(hwndEdit,EM_SETSEL,0,-1);
                    return TRUE;

                case IDC_BASE10:
                    nBase = IDC_BASE10;
                    SetFocus(hwndEdit);
                    nStringLen = MAX_INTEGER;
                    return TRUE;

                case IDC_BASE16:
                    nBase = IDC_BASE16;
                    SetFocus(hwndEdit);                                           
                    nStringLen = MAX_HEX;
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    return TRUE;
            }
        default:
            return FALSE;

    }

    return FALSE;

}

/*******************************************************************************
**
** BOOL APIENTRY CollectionDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARM lPram)
**
** DESCRIPTION: Dialog box proc for Collection entities
**              
**
**  PARAMETERS: Your standard Dialog box proc parms, plus....
**              
**
**     RETURNS:
**
*******************************************************************************/
BOOL CALLBACK CollectionDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_INITDIALOG:
            gCollectionVal = 0;
            SendMessage(GetDlgItem(hDlg,IDC_LINKED),BM_SETCHECK,TRUE,0);
            return TRUE;

        case WM_COMMAND:
            switch( wParam )
            {
                case IDC_LINKED:
                    gCollectionVal = 0x00;
                    return TRUE;

                case IDC_APPLICATION:
                    gCollectionVal = 0x01;
                    return TRUE;

                case IDC_DATALINK:
                    gCollectionVal = 0x02;
                    return TRUE;

                case IDOK:
                    EndDialog(hDlg,TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    return TRUE;
            }
        default:
            return FALSE;

    }

    return FALSE;



}

/*******************************************************************************
**
** BOOL CALLBACK InputDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARM lPram)
**
** DESCRIPTION: Dialog box proc for Input entities
**              
**
**  PARAMETERS: Your standard Dialog box proc parms, plus....
**              
**
**     RETURNS:
**
*******************************************************************************/
/****
BOOL CALLBACK InputDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_INITDIALOG:
            gInputVal = 0;
            SendMessage(GetDlgItem(hDlg,IDC_DATA),      BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_ARRAY),     BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_ABSOLUTE),  BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_NOWRAP),    BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_LINEAR),    BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_PREFSTATE), BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_NULL),      BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_NONVOL),    BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_BITFIELD),  BM_SETCHECK,TRUE,0);
            return TRUE;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {

                // These represent bit values of 0, so clear
                //  the bit which corresponds to the number in wParam
                //  after subtracting 0x1000
                case IDC_DATA:      
                case IDC_ARRAY:     
                case IDC_ABSOLUTE:  
                case IDC_NOWRAP:    
                case IDC_LINEAR:    
                case IDC_PREFSTATE: 
                case IDC_NULL:      
                case IDC_NONVOL:
                case IDC_BITFIELD:
                    gInputVal &= (wParam - 0x1000);
                    return TRUE;


                // These represent bit values of 1, so set 
                //  the bit which corresponds to the number in wParam
                //  after subtracting 0x1000
                case IDC_CONST:     
                case IDC_VARIABLE:  
                case IDC_RELATIVE:  
                case IDC_WRAP:      
                case IDC_NONLINEAR: 
                case IDC_NOPREF:    
                case IDC_NONULL:    
                case IDC_BUFFERED:
                    gInputVal |= (wParam - 0x1000);
                    return TRUE;

                case IDOK:
                    EndDialog(hDlg,TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    return TRUE;
            }
        default:
            return FALSE;

    }

    return FALSE;

}
***/

/*******************************************************************************
**
** BOOL CALLBACK MainItemDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARM lPram)
**
** DESCRIPTION: Dialog box proc for Input entities
**              
**
**  PARAMETERS: Your standard Dialog box proc parms, plus....
**              
**
**     RETURNS:
**
*******************************************************************************/
BOOL CALLBACK MainItemDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_INITDIALOG:
            gMainItemVal = 0;
            SendMessage(GetDlgItem(hDlg,IDC_DATA),      BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_ARRAY),     BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_ABSOLUTE),  BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_NOWRAP),    BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_LINEAR),    BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_PREFSTATE), BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_NULL),      BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_NONVOL),    BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_BITFIELD),  BM_SETCHECK,TRUE,0);
            return TRUE;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {

                // These represent bit values of 0, so clear
                //  the bit which corresponds to the number in wParam
                //  after subtracting 0x1000
                case IDC_DATA:      
                case IDC_ARRAY:     
                case IDC_ABSOLUTE:  
                case IDC_NOWRAP:    
                case IDC_LINEAR:    
                case IDC_PREFSTATE: 
                case IDC_NULL:      
                case IDC_NONVOL:
                case IDC_BITFIELD:
                    gMainItemVal &= (wParam - 0x1000);
                    return TRUE;


                // These represent bit values of 1, so set
                //  the bit which corresponds to the number in wParam
                //  after subtracting 0x1000
                case IDC_CONST:     
                case IDC_VARIABLE:  
                case IDC_RELATIVE:  
                case IDC_WRAP:      
                case IDC_NONLINEAR: 
                case IDC_NOPREF:    
                case IDC_NONULL:    
                case IDC_VOL:
                case IDC_BUFFERED:
                    gMainItemVal |= (wParam - 0x1000);
                    return TRUE;

                case IDOK:
                    EndDialog(hDlg,TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    return TRUE;
            }
        default:
            return FALSE;

    }

    return FALSE;

}

/*******************************************************************************
**
** BOOL CALLBACK UnitDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARM lPram)
**
** DESCRIPTION: Dialog box proc for Unit entities
**              
**
**  PARAMETERS: Your standard Dialog box proc parms, plus....
**              
**
**     RETURNS:
**
*******************************************************************************/
BOOL CALLBACK UnitDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_INITDIALOG:
            gUnitVal = 0;
            SendMessage(GetDlgItem(hDlg,IDC_SYSNONE),BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_ZERO1),BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_ZERO2),BM_SETCHECK,TRUE,0);
            SendMessage(GetDlgItem(hDlg,IDC_ZERO3),BM_SETCHECK,TRUE,0);

            return TRUE;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDC_SYSNONE:
                case IDC_SILIN:                       
                case IDC_SIROT:                       
                case IDC_ENGLIN:                      
                case IDC_ENGROT:                      
                case IDC_ELECTRIC:                    
                case IDC_TEMP:                        
                case IDC_LUMINOSITY:                  
                case IDC_TBD:                         
                case IDC_VENDOR:                      
                case IDC_TBD1:                        
                case IDC_TBD2:                        
                case IDC_TBD3:                        
                case IDC_TBD4:                        
                case IDC_TBD5:                        
                case IDC_TBD6:                        
                    gUnitVal |= (LOWORD(wParam) - IDC_SYSNONE);
                    return TRUE;

                // Length Nibble
                case IDC_ZERO1:       
                case IDC_ONE1:        
                case IDC_TWO1:        
                case IDC_THREE1:      
                case IDC_FOUR1:       
                case IDC_FIVE1:       
                case IDC_SIX1:        
                case IDC_SEVEN1:      
                case IDC_NEGEIGHT1:   
                case IDC_NEGSEVEN1:   
                case IDC_NEGSIX1:     
                case IDC_NEGFIVE1:    
                case IDC_NEGFOUR1:    
                case IDC_NEGTHREE1:   
                case IDC_NEGTWO1:     
                case IDC_NEGONE1:     
                    gUnitVal |= ((LOWORD(wParam) - IDC_ZERO3) << 4);
                    return TRUE;    
                // Mass - Nibble2
                case IDC_ZERO2:       
                case IDC_ONE2:        
                case IDC_TWO2:        
                case IDC_THREE2:      
                case IDC_FOUR2:       
                case IDC_FIVE2:       
                case IDC_SIX2:        
                case IDC_SEVEN2:      
                case IDC_NEGEIGHT2:   
                case IDC_NEGSEVEN2:   
                case IDC_NEGSIX2:     
                case IDC_NEGFIVE2:    
                case IDC_NEGFOUR2:    
                case IDC_NEGTHREE2:   
                case IDC_NEGTWO2:     
                case IDC_NEGONE2:     
                    gUnitVal |= ((LOWORD(wParam) - IDC_ZERO3) << 8);
                    return TRUE;    
                // Time - Nibble3
                case IDC_ZERO3:       
                case IDC_ONE3:        
                case IDC_TWO3:        
                case IDC_THREE3:      
                case IDC_FOUR3:       
                case IDC_FIVE3:       
                case IDC_SIX3:        
                case IDC_SEVEN3:      
                case IDC_NEGEIGHT3:   
                case IDC_NEGSEVEN3:   
                case IDC_NEGSIX3:     
                case IDC_NEGFIVE3:    
                case IDC_NEGFOUR3:    
                case IDC_NEGTHREE3:   
                case IDC_NEGTWO3:     
                case IDC_NEGONE3:     
                    gUnitVal |= ((LOWORD(wParam) - IDC_ZERO3) << 12);
                    return TRUE;    

               

                case IDOK:
                    EndDialog(hDlg,TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    return TRUE;
            }
        default:
            return FALSE;

    }

    return FALSE;

}

/*******************************************************************************
**
** BOOL CALLBACK ExponentDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARM lPram)
**
** DESCRIPTION: Dialog box proc for Exponent entities
**              
**
**  PARAMETERS: Your standard Dialog box proc parms, plus....
**              
**
**     RETURNS:
**
*******************************************************************************/
BOOL CALLBACK ExponentDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_INITDIALOG:
            gExpVal = 0;
            SendMessage(GetDlgItem(hDlg,IDC_ZERO),BM_SETCHECK,TRUE,0);
            return TRUE;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {

                //
                // Exponent. Lower byte represents code
                case IDC_ZERO:     
                case IDC_ONE:      
                case IDC_TWO:      
                case IDC_THREE:    
                case IDC_FOUR:     
                case IDC_FIVE:     
                case IDC_SIX:     
                case IDC_SEVEN:    
                case IDC_NEGEIGHT: 
                case IDC_NEGSEVEN:
                case IDC_NEGSIX:   
                case IDC_NEGFIVE:  
                case IDC_NEGFOUR:  
                case IDC_NEGTHREE:     
                case IDC_NEGTWO:   
                case IDC_NEGONE:   
                    gExpVal = (wParam - 0x4000);
                    return TRUE;

                case IDOK:
                    EndDialog(hDlg,TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    return TRUE;
            }
        default:
            return FALSE;

    }

    return FALSE;

}

/*******************************************************************************
**
** BOOL CALLBACK UsagePageDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARM lPram)
**
** DESCRIPTION: Dialog box proc for UsagePage entities
**              
**
**  PARAMETERS: Your standard Dialog box proc parms, plus....
**              
**
**     RETURNS:
**
*******************************************************************************/
BOOL CALLBACK UsagePageDlgProc( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static HWND hwndListBox;
    int i;

    switch(msg)
    {
        case WM_INITDIALOG:
            hwndListBox = GetDlgItem(hDlg,IDC_LIST1);
            gUsagePageVal = 0;
            for(i=0;i<MAX_USAGE_PAGES;i++)
                SendMessage(hwndListBox,LB_ADDSTRING,0,(LPARAM)szUsagePage[i]);
            SendMessage(hwndListBox,LB_SETCURSEL,0,0);
            SetFocus(hwndListBox);
            return TRUE;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {

                case IDC_LIST1:
                    if( HIWORD(wParam) == LBN_DBLCLK )
                    {
                        gUsagePageVal = (BYTE) SendMessage(hwndListBox,LB_GETCURSEL,0,0);
                        EndDialog(hDlg,TRUE);
                    }
                    if( HIWORD(wParam) == LBN_SELCHANGE )
                        gUsagePageVal = (BYTE) SendMessage(hwndListBox,LB_GETCURSEL,0,0);
                    return TRUE;
                
                case IDOK:
                    EndDialog(hDlg,TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    return TRUE;
            }
        default:
            return FALSE;

    }

    return FALSE;



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\hidmon\class.h ===
/***************************************************************************************************
**
**      MODULE:
**
**
** DESCRIPTION: 
**
**
**      AUTHOR: Daniel Dean.
**
**
**
**     CREATED:
**
**
**
**
** (C) C O P Y R I G H T   D A N I E L   D E A N   1 9 9 6.
***************************************************************************************************/
#include <hidsdi.h>


#define SUCCESS     0
#define FAILURE     (!SUCCESS)
#define WINDOWMENU  1  /* position of window menu     */

#ifdef RC_INVOKED
#define ID(id) id
#else
#define ID(id) MAKEINTRESOURCE(id)
#endif


// Extra bytes associated with each child window
#define CBWNDEXTRA sizeof(ULONG)*5

#define SetDeviceHandle(pw, h)  SetWindowLong(pw, 0, (LONG) h)
#define GetDeviceHandle(w)      (HANDLE)GetWindowLong(w, 0)

#define SetEditWin(pw, w)       SetWindowLong(pw, 4, (LONG) w)
#define GetEditWin(w)           (HWND)GetWindowLong(w, 4)

#define SetThreadData(pw, p)    SetWindowLong(pw, 8, (LONG) p)
#define GetThreadData(w)        (PREADTHREAD)GetWindowLong(w, 8)

#define SetThreadDataSize(pw,p) SetWindowLong(pw,12,(ULONG) p)
#define GetThreadDataSize(w)    (ULONG)GetWindowLong(w, 12)

#define SetDeviceInfo(pw,p)     SetWindowLong(pw,16,(ULONG) p)
#define GetDeviceInfo(w)        (ULONG)GetWindowLong(w, 16)


#define EDIT_WRAP           (WS_CHILD | WS_VISIBLE | ES_NOHIDESEL | ES_AUTOVSCROLL | ES_MULTILINE | ES_LEFT)




/* resource ID's */
#define IDHIDFRAME  ID(1)
#define IDHIDCHILD  ID(2)
#define IDHIDMENU   ID(3)

#define IDS_CLIENTTITLE                 16
#define IDS_UNTITLED                    17
#define IDS_APPNAME                     18

#define IDD_CHANNELDIALOG               102
#define IDC_ITEMLIST                    1000
#define IDC_NEXT                        1001

#define IDM_FILENEW                     1001
#define IDM_FILEEXIT                    1006
#define IDM_FILEREENUM                  1007
#define IDM_DEVICECHANGE				1008

#define IDM_CHANNEL                     2001
#define IDM_DEVICE                      2002
#define IDM_ENABLE                      2003
#define IDM_DISABLE                     2004
#define IDM_READ                        2005
#define IDM_WRITE                       2006
#define IDM_STOP                        2007


#define IDEDIT                          3001


#define IDM_WINDOWTILE                  4001
#define IDM_WINDOWCASCADE               4002
#define IDM_WINDOWCLOSEALL              4003
#define IDM_WINDOWICONS                 4004
#define IDM_WINDOWCHILD                 4100

#define IDT_TIMER						5000

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3
#define FILE_DEVICE_MOUSE               0x0000000f

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe


#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)


/* Structs */

//
// Every MDI child window has one of these structures
//  associated with it.
typedef struct _CHILDINFO{

    PHIDP_PREPARSED_DATA hidPPData;         // Pointer the preparsed data for this device
    ULONG                ulMaxUsageListLen; // Max usages returned from HidP_GetUsage
    PHIDP_CAPS           hidCaps;           // Pointer to struct containing capabilitis for this device
	PHIDP_VALUE_CAPS	 pValueCaps;		// Pointer to a list of Value channel description structs
	ULONG				 NumValues;			// Number of Value channels on this device
	PHIDP_BUTTON_CAPS	 pButtonCaps;		// Pointer to a list of Button channel description structs
	ULONG                NumButtons;		// Number of Button channels on this device

} CHILD_INFO, *PCHILD_INFO;

/* External variable declarations */
extern HANDLE hInst;       /* application instance handle  */
extern HWND hWndFrame;     /* main window handle           */
extern HWND hWndMDIClient; /* handle of MDI Client window  */
extern LONG styleDefault;  /* default child creation state */
extern char szChild[];     /* class of child               */



/* External functions */
ULONG        InitializeApplication(VOID);
ULONG        InitializeInstance(LPSTR, INT);
VOID         OpenClassObjects(VOID);
HWND         MakeNewChild(PCHAR pName, HANDLE hDevice);
VOID         CommandHandler(HWND hWnd, UINT uParam);
VOID         CloseAllChildren (VOID);
LONG  WINAPI HIDFrameWndProc(HWND, UINT, WPARAM, LPARAM);
LONG  WINAPI HIDMDIChildWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT      PopUpMenu(HANDLE hInst, HWND hWnd, HWND hMWnd, LPARAM lPoint, LPSTR lpMenu);
void		 GetDeviceDescription(char *,char *);
BOOL CALLBACK ChannelDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\hidmon\ioctl.c ===
/***************************************************************************************************
**
**      MODULE:
**
**
** DESCRIPTION: 
**
**
**      AUTHOR: Daniel Dean.
**
**
**
**     CREATED:
**
**
**
**
** (C) C O P Y R I G H T   D A N I E L   D E A N   1 9 9 6.
***************************************************************************************************/
#include <WINDOWS.H>
#include <string.h>
#include <hidsdi.h>
#include <hidusage.h>
#include "CLASS.H"
#include "IOCTL.H"
#include "resource.h"

/***************************************************************************************************
**
** IOCTLChannelDesc.
**
** DESCRIPTION:  
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
LPARAM IOCTLChannelDesc(HWND hWnd)
{

   FARPROC lpfnProc;
   HINSTANCE hInstance = (HINSTANCE) GetWindowLong(hWnd, GWL_HINSTANCE);
   

   if((lpfnProc=(FARPROC)MakeProcInstance(ChannelDialogProc, hInstance)) != NULL)
   {
      DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_CHANNELDIALOG), hWnd, lpfnProc,(LPARAM)hWnd);
      FreeProcInstance(lpfnProc);
   }
	return  SUCCESS;
}
/***************************************************************************************************
**
** ChannelDialogProc()
**
** DESCRIPTION: Dialog Box procedure fot the Channel Info dialog 
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
BOOL CALLBACK ChannelDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static HWND         hwndMama;
    static PCHILD_INFO  pChildInfo;
    static ULONG        Index = 0;
    static BOOL         fValues = TRUE;     // Are we displaying 'Value' channels?
                                            //  If not we are displaying 'Button' channels
    HANDLE  hListBox;
    char    buff[32];

    switch(uMsg)
    {
        case WM_INITDIALOG:
            hwndMama = (HWND)lParam;
			pChildInfo = (PCHILD_INFO)GetDeviceInfo(hwndMama);
            SendMessage(hDlg,WM_COMMAND,IDC_NEXT,0);
            return TRUE;

        case WM_COMMAND:
        {
            switch(wParam)
            {
                case IDOK:
                    EndDialog(hDlg,0);
                    return TRUE;

                case IDC_NEXT:
                    hListBox = GetDlgItem(hDlg,IDC_ITEMLIST);
                    SendMessage(hListBox,LB_RESETCONTENT,0,0);
                    
                    if( fValues )
                    {
						wsprintf(buff,"Value Channel %d",Index);
						SetWindowText(hDlg,buff);
                        
						if( Index < pChildInfo->NumValues )
                        {
                            
                            wsprintf(buff,"UsagePage = %d",pChildInfo->pValueCaps[Index].UsagePage);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            wsprintf(buff,"ReportID = %d",pChildInfo->pValueCaps[Index].ReportID);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            if( pChildInfo->pValueCaps[Index].IsRange)
                            {
                                wsprintf(buff,"UsageMin = %d",pChildInfo->pValueCaps[Index].Range.UsageMin);
                                SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                                wsprintf(buff,"UsageMax = %d",pChildInfo->pValueCaps[Index].Range.UsageMax);
                                SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                                wsprintf(buff,"StringMin = %d",pChildInfo->pValueCaps[Index].Range.StringMin);
                                SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                                wsprintf(buff,"StringMax = %d",pChildInfo->pValueCaps[Index].Range.StringMax);
                                SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                                wsprintf(buff,"DesignatorMin = %d",pChildInfo->pValueCaps[Index].Range.DesignatorMin);
                                SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                                wsprintf(buff,"DesignatorMax = %d",pChildInfo->pValueCaps[Index].Range.DesignatorMax);
                                SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            }
                            else
                            {
                                wsprintf(buff,"Usage = %d",pChildInfo->pValueCaps[Index].NotRange.Usage);
                                SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                                wsprintf(buff,"StringIndex = %d",pChildInfo->pValueCaps[Index].NotRange.StringIndex);
                                SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                                wsprintf(buff,"DesignatorIndex = %d",pChildInfo->pValueCaps[Index].NotRange.DesignatorIndex);
                                SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            }
                            if( pChildInfo->pValueCaps[Index].HasNull )
                            {
                                wsprintf(buff,"NULL = %d",pChildInfo->pValueCaps[Index].Null);
                                SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            }
                            wsprintf(buff,"LogicalMin = %d",pChildInfo->pValueCaps[Index].LogicalMin);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            wsprintf(buff,"LogicalMax = %d",pChildInfo->pValueCaps[Index].LogicalMax);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            wsprintf(buff,"PhysicalMin = %d",pChildInfo->pValueCaps[Index].PhysicalMin);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            wsprintf(buff,"PhysicalMax = %d",pChildInfo->pValueCaps[Index].PhysicalMax);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);

                            Index++;
                        }
                        else
                        {
                            Index = 0;
                            fValues = FALSE;
                        }
                    
                    }    
                    else
                    if( Index < pChildInfo->NumButtons )
                    {
                        hListBox = GetDlgItem(hDlg,IDC_ITEMLIST);
						wsprintf(buff,"Button Channel %d",Index);
						SetWindowText(hDlg,buff);
                        
                        wsprintf(buff,"UsagePage = %d",pChildInfo->pValueCaps[Index].UsagePage);
                        SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                        wsprintf(buff,"ReportID = %d",pChildInfo->pValueCaps[Index].ReportID);
                        SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                        if( pChildInfo->pValueCaps[Index].IsRange)
                        {
                            wsprintf(buff,"UsageMin = %d",pChildInfo->pValueCaps[Index].Range.UsageMin);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            wsprintf(buff,"UsageMax = %d",pChildInfo->pValueCaps[Index].Range.UsageMax);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            wsprintf(buff,"StringMin = %d",pChildInfo->pValueCaps[Index].Range.StringMin);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            wsprintf(buff,"StringMax = %d",pChildInfo->pValueCaps[Index].Range.StringMax);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            wsprintf(buff,"DesignatorMin = %d",pChildInfo->pValueCaps[Index].Range.DesignatorMin);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            wsprintf(buff,"DesignatorMax = %d",pChildInfo->pValueCaps[Index].Range.DesignatorMax);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                        }
                        else
                        {
                            wsprintf(buff,"Usage = %d",pChildInfo->pValueCaps[Index].NotRange.Usage);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            wsprintf(buff,"StringIndex = %d",pChildInfo->pValueCaps[Index].NotRange.StringIndex);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                            wsprintf(buff,"DesignatorIndex = %d",pChildInfo->pValueCaps[Index].NotRange.DesignatorIndex);
                            SendMessage(hListBox,LB_ADDSTRING,0,(LPARAM)(LPCTSTR)buff);
                        }
                        Index++;
                    }
                    else
                    {
                        fValues = TRUE;
                        Index = 0;
                    }
                    return TRUE;

            }

        
        }//end case WM_COMMAND

        
    }//end switch(uMsg)

    return FALSE;
}
/***************************************************************************************************
**
** IOCTLDeviceDesc.
**
** DESCRIPTION: 
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
LPARAM IOCTLDeviceDesc(HWND hWnd)
{
	return  SUCCESS;
}

/***************************************************************************************************
**
** IOCTLRead.
**
** DESCRIPTION: 
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
LPARAM IOCTLRead(HWND hWnd)
{
    ULONG dwThreadID;
    HANDLE hThread;
    PREADTHREAD pThreadData;


    OutputDebugString(">>>>HIDMON.EXE: IOCTLRead() Enter\n");

    // If a read or a write is in progress stop it 
    if(GetThreadData(hWnd))
        IOCTLStop(hWnd);

    // Get the number of bytes of data for this device 
    
 
    // Allocate and setup a thread variables
    pThreadData = (PREADTHREAD) GlobalAlloc(GPTR, sizeof(READTHREAD));
    
    if(!pThreadData)
    {
        MessageBox(hWnd,"IOCTLRead(): GlobalAlloc fialed","Ooops!",MB_OK);
        return FALSE;
    }

    pThreadData->hEditWin   = GetEditWin(hWnd);
    pThreadData->ThisThread = TRUE;
    pThreadData->hDevice    = GetDeviceHandle(hWnd);
    pThreadData->hWnd       = hWnd;
    // Create Data notification thread
    hThread = CreateThread((LPSECURITY_ATTRIBUTES) NULL,
                           (DWORD) 0, 
                           (LPTHREAD_START_ROUTINE) ReadWatch,
                           (LPVOID) pThreadData,
                           CREATE_SUSPENDED,
                           &dwThreadID);
    if(!hThread)
    {
        GlobalFree(pThreadData);
        MessageBox(hWnd,"IOCTLRead(): CreateThread fialed","Ooops!",MB_OK);
        return FAILURE;
    }
    SetThreadData(hWnd, pThreadData);

    // Set Thread priority and start thread
    SetThreadPriority(hThread, THREAD_PRIORITY_TIME_CRITICAL);
    ResumeThread(hThread);

    return  SUCCESS;
}

/***************************************************************************************************
**
** IOCTLWrite.
**
** DESCRIPTION: 
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
LPARAM IOCTLWrite(HWND hWnd)
{
    ULONG dwReturn = 0;
    OVERLAPPED Overlapped;
    
    
    // If a read or a write is in progress stop it 
    if(GetThreadData(hWnd))
        IOCTLStop(hWnd);

    // Need a way to get data froom user
    // Need a way to get channel number from user

    Overlapped.Offset = 3; 
    Overlapped.hEvent = NULL; 

    dwReturn = 0;
    WriteFile(GetDeviceHandle(hWnd), (PVOID) "Hello", sizeof("Hello"), &dwReturn, &Overlapped);

    return  SUCCESS;
}

/***************************************************************************************************
**
** IOCTLStop.
**
** DESCRIPTION: 
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
LPARAM IOCTLStop(HWND hWnd)
{
    PREADTHREAD pThreadData;
    
    OutputDebugString(">>>>HIDMON.EXE: IOCTLStop() Enter\n");


    pThreadData = GetThreadData(hWnd);

    if(pThreadData)
    {
    	SetThreadData(hWnd, 0);
        pThreadData->ThisThread = FALSE;
  	}
    // Allow the thread to die
    //Sleep(250);
    
    OutputDebugString(">>>>HIDMON.EXE: IOCTLStop() Exit\n");


    return  SUCCESS;
}

/*******************************************************************************
** 
** FUNCTION: ReadWatch()
**  
** PURPOSE:  Read next available packet and display in child window
**
**
**
*******************************************************************************/
#define MAX_CHARS_PER_LINE 128

VOID CALLBACK ReadWatch(HWND hWnd, UINT uMsg, UINT TimerID, DWORD dwTime)
{
    PUCHAR				WriteBuffer;
    PUCHAR				ReadBuffer;
    ULONG				NumChannels;  
    ULONG				NumBytes;
    ULONG				LogicalReturn;
    READTHREAD			ThreadData;
    OVERLAPPED			OV;
    PCHILD_INFO			pChildInfo;

    OutputDebugString(">>>>HIDMON.EXE: ReadWatch() Enter\n");

    // Retrieve info for this child
	pChildInfo = (PCHILD_INFO)GetDeviceInfo(hWnd);
    
    NumChannels = pChildInfo->hidCaps->NumberInputValueCaps + 
		          pChildInfo->hidCaps->NumberInputButtonCaps;
    NumBytes    = pChildInfo->hidCaps->InputReportByteLength;


	// Allocate memory for our ReadBuffer
    ReadBuffer = (PUCHAR) GlobalAlloc(GPTR,NumBytes); 
    if(!ReadBuffer)
        return;// FALSE;

    // Allocate memory for our 'screen' buffer
    WriteBuffer = (PUCHAR) GlobalAlloc(GPTR,NumChannels*MAX_CHARS_PER_LINE);
    if(!WriteBuffer)									
    {
        GlobalFree(ReadBuffer);
        return;// FALSE;
    }

    // Setup read buffer
    memset(ReadBuffer, 0, NumBytes);
    // Setup overlapped structure
    memset(&OV, 0, sizeof(OVERLAPPED));
	// Start read
	LogicalReturn = ReadFileEx(GetDeviceHandle(hWnd),
                               (LPVOID) ReadBuffer,
                               NumBytes,
                               &OV,
                               NULL);

    // Print error message if failed
    if(!LogicalReturn)
        SendMessage(ThreadData.hEditWin,
                    WM_SETTEXT,
                    (WPARAM) sizeof("ReadFile FAILED!"),
                    (LPARAM) "ReadFile FAILED!");
    else
    if( LogicalReturn )
    {
        PCHAR		pChar = WriteBuffer;
		NTSTATUS	rc;
        char		tmpBuff[256],tmpBuff2[256];
        ULONG		i,Value;
		
		
		//
		// Parse the data from our last Read
		//
		
		// Clear the buffer
		memset(WriteBuffer,'\0',NumChannels*MAX_CHARS_PER_LINE);

        // Make Text strings
        
		// First do the Value channels
		for(i=0;i<pChildInfo->hidCaps->NumberInputValueCaps;i++)
        {
           
    		rc = HidP_GetUsageValue(HidP_Input,
									pChildInfo->pValueCaps[i].UsagePage,
									0,
									pChildInfo->pValueCaps[i].NotRange.Usage,
									&Value,
									pChildInfo->hidPPData,
									ReadBuffer,
									NumBytes );
        
			wsprintf(tmpBuff,"Value: Usage[%02d]:[%02d] = %d\r\n",
							  pChildInfo->pValueCaps[i].UsagePage,			 
							  pChildInfo->pValueCaps[i].NotRange.Usage,
                              Value         );
			
			strcat(WriteBuffer,tmpBuff);
            
		
		}

		// Then do the button channels
		for(i=0;i<pChildInfo->hidCaps->NumberInputButtonCaps;i++)
		{
			PUCHAR pUsageList;
			DWORD ulUsageListLen; 
			//UCHAR TempBuff[256];

	  		// Get the maximum usage list length
            ulUsageListLen = HidP_MaxUsageListLength( HidP_Input, 
                                                      pChildInfo->pButtonCaps[i].UsagePage, 
                                                      pChildInfo->hidPPData    );
		
            pUsageList = (PUCHAR)GlobalAlloc(GMEM_FIXED,ulUsageListLen);

			wsprintf( tmpBuff,"Buttons:[%02d]:[%02d] = ",pChildInfo->pButtonCaps[i].UsagePage,
                                                         pChildInfo->pButtonCaps[i].NotRange.Usage);

			ulUsageListLen++;
			rc = HidP_GetUsages(HidP_Input,
								pChildInfo->pButtonCaps[i].UsagePage,
								pChildInfo->pButtonCaps[i].LinkCollection,
								pUsageList,
								&ulUsageListLen,
								pChildInfo->hidPPData,
								ReadBuffer,
								NumBytes );
			
			// if Buttons are pressed
			if( ulUsageListLen )
			{
				ULONG i;
                for(i=0;i<ulUsageListLen;i++)
				{
					wsprintf(tmpBuff2,"0x%02X ",pUsageList[i]);
					strcat(tmpBuff,tmpBuff2);
				}
			}
			strcat(tmpBuff,"\r\n");
			strcat(WriteBuffer,tmpBuff);

			
			GlobalFree(pUsageList);
			
			//i=pChildInfo->NumButtons;
		}

        SendMessage(GetEditWin(hWnd),//ThreadData.hEditWin,
                    WM_SETTEXT,
                    (WPARAM) strlen(WriteBuffer), 
                    (LPARAM) WriteBuffer);
    
	}// end if(LogicalReturn)
        

    //
	GlobalFree(ReadBuffer);
    GlobalFree(WriteBuffer);
    //TESTING!!
	
    OutputDebugString(">>>>HIDMON.EXE: ReadWatch() Exit\n");


    return;// TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\hidmon\hidini.c ===
/***************************************************************************************************
**
**      MODULE:
**
**
** DESCRIPTION: 
**
**
**      AUTHOR: Daniel Dean.
**
**
**
**     CREATED:
**
**
**
**
** (C) C O P Y R I G H T   D A N I E L   D E A N   1 9 9 6.
***************************************************************************************************/
#include <WINDOWS.H>
#include <string.h>                 // for strncmp() and wcstrok()
#include <crtdbg.h>
#include <hidsdi.h>					// HID parsing library
#include <hidusage.h>
#include <HID.H>                 
#include "public.h"
#include "CLASS.H"
#include "IOCTL.H"


PWSTR wcGetNullDelimitedItemFromList( PWSTR pszzList );

PWSTR UnicodeString = L"This is Unicode\0Dis is more\0\0";

char szFrame[] = "HIDMON frame";    // Class name for "frame" window
char szChild[] = "HIDMON child";    // Class name for MDI window



/****************
  TESTING!!!!!!!
 ****************/
typedef  char* PGUID;

NTSTATUS
IoGetDeviceClassAssociations(
    IN PGUID            ClassGuid,
    OUT PWSTR          *SymbolicLinkList
    );

/****
NTSTATUS
IoGetDeviceClassAssociations(
    IN  PGUID  ClassGuid,
    OUT PWSTR  *SymbolicLinkList
    )
{
    
    *SymbolicLinkList = UnicodeString;
    return TRUE;
}
****/
/***
BOOLEAN
HidD_GetGuidString (
   OUT   PCHAR *     GuidClassInputString
   )
   { return TRUE; }
***/

/***************************************************************************************************
**
** InitializeApplication.
**
** DESCRIPTION: Sets up the class data structures and does a one-time,
**              initialization of the app by registering the window classes
**
**  PARAMETERS:
**
**     RETURNS: TRUE if successful else FALSE.
**
***************************************************************************************************/
ULONG InitializeApplication(VOID)
{
    WNDCLASS  wc;


    // Register the frame class 
    wc.style         = CS_DBLCLKS;
    wc.lpfnWndProc   = HIDFrameWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInst;
    wc.hIcon         = LoadIcon(hInst, IDHIDFRAME);
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_APPWORKSPACE+1);
    wc.lpszMenuName  = IDHIDMENU;
    wc.lpszClassName = szFrame;

    if(RegisterClass(&wc))
    {
        // Register the MDI child class 
        wc.lpfnWndProc   = HIDMDIChildWndProc;
        wc.hIcon         = LoadIcon(hInst,IDHIDCHILD);
        wc.lpszMenuName  = NULL;
        wc.cbWndExtra    = CBWNDEXTRA;
        wc.lpszClassName = szChild;

        if(RegisterClass(&wc))
            return TRUE;
    }
    return FALSE;
}

/***************************************************************************************************
**
** InitializeInstance.
**
** DESCRIPTION: Performs a per-instance initialization of HIDMDI. It
**              also creates the frame and one MDI child window.
**
**  PARAMETERS:
**
**     RETURNS: TRUE if successful else FALSE.
**
***************************************************************************************************/
ULONG InitializeInstance(LPSTR lpCmdLine, INT WindowState)
{
    extern HWND   hWndMDIClient;
	CHAR   sz[80];

    // Get the base window title
    LoadString (hInst, IDS_APPNAME, sz, sizeof(sz));

    // Create the frame 
    // MDI Client window is created in frame's WM_CREATE case
    hWndFrame = CreateWindow(szFrame,
                             sz,
                             WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                             CW_USEDEFAULT,
                             0,
                             CW_USEDEFAULT,
                             0,
                             NULL,
                             NULL,
                             hInst,
                             NULL);

    if(hWndFrame && hWndMDIClient)
    {
        // Display the frame window 
        ShowWindow (hWndFrame, WindowState);
        UpdateWindow (hWndFrame);
        // Open all the Class device objects
        OpenClassObjects(); 
        return TRUE;
    }
    return FALSE;
}
/***************************************************************************************************
**
** OpenClassObjects.
**
** DESCRIPTION: Creates a new MDI child window.
**
**  PARAMETERS:
**
**     RETURNS: TRUE if successful else FALSE.
**
***************************************************************************************************/
#define MAX_DEVICE_NAME_LEN 255

VOID OpenClassObjects(VOID)
{
    HANDLE  hDevice,hGetDeviceClassDriver;
    BOOL    rc;
	//PWSTR   pwszDeviceList;     // UNICODE strings
    WORD    wszDeviceList[1024];
	PWSTR   pwszDeviceName;
    PCHAR   pszGUID;
    char    pszDeviceName[MAX_DEVICE_NAME_LEN];
	char	pszHumanName[MAX_DEVICE_NAME_LEN];
	DWORD   dwReturn;

    if( 1 )//rc = HidD_GetGuidString( &pszGUID ) )
	{
		//
        // If we got a GUID string, retrieve a list of null terminated device
        //  name UNICODE strings similar to \\.\Device. This list is terminated
        //  by a double NULL
        //rc = IoGetDeviceClassAssociations(pszGUID,&pwszDeviceList);
		
		hGetDeviceClassDriver = CreateFile(TEST_DEVICE,
								GENERIC_READ | GENERIC_WRITE,
								0,
								NULL,
								OPEN_EXISTING,
								0,
								NULL);

        if( hGetDeviceClassDriver != INVALID_HANDLE_VALUE)
			rc = DeviceIoControl(hGetDeviceClassDriver,
                                 IOCTL_GET_DEVICE_CLASS_ASSOC,
                                 NULL,
                                 0,
                                 wszDeviceList,
                                 1024*2,
                                 &dwReturn,
                                 NULL);
		else
			MessageBox(NULL,"Failed to load Test driver TEST.SYS","Error",MB_OK);

		CloseHandle(hGetDeviceClassDriver);
		
		pwszDeviceName = wcGetNullDelimitedItemFromList( wszDeviceList ); 
		do{
		    
            // Convert the device name to ANSI
            WideCharToMultiByte( CP_ACP,                // ANSI Code Page
                                 0,                     // No flags
                                 pwszDeviceName,        // UNICODE string
                                 -1,                    // String is NULL terminated
                                 pszDeviceName,         // ANSI string
                                 MAX_DEVICE_NAME_LEN,   // Lenght of ANSI string buffer
                                 NULL,                  // No default character
                                 NULL );
            	
			// Open the Class device
			hDevice = CreateFile(pszDeviceName,
								GENERIC_READ | GENERIC_WRITE,
								0,
								NULL,
								OPEN_EXISTING,
								0,
								NULL);

			if(hDevice != INVALID_HANDLE_VALUE )
            {
				// Turn our DeviceName into a Human Readable name 
				GetDeviceDescription(pszDeviceName, pszHumanName);	
				// Create the window
				MakeNewChild(pszHumanName, hDevice);
            }
			else
				MessageBox(NULL,"CreateFile(pszDeviceName) failed","Get On The Bus!",MB_OK);
		
		 // Get the next device name
        }while( pwszDeviceName = wcGetNullDelimitedItemFromList( NULL ) ); //wcstok(NULL,L"\0") );
	
	    // TESTING!!!! remove comments from free()
        // Remember to free the GUID string memory
        //free(pszGUID);
    }


}
/***************************************************************************************************
**
** GetDeviceDescription( char *pszDevice, char *pszName)
**
**  DESCRIPTION:    Given DeviceName string as returned from IoGetDeviceClassAssociations,
**                  place a NULL terminated string retrieved from HKLM\Enum\USB(...)\DeviceDescription
**					in pszName
**
**  PARAMETERS:     char* pszDevice - Pointer to an ANSII string returned from IoGetDeviceClassAssociations
**                  char* pszName   - Pointer to string to return name of device in              
**
**  RETURNS:        void
**
***************************************************************************************************/
void GetDeviceDescription(char *pszDevice, char *pszName)
{
	HKEY	hkReg;
	LONG	rc;
	LONG	BytesWritten=MAX_DEVICE_NAME_LEN;
	char	*head;
	char    szRegPath[MAX_DEVICE_NAME_LEN];
	head = pszDevice;

	// first whack off the \\.\USB#
	while( *head++ != '#' );
	pszDevice = head;
	// then replace all instances of # with \
	
	while( *head  )
	{
		if( *head == '#' )
			*head = '\\';
		
		head++;
	
	}
	
	// now, whack off the GUID string (begins with a { ) and preceding \ 
	head = pszDevice;
	while( *head != '{' )
		head++;
	// null terminate it
	*--head = '\0';

	// Create our registry path
	wsprintf(szRegPath,"ENUM\\USB\\%s",pszDevice);
	// open up the Reg and get our human readable name
	rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szRegPath,0,KEY_ALL_ACCESS,&hkReg);

	if( rc == ERROR_SUCCESS )
	{
		// add on the Named value we are looking for
		rc = RegQueryValueEx(hkReg,"DeviceDesc",0,NULL,pszName,&BytesWritten);
		RegCloseKey(hkReg);
	}


}
/***************************************************************************************************
**
** wcGetNullDelimitedItemFromList( PWSTR pszzList)
**
**  DESCRIPTION:    Given a list of NULL terminated strings with the last member being a
**                  double NULL, will return the next string in the list. Operation is similar 
**                  to strtok(): the first time the function is called, a valid list must be passed, 
**                  there after to retrieve member strings, pass NULL in the pszzList param.
**
**  PARAMETERS:     PWSTR pszzList - Pointer to a UNICODE double null terminated list of 
**                                   NULL terminated strings.
**                                  
**
**  RETURNS:        PWSTR  Pointer to the next member of the list or NULL if at end of list.
**
***************************************************************************************************/
PWSTR wcGetNullDelimitedItemFromList( PWSTR pszzList )
{
    static PWSTR CurrentMember=NULL;   // Current pointer into the list
    PWSTR tmp;
    
    //
    // Make sure pszzList is not NULL the first time in
    if( !pszzList && !CurrentMember )
        return NULL;

    //
    // If pszzList is not NULL, we are starting from scratch
    if( pszzList )
        CurrentMember = pszzList;
    //
    // If we have 2 NULL's then we are at the end of the list
    if( (*CurrentMember == L'\0') && (*(CurrentMember+1) == L'\0') )
    {
        CurrentMember=NULL;
        return NULL;
    }
    else
    {
        // Save a pointer to the current member
        tmp = CurrentMember;
        // Incriment to the next member
        while( *CurrentMember++ );
        // Return the current member
        return tmp;
    }
}

/***************************************************************************************************
**
** MakeNewChild.
**
** DESCRIPTION: Creates a new MDI child window.
**
**  PARAMETERS:
**
**     RETURNS: TRUE if successful else FALSE.
**
***************************************************************************************************/

/*
BOOLEAN __stdcall
HidD_MyGetPreparsedData (
   IN    HANDLE                  HidDeviceObject,
   OUT   PHIDP_PREPARSED_DATA  * PreparsedData
   );
*/




HWND MakeNewChild(char *pName, HANDLE hDevice)
{
    HWND					hWnd = 0;
    MDICREATESTRUCT			mcs;
    PCHILD_INFO				pChildInfo;
    PHIDP_PREPARSED_DATA	hidPreParsedData;
	DWORD					err;

	NTSTATUS rc;

    if(pName)
    {
        mcs.szTitle     = (LPSTR)pName;		// Fully qualified pathname
        mcs.szClass     = szChild;
        mcs.hOwner      = hInst;
        mcs.x = mcs.cx  = CW_USEDEFAULT;	// Use the default size for the window
        mcs.y = mcs.cy  = CW_USEDEFAULT;
        mcs.style       = styleDefault;		// Set the style DWORD of the window to default

		// tell the MDI Client to create the child 
        hWnd = (HWND)SendMessage(hWndMDIClient,
                                 WM_MDICREATE,
                                 0,
                                 (LONG)(LPMDICREATESTRUCT)&mcs);
        if(hWnd)
        {
            
            //
            // Create and fill in a device info struct for this window

            pChildInfo = (PCHILD_INFO) GlobalAlloc(GPTR,sizeof(CHILD_INFO));
			pChildInfo->hidCaps = (PHIDP_CAPS)  GlobalAlloc(GPTR,sizeof(HIDP_CAPS));

            // rc = HidD_MyGetPreparsedData( hDevice,&pChildInfo->hidPPData );
            rc = HidD_GetPreparsedData( hDevice,&pChildInfo->hidPPData );
            if( !rc )
				err = GetLastError();
			// Get a pointer to this devices capabilities
            rc = HidP_GetCaps( pChildInfo->hidPPData, pChildInfo->hidCaps );

            // Allocate space for and get a list of Value channel descriptions for this device
			pChildInfo->pValueCaps = (PHIDP_VALUE_CAPS) GlobalAlloc(GPTR,pChildInfo->hidCaps->NumberInputValueCaps*sizeof(HIDP_VALUE_CAPS));
			pChildInfo->NumValues = pChildInfo->hidCaps->NumberInputValueCaps;
			rc = HidP_GetValueCaps(	HidP_Input,
									pChildInfo->pValueCaps,
									&pChildInfo->NumValues,
									pChildInfo->hidPPData
									);
            
			// Allocate space for and get a list of Button channel descriptions for this device
			pChildInfo->pButtonCaps = (PHIDP_BUTTON_CAPS) GlobalAlloc(GPTR,pChildInfo->hidCaps->NumberInputButtonCaps*sizeof(HIDP_BUTTON_CAPS));
			pChildInfo->NumButtons = pChildInfo->hidCaps->NumberInputButtonCaps;
			rc = HidP_GetButtonCaps(HidP_Input,
									pChildInfo->pButtonCaps,
									&pChildInfo->NumButtons,
									pChildInfo->hidPPData
									);

			
			// Save the info!
            SetDeviceInfo(hWnd, pChildInfo);
			SetDeviceHandle(hWnd, hDevice);
            ShowWindow(hWnd, SW_SHOW);
			
			//TESTING!!
			//IOCTLRead(hWnd);
		}
    }
    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\hidmon\hidmon.c ===
/***************************************************************************************************
**
**      MODULE:
**
**
** DESCRIPTION: 
**
**
**      AUTHOR: Daniel Dean.
**
**
**
**     CREATED:
**
**
**
**
** (C) C O P Y R I G H T   D A N I E L   D E A N   1 9 9 6.
***************************************************************************************************/
#include <WINDOWS.H>
#include <dbt.h>                // for device change notification defines
#include <hidsdi.h>
#include "CLASS.H"
#include "IOCTL.H"




HANDLE hInst;                   // Program instance handle
HWND hWndFrame     = NULL;      // Handle to main window
HWND hWndMDIClient = NULL;      // Handle to MDI client
LONG styleDefault  = 0;         // Default style bits for child windows



/***************************************************************************************************
**
** HIDFrameWndProc.
**
** DESCRIPTION: If cases are added for WM_MENUCHAR, WM_NEXTMENU, WM_SETFOCUS,
**              and WM_SIZE, note that these messages should be passed on
**              to DefFrameProc even if we handle them.  See the SDK Reference
**              entry for DefFrameProc
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
LPARAM WINAPI HIDFrameWndProc(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam)
{
    switch(Message)
    {
        case WM_CREATE:
            {
                CLIENTCREATESTRUCT ccs;


                // Find window menu where children will be listed
                ccs.hWindowMenu  = GetSubMenu (GetMenu(hWnd),WINDOWMENU);
                ccs.idFirstChild = IDM_WINDOWCHILD;

                // Create the MDI client
                hWndMDIClient = CreateWindow("mdiclient",
                                             NULL,
                                             WS_CHILD | WS_CLIPCHILDREN,
                                             0,
                                             0,
                                             0,
                                             0,
                                             hWnd,
                                             0,
                                             hInst,
                                             (LPSTR)&ccs);
                ShowWindow(hWndMDIClient,SW_SHOW);
                break;
            }

        case WM_DEVICECHANGE:
            switch( uParam )
            {
                //
                // On removal or insertion of a device, reenumerate the
                //  attached USB devices
                case DBT_DEVICEARRIVAL:
                case DBT_DEVICEREMOVECOMPLETE:
           			CloseAllChildren();
                    //Sleep(1000);
					OpenClassObjects();
                    return TRUE;
            }
            break;
       
        case WM_COMMAND:
            // Direct all menu selection or accelerator commands to
            // the CommandHandler function
            CommandHandler(hWnd,uParam);
            break;


		case WM_CLOSE:
        {
			DestroyWindow(hWnd);
			PostQuitMessage(0);
			break;
        }

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        default:
            // use DefFrameProc() instead of DefWindowProc(), since there
            // are things that have to be handled differently because of MDI
            return DefFrameProc (hWnd,hWndMDIClient,Message,uParam,lParam);
    }
    return 0;
}

/***************************************************************************************************
**
** CloseChildWindow.
**
** DESCRIPTION:
**
**  PARAMETERS:
**
**     RETURNS: VOID.
**
***************************************************************************************************/
VOID CloseChildWindow(HWND hWnd)
{
	HANDLE hDevice;

    OutputDebugString(">>>>HIDMON.EXE: CloseChildWindow()Enter\n");
	IOCTLStop(hWnd);
	
	OutputDebugString(">>>>HIDMON.EXE: CloseChildWindow(): CloseHandle()\n");
    hDevice=GetDeviceHandle(hWnd);
	CloseHandle(hDevice);
	SetDeviceHandle(hWnd,NULL);
	OutputDebugString(">>>>HIDMON.EXE: CloseChildWindow()Exit\n");
	
}

/***************************************************************************************************
**
** HIDMDIChildWndProc.
**
** DESCRIPTION: If cases are added for WM_CHILDACTIVATE, WM_GETMINMAXINFO,
**              WM_MENUCHAR, WM_MOVE, WM_NEXTMENU, WM_SETFOCUS, WM_SIZE,
**              or WM_SYSCOMMAND, these messages should be passed on
**              to DefMDIChildProc even if we handle them. See the SDK
**              Reference entry for DefMDIChildProc.
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
#define IDT_READTIMER 1000

LPARAM WINAPI HIDMDIChildWndProc(HWND hWnd, UINT Message, UINT uParam, LPARAM lParam)
{
    
    PCHILD_INFO pChildInfo;

	switch(Message)
    {
        case WM_CREATE:
        {
            HWND	hEdit;
			HFONT   hfFixed;

			hEdit = CreateWindow("EDIT", 0, EDIT_WRAP, 0, 0, 0, 0, hWnd, NULL, GetModuleHandle(NULL), NULL);
            if(!hEdit)
            {
               MessageBox(hWnd,"ChildWindowProc(): CreateWindow(EDIT) fialed","Ooops!",MB_OK);
               return -1;
            }

            hfFixed = GetStockObject(DEFAULT_GUI_FONT );//ANSI_FIXED_FONT);
            SendMessage(hEdit,WM_SETFONT,(WPARAM)hfFixed,0L);
            SetEditWin(hWnd, hEdit);

        
			// TESTING!!!!!
			SetTimer(hWnd,IDT_TIMER,5,(TIMERPROC)ReadWatch);
			
			return 0;
        }

         
        case WM_COMMAND:
            switch(uParam)
            {
                case IDM_CHANNEL: 	return IOCTLChannelDesc(hWnd);
                case IDM_DEVICE: 	return IOCTLDeviceDesc(hWnd);
                case IDM_READ:   	return IOCTLRead(hWnd);
                case IDM_WRITE: 	return IOCTLWrite(hWnd);
                case IDM_STOP:   	return IOCTLStop(hWnd);
        		default: 			return SUCCESS;
            }

        case WM_SIZE: 		
			return !MoveWindow(GetEditWin(hWnd), 0, 0, (INT) LOWORD(lParam), (INT) HIWORD(lParam), TRUE);
    
		case WM_RBUTTONUP: 	
			SetFocus(hWnd); 
			return PopUpMenu(hInst, hWnd, hWnd, lParam,  "CHILD_MENU");
        
		case WM_MDIDESTROY:
		case WM_DESTROY: 	
			OutputDebugString(">>>>HIDMON.EXE: ChildWndProc WM_DESTROY\n");
			
			//TESTING!!
			KillTimer(hWnd,IDT_TIMER);
			
				CloseChildWindow(hWnd); 
            // Free all the stuff malloc'd for this window
            pChildInfo = (PCHILD_INFO) GetDeviceInfo(hWnd);
            free( pChildInfo->hidPPData);
            GlobalFree( pChildInfo->hidCaps);
            GlobalFree( pChildInfo->pValueCaps);
			GlobalFree( pChildInfo->pButtonCaps);
			GlobalFree( pChildInfo );
			return 0;

        default: 			
			return DefMDIChildProc (hWnd, Message, uParam, lParam);
    }
    return SUCCESS;
}

/***************************************************************************************************
**
** CommandHandler.
**
** DESCRIPTION:
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
VOID CommandHandler(HWND hWnd, UINT uParam)
{
    switch(uParam)
    {
        case IDM_FILEEXIT:
            // Close application
            SendMessage(hWnd, WM_CLOSE, 0, 0L);
            break;

        case IDM_FILEREENUM:
            CloseAllChildren();
            OpenClassObjects();
            break;

        case IDM_WINDOWTILE:
            // Tile MDI windows
            SendMessage(hWndMDIClient, WM_MDITILE, 0, 0L);
            break;

        case IDM_WINDOWCASCADE:
            // Cascade MDI windows
            SendMessage(hWndMDIClient, WM_MDICASCADE, 0, 0L);
            break;

        case IDM_WINDOWICONS:
            // Auto - arrange MDI icons
            SendMessage(hWndMDIClient, WM_MDIICONARRANGE, 0, 0L);
            break;

        case IDM_WINDOWCLOSEALL:
            CloseAllChildren();
            break;

        case IDM_DEVICECHANGE:
			SendMessage(hWnd,WM_DEVICECHANGE,DBT_DEVICEREMOVECOMPLETE,0);
			break;

		default:
            DefFrameProc(hWnd, hWndMDIClient, WM_COMMAND, uParam, 0L);
    }
}

/***************************************************************************************************
**
** CloseAllChildern.
**
** DESCRIPTION: Destroys all MDI child windows.
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
VOID CloseAllChildren (VOID)
{
    HWND hWnd;

    // As long as the MDI client has a child, destroy it
    while(hWnd = GetWindow (hWndMDIClient, GW_CHILD))
    {
        // Skip the icon title windows
        while(hWnd && GetWindow (hWnd, GW_OWNER))
            hWnd = GetWindow (hWnd, GW_HWNDNEXT);
        if(hWnd)
            SendMessage(hWndMDIClient, WM_MDIDESTROY, (WPARAM)hWnd, 0L);
        else
            break;
    }
}

/*****************************************************************************
**
**
**
**
**
**
**
**
**
*****************************************************************************/
LRESULT PopUpMenu(HANDLE hInst, HWND hWnd, HWND hMWnd, LPARAM lPoint, LPSTR lpMenu)
{
    POINT   point;
    HMENU   hMenu;
    HMENU   hMenuTP;


    hMenu = LoadMenu(hInst, lpMenu);

    if(!hMenu) return FAILURE;

    point.x = LOWORD(lPoint);
    point.y = HIWORD(lPoint);

    hMenuTP = GetSubMenu(hMenu, 0);
    ClientToScreen(hWnd, (LPPOINT)&point);
    TrackPopupMenu(hMenuTP, 0, point.x, point.y, 0, hMWnd, NULL);
    DestroyMenu(hMenu);

    return SUCCESS;
}                                                                             

/***************************************************************************************************
**
** WinMain.
**
** DESCRIPTION:
**
**  PARAMETERS:
**
**     RETURNS:
**
***************************************************************************************************/
INT PASCAL WinMain(HANDLE hInstance,
                   HANDLE hPrevInstance,
                   LPSTR  szCommand,
                   INT    WindowState)
{
    MSG Message;


    hInst = hInstance;

    // If this is the first instance of the app. register window classes
    if(!hPrevInstance)
        if(!InitializeApplication())
            return 0;

    // Create the frame and do other initialization
    if(!InitializeInstance(szCommand, WindowState))
        return 0;

    // Enter main message loop
    while(GetMessage(&Message, NULL, 0, 0))
    // If a keyboard message is for the MDI, let the MDI client
    // take care of it.  Otherwise, just handle the message as usual
        if(!TranslateMDISysAccel(hWndMDIClient, &Message))
        {
            // Edit windows should get no mouse messages
            if(Message.message >= WM_MOUSEFIRST && Message.message <= WM_MOUSELAST)
            {
                if(Message.message == WM_RBUTTONUP)
                    Message.hwnd = GetParent(Message.hwnd);
                else
                    continue;
            }
            TranslateMessage(&Message);
            DispatchMessage(&Message);
        }

    return Message.lParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\hidmon\ioctl.h ===
/***************************************************************************************************
**
**      MODULE: IOCTL.H
**
**
** DESCRIPTION: 
**
**
**      AUTHOR: Daniel Dean.
**
**
**
**     CREATED:
**
**
**
**
** (C) C O P Y R I G H T   D A N I E L   D E A N   1 9 9 6.
***************************************************************************************************/
#ifndef __IOCTL_H__
#define __IOCTL_H__


#define NUMBER_SIZE             4
#define CHANNEL_STRING_ONE      " Channel["
#define CHANNEL_STRING_TWO      "] = 0x"
#define CHANNEL_STRING_THREE    "\r\n"
#define END_STRING(p,m)         {ULONG Count; for(Count = 0; Count < m; Count++) if(p[0] != '\0') p++;}

#define CHANNELDESC_STRING \
"size = %x\r\ntype = %x\r\ntypeValue = %x\r\nUsage.index = %x\r\nUsage.page = %x\r\nDesignator.designator = %x\r\nDesignator.desFlags = %x\r\nStringLength = %x\r\nString = %s\r\nUnit.unit = %x\r\nUnit.exponent = %x\r\nExtent.integer = %x\r\nExtent.logicalmin = %x\r\nExtent.logicalmax = %x\r\nExtent.physicalmin = %x\r\nExtent.physicalmax = %x\r\n"
#define DEVICEDESC_STRING \
"DeviceDesc.size = 0x%x\r\nDeviceDesc.packetsize = 0x%x\r\nDeviceDesc.queuesize = 0x%x\r\nDeviceDesc.PortDesc.Usage.index = 0x%x\r\nDeviceDesc.PortDesc.Usage.page = 0x%x\r\nDeviceDesc.PortDesc.systemtype = 0x%x\r\nDeviceDesc.PortDesc.devicenamesize = 0x%x\r\nDeviceDesc.PortDesc.oemnamesize = 0x%x\r\nDeviceDesc.PortDesc.extrainfo = 0x%x\r\nDeviceDesc.PortDesc.versionnumber = 0x%x\r\nDeviceDesc.PortDesc.vendorid = 0x%x\r\nDeviceName = %s\r\n"

typedef struct _READTHREAD
{
    HWND    hEditWin;
    ULONG   ThisThread;
    ULONG   Size;
    HANDLE  hDevice;
    HANDLE  hWnd;

} READTHREAD, * PREADTHREAD;

LPARAM IOCTLChannelDesc(HWND hWnd);
LPARAM IOCTLDeviceDesc(HWND hWnd);
LPARAM IOCTLEnableDisable(HWND hWnd, ULONG EnableDisable);
LPARAM IOCTLRead(HWND hWnd);
LPARAM IOCTLWrite(HWND hWnd);
LPARAM IOCTLStop(HWND hWnd);
ULONG  QueryDeviceDataSize(HWND hWnd);

//TESTING!!
VOID CALLBACK ReadWatch(HWND hWnd, UINT uMsg, UINT TimerID, DWORD dwTime);
//ULONG  CALLBACK ReadWatch(PREADTHREAD pThreadData);




#endif // __IOCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\hidmon\public.h ===
//
// public.h
//
// Shared items used both for the driver and the test app

#define TEST_DEVICE  "\\\\.\\hidmon" 

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

#define METHOD_BUFFERED                 0
#define FILE_ANY_ACCESS                 0

//
// 0x8000 - 0xFFFF are reserved for use by customers.
//

#define FILE_DEVICE_TEST  0x0000835F

//
// 0x800 - 0xFFF are reserved for customers.
//

#define TEST_IOCTL_INDEX  0x830

//
// The MONO device driver IOCTLs
//

#define IOCTL_GET_DEVICE_CLASS_ASSOC   CTL_CODE(FILE_DEVICE_TEST, TEST_IOCTL_INDEX  , METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Maximum lenght of the device list returned from IOTCL
//
#define MAX_DEVICE_LIST_LEN 255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\hidmon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winutb.rc
//
#define IDC_SCREEN_IO_FREQ              1000
#define IDC_ASYNC_CHECK                 1001
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\glitch\dma.h ===
#define DMASTATUSREG 0x8
#define DMA8SINGLEMASKREG 0xa
#define DMA16SINGLEMASKREG 0xd4
#define DMA8MASTERMASKREG 0xf
#define DMA16MASTERMASKREG 0xde
#define DMA8CLEARFLIPFLOP 0xc
#define DMA16CLEARFLIPFLOP 0xd8
#define DMA8BASE 0x0
#define DMA16BASE 0xc0


ULONG page[8] = { 0x87, 0x83, 0x81, 0x82, 0x8f, 0x8b, 0x89, 0x8a };



VOID __inline UnmaskDmaChannel(ULONG channel)
{

ASSERT ( channel<8 && channel!=4 );

if (channel<4) {

	__asm {

		mov eax,channel
		out DMA8SINGLEMASKREG,al

		}

	}
else if (channel<8) {

	__asm {

		mov eax,channel
		sub eax,4
		out DMA16SINGLEMASKREG,al

		}

	}

}


VOID __inline MaskDmaChannel(ULONG channel)
{

ASSERT ( channel<8 && channel!=4 );

if (channel<4) {

	__asm {

		mov eax,channel
		or	eax,0x4
		out DMA8SINGLEMASKREG,al

		}

	}
else if (channel<8) {

	__asm {

		mov eax,channel
		out DMA16SINGLEMASKREG,al

		}

	}

}


// This reads the DMA controller mask register.

ULONG __inline ReadDMAMask(VOID)
{

__asm {
	xor eax,eax
	in al,DMA8MASTERMASKREG
	ror eax,4
	in al,DMA16MASTERMASKREG
	and al,0xf
	rol eax,4
	}

}



VOID __inline ReadDmaPosition(ULONG channel, PULONG pCurrentDmaPosition)
{

ASSERT ( channel<8 && channel!=4 );

if (channel<4) {

	__asm {
		// First clear the flip flop.
		xor eax,eax
		out DMA8CLEARFLIPFLOP, al

		// Read low byte and save it away.
		mov edx, channel
		shl edx, 1
		in al, dx
		ror eax,8

		// Read high byte and save it away.
		in al, dx
		ror eax,8

		// Read page byte.
		shl edx, 1
		add edx, offset page
		mov edx, dword ptr[edx]
		in al, dx
		ror eax,8

		// Read hi-page byte.  Ignore if 0xff.
		add edx,0x400
		in al, dx
		sub al, 0xff
		jz done8
		add al, 0xff
done8:
		ror eax,8

		mov edx, pCurrentDmaPosition
		mov dword ptr [edx], eax

		}

	}

else if (channel<8) {

	__asm {
		// First clear the flip flop.
		xor eax,eax
		out DMA16CLEARFLIPFLOP, al

		// Read low byte and save it away.
		mov edx, channel
		sub edx, 4
		shl edx, 2
		add edx, DMA16BASE
		in al, dx
		ror eax,8

		// Read high byte and save it away.
		// We left shift bottom 16 bits by 1 and or top bit into page.
		in al, dx
		ror eax,7
		mov ah, al

		// Read page byte.
		mov edx, channel
		shl edx, 2
		add edx, offset page
		mov edx, dword ptr[edx]
		in al, dx

		// Or in bit 15 of word address and save away page byte.
		or al, ah
		ror eax,8

		// Read hi-page byte.  Ignore if 0xff.
		add edx,0x400
		in al, dx
		sub al, 0xff
		jz done16
		add al, 0xff
done16:
		ror eax,8

		mov edx, pCurrentDmaPosition
		mov dword ptr [edx], eax

		}

	}

}


VOID __inline ReadDmaCount(ULONG channel, PULONG pCurrentDmaCount)
{

ASSERT ( channel<8 && channel!=4 );

if (channel<4) {

	__asm {
		// First clear the flip flop.
		xor eax,eax
		out DMA8CLEARFLIPFLOP, al

		// Read low byte and save it away.
		mov edx, channel
		shl edx, 1
		inc edx
		in al, dx
		ror eax,8

		// Read high byte and fixup count.
		in al, dx
		rol eax,8

		mov edx, pCurrentDmaCount
		mov dword ptr [edx], eax

		}

	}

else if (channel<8) {

	__asm {
		// First clear the flip flop.
		xor eax,eax
		out DMA16CLEARFLIPFLOP, al

		// Read low byte and save it away.
		mov edx, channel
		sub edx, 4
		shl edx, 2
		add edx, 2
		add edx, DMA16BASE
		in al, dx
		ror eax,8

		// Read high byte and fixup count.
		in al, dx
		rol eax,9

		mov edx, pCurrentDmaCount
		mov dword ptr [edx], eax

		}

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\hidmon\driver\hidmon.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: 

    HIDMON.c

Abstract

    Driver for the HID Descriptor tool. Provides an interface to 
    Input.sys so that the tool may register and send data as a 
    HID device.

Author:

    John Piece

Environment:

    Kernel mode

Revision History:


--*/
#include <NTDDK.H>
#include <HIDCLASS.H>
#include <hidmon.h>


#ifdef DEBUG
#pragma message("Debug Defined")
#endif

typedef unsigned short WORD;
//
// Specify pagable functions
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
//#pragma alloc_text(INIT,CreateNewDevice)
#endif


PDRIVER_OBJECT  DriverObject;
PDEVICE_OBJECT  DeviceObject;
UNICODE_STRING  RegistryPath;

ULONG           gDeviceID;
ULONG           gDeviceObj;


   
/*++

Routine Description:
   
    Installable driver initialization entry point.

Arguments:

    DriverObject  - pointer to driver object.

    registrypath  - pointer to unicode string pointer registery entry.

Return Value:

    STATUS_SUCCESS, STATUS_UNSUCCESSFUL.

--*/
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT driverObject,
    IN PUNICODE_STRING registryPath )
   
{
    PDEVICE_OBJECT  deviceObject = NULL;
    NTSTATUS        ntStatus = STATUS_SUCCESS;
    UNICODE_STRING  HidmonDeviceName;
    UNICODE_STRING  HidmonDosDeviceName;

    
    
DbgPrint("HIDMON.SYS: DriverEntry Enter\n");
    
    //
    // Create NULL terminated registry path 
    //
   
//    RegistryPath.Length = registryPath->Length;
//    RegistryPath.MaximumLength = RegistryPath.Length + sizeof(UNICODE_NULL) + sizeof(L"\\Parameters\\Test");
//    RegistryPath.Buffer = ExAllocatePool(PagedPool, RegistryPath.MaximumLength);
//    if(!RegistryPath.Buffer)
//        return STATUS_UNSUCCESSFUL;
//    RtlZeroMemory(RegistryPath.Buffer, RegistryPath.MaximumLength);
//    RtlMoveMemory(RegistryPath.Buffer, registryPath->Buffer, RegistryPath.Length);

    
    //
    // Save the driver object
    //

    DriverObject = driverObject;

    //
    // Create a named control device, so that we get IRPs.
    //

    RtlInitUnicodeString( &HidmonDeviceName, HIDMON_DEVICE_NAME );
    ntStatus = IoCreateDevice(DriverObject,
                              sizeof(DEVICE_EXTENSION),
                              &HidmonDeviceName,
                              FILE_DEVICE_TEST,
                              0,
                              FALSE,
                              &deviceObject);

    //
    // Create a symbolic link that Win32 apps can specify to gain access
    // to this driver
    //
    RtlInitUnicodeString(&HidmonDosDeviceName,HIDMON_LINK_NAME);
    ntStatus = IoCreateSymbolicLink(&HidmonDosDeviceName, &HidmonDeviceName );

    //
    // Create dispatch points
    //
   
    DriverObject->MajorFunction[IRP_MJ_CREATE]                  = HIDMONCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = HIDMONCreateClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          = HIDMONControl;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = HIDMONControl;
    DriverObject->DriverUnload                                  = HIDMONDestructor;
 


DbgPrint("HIDMON.SYS: DriverEntry Exit\n");
    
    return STATUS_SUCCESS;
}


/*++

Routine Description:
   
    handles create and close irps.

Arguments:

    DriverObject - pointer to driver object.

    Irp          - pointer to Interrupt Request Packet.

Return Value:

   STATUS_SUCCESS, STATUS_UNSUCCESSFUL.

--*/
NTSTATUS
HIDMONCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PIO_STACK_LOCATION   irpStack;
    NTSTATUS             ntStatus;


    //
    // Get a pointer to the current location in the Irp.
    //
    
    irpStack = IoGetCurrentIrpStackLocation(Irp);
                        
    switch(irpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            //Irp->IoStatus.Information = 0;
            ntStatus = STATUS_SUCCESS;
            break;

        case IRP_MJ_CLOSE:
            //Irp->IoStatus.Information = 0;
            ntStatus = STATUS_SUCCESS;
            break;

        default:
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Save Status for return and complete irp
    //
    
    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return ntStatus;
}


/*****************************************************************++

Routine Description:
   
    Process the IRPs sent to this device.

Arguments:

    DriverObject - pointer to driver object.

    Irp          - pointer to Interrupt Request Packet.

Return Value:

    NT status code.

****************************************************************--*/
NTSTATUS
HIDMONControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_STACK_LOCATION  IrpStack;
	PWSTR				pDevice,*ppDeviceList;
	PWSTR				ptmp;
    
    //    
    // Get a pointer to the current location in the Irp
    //    
 
    IrpStack = IoGetCurrentIrpStackLocation(Irp);


    //
    // Get a pointer to the device extension
    //
    DeviceExtension = DeviceObject->DeviceExtension;

    switch(IrpStack->Parameters.DeviceIoControl.IoControlCode)
    {
        
		
        case IOCTL_GET_DEVICE_CLASS_ASSOC:
		{
			ULONG size=0;
            GUID MyGUID;

                MyGUID.Data1   = 0x4D1E55B2L;
                MyGUID.Data2   = 0xF16F;
                MyGUID.Data3   = 0x11CF;
                MyGUID.Data4[0]= 0x88;
                MyGUID.Data4[1]= 0xCB;
                MyGUID.Data4[2]= 0x00;
                MyGUID.Data4[3]= 0x11;
                MyGUID.Data4[4]= 0x11;
                MyGUID.Data4[5]= 0x00; 
                MyGUID.Data4[6]= 0x00;
                MyGUID.Data4[7]= 0x30;

DbgPrint("HIDMON.SYS: Enter IOCTL_GET_DEVICE_CLASS_ASSOC\n");


                //
				// Make the call to get the list of devices
				//

				ntStatus = IoGetDeviceClassAssociations(&MyGUID,ppDeviceList);
				
                if( (ntStatus == STATUS_SUCCESS)  && *ppDeviceList)
				{
                 
                    ptmp = *ppDeviceList;
                    while( **ppDeviceList != UNICODE_NULL )
					{
                    	pDevice = *ppDeviceList;
                        while(*pDevice++ != UNICODE_NULL)
                            size ++;                  
					    size += sizeof(UNICODE_NULL);
                        *ppDeviceList += size;
                    }
					//TESTING!!
					//size+=128;

					size += sizeof(UNICODE_NULL)*2;             // include the NULL
					RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer,ptmp,size*2);
					Irp->IoStatus.Information = size*2;
				}

				else
					ntStatus = STATUS_NO_MORE_FILES;

DbgPrint("HIDMON.SYS: Leave IOCTL_GET_DEVICE_CLASS_ASSOC\n");
        				
		}
        break;

        
        default:
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }         

    //    
    // Save Status for return and complete irp
    //    
 
    Irp->IoStatus.Status = ntStatus;
    if(ntStatus == STATUS_PENDING)
    {
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, (PULONG) NULL, NULL);
    }
    else
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return ntStatus;
}


/*++

Routine Description:
   
    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to driver object.

Return Value:

    STATUS_SUCCESS, STATUS_UNSUCCESSFUL. STATUS_SHARING_VIOLATION, STATUS_INVALID_PARAMETER.

--*/
VOID
HIDMONDestructor(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PDEVICE_OBJECT      DeviceObject = DriverObject->DeviceObject;
    PDEVICE_EXTENSION   DeviceExtension = DeviceObject->DeviceExtension; 
    UNICODE_STRING      deviceLinkUnicodeString;   
        
DbgPrint("HIDMON.SYS: HIDMONDestructor() Entry\n");
        //
        // Walk the DriverObject->DeviceObject list freeing as we go
        //
        while( DeviceObject )
        {
            IoDeleteDevice(DeviceObject);
            DeviceObject = DeviceObject->NextDevice;
        }

        RtlInitUnicodeString(&deviceLinkUnicodeString,HIDMON_LINK_NAME);
        IoDeleteSymbolicLink(&deviceLinkUnicodeString);

        IoDeleteDevice(DeviceObject);


DbgPrint("HIDMON.SYS: DeviceObject: %08X deleted\n",DeviceObject);
DbgPrint("HIDMON.SYS: HIDMONDestructor() Exit\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\glitch\device.c ===
//---------------------------------------------------------------------------
//
//  Module:   device.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//     M.McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#define IRPMJFUNCDESC
//#define MAX_DEBUG 1

#include "common.h"
#ifndef UNDER_NT
#include <ntddk.h>
#include <windef.h>
#pragma warning( disable : 4273 )
#include "..\..\..\..\dos\dos386\vxd\ntkern\inc\rtl.h"
#pragma warning( default : 4273 )
#include "..\..\..\..\dos\dos386\vxd\ntkern\hal\ixisa.h"
#else
#include <nthal.h>
// NOTE!  In order to remove cross depot include file dependencies.
// Which break peoples builds if they try to build drivers when they are
// not enlisted in base, I have made a local copy of the file 
// base\hals\halx86\i386\ixisa.h.  That is the file that defines the
// real ADAPTER_OBJECT structure.  This local copy should be kept in sync
// with the original.
#include "ixisa.h"
#endif

#include <rt.h>
#include "glitch.h"


// Maximum number of times we will retry allocating memory for aliasing
// DMA buffers.
#define MAX_RESERVE_RETRIES 128


#ifndef UNDER_NT

#include <vmm.h>

ULONG __stdcall GLITCH_Init_VxD(VOID);

#else

PDEVICE_OBJECT	pDO;

#endif



PVOID MapPhysicalToLinear(VOID *physicaladdress, ULONG numbytes, ULONG flags);
ULONG GetCR3(VOID);



VOID DriverUnload(
    IN PDRIVER_OBJECT	DriverObject
)
{
    //dprintf((" DriverUnload Enter (DriverObject = %x)", DriverObject));
    Break();

}



NTSTATUS DriverEntry
(
    IN PDRIVER_OBJECT	    DriverObject,
    IN PUNICODE_STRING	    usRegistryPathName
)
{

#ifdef UNDER_NT
    UNICODE_STRING	 usDeviceName;
    UNICODE_STRING	 usLinkName;
    PHYSICAL_ADDRESS Physical;
#endif
    ADAPTER_OBJECT *DmaControllerObject, *MasterAdapter;
    DEVICE_DESCRIPTION DmaDevice={0};
    ULONG MapRegisterCount;
    ULONG i;
    PVOID BadReserve[MAX_RESERVE_RETRIES];
    ULONG BadReserveCount=0;
    NTSTATUS Status = STATUS_SUCCESS;


#ifdef UNDER_NT
    DriverObject->MajorFunction[IRP_MJ_CREATE] = DeviceIoCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = DeviceIoClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceIoControl;
#endif
    DriverObject->DriverUnload = DriverUnload;


    // For now, keep the driver loaded always.
    ObReferenceObject(DriverObject);


#ifndef UNDER_NT

    GLITCH_Init_VxD();

#else

    RtlInitUnicodeString( &usDeviceName, STR_DEVICENAME );

    Status = IoCreateDevice( DriverObject, 0, &usDeviceName, FILE_DEVICE_SOUND, 0, FALSE, &pDO );

    if (!NT_SUCCESS(Status)) {
    	return Status;
    }

    RtlInitUnicodeString( &usLinkName, STR_LINKNAME );

    Status = IoCreateSymbolicLink( &usLinkName, &usDeviceName );

    if(!NT_SUCCESS(Status)) {
       IoDeleteDevice( pDO );
       return Status;
    }

#endif


// Now allocate the buffer for writing glitch information.
// Note that we actually allocate space for the GlitchInfo structure here
// as well.  We allocate space for the output buffer plus 1 page for
// the GlitchInfo structure.  This is so that they are tied together
// and we can map both back to user mode at the same time.  It is
// also because it makes it easy for the user mode code to build its
// own pointer to the actual output buffer from the pointer it
// gets to the GlitchInfo structure.  It is important that the
// user mode code be able to do that easily because the pointer
// that we put in the GlitchInfo structure is for our own kernel mode
// use only.  It cannot be used by the user mode code - since the
// buffer will be mapped to a completely different virtual address
// for the user mode code anyway.


#ifdef UNDER_NT
Physical.QuadPart=-1I64;
GlitchInfo=(PGLITCHDATA)MmAllocateContiguousMemory(PROCPAGESIZE*(4+1), Physical);
#else
GlitchInfo=(PGLITCHDATA)ExAllocatePool(NonPagedPool, PROCPAGESIZE*(4+1));
#endif


if (GlitchInfo==NULL) {
    Status=STATUS_NO_MEMORY;
#ifdef UNDER_NT
    IoDeleteSymbolicLink( &usLinkName );
    IoDeleteDevice( pDO );
#endif
    return Status;
    }


GlitchInfo->WriteLocation=0;
GlitchInfo->ReadLocation=0;

// The output or print buffersize MUST be a power of 2.  This is because the read and write 
// locations increment constantly and DO NOT WRAP with the buffer size.  That is intentional
// because it makes checking whether there is data in the buffer or not very simple and atomic.
// However, the read and write locations will wrap on 32 bit boundaries.  This is OK as long as
// our buffersize divides into 2^32 evenly, which it always will if it is a power of 2.
GlitchInfo->BufferSize=PROCPAGESIZE*4;

GlitchInfo->pBuffer=(PCHAR)GlitchInfo+PROCPAGESIZE;


// Mark every slot in the output buffer empty.

for (i=0; i<GlitchInfo->BufferSize; i+=PACKETSIZE) {
    ((ULONG *)GlitchInfo->pBuffer)[i/sizeof(ULONG)]=NODATA;
    }



DmaDevice.Version=DEVICE_DESCRIPTION_VERSION1;
DmaDevice.Master=FALSE;
DmaDevice.ScatterGather=FALSE;
DmaDevice.DemandMode=FALSE;
DmaDevice.AutoInitialize=TRUE;
DmaDevice.Dma32BitAddresses=TRUE;
DmaDevice.IgnoreCount=FALSE;
DmaDevice.Reserved1=FALSE;
DmaDevice.DmaChannel=0;
DmaDevice.InterfaceType=Internal;					// Internal, ISA, EISA
DmaDevice.DmaWidth=Width8Bits;					// Width8Bits, Width16Bits, or Width32Bits
DmaDevice.DmaSpeed=Compatible;					// Compatible, TypeA, TypeB, or TypeC
DmaDevice.MaximumLength=1<<12;
DmaDevice.DmaPort=0;


MapRegisterCount=1;

DmaControllerObject=(ADAPTER_OBJECT *)HalGetAdapter(&DmaDevice, &MapRegisterCount);

MasterAdapter=DmaControllerObject->MasterAdapter;


for (i=0; i<8; i++) {

	if (i==2 || i==4) {
		continue;
		}

	if (MasterAdapter->AdapterBaseVa==(PVOID)(-1I64)) {

		PDMAINFO ChannelInfo;

		// First allocate space for tracking this channel.

		ChannelInfo=(PDMAINFO)ExAllocatePool(NonPagedPool, sizeof(DMAINFO));

		if (ChannelInfo==NULL) {
			Status=STATUS_NO_MEMORY;
			break;
		}


		// Fill in information about this channel.
		ChannelInfo->Channel=i;
		ChannelInfo->pMasterAdapterSpinLock=&MasterAdapter->SpinLock;
		ChannelInfo->Read32BitPhysicalAddresses=MasterAdapter->Dma32BitAddresses;

		// Now get CR3 and map the page directory.  This enables us to remap
		// the physical pages inside our RT thread.  So, we can map our pDmaBuffer
		// to whatever physical addresses the hardware DMA buffer is mapped to.

		ChannelInfo->CR3=GetCR3();
		ChannelInfo->PageDirectory=(PULONG)MapPhysicalToLinear((PVOID)ChannelInfo->CR3, PROCPAGESIZE, 0);

		// Now get a set of linear pages that we can remap to whereever we need.
		// Make SURE that this set of linear pages all share a single page directory entry.
		// To do this we use a very simple algorithm.  If any of the allocations we
		// make happens to cross a page directory entry (4MB boundary) then simply
		// save the location of the bad allocation, and make another allocation.
		// We will free all of the bad allocations after we have processed all of the
		// channels.  That way we hold onto all the bad allocations until after we have
		// finish getting a full set of acceptable allocations.
		#ifdef UNDER_NT
		#define PR_SYSTEM 0
		#define PR_FIXED 0
		#endif
		ChannelInfo->pDmaBuffer=NULL;
		while (ChannelInfo->pDmaBuffer==NULL && BadReserveCount<MAX_RESERVE_RETRIES) {
    		ChannelInfo->pDmaBuffer=ReservePages(PR_SYSTEM, PAGECOUNT, PR_FIXED);
    		// Does this set of pages cross a 4MB boundary?
    		if (((ULONG_PTR)ChannelInfo->pDmaBuffer^((ULONG_PTR)ChannelInfo->pDmaBuffer+PAGECOUNT*PROCPAGESIZE))&(4*1024*1024)) {
    		    // This set of pages crosses page directory entries.  Dump it and retry.
    		    BadReserve[BadReserveCount++]=ChannelInfo->pDmaBuffer;
    		    ChannelInfo->pDmaBuffer=NULL;
    		}
		}

		if (ChannelInfo->pDmaBuffer==NULL) {
			Status=STATUS_NO_MEMORY;
			break;
		}

		// Now get a linear address for the page table containing this set of reserved pages.
		// I need that so I can change the page table entries and map the pages directly.
		ChannelInfo->PageTable=MapPhysicalToLinear((PVOID)((ChannelInfo->PageDirectory[(ULONG)(ChannelInfo->pDmaBuffer)>>22])&(~(PROCPAGESIZE-1))), PROCPAGESIZE, 0);

		// Now lock down my linear address alias of my page.
		//LockPages((ULONG)ChannelInfo->PageTable, 1, 0, 0);
		// This fails.  The function returns zero, it has to be non zero for success.

		ChannelInfo->DmaBufferSize=0;
		ChannelInfo->PhysicalDmaBufferStart=0;

		ChannelInfo->pPrintBuffer=GlitchInfo->pBuffer;
		ChannelInfo->PrintBufferSize=GlitchInfo->BufferSize;
		ChannelInfo->pPrintLoad=&GlitchInfo->WriteLocation;
		ChannelInfo->pPrintEmpty=&GlitchInfo->ReadLocation;

		// Create the realtime glitch detection thread.

		Status=RtCreateThread(1*MSEC, 50*USEC, 0, 2, GlitchDetect, (PVOID)ChannelInfo, NULL);

        if (!NT_SUCCESS(Status)) {
            // Free the ChannelInfo we allocated for this realtime thread.
            ExFreePool(ChannelInfo);
            // Stop trying to create additional realtime threads.
            break;
        }

		}
	else {
		Trap();
		Status=STATUS_UNSUCCESSFUL;
		break;
		}

	}


    // Now clean up properly if we failed during creation of the glitch monitor
    // realtime threads.

    // Note that we only free up allocated resources if NO realtime threads were
    // successfully created.  If we successfully created ANY realtime threads,
    // then do not shut them down, and return STATUS_SUCCESS.

    if (!NT_SUCCESS(Status) && i==0) {

#ifdef UNDER_NT

        MmFreeContiguousMemory(GlitchInfo);
        IoDeleteSymbolicLink( &usLinkName );
        IoDeleteDevice( pDO );

#else

        ExFreePool(GlitchInfo);

#endif

    }
    else {

#ifdef UNDER_NT

    pDO->Flags |= DO_DIRECT_IO ;
    pDO->Flags &= ~DO_DEVICE_INITIALIZING;

#endif

    Status=STATUS_SUCCESS; // We MUST do this in case Status is an error, but i!=0.

    }


    // Now clean up any bad reserves before we leave.
    // Note that we do this here instead of before the above if statement, so that
    // we can reuse i without screwing up the i=0 check in the if statement.

    for (i=0; i<BadReserveCount; i++) {
        FreePages(BadReserve[i], 0);
    }
    

    DbgPrint("Glitch.sys allocated %d DMA alias buffers that crossed 4MB boundaries.\n", BadReserveCount);


    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\glitch\common.h ===
//---------------------------------------------------------------------------
//
//  Module:   common.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>

#ifdef __cplusplus
}
#endif

#if defined(UNDER_NT) && DBG
#define DEBUG 1
#endif

#ifdef DEBUG
#define Trap()	{_asm {_emit 0xcc}}
#else
#define Trap()
#endif

#define Break() \
	__asm int 3

#define WINICEDEBUGDUMP 1



#ifdef DEBUG

#if WINICEDEBUGDUMP
#define QDBG ""
#else
#define QDBG "'"
#endif

extern int RtDebugLevel;


/*
*    Generate debug output in printf type format.
*/

#define dprintf( _x_ )  { DbgPrint(QDBG"Glitch: "); DbgPrint _x_ ; DbgPrint(QDBG"\r\n"); }
#define dprintf1( _x_ ) if (RtDebugLevel >= 1) { DbgPrint(QDBG"Glitch: "); DbgPrint _x_ ; DbgPrint(QDBG"\r\n"); }
#define dprintf2( _x_ ) if (RtDebugLevel >= 2) { DbgPrint(QDBG"Glitch: "); DbgPrint _x_ ; DbgPrint(QDBG"\r\n"); }
#define dprintf3( _x_ ) if (RtDebugLevel >= 3) { DbgPrint(QDBG"Glitch: "); DbgPrint _x_ ; DbgPrint(QDBG"\r\n"); }
#define dprintf4( _x_ ) if (RtDebugLevel >= 4) { DbgPrint(QDBG"Glitch: "); DbgPrint _x_ ; DbgPrint(QDBG"\r\n"); }

#else

#define dprintf(x)
#define dprintf1(x)
#define dprintf2(x)
#define dprintf3(x)
#define dprintf4(x)

#endif // DEBUG



#define INIT_CODE   	code_seg("INIT", "CODE")
#define INIT_DATA   	data_seg("INIT", "DATA")
#define LOCKED_CODE 	code_seg(".text", "CODE")
#define LOCKED_DATA 	data_seg(".data", "DATA")
#define PAGEABLE_CODE	code_seg("PAGE", "CODE")
#define PAGEABLE_DATA	data_seg("PAGEDATA", "DATA")

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//---------------------------------------------------------------------------
//  End of File: common.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\input\tools\hidmon\driver\hidmon.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name: 

    hidmon.h

Abstract

    include file for hidmon.c WDM driver


Author:

	johnpi

Environment:

    Kernel mode

Revision History:


--*/

#ifndef __HIDMON_H_
#define __HIDMON_H__

#include "..\public.h"

//
// Device Name
//
#define HIDMON_DEVICE_NAME L"\\Device\\Hidmon"    

//
// Symbolic link name
//
#define HIDMON_LINK_NAME L"\\DosDevices\\HIDMON"

//
// Registry Strings
//

#define FULL_PORT_NAME_SIZE (10 + INPUT_CLASS_PORT_NAME + MAX_INPUT_PORTS_LSTR_SIZE)


//
// Device extension structure for main object
//

typedef struct _DEVICE_EXTENSION
{
    ULONG         RawSize;
    UCHAR         *pRawData;
    ULONG         DescriptorSize;
    UCHAR         *pDescriptorData;
    
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Function declarations
//

NTSTATUS
HIDMONCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
HIDMONControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
HIDMONDestructor(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#endif // __HIDMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\glitch\glitch.h ===
#define PRESENT 1
#define WRITABLE 2
#define USER 4
#define WRITETHROUGHCACHE 8
#define CACHEDISABLED 16
#define ACCESSED 32
#define DIRTY 64


#define PROCPAGESIZE 4096
#define PAGECOUNT 32
#define MAXDMABUFFERSIZE PAGECOUNT*PROCPAGESIZE

#ifdef UNDER_NT
#define STR_DEVICENAME TEXT("\\Device\\GLITCH")
#define STR_LINKNAME   TEXT("\\DosDevices\\GLITCH")
#else
#define STR_DEVICENAME TEXT(L"\\Device\\GLITCH")
#define STR_LINKNAME   TEXT(L"\\DosDevices\\GLITCH")
#endif

#define PACKETSIZE sizeof(ULONGLONG)+2*sizeof(ULONG)

enum PacketTypes{
	NODATA,
	MASKED,
	UNMASKED,
	GLITCHED,
	HELDOFF
	};


typedef struct {
	ULONG WriteLocation;
	ULONG ReadLocation;
	ULONG BufferSize;
	PCHAR pBuffer;
	} GLITCHDATA, *PGLITCHDATA;


typedef struct {
	ULONG Channel;
	PKSPIN_LOCK pMasterAdapterSpinLock;
	ULONG CR3;
	PULONG PageDirectory;
	PULONG PageTable;
	PULONG pDmaBuffer;
	ULONG DmaBufferSize;
	ULONG PhysicalDmaBufferStart;
	PCHAR pPrintBuffer;
	ULONG PrintBufferSize;
	volatile ULONG *pPrintLoad;
	volatile ULONG *pPrintEmpty;
	BOOLEAN Read32BitPhysicalAddresses;
	} DMAINFO, *PDMAINFO;


extern PGLITCHDATA GlitchInfo;


VOID
TrackGlitches (
    PVOID Context,
    ThreadStats *Statistics
    );

VOID
GlitchDetect (
    PDMAINFO Context,
    ThreadStats *Statistics
    );

PVOID
__cdecl
ReservePages (
    ULONG page,
    ULONG npages,
    ULONG flags
    );

ULONG
__cdecl
FreePages (
    PVOID hmem,
    ULONG flags
    );

PVOID
__cdecl
LockPages (
    ULONG page,
    ULONG npages,
    ULONG pageoffset,
    ULONG flags
    );

#ifdef UNDER_NT

NTSTATUS DeviceIoCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp);

NTSTATUS DeviceIoClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp);

NTSTATUS DeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\glitch\mapview.h ===
/*++

Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    mapview.c

Abstract:

    This header file contains the prototypes of functions for mapping and
    unmapping a contiguous kernel mode buffer to a read only buffer in a 
    user mode process.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/



// This is a handle to the process that successfully opened a section and also
// successfully mapped a view of that section.
// We only allow our section view to be unmapped, and the section handle closed
// by that same process.
extern HANDLE Process;



NTSTATUS
MapContiguousBufferToUserModeProcess (
    PVOID Buffer,
    PVOID *MappedBuffer
    );


NTSTATUS
UnMapContiguousBufferFromUserModeProcess (
    PVOID MappedBuffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\glitch\generic.asm ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PAGLITCHICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-99  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

PAGE 58,132
;******************************************************************************
TITLE GENERIC - GLITCH VxD
;******************************************************************************
;
;   Title:      GLITCH.ASM
;
;   Version:    1.00
;
;==============================================================================

        .386p

;******************************************************************************
;                             I N C L U D E S
;******************************************************************************

DDK_VERSION		EQU	400H
GLITCH_VER_MAJOR	equ	1
GLITCH_VER_MINOR	equ	0

	.XLIST
	INCLUDE VMM.Inc
;	INCLUDE VDMAD.Inc
;	INCLUDE VPICD.Inc
;	INCLUDE DOSMGR.Inc
	INCLUDE Debug.Inc
	.LIST

Declare_Virtual_Device GLITCH, GLITCH_VER_MAJOR, GLITCH_VER_MINOR, GLITCH_VxD_Control

VxD_DATA_SEG

;******************************************************************************
;                                D A T A
;******************************************************************************

;       Normal Data here

        public  C IRQHand
IRQHand		dd	0


EXTERN _GlitchWin32API@4:near


dma_status_struc	STRUC
DMA_PhysicalAddress	DD	?
DMA_Count		DD	?
DMA_Status		DD	?
dma_status_struc	ENDS
	
VxD_DATA_ENDS


VxD_LOCKED_DATA_SEG
next_begin dd  0
next_end dd    0
VxD_LOCKED_DATA_ENDS


VxD_LOCKED_CODE_SEG

;******************************************************************************
;
;   GLITCH_Init_VxD
;
;   DESCRIPTION:
;       This is a shell for a routine that is called at system BOOT.
;       Typically, a VxD would do its initialization in this routine.
;
;   ENTRY:
;       EBX = System VM handle
;
;   EXIT:
;       We return 0 in eax upon success, 1 in eax if failure.
;		Caller MUST fail to load the device if we return 1.
;
;   USES:
;       flags
;
;==============================================================================

BeginProc GLITCH_Init_VxD, SCALL, PUBLIC

	EnterProc
	SaveReg <ebx, esi, edi>

; Note that we this routine should only be executed ONCE.  So we
; ensure that that is the case.

	mov	edi, offset32 GLITCH_DDB
	VMMCall	VMM_Add_DDB
	Debug_Outc "DDB already loaded for GLITCH!"

	xor eax,eax

	RestoreReg <edi, esi, ebx>
	LeaveProc
    Return

EndProc GLITCH_Init_VxD

;******************************************************************************
;
;
; Description:
;
; Entry:
; Exit:
; Uses:
;==============================================================================

BeginProc GLITCH_Uninit_VxD, SCALL, PUBLIC

	EnterProc
	SaveReg	<ebx,esi,edi>

	TRAP

	xor eax,eax
	push eax

	mov	edi, offset32 GLITCH_DDB
	VMMCall	VMM_Remove_DDB
	Debug_Outc "Could not remove DDB for GLITCH!"
	pop	eax
	rcl	eax,1
	
	RestoreReg <edi,esi,ebx>
	LeaveProc
	Return

EndProc GLITCH_Uninit_VxD

;******************************************************************************
;
;   GLITCH_VxD_Control
;
;   DESCRIPTION:
;
;       This is a call-back routine to handle the messages that are sent
;       to VxD's to control system operation. Every VxD needs this function
;       regardless if messages are processed or not. The control proc must
;       be in the LOCKED code segment.
;
;       The Control_Dispatch macro used in this procedure simplifies
;       the handling of messages. To handle a particular message, add
;       a Control_Dispatch statement with the message name, followed
;       by the procedure that should handle the message. 
;
;       The two messages handled in this sample control proc, Device_Init
;       and Create_VM, are done only to illustrate how messages are
;       typically handled by a VxD. A VxD is not required to handle any
;       messages.
;
;   ENTRY:
;       EAX = Message number
;       EBX = VM Handle
;
;==============================================================================

BeginProc GLITCH_VxD_Control, PUBLIC

	Control_Dispatch W32_DEVICEIOCONTROL, GlitchWin32API, sCall, <esi>
	clc
	ret

EndProc GLITCH_VxD_Control


VxD_LOCKED_CODE_ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\glitch\ixisa.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixisa.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    EISA/ISA specific interfaces, defines and structures.

Author:

    Jeff Havens (jhavens) 20-Jun-91

Revision History:

--*/

#ifndef _IXISA_
#define _IXISA_


//
// The MAXIMUM_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for devices which require phyically contigous buffers.
//

#define MAXIMUM_ISA_MAP_BUFFER_SIZE      0x40000

#if !defined(_HALPAE_)
#define MAXIMUM_MAP_BUFFER_SIZE         MAXIMUM_ISA_MAP_BUFFER_SIZE
#endif

//
// MAXIMUM_PCI_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for 32-bit PCI devices on a 64-bit system.
//

#define MAXIMUM_PCI_MAP_BUFFER_SIZE  (64 * 1024 * 1024)

//
// Define the initial buffer allocation size for a map buffers for systems with
// no memory which has a physical address greater than MAXIMUM_PHYSICAL_ADDRESS.
//

#define INITIAL_MAP_BUFFER_SMALL_SIZE 0x10000

//
// Define the initial buffer allocation size for a map buffers for systems with
// no memory which has a physical address greater than MAXIMUM_PHYSICAL_ADDRESS.
//

#define INITIAL_MAP_BUFFER_LARGE_SIZE 0x30000

//
// Define the incremental buffer allocation for a map buffers.
//

#define INCREMENT_MAP_BUFFER_SIZE 0x10000

//
// Define the maximum number of map registers that can be requested at one time
// if actual map registers are required for the transfer.
//

#define MAXIMUM_ISA_MAP_REGISTER  16

#define MAXIMUM_PCI_MAP_REGISTER  16

//
// Define the maximum physical address which can be handled by an Isa card.
//

#define MAXIMUM_PHYSICAL_ADDRESS 0x01000000

//
// Define the scatter/gather flag for the Map Register Base.
//

#define NO_SCATTER_GATHER 0x00000001

//
// Define the copy buffer flag for the index.
//

#define COPY_BUFFER 0XFFFFFFFF

//
// Define adapter object structure.
//

typedef struct _ADAPTER_OBJECT {
    DMA_ADAPTER DmaHeader;
    struct _ADAPTER_OBJECT *MasterAdapter;
    ULONG MapRegistersPerChannel;
    PVOID AdapterBaseVa;
    PVOID MapRegisterBase;
    ULONG NumberOfMapRegisters;
    ULONG CommittedMapRegisters;
    struct _WAIT_CONTEXT_BLOCK *CurrentWcb;
    KDEVICE_QUEUE ChannelWaitQueue;
    PKDEVICE_QUEUE RegisterWaitQueue;
    LIST_ENTRY AdapterQueue;
    KSPIN_LOCK SpinLock;
    PRTL_BITMAP MapRegisters;
    PUCHAR PagePort;
    UCHAR ChannelNumber;
    UCHAR AdapterNumber;
    USHORT DmaPortAddress;
    UCHAR AdapterMode;
    BOOLEAN NeedsMapRegisters;
    BOOLEAN MasterDevice;
    BOOLEAN Width16Bits;
    BOOLEAN ScatterGather;
    BOOLEAN IgnoreCount;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN Dma64BitAddresses;
    LIST_ENTRY AdapterList;
} ADAPTER_OBJECT;

typedef struct _MASTER_ADAPTER_OBJECT {

    PADAPTER_OBJECT AdapterObject;

    //
    // Maximum number of buffers to allocate for this master adapter.
    //

    ULONG MaxBufferPages;

    //
    // Number of map buffers allocated
    //

    ULONG MapBufferSize;

    PHYSICAL_ADDRESS MapBufferPhysicalAddress;

} MASTER_ADAPTER_OBJECT, *PMASTER_ADAPTER_OBJECT;

ULONG 
HalGetDmaAlignment (
    PVOID Conext
    );

NTSTATUS
HalCalculateScatterGatherListSize(
    IN PADAPTER_OBJECT AdapterObject,
    IN OPTIONAL PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    OUT PULONG  ScatterGatherListSize,
    OUT OPTIONAL PULONG pNumberOfMapRegisters
    );

NTSTATUS
HalBuildScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice,
    IN PVOID ScatterGatherBuffer,
    IN ULONG ScatterGatherBufferLength
    );


NTSTATUS
HalBuildMdlFromScatterGatherList(
    IN PADAPTER_OBJECT AdapaterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    );


PHYSICAL_ADDRESS
__inline
HalpGetAdapterMaximumPhysicalAddress(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine determines and returns the maximum physical address that
    can be accessed by the given adapter.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

Return Value:

    Returns the maximum physical address that can be accessed by this
        device.

--*/

{
    PHYSICAL_ADDRESS maximumAddress;

    //
    // Assume the device requires physical addresses < 16M.
    //

    maximumAddress.HighPart = 0;
    maximumAddress.LowPart = MAXIMUM_PHYSICAL_ADDRESS - 1;

    //
    // IoMapTransfer() is sometimes called with a NULL adapter object.  In
    // this case, assume the adapter is 24 bit.
    //

    if (AdapterObject == NULL) {
        return maximumAddress;
    }

    if (AdapterObject->MasterDevice) {

        if (AdapterObject->Dma64BitAddresses) {

            //
            // This device is a master and can handle 64 bit addresses.
            //

            maximumAddress.QuadPart = (ULONGLONG)-1;

        } else if(AdapterObject->Dma32BitAddresses) {

            //
            // This device is a master and can handle 32 bit addresses.
            //

            maximumAddress.LowPart = (ULONG)-1;
        }
    }

    return maximumAddress;
}


#endif // _IXISA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\glitch\mapview.c ===
/*++

Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    mapview.c

Abstract:

    This code is used to map a read only copy of the glitch output buffer into
    a user mode process.  It currently supports mapping the output buffer to
    only 1 user mode process at a time.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/



#ifdef UNDER_NT



#include "common.h"
#include <ntddk.h>
#include <rt.h>
#include "glitch.h"
#include "mapview.h"


// Note that there are PAGEABLE_CODE and PAGEABLE_DATA pragmas in common.h
// so all of this code is pageable.  That is as it should be - as this code
// is all called while handling IOCTLS.


HANDLE SectionHandle=NULL;
HANDLE Process=NULL;


NTSTATUS
MapContiguousBufferToUserModeProcess (
    PVOID Buffer,
    PVOID *MappedBuffer
    )

{

    NTSTATUS Status;
    PHYSICAL_ADDRESS Physical;
    UNICODE_STRING SectionName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG ViewSize;
    LARGE_INTEGER ViewBase;
    PVOID BaseAddress;

    // We only map our buffer into 1 process at a time.
    // Punt if we have already mapped or started to map it.
    if (InterlockedCompareExchangePointer(&SectionHandle, 1, NULL)!=NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    // First get the physical address of the buffer we are going to
    // map into read only user mode memory of the process calling us.
    Physical=MmGetPhysicalAddress(Buffer);

    // Now map this buffer into user mode memory and return a pointer
    // to the mapped memory.

    //
    // Open a physical memory section to map in physical memory.
    //

    RtlInitUnicodeString(
        &SectionName,
        L"\\Device\\PhysicalMemory"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &SectionName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    Status = ZwOpenSection(
        &SectionHandle,
        SECTION_ALL_ACCESS,
        &ObjectAttributes
        );

    if (NT_SUCCESS(Status)) {

        BaseAddress = NULL;
        ViewSize = GlitchInfo->BufferSize+PROCPAGESIZE;
        ViewBase.QuadPart = Physical.QuadPart;

        Status =ZwMapViewOfSection(
            SectionHandle,
            NtCurrentProcess(),
            &BaseAddress,
            0,
            ViewSize,
            &ViewBase,
            &ViewSize,
            ViewUnmap,
            0,
            PAGE_READONLY
            );

        if (NT_SUCCESS(Status)) {
             // Keep track of which process opened and mapped this section.
            Process=IoGetCurrentProcess();
           *MappedBuffer=BaseAddress;
        }
        else {
            // If we fail to map the view.  Then we clean up here.
            // Close down our SectionHandle and setup so we can run this routine
            // again later.
            ZwClose(SectionHandle);

            // Clear the SectionHandle so we can open it again.
            InterlockedExchangePointer(&SectionHandle, NULL);
        }

    }
    else {
        // Clear the SectionHandle so we don't lock out all future mapping attempts.
        InterlockedExchangePointer(&SectionHandle, NULL);
    }

    return Status;

}



NTSTATUS
UnMapContiguousBufferFromUserModeProcess (
    PVOID MappedBuffer
    )

{

    HANDLE CurrentProcess;
    NTSTATUS Status=STATUS_UNSUCCESSFUL;

    // Only let this call through, if we have an open section handle,
    // and the process calling us matches the process that opened the
    // section handle.

    CurrentProcess=IoGetCurrentProcess();

    if (InterlockedCompareExchangePointer(&Process, NULL, CurrentProcess)==CurrentProcess) {

        // I should NEVER be able to get here unless SectionHandle is valid
        // and was a handle opened by the current process.  I should also
        // NEVER be able to get here unless MappedBuffer is valid as well.

        ASSERT( SectionHandle!=NULL );
        ASSERT( MappedBuffer!=NULL );        

        Status = ZwUnmapViewOfSection(NtCurrentProcess(), MappedBuffer);

        ZwClose(SectionHandle);

        // Clear the SectionHandle so we can open it again.
        InterlockedExchangePointer(&SectionHandle, NULL);

    }
    
    return Status;

}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\glitch\glitch.c ===
// A realtime audio glitch detector.
// This will be used to make measurements of audio glitches.

// Author:  Joseph Ballantyne
// Date:    11/17/99

// This will first work with DMA based devices.
// I will add PCI support as well once the DMA glitch detection is working
// properly.

#ifdef UNDER_NT
#include <nthal.h>
#include <ntmmapi.h>
#define IO_NO_INCREMENT 0
HANDLE IoGetCurrentProcess(VOID);
#else
#include <wdm.h>
#include <windef.h>
#include <winerror.h>
#endif

#include "common.h"
#include <string.h>
#include <rt.h>
#include "glitch.h"

#ifdef UNDER_NT
#include "mapview.h"
#else
#include <vmm.h>
#include <vwin32.h>
#endif


#pragma intrinsic ( strcpy )

// Everything we touch HAS to be locked down.

#pragma LOCKED_CODE
#pragma LOCKED_DATA


// This header file has CODE and DATA in it.  It MUST be included after above pragmas.
// The code and data in the following header MUST be LOCKED.

#include "dma.h"



PGLITCHDATA GlitchInfo;


#pragma warning ( disable : 4035 )


#define rdtsc __asm _emit 0x0f __asm _emit 0x31
#define rdprf __asm _emit 0x0f __asm _emit 0x33



LONGLONG
__inline
ReadCycleCounter (
    VOID
    )
{

    __asm {
        rdtsc
        }

}



ULONGLONG
__inline
ReadPerformanceCounter (
    ULONG index
    )
{

    __asm {
        mov ecx,index
        rdprf
        }

}



ULONG
GetCR3 (
    VOID
    )
{

    __asm mov eax, cr3;

}



ULONG
InB (
    ULONG address
    )
{

    __asm {
        mov edx,address
        xor eax,eax
        in al,dx
        }

}


#pragma PAGEABLE_CODE


PVOID
MapPhysicalToLinear (
    VOID *physicaladdress,
    ULONG numbytes,
    ULONG flags
    )
{

#ifndef UNDER_NT

__asm push flags
__asm push numbytes
__asm push physicaladdress

VMMCall( _MapPhysToLinear );

__asm add esp,12

#else

PHYSICAL_ADDRESS Address;
Address.QuadPart=(ULONG_PTR)physicaladdress;
return (PVOID)MmMapIoSpace(Address, numbytes, FALSE);

#endif

}



PVOID
__cdecl
ReservePages (
    ULONG page,
    ULONG npages,
    ULONG flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{

#ifndef UNDER_NT

    __asm {

        push flags
        push npages
        push page

        VMMCall( _PageReserve )

        __asm add esp, 12

        }

#else

return ExAllocatePool( NonPagedPool, npages*PROCPAGESIZE );

#endif

}




ULONG
__cdecl
FreePages (
    PVOID hmem,
    ULONG flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{

#ifndef UNDER_NT

    __asm {

        push flags
        push hmem

        VMMCall( _PageFree )

        __asm add esp, 8

        }

#else

ExFreePool( hmem );

return TRUE;

#endif

}


#ifndef UNDER_NT

PVOID
__cdecl
LockPages (
    ULONG page,
    ULONG npages,
    ULONG pageoffset,
    ULONG flags
    )
{

__asm {

	push flags
	push pageoffset
	push npages
	push page

	VMMCall( _PageLock )

	__asm add esp, 16

	}

}

#endif

#pragma warning( default : 4035 )



enum ControlCodes {
	CHECKLOADED,
	GETVERSION,
	GETBASEADDRESS
	};



#ifndef UNDER_NT

DWORD __stdcall GlitchWin32API(PDIOCPARAMETERS p)
{

switch (p->dwIoControlCode) {

	case CHECKLOADED:
		break;

	case GETVERSION:
		// Get version.
		if (!p->lpvOutBuffer || p->cbOutBuffer<4)
			return ERROR_INVALID_PARAMETER;

		*(PDWORD)p->lpvOutBuffer=0x0100;

		if (p->lpcbBytesReturned)
			*(PDWORD)p->lpcbBytesReturned=4;

		break;

	case GETBASEADDRESS:
		// Get base address.
		if (!p->lpvOutBuffer || p->cbOutBuffer<4)
			return ERROR_INVALID_PARAMETER;

		*(PDWORD)p->lpvOutBuffer=(DWORD)GlitchInfo;

		if (p->lpcbBytesReturned)
			*(PDWORD)p->lpcbBytesReturned=4;

		break;

	default:
		return ERROR_INVALID_PARAMETER;

	}

return 0;

}

#else


PVOID MappedBuffer=NULL;


NTSTATUS
DeviceIoCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS Status=STATUS_SUCCESS;

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return Status;
}


NTSTATUS
DeviceIoClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS Status=STATUS_SUCCESS;
    PVOID Pointer;

    // Make sure that we release our mapped buffer view when the user mode
    // app that opened our section handle closes its handle or goes away.
    // We screen these calls based on the handle we get to the process that
    // sucessfully opened a section handle.  We only make the unmap call
    // if we are being called by the same process that made the map call.

    if (IoGetCurrentProcess()==Process) {
        if ((Pointer=InterlockedExchangePointer(&MappedBuffer, NULL))!=NULL &&
            UnMapContiguousBufferFromUserModeProcess(Pointer)!=STATUS_SUCCESS) {
            Trap();
        }
    }

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return Status;
}


NTSTATUS
DeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    )
{

    PVOID BaseAddress=NULL;
    PIO_STACK_LOCATION  pIrpStack;
    NTSTATUS Status=STATUS_SUCCESS;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {

        case 2:

            if (!pIrp->MdlAddress || pIrp->MdlAddress->ByteCount!=4) {
                Status=STATUS_INVALID_PARAMETER;
                break;
            }

            Status=MapContiguousBufferToUserModeProcess(GlitchInfo, &BaseAddress);

            // Remember the address of the mapped buffer.
            // We depend on the fact that BaseAddress will be NULL for requests
            // to map the buffer when it is already mapped.
            if (BaseAddress) {
                MappedBuffer=BaseAddress;
            }

            *(PDWORD_PTR)(MmGetSystemAddressForMdl(pIrp->MdlAddress))=(DWORD_PTR)BaseAddress;

            break;

        default:
            Status=STATUS_INVALID_PARAMETER;
            break;

    }

    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return Status;

}

#endif


// All the rest of the code in this file MUST be locked as it is all called from within
// the realtime thread.

#pragma LOCKED_CODE


VOID
OutB (
    ULONG address,
    ULONG data
    )
{

__asm {
	mov edx,address
	mov eax,data
	out dx,al
	}

}



// This function loads the DMA buffer just played with our starvation fill pattern.
// Which is 0xffffffff.  This is a nice pattern because for signed 16 bit data it
// is a DC value close to zero.  Moreover, it is DC for both stereo 16 bit, mono 16
// bit, stereo 8 bit and mono 8 bit.  For 8 bit data it is at the max of the data
// range - so is pegged to max volume - for most cards.  Since most cards do unsigned
// 8 bit samples.  This value MUST be different from the KMIXER starvation pattern
// which is zero.

// Note that this routine assumes that CurrentDmaPosition and LastDmaPosition are
// multiples of 4 on entry.  It also assumes that the DmaBufferSize is a
// power of 2 and that DmaBufferSize is greater than 4 bytes.

VOID
FillDmaBuffer (
    ULONG CurrentDmaPosition,
    ULONG LastDmaPosition,
    PDMAINFO Context
    )
{

    // Make positions relative to start of dma buffer.
    CurrentDmaPosition-=Context->PhysicalDmaBufferStart;
    LastDmaPosition-=Context->PhysicalDmaBufferStart;

    while (LastDmaPosition!=CurrentDmaPosition) {
        Context->pDmaBuffer[LastDmaPosition/4]=0xffffffff;
        LastDmaPosition+=4;
        LastDmaPosition&=Context->DmaBufferSize-1;
    }

}



// Glitches start whenever all of the samples in the buffer since we last checked
// match our starvation fill pattern.  This will happen whenever there is at least
// 1 ms of starvation assuming that we run our starvation detection with a 1ms period.
// This means that we WILL miss glitches that are for less than 1ms, but it also
// means that we won't be prone to false positives.

// Note that this routine assumes that CurrentDmaPosition and LastDmaPosition are
// multiples of 4 on entry.  It also assumes that the DmaBufferSize is a
// power of 2 and that DmaBufferSize is greater than 4 bytes.

BOOLEAN
GlitchStarted (
    ULONG CurrentDmaPosition,
    ULONG LastDmaPosition,
    PDMAINFO Context
    )
{

    if (CurrentDmaPosition==LastDmaPosition) {
        return FALSE;
    }

    // Make positions relative to start of dma buffer.
    CurrentDmaPosition-=Context->PhysicalDmaBufferStart;
    LastDmaPosition-=Context->PhysicalDmaBufferStart;

    while (LastDmaPosition!=CurrentDmaPosition) {
        if (Context->pDmaBuffer[LastDmaPosition/4]!=0xffffffff) {
            return FALSE;
        }
        LastDmaPosition+=4;
        LastDmaPosition&=Context->DmaBufferSize-1;
    }

    return TRUE;

}



// Glitches end as soon as any value in the buffer does not match
// our starvation fill pattern.

// Note that this routine assumes that CurrentDmaPosition and LastDmaPosition are
// multiples of 4 on entry.  It also assumes that the DmaBufferSize is a
// power of 2 and that DmaBufferSize is greater than 4 bytes.

BOOLEAN
GlitchEnded (
    ULONG CurrentDmaPosition,
    ULONG LastDmaPosition,
    PDMAINFO Context
    )
{

// Make positions relative to start of dma buffer.
CurrentDmaPosition-=Context->PhysicalDmaBufferStart;
LastDmaPosition-=Context->PhysicalDmaBufferStart;

while (LastDmaPosition!=CurrentDmaPosition) {
	if (Context->pDmaBuffer[LastDmaPosition/4]!=0xffffffff) {
		return TRUE;
		}
	LastDmaPosition+=4;
	LastDmaPosition&=Context->DmaBufferSize-1;
	}

return FALSE;

}


ULONG UnmaskedChannels=0;
ULONG DmaBufferRemapCount=0;
ULONG gCurrentDmaPosition=0;
ULONG gCurrentDmaCount=0;



NTSTATUS MapDmaBuffer(PDMAINFO Context, ULONG CurrentDmaPosition, ULONG CurrentDmaCount)
{

ULONG i;

// Whenever I get a non zero DMA position AND a non zero count, I have to
// make sure that I have that location properly mapped.

if (CurrentDmaPosition!=0 && CurrentDmaCount!=0) {

	// Check if this position and count are properly mapped.
	// If not, then we must remap the buffer.

	if (CurrentDmaPosition<Context->PhysicalDmaBufferStart ||
		CurrentDmaPosition>=Context->PhysicalDmaBufferStart+Context->DmaBufferSize ||
		CurrentDmaPosition+CurrentDmaCount<Context->PhysicalDmaBufferStart ||
		CurrentDmaPosition+CurrentDmaCount>Context->PhysicalDmaBufferStart+Context->DmaBufferSize
		) {

		// Position or size is outside current mapping.  Remap the buffer.
		DmaBufferRemapCount++;

		// Recalculate start and size of where the buffer should be.
		// WARNING:  We ASSUME all buffers we map are multiples of 4k bytes in size.
		// For WDM audio drivers this assumption is currently valid.
		Context->PhysicalDmaBufferStart=CurrentDmaPosition&(~(PROCPAGESIZE-1));
		Context->DmaBufferSize=(CurrentDmaCount+PROCPAGESIZE-1)&(~(PROCPAGESIZE-1));

		if (Context->DmaBufferSize>MAXDMABUFFERSIZE) {
			// Clear start and size since we cannot map them anyway.
			// Even more important, we must clear them so we will try to remap
			// again the next time this routine is called.
			Context->PhysicalDmaBufferStart=0;
			Context->DmaBufferSize=0;
			return STATUS_INSUFFICIENT_RESOURCES;
			}

		// Walk the pages we have for mapping the DMA buffer and remap them
		// to our DMA channel buffer.
		for (i=0; i<(Context->DmaBufferSize/PROCPAGESIZE); i++) {
			Context->PageTable[i+(((ULONG)(Context->pDmaBuffer)>>12)&1023)]=
			(Context->PhysicalDmaBufferStart+(i*PROCPAGESIZE))|(PRESENT|WRITABLE|USER|CACHEDISABLED);
			}

		// Now flush the TLBs.
		// If cr3 changes - which it DOES on NT, then I MUST make
		// sure that we don't get thread switched between the 2
		// assembly instructions - otherwise we will corrupt cr3.
		// Not a good thing.
		while (((LONG)ReadPerformanceCounter(0)+50)>0) {
		    Trap();
		    RtYield(0, 0);
		    }
		__asm mov eax, cr3;
		__asm mov cr3, eax;

		}
	
	}

return STATUS_SUCCESS;

}



ULONG
GetNextPrintPosition (
    PDMAINFO Context
    )

{

    ULONG PrintLocation, NextLocation;

    NextLocation=*Context->pPrintLoad;

    do {

        PrintLocation=NextLocation;

        NextLocation=InterlockedCompareExchange((PULONG)Context->pPrintLoad, PrintLocation+PACKETSIZE, PrintLocation);

    } while (PrintLocation!=NextLocation);

    // Now we clear out the opposite half of the print buffer.  We do this all in kernel mode.
    // This means that we have data only in 1/2 of the buffer.  As we add new data, we
    // delete the old data.  We do the deletion of data in kernel mode so that we only
    // need to read data from user mode.  I do NOT want user mode code to be writing to
    // this buffer.  User mode code can read out of the output buffer, but NOT write into
    // it.  This means we MUST both fill and clear this buffer ourselves.  Since user
    // mode code is dependent on the fact that all slots will be marked as having
    // NODATA in them until they have been completely loaded with data, at which point
    // they will be marked with something other than NODATA.  We guarantee that
    // every slot we are loading starts as NODATA by simply clearing the print slots
    // in kernel mode before we fill them.  The easiest way to do this is to start
    // by marking all entries in the buffer as NODATA, and then by continuing to make
    // sure that for every print slot we are going to fill with data, we clear the corresponding
    // print slot halfway around the buffer.

    // That simple algorithm guarantees that every slot starts out marked as NODATA and
    // then transitions to some other state after it is filled.

    ((ULONG *)Context->pPrintBuffer)[((PrintLocation+Context->PrintBufferSize/2)%Context->PrintBufferSize)/sizeof(ULONG)]=NODATA;

    PrintLocation%=Context->PrintBufferSize;

    return PrintLocation;

}



VOID
GlitchDetect (
    PDMAINFO Context,
    ThreadStats *Statistics
    )
{

    ULONG DmaMask, LastDmaMask;
    KIRQL OldIrql;
    ULONG LastDmaPosition;
    ULONG CurrentDmaPosition;
    ULONG CurrentDmaCount;
    ULONGLONG GlitchStart;
    ULONGLONG LastGlitchStart;
    ULONG GlitchLength;
    ULONG PrintLocation;
    ULONGLONG LastTimesliceStartTime;
    ULONG Owner;


    GlitchStart=0;
    GlitchLength=0;
    LastDmaMask=0;
    LastDmaPosition=0;
    LastGlitchStart=0;
    LastTimesliceStartTime=0;


    while (TRUE) {


        // If any other channels are unmasked.  Punt.
        // Until I figure out what is broken, we only support tracking 1 channel
        // at a time.
        if (UnmaskedChannels&(~(1<<Context->Channel))) {
            goto ReleaseCurrentTimeslice;
        }


        if (LastTimesliceStartTime) {
            LastTimesliceStartTime=Statistics->ThisTimesliceStartTime-LastTimesliceStartTime;
            // At this point LastTimesliceStartTime is really the time between the
            // last timeslice start time, and the current timeslice start time.
        }

        // CR3 DOES change under NT!  However, although there are multiple
        // page directories, they alias the same page tables - at least the
        // system non paged page tables.  (They have to since otherwise the
        // kernel mode locked code would not work.)
#ifndef UNDER_NT

        if (GetCR3()!=Context->CR3) {
            Trap();
            break;
        }

#endif

        // Grab the DMA master adapter spinlock.
        KeAcquireSpinLock(Context->pMasterAdapterSpinLock, &OldIrql);

        // Check mask state of our channel.
        DmaMask=ReadDMAMask();

        // Unmasked.
        if ((~DmaMask)&(1<<Context->Channel)) {

            // Lock out glitch tracking on other channels.  If this fails, then
            // someone else is already doing glitch tracking, so release the
            // spinlock and release the current timeslice.

            Owner=InterlockedCompareExchange(&UnmaskedChannels, 1<<Context->Channel, 0);
            
            if (!(Owner==(1<<Context->Channel) || Owner==0)) {
            
                // Release the DMA master adapter spinlock.
                KeReleaseSpinLock(Context->pMasterAdapterSpinLock, OldIrql);

                goto ReleaseCurrentTimeslice;

            }

            // Mask the DMA channel.
            MaskDmaChannel(Context->Channel);

            // Read the position.
            ReadDmaPosition(Context->Channel, &CurrentDmaPosition);

            // Align it.
            CurrentDmaPosition&=~3;

            // Read the count.
            ReadDmaCount(Context->Channel, &CurrentDmaCount);

            // Align it.
            CurrentDmaCount+=3;
            CurrentDmaCount&=~3;

            // Unmask the DMA channel.
            UnmaskDmaChannel(Context->Channel);

        }

        // Masked.
        else {

#if 0

            // Read the position.
            ReadDmaPosition(Context->Channel, &CurrentDmaPosition);

            // Align it.
            CurrentDmaPosition&=~3;

            // Read the count.
            ReadDmaCount(Context->Channel, &CurrentDmaCount);

            // Align it.
            CurrentDmaCount+=3;
            CurrentDmaCount&=~3;

#else

            CurrentDmaPosition=0;
            CurrentDmaCount=0;
            LastDmaPosition=0;

            // Release our lockout of glitch tracking on other channels.

            InterlockedCompareExchange(&UnmaskedChannels, 0, 1<<Context->Channel);

#endif

        }

        // Release the DMA master adapter spinlock.
        KeReleaseSpinLock(Context->pMasterAdapterSpinLock, OldIrql);

        // Load globals - so I can see what they are.
        gCurrentDmaPosition=CurrentDmaPosition;
        gCurrentDmaCount=CurrentDmaCount;

        // Now find and map the physical DMA buffer.
        // Punt and exit thread if we cannot map the buffer.
        if (MapDmaBuffer(Context, CurrentDmaPosition, CurrentDmaCount)!=STATUS_SUCCESS) {
            Trap();
            break;
        }

        // If LastDmaPosition and CurrentDmaPosition are valid and different,
        // then look for glitches.
        if (CurrentDmaPosition!=0 &&
        LastDmaPosition!=0 &&
        CurrentDmaPosition!=LastDmaPosition) {

            // Make sure our position is within our mapped buffer.  If not, log that
            // info and exit.  That will kill this thread.
            if (CurrentDmaPosition<Context->PhysicalDmaBufferStart || 
            CurrentDmaPosition>=(Context->PhysicalDmaBufferStart+Context->DmaBufferSize)) {
                Trap();
                break;
            }

            // Make sure both current and last dma positions are DWORD aligned.  Punt if not.
            if ((CurrentDmaPosition|LastDmaPosition)&3) {
                Trap();
                break;
            }

            // Make sure the dma buffer size is a power of 2.  Punt if not.
            if (Context->DmaBufferSize&(Context->DmaBufferSize-1)) {
                Trap();
                break;
            }

            // Check if we see our FLAG value in the DMA buffer.  Log glitch start time if so.
            if (!GlitchStart) {
                if (GlitchStarted(CurrentDmaPosition, LastDmaPosition, Context)) {
                    GlitchStart=Statistics->PeriodIndex;
                }
            }
            // If we are tracking a glitch, then see if there is valid data now.  Log glitch
            // stop time if so.
            else {
                if (GlitchEnded(CurrentDmaPosition, LastDmaPosition, Context)) {
                    GlitchLength=(ULONG)(Statistics->PeriodIndex-GlitchStart);
                }
            }

            // Fill in with our flag value behind the DMA pointer back to previous DMA pointer.
            FillDmaBuffer(CurrentDmaPosition, LastDmaPosition, Context);

        }



        // Print interrupt holdoff time if we have been held off.
        // We do this only for channels that are unmasked.
        if ((~DmaMask)&(1<<Context->Channel) && LastTimesliceStartTime>=2000*USEC) {

            PrintLocation=GetNextPrintPosition(Context);

            // Load the packet type last.  When the ring 3 code see's a packet
            // type that is not NODATA it assumes the rest of the packet has already
            // been written.

            ((ULONGLONG *)Context->pPrintBuffer)[1+PrintLocation/sizeof(ULONGLONG)]=LastTimesliceStartTime-MSEC;
            ((ULONG *)Context->pPrintBuffer)[PrintLocation/sizeof(ULONG)]=HELDOFF|(Context->Channel<<8);

        }


        // Print glitch information if any.
        if (GlitchLength) {

            PrintLocation=GetNextPrintPosition(Context);

            // Load the packet type last.  When the ring 3 code see's a packet
            // type that is not NODATA it assumes the rest of the packet has already
            // been written.

            // We put the DMA channel in byte 1 of the packet type.

            ((ULONGLONG *)Context->pPrintBuffer)[1+PrintLocation/sizeof(ULONGLONG)]=GlitchStart-LastGlitchStart;
            ((ULONG *)Context->pPrintBuffer)[1+PrintLocation/sizeof(ULONG)]=GlitchLength;
            ((ULONG *)Context->pPrintBuffer)[PrintLocation/sizeof(ULONG)]=GLITCHED|(Context->Channel<<8);

            LastGlitchStart=GlitchStart;

            GlitchStart=0;
            GlitchLength=0;

        }


        // Print pause/running state changes.
        if ((LastDmaMask^DmaMask)&(1<<Context->Channel)) {
            if (DmaMask&(1<<Context->Channel)) {

                PrintLocation=GetNextPrintPosition(Context);

                // Load the packet type last.  When the ring 3 code see's a packet
                // type that is not NODATA it assumes the rest of the packet has already
                // been written.

                // We put the DMA channel in byte 1 of the packet type.

                ((ULONG *)Context->pPrintBuffer)[PrintLocation/sizeof(ULONG)]=MASKED|(Context->Channel<<8);

            }
            else {

                PrintLocation=GetNextPrintPosition(Context);

                // Load the packet type last.  When the ring 3 code see's a packet
                // type that is not NODATA it assumes the rest of the packet has already
                // been written.

                // We put the DMA channel in byte 1 of the packet type.

                ((ULONG *)Context->pPrintBuffer)[PrintLocation/sizeof(ULONG)]=UNMASKED|(Context->Channel<<8);

            }
        }


        // Update LastDmaPosition;
        LastDmaPosition=CurrentDmaPosition;

        LastDmaMask=DmaMask;


ReleaseCurrentTimeslice:

        LastTimesliceStartTime=Statistics->ThisTimesliceStartTime;


        // Yield till next ms.

        RtYield(0, 0);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\monitor\realtime.c ===
#include <stdio.h>
#include <windows.h>
#include <mmsystem.h>
#include <dsound.h>


typedef struct {
    ULONG WriteLocation;
    ULONG ReadLocation;
    ULONG BufferSize;
    PCHAR pBuffer;
    } GLITCHDATA, *PGLITCHDATA;


enum PacketTypes{
    NODATA,
    MASKED,
    UNMASKED,
    GLITCHED,
    HELDOFF
    };


PGLITCHDATA rtbaseaddress=0;
ULONG rdwrrealtimedata=0;

#ifndef UNDER_NT
ULONG rdsystemdata=0;
#else
HANDLE  filterHandle;
#endif



#pragma warning( disable: 4035 )

ULONGLONG GetRealTimeData(PVOID address)
{

#ifndef UNDER_NT

__asm{
    push ds
    mov  eax,rdsystemdata
    mov  ds,ax
    mov  eax,address
    mov  edx,[eax+4]
    mov  eax,[eax]
    pop  ds
    }

#else

return *(PULONGLONG)address;

#endif

}

#ifndef UNDER_NT

CHAR GetRealTimeChar(PVOID address)
{

__asm{
    push ds
    mov  eax,rdsystemdata
    mov  ds,ax
    mov  edx,address
    xor  eax,eax
    mov  al,[edx]
    pop  ds
    }

}

#endif

#pragma warning( default: 4035 )

// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
BOOL GetRtBaseAddress(void)
{
#ifndef UNDER_NT
    HANDLE  filterHandle;
    char*   deviceName = "\\\\.\\RT";
#endif
    char*   glitchName = "\\\\.\\GLITCH";
    ULONG bytesreturned;

#ifndef UNDER_NT

    filterHandle = CreateFile(
        deviceName, 
        0,    //    GENERIC_READ | GENERIC_WRITE, 
        0,
        NULL,
        0,    //        OPEN_EXISTING,
        0,    //        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL
        );

    if (filterHandle == (HANDLE) -1) {
        printf("Realtime executive not loaded.  GetLastError == %x.\n", GetLastError());
        return FALSE;
        }

    DeviceIoControl(filterHandle, 2, NULL, 0, &rdsystemdata, sizeof(rdsystemdata), NULL, NULL);

    CloseHandle(filterHandle);

    if (!rdsystemdata) {
        return FALSE;
    }

#endif

    filterHandle = CreateFile(
        glitchName,
        #ifdef UNDER_NT
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        #else
        0,//        GENERIC_READ | GENERIC_WRITE, 
        0,
        NULL,
        0,//        OPEN_EXISTING,
        0,//        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL
        #endif
        );

    if (filterHandle == (HANDLE) -1) {
        printf("Glitch detector not loaded.  GetLastError == %x.\n", GetLastError());
        return FALSE;
    }

    
    DeviceIoControl(filterHandle, 2, NULL, 0, &(ULONG)rtbaseaddress, sizeof(rtbaseaddress), &bytesreturned, NULL);

    // On NT we only close the handle when we are done, since closing this handle
    // will cause our mapped view of the buffer to go away.  This is by design
    // since we use the fact that the OS will close open handles whenever the
    // process goes away to make sure that we properly clean up our mapped view.
#ifndef UNDER_NT
    CloseHandle(filterHandle);
#endif

    if (rtbaseaddress) {
        printf("base address = 0x%p\n", rtbaseaddress);
    }

    // We return TRUE even if rtbaseaddress is NULL.  We do this so we can
    // differentiate between when glitch.sys cannot be opened, and when
    // we cannot get a base address - which will ONLY happen under NT when
    // another instance of glitch.exe has already opened glitch.sys and has
    // not yet closed it.
    return TRUE;
}

// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
// #define VERBOSE

BOOL TrapDSError(HRESULT hRes, LPCSTR  szAPI)
{
    LPCSTR  szError;
    switch(hRes)
    {
        case DS_OK:                     szError = "DS_OK";                      break;
        case DSERR_ALLOCATED:           szError = "DSERR_ALLOCATED";            break;
        case DSERR_CONTROLUNAVAIL:      szError = "DSERR_CONTROLUNAVAIL";       break;
        case DSERR_INVALIDPARAM:        szError = "DSERR_INVALIDPARAM";         break;
        case DSERR_INVALIDCALL:         szError = "DSERR_INVALIDCALL";          break;
        case DSERR_GENERIC:             szError = "DSERR_GENERIC";              break;
        case DSERR_PRIOLEVELNEEDED:     szError = "DSERR_PRIOLEVELNEEDED";      break;
        case DSERR_OUTOFMEMORY:         szError = "DSERR_OUTOFMEMORY";          break;
        case DSERR_BADFORMAT:           szError = "DSERR_BADFORMAT";            break;
        case DSERR_UNSUPPORTED:         szError = "DSERR_UNSUPPORTED";          break;
        case DSERR_NODRIVER:            szError = "DSERR_NODRIVER";             break;
        case DSERR_ALREADYINITIALIZED:  szError = "DSERR_ALREADYINITIALIZED";   break;
        case DSERR_NOAGGREGATION:       szError = "DSERR_NOAGGREGATION";        break;
        case DSERR_BUFFERLOST:          szError = "DSERR_BUFFERLOST";           break;
        case DSERR_OTHERAPPHASPRIO:     szError = "DSERR_OTHERAPPHASPRIO";      break;
        case DSERR_UNINITIALIZED:       szError = "DSERR_UNINITIALIZED";        break;
        case DSERR_NOINTERFACE:         szError = "DSERR_NOINTERFACE";          break;
        default:                        szError = "UNKNOWN ERROR CODE";         break;    }

    if(FAILED(hRes))
        fprintf(stdout, "DSound ERROR: %s returned %s\n", szAPI, szError);
#ifdef VERBOSE
    else
        fprintf(stdout, "%s returned %s\n", szAPI, szError);
#endif

    return SUCCEEDED(hRes);
}

LPDIRECTSOUND       pDS = NULL;
LPDIRECTSOUNDBUFFER pDSB = NULL;

#define BUFFER_SIZE 88200
// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
void CleanupDSound(void)
{
    if (pDSB)
        IDirectSound_Release(pDSB);
    if (pDS)
        IDirectSoundBuffer_Release(pDS);

    pDS = NULL;
    pDSB = NULL;
}

// ------------------------------------------------------------------------------
// ------------------------------------------------------------------------------
BOOL StartDSoundLoop(void)
{
    WAVEFORMATEX    wfx;
    HRESULT         hRes;
    DSBUFFERDESC    dsbdesc;
    DWORD           cb1, cb2;
    PVOID           pv1, pv2;

    wfx.wFormatTag = WAVE_FORMAT_PCM; 
    wfx.nChannels = 1; 
    wfx.nSamplesPerSec = 44100; 
    wfx.nAvgBytesPerSec = 88200; 
    wfx.nBlockAlign = 2; 
    wfx.wBitsPerSample = 16;
    wfx.cbSize = 0; 

    hRes = DirectSoundCreate(NULL, &pDS, NULL );
    if (!TrapDSError(hRes, "DirectSoundCreate"))
        goto fail;

    hRes = IDirectSound_SetCooperativeLevel(pDS, GetForegroundWindow(), DSSCL_NORMAL );
    if (!TrapDSError(hRes, "SetCooperativeLevel"))
        goto fail;

    ZeroMemory( &dsbdesc, sizeof(DSBUFFERDESC));
    dsbdesc.dwSize = sizeof(DSBUFFERDESC);
    dsbdesc.dwBufferBytes = BUFFER_SIZE;
    dsbdesc.lpwfxFormat = &wfx;
    dsbdesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_LOCSOFTWARE;

    hRes = IDirectSound_CreateSoundBuffer(pDS, &dsbdesc, &pDSB, NULL );
    if (!TrapDSError(hRes, "CreateSoundBuffer"))
        goto fail;

    hRes = IDirectSoundBuffer_Lock(pDSB, 0, 0, &pv1, &cb1, &pv2, &cb2, DSBLOCK_ENTIREBUFFER);
    if (!TrapDSError(hRes, "Lock"))
        goto fail;

    // silence
    ZeroMemory(pv1, cb1);
    ZeroMemory(pv2, cb2);

    hRes = IDirectSoundBuffer_Unlock(pDSB, pv1, cb1, pv2, cb2);
    if (!TrapDSError(hRes, "Unlock"))
        goto fail;

    hRes = IDirectSoundBuffer_Play(pDSB, 0, 0, DSBPLAY_LOOPING);
    if (!TrapDSError(hRes, "Play"))
        goto fail;

    return TRUE;
fail:

    CleanupDSound();
    return FALSE;
}



int
__cdecl
main (
    void
    )
{

    ULONG OpenedGlitch;
    ULONG StartedDSound=FALSE; // MUST be preinitialized - for file open failure path.
    ULONG PrintedIndex;
    ULONG ToPrintIndex;
    PCHAR pPrintBuffer;
    ULONG PrintBufferSize;
    ULONGLONG Data[2];
    OSVERSIONINFO Version;
    SYSTEMTIME SystemTime;
    CHAR Build[5];
    CHAR MachineName[MAX_COMPUTERNAME_LENGTH+1];
    CHAR Date[9];
    CHAR Time[7];
    CHAR Path[_MAX_PATH];
    ULONG SupportStupidApi=MAX_COMPUTERNAME_LENGTH+1;
    FILE *f;


    // First open glitch.sys and map its buffer into our memory.
    // If we cannot open glitch.sys, then GetRtBaseAddress will return FALSE.
    // Otherwise it will return TRUE, but it will STILL return a NULL
    // rtbaseaddress if another glitch.exe has already opened it.
    OpenedGlitch=GetRtBaseAddress();

    if (OpenedGlitch && rtbaseaddress==NULL) {
        // We get here only if another instance of glitch.exe is running.
        printf("Another instance of glitch.exe is already running.\n");

#ifdef UNDER_NT
        CloseHandle(filterHandle);
#endif

        // We may want to make our display window hidden by default and
        // we could then ask the user if they want to unhide the window
        // of the already running glitch.exe.  That would be cool.
        return 0;
    }


    // If we succeeded in opening glitch.sys then load information about
    // the print buffer.  IMPORTANT:  this code should NOT be moved inside
    // the startnewlogfile loop!!  We do NOT want PrintedIndex to be zeroed
    // when we are continuing logging but just into a new file.
    if (OpenedGlitch) {
#ifndef UNDER_NT
        pPrintBuffer=(PCHAR)GetRealTimeData(&rtbaseaddress->pBuffer);
#else
        pPrintBuffer=(PCHAR)rtbaseaddress+4096;
#endif

        PrintBufferSize=(ULONG)GetRealTimeData(&rtbaseaddress->BufferSize);

        PrintedIndex=0;
    }

    
    // This is our entry point for starting a new log file.  We will start
    // a new log file for each day.
//startnewlogfile:


    // Initialize the strings we use to build the filename.
    strcpy(MachineName, "NONAME");
    Build[0]=0;
    Date[0]=0;
    Time[0]=0;

    // Initialize variables we use to build some of the strings - in case the
    // API's we call to get the real values fail.

    // We don't want a random build number if we don't get the real build
    // number.  So set it to zero.
    Version.dwBuildNumber=0;

    // We don't want a random date, if GetLocalTime fails.  HOWEVER, we DO want
    // a random time in that case, so that we get different filenames whenever
    // that happens.  So, we clear the fields that are used to generate the
    // date, also, randomize the the fields used to generate time.  For now
    // we do that by simply leaving whatever was on the stack in them.
    SystemTime.wMonth=0;
    SystemTime.wDay=0;
    SystemTime.wYear=0;

    // Get the version of the operating system we are running on.
    Version.dwOSVersionInfoSize=sizeof(OSVERSIONINFO);
    GetVersionEx(&Version);
    
    // Read the name of the machine we are running on.
    // Why they made the API require you to pass in a POINTER to the length
    // I will never understand.
    GetComputerName(MachineName, &SupportStupidApi);

    // Get the current local time.
    GetLocalTime(&SystemTime);

    // Build the path and filename of our glitch data file.
    // Our file name is built from the build number, date, machine name, and time of day.
    // The time is used primarily just to allow unique files to be created during the same day.

    // All files go to \\joeball7\glitch so we can build a database of all the glitch information.
    strcpy(Path, "\\\\joeball7\\glitch\\");

    // First put the build number into the filename.  Lets us easily group data by build.
    // Note that we modulo the build number by 10000 to guarantee that the number will
    // be 4 base 10 numerals or less.
    // We use that same trick when building all of our strings.  Since all of the strings
    // are exactly the length they need to be and no more.  It makes sure we don't have
    // buffer overruns in sprintf - without having to use snprintf.
    sprintf(Build, "%04d", (ULONG)((WORD)Version.dwBuildNumber%10000));
    strcat(Path, Build);
    strcat(Path, "_");

    // Next put the date into the filename.  Lets us easily group data by time.
    sprintf(Date, "%02d%02d%04d", (ULONG)SystemTime.wMonth%100, (ULONG)SystemTime.wDay%100, (ULONG)SystemTime.wYear%10000);
    strcat(Path, Date);
    strcat(Path, "_");

    // Next put the machine name into the filename.  This lets us group data by machine.
    strcat(Path, MachineName);
    strcat(Path, "_");

    // Finally put the time at the end.
    sprintf(Time, "%02d%02d%02d", (ULONG)SystemTime.wHour%100, (ULONG)SystemTime.wMinute%100, (ULONG)SystemTime.wSecond%100);
    strcat(Path, Time);

    // Open the glitch logging file.
    f=fopen(Path, "w");

    if (f==NULL) {

        if (OpenedGlitch) {
#ifdef UNDER_NT
            CloseHandle(filterHandle);
#endif
        }

        if (StartedDSound) {
            CleanupDSound();
        }

        return -1;
    }


    // Now that we have our logging file open, log any errors that occurred when
    // we tried to open glitch.sys.  Then exit.
    // I want to track how many machines cannot run glitch.exe - as that will
    // indicate how many machines can run rt.sys.
    if (!OpenedGlitch) {

        fprintf(f, "!!! FAILURE !!! - glitch.exe could not open glitch.sys.\n");
        fflush(f);
        fclose(f);

        return -1;
        }

    if (!StartedDSound) {
        StartedDSound=StartDSoundLoop();
    }



    // This is the main LOGGING loop.

    while(TRUE) {

        ToPrintIndex=(ULONG)GetRealTimeData(&rtbaseaddress->WriteLocation);

        if ( (ToPrintIndex-PrintedIndex) >= PrintBufferSize/2 ) {
            // We have gotten too far behind the kernel mode glitch detector.
            // Skip to the current kernel print position.
            // Also add a warning to the screen and the file.

            fprintf(stdout, "\n!!! WARNING !!! - skipping to current print location.\n\n");
            fprintf(f, "\n!!! WARNING !!! - skipping to current print location.\n\n");

            fflush(stdout);
            fflush(f);

            PrintedIndex=ToPrintIndex;
        }

        while (ToPrintIndex-PrintedIndex>15) {

            // Get the data packet.  First wait until packet loaded.
            do {
                Data[0]=GetRealTimeData(&pPrintBuffer[PrintedIndex%PrintBufferSize]);
            } while ((ULONG)Data[0]==NODATA);

            PrintedIndex+=8;

            // Now get the rest of the packet.
            Data[1]=GetRealTimeData(&pPrintBuffer[PrintedIndex%PrintBufferSize]);
            PrintedIndex+=8;

            // Print the data.
            switch((UCHAR)Data[0]) {
                case MASKED:
                    fprintf(stdout, "Masked,   %d\n", (ULONG)(Data[0])>>8);
                    fprintf(f, "M, %d\n", (ULONG)(Data[0])>>8);
                    break;
                case UNMASKED:
                    fprintf(stdout, "Unmasked, %d\n", (ULONG)(Data[0])>>8);
                    fprintf(f, "U, %d\n", (ULONG)(Data[0])>>8);
                    break;
                case GLITCHED:
                    fprintf(stdout, "Glitched, %d, %I64u, %lu\n", (ULONG)(Data[0])>>8, Data[1], (ULONG)(Data[0]>>32));
                    fprintf(f, "G, %d, %I64u, %lu\n", (ULONG)(Data[0])>>8, Data[1], (ULONG)(Data[0]>>32));
                    break;
                case HELDOFF:
                    fprintf(stdout, "Held Off, %d, %I64u\n", (ULONG)(Data[0])>>8, Data[1]);
                    fprintf(f, "H, %d, %I64u\n", (ULONG)(Data[0])>>8, Data[1]);
                    break;
                default:
                    break;
                }

            // We recheck if there is more data to print before we exit this inner
            // print loop.  Once we are printing, we print as much as we can before
            // we go back to sleep.

            ToPrintIndex=(ULONG)GetRealTimeData(&rtbaseaddress->WriteLocation);

            if ( (ToPrintIndex-PrintedIndex) >= PrintBufferSize/2 ) {
                // We have gotten too far behind the kernel mode glitch detector.
                // Skip to the current kernel print position.
                // Also add a warning to the screen and the file.

                fprintf(stdout, "\n!!! WARNING !!! - skipping to current print location.\n\n");
                fprintf(f, "\n!!! WARNING !!! - skipping to current print location.\n\n");

                PrintedIndex=ToPrintIndex;
            }

            // When we have finished printing everything that we can, then flush the
            // output buffers.  We do this here, so that we only flush data if we
            // have printed some, instead of every time through this loop, or
            // every time we wake up to check if there is data to print.
            if (ToPrintIndex-PrintedIndex<=15) {
                fflush(stdout);
                fflush(f);
            }

        }

        // Wake up every 100ms and loop to check if there is anything we need to print.
        Sleep(100);

    }

    fclose(f);

    CleanupDSound();

#ifdef UNDER_NT
    CloseHandle(filterHandle);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\rtmidi\common.h ===
//---------------------------------------------------------------------------
//
//  Module:   common.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#include <wdm.h>
#include <windef.h>
#include <winerror.h>

#include <stdio.h>

/*

#include <memory.h>
#include <stddef.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmedia.h>
#include <midi.h>
*/
#ifdef __cplusplus
}
#endif


#if defined(UNDER_NT) && DBG
#define DEBUG 1
#endif


#ifdef DEBUG
#define Trap()	{_asm {_emit 0xcc}}
#else
#define Trap()
#endif

#define WINICEDEBUGDUMP 1



#ifdef DEBUG

#if WINICEDEBUGDUMP
#define QDBG ""
#else
#define QDBG "'"
#endif

extern int RtDebugLevel;


/*
*    Generate debug output in printf type format.
*/

#define dprintf( _x_ )  { DbgPrint(QDBG"RT: "); DbgPrint _x_ ; DbgPrint(QDBG"\r\n"); }
#define dprintf1( _x_ ) if (RtDebugLevel >= 1) { DbgPrint(QDBG"RT: "); DbgPrint _x_ ; DbgPrint(QDBG"\r\n"); }
#define dprintf2( _x_ ) if (RtDebugLevel >= 2) { DbgPrint(QDBG"RT: "); DbgPrint _x_ ; DbgPrint(QDBG"\r\n"); }
#define dprintf3( _x_ ) if (RtDebugLevel >= 3) { DbgPrint(QDBG"RT: "); DbgPrint _x_ ; DbgPrint(QDBG"\r\n"); }
#define dprintf4( _x_ ) if (RtDebugLevel >= 4) { DbgPrint(QDBG"RT: "); DbgPrint _x_ ; DbgPrint(QDBG"\r\n"); }

#else

#define dprintf(x)
#define dprintf1(x)
#define dprintf2(x)
#define dprintf3(x)
#define dprintf4(x)

#endif // DEBUG



//#include "private.h"
//#include "sysaudio.h"

#define INIT_CODE   	code_seg("INIT", "CODE")
#define INIT_DATA   	data_seg("INIT", "DATA")
#define LOCKED_CODE 	code_seg(".text", "CODE")
#define LOCKED_DATA 	data_seg(".data", "DATA")
#define PAGEABLE_CODE	code_seg("PAGE", "CODE")
#define PAGEABLE_DATA	data_seg("PAGEDATA", "DATA")

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//---------------------------------------------------------------------------
//  End of File: common.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\common.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    common.h

Abstract:

    This module is the common internal header file for rt.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/



#ifndef UNDER_NT
#include <wdm.h>
#else
#include <ntddk.h>
#endif

#include <windef.h>



// On Win9x we have a guard page on all realtime stacks.
// NOTE: We need to implement the guard page feature on NT.

#ifndef UNDER_NT
#define GUARD_PAGE 1
#endif


// We make sure the processor can wake up every MS on even agressively
// power managed machines by setting the system timer resolution to 1ms.

#define WAKE_EVERY_MS 1


// Make sure our debug code works properly on NT.

#if defined(UNDER_NT) && DBG
#define DEBUG 1
#endif


// Trap macro stops on debug builds, does nothing on retail.

#ifdef DEBUG
#define Trap() __asm int 3
#else
#define Trap()
#endif


// Break macro stops on both debug and retail.

#define Break() __asm int 3


// Debug output defines and macros.

#ifdef DEBUG


// This controls whether or not to use the NTKERN internal debug buffer
// when doing debug printing.

#define USE_NTKERN_DEBUG_BUFFER 0


#if USE_NTKERN_DEBUG_BUFFER
#define QDBG "'"
#else
#define QDBG ""
#endif


// Generate debug output in printf type format.

#define dprintf( _x_ )  { DbgPrint(QDBG"RT: "); DbgPrint _x_ ; DbgPrint(QDBG"\r\n"); }


#else // DEBUG


#define dprintf(x)


#endif // DEBUG



// These control where code and data are located:  in pageable or non pageable memory.
// Much of the code and data in rt are in non pageable memory.
// However, the total amount of both code and data in rt is small.

#define INIT_CODE   	code_seg("INIT", "CODE")
#define INIT_DATA   	data_seg("INIT", "DATA")
#define LOCKED_CODE 	code_seg(".text", "CODE")
#define LOCKED_DATA 	data_seg(".data", "DATA")
#define PAGEABLE_CODE	code_seg("PAGE", "CODE")
#define PAGEABLE_DATA	data_seg("PAGEDATA", "DATA")


#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\rtmidi\device.c ===
//---------------------------------------------------------------------------
//
//  Module:   device.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//     M.McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#define IRPMJFUNCDESC
//#define MAX_DEBUG 1


#include "common.h"
#include "rt.h"
#include "sequence.h"


VOID DriverUnload(
    IN PDRIVER_OBJECT	DriverObject
)
{
    //dprintf((" DriverUnload Enter (DriverObject = %x)", DriverObject));
    Trap();

}


extern testmidi;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS DriverEntry
(
    IN PDRIVER_OBJECT	    DriverObject,
    IN PUNICODE_STRING	    usRegistryPathName
)
{
    NTSTATUS Status = STATUS_SUCCESS;
	
    DriverObject->DriverUnload                                  = DriverUnload;

    // For now, keep the driver loaded always.
    ObReferenceObject(DriverObject);

	Status=RtCreateThread(1*MSEC,15*USEC,0,2,PlayMidi,(PVOID)testmidi,NULL);

    return Status;
}

//---------------------------------------------------------------------------
//  End of File: device.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\rtmidi\sequence.h ===
VOID PlayMidi(PVOID Context, ThreadStats *Statistics);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\apic.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    apic.h

Abstract:

    This module contains private x86 processor local APIC defines, variables, inline
    functions and prototypes.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




// Local APIC defines.


// APIC register address offsets from the APICBASE.

// These are offsets to registers used to control local interrupt sources for the processor.
// The local APIC timer is built into the local APIC on the processor itself and is
// separate from other timers on the motherboard.

#define APICSPURIOUS 0xf0       // Spurious interrupt
#define APICTIMER 0x320         // Local APIC timer interrupt (maskable only)
#define APICPERF 0x340          // Performance counter interrupt (NMI or maskable)
#define APICINTR 0x350          // External interrupt 1 (normally connected to external maskable interrupts)
#define APICNMI 0x360           // External interrupt 2 (normally connected to external NMI)
#define APICERROR 0x370         // Local APIC error interrupt.


// These are assorted additional registers in the local APIC.

#define APICID 0x20
#define APICVERSION 0x30
#define APICTPR 0x80
#define APICAPR 0x90
#define APICPPR 0xa0
#define APICEOI 0xb0            // Used to EOI maskable interrupt sources.
#define APICSTATUS 0x280
#define APICICRLOW 0x300        // Used to generate interrupts on the local APIC bus under software control.
#define APICICRHIGH 0x310


// These are registers associated with the local APIC timer.

#define APICTIMERINITIALCOUNT 0x380     // Loads initial count into timer and starts it running.
#define APICTIMERCURRENTCOUNT 0x390     // Used to read the local APIC timer current count.
#define APICTIMERDIVIDE 0x3e0           // Programs local APIC timer divisor (divide by 1, 2, 4 etc)


// These are values that can be written into the local apic interrupt control
// registers (APICSPURIOUS-APICERROR) to control what type of interrupt each of the
// local interrupt sources generate.

#define FIXED 0                 // Maskable interrupt.  Interrupt vector is specified.
#define NMI 0x400               // Non maskable interrupt.  Interrupt vector ignored. (Vector 2 always used).
#define EXTINT 0x700            // Used ONLY for exteral maskable PIC controlled interrupts. (APICINTR)


// This is a mask for the interrupt vector in the local apic interrupt control registers.

#define VECTORMASK 0xff

// These values are also written into the local apic interrupt control registers.
// All of the local interrupt sources can be individually masked or unmasked in the local apic.

#define MASKED 0x10000
#define UNMASKED 0


// The following values are used to program the mode of the local APIC timer.

#define PERIODIC 0x20000
#define ONESHOT 0


// The following values are used to program the divisor used by the local APIC timer.

#define DIVIDEBY1 0xb
#define DIVIDEBY2 0x0
#define DIVIDEBY4 0x1
#define DIVIDEBY8 0x2


#define SENDPENDING 0x1000
#define ASSERTIRQ 0x4000




// Local APIC globals.

// This global contains the base virtual address of the local APIC.
// The local APIC is memory mapped.

extern CHAR *ApicBase;


// These global variables point to their respective interrupt control registers.

extern volatile ULONG *ApicPerfInterrupt;
extern volatile ULONG *ApicTimerInterrupt;
extern volatile ULONG *ApicNmiInterrupt;
extern volatile ULONG *ApicIntrInterrupt;


// These are the interrupt vectors for the local apic timer and performance counter
// interrupt control registers.  We use variables now instead of constants
// for these, so that we keep using the same vector locations that the HALs which
// support the local APIC initially program into the control registers.

extern ULONG ApicTimerVector;
extern ULONG ApicPerfVector;
extern ULONG ApicErrorVector;
extern ULONG ApicSpuriousVector;


// Various local APIC related function prototypes.

BOOL
MachineHasAPIC (
    VOID
    );

BOOL
EnableAPIC (
    VOID
    );




// Inline functions for reading and writing local APIC registers.

#pragma LOCKED_CODE


// __inline
// ULONG
// ReadAPIC (
//     ULONG offset
//     )
// 
// /*++
//
// Function Description:
//
//     Reads and returns the contents of the specified processor local APIC register.
//
// Arguments:
//
//     offset - Supplies the offset from the base address of the local APIC of the register
//     to be read.
//
// Return Value:
//
//     The value read from the specified local APIC register is returned.
//
// --*/

__inline
ULONG
ReadAPIC (
    ULONG offset
    )

{

ASSERT( ApicBase );

return *(ULONG *)(ApicBase+offset);

}



// __inline
// VOID
// WriteAPIC (
//     ULONG offset,
//     ULONG value
//     )
//
// /*++
//
// Function Description:
//
//      Writes the processor local apic register at the specified offset from the local
//      APIC base address, with the specifed value.
//
// Arguments:
//
//      offset - Supplies the offset from the base address of the local APIC of the register
//              to be written.
//
//      value - Supplies the value to be written into the local APIC register.
//
// Return Value:
//
//      None.
//
// --*/

__inline
VOID
WriteAPIC (
    ULONG offset,
    ULONG value
    )

{

ASSERT( ApicBase );

*(ULONG *)(ApicBase+offset)=value;

}


#pragma PAGEABLE_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\clients\rtmidi\sequence.c ===
// A Somewhat Useful Sample Real Time Client.

// Author:  Joseph Ballantyne
// Date:    3/12/99

// This is the first real time client that actually does something
// useful.  This is a midi MPU401 sequencer.  It is simple, but it
// works and uses less CPU than our current 98 and NT WDM sequencer.

// Of course since this is a sample and I am not in the business of
// writing MIDI sequencers, it has some limitations.

// The data to be sequenced is passed in in one big block.
// It is passed in already formatted and timestamped appropriately.
// This code simply processes the buffer it was passed, and when
// it has sequenced everything that was passed in, it returns - 
// which kills the real time thread.


#include "common.h"
#include "rt.h"
#include "sequence.h"


// This code only supports the MPU401 at a fixed IO location of 0x330.

// MPU401 defines

#define MPU401BASEADDRESS 0x330

#define MPU401_REG_DATA     0x00    // Data in/out register offset from base address
#define MPU401_REG_COMMAND  0x01    // Command register offset from base address
#define MPU401_REG_STATUS   0x01    // Status register offset from base addess

#define MPU401_DRR          0x40    // Output ready (for command or data)
#define MPU401_DSR          0x80    // Input ready (for data)

#define MPU401_CMD_RESET    0xFF    // Reset command
#define MPU401_CMD_UART     0x3F    // Switch to UART mod
#define MPU401_ACK			0xFE	// Ack from MPU401 after successful command.


#define MidiWriteOK(status)  ((status & MPU401_DRR) == 0)
#define MidiReadOK(status)   ((status & MPU401_DSR) == 0)


// Here is the format of the data we process.

#pragma pack(push,1)

typedef struct MidiChunk{
	struct MidiChunk *next;
	struct MidiChunk *previous;
	ULONGLONG timestamp;
	ULONG numbytes;
	UCHAR data[3];
	} MidiMessage, *PMidiMessage;

#pragma pack(pop)


// Remember, everything we touch HAS to be locked down.

#pragma LOCKED_CODE
#pragma LOCKED_DATA


MidiMessage testmidi[2]={
	{&testmidi[1],&testmidi[1],0,3,0x99,0x25,0x7f},
	{&testmidi[0],&testmidi[0],240,3,0x99,0x25,0}
	};


#pragma warning ( disable : 4035 )

#define rdtsc __asm _emit 0x0f __asm _emit 0x31


LONGLONG __inline ReadCycleCounter(VOID)
{

__asm {
	rdtsc
	}

}

#pragma warning ( default : 4035 )



VOID OutB(ULONG address, ULONG data)
{

__asm {
	mov edx,address
	mov eax,data
	out dx,al
	}

}


#pragma warning( disable : 4035 )

ULONG InB(ULONG address)
{

__asm {
	mov edx,address
	xor eax,eax
	in al,dx
	}

}

#pragma warning( default : 4035 )


// This routine sends a command to the MPU401 and waits for an acknowledge from
// the MPU that the command succeeded.  If no ack is recieved in 200ms then
// it returns FALSE, otherwise it returns TRUE.

BOOL SendMpuCommand(ULONG MidiBaseAddress, UCHAR command)
{
LONG count=0;

// Wait until OK to write a command.

while (!MidiWriteOK(InB(MidiBaseAddress+MPU401_REG_STATUS))) {
	RtYield(0, 0);
	}

// Send command to the MPU401.

OutB(MidiBaseAddress+MPU401_REG_COMMAND, command);

// Wait for the MPU acknowlege.  If we don't get the correct response
// in 200ms or less, then punt.

while (!MidiReadOK(InB(MidiBaseAddress+MPU401_REG_STATUS))) {
	count++;
	if (count<=200) {
		RtYield(0, 0);
		}
	else {
		// We did not get any response, perhaps we were in UART mode.
		#if 0
		return FALSE;
		#else
		break;
		#endif
		}
	}

// At this point we received something from the MPU, check if it is an ack.

if (InB(MidiBaseAddress+MPU401_REG_DATA)!=0xfe) {
	// Not a command acknowledge.
	Trap();
	return FALSE;
	}

return TRUE;

}


VOID PlayMidi(PVOID Context, ThreadStats *Statistics)
{

PMidiMessage RealTimeMidiData;
ULONG MidiBaseAddress;
ULONG MidiStatus;
ULONG count;

LONGLONG starttime;


//Trap();

RealTimeMidiData=(PMidiMessage)Context;

MidiBaseAddress=MPU401BASEADDRESS;

count=0;

// First wait until the MPU401 comes on line.  We need to do this because
// many MPU401s are plug and play devices and do not appear until
// the hardware is setup.  Note that on most machines, when there is
// no device on the bus at the I/O port address, InB will return
// 0xff.
while (InB(MidiBaseAddress+MPU401_REG_STATUS)==0xff) {
	RtYield(0, 0);
	}

//Trap();

// At this point, there is detected hardware at 331.
// Now wait an extra 10 seconds.
starttime=Statistics->ThisPeriodStartTime;
while((Statistics->ThisPeriodStartTime-starttime)/SEC<10) {
	RtYield(0, 0);
	}

//Trap();

// Now read the MPU401 data register until it is empty.
while (MidiReadOK(InB(MidiBaseAddress+MPU401_REG_STATUS))) {
	InB(MidiBaseAddress+MPU401_REG_DATA);
	RtYield(0, 0);
	}

//Trap();

// Now reset the MPU401.  If this succeeds, we know we have a real
// MPU at our base address.  Note that the MPU may be in UART
// mode.  If so, then we will NOT get an acknowlege back when we reset it.
// To handle this case, if there is no acknowlege on the first
// reset, we will retry once and see if we get the acknowlege the second
// time.  If not, then we punt.

if (!SendMpuCommand(MidiBaseAddress, MPU401_CMD_RESET)) {
	if (!SendMpuCommand(MidiBaseAddress, MPU401_CMD_RESET)) {
		Trap();
		return;
		}
	}

// Now put the MPU into UART mode.

if (!SendMpuCommand(MidiBaseAddress, MPU401_CMD_UART)) {
	// For now we disable the trap and the thread exit.
	// We do this because if we run this code on current WDM driven devices,
	// the acknowlege code will be handled by the read interrupt service
	// routine of the driver and so we will not see it.
	Trap();
	return;
	}


// Now reset the starttime.
starttime=ReadCycleCounter();

// Run until we are out of data to send.

while (RealTimeMidiData!=NULL) {

	// Wait until we need to send the next chunk of data.
//	if (Statistics->totalperiods*MSEC<RealTimeMidiData->timestamp) {
	if ((ULONGLONG)(ReadCycleCounter()-starttime)/200000<RealTimeMidiData->timestamp) {
		RtYield(0, 0);
		continue;
		}

	// Read the status of the device.

	MidiStatus=InB(MidiBaseAddress+MPU401_REG_STATUS);

	// Make sure its OK to write to the device.  We should ALWAYS
	// be able to, since we syncronize with the hardware.  If not,
	// then update the syncronization, and slip to our next time slice.

	if (!MidiWriteOK(MidiStatus)) {
		RtYield(0, 0);
		continue;
		}

	// Now write the next byte out to the MPU.
	OutB(MidiBaseAddress+MPU401_REG_DATA, RealTimeMidiData->data[count]);

	// Update our state.
	count++;
	if (count>=RealTimeMidiData->numbytes) {

		RealTimeMidiData->timestamp+=250;

		RealTimeMidiData=RealTimeMidiData->next;
		count=0;
		}

	// And yeild - we are done until its time for the next byte.
	RtYield(0, 0);

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\cpu.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    cpu.h

Abstract:

    This module contains code for processor identification, as well as code for
    calibrating the processor clock speed.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




// Processor related defines and macros.


// Supported architectures.

#define X86 1


// Supported manufacturers.

#define INTEL 1
#define AMD 2


// Feature bit locations in the CPU id instruction supported features dword.

#define FXSR (1<<24)
#define MMX (1<<23)
#define APIC (1<<9)
#define MSR (1<<5)
#define TSC (1<<4)
#define FPU (1<<0)


#define OSFXSR 0x200


#define MAXTIMERREADSLOTS 33
#define LIMITTOTALTIMERREADS 64


#define DEFAULTMAXTIMERCOUNT 0x12


// Instructions not supported by the inline assembler.

#define cpuid __asm _emit 0x0f __asm _emit 0xa2
#define rdtsc __asm _emit 0x0f __asm _emit 0x31


// Macro to force serialization of instruction execution.
// This is the fastest possible way to force instruction serialization for
// Pentium processors.  It may not be the fastest on PII, PIII or P4
// processors.

#define SerializeExecution() \
__asm { \
	__asm sub esp,8 \
	__asm sidt [esp] \
	__asm lidt [esp] \
	__asm add esp,8 \
	}




// Structures for supporting processor identification and clock speed calibration.


// The CPUINFO structure is used to store/access the results of the CPU ID instruction.

typedef struct {
	ULONG eax;
	ULONG ebx;
	ULONG edx;
	ULONG ecx;
	} CPUINFO;


// The TimerReadInfo structure is used by the cpu clock speed calibration code.

// Note that we want this structure to be 32 byte aligned.
// This allows us to force the whole thing into cache by just touching
// the first element.  We depend on this in our code for getting
// stuff into the cache, so don't change it.

typedef struct {
	ULONGLONG firstreadtimestamp;
	ULONGLONG lastreadtimestamp;
	ULONG count;
	ULONG value;
	ULONGLONG align;
	} TimerReadInfo;




// These globals store information about the processor we are running on.

ULONG CPUArchitecture=0;
ULONG CPUManufacturer=0;
LONG CPUFamily=0xffffffff;
LONG CPUModel=0xffffffff;
LONG CPUStepping=0xffffffff;
ULONGLONG CPUFeatures=0;


// TimerReadInfo stores timing meassurements as they are taken.

TimerReadInfo TimerRead[MAXTIMERREADSLOTS];




#pragma warning ( disable : 4035 )


ULONG
CpuIdOk (
    VOID
    )

/*++

Routine Description:

    Determines if the processor supports running the CPUID instruction.
    It does so by checking if the state of bit 21 of the eflags register
    can be changed.

Arguments:

    None.

Return Value:

    FALSE (0) if processor does not support the CPUID instruction.
    TRUE (bit 21 set to 1) if processor does support CPUID.

--*/

{

    __asm {

        // First save eflags.
        pushfd

        // Load eflags into eax.
        mov eax, [esp]

        // Flip state of bit 21 and put it back into eflags.
        xor	eax,1<<21
        push eax
        popfd

        // Read new eflags into eax.
        pushfd
        pop	eax

        // See if bit 21 state change stuck.  If so, we have CPUID instruction support
        // and we will return with bit 21 set, otherwise there is no CPUID support and
        // we will return zero.
        xor	eax, [esp]

        // Restore orignal eflags.
        popfd

        }

}


#pragma warning ( default : 4035 )



BOOLEAN
GetCpuId (
    ULONG index,
    CPUINFO *cpuinfo
    )

/*++

Routine Description:

    Checks whether the processor supports the CPUID instruction.  If not, returns
    FALSE.  Otherwise, runs the CPUID instruction with the supplied index and
    writes the output into the location pointed to by cpuinfo if it is not NULL.

Arguments:

    index - Supplies a value that selects which data should be returned by CPUID.

    cpuinfo - Supplies a pointer to a CPUINFO structure into which the CPUID data
              will be written.  Can be NULL in which case no data is returned.

Return Value:

    TRUE if the CPUID instruction is supported by the processor and was run for
    this call of the function.
    FALSE if the CPUID instruction is not supported.  Nothing is written into
    cpuinfo in that case.
    

--*/

{


    static ULONG initialized=0;


    // Check if the processor supports the CPUID instruction.
    // This is a one time check.
    if (!initialized) {
        initialized=1+CpuIdOk();
    }


    // If the CPUID instruction is supported, then run it.
    if (initialized&(1<<21)) {

        // The CPU supports CPU ID.  Do it.

        __asm {
            mov eax,index

            // Now make clear to the compiler that the cpuid instruction
            // will blow away the contents of these registers.  The inline
            // assembler does not support the cpuid instruction, so the compiler
            // thinks edx, ebx, and ecx do not change in this function.  Not so.
            xor edx,edx
            xor ebx,ebx
            xor ecx,ecx

            cpuid

            // Now, if we were passed a valid pointer for the data, then store it.

            mov esi,cpuinfo
            or esi,esi
            jz nullptr

            mov [esi],eax
            mov [esi+4],ebx
            mov [esi+8],edx
            mov [esi+12],ecx

            nullptr:
            }

        return TRUE;

    }

    // CPU does not support CPU ID.
    return FALSE;


}




BOOL
GetProcessorInfo (
    VOID
    )

/*++

Routine Description:

    Loads globals containing information about the processor architecture, manufacturer
    family, model, stepping and features.  Currently supports AMD and Intel processors.

Arguments:

    None.

Return Value:

    TRUE if the processor supports CPUID instruction and the manufacturer is known
    and supported.  Currently Intel and AMD are supported.

    FALSE otherwise.

--*/

{

    CPUINFO thecpu;

    if (!GetCpuId(0, &thecpu)) {
        return FALSE;
    }

    if (thecpu.ebx==0x756e6547 && thecpu.edx==0x49656e69 && thecpu.ecx==0x6c65746e ) {

        CPUManufacturer=INTEL;

        if (thecpu.eax) {

            GetCpuId(1, &thecpu);

            CPUFamily=(thecpu.eax>>8)&0xf;

            CPUModel=(thecpu.eax>>4)&0xf;

            CPUStepping=(thecpu.eax)&0xf;

            CPUArchitecture=X86;

            CPUFeatures=thecpu.edx;

            return TRUE;

        }

        return FALSE;

    }

    if (thecpu.ebx==0x68747541 && thecpu.edx==0x69746e65 && thecpu.ecx==0x444d4163 ) {

        CPUManufacturer=AMD;

        if (thecpu.eax) {

            GetCpuId(1, &thecpu);

            CPUFamily=(thecpu.eax>>8)&0xf;

            CPUModel=(thecpu.eax>>4)&0xf;

            CPUStepping=(thecpu.eax)&0xf;

            CPUArchitecture=X86;

            CPUFeatures=thecpu.edx;

            return TRUE;

        }

        return FALSE;

    }

    CPUManufacturer=(ULONG)-1;

    return FALSE;

}


// Note that all of the timing functions should be in locked memory.  Note also
// that I should make sure that they are in the cache - preferably in the primary CPU
// cache, but at least in the secondary cache.


// We use timer 0 on the PC motherboard for our calibration of the CPU
// cycle counter.


#pragma warning ( disable : 4035 )


LONGLONG
__inline
ReadCycleCounter (
    VOID
    )
{

    __asm {
        rdtsc
        }

}




ULONG
ReadPcTimer (
    VOID
    )
{

    __asm {

        xor eax,eax
        out 0x43,al
        in al,0x40
        mov ecx,eax
        in al,0x40
        shl eax,8
        or eax,ecx

        }

}




ULONG
__inline
FastPcTimerRead (
    VOID
    )
{

    __asm {
        xor eax,eax
        in al,0x41
        }

}


#pragma warning ( default : 4035 )




VOID
SetupPcTimer (
    VOID
    )
{

    __asm {

#if 0
        // The following code is for using timer 2.  I have decided to use timer 0.

        // First turn off PC speaker and turn ON timer 2 gate.
        mov eax,1
        out 0x61,al

        // Now read from timer port to clear any previously latched data.
        // In case someone else latched data but never read it.
        in al,0x42
        in al,0x42

        // Now latch timer 2 status and make sure mode and latch type OK.
        mov eax,0xe8
        out 0x43,al
        in al,0x42
        and	eax,0x37
        cmp eax,0x36
        jz timersetupok
        int 3
    timersetupok:

#endif

        // Now read from timer port to clear any previously latched data.
        // In case someone else latched data but never read it.
        // Note that we do three reads in case both status and a 2 byte 
        // count were latched.
        in al,0x40
        in al,0x40
        in al,0x40

        // Now latch timer 0 status and make sure mode and latch type OK.
        mov eax,0xe2
        out 0x43,al
        in al,0x40
        and	eax,0x37
        cmp eax,0x34
        jz timersetupok
        int 3
    timersetupok:

        }

    // Now since we are NOT reprogramming the mode, or the count of the timer, we
    // do not know what count the timer counter will autoreload.  Therefore, we
    // cannot make an accurate timing measurement if the timer wraps.  Therefore
    // we wait here until the timer has a positive count that is large enough to
    // ensure that we can calibrate our delay loop without having the timer wrap.

    // Note that this does mean we WILL have an extra delay here waiting for the timer
    // to wrap.  Note that we should also make sure that we disable the timer interrupts
    // so that they don't cause us to wait even longer.

    while (ReadPcTimer()<20)
        ;


}




// IMPORTANT! Note that it is possible though VERY unlikely that someone
// could have sent a command to latch BOTH the count and the status
// and then never done the reads.  To clear out any latched data we
// would thus need to do 3 reads.  One for status, and 2 for possibly
// 16 bits of latched data.


// In this function, we check setup of the motherboard PC timer 1.
// It should be setup for mode 2 counting, for doing single byte reads, 
// and for reloading a max count of 0x12.  We verify this and return
// true if so, false otherwise.

BOOL
SetupFastPcTimer (
    VOID
    )
{

    __asm {

        // Read from timer port to clear any previously latched data.
        // We do 3 reads in case the timer was programmed for 16 bit reads
        // and both status and count were latched.
        in al,0x41
        in al,0x41
        in al,0x41

        // Now latch timer 2 status and make sure mode and latch type OK.
        mov eax,0xe4
        out 0x43,al
        in al,0x41
        and	eax,0x37
        cmp eax,0x14
        jz timersetupok

        }

    Trap();

    return FALSE;

    timersetupok:

    return TRUE;

}



// Note that this function assumes that there is a cycle counter
// in the machine and that calling ReadCycleCounter will read
// it correctly.

// If this function cannot successfully measure cyclespertick, it 
// returns 0.

ULONG
MeasureCPUCyclesPerTick (
    VOID
    )
{

    ULONG i;
    ULONG ticks;
    LONGLONG cyclecount;
    ULONG totaltimerreads;
    ULONG fasttimermaxvalue,counterwrapped;
    ULONG cyclespertick;
    static ULONG largesttimermaxvalue=0;
#if DEBUG
    static ULONG maxcyclespertick=0,mincyclespertick=0xffffffff;
#endif

    // Make sure that the PC motherboard timer we will use is setup
    // correctly.  If not, then punt.
    if (!SetupFastPcTimer()) {
        return 0;
    }

    // Get the variables we will use in the cache.
    cyclecount=0;
    for (i=0;i<MAXTIMERREADSLOTS;i++) {
        cyclecount+=TimerRead[i].firstreadtimestamp;
    }

    i=1;
    ticks=0;
    cyclecount=0;
    totaltimerreads=0;
    fasttimermaxvalue=0;
    counterwrapped=FALSE;

    // Get the functions we call while making measurements into the cache

    FastPcTimerRead();
    SerializeExecution();
    ReadCycleCounter();

    // Setup for the first time through the loop.

    TimerRead[i-1].value=0xffffffff;
    TimerRead[i-1].lastreadtimestamp=ReadCycleCounter();

    while (i<MAXTIMERREADSLOTS && totaltimerreads<LIMITTOTALTIMERREADS) {
        // Count total number of timer reads.
        totaltimerreads++;

        // Read the timer value and timestamp the end of the read
        // with the cycle counter.
        ticks=FastPcTimerRead();
        SerializeExecution();
        cyclecount=ReadCycleCounter();

        // Track the max count.
        if (ticks>fasttimermaxvalue) {
            fasttimermaxvalue=ticks;
        }

        // Track if the counter wraps.
        // IMPORTANT!  We depend here on TimerRead[0].value ALWAYS being larger
        // than any value we can read from the hardware.
        if (ticks>TimerRead[i-1].value) {
            counterwrapped=TRUE;
        }

        // Make sure the cyclecounter didn't get blown away between this and
        // the last measurement.  If so, then punt.
        // IMPORTANT!  We depend here on TimerRead[0].lastreadtimestamp
        // being correctly initialized outside this loop.
        if ((LONGLONG)(cyclecount-TimerRead[i-1].lastreadtimestamp)<0) {
            Trap();
            return 0;
        }

        // If we are on the same tick as the last read, then update
        // the lastreadtimestamp and count for the previous set of reads.
        // IMPORTANT!  We depend here on TimerRead[0].value ALWAYS being
        // different from any value we can read from the hardware.
        if (ticks==TimerRead[i-1].value) {
            TimerRead[i-1].lastreadtimestamp=cyclecount;
            TimerRead[i-1].count++;
            continue;
        }

        // If we get here, we have a new timer value.  So log the new
        // value.
        TimerRead[i].firstreadtimestamp=cyclecount;
        TimerRead[i].lastreadtimestamp=cyclecount;
        TimerRead[i].value=ticks;
        TimerRead[i].count=1;

        // Point to next timer read slot.
        i++;

    }

    // Make sure that we don't try to calibrate with a broken timer.
    if (totaltimerreads>=LIMITTOTALTIMERREADS) {
        Trap();
        return 0;
    }

    // Track the largest value read from timer 1 since boot.
    if (fasttimermaxvalue>largesttimermaxvalue) {
        largesttimermaxvalue=fasttimermaxvalue;

        // Make sure the max count is OK.
        if (largesttimermaxvalue>DEFAULTMAXTIMERCOUNT) {
            dprintf(("Max count of 0x%x instead of 0x12 on channel 1 of 8254 timer.", largesttimermaxvalue));
        }

    }

    // If we wrapped, and our current max count either equals or is within
    // 2 ticks of the largest since boot, then use the largest max count
    // since boot in our loops to calculate the upper and lower bounds
    // on cyclespertick.

    // Otherwise we have wrapped and logged a maximum timer 1 count that
    // is not close enough to the maximum since boot to be able to trust
    // that the max since boot is the correct value to use when calculating
    // the bounds, so, force the calculations to only pair up measurements
    // that do not include counter wraps in the calculations by setting
    // fasttimermaxvalue to zero.

    // If we did not wrap, then the value of fasttimermaxvalue is irrelevant
    // since it will not be needed to correctly calculate the upper and lower
    // bounds on cyclespertick.
    if (counterwrapped) {
        if (fasttimermaxvalue+2>=largesttimermaxvalue) {
            fasttimermaxvalue=largesttimermaxvalue;

            // Now make sure that largesttimermaxvalue matches what
            // the default maximum should be.  If not, then prevent the
            // upper and lower bound calculations from using measurement
            // pairs that have wrapped timer ticks.
            if (fasttimermaxvalue!=DEFAULTMAXTIMERCOUNT) {
                fasttimermaxvalue=0;
            }
        }
        else {
            fasttimermaxvalue=0;
        }
    }


    // Now calculate the cyclespertick.

    // Scan through all of the pairs of tick values and calculate an
    // an upper and lower bound on the cycles per tick for each pair.

    {
    ULONG j;
    ULONG lowerbound,upperbound;
    ULONG maxlowerbound,minupperbound;
    ULONG lowerboundtotal,upperboundtotal;
    ULONG lowerboundcount,upperboundcount;

    lowerboundtotal=0;
    lowerboundcount=0;
    upperboundtotal=0;
    upperboundcount=0;

    maxlowerbound=0;
    minupperbound=0xffffffff;

    for (i=1;i<MAXTIMERREADSLOTS;i++) {

        LONG totaltickdiff;

        // If a tick was read more than once, then update the lower bound
        // on cycles per tick.
        if (TimerRead[i].count>1) {
            //Trap();
            lowerbound=(ULONG)(TimerRead[i].lastreadtimestamp-TimerRead[i].firstreadtimestamp);
            if (lowerbound>maxlowerbound) {
                maxlowerbound=lowerbound;
            }
            lowerboundtotal+=lowerbound;
            lowerboundcount++;
        }

        totaltickdiff=0;

        for (j=i+1;j<MAXTIMERREADSLOTS;j++) {

            LONG tickdiff;

            tickdiff=TimerRead[j-1].value-TimerRead[j].value;

            if (tickdiff<0) {
                // The timer tick values have wrapped, if we have a valid
                // maximum for the timer tick values, then fix up the 
                // tickdiff and allow these pairs.  Otherwise prevent wrapped
                // tick value pairs from being used in our calculations.
                if (fasttimermaxvalue) {
                    tickdiff+=fasttimermaxvalue;
                }
                else {
                    break;
                }
            }

            // At this point tickdiff MUST be >= 1.  If not, then something
            // is very wrong.  So punt completely.
            if (tickdiff<1) {
                Trap();
                return 0;
            }

            totaltickdiff+=tickdiff;

            lowerbound=(ULONG)(TimerRead[j].lastreadtimestamp-TimerRead[i].firstreadtimestamp)/(totaltickdiff+1);
            if (lowerbound>maxlowerbound) {
                maxlowerbound=lowerbound;
            }
            lowerboundtotal+=lowerbound;
            lowerboundcount++;

            if (totaltickdiff>1) {

                upperbound=(ULONG)(TimerRead[j].firstreadtimestamp-TimerRead[i].lastreadtimestamp)/(totaltickdiff-1);
                if (upperbound<minupperbound) {
                    minupperbound=upperbound;
                }
                upperboundtotal+=upperbound;
                upperboundcount++;

            }

        }

    }



    {
    static totalcount=0;
    totalcount++;

    }


    {
    if ((ULONG)abs((LONG)(minupperbound-maxlowerbound))*10>(maxlowerbound+minupperbound)/2) {
    	static badcount=0;
    	badcount++;
    	//Trap();
    	return 0;
    	}

    }

    if (maxlowerbound>minupperbound) {
        static invertedcount=0;
        invertedcount++;
        //Trap();
    }


    {

        static ULONG totalminupperbound=0;
        static ULONG countminupperbound=0;
        static ULONG minminupperbound=0xffffffff;
        static ULONG maxminupperbound=0;

        if (minupperbound<minminupperbound) {
            minminupperbound=minupperbound;
        }
        if (minupperbound>maxminupperbound) {
            maxminupperbound=minupperbound;
        }

        totalminupperbound+=minupperbound;
        countminupperbound++;

    }


    cyclespertick=(upperboundtotal/upperboundcount + lowerboundtotal/lowerboundcount)/2;

    cyclespertick=(maxlowerbound+minupperbound)/2;


    }

    // IDEA!  We can probably get a better estimate if we randomize the
    // time of our reads.  That will remove any relationship between the
    // time it takes to do an i/o read and the period of the timer tick
    // itself.


#if DEBUG
    // Log statistics.
    if (cyclespertick>maxcyclespertick) {
        maxcyclespertick=cyclespertick;
    }
    if (cyclespertick<mincyclespertick) {
        mincyclespertick=cyclespertick;
    }
#endif

    return cyclespertick;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\device.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    device.c

Abstract:

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




#define IRPMJFUNCDESC
#define WANTVXDWRAPS

#include "common.h"
#include "rtp.h"
#include "log.h"



#ifndef UNDER_NT

ULONG RT_Init_VxD(VOID);

#define STR_DEVICENAME	TEXT(L"\\Device\\Rt")
#define STR_REGISTRY	TEXT(L"\\REGISTRY\\Machine\\Software\\Microsoft\\RealTime")
#define STR_RTDISABLE   TEXT(L"DisableRtExecutive")

#else

//#define OFFBYDEFAULT 1

#define STR_DEVICENAME	TEXT("\\Device\\Rt")
#define STR_REGISTRY	TEXT("\\REGISTRY\\Machine\\Software\\Microsoft\\RealTime")
#define STR_RTDISABLE   TEXT("DisableRtExecutive")
#ifdef OFFBYDEFAULT
#define STR_RTENABLE   TEXT("EnableRtExecutive")
#endif

#endif

#define RT_LOG_SIZE 32 // This MUST be a power of 2.




#ifdef OFFBYDEFAULT
DWORD RtEnable=0;
#endif
DWORD RtDisable=0;

LONG RtInitialized=0;

PDEVICE_OBJECT pdo=NULL;

PRTLOGHEADER RtLog=NULL;




VOID
DriverUnload (
    IN PDRIVER_OBJECT DriverObject
    )
{

    Break();

}




NTSTATUS
RtpInitialize (
    VOID
    )

{

    RTL_QUERY_REGISTRY_TABLE QueryTable[] = {
            {
            NULL,   // No callback routine
            RTL_QUERY_REGISTRY_DIRECT,
            NULL,
            &RtDisable,
            REG_DWORD,
            &RtDisable,
            sizeof(RtDisable)
            },

#ifdef OFFBYDEFAULT
            {
            NULL,   // No callback routine
            RTL_QUERY_REGISTRY_DIRECT,
            NULL,
            &RtEnable,
            REG_DWORD,
            &RtEnable,
            sizeof(RtEnable)
            },
#endif

            {
            NULL,   // Null entry
            0,
            NULL,
            NULL,
            0,
            NULL,
            0
            }
        };
    UNICODE_STRING usRegistry;
    UNICODE_STRING usRtDisable;
#ifdef OFFBYDEFAULT
    UNICODE_STRING usRtEnable;
#endif
#ifdef UNDER_NT
    PHYSICAL_ADDRESS Physical;
#endif
    ULONG i;


    //Break();


    // Prepare to query the registry
    RtlInitUnicodeString( &usRegistry, STR_REGISTRY );
    RtlInitUnicodeString( &usRtDisable, STR_RTDISABLE );
#ifdef OFFBYDEFAULT
    RtlInitUnicodeString( &usRtEnable, STR_RTENABLE );
#endif

    QueryTable[0].Name = usRtDisable.Buffer;
#ifdef OFFBYDEFAULT
    QueryTable[1].Name = usRtEnable.Buffer;
#endif


    // Query registry to see if we should allow RT to run.
    RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE,
        usRegistry.Buffer,
        &(QueryTable[0]),
        NULL,
        NULL
        );

    // Now setup the realtime logging buffer.
#ifdef UNDER_NT
    Physical.QuadPart=-1I64;
    RtLog=(PRTLOGHEADER)MmAllocateContiguousMemory(PAGE_SIZE*(RT_LOG_SIZE+1), Physical);
#else
    RtLog=(PRTLOGHEADER)ExAllocatePool(NonPagedPool, PAGE_SIZE*(RT_LOG_SIZE+1));
#endif


    // Failing to allocate the RtLog is not fatal.  If we get it, set it up.
    if (RtLog) {

        RtLog->Buffer=(PCHAR)RtLog+PAGE_SIZE;

        // The output or print buffersize MUST be a power of 2.  This is because the read and write 
        // locations increment constantly and DO NOT WRAP with the buffer size.  That is intentional
        // because it makes checking whether there is data in the buffer or not very simple and atomic.
        // However, the read and write locations will wrap on 32 bit boundaries.  This is OK as long as
        // our buffersize divides into 2^32 evenly, which it always will if it is a power of 2.
        RtLog->BufferSize=PAGE_SIZE*RT_LOG_SIZE;

        RtLog->WriteLocation=0;


        // Mark every slot in the output buffer empty.

        for (i=0; i<RtLog->BufferSize; i+=RT_LOG_ENTRY_SIZE) {
            ((ULONG *)RtLog->Buffer)[i/sizeof(ULONG)]=NODATA;
            }

    }




#ifdef OFFBYDEFAULT
    if (RtEnable) {
#endif


    // Initialize if RT not disabled and we have not already initialized.
    if (!RtDisable && InterlockedIncrement(&RtInitialized)==1) {

#ifndef UNDER_NT
        RT_Init_VxD();
#endif

        SetupRealTimeThreads();

    }

#ifdef OFFBYDEFAULT
    }
#endif


    return STATUS_SUCCESS;

}




NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING usRegistryPathName
    )
{

    //dprintf(("DriverEntry Enter (DriverObject = %x)", DriverObject));

    DriverObject->DriverUnload = DriverUnload;

    // For now, keep RT loaded always.
    ObReferenceObject(DriverObject);


#if 0

    // We will need to create a device in order to be able to pull
    // RT statistics down into user mode.
    {

    UNICODE_STRING usDeviceName;

    RtlInitUnicodeString( &usDeviceName, STR_DEVICENAME );

    IoCreateDevice(DriverObject,0,&usDeviceName,0,0,FALSE,&pdo);

    }

#endif


    return RtpInitialize();


}




NTSTATUS
DllInitialize (
    IN PUNICODE_STRING RegistryPath
    )
{

#ifdef UNDER_NT


    // On NT, we do NOT load until someone linked to us loads.  That way
    // unless we are needed, we stay out of the way.


    return RtpInitialize();


#else

    // On Win9x because Rt hooks the IDT, it MUST be loaded at boot time.
    // This code is here to catch if we ever get loaded as a DLL which will only
    // happen if we did NOT get properly loaded at boot time.

    // In debug on Win9x, make SURE our failure to load properly at boot is noticed.

#if DEBUG

    KeBugCheckEx(0x1baddeed,0,0,0,0);

#endif // DEBUG

    // In retail on Win9x be as nice as possible.  None of our API's will succeed,
    // but we let people that are linked to us load without failing.

    return STATUS_SUCCESS;


#endif // UNDER_NT

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\apic.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    apic.c

Abstract:

    This module contains global variables and functions used to program the local APIC.
    The local APIC resides on the processor die of newer Intel and AMD processors.  It is
    used to control various interrupt sources both local and external to the processor.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




#include "common.h"
#include "apic.h"
#include "irq.h"
#include "msr.h"
#include "rtp.h"
#include "rt.h"
#include "x86.h"
#include "rtexcept.h"

#ifndef UNDER_NT
#include <vmm.h>
#endif


#pragma LOCKED_DATA

// These globals contain addresses pointing at various local APIC registers.
// They must be in locked memory as they will be used to program the local APIC
// while in interrupt service routines.

CHAR *ApicBase=NULL;
volatile ULONG *ApicPerfInterrupt=NULL;
volatile ULONG *ApicTimerInterrupt=NULL;
volatile ULONG *ApicNmiInterrupt=NULL;
volatile ULONG *ApicIntrInterrupt=NULL;


// WARNING!!!  Do NOT change the ApicTimerVector or ApicErrorVector default
// settings to a different define, without also updating HookWindowsInterrupts
// in rt.c!  Otherwise any local apic errors will jump to some unknown and
// incorrect interrupt handler instead of our own - since we will not have
// hooked the error vector IDT entry.
// Also make sure you also update rtexcept.c appropriately as well if any
// of the below variables are initialized with different defines.


ULONG ApicTimerVector=MASKABLEIDTINDEX;
ULONG ApicPerfVector=RTINTERRUPT;
ULONG ApicErrorVector=APICERRORIDTINDEX;
ULONG ApicSpuriousVector=APICSPURIOUSIDTINDEX;


extern ID OriginalApicSpuriousVector;



NTSTATUS
HookInterrupt (
    ULONG index,
    ID *originalvector,
    VOID (* handler)(VOID)
    );



#pragma PAGEABLE_DATA
#pragma PAGEABLE_CODE

#ifndef UNDER_NT
#pragma warning ( disable : 4035 )
#endif


PCHAR
MapPhysToLinear (
    VOID *physicaladdress,
    ULONG numbytes,
    ULONG flags
    )

/*++

Routine Description:

    This routine is a wrapper for OS functions that map physical memory to linear address
    space.  On Win9x it wraps MapPhysToLinear, on WinNT it wraps MmMapIoSpace.

Arguments:

    physicaladdress - Supplies the physical address to be mapped into linear address space.

    numbytes - Supplies the size of the block of physical memory to be mapped.

    flags - Supplies flags controlling the characteristics of the linear/virtual memory.

Return Value:

    Since this routine is really just a wrapper for OS functions on
    Win9x and WinNT, the return value differs depending on the OS.
    On both platforms if the mapping is successful, the return value is the linear
    address of the mapped physical address.
    On Win9x if the mapping fails, the function returns (-1).
    On WinNT if the mapping fails, the function returns NULL.
    Platform independent callers MUST check for returns of EITHER (-1) or NULL
    when checking for failure.

--*/

{

#ifdef UNDER_NT


    PHYSICAL_ADDRESS address;

    address.QuadPart=(ULONGLONG)physicaladdress;

    return MmMapIoSpace(address, numbytes, flags);


#else


    __asm push flags
    __asm push numbytes
    __asm push physicaladdress

    VMMCall( _MapPhysToLinear );

    __asm add esp,12


#endif

}


#ifndef UNDER_NT
#pragma warning ( default : 4035 )
#endif



BOOL
InitializeAPICBase (
    VOID
    )

/*++

Routine Description:

    If this routine has already run successfully, then it simply returns TRUE.
    If not, then it first reads the physical address that the local APIC
    is mapped to.  Then it maps that physical address to virtual memory
    and saves the virtual memory location in the global ApicBase.  If the
    mapping fails, then it returns FALSE, otherwise it loads globals that
    point to specific local APIC interrupt control registers and returns
    TRUE.

    WARNING:  Currently this routine ASSUMES processor support of the
    Intel local APIC mapping MSR.

Arguments:

    None.

Return Value:

    TRUE if local APIC already mapped, or if it is mapped successfully during the call.
    FALSE if mapping the local APIC fails.

--*/

{

    // If local APIC already mapped, simply return TRUE.

    if (ApicBase!=NULL && ApicBase!=(CHAR *)(-1)) {
        return TRUE;
    }

    // Read the local APIC physical location.
    // NOTE:  This next line assumes all machines this code runs on support the
    // local APIC mapping MSR that PII and newer Intel processors have.
    // Code that calls this function MUST properly screen for manufacturer,
    // processor family, and local apic support before calling this function.

    ApicBase=(CHAR *)(ReadIntelMSR(APICBASE)&~(0xfff));

    // Map the physical address to a virtual address.

    ApicBase=MapPhysToLinear(ApicBase, 4096, 0);

    // Return false if the mapping failed.

    if (ApicBase==(CHAR *)(-1) || ApicBase==NULL) {
        return FALSE;
    }

    // Mapping succeeded, so load global interrupt control register locations
    // and return TRUE.

    ApicPerfInterrupt=(ULONG *)(ApicBase+APICPERF);
    ApicTimerInterrupt=(ULONG *)(ApicBase+APICTIMER);
    ApicNmiInterrupt=(ULONG *)(ApicBase+APICNMI);
    ApicIntrInterrupt=(ULONG *)(ApicBase+APICINTR);

    return TRUE;

}



BOOL
MachineHasAPIC (
    VOID
    )

/*++

Routine Description:

    Check the processor manufacturer, family, and the local APIC feature bit, and
    then call InitializeAPICBase on supported processors.

Arguments:

    None.

Return Value:

    FALSE for unsupported processor manufacturers and families and for processors
    without the local APIC feature bit set.

    If the manufacturer and processor family are supported and the processor sets
    the local APIC feature bit, then we call InitializeAPICBase and return the
    value returned by that function.


--*/

{

    if (CPUManufacturer==INTEL && CPUFamily>=6 && (CPUFeatures&0x20)) {

        return InitializeAPICBase();

    }

    if (CPUManufacturer==AMD && CPUFamily>=6 && (CPUFeatures&0x20)) {

        return InitializeAPICBase();

    }


    return FALSE;

}



#pragma LOCKED_CODE
#pragma LOCKED_DATA



#if 0

__inline
VOID
GenerateLocalHardwareInterrupt (
    ULONG interrupt
    )

/*++

Routine Description:

    This routine can be used to generate what will appear to be a hardware interrupt.
    The local APIC is used to send the passed interrupt vector number to itself
    and will then handle the interrupt by invoking specified interrupt vector to
    handle the interrupt.  I do NOT know whether this will work at all.  It may or may not
    work with interrupt handlers that normally handle interrupts coming from an external
    IO APIC, and it may or may not work with interrupt handlers that normally handle
    interrupts coming through an external PIC.  It seemed like an idea with interesting 
    possibilities, so I wrote the code.  It is NOT currently used.  Note that for code
    already running in ring 0 on x86 processors, if you just want to run an arbitrary
    interrupt handler, it is much faster to just simulate the interrupt by running
    an __asm int x instruction.
    
    WARNING: This function does NOT currently wait until the interrupt is delivered
    before returning.

Arguments:

    interrupt - Contains the interrupt vector number of the interrupt to be simulated.

Return Value:

    None.
    
--*/

{

    // First write this machines local apic ID into the destination register of the ICR.
    // We must do this with interrupts disabled so that it is safe on NT multiproc
    // machines.  Otherwise we could read the APIC ID for one processor and be switched
    // out and load it into a different processors register.

    SaveAndDisableMaskableInterrupts();

    WriteAPIC(APICICRHIGH,ReadAPIC(APICID));

    WriteAPIC(APICICRLOW,ASSERTIRQ|interrupt);

    RestoreMaskableInterrupts();

}

#endif



BOOL
TurnOnLocalApic (
    VOID
    )

{

    if (!(CPUFeatures&0x20)) {
        return FALSE;
    }


    {
        ULONGLONG apicbaseaddress;

        // Make sure that APIC turned on by MSRs.
        apicbaseaddress=ReadIntelMSR(APICBASE);

        if (!(apicbaseaddress&0x800)) {  // Apic is turned off.

            // First disable all interrupts.
            SaveAndDisableMaskableInterrupts();

            // Try turning it back on.  Intel claims this doesn't work.  It does.
            apicbaseaddress|=0x800;
            WriteIntelMSR(APICBASE, apicbaseaddress);

            // The following code should only be run in the case when the local APIC was
            // not turned on and we then turned it on.

            // Now check if the local APIC is turned on.  If so, then set it up.

            if (ReadIntelMSR(APICBASE)&0x800) {

                // Local APIC is on.

                // Hook the APIC spurious interrupt vector if we have not hooked it before.
                if (*(PULONGLONG)&OriginalApicSpuriousVector==0 &&
                    HookInterrupt(ApicSpuriousVector, &OriginalApicSpuriousVector, RtpLocalApicSpuriousHandler)!=STATUS_SUCCESS) {
                    RestoreMaskableInterrupts();
                    return FALSE;
                }

                // Now enable the APIC itself.
                // This also loads the spurious interrupt vector.
                WriteAPIC(APICSPURIOUS,(ReadAPIC(APICSPURIOUS)&0xfffffc00)|0x100|APICSPURIOUSIDTINDEX);

                // Now setup INTR.
                // Unmasked, ExtINT.
                WriteAPIC(APICINTR,(ReadAPIC(APICINTR)&0xfffe58ff)|EXTINT);

                // Now setup NMI.
                // Masked, NMI.
                // Leave external NMI enabled.
                WriteAPIC(APICNMI,(ReadAPIC(APICNMI)&0xfffe58ff)|NMI);

                // Now reenable interrupts.
                RestoreMaskableInterrupts();

                return TRUE;

            }

            else {

                // Local APIC could not be turned on with the MSRs!
                // This WILL happen on some mobile parts.

                // Now reenable interrupts.
                RestoreMaskableInterrupts();

                dprintf(("RealTime Executive could not enable local APIC.  RT NOT RUNNING!"));

                return FALSE;

            }

        }
        else {  // Local APIC is already turned on!

            // This will happen for HALs that use the local APIC.  (mp, ACPI)
            // We should not touch the spurious, ExtINT, or NMI vectors in this case.

            // We do however read the settings out of the local APIC for the local timer
            // interrupt vector, and the performance counter interrupt vector.  That
            // way we use the same vectors as the HAL initially programmed.  (Except
            // that we do set the NMI flag in the performance counter interrupt, so
            // it actually uses interrupt vector 2.)

            ApicTimerVector=ReadAPIC(APICTIMER)&VECTORMASK;
#ifdef MASKABLEINTERRUPT
            ApicPerfVector=ReadAPIC(APICPERF)&VECTORMASK;
#else
            ApicPerfVector=NMI|(ReadAPIC(APICPERF)&VECTORMASK);
#endif

            // We also read the error and spurious vector locations since we need
            // them when setting up our private IDTs.
            
            ApicErrorVector=ReadAPIC(APICERROR)&VECTORMASK;
            ApicSpuriousVector=ReadAPIC(APICSPURIOUS)&VECTORMASK;

            // Make sure the vectors we just read are valid.  If not, then load them with
            // our defaults.  These vectors should never be invalid if the local APIC
            // was turned on.  The only way we will hit this case is if the BIOS turns
            // on the local APIC, but then a HAL without local apic support does not
            // turn OFF the local apic.

            if (!ApicTimerVector) {
                Trap();
                ApicTimerVector=MASKABLEIDTINDEX;
            }

            if (!ApicPerfVector) {
                Trap();
                ApicPerfVector=RTINTERRUPT;
            }

            if (!ApicErrorVector) {
                Trap();
                ApicErrorVector=APICERRORIDTINDEX;
            }

            if (!ApicSpuriousVector) {
                Trap();
                ApicSpuriousVector=APICSPURIOUSIDTINDEX;
            }

            return TRUE;

        }

    }

}



BOOL
EnableAPIC (
    VOID
    )

/*++

Routine Description:

    This routine will enable the local APIC on processors it knows are supported.
    We check if the processor manufacturer and family are supported.  If so we
    call TurnOnLocalApic to enable the local apic on the processor.


Arguments:

    None.

Return Value:

    FALSE if processor manufacturer and family are not explicitly supported.

    If the manufacturer and processor family are supported then we call
    TurnOnLocalApic and return the value returned by that function.

--*/

{


    // Is manufaturer supported?

    switch (CPUManufacturer) {

        case INTEL:

            // Check the processor family code for Intel.

            switch (CPUFamily) {

                case 6:     // PII, PIII, Celeron
                case 0xf:   // P4

                    return TurnOnLocalApic();

                    break;

                default:

                    break;

            }

            break;

        case AMD:

            // Check the processor family code for AMD.

            switch (CPUFamily) {

                case 6:     // Athlon, Duron

                    return TurnOnLocalApic();

                    break;

                default:

                    break;

            }

            break;

        default:

            break;

    }

    return FALSE;

}


#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\msr.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation.  All Rights Reserved.


Module Name:

    msr.c

Abstract:

    This module contains global variables used to access x86 processor model specific registers
    related to performance counters, as well as a function for writing to x86 model specific registers.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/


#include "common.h"
#include "msr.h"



#pragma LOCKED_DATA

// These variables are used when programming performance counter MSRs.
// The default values are for Intel PII/PIII/Celeron processors.

ULONG PerformanceCounter0=INTELPERFORMANCECOUNTER0;
ULONG PerformanceCounter1=INTELPERFORMANCECOUNTER1;
ULONG EventSelect0=INTELEVENTSELECT0;
ULONG EventSelect1=INTELEVENTSELECT1;
ULONGLONG PerformanceCounterMask=INTELPERFCOUNTMASK;
ULONG StopCounter=PERFCOUNTERENABLED;
ULONG StartCycleCounter=STARTPERFCOUNTERS|INTELCOUNTCYCLES;
ULONG StartInstructionCounter=STARTPERFCOUNTERS|INTELCOUNTINSTRUCTIONS;
ULONG StartInterruptsDisabledCounter=STARTPERFCOUNTERS|INTELINTSDISABLEDWHILEPENDING;
ULONG EnablePerfCounters=0;

#pragma PAGEABLE_DATA



#pragma LOCKED_CODE

// We disable stack frames so that our direct accessing of parameters based
// off of the stack pointer works properly.
#pragma optimize("y", on)

VOID
__fastcall
WriteIntelMSR (
    ULONG index,
    ULONGLONG value
    )

/*++

Routine Description:

    Writes the 64 bit data in value to the processor model specific register selected
    by index.

Arguments:

    index - Supplies the index of the model specific register (MSR) to be written.
            Note that writing to an unsupported MSR will cause a GP (general protection)
            fault.

    value - Supplies the 64 bit data to write into the specified MSR.

Return Value:

    None.

--*/

{

    __asm {
        mov eax, [esp + 0x4]
        mov edx, [esp + 0x8]
        wrmsr
        }

}

#pragma optimize("", on)

#pragma PAGEABLE_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\irq.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    irq.h

Abstract:

    This module contains defines, global variables, and macros used to enable and disable
    processor maskable interrupts as well as the processor performance counter interrupt.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/


extern ULONG PerformanceInterruptState;

#define MASKPERF0INT 1


#define SaveAndDisableMaskableInterrupts() 		\
__asm 				\
	{				\
	__asm pushfd	\
	__asm cli		\
	}



#define RestoreMaskableInterrupts()			\
__asm				\
	{				\
	__asm popfd		\
	}


VOID __inline SaveAndDisablePerformanceCounterInterrupt(ULONG *pOldState)
{
__asm {
	__asm or PerformanceInterruptState, MASKPERF0INT
	__asm mov eax, ApicPerfInterrupt
	__asm mov ecx, dword ptr[eax]
	__asm or dword ptr[eax], MASKED
	__asm mov eax, pOldState
	__asm mov dword ptr[eax], ecx
	}
}


#define DisablePerformanceCounterInterrupt()	\
__asm 				\
	{				\
	__asm or PerformanceInterruptState, MASKPERF0INT	\
	__asm mov eax, ApicPerfInterrupt	\
	__asm or dword ptr[eax], MASKED 	\
	}



#define RestorePerformanceCounterInterrupt(OldState)			\
__asm							\
	{							\
	__asm mov ecx, OldState		\
	__asm mov eax, ApicPerfInterrupt	\
	__asm test ecx, MASKED		\
	__asm jz unmask				\
	__asm or PerformanceInterruptState, MASKPERF0INT		\
	__asm jmp sethardware		\
	__asm unmask:				\
	__asm and PerformanceInterruptState, ~(MASKPERF0INT)	\
	__asm sethardware:			\
	__asm mov dword ptr[eax], ecx		\
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\msr.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation.  All Rights Reserved.


Module Name:

    msr.h

Abstract:

    This module contains private x86 processor model specific register defines, variables, inline
    functions and prototypes.  The model specific registers supported are those related to
    the processor performance counters and local apic for Intel PII/PIII, AMD K7, and Intel P4
    processors.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/



// Model Specific Register locations


// This is the offset for the MSR which can be used to program the local APIC
// base address, as well as for turning the local APIC on and off.

#define APICBASE 0x1b




// Performance counter Model Specific Register offsets (for the Intel Pentium II/III)

#define INTELPERFORMANCECOUNTER0 0xc1
#define INTELPERFORMANCECOUNTER1 0xc2

#define INTELEVENTSELECT0 0x186
#define INTELEVENTSELECT1 0x187

// This is a bit mask which defines which bits can actually be read from
// the performance counters.  For Intel that is the bottom 40 bits.
#define INTELPERFCOUNTMASK 0x000000ffffffffff

// These are event codes used to make the performance counters count cycles
// and instructions on Intel PII/PIII processors.
#define INTELCOUNTCYCLES 0x79
#define INTELCOUNTINSTRUCTIONS 0xc0
#define INTELINTSDISABLED 0xc6
#define INTELINTSDISABLEDWHILEPENDING 0xc7

// These are values used to start and stop the Intel PII/PIII performance counters.
// Note that we leave performance counter 1 enabled for counting on Intel
// PII/PIII processors.
#define STARTPERFCOUNTERS 0x00570000
#define PERFCOUNTERENABLED 0x00400000




// Performance counter Model Specific Register offsets for the Intel P4 Processor.
// Note that this is NOT all of the locations, just those for the first 2 counters.
// There are other additional counters but their locations are not yet defined here.
// The structure and programming of the perf counters on the P4 is quite different
// from earlier Intel processors.

#define WILLAMETTEPERFCOUNTER0 0x300
#define WILLAMETTEPERFCOUNTER1 0x301

#define WILLAMETTEESCR0 0x3c8
#define WILLAMETTEESCR1 0x3c9

#define WILLAMETTECCR0 0x360
#define WILLAMETTECCR1 0x361

// These are event codes used to make the performance counters count cycles
// and instructions on Intel P4 processors.
#define WILLAMETTECOUNTCYCLES 0x04ffa000
#define WILLAMETTECOUNTINSTRUCTIONS 0xc0

// These are values used to start and stop the P4 performance counters.
#define WILLAMETTESTOPPERFCOUNTER 0x80000000
#define WILLAMETTESTARTPERFCOUNTERS 0x00001000




// Performance counter Model Specific Register offsets (for the AMD K7)
// AMD supports 4 different performance counters.  All of the MSR locations
// are defined here.

#define AMDPERFORMANCECOUNTER0 0xc0010004
#define AMDPERFORMANCECOUNTER1 0xc0010005
#define AMDPERFORMANCECOUNTER2 0xc0010006
#define AMDPERFORMANCECOUNTER3 0xc0010007

#define AMDEVENTSELECT0 0xc0010000
#define AMDEVENTSELECT1 0xc0010001
#define AMDEVENTSELECT2 0xc0010002
#define AMDEVENTSELECT3 0xc0010003

// This is a bit mask which defines which bits can actually be read from
// the performance counters.  For AMD that is the bottom 48 bits.
#define AMDPERFCOUNTMASK 0x0000ffffffffffff

// These are event codes used to make the performance counters count cycles
// and instructions on AMD processors.
#define AMDCOUNTCYCLES 0x76
#define AMDCOUNTINSTRUCTIONS 0xc0
#define AMDINTSDISABLED 0xc6
#define AMDINTSDISABLEDWHILEPENDING 0xc7

// These are values used to start and stop the AMD K7 performance counters.
#define AMDSTOPPERFCOUNTER 0
#define AMDSTARTPERFCOUNTERS 0x00530000




// The following defines have been mapped to variables, so that we can properly support
// the different processors.  The above MSR defined locations and programming values
// are loaded into these variables at initialization according to the processor
// type, and these defines are used from then on for programming the MSRs.

#define PERFORMANCECOUNTER0 PerformanceCounter0
#define PERFORMANCECOUNTER1 PerformanceCounter1
#define EVENTSELECT0 EventSelect0
#define EVENTSELECT1 EventSelect1
#define PERFCOUNTMASK PerformanceCounterMask
#define STOPPERFCOUNTERS StopCounter


// Define inline assembly sequences that map to instruction opcodes the inline
// assembler does not know about.

#define rdmsr __asm _emit 0x0f __asm _emit 0x32
#define wrmsr __asm _emit 0x0f __asm _emit 0x30
#define rdprf __asm _emit 0x0f __asm _emit 0x33



// Global variables used to support MSRs on different processor types.
// These variables are loaded at initialization with values appropriate for
// the processor the code is running on.

extern ULONG PerformanceCounter0;
extern ULONG PerformanceCounter1;
extern ULONG EventSelect0;
extern ULONG EventSelect1;
extern ULONGLONG PerformanceCounterMask;
extern ULONG StopCounter;
extern ULONG StartCycleCounter;
extern ULONG StartInstructionCounter;
extern ULONG StartInterruptsDisabledCounter;
extern ULONG EnablePerfCounters;



// Function prototype for writing model specific registers.

VOID
__fastcall
WriteIntelMSR (
    ULONG index,
    ULONGLONG value
    );



#pragma LOCKED_CODE

#pragma warning ( disable : 4035 )



// __inline
// ULONGLONG
// ReadIntelMSR (
//     ULONG index
//     )
//
//*++
//
// Function Description:
//
//      Reads processor model specific register (MSR) indicated by index, and returns the 64 bit
//      result.
//
// Arguments:
//
//      index - Supplies an index which indicates which processor Model Specific Register (MSR)
//              should be read.  Attempting to read an unsupported register location will result
//              in a general protection (GP) fault.
//
// Return Value:
//
//      64 bit contents of selected model specific register.
//
//*--

__inline
ULONGLONG
ReadIntelMSR (
    ULONG index
    )
{

    __asm {
        mov ecx,index
        rdmsr
        }

}


// __inline
// ULONGLONG
// ReadPerformanceCounter (
//     ULONG index
//     )
//
//*++
//
// Function Description:
//
//      Reads processor performance counter indicated by index, and returns the 64 bit
//      result.
//
// Arguments:
//
//      index - Supplies a zero based index which indicates which processor performance
//              counter should be read.  For PII/PIII processors this index can be 0 or 1.
//              For AMD K7 processors this index can be 0 - 3.
//
// Return Value:
//
//      64 bit contents of selected performance counter.
//
//*--

__inline
ULONGLONG
ReadPerformanceCounter (
    ULONG index
    )
{

    __asm {
        mov ecx,index
        rdprf
        }

}


#pragma warning ( default : 4035 )

#pragma PAGEABLE_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\rtexcept.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    rtexcept.c

Abstract:

    This module contains the realtime executive exception handlers.  It also
    has the code for setting up the 2 realtime executive IDTs:  one for the
    realtime executive thread switcher, and one for the realtime threads
    themselves.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




// This file contains the real time executive exception handlers.

// These exception handlers are used to build a separate real time IDT that is
// loaded whenever we switch into the real time executive.  This real time IDT is
// kept loaded while any real time thread is running.  We switch back to the Windows
// IDT when the real time executive transfers control back to Windows.


// It is very important that we do NOT allow the standard Windows exception handlers
// to fire while we are running real time threads.  It makes Windows get very confused
// and the system will eventually crash.


// The first thing we do in all of these execption handlers is to disable the
// interrupt that drives the real time scheduler.

// Then we break into the debugger - since currently it is an error to cause any
// exception to fire while running in a real time thread.

// After we get control back from the debugger, we kill the real time thread that
// caused the exception.


// Since I switch the IDT AFTER I load in a valid DS, I should be able to turn off
// the scheduler interrupt in 1 instruction.  I assume that DS is valid.

// In order to be able to turn off the scheduler in 1 instruction, I will need to
// map the APIC to memory where the real time executive is loaded.  This will
// allow me to get around the x86 instruction set limits - which do not support
// indirect memory addressing.

// Currently that is not being done, so it takes 3 instructions to get the interrupt
// disabled instead of 1.

// Note that since loading the processor IDT register is a READ from memory, if
// I do not have to save the IDT first, then I can make it the VERY first thing
// that happens in the real time executive SwitchRealTimeThreads interrupt handler.

// That would be cool.

// It would be nice if the processor automatically pushed the old IDT settings into
// an internal register, and there was an instruction for poping it back out - as well
// as a flag that you could read if 2 pushes occur without a pop - and blow away
// one of the stored IDTs.


// One very cool thing is that I figured out that we can switch the IDT as the
// FIRST instruction of our real time interrupt handler - and we can restore it
// as the LAST instruction of our real time interrupt handler.  This is possible
// as long as other people are NOT switching the IDT - so that the IDT that we
// reload for Windows is correct.  If other people are switching the Windows IDT,
// then that will NOT work, since we will have to save the current IDT first before
// we load the new one and that would involve getting a valid segment register loaded
// that we can write into memory with.


// However, I now have the realtime executive saving eax on the stack in
// order to get working space rather than sticking it in DR0 or CR2.
// That is much faster and safer, and it seems to work just fine - as
// it should.

// Since I CAN use the stack to save state, I may be able to save the
// IDT directly on the stack at the start of the real time executive
// interrupt, and then load the new one as the second instruction.

// This means we will have to burn 16 cycles on every thread switch
// saving and loading the IDT (assuming that we also have a separate
// IDT for the real time executive itself).  Which I think is probably
// a good idea.  4 cycles to save the initial IDT, 6 cycles to load
// the rt exec IDT, and 6 cycles to load the final IDT for the thread
// being switched to.


#include "common.h"
#include "rtp.h"
#include "x86.h"
#include "rtexcept.h"
#include "apic.h"
#include "irq.h"


#define MAX_DEFAULT_HANDLERS 20


#pragma LOCKED_CODE
#pragma LOCKED_DATA

#ifdef MASKABLEINTERRUPT
extern ULONG InjectWindowsInterrupt;
extern SPTR HandleWindowsInterrupt;
#endif

#ifdef DEBUG
ULONG HitInt3InRtThread=0;
#endif

#ifdef RAISE_DEBUGGER_IRQL
ULONG DebuggerSavedIrql=0;
#endif

// This is a collection of the entry point addresses of the handlers.
// It makes the IDT initialization simpler.

VOID (* RtExceptionHandlers[MAX_DEFAULT_HANDLERS])(VOID)={
	DivideByZero,		// 0x0
	DebugExceptions,
	RtExecPerfCounterNMI,
	RtExecBreakPoint,
	Overflow,
	BoundsCheck,
	InvalidOpcode,
	DeviceNotAvailable,
	DoubleFault,
	IntelReserved,
	InvalidTSS,
	SegmentNotPresent,
	StackException,
	GeneralProtection,
	PageFault,
	IntelReserved,
	FloatingPointError,	// 0x10
	AlignmentCheck,
	MachineCheck,
	IntelReserved
	};


// This is the real time executive IDT itself.  Note that Intel suggests that it is
// a good idea to make sure that the IDT does NOT cross a page boundary.

// TODO: Ensure RtThreadID and RtExecID do NOT cross a page boundary.

ID RtThreadID[RTTHREADLARGEIDTSIZE];
ID RtExecID[RTEXECIDTSIZE];


TSS RtTss={0};

ULONG TssStack[512];


// These hold the processor IDT register data for the rt exec and Windows.  These
// are used to switch the IDTs.

IDT WindowsIDT;
IDT RtExecIDT;
IDT RtThreadIDT;
IDT DebugIDT;	// This is the IDT that will be restored by RT exception handlers.
IDT NextIDT;

// These are for debug purposes - to see if either the Windows or RT exec IDT
// addresses change over time.  The RT exec IDT should NEVER change.  I expect
// the Windows NT IDT to never change.  The Win9x IDT may change since who knows
// what the 3rd party VxD code does.

// Note that for Windows NT if the IDT never changes we could optimize out the
// saving of the current IDT and simply load the RT idt.  That would allow us to
// do that as the very first thing in the interrupt handler.

// Doing that would also allow us to detect if SoftICE is trapping debug register
// accesses.  I expect that it is.

#ifdef DEBUG
IDT LastWindowsIDT;
IDT LastRtThreadIDT;
#endif



VOID
RtpSetupTss (
    VOID
    )
{

    RtTss.link=0;
    RtTss.esp0=(ULONG)(TssStack+sizeof(TssStack)/sizeof(ULONG)-1);
    RtTss.ss0=RealTimeSS;
    RtTss.cr3=ReadCR3();
    RtTss.eip=(ULONG)DoubleFault;
    RtTss.eflags=0;
    RtTss.esp=(ULONG)(TssStack+sizeof(TssStack)/sizeof(ULONG)-1);
    RtTss.es=RealTimeDS;
    RtTss.cs=RtExecCS;
    RtTss.ss=RealTimeSS;
    RtTss.ds=RealTimeDS;
    RtTss.ldt=0;
    RtTss.t=0;
    RtTss.iomap=0x80;	// Past end of TSS segment.  All I/O causes exceptions.

}



VOID
RtpBuildIdt (
    ID *Id,
    ULONG Size
    )
{

    ULONG i,j;

    // Now build our IDT.

    j=0;

    for (i=0; i<Size; i++) {

#ifdef GUARD_PAGE
        if (i!=DOUBLEFAULTIDTINDEX) {
#endif
            Id[i].lowoffset=(WORD)RtExceptionHandlers[j];
            Id[i].selector=RtExecCS;
            Id[i].flags=0x8e00;
            Id[i].highoffset=(WORD)((DWORD)RtExceptionHandlers[j]>>16);
#ifdef GUARD_PAGE
        }
        else {
            Id[i].lowoffset=0;
            Id[i].selector=RtExecTSS;
            Id[i].flags=0x8500;
            Id[i].highoffset=0;
        }
#endif

        if (j<MAX_DEFAULT_HANDLERS-1) {
            j++;
        }

    }

}



VOID
RtpReplaceDefaultIdtHandler (
    ID *Id,
    ULONG Size,
    VOID (* ExceptionHandler)(VOID),
    ULONG Location
    )
{

    ASSERT (Location < Size);
    ASSERT (Location != DOUBLEFAULTIDTINDEX);

    Id[Location].lowoffset=(WORD)ExceptionHandler;
    Id[Location].selector=RtExecCS;
    Id[Location].flags=0x8e00;
    Id[Location].highoffset=(WORD)((DWORD)ExceptionHandler>>16);

}



VOID
RtpSetupIdtSwitch (
    ULONG TimerVector,
    ULONG PerfVector,
    ULONG ErrorVector,
    ULONG SpuriousVector
    )
{

    ULONG RtThreadIdtSize=RTTHREADSMALLIDTSIZE;

    if (TimerVector!=MASKABLEIDTINDEX ||
        PerfVector!=RTINTERRUPT ||
        ErrorVector!=APICERRORIDTINDEX ||
        SpuriousVector!=APICSPURIOUSIDTINDEX) {

        // We are not using the default vector locations for the local APIC interrupt
        // sources.  This is because the HAL supports the local APIC and has already
        // set it up, so use a full IDT rather than a small one.  That way we will
        // be able to use the same perf and timer vector locations as the ones the
        // HAL has set up.

        RtThreadIdtSize=RTTHREADLARGEIDTSIZE;

    }


    SaveIDT(WindowsIDT);


    RtpSetupTss();


    // We build the rt executive IDT without the SwitchRealTimeThreads vector
    // in it.  That way we can catch whenever we get an interrupt that would
    // reenter SwitchRealTimeThreads.

    RtpBuildIdt(RtExecID, RTEXECIDTSIZE);

#ifdef NONMI
    RtpReplaceDefaultIdtHandler(RtExecID, RTEXECIDTSIZE, JumpToWindowsNmiHandler, NMIIDTINDEX);
#endif

#ifdef DEBUG
    //RtpReplaceDefaultIdtHandler(RtExecID, RTEXECIDTSIZE, RtThreadBreakPoint, BREAKPOINTIDTINDEX);
#endif


    // Now build the realtime thread IDT.  This is the IDT that is loaded while
    // any realtime thread is running.

    RtpBuildIdt(RtThreadID, RtThreadIdtSize);

    // Replace default vectors with those we need to enable the realtime threads to
    // be switched properly.

#ifndef NONMI
    RtpReplaceDefaultIdtHandler(RtThreadID, RtThreadIdtSize, RtThreadPerfCounterNMI, NMIIDTINDEX);
#endif

    RtpReplaceDefaultIdtHandler(RtThreadID, RtThreadIdtSize, RtThreadBreakPoint, BREAKPOINTIDTINDEX);

#ifdef MASKABLEINTERRUPT
    RtpReplaceDefaultIdtHandler(RtThreadID, RtThreadIdtSize, SwitchRealTimeThreads, PerfVector);
#endif

    RtpReplaceDefaultIdtHandler(RtThreadID, RtThreadIdtSize, SwitchRealTimeThreads, TimerVector);

    RtpReplaceDefaultIdtHandler(RtThreadID, RtThreadIdtSize, RtpLocalApicErrorHandler, ErrorVector);

    RtpReplaceDefaultIdtHandler(RtThreadID, RtThreadIdtSize, RtpLocalApicSpuriousHandler, SpuriousVector);


    RtThreadIDT.base=(DWORD)RtThreadID;
    RtThreadIDT.limit=(WORD)(8*RtThreadIdtSize-1);

    RtExecIDT.base=(DWORD)RtExecID;
    RtExecIDT.limit=8*RTEXECIDTSIZE-1;

    DebugIDT=RtExecIDT;

#ifdef DEBUG

    //RtExecIDT=WindowsIDT;

    LastWindowsIDT=WindowsIDT;
    LastRtThreadIDT=RtThreadIDT;

#endif

}


// For now we force the debug code in the exception handlers to execute and
// we force the breakpoint to hit.

#ifndef DEBUG
#define DEBUG 1
#else
#define OLDDEBUG DEBUG
#endif


// Here are the exception handlers.


#ifdef NONMI

VOID __declspec(naked) JumpToWindowsNmiHandler(VOID)
{

// For now I do not mask the ApicIntrInterrupt - since it should ALWAYS be
// masked when we hit this anyway.  Since we will only hit these after
// switching IDTs.

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

LoadIDT(WindowsIDT);

// Now we jump to the NMI handler in the Windows IDT.

__asm {

	// Save space for address of windows NMI (int 2) handler.
	sub esp,8

	// Get working space in registers
	push eax
	push ecx

	mov ecx, WindowsIDT.base

	// ecx now has base address of the windows idt

	mov eax, [ecx+NMIIDTINDEX*8]
	shr eax, 16
	mov dword ptr[esp+12], eax

	// Now the selector for the windows NMI handler is on the stack

	mov eax, [ecx+NMIIDTINDEX*8+4]
	mov ax, [ecx+NMIIDTINDEX*8]

	// eax now has offset of windows NMI handler

	mov dword ptr[esp+8], eax

	// stack now setup for far return to the windows NMI handler

	// restore our registers
	pop ecx
	pop eax

	retf
}

}

#endif


VOID __declspec(naked) DoWindowsNmi(VOID)
{

__asm push eax;

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

LoadIDT(WindowsIDT);

// Now we jump to the NMI handler in the Windows IDT.

__asm {

	// Save space for address of windows NMI (int 2) handler.
	sub esp,8

	// Get working space in registers
	push eax
	push ecx

	mov ecx, WindowsIDT.base

	// ecx now has base address of the windows idt

	mov eax, [ecx+NMIIDTINDEX*8]
	shr eax, 16
	mov dword ptr[esp+12], eax

	// Now the selector for the windows NMI handler is on the stack

	mov eax, [ecx+NMIIDTINDEX*8+4]
	mov ax, [ecx+NMIIDTINDEX*8]

	// eax now has offset of windows NMI handler

	mov dword ptr[esp+8], eax

	// stack now setup for far return to the windows NMI handler

	// restore our registers
	pop ecx
	pop eax

	retf
}

}


#pragma warning(disable: 4414)

VOID __declspec(naked) RtThreadPerfCounterNMI(VOID)
{

__asm {

	// First check if we have masked the performance counter interrupt.
	// If not, then jump to switchrealtimethreads.
	test cs:PerformanceInterruptState, MASKPERF0INT
	jz SwitchRealTimeThreads

	// Otherwise, the performance counter interrupt is masked.  Eat it.

	}

Return();

}


VOID __declspec(naked) RtExecPerfCounterNMI(VOID)
{

__asm {

	// First check if we have masked the performance counter interrupt.
	// If not, then jump to switchrealtimethreads.
	test cs:PerformanceInterruptState, MASKPERF0INT
	jz IntelReserved

	// Otherwise, the performance counter interrupt is masked.  Eat it.

	}

Return();

}

#pragma warning(default: 4414)


VOID __declspec(naked) DivideByZero(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}


// When this hits, we switch IDT's back to the WindowsIDT and then break
// into the debugger.  Note this should catch if Winice is trapping my
// use of the debug register to hold EAX.  (It is NOT.)


VOID __declspec(naked) DebugExceptions(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

LoadIDT(WindowsIDT);

Break();

Return();

}



VOID __declspec(naked) RtExecBreakPoint(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

#ifdef RAISE_DEBUGGER_IRQL

// Now save current IRQL setting, and set IRQL to HIGH_LEVEL.
// This is so we will work with the NT debugger - which pays attention to
// IRQL levels.  If we don't do this, then we reboot on NT when we try to
// go after hitting a breakpoint inside the realtime executive.

__asm push ecx
__asm mov eax,pCurrentIrql
__asm mov cl, 0x1f
__asm xchg cl, byte ptr[eax]
__asm mov byte ptr[DebuggerSavedIrql],cl
__asm pop ecx

#endif

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

#ifdef RAISE_DEBUGGER_IRQL

// Restore IRQL BEFORE we load our IDT.  This is so we can never
// overwrite the DebuggerSavedIrql before we have restored it.

__asm push eax
__asm push ecx
__asm mov eax,pCurrentIrql
__asm mov cl, byte ptr[DebuggerSavedIrql]
__asm mov DebuggerSavedIrql, 0
__asm mov byte ptr[eax], cl
__asm pop ecx
__asm pop eax

#endif

// Restore the appropriate IDT.

LoadIDT(DebugIDT);

#endif

Return();

}



// When this hits, we switch IDT's back to the WindowsIDT and then break
// into the debugger.

// Note that this will obviate the need for an RtTrap instruction.  Since it will
// make normal breakpoints work properly automatically.  Well it will make them
// work like RtTrap currently does - as long as we do NOT switch back the IDT
// before returning to the thread.  As long as we handle the case when the
// real time thread yields control to the rt executive and the IDT is NOT the
// real time IDT and we don't break because of that we will be OK.

// At the end of this routine, we switch back to the current IDT.

// WARNING:  We may need to change the limit on windows flat CS selector so that
// we do NOT get gp faults in it when we are stepping through the
// realtime code.  Especially since we will be back in the windows IDT.

VOID __declspec(naked) RtThreadBreakPoint(VOID)
{

// For now I do not mask the ApicIntrInterrupt - since it should ALWAYS be
// masked when we hit this anyway.  Since we will only hit these after
// switching IDTs.

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

LoadIDT(WindowsIDT);

// Now we jump to the int3 handler in the debugger.

__asm {

	// But first we clear the IF flag on our stack - so that interrupts are
	// disabled.  This means the only way we will switch out of the
	// realtime thread - if we break into it, is to RtYield.  If the thread
	// never RtYields, or blocks on a spinlock, or releases a spinlock
	// blocking another thread, then we will be stuck in that thread forever.

	and dword ptr[esp+8], ~(IF)

#ifdef OLDDEBUG
	// Keep debug check for interrupts enabled from hitting since we just
	// turned them off ourselves intentionally.
	inc HitInt3InRtThread
#endif

	// Save space for address of windows int3 handler.
	sub esp,8

	// Get working space in registers
	push eax
	push ecx

	mov ecx, WindowsIDT.base

	// ecx now has base address of the windows idt

	mov eax, [ecx+3*8]
	shr eax, 16
	mov dword ptr[esp+12], eax

	// Now the selector for the windows int 3 handler is on the stack

	mov eax, [ecx+3*8+4]
	mov ax, [ecx+3*8]

	// eax now has offset of windows int 3 handler

	mov dword ptr[esp+8], eax

	// stack now setup for far return to the windows int 3 handler

	// restore our registers
	pop ecx
	pop eax

	retf
}

}


VOID __declspec(naked) Overflow(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}


VOID __declspec(naked) BoundsCheck(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}


VOID __declspec(naked) InvalidOpcode(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}


VOID __declspec(naked) DeviceNotAvailable(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}


VOID __declspec(naked) DoubleFault(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}


VOID __declspec(naked) IntelReserved(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}


VOID __declspec(naked) InvalidTSS(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}


VOID __declspec(naked) SegmentNotPresent(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}


VOID __declspec(naked) StackException(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}


VOID __declspec(naked) GeneralProtection(VOID)
{


#ifdef MASKABLEINTERRUPT

// Unfortunately when we are using a maskable interrupt to take control from
// windows, we can get PIC interrupts queued up in the cpu between the time
// that we enter our switchrealtimethreads handler, and the time that we
// mask the interrupt at the local apic itself.

__asm {
	test dword ptr[esp],1
	jz catchthis
	test dword ptr[esp],2
	jz catchthis

	// If we get here, then this is an interrupt that got logged into the
	// processor from the pic, between the time that interrupts were disabled
	// by entering switchrealtimethreads, and the time that we masked
	// external interrupts at the local apic.

	// We need to save the error code - since it has the vector information
	// of the interrupt that we need to call when we return back to
	// windows.  We also need to make sure that there isn't already an error
	// code logged.  If there is, that is a fatal error, since we don't
	// currently support logging of multiple interrupts that we call when
	// we finally get back to windows.  We only support saving 1.

	// Trap if there is already an interrupt logged.
	test InjectWindowsInterrupt, 0xffffffff
	jnz catchthis	// Taking this route is a FATAL ERROR.

	// Now, build the address of the windows interrupt handler for the
	// interrupt that we just got.  Jam it into InjectWindowsInterrupt.
	push eax
	push ecx
	push edx

	// we now have registers we can use

	mov edx,[esp+12]
	and edx, 0xfffffff8

	// edx now has the selector index into the windows idt

	mov ecx, WindowsIDT.base

	// ecx now has base address of the windows idt

	mov eax, [ecx+edx]
	shr eax, 16
	mov HandleWindowsInterrupt.selector, ax

	// Now the selector is correct for the windows interrupt handler.


	mov eax, [ecx+edx+4]
	mov ax, [ecx+edx]

	// eax now has address of interrupt handler we need to call when we
	// eventually return to windows

	mov InjectWindowsInterrupt, eax

	pop edx
	pop ecx
	pop eax

	// we have handled this nasty problem and are ready to rock
	// exit this handler without stopping

	jmp exit

catchthis:
	}

#endif


__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

#ifdef MASKABLEINTERRUPT
exit:
#endif

// Clean the error code off of the stack before returning.

__asm add esp,4

Return();

}


VOID __declspec(naked) PageFault(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

// Now clean the error code off of the stack before returning.

__asm add esp,4

Return();

}


VOID __declspec(naked) FloatingPointError(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}


VOID __declspec(naked) AlignmentCheck(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}


VOID __declspec(naked) MachineCheck(VOID)
{

__asm push eax;

DisablePerformanceCounterInterrupt();

__asm mov eax, ApicTimerInterrupt
__asm or dword ptr[eax], MASKED

__asm mov eax, cr0
__asm and eax, ~(FPUEMULATION)
__asm mov cr0, eax

__asm pop eax;

#ifdef DEBUG

LoadIDT(WindowsIDT);

Break();

LoadIDT(DebugIDT);

#endif

Return();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\rtexcept.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    rtexcept.h

Abstract:

    This header contains defines, globals, and function prototypes related to
    the realtime executive interrupt descriptor tables and exception handlers.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




// This is the number of entries in the real time executive
// interrupt descriptor table (IDT) as well as the number of entries
// in the realtime thread IDT.

// The realtime executive IDT is loaded while the realtime executive is
// switching threads.  The realtime thread IDT is loaded whenever a
// non windows realtime thread is running.

#define RTEXECIDTSIZE 0x20
#define RTTHREADSMALLIDTSIZE 0x50
#define RTTHREADLARGEIDTSIZE 0x100


// Here are the locations of a couple of individual IDT entries.

#define BREAKPOINTIDTINDEX 3
#define DOUBLEFAULTIDTINDEX 8




// Global variables that hold various IDT locations.  Used for switching
// between the various IDTs.

// This is used to save the location/size of the current IDT when we leave Windows.
extern IDT WindowsIDT;

// This holds the location/size of the IDT that is loaded while running the 
// realtime executive thread switching code.
extern IDT RtExecIDT;

// This holds the location/size of the IDT that is loaded while running non
// Windows realtime threads.
extern IDT RtThreadIDT;

// This holds the location/size of the IDT that is loaded just before the realtime
// executive thread switcher returns control to whatever thread it is
// switching to - realtime or Windows.  If we are returning to Windows, then
// this variable is loaded with the contents of WindowsIDT.  If we are switching
// to a realtime thread, then this variable is loaded with the contents of
// RtThreadIDT.
extern IDT NextIDT;

extern IDT DebugIDT;



#ifdef DEBUG

// These are for debug purposes - to see if either the Windows or RT exec IDT
// addresses change over time.  The RT exec IDT should NEVER change.  I expect
// the Windows NT IDT to never change.  The Win9x IDT may change since who knows
// what 3rd party VxD code does.

// Note that for Windows NT if the IDT never changes we could optimize out the
// saving of the current IDT and simply load the RT idt.  That would save a few
// cycles and allow us to do the IDT load as the very first thing in the realtime
// thread switcher.

// HOWEVER, these gains are NOT worth the risk of breaking if the Windows NT IDT
// ever starts changing.  For now we always save and restore the IDT whenever we
// leave and return to Windows.

extern IDT LastWindowsIDT;
extern IDT LastRtThreadIDT;


extern ULONG HitInt3InRtThread;

#endif




// These are the realtime executive exception handler prototypes.
// We are NOT defining these with the various parameters that the hardware
// actually passes them.
// Note that IntelReserved is used for a number of different IDT entries.

VOID
DivideByZero (
    VOID
    );

VOID
DebugExceptions (
    VOID
    );

VOID
SwitchRealTimeThreads (
    VOID
    );

VOID
RtThreadPerfCounterNMI (
    VOID
    );

VOID
RtExecPerfCounterNMI (
    VOID
    );

VOID
RtExecBreakPoint (
    VOID
    );

VOID
RtThreadBreakPoint (
    VOID
    );

VOID
Overflow (
    VOID
    );

VOID
BoundsCheck (
    VOID
    );

VOID
InvalidOpcode (
    VOID
    );

VOID
DeviceNotAvailable (
    VOID
    );

VOID
DoubleFault (
    VOID
    );

VOID
IntelReserved (
    VOID
    );

VOID
InvalidTSS (
    VOID
    );

VOID
SegmentNotPresent (
    VOID
    );

VOID
StackException (
    VOID
    );

VOID
GeneralProtection (
    VOID
    );

VOID
PageFault (
    VOID
    );

VOID
FloatingPointError (
    VOID
    );

VOID
AlignmentCheck (
    VOID
    );

VOID
MachineCheck (
    VOID
    );

VOID
RtpLocalApicErrorHandler (
    VOID
    );

VOID
RtpLocalApicSpuriousHandler (
    VOID
    );

#ifdef NONMI

VOID
JumpToWindowsNmiHandler (
    VOID
    );

#endif



// This function initializes the realtime executive IDT and the realtime thread IDT,
// and sets things up for the IDT switch that happens at the beginning and end of 
// every real time interrupt.

VOID
RtpSetupIdtSwitch (
    ULONG TimerVector,
    ULONG PerfVector,
    ULONG ErrorVector,
    ULONG SpuriousVector
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\log.h ===
// This is the list of all currently defined types of packets.

enum PacketTypes{
	NODATA,
	DMA_MASKED,
	DMA_UNMASKED,
	GLITCHED,
	INTERRUPTS_HELDOFF
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\rt.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    rt.c

Abstract:

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




// We use inline functions heavily.  Set up the compiler
// to use them.

#pragma inline_recursion(off)
#pragma inline_depth(255)


// Some functions MUST be inlined in order for the code to
// work correctly.  Force the compiler to report errors for
// functions that are marked __forceinline that are not inlined.

#pragma warning( error: 4714 )


#include "common.h"

#pragma LOCKED_CODE
#pragma LOCKED_DATA

#include "x86.h"
#include "cpu.h"
#include "msr.h"
#include <rt.h>
#include "rtp.h"
#ifdef UNDER_NT
#include "rtinfo.h"
#else
#include <rtinfo.h>
#endif
#include "apic.h"
#include "irq.h"
#include "rtexcept.h"
#include "log.h"


#ifndef UNDER_NT

#include <vmm.h>
#include <vwin32.h>
#include <ntkern.h>
#include <vpowerd.h>
#define PAGEFRMINST    0x20000000
#ifdef WAKE_EVERY_MS
#include <vtd.h>
#endif

#endif


#pragma LOCKED_CODE
#pragma LOCKED_DATA


typedef struct {
	ULONGLONG Mark;
	ULONGLONG Delta;
	} YIELDTIME, *PYIELDTIME;


#pragma pack(push,2)

typedef struct threadstate {
	struct threadstate *next;
	struct threadstate *previous;
	WORD ds;
	WORD es;
	WORD fs;
	WORD gs;
	ULONG ecx;
	ULONG edx;
	ULONG ebx;
	ULONG ebp;
	ULONG esi;
	ULONG edi;
	ULONG esp;
	WORD ss;
	WORD state;
	ULONG data;
	ULONG irql;
	ThreadStats *Statistics;
	HANDLE ThreadHandle;
	ULONGLONG Mark;
	ULONGLONG Delta;
	PVOID FloatState;
	PHANDLE pThreadHandle;
	PULONG StackBase;
	PVOID FloatBase;
	} ThreadState;

typedef struct {
	ULONG esp;
	WORD ss;
	} Stack;

#pragma pack(pop)



#define CATCH_INTERRUPTS_DISABLED_TOO_LONG 1

#define USEMACROS 1


#define LOCALSTACKSIZE 256

#define FLOATSTATESIZE 512
#define FXALIGN 16


#define MAXAPICERRORHISTOGRAM 0xff

#define MINIMUMCYCLECOUNT 50

#ifdef WAKE_EVERY_MS
ULONG WakeCpuFromC2C3EveryMs=FALSE;
#endif

#ifdef CATCH_INTERRUPTS_DISABLED_TOO_LONG
extern PBOOLEAN KdEnteredDebugger;
ULONG NmiInterruptCount=0;
ULONG_PTR OriginalWindowsNmiHandler=0;
LONG MaxUsecWithInterruptsDisabled=1500;
#endif

ULONGLONG RtShutdownTime=0;
ULONGLONG lasttime=0;

ULONG LocalApicSpuriousInterruptCount=0;
ULONG LocalApicErrorInterruptCount=0;

ULONG ApicErrorHistogram[MAXAPICERRORHISTOGRAM+1];

ULONG RtCpuCyclesPerUsec=0;
ULONG RtSystemBusCyclesPerUsec=0;
volatile ULONG RtCpuAllocatedPerMsec=0;
ULONG RtPsecPerCpuCycle;

ULONG RtRunning=0;

ULONG RtLastUniqueThreadHandle=0;

ID OriginalNmiVector;
ID OriginalMaskableVector;
ID OriginalApicErrorVector;
ID OriginalApicSpuriousVector;

ULONG LastTPR=0;

ULONG SwitchRtThreadReenterCount=0;

ULONGLONG threadswitchcount=0;

ULONGLONG lastthreadswitchtime=0;

ThreadState *windowsthread=NULL;

ThreadState *currentthread=NULL;

ThreadState *lastthread=NULL;

ThreadState * volatile RtDeadThreads=NULL;

ULONG RtThreadCount=0;

ULONG activefloatthreadcount=0;

ULONG RtpForceAtomicHoldoffCount=0;
ULONG RtpTransferControlHoldoffCount=0;

KSPIN_LOCK RtThreadListSpinLock=0;

ULONG PerformanceInterruptState=MASKPERF0INT;

PKIRQL pCurrentIrql=NULL;

#ifdef MASKABLEINTERRUPT
ULONG InjectWindowsInterrupt=0;
SPTR HandleWindowsInterrupt={0,0x28};
ULONG InjectedInterruptCount=0;

ULONG EnabledInterrupts=0;
ULONG OriginalIrql=0;
#endif

ULONG LastWindowsCR0=0;
ULONG NextCR0=0;

WORD RtRing3Selector=0;
WORD RtExecCS=0;
WORD RtThreadCS=0;
WORD RealTimeDS=0;
WORD RealTimeSS=0;
WORD OriginalDS=0;

#ifdef GUARD_PAGE
WORD RtExecTSS=0;
extern TSS RtTss;
#endif


ULONG loopcount=0;


ULONG SendPendingCount=0;
ULONG SendPendingLoopCount=0;

ULONG TransferControlReMaskCount=0;


Stack RealTimeStack;

ULONG LocalStack[LOCALSTACKSIZE];




#ifdef WAKE_EVERY_MS


ULONG
SetTimerResolution (
    ULONG ms
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{

    ASSERT ( ms != 0 );

    // Set the new resolution.

#ifdef UNDER_NT

    return (ExSetTimerResolution( ms*10000, TRUE) + 5000)/10000;

#else

    __asm mov	eax, ms
    VxDCall(VTD_Begin_Min_Int_Period);

    __asm jnc	done
    __asm xor	eax,eax

    done:
    ;

#endif

}


VOID
ReleaseTimerResolution (
    ULONG ms
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{

    ASSERT ( ms != 0 );

#ifdef UNDER_NT

    ExSetTimerResolution( ms*10000, FALSE);

#else

    __asm mov	eax,ms

    VxDCall(VTD_End_Min_Int_Period);

#if DEBUG

    __asm jnc	ok

    dprintf((QDBG"Error releasing minimum interrupt period!"));
    Trap();

    ok:
    ;

#endif

#endif

}


#endif



#if 0

// This doesn't work.  New Intel machines only write the bottom 32 bits of the count
// and clear the top 32 bits - so setting the count is not useful except to set it
// to zero.

VOID __inline WriteCycleCounter(LONGLONG Count)
{

WriteIntelMSR(0x80000000+0x10, Count);

}

#endif


#pragma warning ( disable : 4035 )


#ifdef MASKABLEINTERRUPT

VOID
_fastcall
WrapKfLowerIrql (
    KIRQL Irql
    )
{

KeLowerIrql(Irql);

}

#endif




#ifdef GUARD_PAGE

ULONG
__cdecl
CommitPages (
    ULONG page,
    ULONG npages,
    ULONG hpd,
    ULONG pagerdata,
    ULONG flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{

    __asm {

        push flags
        push pagerdata
        push hpd
        push npages
        push page

        VMMCall( _PageCommit )

        __asm add esp, 0x14

        }

}




PVOID
__cdecl
ReservePages (
    ULONG page,
    ULONG npages,
    ULONG flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{

    __asm {

        push flags
        push npages
        push page

        VMMCall( _PageReserve )

        __asm add esp, 12

        }

}




PVOID
__cdecl
FreePages (
    PVOID hmem,
    DWORD flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{

    __asm {

        push flags
        push hmem

        VMMCall( _PageFree )

        __asm add esp, 8

        }

}

#endif


#pragma warning ( default : 4035 )




#if 0

NTSTATUS CreateReadOnlyStatisticsPage(ThreadState *ThreadState)
{

#ifndef UNDER_NT


ULONG CR3;
static ULONG LastCR3=0;
static ULONG PageDirectory=0;
ULONG PageTable;
ThreadStats *readonlystats;

// Get current CR3 value.

CR3=GetCR3();

// If different from previous, we must map the page directory.

if (CR3!=LastCR3) {

	if (LastCR3) {
		// CR3 changed - after we started up.  This should not normally happen.
		Trap();
		}

	// Map the page directory.  We must redo this when CR3 changes.  In that case
	// we will waste the previously mapped directory, but then again, that should
	// never happen.
	PageDirectory=(PULONG)MapPhysicalToLinear((PVOID)CR3, PROCPAGESIZE, 0);

	if (PageDirectory==(-1)) {
		return STATUS_UNSUCCESSFUL;
		}

	// Remember which page directory we have currently mapped.
	LastCR3=CR3;

	}

// Now get a page that we can map for a read only copy of the statistics.
readonlystats=ReservePages(PR_SYSTEM, 1, PR_FIXED);

if (readonlystats==(-1)) {
	return STATUS_UNSUCCESSFUL;
	}

// Now get a linear address for the page table containing this page.
ReadOnlyStatisticsPageTable=MapPhysicalToLinear((PVOID)((PageDirectory[(ULONG)(readonlystats)>>22])&(~(PROCPAGESIZE-1))), PROCPAGESIZE, 0);

// Make our page a read only page mapped to same physical page as the read/write
// statistics.
return readonlystats;


#else

// This function is not yet implemented.  For now punt.

return STATUS_NOT_IMPLEMENTED;

#endif

}

#endif




NTSTATUS
HookInterrupt (
    ULONG index,
    ID *originalvector,
    VOID (* handler)(VOID)
    )
{

    IDT systemidt;
    ID newvector;

    SaveAndDisableMaskableInterrupts();

    // Get the IDT.
    SaveIDT(systemidt);

    if ( systemidt.limit < (index+1)*8-1 ) {
        Trap();
        RestoreMaskableInterrupts();
        return STATUS_UNSUCCESSFUL;
    }

    // Save the current handler.
    *originalvector=*(ID *)(systemidt.base+index*8);

    // Blast in our new idt entry.
    newvector.highoffset=(WORD)((DWORD)handler>>16);
    newvector.flags=0x8e00;
    newvector.selector=RtExecCS;
    newvector.lowoffset=(WORD)handler;

    *(ID *)(systemidt.base+index*8)=newvector;

    RestoreMaskableInterrupts();

    return STATUS_SUCCESS;

}




// This routine takes at least 10 cycles on a Pentium.

#define SaveThreadState() \
__asm {					\
	__asm sub esp,4		/*ds already saved */	\
	__asm push es		\
	__asm push fs		\
	__asm push gs		\
	__asm pushad		\
	}


// This routine takes at least 18 cycles on a Pentium.

#define RestoreThreadState() \
__asm {					\
	__asm popad			\
	__asm pop gs		\
	__asm pop fs		\
	__asm pop es		\
	__asm pop ds		\
	}


#define AllocateStackForFPState() \
__asm {					\
	__asm sub esp,108	\
	}


#define ReleaseStackForFPState() \
__asm {					\
	__asm add esp,108	\
	}



#define fxsave_eax __asm _emit 0xf __asm _emit 0xae __asm _emit 0x0
#define fxrstor_eax __asm _emit 0xf __asm _emit 0xae __asm _emit 0x8



// This routine takes at least 125 cycles on a Pentium.

VOID __inline SaveThreadFloatState(PVOID FloatState)

{

__asm {
	test dword ptr CPUFeatures,FXSR
	mov eax,FloatState
	jnz xsave
	fnsave [eax]
	jmp savedone
xsave:
	fxsave_eax
savedone:
	}

}


// This routine takes at least 71 cycles on a Pentium.

VOID __inline RestoreThreadFloatState(PVOID FloatState)

{

__asm {
	test dword ptr CPUFeatures,FXSR
	mov eax,FloatState
	jnz xrestore
	frstor [eax]
	jmp restoredone
xrestore:
	fxrstor_eax
restoredone:
	}

}



#pragma warning ( disable : 4035 )

ULONG Get_FS(VOID)
{

#ifndef UNDER_NT

Load_FS;

#endif

__asm {
	xor eax,eax
	mov ax,fs

#ifdef UNDER_NT

	cmp eax,0x30
	jz ok
	int 3
ok:

#endif

	}

}

#pragma warning ( default : 4035 )



// 1 cycle

#define LoadThreadStatePointer() \
	__asm mov eax, currentthread


// 2 cycles

#define SaveThreadStack() \
__asm {									\
	__asm mov [eax]ThreadState.esp,esp	\
	__asm mov [eax]ThreadState.ss,ss	\
	}


// 8 cycles

#define RestoreThreadStack() \
__asm {									\
	__asm lss esp,[eax]ThreadState.esp	\
	}


#define StopPerformanceCounters() \
__asm { \
	__asm mov eax, STOPPERFCOUNTERS		\
	__asm xor edx, edx					\
	__asm mov ecx, EVENTSELECT0			\
	__asm _emit 0x0f					\
	__asm _emit 0x30					\
	}


#define StartPerformanceCounters() \
__asm { \
	__asm mov eax,EnablePerfCounters		\
	__asm xor edx,edx					\
	__asm mov ecx, EVENTSELECT0			\
	__asm _emit 0x0f					\
	__asm _emit 0x30					\
	}


#define TurnOnPerformanceCounters() \
__asm { \
	__asm test cs:EnablePerfCounters, 0xffffffff	\
	__asm jz noperf									\
	__asm push eax									\
	__asm push edx									\
	__asm push ecx									\
	__asm xor edx, edx								\
	__asm mov ecx, cs:EVENTSELECT0					\
	__asm mov eax, cs:EnablePerfCounters			\
	__asm _emit 0x0f								\
	__asm _emit 0x30								\
	__asm pop ecx									\
	__asm pop edx									\
	__asm pop eax									\
	__asm noperf:									\
	}



// We need a more advanced function for on the fly programming.
// Using this function for programming counters that are moving will
// NOT keep them syncronized.

// Note that when we implement that and compensate for the instruction
// count to keep the counters syncronized, we need to make sure we
// do NOT take counts between zero and OVERHEAD instructions and make them 
// NEGATIVE and thus generate interrupts too soon. 

// For counters that are both moving we should subtract the overhead.  For
// counters that are stopped we should NOT.  For mismatched counters there
// is no intelligent thing we can do.  We will not subtract overhead.


VOID SetTimeLimit(LONG cycles, LONG instructions)
{

ULONG OldPerfIntState;

// Disable maskable and the scheduler interrupts.

SaveAndDisableMaskableInterrupts();

SaveAndDisablePerformanceCounterInterrupt(&OldPerfIntState);


//WriteIntelMSR(INSTRUCTIONCOUNT, -instructions);

WriteIntelMSR(CYCLECOUNT,-cycles);


#if DEBUG

// Now if the counters are disabled, then verify that they are set correctly.
// For we only validate the bottom 32 bits since on Intel P6 processors that
// is all that is used to program the counts.  This validation code should
// work correctly on all P6 and K7 processors.

if (((ReadIntelMSR(CYCLECOUNT)^(ULONGLONG)-cycles)&PERFCOUNTMASK)) {
	Trap();
	}

// We have to handle AMD and Intel differently, since on Intel, the enable
// bit in perf counter 0 controls ALL of the counters, while on AMD, they did
// it differently and gave each counter its own enable bit.  The Intel way
// makes it possible for you to turn on and off all of the counters in
// one instruction which is very important if you want to syncronize the
// results of multiple counters to the same enabled/disabled time period.

// Actually, AMDs design could cause me problems - since I may not
// want to have to turn on and off every counter individually.  It certainly
// does make perfect syncronization of multiple counters impossible.

// One VERY nice thing about AMD's design is that you can use the counters
// independently:  you don't HAVE to own counter0 to be able to use counter1.
// That makes sharing different counters between different clients possible.

/*
{
ULONG Counter1Enable=EVENTSELECT0;

if (CPUManufacturer==AMD) {
	Counter1Enable=EVENTSELECT1;
	}

if (!(ReadIntelMSR(Counter1Enable)&PERFCOUNTERENABLED)  &&
	((ReadIntelMSR(INSTRUCTIONCOUNT)^(ULONGLONG)-instructions)&PERFCOUNTMASK)) {
	Trap();
	}

}
*/

#endif

// Restore interrupt state.

RestorePerformanceCounterInterrupt(OldPerfIntState);

RestoreMaskableInterrupts();


}



#define SaveEAX() \
	__asm push eax

#define RestoreEAX() \
	__asm pop eax


// 19 cycles

#define SignalRtExceptions() \
__asm { \
	__asm _emit 0x0f __asm _emit 0x20 __asm _emit 0xe0 /* __asm mov eax,cr4 */ \
	__asm or eax,4		\
	__asm _emit 0x0f __asm _emit 0x22 __asm _emit 0xe0 /* __asm mov cr4,eax */ \
	}


// 7 cycles

#define LoadRtDS() \
__asm { \
	__asm mov ax,ds				\
	__asm shl eax,16			\
	__asm mov ax,cs:RealTimeDS	\
	__asm mov ds,ax				\
	}


// 2 cycles

#define HoldOriginalDS() \
__asm { \
	__asm shr eax,16			\
	__asm mov OriginalDS,ax		\
	}


// 2 cycles

#define SaveOriginalDS() \
__asm { \
	__asm mov bx,OriginalDS				\
	__asm mov [eax]ThreadState.ds,bx	\
	}


// 3 cycles

#define RestoreOriginalDS() \
__asm { \
	__asm mov ds,[eax]ThreadState.ds	\
	}


#define SetupStack() \
__asm { \
	__asm lss esp,RealTimeStack	\
	__asm mov ebp,esp			\
	__asm sub esp,__LOCAL_SIZE	\
/* The next 2 lines are CRITICAL.  Without them, string instructions fault! */	\
	__asm mov es,RealTimeDS		\
	__asm cld  \
	}





// 3 cycles

#define SaveSegmentState() \
__asm { \
	__asm mov [eax]ThreadState.es,es \
	__asm mov [eax]ThreadState.fs,fs \
	__asm mov [eax]ThreadState.gs,gs \
	}


// 9 cycles

#define RestoreSegmentState() \
__asm { \
	__asm mov es,[eax]ThreadState.es \
	__asm mov fs,[eax]ThreadState.fs \
	__asm mov gs,[eax]ThreadState.gs \
	}


// ~3 cycles

#define SaveRegisterState() \
__asm { \
	__asm mov [eax]ThreadState.ecx, ecx \
	__asm mov [eax]ThreadState.edx, edx \
	__asm mov [eax]ThreadState.ebx, ebx \
	__asm mov [eax]ThreadState.ebp, ebp \
	__asm mov [eax]ThreadState.esi, esi \
	__asm mov [eax]ThreadState.edi, edi \
	}

// ~3 cycles

#define RestoreRegisterState() \
__asm { \
	__asm mov ecx,[eax]ThreadState.ecx	\
	__asm mov edx,[eax]ThreadState.edx	\
	__asm mov ebx,[eax]ThreadState.ebx	\
	__asm mov ebp,[eax]ThreadState.ebp	\
	__asm mov esi,[eax]ThreadState.esi	\
	__asm mov edi,[eax]ThreadState.edi	\
	}



VOID RemoveRtThread(ThreadState *thread)
{

// Now make sure the thread is not holding any spinlocks.  It is an
// error to destroy a realtime thread that is holding any spinlocks.
// Note that we MUST atomically check the spinlock count and remove
// the thread from the list of runnable threads - otherwise we could
// think the thread is not holding a spinlock and get switched out and
// have it acquire one just before we kill it.




// Unhook thread from the list.
thread->next->previous=thread->previous;
thread->previous->next=thread->next;

if (thread->FloatState!=NULL) {
	activefloatthreadcount--;
	}

// Update our RT thread count.
RtThreadCount--;

// Mark the thread as dead.
//thread->state=DEAD;

// Now mask the realtime scheduler interrupt if the thread count is 1.
if (RtThreadCount==1) {

	WriteAPIC(APICTIMER, ApicTimerVector|MASKED|PERIODIC);

	}

// Make its cycles available.
RtCpuAllocatedPerMsec-=(ULONG)(thread->Statistics->Duration/(thread->Statistics->Period/MSEC));


}



ULONGLONG
OriginalRtTime (
    VOID
    )
{

ULONGLONG time;

time=ReadCycleCounter();

// Make sure time never goes backwards.  Trap if it does.
if ((LONGLONG)(time-lasttime)<0) {
	//Trap(); // BUGBUG  THIS IS HITTING FIND OUT WHY!!!
	}

lasttime=time;

time*=USEC/RtCpuCyclesPerUsec;

if (!time) {
	time--;
	}

return time;

}



ULONGLONG
FastRtTime (
    VOID
    )
{

ULONGLONG time;

time=ReadCycleCounter();

lasttime=time;

time*=RtPsecPerCpuCycle;

if (!time) {
	time--;
	}

return time;

}



ULONGLONG
RtTime (
    VOID
    )
{

    ULONGLONG CurrentRead, LastRead, PreviousValue;

    PreviousValue=0;


    // First atomically grab the last time logged.
    LastRead=InterlockedCompareExchange64(&lasttime, PreviousValue, PreviousValue);


    // Now read the timestamp counter.

    CurrentRead=ReadCycleCounter();


    // Make sure time never goes backwards.  Trap if it does.

    if ((LONGLONG)(CurrentRead-LastRead)<0) {
        Break();
    }


    // Save this read of the timestamp counter.  If the compare exchange fails,
    // then a higher priority task has interrupted us and already updated the
    // time, so just report the time it logged.

    PreviousValue=InterlockedCompareExchange64(&lasttime, CurrentRead, LastRead);

    if (PreviousValue!=LastRead) {
        CurrentRead=PreviousValue;
    }


    // Convert the timestamp counter reading from cycles into picoseconds.
    // Make sure we never return a time of zero.

    CurrentRead*=RtPsecPerCpuCycle;

    if (CurrentRead==0) {
        CurrentRead--;
    }


    return CurrentRead;

}



// This is the local apic spurious interrupt handler.  All we do in this
// handler is increment a count of the number of spurious interrupts, and
// return.  This routine should NOT EOI the apic.

VOID
__declspec(naked)
RtpLocalApicSpuriousHandler (
    VOID
    )
{

__asm {
	push ds
	mov ds, cs:RealTimeDS
	lock inc LocalApicSpuriousInterruptCount
	pop ds
	}

Return();

}




// This routine will be called when local apic errors are unmasked and
// occur.

// For now all we do is increment a count and

// We may use this in the future to help determine if interrupts are staying
// masked for too long.  This we can do by simply forcing an error while in
// the SwitchRealTimeThreads routine while interrupts are off, and then seeing
// if when we get back into that routine, this Error handler has hit or not.

// If we hit this handler then interrupts were definitely enabled for at least
// part of the time since we left the SwitchRealTimeThreads routine.  If we didn't
// hit this handler then interrupts MAY have been disabled the whole time.  It is possible
// that we were not the highest priority interrupt when interrupts were enabled and
// some other handler was called.  So, not getting called does NOT mean that interrupts
// were disabled the whole time.  It CAN mean that - and it ussually will mean that.

VOID
__declspec(naked)
RtpLocalApicErrorHandler (
    VOID
    )
{

__asm {
	push ds
	mov ds, cs:RealTimeDS
	lock inc LocalApicErrorInterruptCount
	pop ds
	}

Trap();

Return();

}




VOID __declspec(naked) SwitchRealTimeThreads(VOID)
{

//LONG i;


// Paranoia:  Make sure we are not being reentered.
__asm {
	push ds
	mov ds, cs:RealTimeDS
	inc SwitchRtThreadReenterCount
	cmp SwitchRtThreadReenterCount, 1
	pop ds
	jz notreentered
	int 3
notreentered:
	}


#ifdef DEBUG

// Paranoia:  Make sure interrupts are disabled.

__asm {
	pushfd
	test dword ptr[esp], IF
	jz intsdisabled
	int 3
	and dword ptr[esp], ~(IF)
intsdisabled:
	popfd
	}

#endif


// Now save the Windows IDT properly so that any exceptions that hit
// after we switch IDTs will be handled properly.  If we do not do
// this BEFORE switching IDTs, then any exceptions that occur between
// the switch and the saving of the Windows IDT state could make an
// OLD windows IDT get loaded in the exception handler.  Really NOT
// a good idea.
__asm {
	// Note that we do NOT use the CS test here, since we may have
	// come in from the debugger and that might have switched our
	// CS, although it should NOT have.  If it does, it will also
	// hose all of our checks in ntkern and vmm for whether we are
	// running a realtime thread or not.  This is a faster test
	// anyway.
	push eax
	mov eax, cs:currentthread
	cmp eax, cs:windowsthread
	jnz notwindows

	// Get our FLAT selector into DS so we can write memory.
	push ds
	mov ds, cs:RealTimeDS

#ifdef MASKABLEINTERRUPT

// The very first thing we do is to disable all maskable interrupts.
// We do this as early as possible in this routine - since we need
// to prevent normal PIC interrupts from getting queued up in the
// processor.  They will fire when we return control to the realtime
// threads and will GP fault.  We can currently queue up and defer
// one, but ONLY one.

// The fundamental problem we are trying to solve is that there is a
// window between when the processor masks interrupts when it is
// processing this interrupt through the interrupt gate, and this next
// snippet of code - where we disable the external interrupts.  This
// is only a problem if we run the realtime threads with interrupts
// enabled and use a maskable interrupt to switch between them.

// Because of that Window we may ALWAYS have 1 or more interrupts pended
// inside the CPU that masking the local APIC interrupt will have
// no effect on.

// Note that we only need to mask external interrupts and then flush
// out any pending ones IF we are coming in from windows AND we are
// NOT coming in on an rtptransfercontrol.  If the external interrupts
// are already masked then we ABSOLUTELY DO NOT want to reenable
// interrupts - since we are trying to make the transition from
// transfer control all the way through this routine COMPLETELY ATOMIC.

// IF and ONLY IF, the external interrupts are currently ENABLED, then
// we will mask them, and reenable interrupts temporarily.  This
// technique functions like an airlock - where first all interrupts
// are masked in the processor, but some may get stuck inside pending.
// Then we close the outside door - by masking external interrupts at
// the apic.  Then we flush anything left waiting inside through by
// enabling interrupts while the external interrupts are disabled,
// then we close the inside door again by masking interrupts.


	mov eax, ApicIntrInterrupt
	test dword ptr[eax], MASKED
	jnz skippendinginterruptfix

// If we get here, then interrupts need to be masked at the apic and we
// need to flush through any interrupts pending in the processor.

	or dword ptr[eax], MASKED

// The second line of defense is to REENABLE interrupts after having
// turned them off!  This will allow any interrupts that are queued
// up to fire.  We do this ONLY if we are leaving windows and are starting
// to run realtime threads.  We also only do this if we MUST.  It is
// likely that we will need to do this, because the processor can
// queue up multiple interrupts - and it does handle some with higher
// priority than others.  So, IF the local apic interrupts have higher
// priority than the external interrupt interrupt, then we may still
// have interrupts pending inside the processor that will hit when we
// popfd in either RtpTransferControl, or when we iret to a real time
// thread from this routine.  This fix should prevent that from ever 
// happenning.

// Before we turn on interrupts however, we make sure that we hold
// off any processing of DPCs.  We hold off DPC processing until
// we are switching back to Windows.  This should help reduce or ideally
// eliminate reentrancy in this routine.

// The code between enableok and irqlok is ABSOLUTELY NOT reentrant.  So we
// must crash and burn if we try to reenter it.

	inc EnabledInterrupts
	cmp EnabledInterrupts, 1
	jz	enableok
	int 3

enableok:

	mov eax, pCurrentIrql
	movzx eax, byte ptr[eax]
	mov OriginalIrql, eax

	cmp eax, DISPATCH_LEVEL
	jge irqlok
	mov eax, pCurrentIrql
	mov byte ptr[eax], DISPATCH_LEVEL

irqlok:

	sti
	nop
	nop
	nop
	nop
	cli

skippendinginterruptfix:

#endif

	// If we get here, then we need to save off the current IDT so
	// that we restore the proper IDT in our RT exec exception handlers.
	// We MUST do this BEFORE switching IDTs.  Otherwise our exception
	// handlers may restore the WRONG windows IDT.
	sidt WindowsIDT
	pop ds
notwindows:
	pop eax
	}


// We MUST have saved away the current windows idt before we make this
// switch.  Otherwise the realtime executive exception handlers may
// load an INCORRECT windows IDT.

LoadIDT(RtExecIDT);

__asm {
	push ds
	mov ds, cs:RealTimeDS
	}

SaveIDT(DebugIDT);	// Make sure we put back correct IDT in exception handlers.

__asm {
	pop ds
	}



SaveEAX();

LoadRtDS();

HoldOriginalDS();

LoadThreadStatePointer();

SaveSegmentState();

SaveRegisterState();

SaveOriginalDS();

SaveThreadStack();

SetupStack();


StopPerformanceCounters();

// Save Irql for thread we are leaving.
// To do this we directly read the memory in ntkern that holds current irql.
currentthread->irql=*pCurrentIrql;

#if DEBUG
//*ApicTimerInterrupt=ApicTimerVector|MASKED|PERIODIC;
#endif

// After this point it is safe to run essentially any code we want.
// The stack is setup so straight c will work properly, and the
// scheduler interrupt is turned off.

// Note that we should check for reentrancy on this interrupt.  We can
// do that really easily by having a separate IDT for the rt executive.
// We load that when we enter this routine, we load the windows IDT when
// we exit this routine and return to windows, and we load the rt threads
// IDT when we exit this routine running a real time thread.

// That will make it easy to isolate exceptions caused by the RT executive
// versus exceptions caused by real time threads.


//Trap();



// Make sure that we do not have any ISR in APIC other than our own.
// Make sure no IRR in APIC - otherwise we have been held off.


// Check for cases when we have stopped in the debugger on an int 3 in
// a realtime thread and have loaded the windows idt.

// Nasty case when we iret back from switchrealtime threads to an int 3 itself 
// should be considered
// we have to make absolutely sure that no interrupts get processed while
// we are running the realtime thead.  In that case ints may stay disabled
// the whole time until after the windows idt is loaded.

if (currentthread!=windowsthread) {

#ifdef MASKABLEINTERRUPT

	// Make sure that interrupts are enabled on this realtime thread.  Again
	// they may not be if we hit an int 3 and transfered control to the
	// debugger.  If they are disabled, then reenable them for the next
	// switch into that thread.

	// Trap in debug if they are disabled and we did not log an int 3 hit in
	// the code.

	// First make sure that we got here on an RtpTransferControl.
	if (*(WORD *)((*(ULONG *)(currentthread->esp+EIPRETURNADDRESSOFFSET*sizeof(ULONG)))-2)==(0xcd|(TRANSFERCONTROLIDTINDEX<<8))) {

		// We got here on an RtpTransferControl.  Check the flags that got pushed
		// in that routine before the CLI, so that we check the real state of the
		// rt thread's interrupt flag.
		if (((ULONG *)(currentthread->esp))[RTPTRANSFERCONTROLEFLAGSOFFSET]&IF) {
			// Realtime thread has interrupts ENABLED!
			// We better not think that we hit an int 3.
			#ifdef DEBUG
			if (HitInt3InRtThread) {
				Trap();
				}
			#endif
			}
		else {
			// Realtime thread has interrupts DISABLED!
			// Reenable them, and make sure we hit an int 3.
			((ULONG *)(currentthread->esp))[RTPTRANSFERCONTROLEFLAGSOFFSET]|=IF;
			#ifdef DEBUG
			if (!HitInt3InRtThread) {
				Trap();
				}
			else {
				HitInt3InRtThread=0;
				}
			#endif
			}

		}

#endif

	// Now make sure that our IRQL is never lower than DISPATCH_LEVEL.
	if (currentthread->irql<DISPATCH_LEVEL) {
		Trap();
		}

	}




if (currentthread==windowsthread) {

	#ifdef MASKABLEINTERRUPT
	HandleWindowsInterrupt.offset=0;
	#endif

	// If the current thread is windows, then save CR0.
	// Then we can properly restore CR0 when we return to windows.

	LastWindowsCR0=ReadCR0();


	#ifdef DEBUG

	// Make sure that the APIC interrupt is programmed properly.

	if (!((*ApicPerfInterrupt)&NMI)) {
		#ifndef MASKABLEINTERRUPT
		Trap();
		#endif
		}
	else {
		#ifdef MASKABLEINTERRUPT
		Trap();
		#endif
		}

	#endif


	// I need to figure out how to clear pending interrupts
	// so that they are not generated.  That is for the case
	// when an maskable interrupt hits after we have disabled
	// maskable interrupts (CLI) but before we have masked the
	// APIC interrupt itself.


	// If the ISR bit is set for our maskable interrupt then we need to
	// clear it.

	// We only EOI the APIC if our ISR bit is set.

	if (ReadAPIC(0x100+(ApicTimerVector/32)*0x10)&(1<<(ApicTimerVector%32))) {

		// We have to EOI the APIC for non NMI based interrupts.
		WriteAPIC(APICEOI,0);

		}
	#ifdef DEBUG
	else {

		// Our ISR bit was not set.  We better have gotten here with a software interrupt.

		// If we did not get here on a software interrupt instruction, then
		// trap.  This way of checking will work regardless of the routine
		// used to transfer control.  As long as an interrupt instruction is used
		// to give us control.

		if (*(WORD *)((*(ULONG *)(windowsthread->esp+EIPRETURNADDRESSOFFSET*sizeof(ULONG)))-2)!=(0xcd|(TRANSFERCONTROLIDTINDEX<<8))) {
			Trap();
			}

		}
	#endif


	// Now in debug code make sure our ISR bit is now clear.  If not, then
	// we are in real trouble, because we just did an EOI if our ISR bit was
	// set and that DID NOT clear our bit.  It must have cleared another ISR
	// bit (very bad) or the APIC is broken (also very bad).

	#ifdef DEBUG

	if (ReadAPIC(0x100+(ApicTimerVector/32)*0x10)&(1<<(ApicTimerVector%32))) {

		Trap();

		}

	#endif
	
	}

#ifdef DEBUG

// Current thread is NOT a windows thread.
// In this case the APIC interrupt should be programmed to
// be NMI, and interrupts MUST be masked.  It is a FATAL
// error to unmask interrupts while inside a real time thread.

else {

	if (!((*ApicPerfInterrupt)&NMI)) {
		#ifndef MASKABLEINTERRUPT
		Trap();
		#endif
		}
	else {
		#ifdef MASKABLEINTERRUPT
		Trap();
		#endif
		}

	// I need to decide if I got here on RtpTransferControl or not.
	// If I did, then the interrupt flag I need to check is at a different
	// location on the stack.

	if (*(WORD *)((*(ULONG *)(currentthread->esp+EIPRETURNADDRESSOFFSET*sizeof(ULONG)))-2)!=(0xcd|(TRANSFERCONTROLIDTINDEX<<8))) {

		// This was not an RtpTransferControl.  It was a hardware NMI.
		if (((ULONG *)(currentthread->esp))[EFLAGSOFFSET]&IF) {
			// Realtime thread has interrupts ENABLED!  Fatal Error!
			// Everything is dead at this point.  We really need to
			// make it essentially impossible for real time threads
			// to enable interrupts.
			#ifndef MASKABLEINTERRUPT
			Trap();
			#endif
			}
		else {
			#ifdef MASKABLEINTERRUPT
			Trap();
			#endif
			}

		}
	else {

		// We got here on an RtpTransferControl.  Check the flags that got pushed
		// in that routine before the CLI, so that we check the real state of the
		// rt thread's interrupt flag.
		if (((ULONG *)(currentthread->esp))[RTPTRANSFERCONTROLEFLAGSOFFSET]&IF) {
			// Realtime thread has interrupts ENABLED!  Fatal Error!
			// Everything is dead at this point.  We really need to
			// make it essentially impossible for real time threads
			// to enable interrupts.
			#ifndef MASKABLEINTERRUPT
			Trap();
			#endif
			}
		else {
			#ifdef MASKABLEINTERRUPT
			Trap();
			#endif
			}

		}

	}

#endif


#ifdef DEBUG

// Make sure the enable floating point MMX instructions bit is set in CR4.
// If not, then the fxsave and fxrstor instructions will not work properly.

if ((CPUFeatures&FXSR) && !(ReadCR4()&OSFXSR)) {

	Trap();

	}

#endif


// The following code is for detecting how the IDT and CR0 are
// used by the OS.

#if defined(DEBUG) && 0

// This is monitoring code to see if anyone else in the system
// is swaping IDTs.  If they are, this should catch them.
// I ran this on Win2K Pro, and did NOT hit the Trap().

// This hits constantly on 9x - just another indication that
// NT is a much better behaved environment than 9x.

// This means that we will need to SAVE the 9x IDT BEFORE we
// blast in a new value.  Otherwise we will crash the OS since
// we will blow away an IDT and restore it improperly.  What
// a pain.

SaveIDT(WindowsIDT);

if (WindowsIDT!=LastWindowsIDT) {
	Trap();
	}

LastWindowsIDT=WindowsIDT;

{
ULONG currentCR0;

currentCR0=ReadCR0();

// The MP bit should always be set.
if (!(currentCR0&FPUMONITOR)) {
	Trap();
	}

// The EM bit should never be set.
if (currentCR0&FPUEMULATION) {
	Trap();
	}

// The TS bit should never be set.
if (currentCR0&FPUTASKSWITCHED) {
	Trap();
	}

// The ET bit should always be set.
if (!(currentCR0&FPU387COMPATIBLE)) {
	Trap();
	}

// The NE bit must ALWAYS be set.  This is REQUIRED, since we will run realtime threads
// with interrupts masked, so an external interrupt will NOT fire.  We MUST have the
// internally generated exception.
if (!(currentCR0&FPUEXCEPTION)) {
	Trap();
	}

}

#endif


#ifdef DEBUG
// Make sure performance counters are not moving.
if (ReadPerformanceCounter(0)!=ReadPerformanceCounter(0)) {
	Trap();
	}
#endif


// The following test is broken because new PIIs update information
// in the 40-48 bit range.  We need to fix this test so it works
// correctly on all processors.  Intel (old and new) and AMD.
#if 0
// Make sure both performance counters are positive.
if ((ReadPerformanceCounter(0)&0x0000008000000000) ||
	(ReadPerformanceCounter(1)&0x0000008000000000)) {
	Trap();
	}
#endif


#ifdef DEBUG

// Make sure that no APIC errors have been logged.
// Before reading the APIC status, we must write to the register
// first.  That updates it with the most recent data which we then
// read.  We do not need to clear the register after reading.
// The next time we write, it will latch any new status which we
// will then read.
{
ULONG ApicStatus;
WriteAPIC(APICSTATUS,0);
if (ApicStatus=ReadAPIC(APICSTATUS)) {
	ApicErrorHistogram[ApicStatus&MAXAPICERRORHISTOGRAM]++;
	Trap();
	}
}

#endif


// See if CR0 has changed since the last interrupt.

#if 0
// If we are switching between realtime threads double check
// that the CR0 floating point state is correct.  Trap if not.

if (currentthread!=windowsthread && ) {
	Trap();
	}
#endif


// At this point we save the floating point state if required.

if (currentthread->FloatState!=NULL) {

	// If there is more than 1 thread using FLOAT or MMX, then
	// we need to save the current thread's floating point state.

	if (activefloatthreadcount>1) {

		ULONG currentCR0;
		ULONG fpubits;

		currentCR0=ReadCR0();

		// If CR0 has either the TS or EM bit set, then clear those
		// bits in CR0 so we can save the floating point state without
		// causing an exception.  
		// Trap if clearing the bits fails.
		if (fpubits=(currentCR0&(FPUTASKSWITCHED|FPUEMULATION))) {

			currentCR0^=fpubits;
			WriteCR0(currentCR0);

			#if DEBUG

			if (currentCR0^ReadCR0()) {
				Trap();
				}

			#endif

			}

		SaveThreadFloatState(currentthread->FloatState);

		}

	}


if (YIELD==currentthread->state) {
	// Save away the mark and time for this thread.
	currentthread->Mark=((PYIELDTIME)(currentthread->data))->Mark;
	currentthread->Delta=((PYIELDTIME)(currentthread->data))->Delta;
	}


// I need to have a complete set of statistics on all of the threads
// available to the scheduler - so it can make a good decision about what
// thread to run.  That means I have to log the threadswitchtime and update
// the current thread's duration BEFORE I actually do the switch itself.

// Log threadswitch time.
lastthreadswitchtime=RtTime();

// Update just switched out thread's duration.
currentthread->Statistics->DurationRunThisPeriod+=lastthreadswitchtime-currentthread->Statistics->ThisTimesliceStartTime;



// Now we record last thread and switch to the next thread to run.
lastthread=currentthread;


if (YIELDAFTERSPINLOCKRELEASE==currentthread->state) {
	if ((currentthread->data&3)!=3) {
		Trap();
		}
	currentthread->data&=~(3);
	if (YIELDAFTERSPINLOCKRELEASE==((ThreadState *)currentthread->data)->state ||
		YIELD==((ThreadState *)currentthread->data)->state ||
		EXIT==((ThreadState *)currentthread->data)->state ||
		DEAD==((ThreadState *)currentthread->data)->state) {
		Trap();
		}
	// Update state of currentthread to RUN.
	currentthread->state=RUN;
	// Just unblocked thread is now current thread to run.
	currentthread=(ThreadState *)currentthread->data;
	// Update the state of the just unblocked thread so that it can run.
	currentthread->state=RUN;
	goto nextthreadselected;
	}




loopcount=0;

nextthread:
currentthread=currentthread->next;

if (loopcount++>1000) {
	Trap();
	}

if (currentthread!=windowsthread && (BLOCKEDONSPINLOCK==currentthread->state /*||
	SPINNINGONSPINLOCK==currentthread->state*/)) {
	// We allow switching back to windows even when it is blocked on a
	// spinlock so that interrupts can get serviced.
	// All other threads will never get switched to while they are blocked
	// or spinning on a spinlock.
	goto nextthread;
	}


if (YIELD==currentthread->state) {
	if ((lastthreadswitchtime-currentthread->Mark)>=currentthread->Delta) {
		// We can run this thread.  It has finished its Yield.
		currentthread->state=RUN;
		}
	else {
		// This thread is not runnable.  Make sure that we are not trying
		// to run it because it is holding a spinlock and is thus holding
		// off some other thread.  For now, just trap if that is the case.
		if (lastthread!=windowsthread &&
			BLOCKEDONSPINLOCK==lastthread->state &&
			(ThreadState *)(lastthread->data&~(3))==currentthread) {
			Trap();
			}
		goto nextthread;
		}
	}

nextthreadselected:

// Now that we have the next thread to run, increment thread switch count.

threadswitchcount++;




// Update new thread statistics.
currentthread->Statistics->TimesliceIndex++;
currentthread->Statistics->ThisTimesliceStartTime=lastthreadswitchtime;
if (currentthread->Statistics->ThisPeriodStartTime==0) {
	currentthread->Statistics->ThisPeriodStartTime=lastthreadswitchtime;
	}
if ((lastthreadswitchtime-currentthread->Statistics->ThisPeriodStartTime)>currentthread->Statistics->Period) {
	// We have entered a new period.
	// Update starttime and index.
	currentthread->Statistics->ThisPeriodStartTime+=currentthread->Statistics->Period;
	currentthread->Statistics->PeriodIndex++;
	// Make sure we haven't dropped periods on the floor.  If so, jump to current
	// period.
	if ((lastthreadswitchtime-currentthread->Statistics->ThisPeriodStartTime)>currentthread->Statistics->Period) {
		ULONGLONG integralperiods;
		integralperiods=(lastthreadswitchtime-currentthread->Statistics->ThisPeriodStartTime)/currentthread->Statistics->Period;
		currentthread->Statistics->ThisPeriodStartTime+=integralperiods*currentthread->Statistics->Period;
		currentthread->Statistics->PeriodIndex+=integralperiods;
		}
	currentthread->Statistics->TimesliceIndexThisPeriod=0;
	currentthread->Statistics->DurationRunLastPeriod=currentthread->Statistics->DurationRunThisPeriod;
	currentthread->Statistics->DurationRunThisPeriod=0;
	}
currentthread->Statistics->TimesliceIndexThisPeriod++;



// Now restore the new threads floating point state if required.

if (currentthread->FloatState!=NULL) {

	// If there is more than 1 thread using FLOAT or MMX, then
	// we need to restore the current threads state.

	if (activefloatthreadcount>1) {

		ULONG currentCR0;
		ULONG fpubits;

		currentCR0=ReadCR0();

		// If CR0 has either the TS or EM bit set, then clear those
		// bits in CR0 so we can save the floating point state without
		// causing an exception.  
		// Trap if clearing the bits fails.
		if (fpubits=(currentCR0&(FPUTASKSWITCHED|FPUEMULATION))) {

			currentCR0^=fpubits;
			WriteCR0(currentCR0);

			#if DEBUG

			if (currentCR0^ReadCR0()) {
				Trap();
				}

			#endif

			}

		RestoreThreadFloatState(currentthread->FloatState);

		}

	}


#if 0
if (currentthread==windowsthread && activefloatthreadcount>1) {
	// Windows thread is being switched back in.
	// Restore CR0.  Most critical is the ts bit.
	ULONG currentCR0;

	currentCR0=ReadCR0();

	// The TS bit should currently NEVER be set when we switch from realtime
	// threads back to Windows.
	if (currentCR0&FPUTASKSWITCHED) {
		Trap();
		}

	// The EM bit should currently NEVER be set when we switch from realtime
	// threads back to Windows.
	if (currentCR0&FPUEMULATION) {
		Trap();
		}

	// The NE bit must ALWAYS be set when we switch from realtime to Windows.
	// NOTE: this is another CR0 bit that should be RESTORED!
	if (!(currentCR0&FPUEXCEPTION)) {
		Trap();
		}

	// Check if the TS bit state is different from its state when we left Windows.
	if ((currentCR0^LastWindowsCR0)&FPUTASKSWITCHED) {
		Trap();
		// Switch TS back to the state it was when we took control from Windows.
		currentCR0^=FPUTASKSWITCHED;
		}

	// See if any other bits have changed.  There shouldn't be any other bits that
	// change unless the debugger is mucking around.
	if (currentCR0^LastWindowsCR0) {
		Trap();
		}

	}
#endif


// Setup to load CR0.
NextCR0=ReadCR0();

// Now make sure CR0 state has correct defaults for this thread.
// If thread does not use FP or MMX, then EM=1.  Otherwise EM=0.
// NE=1, ET=1, TS=0, MP=1 are other default settings.

// Set desired defaults.
NextCR0&=~(FPUMASK);
NextCR0|=FPUEXCEPTION|FPU387COMPATIBLE|FPUMONITOR;
if (currentthread->FloatState==NULL) {
	// Turn on traps for FP or MMX instructions in non MMX/FP threads.
	// We do this only when IDT switching is turned on since we do
	// NOT want to cause traps or faults that might confuse windows.
	NextCR0|=FPUEMULATION;
	}

// If we current thread is windows, then make sure we restore
// CR0 to the state it had when we took control from windows.

if (currentthread==windowsthread) {
	NextCR0=LastWindowsCR0;
	}


NextIDT=RtThreadIDT;
if (currentthread==windowsthread) {
	NextIDT=WindowsIDT;
	}


#ifdef DEBUG

// Make sure that the ISR bit for our interrupt is NOT set at this point.
// It should be clear.  Trap if set and force clear.

if (ReadAPIC(0x100+(ApicTimerVector/32)*0x10)&(1<<(ApicTimerVector%32))) {

	Trap();

	// The only way to clear this is to EOI the APIC.  If our EOI does
	// not clear it then we are screwed.

	WriteAPIC(APICEOI, 0);

	}

#endif


#ifdef MASKABLEINTERRUPT

// WARNING WARNING if you move this up to the beggining of the routine,
// do NOT forget to change lastthread to currentthread!!!!!!

if (lastthread!=windowsthread) {

// EOI the APIC for the maskable rt thread interrupt.

if (ReadAPIC(0x100+(RTMASKABLEIDTINDEX/32)*0x10)&(1<<(RTMASKABLEIDTINDEX%32))) {

	WriteAPIC(APICEOI, 0);

	}
else {

//	Trap();  May not happen if we RtYield!!!!

	}

}


// Make sure it is now clear.

if (ReadAPIC(0x100+(RTMASKABLEIDTINDEX/32)*0x10)&(1<<(RTMASKABLEIDTINDEX%32))) {

	Trap();

	WriteAPIC(APICEOI, 0);

	}

#endif


// In debug code, make sure ALL TMR bits are clear.  Trap if not.

#ifdef DEBUG
{
LONG tmr;

for (tmr=0x180;tmr<0x200;tmr+=0x10) {
	if (ReadAPIC(tmr)) {
		Trap();
		}
	}
}
#endif

// In debug code, make sure ALL ISR bits are clear.  Trap if not.

#ifdef DEBUG
{
LONG isr;

for (isr=0x100;isr<0x180;isr+=0x10) {
	if (ReadAPIC(isr)) {
		Trap();
		}
	}
}
#endif


#if 0

// In debug code, make sure ALL IRR bits except ours are clear.  Trap if not.

#ifdef DEBUG
{
LONG irr;

for (irr=0x200;irr<0x280;irr+=0x10) {
	if (ReadAPIC(irr)) {
		Trap();
		}
	}
}
#endif

#endif

// TODO: In debug code make sure all of our interrupts are still properly hooked.


if (lastthread->state==EXIT) {
	// Remove the previous thread from the list of threads to run as
	// it has exited.
	// Make sure we never exit from the Windows thread.
	if (lastthread==windowsthread) {
		Trap();
		lastthread->state=RUN; // put Windows thread back in RUN state
		}
	else {
		// If we get here, then the lastthread has exited and is NOT the
		// windows thread.  So remove it from the list of running realtime
		// threads.
		RemoveRtThread(lastthread);

		// Now atomically add it to the list of dead realtime threads - so its resources
		// will be released the next time RtCreateThread or RtDestroyThread are
		// called.

		lastthread->next=RtDeadThreads;
		while (RtpCompareExchange(&(ULONG)RtDeadThreads, (ULONG)lastthread, (ULONG)lastthread->next)!=(ULONG)lastthread) {
			// If we get here, then the compare exchange failed because either another
			// thread was added to the list since we read RtDeadThreads,
			// or another Windows thread cleaned up the dead thread list and
			// RtDeadThreads is now null when it wasn't before.
			// Retry adding our thread to the list.
			lastthread->next=RtDeadThreads;
			}

		// Mask the realtime scheduler interrupt if there is only the windows thread.

		if (RtThreadCount<=1) {
			// Mask the local apic timer interrupt.
			*ApicTimerInterrupt=ApicTimerVector|MASKED|PERIODIC;
			// Mask the performance counter interrupt.
			DisablePerformanceCounterInterrupt();
			}

		}

	}


// Make sure if there are any realtime threads that the local timer interrupt
// is enabled.

if (RtThreadCount>1) {

/*
#ifdef DEBUG

	if (*ApicTimerInterrupt!=(ApicTimerVector|UNMASKED|PERIODIC)) {
		Trap();
		}

#endif
*/

	// Unmask the local apic timer interrupt.
	*ApicTimerInterrupt=(ApicTimerVector|UNMASKED|PERIODIC);
	}


if (currentthread==windowsthread) {

	// Mask the performance counter interrupt.

	DisablePerformanceCounterInterrupt();

#ifdef CATCH_INTERRUPTS_DISABLED_TOO_LONG
    *ApicPerfInterrupt=ApicPerfVector|UNMASKED;
    EnablePerfCounters=StopCounter;
#else
	EnablePerfCounters=0;
#endif

#ifdef MASKABLEINTERRUPT

	// Reset the performance counters.  Perfomance HIT.
	// We should NOT need to do this.
	SetTimeLimit( 0, 0);

	// Unmask the normal interrupts at the local apic.
	*ApicIntrInterrupt=EXTINT|UNMASKED;

	if (InjectWindowsInterrupt) {
		HandleWindowsInterrupt.offset=InjectWindowsInterrupt;
		InjectWindowsInterrupt=0;
		InjectedInterruptCount++;
		}

	// Enable the interrupt that will get us out of windows.
	// Leave the maskable performance counter interrupt masked.

	// That is critical since otherwise we get invalid dyna-link
	// blue screens.

	WriteAPIC(APICTPR, 0x30);

#endif

	}

else {

	LONG timelimit;

#ifdef MASKABLEINTERRUPT
	// Mask normal interrupts at the local apic.
	// We do this instead of running with interrupts disabled.
	// On 9x where the IO apic is not used this will work the same
	// as disabling interrupts - except that now we can make the
	// syncronization that depends on PUSHFD/CLI/STI/POPFD work properly.

	// I can fix ntkern so it will be NMI safe, but this is the
	// easiest and safest way to get the current functions safe
	// it also gets us any windows functions that ntkern calls
	// that depend on PUSHFD/CLI/STI/POPFD syncronization.

	*ApicIntrInterrupt=EXTINT|MASKED;

	// Eat APIC timer interrupts that fire during realtime threads.
	// The only way that should happen is if someone in windows
	// masked interrupts enough to hold off the APIC timer interrupt
	// so much that the next one fired while we were still running
	// our realtime threads.
	
	*ApicTimerInterrupt=ApicTimerVector|MASKED|PERIODIC;

	// Enable all of the local apic interrupts.  Including the
	// performance counter interrupt.
	// Leave the maskable performance counter interrupt masked.

	WriteAPIC(APICTPR, 0);

#endif

	// Setup the performance counters for the next interrupt.

	timelimit=(LONG)(RtCpuCyclesPerUsec*1000*currentthread->Statistics->Duration/currentthread->Statistics->Period);
	if (timelimit<MINIMUMCYCLECOUNT) {
		// In this case, we run instructions instead of cycles so that we
		// can guarantee that the thread runs at least a little each slice.
		timelimit=10;
		EnablePerfCounters=StartInstructionCounter;
		}
	else {
		EnablePerfCounters=StartCycleCounter;
		}

	SetTimeLimit(timelimit, 0);

	// Unmask the performance counter interrupt.

	PerformanceInterruptState&=~(MASKPERF0INT);
	*ApicPerfInterrupt=ApicPerfVector|UNMASKED;

	}


// Load irql for thread we are entering.
*pCurrentIrql=(KIRQL)currentthread->irql;

LoadThreadStatePointer();

RestoreSegmentState();

RestoreRegisterState();

RestoreThreadStack();

RestoreOriginalDS();

LoadCR0(NextCR0);

RestoreEAX();



LoadIDT(NextIDT);


// Fix up ds so we can access the memory we need to.
// We need a valid ds so we can save the IDT and so that we can
// check our reenter count.

__asm{
	push ds
	mov ds, cs:RealTimeDS
	}

SaveIDT(DebugIDT);

// Paranoia:  Decrement reenter count.  Make sure it is zero.
// Note that until I fix the interrupt pending problem once and
// for all, I MUST decrement my reenter count BEFORE I jump to
// any injected interrupts.  Since when I jump to injected interrupts,
// I WILL get reentered sometimes before the IRET occurs.  That
// is OK.  All that means is that Windows sat in interrupt service
// routines for the rest of the current time slice AND that Windows
// reenabled interrupts.
__asm {
	dec SwitchRtThreadReenterCount
	pop ds
	jz leaveclean
	int 3
leaveclean:
	}


#ifdef MASKABLEINTERRUPT

// If we are returning to windows and we allowed interrupts when we
// left windows, and we raised irql, then we need to lower irql
// here.  That will cause all of the pending dpcs to get processed.

// We are NOT guaranteed to have a flat stack, so we MUST get our
// own FLAT DS before we try to touch our variables.

__asm {
	push ds
	push ecx
	mov ds, cs:RealTimeDS
	mov ecx, currentthread
	cmp ecx, windowsthread
	jnz irqllowered
	cmp EnabledInterrupts, 1
	jl irqllowered
	jz checkirql

	// If we get here, then EnabledInterrupts is greater than 1.  That
	// should NEVER be the case.  We need to crash and burn in that case.
	int 3

checkirql:
	int 3
	dec EnabledInterrupts
	mov ecx, pCurrentIrql
	movzx ecx, byte ptr[ecx]
	cmp ecx, OriginalIrql
	je irqllowered
	ja lowerirql

	// We only get here, if the OriginalIrql is greater than the CurrentIrql.
	// That will only happen if we screwed up.
	int 3

lowerirql:

	mov ecx, OriginalIrql
	pushad
	call WrapKfLowerIrql
	popad

irqllowered:
	// Restore registers.
	pop ecx
	pop ds
	}


// Here we inject any interrupts required into windows.  This code
// should almost NEVER get run.

__asm {
	// Save space on stack for far return.
	sub esp,8
	// Get a DS we can access our data with.
	push ds
	mov ds, cs:RealTimeDS
	// Check if we need to inject an interrupt into windows.
	test HandleWindowsInterrupt.offset,0xffffffff
	jz skipit
	// Set up the stack with the appropriate address.
	push eax
	xor eax,eax
	mov ax, HandleWindowsInterrupt.selector
	mov dword ptr[esp+12], eax
	mov eax, HandleWindowsInterrupt.offset
	mov dword ptr[esp+8], eax
	pop eax
	// Clean up DS and jump to handler.
	pop ds
	retf
skipit:
	// Restore DS and cleanup stack.
	pop ds
	add esp,8
	}

#endif

TurnOnPerformanceCounters();

Return();

}



#ifdef CATCH_INTERRUPTS_DISABLED_TOO_LONG


VOID
__declspec(naked)
InterruptsHaveBeenDisabledForTooLong (
    VOID
    )

/*

Routine Description:

    This is our replacement Windows NMI handler when we are trying to catch
    code that turns off interrupts too long.  If we determine that we should
    not handle this interrupt, we pass it on to the original handler.

Arguments:


Return Value:

    None.

*/


{

__asm {
    pushad
    cld
    mov ebp,esp
    sub esp,__LOCAL_SIZE
    }

// In order for this NMI to have been generated by the performance counters,
// we must have a machine that has the following state.
// 1) Supports the CPUID instruction.
// 2) Has a local APIC.
// 3) Has the local APIC enabled.
// 4) Has MSRs.
// 5) Has performance counters.
// 6) Has performance counter 1 enabled, interrupt on, counting cycles w/ints off
// 7) Performance counter 1 is greater than 0.

// If any of the above requirements are not met, this NMI was not generated by
// the performance counters and we should run the original NMI handler code.

// If all of the above requirements are met, then we check if we are in the
// debugger.  If so, then we reload our count and exit.  If not, then we break
// into the debugger if it is present otherwise we bugcheck.

/*

    if (CpuIdOk()) {

        CPUINFO cpu;
        ULONG PerfControlMsr=0;

        if (thecpu.==) {
        
        }
        
        


        // Make sure the machine has APIC and perf counters.

        CpuId(0, &cpu);

        if (cpu.eax) {

            CpuId(1, &cpu);

            if (cpu.edx&)
        }
        
        
    }

*/

    InterlockedIncrement(&NmiInterruptCount);


    if ((ReadPerformanceCounter(1)&((PERFCOUNTMASK+1)/2))==0 &&
         ReadIntelMSR(EVENTSELECT1)==StartInterruptsDisabledCounter
        ) {

        // We have caught someone holding off interrupts for too long.
        // See if it is the debugger.  If so, then reload our counter so
        // that it will fire again later and drop this NMI on the floor.
        // If we are not in the debugger, then we need to break in on the 
        // offending code so we can see who is breaking the rules and what
        // they are doing.

        if (*KdEnteredDebugger) {

            // We are in the debugger, so simply reload the performance
            // counter so it will fire again later, and eat this interrupt
            // and continue.

            // Setup the count.
            WriteIntelMSR(PERFORMANCECOUNTER1, -MaxUsecWithInterruptsDisabled*RtCpuCyclesPerUsec);

        }
        else {

            // We have caught a badly behaved peice of code in the middle
            // of its work.  Stop in the debugger so we can identify the
            // code and what it is doing.  Note that we do this by munging
            // the stack so that when we iret we will run DbgBreakPoint with
            // a stack setup so that it looks like DbgBreakPoint was called
            // by the offending code, even though it wasn't.  This has the
            // nice side effect of clearing out the NMI.

            // Note that if we want to be sneaky, we can erase our tracks
            // by restoring the normal windows NMI handler so that it is
            // difficult for people to figure out how they are getting caught
            // and try to work around our code by patching us or turning off
            // our interrupt source.

            DbgPrint("Interrupts have been turned off for more than %d usec.\nBreaking in on the offending code.\n", MaxUsecWithInterruptsDisabled);

            DbgBreakPoint();

            // Restart the counter when we continue running.
            WriteIntelMSR(PERFORMANCECOUNTER1, -MaxUsecWithInterruptsDisabled*RtCpuCyclesPerUsec);

        }

    }
    else {

        // This is NMI is coming from a source other than the performance
        // counters.  Send it off to the standard Windows NMI handler.

        __asm {
            add esp,__LOCAL_SIZE
            popad
            push OriginalWindowsNmiHandler
            ret
            }

    }



__asm {
    add esp,__LOCAL_SIZE
    popad
    }


// Now we do an IRET to return control to wherever we are going.
// Note that this clears the holdoff of further NMI's which is what we want.
// This code path gets run whenever we reload the perf counter and eat the NMI
// as well as when we break in on offending drivers.

Return();

}



VOID
ResetInterruptsDisabledCounter (
    PVOID Context,
    ThreadStats *Statistics
    )
{

while(TRUE) {

    // Reload the count.
    WriteIntelMSR(PERFORMANCECOUNTER1, -MaxUsecWithInterruptsDisabled*RtCpuCyclesPerUsec);

    // Start the counter counting cycles with interrupts pending and interrupts
    // disabled.
    WriteIntelMSR(EVENTSELECT1, StartInterruptsDisabledCounter);

    RtYield(0, 0);

    }

}


VOID
SetupInterruptsDisabledPerformanceCounter (
    VOID
    )
{

    // Event counter one counts cycles with interrupts disabled and interrupts
    // pending.  We set this counter up so that it overflows when interrupts
    // have been disabled with interrupts pending for more than
    // InterruptsDisabledLimit microseconds.

    // Disable the counter while we are setting it up.
    WriteIntelMSR(EVENTSELECT1, STOPPERFCOUNTERS);

    // Setup the count.
    WriteIntelMSR(PERFORMANCECOUNTER1, -MaxUsecWithInterruptsDisabled*RtCpuCyclesPerUsec);

    // Now unmask performance counter interrupt.
    *ApicPerfInterrupt=ApicPerfVector|UNMASKED;

    // Start the counter counting cycles with interrupts pending and interrupts
    // disabled.
    WriteIntelMSR(EVENTSELECT1, StartInterruptsDisabledCounter);
    
}

#endif




HANDLE
RtpCreateUniqueThreadHandle (
    VOID
    )
{

    ULONG newhandle,lasthandle;

    newhandle=RtLastUniqueThreadHandle;

    while ((newhandle+1)!=(lasthandle=RtpCompareExchange(&RtLastUniqueThreadHandle,newhandle+1,newhandle))) {
        newhandle=lasthandle;
    }

    return (HANDLE)(newhandle+1);

}




NTSTATUS
RtpInitializeThreadList (
    VOID
    )
{

    ThreadState *initialthread;


    ASSERT( currentthread == NULL && windowsthread == NULL );


    // Allocate a thread block for Windows.

    initialthread=(ThreadState *)ExAllocatePool( NonPagedPool, sizeof(ThreadState) );
    if (initialthread==NULL) {
        return STATUS_NO_MEMORY;
    }


    // There is no StackBase for Windows.
    initialthread->StackBase=NULL;


    // Allocate a statistics block for Windows.

    initialthread->Statistics=(ThreadStats *)ExAllocatePool( NonPagedPool, sizeof(ThreadStats) );
    if (initialthread->Statistics==NULL) {
        ExFreePool(initialthread);
        return STATUS_NO_MEMORY;
    }

    // Initialize the statistics block.
    RtlZeroMemory(initialthread->Statistics, sizeof(ThreadStats));

    initialthread->Statistics->Period=MSEC;
    initialthread->Statistics->Duration=(MSEC*133)/RtCpuCyclesPerUsec;
    initialthread->Statistics->Flags=USESFLOAT|USESMMX;


    // Allocate space for floating point state for Windows.

    initialthread->FloatBase=ExAllocatePool( NonPagedPool, FLOATSTATESIZE+FXALIGN );

    if (initialthread->FloatBase==NULL) {
        ExFreePool(initialthread->Statistics);
        ExFreePool(initialthread);
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(initialthread->FloatBase, FLOATSTATESIZE+FXALIGN);

    // Now 16 byte align the floating point state pointer so fxsave/fxrstor can
    // be used if supported.

    initialthread->FloatState=(PVOID)(((ULONG)initialthread->FloatBase+(FXALIGN-1))&~(FXALIGN-1));

    // Get a handle for the windows thread.
    initialthread->ThreadHandle=RtpCreateUniqueThreadHandle();

    // Set initial state and data for the windows thread.
    initialthread->state=RUN;
    initialthread->data=0;

    // Setup windows thread state.
    initialthread->next=initialthread;
    initialthread->previous=initialthread;

    // Initialize list spinlock.
    KeInitializeSpinLock(&RtThreadListSpinLock);

    // Count it as a float thread.
    activefloatthreadcount++;

    // Update our RT thread count.
    RtThreadCount++;

    // Allocate Windows thread its CPU.  For now we give it at least 133MHz.
    RtCpuAllocatedPerMsec=(ULONG)(initialthread->Statistics->Duration);

    // Add it to the list.
    windowsthread=currentthread=initialthread;

    return STATUS_SUCCESS;

}




VOID
HookWindowsInterrupts (
    ULONG TimerVector,
    ULONG ErrorVector
    )
{

    // Hook the NMI interrupt vector.
    //HookInterrupt(NMIIDTINDEX, &OriginalNmiVector, SwitchRealTimeThreads);

#ifdef CATCH_INTERRUPTS_DISABLED_TOO_LONG
    HookInterrupt(NMIIDTINDEX, &OriginalNmiVector, InterruptsHaveBeenDisabledForTooLong);
    OriginalWindowsNmiHandler=OriginalNmiVector.lowoffset | OriginalNmiVector.highoffset<<16;
#endif

    // Hook the maskable interrupt vector as well.
    HookInterrupt(TimerVector, &OriginalMaskableVector, SwitchRealTimeThreads);

    // Hook the APIC error interrupt vector.
    // Note that we only do this if both of the local APIC vectors match the
    // defaults, since otherwise the HAL will have already loaded a vector
    // for handling APIC errors - and we don't want to hook theirs out.
    if (TimerVector==MASKABLEIDTINDEX && ErrorVector==APICERRORIDTINDEX) {
        // HAL has not programmed the IDT already.  (Yes, the hal could
        // potentially use the same vectors we do, but none of the existing
        // hals do.)
        HookInterrupt(ErrorVector, &OriginalApicErrorVector, RtpLocalApicErrorHandler);
    }

}




VOID
SetupPerformanceCounters (
    VOID
    )
{

    // Initialize the performance counters.
    // Event counter zero counts cycles.  Interrupt disabled.

    // Counters disabled.
    WriteIntelMSR(EVENTSELECT0, STOPPERFCOUNTERS);

    // Zero the counts.
    WriteIntelMSR(PERFORMANCECOUNTER0, 0);

    if (CPUManufacturer==INTEL && CPUFamily==0xf) {

        // Setup escr register in Willamette processor.
        WriteIntelMSR(WILLAMETTEESCR0, 0x05fffe0c);

    }

    // Now setup performance counter interrupt.
    *ApicPerfInterrupt=ApicPerfVector|MASKED;

}




#ifndef UNDER_NT

#pragma warning ( disable : 4035 )

ULONGLONG
__declspec(naked)
_cdecl
AllocateGDTSelector (
    ULONG HiDWORD,
    ULONG LowDWORD,
    ULONG flags
    )
{

    VxDJmp( _Allocate_GDT_Selector );

}


ULONG
__declspec(naked)
_cdecl
FreeGDTSelector (
    ULONG Selector,
    ULONG flags
    )
{

    VxDJmp( _Free_GDT_Selector );

}

#pragma warning ( default : 4035 )

#endif




NTSTATUS
InitializeRealTimeStack (
    VOID
    )
{

    ULONGLONG gdtselector;

    // Allocate and initialize a new code segment descriptor in
    // the GDT.

#ifdef UNDER_NT
    gdtselector=0x8;
#else
    gdtselector=AllocateGDTSelector(0x00cf9b00, 0x0000ffff, 0);
#endif

    RtExecCS=(WORD)gdtselector;


#ifdef USERING1

    // Allocate and initialize a ring 1 code segment descriptor in
    // the GDT for our real time threads.

#ifdef UNDER_NT
    gdtselector=0x8;
#else
    gdtselector=AllocateGDTSelector(0x00cfbb00, 0x0000ffff, 0);
#endif

    RtThreadCS=(WORD)gdtselector;

#else

    RtThreadCS=RtExecCS;

#endif

    // Allocate and initialize a new data segment descriptor in 
    // the GDT.

#ifdef UNDER_NT
    gdtselector=0x10;
#else

    //gdtselector=AllocateGDTSelector(0x00cf9300,0x0000ffff, 0);

    // To catch null pointer accesses in realtime threads, we make this selector
    // expand down and put the bottom 64k of memory off limits.
    gdtselector=AllocateGDTSelector(0x00c09700,0x0000000f, 0);
#endif

    RealTimeDS=(WORD)gdtselector;
    RealTimeSS=(WORD)gdtselector;


#ifdef GUARD_PAGE

    // Now allocate a TSS for our realtime thread double fault handler.
    {

    ULONG highdword;
    ULONG lowdword;

    lowdword=(ULONG)&RtTss;
    highdword=lowdword&0xffff0000;
    lowdword<<=16;
    lowdword|=sizeof(RtTss)-1;
    highdword|=highdword>>16;
    highdword&=0xff0000ff;
    highdword|=0x00108900;

    gdtselector=AllocateGDTSelector(highdword, lowdword, PAGEFRMINST);

    RtExecTSS=(WORD)gdtselector;

    }


    // Allocate and initialize a read only Ring 3data segment descriptor
    // in the GDT that our ring 3 code can use to look at our
    // data structures.

    gdtselector=AllocateGDTSelector(0x00cff100,0x0000ffff, 0);

    RtRing3Selector=(WORD)gdtselector;

#endif


    // Point our stack segment at it.
    RealTimeStack.ss=RealTimeSS;

    // Point our stack pointer at the top of our local stack.
    RealTimeStack.esp=(ULONG)(LocalStack+LOCALSTACKSIZE-1);


    if (!RtExecCS || !RtThreadCS || !RealTimeDS || !RealTimeSS) {
        return STATUS_UNSUCCESSFUL;
    }


    return STATUS_SUCCESS;

}




NTSTATUS
RtpCalibrateCpuClock (
    ULONG *cyclesperusec
    )
{

    ULONG i;
    ULONG cycles;
    ULONG *histogram;

    #define MAXCYCLESPERTICK 16384
    #define CPUCALIBRATECOUNT 1024

    // This is the number of times we will measure the CPU clock speed.
    // Each measurement takes ~24us so measuring it 1024 times will take
    // about 25ms.

    // To do this calibration, we measure the CPU clock speed quickly
    // many many times, and then we look at the distribution and choose
    // the most frequently measured value as the correct CPU speed.

    if (RtRunning) {
        Trap();
        return STATUS_UNSUCCESSFUL;
    }

    histogram=ExAllocatePool(NonPagedPool, MAXCYCLESPERTICK*sizeof(ULONG));

    if (histogram==NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(histogram, MAXCYCLESPERTICK*sizeof(ULONG));

    // First we collect the measurements.

    for (i=0; i<CPUCALIBRATECOUNT; i++) {

        // Make the measurement.  Note that interrupts must be disabled.
        SaveAndDisableMaskableInterrupts();

        cycles=MeasureCPUCyclesPerTick();

        RestoreMaskableInterrupts();

        // Make sure we stay within our measurement limits.  So we don't
        // trash memory.
        if (cycles>=MAXCYCLESPERTICK) {
            cycles=MAXCYCLESPERTICK-1;
        }

        histogram[cycles]++;

    }


    // Stop if we have hit the limits of our histogram.  This will happen when
    // someone ships a processor that runs faster than MAXCYCLESPERTICK-1 MHz.

    if (histogram[MAXCYCLESPERTICK-1]) {
        dprintf(("This CPU runs faster than %d MHz.  Update MAXCYCLESPERTICK!", MAXCYCLESPERTICK-1));
        Break();
    }


    // Now process the measurements and choose the optimal CPU speed.

    {
    ULONG totalcount;

    cycles=1;
    totalcount=0;

    // Scan through all of the possible measurement values looking for
    // the most frequently reported one.

    // We ignore measurements of zero, since they indicate some sort of error
    // occured in MeasureCPUCyclesPerTick.

    // Count any measurements that failed, so we properly quit the scan as soon
    // as we have considered all the measurements we took.

    totalcount+=histogram[0];

    for (i=1; i<MAXCYCLESPERTICK; i++) {

        if (histogram[i]>histogram[cycles]) {
            cycles=i;
        }

        totalcount+=histogram[i];

        // Quit if we have already scanned all the measurements.

        if (totalcount>=CPUCALIBRATECOUNT) {
            break;
        }

    }

    }


    ExFreePool(histogram);

    *cyclesperusec=(ULONG)(((ULONGLONG)cycles*1193182+(1000000/2))/1000000);


    dprintf(("RealTime Executive measured a CPU clock speed of %d MHz.", *cyclesperusec));


    return STATUS_SUCCESS;

}


NTSTATUS
RtpMeasureSystemBusSpeed (
    ULONG CpuCyclesPerUsec,
    ULONG *SystemBusCyclesPerUsec
    )

{

    ULONGLONG starttime, finaltime;
    ULONG finalcount;
    ULONG OriginalTimerInterruptControl;
    ULONG OriginalTimerInitialCount;
    ULONG OriginalTimerDivide;

    #define STARTCOUNT 0xffffffff

    // Save the local APIC timer state.

    OriginalTimerDivide=ReadAPIC(APICTIMERDIVIDE);
    
    OriginalTimerInterruptControl=ReadAPIC(APICTIMER);

    OriginalTimerInitialCount=ReadAPIC(APICTIMERINITIALCOUNT);

    // Make sure the timer interrupt is masked and is setup as a
    // one shot counter.  Note that we are masking the interrupt, so we may
    // caused dropped interrupts while doing this calibration if there
    // is other code in the system using the local APIC timer.

    // If there is not a valid interrupt vector in the timer, then put one
    // there.  Otherwise the local apic logs a received an illegal vector
    // error and with debug bits we trap in switchrealtimethreads.

    if ( (OriginalTimerInterruptControl&VECTORMASK)==0 ) {
        OriginalTimerInterruptControl|=ApicTimerVector;
    }

    WriteAPIC(APICTIMER, (OriginalTimerInterruptControl&VECTORMASK)|MASKED|ONESHOT);

    // Now calibrate the timer.  We use the already calibrated CPU speed
    // to calibrate the timer.

    // We calibrate the timer by setting it to count down from its max,
    // delaying 10us, and then calculating the number of counts per usec.

    // First make sure the timer is zeroed.  If not zero it.  That will
    // stop it counting.

    if (OriginalTimerInitialCount) {
        // On Win9x the OriginalTimerInitialCount should always be zero.
        // On NT, it won't be for hals that use the local APIC.
#ifndef UNDER_NT
        Trap();
#endif
        WriteAPIC(APICTIMERINITIALCOUNT, 0);
    }

    // Make sure counter is stopped.  If not, then punt.

    if (ReadAPIC(APICTIMERINITIALCOUNT) || 
        ReadAPIC(APICTIMERCURRENTCOUNT)) {
        Trap();
        return STATUS_UNSUCCESSFUL;
    }

    // Setup the timer to count single bus cycles.

    WriteAPIC(APICTIMERDIVIDE, DIVIDEBY1);

    // Set the timer to its maximum possible count.  This will start
    // the timer counting.

    SaveAndDisableMaskableInterrupts();

    finaltime=starttime=ReadCycleCounter();

    WriteAPIC(APICTIMERINITIALCOUNT, STARTCOUNT);

    while ((ULONG)(finaltime-starttime)<10*RtCpuCyclesPerUsec) {
        finaltime=ReadCycleCounter();
    }

    finalcount=ReadAPIC(APICTIMERCURRENTCOUNT);

    RestoreMaskableInterrupts();

    // Stop the local apic timer.

    WriteAPIC(APICTIMERINITIALCOUNT, 0);


    // Restore local apic timer settings.

    WriteAPIC(APICTIMERDIVIDE, OriginalTimerDivide);

    WriteAPIC(APICTIMER, OriginalTimerInterruptControl);

    WriteAPIC(APICTIMERINITIALCOUNT, OriginalTimerInitialCount);

    
    // Calculate and return the bus speed of this system.

    *SystemBusCyclesPerUsec=(((STARTCOUNT-finalcount)*CpuCyclesPerUsec)+((ULONG)(finaltime-starttime)/2))/(ULONG)(finaltime-starttime);


    return STATUS_SUCCESS;

}




NTSTATUS
RtpCalibrateSystemBus (
    ULONG CpuCyclesPerUsec,
    ULONG *SystemBusCyclesPerUsec
    )
{

ULONG i;
ULONG cycles;
ULONG *histogram;

#define MAXSYSTEMCLOCKSPEED 4096
#define SYSTEMBUSCALIBRATECOUNT 512

// This is the number of times we will measure the system bus speed.
// Each measurement takes ~10us so measuring it 512 times will take
// about 5ms.

// To do this calibration, we measure the CPU clock speed quickly
// many many times, and then we look at the distribution and choose
// the most frequently measured value as the correct CPU speed.

if (RtRunning) {
    Trap();
    return STATUS_UNSUCCESSFUL;
}

histogram=ExAllocatePool(NonPagedPool, MAXSYSTEMCLOCKSPEED*sizeof(ULONG));

if (histogram==NULL) {
    return STATUS_NO_MEMORY;
}

RtlZeroMemory(histogram, MAXSYSTEMCLOCKSPEED*sizeof(ULONG));

// First we collect the measurements.

for (i=0; i<SYSTEMBUSCALIBRATECOUNT; i++) {

    cycles=0;

    RtpMeasureSystemBusSpeed(CpuCyclesPerUsec, &cycles);

    // Make sure we stay within our measurement limits.  So we don't
    // trash memory.
    if (cycles>=MAXSYSTEMCLOCKSPEED) {
        cycles=MAXSYSTEMCLOCKSPEED-1;
    }

    histogram[cycles]++;

}


// Stop if we have hit the limits of our histogram.  This will happen when
// someone ships a machine with a system bus that runs faster than MAXSYSTEMCLOCKSPEED-1 MHz.

if (histogram[MAXSYSTEMCLOCKSPEED-1]) {
    dprintf(("This system bus runs faster than %d MHz.  Update MAXSYSTEMCLOCKSPEED!", MAXSYSTEMCLOCKSPEED-1));
    Break();
}


// Now process the measurements and choose the optimal system bus speed.

{
ULONG totalcount;

cycles=1;
totalcount=0;

// Scan through all of the possible measurement values looking for
// the most frequently reported one.

// We ignore measurements of zero, since they indicate some sort of error
// occured in RtpMeasureSystemBusSpeed.

// Count any measurements that failed, so we properly quit the scan as soon
// as we have considered all the measurements we took.

totalcount+=histogram[0];

for (i=1; i<MAXSYSTEMCLOCKSPEED; i++) {

    if (histogram[i]>histogram[cycles]) {
        cycles=i;
    }

    totalcount+=histogram[i];

    // Quit if we have already scanned all the measurements.

    if (totalcount>=SYSTEMBUSCALIBRATECOUNT) {
        break;
    }

}

}

ExFreePool(histogram);

*SystemBusCyclesPerUsec=cycles;


dprintf(("RealTime Executive measured a system bus speed of %d MHz.", *SystemBusCyclesPerUsec));


return STATUS_SUCCESS;

}



// This function sets up and turns on the local APIC timer.  It
// programs it to generate an interrupt once per MS.  This is the
// interrupt that we will use to take control from Windows.  This
// is a maskable interrupt.

NTSTATUS
RtpEnableApicTimer (
    VOID
    )
{

// Stop the timer.

WriteAPIC(APICTIMERINITIALCOUNT, 0);

// Make sure counter is stopped.  If not, then punt.

if (ReadAPIC(APICTIMERINITIALCOUNT) || 
	ReadAPIC(APICTIMERCURRENTCOUNT)) {
	Trap();
	return STATUS_UNSUCCESSFUL;
	}

// Make the timer interrupt a periodic interrupt.  Leave it masked
// for now.

WriteAPIC(APICTIMER, ApicTimerVector|MASKED|PERIODIC);

// Setup the timer to count single cycles.

WriteAPIC(APICTIMERDIVIDE, DIVIDEBY1);

// Start the timer up.  It should fire every MS.
// This is our failsafe for getting control to Windows on aggressively
// power managed machines that turn off the CPU at every chance they
// get.  Unfortunately, I don't yet know of a performance counter that
// will count bus cycles or some other entity that doesn't stop when
// the processor is stopped.

WriteAPIC(APICTIMERINITIALCOUNT, 1000*RtSystemBusCyclesPerUsec);

return STATUS_SUCCESS;

}




VOID
RtpSetupStreamingSIMD (
    VOID
    )
{

    // If the CPU supports floating point MMX instructions, then make sure CR4
    // is setup so that fxsave and fxrstor instructions will work properly.

    // The OS should have already set this bit to the proper state.  If not,
    // then we trap in both retail and debug, since our setting this bit
    // may cause problems.

    if (CPUFeatures&FXSR) {

        ULONG reg;

        SaveAndDisableMaskableInterrupts();

        reg=ReadCR4();

        if (!(reg&OSFXSR)) {

            // Trap in retail and debug.
            Break();

            // Force the bit set.
            WriteCR4(reg|OSFXSR);

        }

        RestoreMaskableInterrupts();

    }

}




VOID
TurnOffLocalApic (
    VOID
    )
{

    SaveAndDisableMaskableInterrupts();

    // First mask and clear all of the local interrupt sources.
    WriteAPIC(APICPERF, MASKED);
    WriteAPIC(APICERROR, MASKED);
    WriteAPIC(APICTIMER, MASKED);
    WriteAPIC(APICNMI, MASKED);
    WriteAPIC(APICINTR, MASKED);

    // Now stop the local apic timer.
    WriteAPIC(APICTIMERINITIALCOUNT, 0);

    // Now disable the local apic.
    WriteAPIC(APICSPURIOUS,0x100);

    // Now turn it off with the MSRs.
    WriteIntelMSR(APICBASE, ReadIntelMSR(APICBASE)&(~0x800I64));

    RestoreMaskableInterrupts();

}




// This function is called when we are going down into hibernate and
// we hit the interrupts disabled phase.  We should be the last driver
// to get called in this situation.  We clear all of the APIC settings
// and then turn the APIC off.

NTSTATUS
ShutdownAPIC (
    VOID
    )
{

    // We only ever need to do this if we were running before.

    if (!RtRunning) {
        return STATUS_NOT_SUPPORTED;
    }

    TurnOffLocalApic();

    // Now read the timestamp counter shutdown count.  We use this to properly 
    // restore the time when we wake up - if needed.  (Will be needed for 
    // hibernate cases, will also be needed on ACPI machines that take power 
    // from CPU in S2 and S3.)
    RtShutdownTime=RtTime();

    return STATUS_SUCCESS;

}




NTSTATUS
RestartAPIC (
    VOID
    )
{

    CPUINFO cpuinfo;

    // First we decide if we need to reprogram the APIC.
    // We do this by first reading the CPU features with the cpu ID instruction.
    // Then we check if the APIC bit is set.  If so, then everything should
    // be OK.  In the debug code we validate a bunch of stuff to make sure.

    // If the APIC bit is NOT set in the features bit, then we know we need
    // to turn the APIC back on.  So we do.


    // We only ever need to do this if we were running before.

    if (!RtRunning) {
        return STATUS_NOT_SUPPORTED;
    }

    // Get the cpu features.

    if (!GetCpuId(1,&cpuinfo)) {
        return STATUS_UNSUCCESSFUL;
    }

    // If the APIC is already on, then do nothing.

    if (cpuinfo.edx&APIC) {
        return STATUS_UNSUCCESSFUL;
    }

    // Prevent Trap() in RtTime.  Fixup thread Statistic timestamps.

    if ((LONGLONG)((ULONGLONG)ReadCycleCounter()-lasttime)<0) {

        ULONGLONG RtStartupTime;
        ThreadState *thread;
        //KIRQL OldIrql;

        lasttime=0;

        RtStartupTime=RtTime();

        // Fix ThisTimesliceStartTime for the windows thread.
        windowsthread->Statistics->ThisTimesliceStartTime-=RtShutdownTime;
        windowsthread->Statistics->ThisTimesliceStartTime+=RtStartupTime;

        // Also fix up ThisPeriodStartTime for each and every rt thread.

        //KeAcquireSpinLock(&RtThreadListSpinLock,&OldIrql);

        thread=windowsthread;

        do {
            thread->Statistics->ThisPeriodStartTime-=RtShutdownTime;
            thread->Statistics->ThisPeriodStartTime+=RtStartupTime;
            thread=thread->next;
        } while(thread!=windowsthread);

        //KeReleaseSpinLock(&RtThreadListSpinLock, OldIrql);

    }

    if (!EnableAPIC()) {
        return STATUS_UNSUCCESSFUL;
    }

    if ( !NT_SUCCESS(RtpEnableApicTimer()) ) {
        return STATUS_UNSUCCESSFUL;
    }

    RtpSetupStreamingSIMD();

    SetupPerformanceCounters();

    SetTimeLimit( 0, 0);

    if (RtThreadCount>1) {

        WriteAPIC(APICTIMER, ApicTimerVector|UNMASKED|PERIODIC);

    }

    return STATUS_SUCCESS;

}


// Ideas:

// We should maintain a thread state and data associated with that state
// for all threads.

// We set the state/data and then transfer control to the executive.

// The default state of a thread is RUNNING.

// Other possible states, DEAD, YIELDEDTIMESLICE, YIELDEDPERIOD, 
// RELEASEDSPINLOCK (data=thread handle to yield to)

// We can add states as we please and define the new mappings between
// those states.

// For now my states are RUNNING, YIELDEDTIMESLICE, YIELDEDPERIOD, DEAD



#ifndef UNDER_NT

/* 

PowerFunc 
Power function. Can be one of these values:

#define PF_SUSPEND_PHASE1               0x00000000
#define PF_SUSPEND_PHASE2               0x00000001
#define PF_SUSPEND_INTS_OFF             0x00000002
#define PF_RESUME_INTS_OFF              0x00000003
#define PF_RESUME_PHASE2                0x00000004
#define PF_RESUME_PHASE1                0x00000005
#define PF_BATTERY_LOW                  0x00000006
#define PF_POWER_STATUS_CHANGE          0x00000007
#define PF_UPDATE_TIME                  0x00000008
#define PF_CAPABILITIES_CHANGE          0x00000009
#define PF_USER_ARRIVED                 0x0000000A
#define PF_PRE_FLUSH_DISKS              0x0000000B
#define PF_APMOEMEVENT_FIRST            0x00000200
#define PF_APMOEMEVENT_LAST             0x000002FF

Flags

#define PFG_UI_ALLOWED                  0x00000001
#define PFG_CANNOT_FAIL                 0x00000002
#define PFG_REQUEST_VETOED              0x00000004
#define PFG_REVERSE                     0x00000008
#define PFG_STANDBY                     0x00000010
#define PFG_CRITICAL                    0x00000020
#define PFG_RESUME_AUTOMATIC            0x00000040
#define PFG_USER_ARRIVED                0x00000080
#define PFG_HIBERNATE                   0x00000100
#define PFG_FAKE_RESUME                 0x00000200

Power flags. Can be one of these values: PFG_UI_ALLOWED (0x00000001)    
PFG_CANNOT_FAIL (0X00000002)  
PFG_REQUEST_VETOED (0X00000004)  Indicates that the user may not be available 
to answer questions prior to the suspend operation. If this value is not given
, higher levels of software may attempt some user interaction prior to 
accepting a suspend request.  
PFG_REVERSE (0x00000008)  Clear for suspend operations, set on resume.  
PFG_STANDBY (0x00000010)  Indicates a standby request when set as opposed to 
a suspend request.  
PFG_CRITICAL (0x00000020)  Set to notify power handlers of critical resume 
operations so that they may attempt to resume their clients as best as 
possible. Critical suspends do not reach the power handlers in order to 
maintain compliance with the APM 1.1 specification.  

//
//  Standard POWER_HANDLER priority levels.
//

#define PHPL_PBT_BROADCAST              0x40000000
#define PHPL_NTKERN                     0x60000000
#define PHPL_UNKNOWN                    0x80000000
#define PHPL_CONFIGMG                   0xC0000000
#define PHPL_PCI                        0xC8000000      // Must be after CONFIGMG
#define PHPL_ACPI                       0xD0000000      // Must be after CONFIGMG
#define PHPL_IOS                        0xD8000000      // Must be after ACPI
#define PHPL_PIC                        0xE0000000
#define PHPL_TIMER                      0xF0000000      // Must be after PIC

//
// If you want the ints off phase, you must have the A5 in the low byte
// of the priority level.
//
#define PHPL_HANDLE_INTS_OFF            0x000000A5

*/


ULONG ApicRestartCount=0;


POWERRET _cdecl RtpPowerHandler(POWERFUNC PowerFunc, ULONG Flags)
{

switch(PowerFunc) {

	case PF_SUSPEND_PHASE1:
		break;

	case PF_SUSPEND_PHASE2:
		break;

	case PF_SUSPEND_INTS_OFF:
			// We are going down into hibernate or suspend.  Shutdown the local APIC.
			// I HAVE to do this because on some machines we will go down into S3 on
			// suspend, and that will blow away the local apic state - since the processor
			// can be powered down when we are in S3.  Actually processor may lose power
			// even in S2.
			ShutdownAPIC();
		break;

	case PF_RESUME_INTS_OFF:
		if (!(Flags&PFG_FAKE_RESUME)) {

			// We are coming up out of hibernate or suspend.  Turn the local APIC back on.
			// Make sure we don't do it for the fake resume.  Only for the real resume.
			if (RestartAPIC()==STATUS_SUCCESS)
				ApicRestartCount++;
			}
		break;

	case PF_RESUME_PHASE2:
		break;

	case PF_RESUME_PHASE1:
		break;

	case PF_BATTERY_LOW:
		break;

	case PF_POWER_STATUS_CHANGE:
		break;

	case PF_UPDATE_TIME:
		break;

	case PF_CAPABILITIES_CHANGE:
		break;

	case PF_USER_ARRIVED:
		break;

	case PF_PRE_FLUSH_DISKS:
		break;

	case PF_APMOEMEVENT_FIRST:
		break;

	case PF_APMOEMEVENT_LAST:
		break;

	default:
		Trap();
		break;

	}

return PR_SUCCESS;

}




ULONG RtPowerManagementVersion=0;
ULONG RtSystemPowerMode=0;




DWORD
__declspec(naked)
_cdecl
VPOWERD_Get_Version (
    VOID
    )
{

    VxDJmp(_VPOWERD_Get_Version);

}




POWERRET
__declspec(naked)
_cdecl
VPOWERD_Get_Mode (
    PDWORD pMode
    )
{

    VxDJmp(_VPOWERD_Get_Mode);

}




POWERRET
__declspec(naked)
_cdecl
VPOWERD_Register_Power_Handler (
    POWER_HANDLER Power_Handler,
    DWORD Priority
    )
{

    VxDJmp(_VPOWERD_Register_Power_Handler);

}


// This is the priority that we use when we register with VPOWERD.
// This is the highest possible priority that can be used.
// This means that we will be called after everyone else when the machine is
// suspending, and before everyone else when the machine is resuming.
// That is exactly what we want.

#define HIGHESTPRIORITYVPOWERDCLIENT 0xffffff00


NTSTATUS RtpSetupPowerManagement()
{

    if ((RtPowerManagementVersion=VPOWERD_Get_Version())==0) {
        // VPOWERD is not loaded.  Punt!
        Trap();
        return STATUS_UNSUCCESSFUL;
    }

    if (VPOWERD_Get_Mode(&RtSystemPowerMode)!=PR_SUCCESS) {
        // VPOWERD get mode failed.  Punt!
        Trap();
        return STATUS_UNSUCCESSFUL;
    }

    // Register our power handler.
    if (VPOWERD_Register_Power_Handler((POWER_HANDLER)RtpPowerHandler, HIGHESTPRIORITYVPOWERDCLIENT|PHPL_HANDLE_INTS_OFF)!=PR_SUCCESS) {
        Trap();
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;

}

#endif  // UNDER_NT




#define MEASUREMENTCOUNT 1000


ULONG CyclesPerRtYield;
ULONG CyclesPerInt2;
ULONG CyclesPerInt2FloatSwitch;




// This routine calls the SwitchRealTimeThreads routine in several different ways
// in order to measure the overhead involved in switching between realtime threads.

VOID
MeasureRealTimeExecutiveOverhead (
    VOID
    )
{

    ULONG i;
    ULONGLONG starttime, stoptime;


    // Time thread switches.

    // First we time them when RtYield is used to transfer control.
    // Note that we must enable RtRunning in order to get RtYield to accept
    // the request.  We turn it on after interrupts are off and then turn
    // it back off before interrupts go on in order to fake out the check
    // in RtYield.

    SaveAndDisableMaskableInterrupts();

    RtRunning=1;

    // Get code/data in the cache.

    RtYield(0, 0);
    RtYield(0, 0);


    starttime=ReadCycleCounter();

    for (i=0; i<MEASUREMENTCOUNT; i++) {
        RtYield(0, 0);
    }

    stoptime=ReadCycleCounter();

    RtRunning=0;

    RestoreMaskableInterrupts();

    CyclesPerRtYield=(ULONG)((stoptime-starttime)/MEASUREMENTCOUNT);


    // Now time them when we directly interrupt to transfer control.

    SaveAndDisableMaskableInterrupts();

    starttime=ReadCycleCounter();

    for (i=0; i<MEASUREMENTCOUNT; i++) {
        RtpSimulateRtInterrupt();
    }

    stoptime=ReadCycleCounter();

    RestoreMaskableInterrupts();

    CyclesPerInt2=(ULONG)((stoptime-starttime)/MEASUREMENTCOUNT);


    // Now time them when we directly interrupt to transfer control but also
    // switch the floating point state.

    activefloatthreadcount++;

    SaveAndDisableMaskableInterrupts();

    starttime=ReadCycleCounter();

    for (i=0; i<MEASUREMENTCOUNT; i++) {
        RtpSimulateRtInterrupt();
    }

    stoptime=ReadCycleCounter();

    RestoreMaskableInterrupts();

    CyclesPerInt2FloatSwitch=(ULONG)((stoptime-starttime)/MEASUREMENTCOUNT);

    activefloatthreadcount--;

}


// In order to properly support the APIC hals on NT, I am going to have to significantly change
// how we obtain and change the system irql levels.  On UP hals, this was easy because there
// is a single global variable that contains the current IRQL level, and the UP hal implemented
// lazy irql.  The variable was NOT connected to any hardware, it was just the desired current
// IRQL level.  When irql changed, the hardware was NOT neccesarily programed, just this global
// value was changed.  If an interrupt hit and IRQL was higher than that interrupt, then the
// interrupt was queued up for later simulation, and the hardware was programmed to raise the
// hardware irql level to that indicated in the system irql level global variable.  This made
// faking the IRQL levels for RT threads very easy, as all we needed to do was to change the
// global IRQL level to what we wanted IRQL to be, and we were done, since interrupts were
// disabled the whole time anyway, no interrupt would come in - so there was no bad effect of
// temporarily changing the system irql level to match what the IRQL in the rt thread was.  We
// simply always restored the global irql level variable back to its windows value before
// we returned to windows.

// On APIC hals, this is much more complicated.  There is not really any lazy irql on the
// APIC hals.  When the IRQL level is changed, it is written to memory, but the memory it is
// written to is a local APIC hardware register that is used for masking off interrupts.  So,
// when you change irql levels on the APIC hal, you are immediately masking or unmasking
// interrupts.  This means that the global memory location used to store the current irql level
// is now a hardware register.  I can't go off and reprogram the hardware register to an
// irql level lower than that which it currently contains without asking for lots of grief and
// pain.  It won't work.  I need to leave the hardware irql levels untouched, just as happens
// in the UP hal case.  All I want to do really is to change the value that will be returned
// by system functions that access the current IRQL level, to match what the current RT thread
// irql level is.  Then when we switch back to windows I want those functions to see again the
// true hardware irql level.

// So, the solution on an APIC hal, is to remap the pointer the system uses to get to the local
// APIC hardware from the hardware memory location to a normal page of memory - whenever we
// switch out of windows.  We also load into that page, the IRQL level of the each rt thread
// when we switch to it.  This makes it so that all of the functions that report irql levels
// will report the proper irql levels for each rt thread when they are called from that thread.
// When we switch back to windows, we point the memory used to access the local apic, back at
// the real hardware.  We switch this back and forth by modifying the page table entry that
// is used to map the hal into virtual memory.  After each switch, we also have to invalidate
// the TLBs for that page.  We use the INVLPG instruction to do this - so that we only invalidate
// the entries for that specific page.

// We can also be more tricky about this, if we want to make sure that no code is trying to
// change anything on the faked out local apic, by marking the memory page as read only.  We
// can make it so that page that the system uses to access the memory is an alias of a page that
// we have read write access to, but it only has read access to.  Then if any system code runs
// while we are running an rt thread, that tries to program the local apic, it will fault and we
// will catch it.

// A further nasty detail we have to deal with on the APIC hals is that the IRQL level programmed
// into the hardware does NOT correspond 1 to 1 with IRQL levels that the system APIs understand.
// This is because there are only 32 official IRQL levels in the system APIs, but the local
// APICs support 256 interrupts, and have limitations on the depth of their interrupt queing
// that essentially requires the system to spread the hardware interrupts accross the 256 interrupt
// levels.  This means that the value stored in the APIC hardware register is NOT a simple system
// IRQL level, so we have to also discover and save whatever the value that gets programmed
// into the hardware for DISPATCH_LEVEL is.  Since for now, rt threads all run at DISPATCH_LEVEL
// and only DISPATCH_LEVEL, that is the only value we need to track.  Currently on the machines
// I have been investigating, the APIC is programmed to 0x41 for DISPATCH_LEVEL.  However,
// since this can change, we simply record what the system sets it to when we set the IRQL
// level to DISPATCH_LEVEL.  Then the value will always be correct even if the HALs change.


NTSTATUS
GetSystemIrqlPointer (
    PKIRQL *ppCurrentIrql
    )
{

    KIRQL OldIrql;
    PKIRQL pIrql;
    PULONG_PTR Code;
    ULONG_PTR Offset=0;
    BOOL FoundSystemIrql=FALSE;

    // First call KeGetCurrentIrql.  This will snap any links to the function.

    KeGetCurrentIrql();

    // Get a pointer to start of the function;

    Code=(PULONG_PTR)KeGetCurrentIrql;


    // Scan for system IRQL memory location.

    while (!FoundSystemIrql) {

        // Make sure that first instruction of that code matches what we expect.  If not,
        // then punt.

        switch( (*Code&0xff) ) {

            case 0x0f:

                // We hit this for retail VMM on Win9x and on the NT uniprocessor and ACPI HALs.
                // We also hit this the second time through the loop for debug VMM on Win9x.
                // We also hit this the third time through the loop for the NT MP HAL.
                
                if (!(  ((*Code&0x0000ffff)==0x0000b60f &&
                        ((*Code&0x00ff0000)==0x00050000 || (*Code&0x00ff0000)==0x00800000)) || 
                        ((*Code&0x0000ffff)==0x0000b70f &&
                        ((*Code&0x00ff0000)==0x00050000)) 
                    )) {
                    // movzx al,  opcode=0f b6 05 addr  or  opcode=0f b6 80 addr
                    return STATUS_UNSUCCESSFUL;
                }

                // Get the memory location of CurrentIrql in vmm.  We pull it out of
                // the tail end of this instruction.

                // Skip the opcode.

                Code=(PULONG_PTR)(((PCHAR)Code)+3);

                // Pull out the address.  This will be an unligned reference, but thats
                // ok, x86 deals with unaligned references just fine.

                pIrql=(PKIRQL)(*Code+Offset);

                // We have our pointer to system IRQL so break out of the scan loop.
                FoundSystemIrql=TRUE;

                break;


            case 0x6a:

                // We hit this for debug VMM on Win9x.
                
                if ((*Code&0x0000ffff)!=0x0000046a) {
                    return STATUS_UNSUCCESSFUL;
                }

                // If we get here, then it should be debug VMM.  Skip to next instruction
                // and recheck.  Next instruction should be movzx al with opcode=0f b6 05 addr
                Code+=2;

                break;


            case 0xa1:

                // We hit this for the NT multiprocessor HAL.  The first time through the loop.

                // For now we disable support for hals that use the local APIC.  We will
                // turn them on once we have them working properly.

                return STATUS_UNSUCCESSFUL;

                // Point at and load the processor offset for the processor we are running on.
                // For now, since we only run on UP, this should always be zero.

                Code=(PULONG_PTR)(((PCHAR)Code)+1);

                // Pull out the offset.  This will make one unligned reference, but thats
                // ok, x86 deals with unaligned references just fine.

                Offset=*(PULONG_PTR)(*Code);

                ASSERT ( Offset == 0 );

                // Now point to the next instruction.  Should be a shr eax, 0x4.

                Code=(PULONG_PTR)(((PCHAR)Code)+4);

                break;


            case 0xc1:

                // We hit this for NT MP HAL.  The second time through the loop.

                if ((*Code&0x00ffffff)!=0x0004e8c1) {
                    return STATUS_UNSUCCESSFUL;
                }

                // Move to next instruction.  Should be a movzx eax.

                Code=(PULONG_PTR)(((PCHAR)Code)+3);

                break;


            default:

                return STATUS_UNSUCCESSFUL;

        }

    }



    // Now test our pointer and make sure it is correct.  If not, then punt.

    if (*pIrql!=KeGetCurrentIrql()) {
        return STATUS_UNSUCCESSFUL;
    }

    // Raise IRQL and test it again.

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    if (*pIrql!=DISPATCH_LEVEL) {
        return STATUS_UNSUCCESSFUL;
    }

    // Restore IRQL and test it one last time.

    KeLowerIrql(OldIrql);

    if (*pIrql!=OldIrql) {
        return STATUS_UNSUCCESSFUL;
    }

    // We got the pointer, save it away and return success.

    *ppCurrentIrql=pIrql;

    return STATUS_SUCCESS;

}




enum ControlCodes {
	CHECKLOADED,
	GETVERSION,
	GETSELECTOR,
	GETBASEADDRESS
	};


#ifndef UNDER_NT

DWORD __stdcall RtWin32API(PDIOCPARAMETERS p)
{

switch (p->dwIoControlCode) {

	case CHECKLOADED:
		break;

	case GETVERSION:
		// Get version.
		if (!p->lpvOutBuffer || p->cbOutBuffer<4)
			return ERROR_INVALID_PARAMETER;

		*(PDWORD)p->lpvOutBuffer=0x0100;

		if (p->lpcbBytesReturned)
			*(PDWORD)p->lpcbBytesReturned=4;

		break;

	case GETSELECTOR:
		// Get selector.
		if (!p->lpvOutBuffer || p->cbOutBuffer<4)
			return ERROR_INVALID_PARAMETER;

		*(PDWORD)p->lpvOutBuffer=(DWORD)RtRing3Selector;

		if (p->lpcbBytesReturned)
			*(PDWORD)p->lpcbBytesReturned=4;

		break;

	case GETBASEADDRESS:
		// Get base address.
		if (!p->lpvOutBuffer || p->cbOutBuffer<4)
			return ERROR_INVALID_PARAMETER;

		*(PDWORD)p->lpvOutBuffer=(DWORD)&threadswitchcount;

		if (p->lpcbBytesReturned)
			*(PDWORD)p->lpcbBytesReturned=4;

		break;

	default:
		return ERROR_INVALID_PARAMETER;

	}

return 0;

}

#endif




VOID
RtpForceAtomic (
    VOID (*AtomicOperation)(PVOID),
    PVOID Context
    )
{

    ULONG OldPerfInterrupt;


    // Acquire the RT lock.

    SaveAndDisableMaskableInterrupts();
    OldPerfInterrupt=*ApicPerfInterrupt;

    if ((OldPerfInterrupt&(NMI|MASKED))==NMI) {
        DisablePerformanceCounterInterrupt();
    }


    // Call the function that must be run atomically.

    (*AtomicOperation)(Context);


    // Now release the RT lock.

    if ((OldPerfInterrupt&(NMI|MASKED))==NMI) {

        // First unmask the scheduler interrupt.

        RestorePerformanceCounterInterrupt(OldPerfInterrupt);

        // Now check if we have held off the rt scheduler.
        // If so, then update that count and give scheduler control now.

        // We have held off the scheduler if both performance counters
        // are positive for 2 consecutive reads.
        if ((ReadPerformanceCounter(0)&((PERFCOUNTMASK+1)/2))==0 &&
        (ReadPerformanceCounter(1)&((PERFCOUNTMASK+1)/2))==0) {

            if ((ReadPerformanceCounter(0)&((PERFCOUNTMASK+1)/2))==0 &&
            (ReadPerformanceCounter(1)&((PERFCOUNTMASK+1)/2))==0) {

                Trap();
                RtpForceAtomicHoldoffCount++;
                RtYield(0, 0);

            }

        }

    }


    // Now check if we held off maskable interrupts.  Either maskable
    // performance counter interrupts, OR maskable apic timer interrupts.
    // We check this by looking at the interrupt request bit in the APIC 
    // for our maskable interrupt vector.  If it is set, we have held it off.

    // Note that we do NOT need to RtYield in this case since as soon as we
    // restore maskable interrupts, the interrupt will fire by itself.

    if (ReadAPIC(0x200+(ApicTimerVector/32)*0x10)&(1<<(ApicTimerVector%32))) {

        RtpForceAtomicHoldoffCount++;

    }


    // Now restore maskable interrupts.

    RestoreMaskableInterrupts();

}




VOID
RtpFreeRtThreadResources (
    ThreadState *thread
    )
{

    // Blow away and then release its internal data structures.

    if (thread->FloatState!=NULL) {
        RtlZeroMemory(thread->FloatBase, FLOATSTATESIZE+FXALIGN);
        ExFreePool(thread->FloatBase);
    }

    #ifdef GUARD_PAGE

    RtlZeroMemory(thread->StackBase+1024, thread->Statistics->StackSize<<12);
    FreePages(thread->StackBase, 0);

    #else

    RtlZeroMemory(thread->StackBase, thread->Statistics->StackSize<<12);
    ExFreePool(thread->StackBase);

    #endif

    RtlZeroMemory(thread->Statistics, sizeof(ThreadStats));
    ExFreePool(thread->Statistics);

    RtlZeroMemory(thread, sizeof(ThreadState));
    ExFreePool(thread);

}




VOID
RtpProcessDeadThreads (
    VOID
    )
{

    ThreadState *thread;


    // See if there are any threads to clean up.  If not, then exit.

    thread=RtDeadThreads;
    if (thread==NULL) {
        return;
    }

    // Now atomically grab the list of threads to be cleaned up.

    while (RtpCompareExchange(&(ULONG)RtDeadThreads, (ULONG)NULL, (ULONG)thread)!=(ULONG)NULL) {
        // If we get here, then the compare exchange failed because either another
        // thread was added to the list since we read RtDeadThreads,
        // or another Windows thread cleaned up the dead thread list and
        // there is nothing to do anymore.
        // Reread RtDeadThreads - see if there are threads to clean up, if so
        // try to claim the list again.
        thread=RtDeadThreads;
        if (thread==NULL) {
            return;
        }
    }

    // When we get here, thread is pointing to the head of a list of dead threads
    // that need to be cleaned up.  This list is guaranteed to not be touched by 
    // anyone else while we are processing it.

    // Walk through the list freeing all of the thread resources in the list.

    {

        ThreadState *nextthread;

        while (thread!=NULL) {
            nextthread=thread->next;
            RtpFreeRtThreadResources(thread);
            thread=nextthread;
        }

    }

}




ThreadState *
RtpGetThreadStateFromHandle (
    HANDLE RtThreadHandle
    )
{

    ThreadState *thread;
    KIRQL OldIrql;

    // Acquire the thread list spinlock.

    KeAcquireSpinLock(&RtThreadListSpinLock,&OldIrql);

    // Find the thread whose handle matches RtThreadHandle.

    thread=windowsthread;
    while (thread->ThreadHandle!=RtThreadHandle) {
        thread=thread->next;
        // Check if we have searched the whole list.  If so, punt.
        if (thread==windowsthread) {
            thread=NULL;
            break;
        }
    }

    // Release the thread list spinlock.

    KeReleaseSpinLock(&RtThreadListSpinLock, OldIrql);

    return thread;

}




// WARNING!  The following 2 functions work correctly only if they are called
// by functions that HAVE a stack frame!

#ifndef UNDER_NT

ULONG
__inline
ReturnAddress (
    VOID
    )
{

__asm mov eax, [ebp+4]

}

#endif



ULONG
__inline
AddressofReturnAddress (
    VOID
    )
{

__asm mov eax, ebp
__asm add eax, 4

}


// This function transfers control to the real time executive.

// It logs the appropriate counters and timestamp before transfering
// control and again just after control returns.  Those logs can
// be used to determine the overhead involved in transfering control.

BOOL RtpTransferControl(
    WORD State,
    ULONG Data,
    BOOL (*DoTransfer)(PVOID),
    PVOID Context
    )
{

    BOOL ControlTransferred;
    ULONG OldPerfInterrupt;
#ifdef MASKABLEINTERRUPT
    ULONG OldExtIntInterrupt;
    ULONG OldTimerInterrupt;
    ULONG OldTpr;
#endif

    // Assume success.  If we are running.
    ControlTransferred=RtRunning;

    // It is an error to call RtpTransferControl if the realtime executive is not
    // running.  Punt.
    if (!ControlTransferred) {
        Trap();
        return ControlTransferred;
    }

#ifdef MASKABLEINTERRUPT

    // Make sure no interrupts happen between masking the realtime executive
    // interrupt and transfering control to the executive.

    // However we also must make sure no interrupts get queued up in the processor
    // behind a disable interrupts.  So, we do things in a particular order.

    // First we disable the external interrupts.  This is typically what a
    // CLI would normally disable on 9x.  This will prevent the scheduler from
    // taking control the rest of the code.  However it may not be.

    // If we are yielding out of an rt thread, this will already be masked.
    {

    ULONG CheckIntrInterrupt;
    ULONG CheckTimerInterrupt;
    ULONG CheckPerfInterrupt;
    ULONG LoopLimit;

    LoopLimit=0;


    // First read and save all of the interrupt states.
    // Ignore the Delivery Status bit.  We do not care if it is
    // set or not - and we do NOT want it to lock up our loop by
    // causing a mismatch when we are checking for the mask

    // First wait until none of the interrupts are send pending.

    while (TRUE) {

        OldExtIntInterrupt=*ApicIntrInterrupt;
        OldTimerInterrupt=*ApicTimerInterrupt;
        OldPerfInterrupt=*ApicPerfInterrupt;

#ifdef DEBUG

        // ADD checks here on states of all of the local apic interrupts.
        // If they do not match what we expect, then someone else is programming
        // the local apic state and WE ARE THEREFORE BROKEN.

#endif

        if (!((OldExtIntInterrupt|OldTimerInterrupt|OldPerfInterrupt)&SENDPENDING)) {
            break;
        }

        if (!LoopLimit) {
            SendPendingCount++;
        }

        if (LoopLimit++>1000) {
            Break();
        }

    }

    SendPendingLoopCount+=LoopLimit;


    // Now mask all of those interrupts.

    while (TRUE) {

        *ApicIntrInterrupt=OldExtIntInterrupt|MASKED;

        // Mask the timer interrupt so if we are RT yielding out of windows and it
        // fires, we eat it and it doesn't cause us to prematurely leave our
        // precious realtime threads.  :-) :-)  If we are yielding out of an
        // rt thread this will already be masked.

        *ApicTimerInterrupt=OldTimerInterrupt|MASKED;

        // Mask the RT executive interrupt.
        // We do this so we can guarantee the exact location inside this routine where
        // control is transfered to the real time executive.

        *ApicPerfInterrupt=OldPerfInterrupt|MASKED;

        // Now read the current states.

        CheckIntrInterrupt=*ApicIntrInterrupt;
        CheckTimerInterrupt=*ApicTimerInterrupt;
        CheckPerfInterrupt=*ApicPerfInterrupt;

        // Loop until the current states match the set states.
        if (CheckIntrInterrupt==(OldExtIntInterrupt|MASKED) &&
        CheckTimerInterrupt==(OldTimerInterrupt|MASKED) &&
        CheckPerfInterrupt==(OldPerfInterrupt|MASKED)) {
            break;
        }
        else {
            TransferControlReMaskCount++;
        }

    }

    if (LoopLimit++>1000) {
        Break();
    }

    }

#else

    SaveAndDisableMaskableInterrupts();

    // Mask the RT executive interrupt.
    // We do this so we can guarantee the exact location inside this routine where
    // control is transfered to the real time executive.

    // NOTE!! We must handle cases where maskable interrupt hits NOW after
    // masking interrupts but before masking them at the APIC.  In that
    // case the interrupt was pending and then got masked.  Make SURE
    // we do the right thing.  Apic may generate a SPURIOUS interrupt in
    // that case.

    SaveAndDisablePerformanceCounterInterrupt(&OldPerfInterrupt);

#endif



#ifdef MASKABLEINTERRUPT

    // Now make sure that no matter what anyone does with the interrupt flag
    // between now and the end of switchrealtimethreads, our 2 interrupts
    // will not fire.  Unless that someone messes with the local apic as well.

    OldTpr=ReadAPIC(APICTPR);
    WriteAPIC( APICTPR, 0xff);

    SaveAndDisableMaskableInterrupts();

#endif

    // Validate parameters.

    // Decide if we are really going to transfer control.

    if (!(*DoTransfer)(Context)) {

#ifdef MASKABLEINTERRUPT

        RestoreMaskableInterrupts();

        // Restore original task priority register state.

        WriteAPIC( APICTPR, OldTpr);

#endif

        // Restore the original performance counter interrupt state.

        RestorePerformanceCounterInterrupt(OldPerfInterrupt);

#ifdef MASKABLEINTERRUPT

        // Restore original timer interrupt state.

        *ApicTimerInterrupt=OldTimerInterrupt;

        *ApicIntrInterrupt=OldExtIntInterrupt;

#else

        RestoreMaskableInterrupts();

#endif

        // At this point we know we will NOT transfer control for the reason
        // requested.
        ControlTransferred=FALSE;

        // Note that we now need the complexity that we have in RtpForceAtomic
        // to check for cases when we have lost our interrupt because it was
        // masked, and get the proper control transfered.

        // If we have dropped our normal interrupt for timeslicing on the
        // floor, then even though we are NOT going to transfer control for
        // the reason we tested for in this routine, we MUST still transfer
        // control because we masked our interrupt and it hit while it was
        // masked and thus got dropped on the floor.  (Since both the timer
        // and the performance counter interrupts are edge triggered and we
        // can't change them to level triggered.)  So, we now check if we
        // missed our interrupt, and if so, we override the State and Data
        // passed in, and force the transfer control to happen anyway, with
        // a State of RUN and Data of zero.  That is the state for normal
        // timeslice interrupts.

        if (currentthread!=windowsthread) {
            // We have held off the scheduler if both performance counters
            // are positive for 2 consecutive reads.
            if ((ReadPerformanceCounter(0)&((PERFCOUNTMASK+1)/2))==0 &&
            (ReadPerformanceCounter(1)&((PERFCOUNTMASK+1)/2))==0) {
                if ((ReadPerformanceCounter(0)&((PERFCOUNTMASK+1)/2))==0 &&
                (ReadPerformanceCounter(1)&((PERFCOUNTMASK+1)/2))==0) {
                    RtpTransferControlHoldoffCount++;
                    State=RUN;
                    Data=0;
                    SaveAndDisableMaskableInterrupts();
                    goto yieldtimeslice;
                }
            }
        }
        else {
            // This is tougher to figure out.  For now, we do not handle this
            // case.

            // I need to see if the counter rolled over while in this routine,
            // and if there is no interrupt pending, and if I did not service
            // the interrupt itself.
        }

        return ControlTransferred;

    }

    yieldtimeslice:

    // Load state/data slots for current thread.

    currentthread->state=State;
    currentthread->data=Data;


    // Log the appropriate counters/timestamps.


    // The fastest way to get control to the realtime executive is to do a
    // software NMI.  Run a software interrupt instruction.  This will NOT enable the hardware
    // to hold off other NMIs while servicing this software NMI, but we have
    // all other NMIs masked.  If there is a way for other NMIs to hit then
    // we will either have to revert to a method that generates a hardware NMI - or
    // we will need a mechanism to detect and prevent reentrant NMIs.

    // With local APICs, it IS possible for an IOAPIC or another local APIC to
    // send an NMI to us that would reenter this software NMI.  Note that if we switch 
    // IDTs we can detect if a NMI fires while we are in our NMI handler.

    // One nice benefit from using a software NMI is that do not lose the
    // current counts in the performance counters.  We can use that to track the
    // overhead nicely.

    RtpSimulateRtInterrupt();


    // When control returns here, the real time executive will have unmasked the
    // PerformanceCounter interrupt for us.  We do not need to do unmask it.
    // The realtime executive will also have set the ApicTimerInterrupt properly
    // as well as the task priority register.

    // Log the counters/timestamps again - this is done immediately after control is
    // returned to this function.


    // Restore the original interrupt state.

    RestoreMaskableInterrupts();

    return ControlTransferred;

}




BOOL
RtpTrue (
    PVOID Context
    )
{

    return TRUE;

}




BOOL
RtpYieldNeeded (
    PVOID Context
    )
{

    PYIELDTIME Time=(PYIELDTIME)Context;

    if ( (RtTime() - Time->Mark) < Time->Delta) {
    	return TRUE;
    }
    else {
    	return FALSE;
    }

}




BOOL
RtpAtomicExit (
    PVOID Context
    )
{

    ULONG PerfInterrupt;
    KIRQL OldIrql;


    // First see if the SpinLock is clear.  If so, then everything is
    // hunky dory and we allow control to transfer.

    // Note that this SpinLock is only used to protect the list for a SINGLE
    // processor.  This is NOT multiprocessor safe.  That is OK because
    // we are going to have separate lists of realtime threads on a per
    // processor basis.  If we even port this implementation to multiple
    // procs - which on NT in my opinion we should NOT.

    // Although there is a tradeoff there.  We could actually get dpc's
    // firing on both processors with this when we would not if we used
    // my other NT implementation.  There is actually a cross over point
    // between the 2 implementations depending on the number of processors
    // and how many processors are used for RT, and how heavily they
    // are loaded down with RT threads.

    // The key to running this nicely on a multiproc system is to ensure
    // that you sync the processors so the realtime threads are running
    // as far out of phase as possible - ideally 180 degrees out of phase.

    // That gives you the best overall system interrupt latency.  And,
    // with a light rt load allows you to run DPCs on both processors.

    // The very nice thing about the other implementation is that it gets
    // you user mode realtime support.

    if (RtThreadListSpinLock==0) {
        return TRUE;
    }

    // If we get here, then someone is holding the lock.  So, queue up behind
    // them.

    KeAcquireSpinLock(&RtThreadListSpinLock, &OldIrql);

    // Now we are holding the lock and the scheduler interrupt will be unmasked
    // since we will have RtYielded to the other thread and back.

    // There may be other threads queued up on this lock behind us - since we
    // lost control to the scheduler when we tried to acquire the spinlock.

    // Note however that maskable interrupts should still be disabled.

    PerfInterrupt=*ApicPerfInterrupt;


#ifdef DEBUG

    // Check that the scheduler interrupt is enabled.

    if (PerfInterrupt&MASKED) {
        Trap();
        return FALSE;
    }

    // Check that the SpinLock is held.

    if (!RtThreadListSpinLock) {
        Trap();
        return FALSE;
    }

    // Check that maskable interrupts are disabled.

#endif

    // Grab the scheduler lock again and release the spinlock.

    DisablePerformanceCounterInterrupt();

    KeReleaseSpinLock(&RtThreadListSpinLock, OldIrql);

    // Now either the SpinLock is free and the scheduler is still disabled,
    // which means that there was noone blocked on the spinlock behind us,
    // OR the scheduler is enabled and the state of the spinlock is indeterminate
    // in which case we should start over completely anyway.

    PerfInterrupt=*ApicPerfInterrupt;

    if (RtThreadListSpinLock==0 && (PerfInterrupt&MASKED)) {
        return TRUE;
    }

    return FALSE;

}



VOID
AddRtThread (
    ThreadState *thread
    )
{

    // If we were passed a pointer to a thread handle, fill it in now.
    // This is atomic with regard to the creation and running of this thread.
    // The handle can be used within the realtime thread as well as by
    // any non rt code.  It is guaranteed to be set properly before the
    // thread starts to run.

    if (thread->pThreadHandle!=NULL) {
        *thread->pThreadHandle=thread->ThreadHandle;
    }


    // Add thread to the rt thread list.

    thread->next=windowsthread;
    thread->previous=windowsthread->previous;
    windowsthread->previous=thread;
    thread->previous->next=thread;


    // Update the floating point/mmx thread count.

    if (thread->FloatState!=NULL) {
        activefloatthreadcount++;
    }


    // Update our RT thread count.

    RtThreadCount++;


    // Now unmask the realtime scheduler interrupt if the thread count is 2.

    if (RtThreadCount>1) {

        // Start the performance counters and unmask the local apic timer
        // interrupt.  This starts the realtime executive task switching.

        WriteAPIC(APICTIMER, ApicTimerVector|UNMASKED|PERIODIC);

    }

}




// This function runs when a realtime thread exits.

VOID
RtpThreadExit (
    VOID
    )
{

    // This function is tricky.

    // The problem is that when this function is called, we need to remove the
    // thread from the list of real time threads.  With our current implementation,
    // that means that we need to grab the RtThreadListSpinLock.  However, I do NOT
    // want to deal with releasing the spinlock from within the realtime
    // executive thread switcher - switchrealtimethreads.

    // So, that means that I need a way to atomically grab the spinlock, so that
    // I will block if someone else owns the spinlock until they release it.  However,
    // I must do this so that when I grab the spinlock, I am guaranteed that NOONE
    // else will try to grab it after me, before I have transfered control atomically
    // up to the realtime executive.  This is so that I can RELEASE the spinlock just
    // before transfering control up to the executive and be guaranteed that I will
    // not give control to anyone else who has blocked on the spinlock.

    // That way I can use the spinlock to protect the list, but release it in
    // the realtime thread just before control is atomically transfered to the
    // executive.

    // The executive can then take this thread out of the list put it on the dead
    // thread list and switch to the next thread to run.

    while (!RtpTransferControl(EXIT, 0, RtpAtomicExit, NULL))
        ;

}




// Add a failsafe for thread switching the realtime threads -
// use the PIIX3 to generate NMIs instead of SMIs and that is
// our backup if the perfcounter NMI interrupt does not work.


// IDEA!  Actually, we CAN get these realtime threads to run on
// Pentium class machines.  We use the chipset on the motherboard
// to generate the NMI that drives the scheduler.  That will work
// not quite as well as the perf counters, but it will work.

// We could use that to drive the 1ms or 2ms or 0.5ms initial
// NMI that takes control away from windows and transfers it to the
// first real time thread.  That would bypass the problem we
// currently have of not having a perf counter that is just a simple
// cycle counter.  Right now we have the problem that the cycle
// counter we have stops when we hit a halt instruction.  Also,
// the instruction counter also stops when we hit a halt instruction.


// Unfortunately, it is not completely that simple.  After looking
// closer at the documentation, the only interrupt that I can get
// to fire from the chipset is SMI, and furthermore, the counter is
// only an 8 bit counter.  In order to get the resolution I want
// I would have to set it to count single PCI cycles.  So, the
// longest period that would have would be 8usec.  That would mean
// taking an SMI every 8 usec.  or over 100,000 times/sec.  That
// is a little excessive. 125,000 times/sec with a 33MHz clock.

// Furthermore, I would have to write an smi handler that would
// then generate an NMI.  That would be possible but even more work,
// since then I would have to write and load a SMI handler - which
// would mean trying to take control of that away from the BIOS.

// Not necessarily a good idea.  Plus it would likely be very tricky
// and potentially impossible to wrest control of the SMI handler
// away from the BIOS especially if it is using the special bits
// that keep the PIIX3 from letting anyone else load the SMI
// memory.



#pragma warning( disable: 4035 )

ULONG
__inline
RtpCompareExchange (
    ULONG *destination,
    ULONG source,
    ULONG value
    )
{

ASSERT( destination!=NULL );
ASSERT( source!=value );

__asm {
	mov eax,value
	mov ecx,source
	mov edx,destination
	lock cmpxchg [edx],ecx
	jnz done
	mov eax,ecx
done:
	}

}



#define cmpxchg8 __asm _emit 0xf0 __asm _emit 0x0f __asm _emit 0xc7 __asm _emit 0x0f 

ULONGLONG __cdecl RtCompareExchange8(ULONGLONG *destination, ULONGLONG source, ULONGLONG value)
{

ASSERT( destination!=NULL );
ASSERT( source!=value );

__asm {
	mov edi,destination
	mov ebx,[ebp + 0x8 + TYPE destination]
	mov ecx,[ebp + 0x8 + TYPE destination + TYPE source/2]
	mov eax,[ebp + 0x8 + TYPE destination + TYPE source]
	mov edx,[ebp + 0x8 + TYPE destination + TYPE source + TYPE value / 2]
	cmpxchg8
	jnz done
	mov edx,ecx
	mov eax,ebx
done:
	}

}

#pragma warning( default: 4035 )




NTSTATUS
RtpWriteVersion (
    PULONG Version
    )
{

    __try {

        *Version=0x00090000;

    }

    __except(EXCEPTION_EXECUTE_HANDLER) {

        return STATUS_INVALID_PARAMETER;

    }

    return STATUS_SUCCESS;

}



// If the real time executive is running, this function returns
// STATUS_SUCCESS.  If for some reason the real time executive
// cannot run on the current machine then STATUS_NOT_SUPPORTED
// is returned.

// If the pointer to the version number is non NULL, then the
// version information for the currently loaded real time executive
// is returned.  The version information will be returned regardless
// of whether the real time executive can run or not.

// If this function is called from a real time thread, then the version
// pointer MUST either be NULL, or it MUST point to a local variable on 
// that real time thread's stack.  Otherwise this function will return 
// STATUS_INVALID_PARAMETER.


// We enable stack frames for RtVersion so that AddressofReturnAddress works properly.
#pragma optimize("y", off)

NTSTATUS
RtVersion (
    PULONG Version
    )
{

    if (Version!=NULL) {

        // We must validate this pointer before we go writing into it.
        // This is complicated by the fact that this must be RT safe as well.
        // The solution to make this check simple is to impose the requirement
        // that if this function is called from an RT thread, then the version
        // pointer MUST point to a local variable on THAT rt thread's stack.
        // Otherwise we simply return STATUS_INVALID_PARAMETER.

        if (currentthread==windowsthread) {

            // This is a Windows thread.
            // Wrap the version number write inside an exception handler.

            NTSTATUS Status;

            Status=RtpWriteVersion(Version);

            if (Status!=STATUS_SUCCESS) {

                return Status;

            }

        }
        else {

            // This is an RT thread.  Check if pointer is to a local var on this
            // RT thread stack.  Note that we make sure to exclude the thread return
            // address and its 2 parameters from the allowable space for this local
            // variable.  We also exclude all of the space on the stack required to
            // call this function.  Everything else is fair game.

            if ((ULONG)Version<(AddressofReturnAddress()+sizeof(VOID(*)(VOID))+sizeof(Version)) || 
            (ULONG)Version>=((ULONG)(currentthread->StackBase+1024)+(currentthread->Statistics->StackSize<<12) -
            		(sizeof(VOID(*)(VOID))+sizeof(PVOID)+sizeof(ThreadStats *))) ) {
                return STATUS_INVALID_PARAMETER;
            }

            *Version=0x00090000;

        }

    }

#ifndef UNDER_NT

    // Make sure we are being called from a WDM driver.  If not, we are
    // not available.

    if (ReturnAddress()<WDMADDRESSSPACE) {

        return STATUS_NOT_SUPPORTED;

    }

#endif

    if (RtRunning) {

        return STATUS_SUCCESS;

    }

    return STATUS_NOT_SUPPORTED;

}

#pragma optimize("", on)



// We can calibrate - and should calibrate, the threadswitching time.
// We do this by measuring how long it takes to repeatedly call the threadswitch
// routine.  Note that we should do this in many different ways so that we can
// get a good measure of the different paths through the routine.

// We should call it straight - with a software interrupt.  We should call it the fast
// way where we simply set things up on the stack and jump straight to the
// routine.

// We should call it with floatingpointcount set to force the floatingpoint
// save and restore.  We should call it without that.

// Ideally we calibrate all of the standard paths through the routine.

// We should also simulate the hardware interrupt version as well - both the
// nmi and the maskable interrupt entrance.  Then we can know very acurately
// how we perform.

// For all these measurements, build a histogram.  Ideally we dump those measurements
// to a file.

// We also need to track the results in whatever standard way we are going to
// track statistics on run times.  Then we can use whatever tools we build for use
// with those with these measurements of critical code paths.

// Note that this can enable us to measure overhead without having to measure the
// overhead internally to the routine.  That will enable us to keep the routine
// as fast as possible.  The less we have to read counters/write counters etc
// the faster we will be able to switch threads.



// Calibrate RtYield, RtpTransferControl,



BOOLEAN
RtThread (
    VOID
    )
{

    if (RtRunning && currentthread!=windowsthread) {
        return TRUE;
    }

    return FALSE;

}




// IDEA:  I can know exactly which data is likely unreliable when I am calibrating
// the CPU.  If 2 successive measurements are farther apart than I think they
// should be, then drop that pair - the hardware read and the timestamp read,
// do another hardware read and timestamp read.  Keep the previous timestamp
// read just to validate if this new hardware read and timestamp read are valid.
// If so, then log them as good data and continue with the latest timestamp read
// used to check the next pair of readings.  I think this validation technique
// can really improve the speed and results of my cpu calibration.

// Note, that I can use this to throw away bad data points in the set AFTER all of the
// measurements are done.

// Write a clock tracking realtime thread.  Track the APIC vs CPU clocks and the
// APIC vs the motherboard timer clock and the CPU vs motherboard clock.




NTSTATUS
RtCreateThread (
    ULONGLONG Period,
    ULONGLONG Duration,
    ULONG Flags,
    ULONG StackSize,
    RTTHREADPROC RtThread,
    PVOID pRtThreadContext,
    PHANDLE pRtThreadHandle
    )
{

    ThreadState *thread;
    ULONG *stack;
    ThreadStats *statistics;
    ULONG FloatSave[(FLOATSTATESIZE+FXALIGN)/sizeof(ULONG)];
    KIRQL OldIrql;


    // Make sure we NULL out handle if a valid handle passed in.
    // This way we clear handle for all error cases.
    if (pRtThreadHandle!=NULL) {
        *pRtThreadHandle=NULL;
    }

#ifndef UNDER_NT

    // First make sure we are being called from a WDM driver.  If not, punt.

    if (ReturnAddress()<WDMADDRESSSPACE) {
        return STATUS_NOT_SUPPORTED;
    }

#endif

    // Now make sure the realtime executive is running.

    if (!RtRunning) {
        return STATUS_NOT_SUPPORTED;
    }

    // Make sure we are being called from a windows thread.
    if (currentthread!=windowsthread) {
        return STATUS_UNSUCCESSFUL;
    }

    // Free any resources held by dead realtime threads.
    // Dead realtime threads are threads that have exited since either
    // RtCreateThread or RtDestroyThread were last called.

    RtpProcessDeadThreads();


    // Validate parameters.

    // For now Period must be 1 msec or greater.
    // For now it also must be an exact multiple of a MSEC.
    if (Period<1*MSEC || Period%MSEC) {
        Trap();
        return STATUS_INVALID_PARAMETER_1;
    }

    // For now Duration must be 1 usec or greater.
    if (Duration>=Period || (Duration>0 && Duration<1*USEC)) {
        Trap();
        return STATUS_INVALID_PARAMETER_2;
    }

    // Don't accept any flags except the ones we know about.
    // For now we do NOT accept INSTRUCTIONS flag.
    if (Flags&~(USESFLOAT|USESMMX|CPUCYCLES/*|INSTRUCTIONS*/)) {
        Trap();
        return STATUS_INVALID_PARAMETER_3;
    }

    // Stacksize must be between 4k and 32k inclusive.
    if (StackSize<1 || StackSize>8) {
        Trap();
        return STATUS_INVALID_PARAMETER_4;
    }

#ifndef UNDER_NT

    if ((ULONG)RtThread<WDMADDRESSSPACE) {
        Trap();
        // This could be STATUS_BAD_INITIAL_PC but that would be too
        // informative.  We don't want non WDM drivers creating real time
        // threads.
        return STATUS_NOT_SUPPORTED;
    }

#endif

    // TODO: Get the name of the driver that owns the return address.  Stuff
    // it in our ThreadState structure.  Make sure that the RtDestroyThread
    // comes from the same driver.  Use that to track who has created what threads.

    // Idea: set a debug register to catch writes to a certain spot in memory
    // above where we will fault.

    // Even when I have a guard page at the bottom of the stack, I STILL need
    // a task gate on the page fault handler.  Since otherwise I will simply
    // triple fault the processor and it will reboot - since if the realtime
    // threads run ring0, and I fault, I stay on the ring 0 stack and that
    // has just page faulted and will page fault again when attempting to
    // service the page fault, so will double fault, which will then fault again
    // which will reboot.

    // However, if I have a double fault handler that has a task gate, then
    // I can differentiate between stack generated page faults and other
    // page faults.  The stack based ones will all hit the double fault
    // handler while the other ones will hit the page fault handler.

    // OR, an interesting idea: just put a task gate on the stack segment fault
    // handler.  Then it will work.  Either the page fault, or the stack segment
    // will fault when we reach the edge.  Task gate those, so you can not
    // double fault.

    // Stack overflow - 1) if a debugger, stop in debugger pointing to code where it died,
    // 2) kill the thread.  Any operation - single step or go - should kill the
    // thread.  In retail, just kill the thread.



    // Allocate a thread state block.
    thread=(ThreadState *)ExAllocatePool( NonPagedPool, sizeof(ThreadState) );
    if (thread==NULL) {
        return STATUS_NO_MEMORY;
    }


#ifdef GUARD_PAGE
    // Allocate a stack for this thread.
    stack=thread->StackBase=(ULONG *)ReservePages(PR_SYSTEM, StackSize+1, PR_FIXED);
    if ((LONG)stack==(-1)) {
        ExFreePool(thread);
        return STATUS_NO_MEMORY;
    }

    // Commit memory to all but first page of stack.  This gives us a guard
    // page at bottom of stack.  So we will page fault if a realtime thread
    // blows their stack.  Actually, if a realtime thread blows their stack
    // we will double fault and we MUST have a task gate on the double fault
    // handler.
    if (!CommitPages(((ULONG)stack>>12)+1, StackSize, PD_FIXEDZERO, 0, PC_FIXED|PC_WRITEABLE)) {
        FreePages(stack, 0);
        ExFreePool(thread);
        return STATUS_NO_MEMORY;
    }
#else
    // Allocate a stack for this thread.
    stack=thread->StackBase=(ULONG *)ExAllocatePool( NonPagedPool, StackSize<<12 );
    if (stack==NULL) {
        ExFreePool(thread);
        return STATUS_NO_MEMORY;
    }
#endif

    // Allocate a statistics block for this thread.
    statistics=thread->Statistics=(ThreadStats *)ExAllocatePool( NonPagedPool, sizeof(ThreadStats) );
    if (statistics==NULL) {
#ifdef GUARD_PAGE
        FreePages(stack, 0);
#else
        ExFreePool(stack);
#endif
        ExFreePool(thread);
        return STATUS_NO_MEMORY;
    }

    // Initialize the statistics block.
    RtlZeroMemory(statistics, sizeof(ThreadStats));

    statistics->Period=Period;
    statistics->Duration=Duration;
    statistics->Flags=Flags;
    statistics->StackSize=StackSize;


#if 0
    // Reserve a page that we can map as a read only page for the statistics block.
    // That will keep people from being able to trash the statistics.

    readonlystats=CreateReadOnlyStatisticsPage(statistics);
    if (readonlystats==NULL) {
        ExFreePool(statistics);
#ifdef GUARD_PAGE
        FreePages(stack, 0);
#else
        ExFreePool(stack);
#endif
        ExFreePool(thread);
        return STATUS_NO_MEMORY;
    }
#endif


    // Allocate space for thread float/MMX state if required.
    // TODO:  Use NonPagedPoolCacheAligned as a parameter and get rid of FloatBase.
    // I don't need it except to make sure things are 8 byte aligned.
    // Cache Aligning will do that for me.
    thread->FloatBase=NULL;
    thread->FloatState=NULL;
    if (Flags&USESFLOAT || Flags&USESMMX) {

        thread->FloatBase=ExAllocatePool( NonPagedPool, FLOATSTATESIZE+FXALIGN );
        if (thread->FloatBase==NULL) {
            ExFreePool(statistics);
#ifdef GUARD_PAGE
            FreePages(stack, 0);
#else
            ExFreePool(stack);
#endif
            ExFreePool(thread);
            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory(thread->FloatBase, FLOATSTATESIZE+FXALIGN);

        // Now 16 byte align the floating point state pointer so fxsave/fxrstor can
        // be used if supported.
        thread->FloatState=(PVOID)(((ULONG)thread->FloatBase+(FXALIGN-1))&~(FXALIGN-1));

#ifdef DEBUG

        // Make sure the enable floating point MMX instructions bit is set in CR4.
        // If not, then the fxsave and fxrstor instructions will not work properly.

        if ((CPUFeatures&FXSR) && !(ReadCR4()&OSFXSR)) {

            Trap();

        }

#endif

        {
        ULONG SaveCR0, NewCR0;

        // We don't want vmcpd or the windows thread switcher to intervene while
        // we are setting up a pristine floating point state.
        SaveAndDisableMaskableInterrupts();

        // Save off CR0 state.

        NewCR0=SaveCR0=ReadCR0();

        // Now make sure we won't fault running FP instructions.
        // EM=0, NE=1, ET=1, TS=0, MP=1.

        NewCR0&=~(FPUMASK);
        NewCR0|=FPUEXCEPTION|FPU387COMPATIBLE|FPUMONITOR;

        WriteCR0(NewCR0);

        // Now save a valid initial floating point state for this thread.
        SaveThreadFloatState((PVOID)((((ULONG)FloatSave)+FXALIGN-1)&~(FXALIGN-1)));
        __asm fninit;
        SaveThreadFloatState(thread->FloatState);
        RestoreThreadFloatState((PVOID)((((ULONG)FloatSave)+FXALIGN-1)&~(FXALIGN-1)));

        // Restore original CR0 state.

        WriteCR0(SaveCR0);

        RestoreMaskableInterrupts();

        }

    }


    // Now everything is ready to go, allocate our CPU and see if we have enough.
    // If not, punt.
    RtCpuAllocatedPerMsec+=(ULONG)(Duration/(Period/MSEC));
    if (RtCpuAllocatedPerMsec>MSEC) {
        RtCpuAllocatedPerMsec-=(ULONG)(Duration/(Period/MSEC));
        RtpFreeRtThreadResources(thread);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    // Get a unique handle for this thread.

    thread->ThreadHandle=RtpCreateUniqueThreadHandle();

    // Save off output pointer to handle.

    thread->pThreadHandle=pRtThreadHandle;


    // Set initial state and data for this thread.
    thread->state=RUN;
    thread->data=0;

    // Setup StackSize so we can use it as an offset into stack.
    // First add guard page to size, then turn StackSize into count
    // of DWORDs instead of pages.
#ifdef GUARD_PAGE
    StackSize+=1;
#endif
    StackSize<<=10;

    // Setup the thread function parameters on the stack.
    // C calling convention.

    stack[--StackSize]=(ULONG)statistics;	// Statistics
    stack[--StackSize]=(ULONG)pRtThreadContext;	// Context

    // Now setup the return address of our function.
    // We point the return address at the internal destroy rt thread function.
    // That function will take the realtime thread out of the list of active
    // realtime threads, and will put it on the dead thread list, so its
    // resources will be freed the next time RtCreateThread or RtDestroyThread
    // are called.

    stack[--StackSize]=(ULONG)RtpThreadExit;


    // Now setup the IRET so we will run the thread function.

    // Actually there is fast way to detect if we are switching a windows
    // thread or an rt thread.  Simply use the CS stored
    // on the stack.  If it is the CS for the RT descriptor, then we
    // came in on a rt thread, if it is not, then it was windows.  That
    // is faster since we do NOT have to push the flags - which is slow,
    // and we can do it with a stack segment relative read, and a
    // compare (read) with a code segment descriptor.  So we can do
    // the test at the very beginning of our interrupt handler if
    // we want - and it will be FAST.

    // However, I DO want to eventually run them at CPL=1 or CPL=2 or
    // CPL=3, so we will have to do something about IOPL then anyway.

#ifdef MASKABLEINTERRUPT
    stack[--StackSize]=0x00000046|IF;	// EFLAGS: IOPL=0 IF=1
#else
    stack[--StackSize]=0x00000046;		// EFLAGS: IOPL=0 IF=0
#endif
    stack[--StackSize]=RtThreadCS;		// CS
    stack[--StackSize]=(ULONG)RtThread;	// EIP


    stack[--StackSize]=0;			// EAX


    // Initialize the thread block.
    thread->esp=(ULONG)(stack+StackSize);
    thread->ss=RealTimeSS;


    thread->ds=RealTimeDS;
    thread->es=RealTimeDS;
    thread->fs=0;
    thread->gs=0;

    thread->ecx=0;
    thread->edx=0;
    thread->ebx=0;
    thread->ebp=0;
    thread->esi=0;
    thread->edi=0;

    thread->irql=DISPATCH_LEVEL;


    // Add this thread to list of threads to run.
    // This MUST be atomic!

    KeAcquireSpinLock(&RtThreadListSpinLock,&OldIrql);

    RtpForceAtomic((VOID(*)(PVOID))AddRtThread, (PVOID)thread);

#ifdef WAKE_EVERY_MS
#ifndef UNDER_NT

    // On NT, we cannot call SetTimerResolution from DISPATCH_LEVEL
    // because it calls ExSetTimerResolution which is paged.
    // Unfortunately, this makes syncronization of setting the system timer
    // resolution to 1ms with the creation and deletion of realtime
    // threads more complicated.  See comment below for an explanation of
    // how we syncronize this on NT.

    if (!WakeCpuFromC2C3EveryMs && RtThreadCount>1) {
        WakeCpuFromC2C3EveryMs=TRUE;
        SetTimerResolution(1);
    }

#endif
#endif

    KeReleaseSpinLock(&RtThreadListSpinLock, OldIrql);


#ifdef WAKE_EVERY_MS
#ifdef UNDER_NT

    // On NT, our SetTimerResolution, ReleaseTimerResolution calls are synchronized
    // differently than they are on 9x.  We cannot call them while holding our
    // RtThreadListSpinLock.  In addition, I really did NOT want to add a mutex for
    // syncronization of those calls because we currently do not have a mutex that we
    // grab in RtCreateThread or in RtDestroyThread and I do not want to start using
    // one.

    // After looking at how ExSetTimerResolution works on NT, and thinking about this
    // problem, I came up with the following synchronization algorithm that will work
    // acceptably on NT.  First, the critical thing is that we MUST always have the
    // system timer resolution set to 1ms if there are any realtime threads running.
    // The one thing that we do NOT want is to have 1 or more realtime threads running
    // while the system timer resolution is more than 1ms.  If we sometimes in very rare
    // situations, leave the system timer set to 1ms when there are no realtime threads
    // running, that is OK - as long as we retry turning off 1ms resolution after more
    // realtime threads are created and then destroyed.

    // The algorithm I have implemented has the above characteristics.  It guarantees
    // because of the way that ExSetTimerResolution works on NT, that if there
    // are realtime threads, then the system timer resolution WILL be set to 1ms.  It
    // can in rare situations allow the system timer resolution to stay set to 1ms even
    // when there are no realtime threads left running.

    // The algorithm is the following:  When we are creating a realtime thread,
    // if RtThreadCount is greater than 1, and the system timer resolution has not 
    // been set, then note that we are setting the resolution to 1ms, then call 
    // SetTimerResolution and when the call completes, note that the system timer
    // resolution has been set to 1ms.  In this way we will only ever set the system
    // timer resolution to 1ms if it has not already been set or started to be set to
    // 1ms.

    // When we are destroying a realtime thread, if there are no realtime threads left
    // running, and we have already completed setting the system timer resolution to
    // 1 ms, then mark the system timer as not set to 1ms and then turn it off.  Note that
    // there is a window between when we mark the system timer as turned off, and when
    // ExSetTimerResolution actually grabs its internal mutex.  This means that an
    // RtCreateThread call can run before we actually have turned off the system timer
    // and it will decide to turn on the system timer again before we have turned it off.

    // This is GOOD.  Because ExSetTimerResolution works by keeping track of the number of
    // times a resolution has been set, and the number of times it has been released.  It
    // then only releases whatever the minimum setting has been to the current time, when
    // ALL of the set calls have been matched by a release call.  This means that if we
    // do an additional set call before we have run our release call, that the system
    // timer resolution will stay at a resolution at least as small as our resolution the
    // whole time, and the release call will NOT release the resolution because we made
    // an additional set call before the release.  If the release call runs before the
    // set call, that is OK as well, since the set call will reset the resolution back
    // down to 1ms.

    // The point is to make sure that if there are realtime threads, the system timer
    // resolution gets set to 1ms or stays at 1ms.  That is why we mark the system timer
    // as turned off before we actually turn it off - so that we WILL turn it on the
    // next time RtCreateThread is called.  Again the point is to not ever let the system
    // timer NOT be set to 1ms if there are realtime threads.

    // The only thing about the current algorithm that is not perfect, is that there is
    // also a window where we can leave the system resolution set to 1 ms even though there
    // are no realtime threads running.  This can only happen if an RtDestroyThread call
    // runs before the RtCreateThread call has completed and destroys the just created
    // realtime thread.  If that RtDestroyThread call runs after the realtime thread has
    // been added to the list, and after we have started to set the system timer resolution
    // to 1ms, but before we have completed setting the system timer resolution to 1ms,
    // then we will NOT clear the setting of the system timer resolution to 1ms in that
    // RtDestroyThread call, and when both calls have completed, we will have no realtime
    // threads running, but the system timer resolution will have been left at 1ms.

    // This is NOT a problem.  First of all, the current client - kmixer - never calls
    // RtDestroyThread until AFTER RtCreateThread has completed.  Second of all, even if
    // this happened, all that means is the next time a realtime thread is created, we
    // will note that the system timer resolution is already 1ms, and will NOT set it down
    // to 1ms since it is already there.  Furthermore, when that realtime thread is
    // destroyed, we WILL release the resolution.  This works because the state of the
    // WakeCpuFromC2C3EveryMs variable is always CORRECT.  If we get into this situation
    // where we destroy the only realtime thread in the system before we complete setting
    // the system timer resolution to 1ms, WakeCpuFromC2C3EveryMs will indicate that the
    // system timer resolution is still set to 1ms - and the system timer resolution WILL
    // be set to 1ms.

    // Again the CRITICAL requirement that this algorithm DOES MEET, is that we guarantee
    // that whenever there are realtime threads running the system timer resolution is
    // 1ms.  And except in very very rare and hard to produce circumstances, whenever
    // there are no realtime threads, the system timer resolution is released.  In those
    // cases when it is not released, its release will again be attempted if further
    // realtime threads are created and destroyed.  Furthermore the current realtime client
    // will NEVER cause this case to hit, so we will ALWAYS turn off system timer
    // properly.

    // Don't change this code unless you GUARANTEE that whenever there are realtime threads
    // the system timer resolution is 1ms.


    if (RtThreadCount>1 && InterlockedCompareExchange(&WakeCpuFromC2C3EveryMs, 1, 0)==0) {
        SetTimerResolution(1);
        InterlockedIncrement(&WakeCpuFromC2C3EveryMs);
    }
#endif
#endif


#ifndef MASKABLEINTERRUPTS

    // This hack is not longer safe for the maskable interrupt version of
    // rt.sys.  We may have one of our interrupts queued up on the 

    // WARNING:  BROKEN IBM MACHINE SPECIFIC HACK FOLLOWS.
    // Check if the local APIC is wedged.  This happens if the ISR bit for
    // our maskable realtime scheduler bit is set.  That bit should only
    // ever be set while we are in our interrupt service routine.  If it
    // is set now, then the scheduler is stuck - at least until we get
    // the performance counter backup working.

    // If the ISR bit is set for our maskable interrupt then we need to
    // clear it.

    // We only EOI the APIC if our ISR bit is set.

    {
    ULONG count=0;

    while (ReadAPIC(0x100+(ApicTimerVector/32)*0x10)&(1<<(ApicTimerVector%32))) {

        // Since this fix is for broken machines, trap so in debug code I can see how
        // many machines hit this.
        Trap();

        // We have to EOI the APIC to try to get our ISR bit cleared.
        WriteAPIC(APICEOI,0);

        count++;

        // At most we would have to clear all the ISR bits that are higher
        // priority than ours before ours should go clear.  This in reality
        // is overkill but worst case of completely broken APIC/software, this many
        // EOIs might be necessary.
        if (ApicTimerVector+count>255) {
            Trap();
            break;
        }

    }

    }

#endif


    return STATUS_SUCCESS;

}




// This function is called from a windows thread to destroy a real
// time thread.  This function should NOT be called from a real
// time thread - that is because it is currently freeing memory
// and calling functions that are NOT realtime safe.

// If we modify the implementation so that we simply put the
// destroyed thread on a list, and process the memory releases
// from our own private windows thread, then we can make this
// API safe for real time threads.

// For now, since RtCreateThread can only be called from windows
// threads, we leave this API as callable only from windows threads
// as well.

// The only way to destroy a real time thread from within the
// realtime thread itself is to return from it.

// We do NOT want to be able to kill the windows thread.
// We currently will not be able to do that since the windows
// thread stack does not ever return to the destroy thread
// code.


// IDEA:  Try just jumping to the int3 handler with the stack setup
// to point to the spot you want the debugger to break.  Make it so
// when there are errors of any kind, we break on the instruction after
// the call.  As long as debuggers actually stop on an int3 even if they
// do not see one there, this will work.  ie: if they are not picky and
// don't double check to make sure the previous instruction was an int3
// then this will work.  Then I do not need to get control after the
// debugger.  The debugger should treat the int3 as a call to tell it
// STOP at that location - even if no int 3 was embedded in the instruction
// stream.  Then I can fix things up and get things to stop where I want.


NTSTATUS
RtDestroyThread (
    HANDLE RtThreadHandle
    )
{

    ThreadState *thread;
    KIRQL OldIrql;

#ifndef UNDER_NT

    // First make sure we are being called from a WDM driver.  If not, punt.

    if (ReturnAddress()<WDMADDRESSSPACE) {
        return STATUS_NOT_SUPPORTED;
    }

#endif

    // Punt if we are not running on this machine.
    if (!RtRunning) {
        Trap();
        return STATUS_NOT_SUPPORTED;
    }

    // Make sure we are being called from a windows thread.
    if (currentthread!=windowsthread) {
        return STATUS_UNSUCCESSFUL;
    }

    // Find the thread whose handle has been passed in.

    thread=RtpGetThreadStateFromHandle(RtThreadHandle);

    if (thread==NULL) {
        Trap();
        return STATUS_INVALID_HANDLE;
    }

    // If we get here, then thread is pointing to the thread state
    // of the thread that needs to be destroyed.

    // It is an error to destroy the windows thread.  Make sure
    // we are not attempting to destroy the windows thread.  We must
    // make this check in case someone passes in a handle matching
    // the windows thread handle.

    if (thread==windowsthread) {
        Trap();
        return STATUS_UNSUCCESSFUL;
    }


    // Now make sure that the thread is being destroyed by the same driver
    // that created it.  If not, then punt.


    // At this point, everything is set to kill the thread.  Only thing
    // we must ensure is that the real time thread is not holding any
    // spinlocks when it is removed from the list of real time threads.


    // Atomically remove the realtime thread from list of realtime threads.

    KeAcquireSpinLock(&RtThreadListSpinLock,&OldIrql);

    RtpForceAtomic((VOID(*)(PVOID))RemoveRtThread, (PVOID)thread);

#ifdef WAKE_EVERY_MS
#ifndef UNDER_NT

    // On NT, we cannot call ReleaseTimerResolution from DISPATCH_LEVEL
    // because it calls ExSetTimerResolution which is paged.

    if (WakeCpuFromC2C3EveryMs && RtThreadCount<=1) {
        WakeCpuFromC2C3EveryMs=FALSE;
        ReleaseTimerResolution(1);
    }

#endif
#endif

    KeReleaseSpinLock(&RtThreadListSpinLock, OldIrql);


#ifdef WAKE_EVERY_MS
#ifdef UNDER_NT

    if (RtThreadCount<=1 && InterlockedCompareExchange(&WakeCpuFromC2C3EveryMs, 0, 2)==2) {
        ReleaseTimerResolution(1);
    }

#endif
#endif


    // Free this threads resources.

    RtpFreeRtThreadResources(thread);


    // Now free any resources held by dead realtime threads.
    // Dead realtime threads are threads that have exited since either
    // RtCreateThread or RtDestroyThread were last called.

    RtpProcessDeadThreads();


    return STATUS_SUCCESS;

}




VOID
RtYield (
    ULONGLONG Mark,
    ULONGLONG Delta
    )
{

    WORD State;

    //ASSERT( &Delta == &Mark+sizeof(Mark) );

    YIELDTIME Time;

    Time.Mark=Mark;
    Time.Delta=Delta;

    // It is an error to call RtYield if the realtime executive is not
    // running.  Punt.

    if (!RtRunning) {
        Trap();
        return;
    }


    // Load our command to the realtime executive.

    State=YIELD;
    if (0==Mark && 0==Delta) {
        State=RUN;
        RtpTransferControl(State, 0, RtpTrue, NULL);
        return;
    }
    else if (currentthread==windowsthread) {
        // It is an error to RtYield for a non zero length of time from
        // Windows.
        Trap();
        return;
    }

    // Send the appropriate command to the realtime executive and transfer control.

    RtpTransferControl(State, (ULONG)&Time, RtpYieldNeeded, (PVOID)&Time);

}




NTSTATUS
RtAdjustCpuLoad(
    ULONGLONG Period,
    ULONGLONG Duration,
    ULONGLONG Phase,
    ULONG Flags
    )
{

#ifndef UNDER_NT

    // First make sure we are being called from a WDM driver.  If not, punt.

    if (ReturnAddress()<WDMADDRESSSPACE) {
        return STATUS_NOT_SUPPORTED;
    }

#endif

    // Now make sure the realtime executive is running.

    if (!RtRunning) {
        return STATUS_NOT_SUPPORTED;
    }

    // Make sure we are being called from a realtime thread.
    if (currentthread==windowsthread) {
        return STATUS_UNSUCCESSFUL;
    }


    // Validate parameters.

    // For now Period must be 1 msec or greater.
    // For now it also must be an exact multiple of a MSEC.
    if (Period<1*MSEC || Period%MSEC) {
        Trap();
        return STATUS_INVALID_PARAMETER_1;
    }

    // For now Duration must be 1 usec or greater.
    if (Duration>=Period || (Duration>0 && Duration<1*USEC)) {
        Trap();
        return STATUS_INVALID_PARAMETER_2;
    }

    // For now we do NOT accept any changes in the Flags parameters from the
    // settings passed in at thread creation.
    if (Flags!=currentthread->Statistics->Flags) {
        Trap();
        return STATUS_INVALID_PARAMETER_3;
    }


    // Now make sure that we have sufficient CPU to succeed this allocation and
    // update the CPU allocation for this thread.

    RtCpuAllocatedPerMsec+=(ULONG)(Duration/(Period/MSEC))-(ULONG)(currentthread->Statistics->Duration/(currentthread->Statistics->Period/MSEC));
    if (RtCpuAllocatedPerMsec>MSEC) {
        RtCpuAllocatedPerMsec-=(ULONG)(Duration/(Period/MSEC))-(ULONG)(currentthread->Statistics->Duration/(currentthread->Statistics->Period/MSEC));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Update the thread's statistics with the new Period and Duration.

    currentthread->Statistics->Period=Period;
    currentthread->Statistics->Duration=Duration;

    return STATUS_SUCCESS;

}


NTSTATUS
RtSystemInfo(
    ULONG Processor,
    SystemInfo * pSystemInfo
    )
{

    CPUINFO thecpu;
    ULONG MaxIndex;

#ifndef UNDER_NT

    // First make sure we are being called from a WDM driver.  If not, punt.

    if (ReturnAddress()<WDMADDRESSSPACE) {
        return STATUS_NOT_SUPPORTED;
    }

#endif

    // Validate our parameters.

    if (Processor) {
        return STATUS_INVALID_PARAMETER_1;
    }

    if (pSystemInfo==NULL) {
        return STATUS_INVALID_PARAMETER_2;
    }


    if (!GetCpuId(0, &thecpu)) {
        return STATUS_UNSUCCESSFUL;
    }


    // Clear all of the initial values.
    // We also use this as an good time to ensure that the pointer we were
    // passed is actually valid.

    __try {

        RtlZeroMemory(pSystemInfo, sizeof(SystemInfo));

    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        return STATUS_INVALID_PARAMETER_2;

    }

    MaxIndex=thecpu.eax;


    // On 9x, ProcessorCount is always 1 for now.

    pSystemInfo->ProcessorCount=1;


    // Load the architecture value.

    pSystemInfo->CpuArchitecture=X86;


    // Load the manufacturer value.

    if (thecpu.ebx==0x756e6547 && thecpu.edx==0x49656e69 && thecpu.ecx==0x6c65746e ) {
        pSystemInfo->CpuManufacturer=INTEL;
    }

    if (thecpu.ebx==0x68747541 && thecpu.edx==0x69746e65 && thecpu.ecx==0x444d4163 ) {
        pSystemInfo->CpuManufacturer=AMD;
    }


    // If its supported, get the family/model/stepping and features info.

    if (MaxIndex) {

        GetCpuId(1, &thecpu);

        pSystemInfo->CpuFamily=(thecpu.eax>>8)&0xf;

        pSystemInfo->CpuModel=(thecpu.eax>>4)&0xf;

        pSystemInfo->CpuStepping=thecpu.eax&0xf;

        pSystemInfo->CpuFeatures=thecpu.edx;

    }


    // Get the unique processor ID number.

    if (MaxIndex>=3 /* && (pSystemInfo->CpuFeatures&(1<<18)) */ ) {

        // The top 32 bits of the 96 bit processor id is the value returned
        // in eax from running a cpuid instruction with 1 in eax.
        // This value is still left in thecpu.eax.

        pSystemInfo->ProcessorID[1]=thecpu.eax;

        GetCpuId(3, &thecpu);

        pSystemInfo->ProcessorID[0]=((ULONGLONG)thecpu.edx<<32)|thecpu.ecx;

    }


    // Get the extended features information on AMD systems.

    pSystemInfo->CpuExtendedFeatures=0;


    // Load the CPU speed and system bus speed information.

    pSystemInfo->CpuCyclesPerMsec=RtCpuCyclesPerUsec*1000;
    pSystemInfo->SystemBusCyclesPerMsec=RtSystemBusCyclesPerUsec*1000;


    // Load the CPU allocation information if available.

    if (windowsthread!=NULL && 
        RtCpuAllocatedPerMsec>=(ULONG)windowsthread->Statistics->Duration) {
        pSystemInfo->ReservedCpuPerMsec=RtCpuAllocatedPerMsec-(ULONG)windowsthread->Statistics->Duration;
        if (pSystemInfo->ReservedCpuPerMsec>(ULONG)MSEC) {
            pSystemInfo->ReservedCpuPerMsec=(ULONG)MSEC;
        }
    }

    if (windowsthread!=NULL) {
        KIRQL OldIrql;
        ThreadState* thread;

        pSystemInfo->UsedCpuPerMsec=0;
        thread=windowsthread;

        KeAcquireSpinLock(&RtThreadListSpinLock,&OldIrql);

        while(thread->next!=windowsthread) {

            thread=thread->next;

            pSystemInfo->UsedCpuPerMsec+=(ULONG)(thread->Statistics->DurationRunLastPeriod/(thread->Statistics->Period/MSEC));

        }

        KeReleaseSpinLock(&RtThreadListSpinLock, OldIrql);

    }

    if (RtRunning && windowsthread!=NULL ) {
        pSystemInfo->AvailableCpuPerMsec=(ULONG)MSEC-pSystemInfo->ReservedCpuPerMsec;
        if (pSystemInfo->AvailableCpuPerMsec>=(ULONG)windowsthread->Statistics->Duration) {
            pSystemInfo->AvailableCpuPerMsec-=(ULONG)windowsthread->Statistics->Duration;
        }
        else {
            pSystemInfo->AvailableCpuPerMsec=0;
        }
    }


    return STATUS_SUCCESS;

}


PVOID
RtAddLogEntry (
    ULONG Size
    )

{

    ULONG PrintLocation, NextLocation;


    // For now the Size MUST be 16 bytes always.  We can support integral multiples of 16
    // bytes, but then we will have to deal with buffer alignment and wrapping issues.

    if (!RtLog || Size!=RT_LOG_ENTRY_SIZE) {
        return NULL;
    }


    NextLocation=RtLog->WriteLocation;

    do {

        PrintLocation=NextLocation;

        NextLocation=InterlockedCompareExchange(&RtLog->WriteLocation, PrintLocation+RT_LOG_ENTRY_SIZE, PrintLocation);

    } while (PrintLocation!=NextLocation);

    // Now we clear out the opposite half of the print buffer.  We do this all in kernel mode.
    // This means that we have data only in 1/2 of the buffer.  As we add new data, we
    // delete the old data.  We do the deletion of data in kernel mode so that we only
    // need to read data from user mode.  I do NOT want user mode code to be writing to
    // this buffer.  User mode code can read out of the output buffer, but NOT write into
    // it.  This means we MUST both fill and clear this buffer ourselves.  Since user
    // mode code is dependent on the fact that all slots will be marked as having
    // NODATA in them until they have been completely loaded with data, at which point
    // they will be marked with something other than NODATA.  We guarantee that
    // every slot we are loading starts as NODATA by simply clearing the print slots
    // in kernel mode before we fill them.  The easiest way to do this is to start
    // by marking all entries in the buffer as NODATA, and then by continuing to make
    // sure that for every print slot we are going to fill with data, we clear the corresponding
    // print slot halfway around the buffer.

    // That simple algorithm guarantees that every slot starts out marked as NODATA and
    // then transitions to some other state after it is filled.

    ((ULONG *)RtLog->Buffer)[((PrintLocation+RtLog->BufferSize/2)%RtLog->BufferSize)/sizeof(ULONG)]=NODATA;

    PrintLocation%=RtLog->BufferSize;

    return RtLog->Buffer+PrintLocation;

}




#ifndef UNDER_NT

#pragma warning( disable : 4035 )

pVpdRtData
SendVpdRtInfo (
    VOID
    )
{

    VMMCall( _VPOWERD_RtInfo );

}

#pragma warning( default : 4035 )


VOID
InitializeVPOWERD (
    VOID
    )
{

    pVpdRtData VpdData;

    VpdData=SendVpdRtInfo();

    *VpdData->pFunction=TurnOffLocalApic;

}


#pragma warning( disable : 4035 )

pNtRtData
SendNtKernRtInfo (
    VOID
    )
{

    VMMCall( _NtKernRtInfo );

}

pVmmRtData
SendVmmRtInfo (
    VOID
    )
{

    VMMCall( _VmmRtInfo );

}

#pragma warning( default : 4035 )


VOID
InitializeNT (
    VOID
    )
{

    pNtRtData NtData;
    pVmmRtData VmmData;

    NtData=SendNtKernRtInfo();

    *NtData->pBase=ApicBase;
    *NtData->pFunction1=RtpTransferControl;
    *NtData->pFunction2=RtpForceAtomic;
    *NtData->pThread=&(volatile ULONG)currentthread;
    // Do this LAST - so other values are valid before we set this.
    *NtData->pRtCs=RtExecCS;

    VmmData=SendVmmRtInfo();

    *VmmData->pBase=ApicBase;
    *VmmData->pFunction=RtpForceAtomic;
    // Do this LAST - so other values are valid before we set this.
    *VmmData->pRtCs=RtExecCS;

}

#endif


#ifdef UNDER_NT

ULONGLONG OriginalAcquireCode;
ULONGLONG OriginalReleaseCode;




VOID
__declspec(naked)
PatchAcquire (
    VOID
    )
{

    __asm{
        push RtKfAcquireSpinLock
        ret
        int 3
        int 3
        }

}




VOID
__declspec(naked)
PatchRelease (
    VOID
    )
{

    __asm {
        push RtKfReleaseSpinLock
        ret
        int 3
        int 3
        }

}



#if 0

VOID
FASTCALL
__declspec(naked)
OriginalRelease (
    IN PKSPIN_LOCK SpinLock
    )
{

    __asm {
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        }

}



NTSTATUS
RtpSetupOriginalReleaseSpinlock (
    PULONGLONG ReleaseAddress
    )
{

    PULONGLONG OriginalReleaseAddress, OriginalReleaseAlias;
    PHYSICAL_ADDRESS OriginalReleasePhysicalAddress;

    // First get the virtual addresse of OriginalRelease.

    OriginalReleaseAddress=(PULONGLONG)OriginalRelease;


    // Make sure the code they point to starts like we expect it to.  If not, punt.

    OriginalReleaseCode=*ReleaseAddress;

    if ( ! ((OriginalAcquireCode==0xc6ffdff024a0c033 && OriginalReleaseCode==0xf0241588fa9cc933) || // UP HAL
            (OriginalAcquireCode==0x05c7fffe0080158b && OriginalReleaseCode==0x888ac933c28ac033) || // APIC HAL
            (OriginalAcquireCode==0xc6ffdff024a0c033 && OriginalReleaseCode==0xf0243d80cab60f9c))   // ACPI HAL
        ) {
        return STATUS_UNSUCCESSFUL;
    }

    // Now alias the memory with our own writable pointer.  So we can
    // patch the code to jump to our routines.

    ReleasePhysicalAddress=MmGetPhysicalAddress(ReleaseAddress);


    ReleaseAlias=MmMapIoSpace(ReleasePhysicalAddress, 16, FALSE);

    if (!ReleaseAlias) {
        return STATUS_UNSUCCESSFUL;
    }

    // Now patch the routines.  Note that this code is not MP safe.
    // Currently we will not be called except on uniprocessor machines.

    SaveAndDisableMaskableInterrupts();

    InterlockedCompareExchange64(AcquireAlias, *(PULONGLONG)PatchAcquire, OriginalAcquireCode);

    InterlockedCompareExchange64(ReleaseAlias, *(PULONGLONG)PatchRelease, OriginalReleaseCode);

    RestoreMaskableInterrupts();

    // Release our alias mappings.

    MmUnmapIoSpace(ReleaseAlias, 16);


    return STATUS_SUCCESS;

}

#endif


NTSTATUS
RtpPatchHalSpinlockFunctions (
    VOID
    )
{

    UNICODE_STRING AcquireLock;
    UNICODE_STRING ReleaseLock;
    PULONGLONG AcquireAddress, AcquireAlias;
    PULONGLONG ReleaseAddress, ReleaseAlias;
    PHYSICAL_ADDRESS AcquirePhysicalAddress;
    PHYSICAL_ADDRESS ReleasePhysicalAddress;

    // First get the virtual addresses of KfAcquireSpinLock and KfReleaseSpinLock.

    RtlInitUnicodeString (&AcquireLock, (const PUSHORT)L"KfAcquireSpinLock");
    RtlInitUnicodeString (&ReleaseLock, (const PUSHORT)L"KfReleaseSpinLock");

    AcquireAddress=MmGetSystemRoutineAddress(&AcquireLock);
    ReleaseAddress=MmGetSystemRoutineAddress(&ReleaseLock);

    // Punt if we did not get both addresses.

    if (!AcquireAddress || !ReleaseAddress) {
        return STATUS_UNSUCCESSFUL;
    }

    // Make sure the code they point to starts like we expect it to.  If not, punt.

    OriginalAcquireCode=*AcquireAddress;
    OriginalReleaseCode=*ReleaseAddress;

    if ( ! ((OriginalAcquireCode==0xc6ffdff024a0c033 && OriginalReleaseCode==0xf0241588fa9cc933) || // UP HAL
            (OriginalAcquireCode==0x05c7fffe0080158b && OriginalReleaseCode==0x888ac933c28ac033) || // APIC HAL
            (OriginalAcquireCode==0xc6ffdff024a0c033 && OriginalReleaseCode==0xf0243d80cab60f9c))   // ACPI HAL
        ) {
        return STATUS_UNSUCCESSFUL;
    }

#if 0
    // Setup the release spinlock function we call for windows code.  This makes sure that
    // we run any additional code that the HAL normally runs after releasing a spinlock whenever
    // a spinlock is released from a windows thread.

    if (RtpSetupOriginalReleaseSpinlock(ReleaseAddress)!=STATUS_SUCCESS) {
        return STATUS_UNSUCCESSFUL;
    }
#endif

    // Now alias the memory with our own writable pointer.  So we can
    // patch the code to jump to our routines.

    AcquirePhysicalAddress=MmGetPhysicalAddress(AcquireAddress);
    ReleasePhysicalAddress=MmGetPhysicalAddress(ReleaseAddress);

    AcquireAlias=MmMapIoSpace(AcquirePhysicalAddress, 16, FALSE);

    if (!AcquireAlias) {
        return STATUS_UNSUCCESSFUL;
    }

    ReleaseAlias=MmMapIoSpace(ReleasePhysicalAddress, 16, FALSE);

    if (!ReleaseAlias) {
        MmUnmapIoSpace(AcquireAlias, 16);
        return STATUS_UNSUCCESSFUL;
    }

    // Now patch the routines.  Note that this code is not MP safe.
    // Currently we will not be called except on uniprocessor machines.

    SaveAndDisableMaskableInterrupts();

    InterlockedCompareExchange64(AcquireAlias, *(PULONGLONG)PatchAcquire, OriginalAcquireCode);

    InterlockedCompareExchange64(ReleaseAlias, *(PULONGLONG)PatchRelease, OriginalReleaseCode);

    RestoreMaskableInterrupts();

    // Release our alias mappings.

    MmUnmapIoSpace(AcquireAlias, 16);
    MmUnmapIoSpace(ReleaseAlias, 16);


    return STATUS_SUCCESS;

}

#endif



VOID
MeasureRtTimeOverhead (
    VOID
    )
{

    ULONGLONG Start, Finish, Temp;
    ULONGLONG Original, Fast, Interlocked;
    ULONG i;


    Start=RtTime();

    for (i=0; i<10000; i++) {
        Temp=OriginalRtTime();
    }

    Finish=RtTime();

    Original=Finish-Start;


    Start=RtTime();

    for (i=0; i<10000; i++) {
        Temp=FastRtTime();
    }

    Finish=RtTime();

    Fast=Finish-Start;


    Start=RtTime();

    for (i=0; i<10000; i++) {
        Temp=RtTime();
    }

    Finish=RtTime();

    Interlocked=Finish-Start;



    DbgPrint("Original: %I64d,  Fast: %I64d,  Interlocked: %I64d\n", Original, Fast, Interlocked);

}




BOOL SetupRealTimeThreads(VOID)
{

    //Break();

#ifdef UNDER_NT

    // For now on NT we only support RT threads on non MP machines.
    // We need to generalize the RT spinlock support to MP before we can run MP.

    if (KeNumberProcessors>1) {
        return FALSE;
    }

#endif

    if (!CPUManufacturer) {
        if (!GetProcessorInfo()) {
            return FALSE;
        }
    }


    if (CPUManufacturer==AMD) {

        // Since this is an AMD machine we need to update the performance counter
        // model specific register locations.  (They default to the Intel locations.)
        // If we don't do this we will gp fault when we program the msrs.

        PerformanceCounter0=AMDPERFORMANCECOUNTER0;
        PerformanceCounter1=AMDPERFORMANCECOUNTER1;
        EventSelect0=AMDEVENTSELECT0;
        EventSelect1=AMDEVENTSELECT1;
        PerformanceCounterMask=AMDPERFCOUNTMASK;
        StopCounter=AMDSTOPPERFCOUNTER;
        StartCycleCounter=AMDSTARTPERFCOUNTERS|AMDCOUNTCYCLES;
        StartInstructionCounter=AMDSTARTPERFCOUNTERS|AMDCOUNTINSTRUCTIONS;
        StartInterruptsDisabledCounter=AMDSTARTPERFCOUNTERS|AMDINTSDISABLEDWHILEPENDING;

    }


    if (CPUManufacturer==INTEL && CPUFamily==0xf) {

        // This is Willamette processor.  They changed things again...

        PerformanceCounter0=WILLAMETTEPERFCOUNTER0;
        PerformanceCounter1=WILLAMETTEPERFCOUNTER1;
        EventSelect0=WILLAMETTECCR0;
        EventSelect1=WILLAMETTECCR1;
        StopCounter=WILLAMETTESTOPPERFCOUNTER;
        StartCycleCounter=WILLAMETTESTARTPERFCOUNTERS|WILLAMETTECOUNTCYCLES;
        StartInstructionCounter=WILLAMETTESTARTPERFCOUNTERS|WILLAMETTECOUNTINSTRUCTIONS;

    }


    if (!MachineHasAPIC()) {
        return FALSE;
    }



    // Get a pointer to the system irql.  We need this so we can properly
    // maintain irql for realtime threads.  If we don't get this, we don't
    // run.

    if (GetSystemIrqlPointer(&pCurrentIrql)!=STATUS_SUCCESS) {
        Trap();
        return FALSE;
    }



    if ( !NT_SUCCESS(InitializeRealTimeStack()) ) {
        return FALSE;
    }


    if (!EnableAPIC()) {
        return FALSE;
    }

    // If we got the local apic turned on, then we need to register with VPOWERD so
    // that we can turn off the local apic before the machine shuts down or restarts.
    // If we don't do that, then some broken Toshiba machines with mobile Celeron
    // motherboards and bios will hang, since they have desktop Celerons in them.
    // Mobile Celeron parts do not allow the apic to turn on.  Desktop Celeron parts
    // DO allow the local apic to turn on.  It seems the mobile celeron bios gets
    // confused if you restart the machine with the local apic in the desktop celeron
    // turned on.  So, to fix this we turn OFF the local apic on ALL machines before
    // VPOWERD either shutsdown or restarts.
    // Classic windows hack to fix stupid broken hardware.

#ifndef UNDER_NT

    InitializeVPOWERD();

#endif

    // First calibrate the cpu cycle counter.

    if ( !NT_SUCCESS(RtpCalibrateCpuClock(&RtCpuCyclesPerUsec)) ) {
        Trap();
        return FALSE;
    }

    if ( RtCpuCyclesPerUsec<160 ) {
        Trap();
        return FALSE;
    }

    RtPsecPerCpuCycle=USEC/RtCpuCyclesPerUsec;


    // Now calibrate the local apic timer - which is clocked from the system bus.

    if ( !NT_SUCCESS(RtpCalibrateSystemBus(RtCpuCyclesPerUsec, &RtSystemBusCyclesPerUsec)) ) {
        Trap();
        return FALSE;
    }

    if (RtSystemBusCyclesPerUsec<57) {	// Some PPro's have ~60MHz buses.
        Trap();
        return FALSE;
    }


    if ( !NT_SUCCESS(RtpEnableApicTimer()) ) {
        return FALSE;
    }


    RtpSetupStreamingSIMD();


    RtpSetupIdtSwitch(ApicTimerVector, ApicPerfVector, ApicErrorVector, ApicSpuriousVector);


    if ( !NT_SUCCESS(RtpInitializeThreadList()) ) {
        return FALSE;
    }


    HookWindowsInterrupts(ApicTimerVector, ApicErrorVector);


    SetupPerformanceCounters();


    SetTimeLimit( 0, 0);


#ifndef UNDER_NT

    if (!NT_SUCCESS(RtpSetupPowerManagement())) {
        return FALSE;
    }


    // Don't tell NTKERN we are here until we KNOW everything is set to go.
    // Once we make this call the KeAcquireSpinLock and KeReleaseSpinLock
    // calls will assume that rt support is on and running.

    InitializeNT();

#endif


#ifdef UNDER_NT

    if (RtpPatchHalSpinlockFunctions()!=STATUS_SUCCESS) {
        return FALSE;
    }

#endif


#ifdef MASKABLEINTERRUPT

    // Snap the dynalink to KfLowerIrql.
    WrapKfLowerIrql(KeGetCurrentIrql());

#endif


    // At this point, everything is ready to roll.  Before we enable our APIs,
    // we first run some calibration code to determine the overhead involved in
    // switching threads.

    //MeasureRealTimeExecutiveOverhead();
    // One run of the below measurements gave the following output.
    // Original: 7295923440,  Fast: 2771265627,  Interlocked: 5724782154
    //MeasureRtTimeOverhead();


    // Now set our loaded flag so that the external RT APIs succeed.

    RtRunning=1;

    //RtCreateThread(3500*MSEC, 3500*USEC, 0, 2, thread1, NULL, NULL);
    //RtCreateThread(thread2,2,0);
    //RtCreateThread(1*MSEC, 0, 0, 1, thread3, NULL, NULL);
    //RtCreateThread(1*MSEC, 10*USEC, 0, 1, thread4, NULL, NULL);
    //RtCreateThread(1*MSEC, 10*USEC, USESFLOAT|USESMMX, 1, thread5, NULL, NULL);
    //RtCreateThread(10*MSEC, 1000*USEC, USESFLOAT|USESMMX, 1, thread6, NULL, NULL);
    //RtCreateThread(20*MSEC, 2000*USEC, 0, 1, thread6, NULL, NULL);

#ifdef CATCH_INTERRUPTS_DISABLED_TOO_LONG
    RtCreateThread(1*MSEC, 3*USEC, 0, 1, ResetInterruptsDisabledCounter, NULL, NULL);
#endif

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\rtinfo.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    rtinfo.h

Abstract:

    This module defines the valid realtime thread states as well as structures
    used on Win9x for passing information about rt.sys to various kernel modules.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




// These are the valid realtime thread states.

enum {
	RUN,
	YIELD,
	BLOCKEDONSPINLOCK,
	SPINNINGONSPINLOCK,
	YIELDAFTERSPINLOCKRELEASE,
	EXIT,
	DEAD
	};


#ifndef UNDER_NT


// These structures are used on Win9x to pass information about rt to ntkern,
// vmm, and vpowerd respectively.  On NT they are not used.


typedef struct {
    ULONG *pRtCs;
    volatile CHAR **pBase;
    volatile ULONG **pThread;
    BOOL (**pFunction1)(WORD State, ULONG Data, BOOL (*DoTransfer)(PVOID), PVOID Context);
    VOID (**pFunction2)(VOID (*Operation)(PVOID), PVOID Context);
	} NtRtData, *pNtRtData;

typedef struct {
    ULONG *pRtCs;
    volatile CHAR **pBase;
    VOID (**pFunction)(VOID (*Operation)(PVOID), PVOID Context);
	} VmmRtData, *pVmmRtData;

typedef struct {
    VOID (**pFunction)(VOID);
	} VpdRtData, *pVpdRtData;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\rtp.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    rtp.h

Abstract:

    This header contains private internal realtime executive information.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




#define INSTRUCTIONCOUNT PERFORMANCECOUNTER1
#define CYCLECOUNT PERFORMANCECOUNTER0


//#define USERING1

//#define NONMI 1

// When USERING1 is defined, the realtime executive runs realtime threads with
// a priviledge level of ring 1 rather than ring 0.  This allows the executive to
// trap when code in a realtime thread uses CLI/STI instructions.  That allows the
// realtime executive to syncronize that code with Windows code.


// The real time executive stores eax on the
// stack and then uses that space in eax to switch to a known valid
// data segment.

// Currently we ALWAYS use a maskable interrupt to take control from Windows.

// We use a maskable interrupt to be nice to the OS and also to make 
// sure old debuggers like WDEB work properly.

// The real time executive currently always runs the real time threads
// with interrupts disabled, and uses a NMI interrupt to switch between
// them.

// We always use a private IDT for
// the realtime executive and the realtime threads.  We use them to catch
// any faults, or exceptions before they get to the normal Windows
// handlers.  It is an error to generate any faults or exceptions inside
// a real time thread.

// Although we used to use the performance counters to generate both the maskable
// and the non maskable interrupts, and we switched the perf counter
// interrupt dynamically between generating an NMI, and generating a
// maskable interrupt, we currently only use the local apic timer interrupt
// to generate the maskable interrupt.  We use the performance counters
// to generate the NMI to switch between the real time threads.

// This eliminates dual sources of maskable interrupts which was causing a
// single rt thread to get more time than it should have.

// One problem with using the performance counters to generate the maskable
// interrupt was also that the maskable interrupt was not guaranteed to hit -
// especially when vpowerd is doing idle detection and halting the cpu to
// reduce power consumption.  Unfortunately, I have not yet found a performance
// counter that will count cycles or bus cycles regardless of the power state
// of the processor.  Not even simply when the processor is halted or in a light
// power down state.


//#define MASKABLEINTERRUPT 1

// If MASKABLEINTERRUPT is defined, then we make the performance counters generate
// a maskable interrupt!  We do this so that we can quickly and surely guarantee
// that all of the ntkern functions that are called by ks2 are realtime safe.
// I will go fix those anyway, but to get ks2 up and running quickly, safely,
// and stable, changing rt.sys to never use NMI is the easiest way to go.



#define NMIIDTINDEX 2
#define MASKABLEIDTINDEX 0x4c
#define APICERRORIDTINDEX 0x4e
#define APICSPURIOUSIDTINDEX 0x4f	// This ABSOLUTELY MUST end in 0xf.  Hardware forces that.
#ifdef MASKABLEINTERRUPT
#define RTMASKABLEIDTINDEX 0x20
#define RTINTERRUPT (RTMASKABLEIDTINDEX)
#else
#define RTINTERRUPT (NMI|MASKABLEIDTINDEX)
#endif

#define TRANSFERCONTROLIDTINDEX MASKABLEIDTINDEX


// EIPRETURNADDRESSOFFSET is the offset in DWORDS from the bottom of the
// realtime thread's stack to the EIP DWORD of the IRET return address.

#define EIPRETURNADDRESSOFFSET (1)


// CSRETURNADDRESSOFFSET is the offset in DWORDS from the bottom of the
// realtime thread's stack to the CS DWORD of the IRET return address.

#define CSRETURNADDRESSOFFSET (2)


// EFLAGSOFFSET is the offset in DWORDS from the bottom of the 
// realtime thread's stack to the EFLAGS DWORD.

#define EFLAGSOFFSET (3)


// RTPTRANSFERCONTROLEFLAGSOFFSET is the offset in DWORDS from the bottom of the 
// realtime thread's stack to the EFLAGS DWORD that is pushed in the
// RtpTransferControl routine before doing a CLI and eventually transfering control
// to the realtime executive.

#define RTPTRANSFERCONTROLEFLAGSOFFSET (1+EFLAGSOFFSET)


// IF is the bit in the eflags register that is set and cleared to enable
// and disable maskable interrupts.

#define IF 0x200


// This is the starting address of the WDM driver address space on Win9x.  All
// preemtible WDM drivers are loaded into memory with virtual memory addresses
// equal to or larger than this address.

// We use this to check on Win9x if we are being called from a WDM driver or a
// VXD.  We do not support calling realtime functions from VXDs - so we check
// where we are called from and fail the call if it is not from WDM address
// space.

// On Windows NT, we allow any drivers to call our functions and so do not
// make this check.  It would not work anyway, since the driver address space
// does not start in the same place anyway.

#ifndef UNDER_NT
#define WDMADDRESSSPACE 0xff000000
#endif


#define RT_LOG_ENTRY_SIZE 16




// This structure is the header to the realtime log.

typedef struct {
	PCHAR Buffer;
	ULONG BufferSize;
	ULONG WriteLocation;
	} RTLOGHEADER, *PRTLOGHEADER;




extern PRTLOGHEADER RtLog;


// RtExecCS is the real time executive code segment.

extern WORD RtExecCS;
extern WORD RealTimeDS;
extern WORD RealTimeSS;
extern WORD RtExecTSS;


// These are globals with information about the processor we are running on.

extern ULONG CPUArchitecture;
extern ULONG CPUManufacturer;
extern LONG CPUFamily;
extern LONG CPUModel;
extern LONG CPUStepping;
extern ULONGLONG CPUFeatures;


// This global counts the number of times we have switched realtime threads since
// the machine was booted.  Note that this value is not cleared to zero if the
// machine is hibernated.

extern ULONGLONG threadswitchcount;


// This global points to the system irql level.

extern PKIRQL pCurrentIrql;




// Various prototypes of internally used functions.


BOOL
SetupRealTimeThreads ( 
    VOID
    );


VOID
SetTimeLimit (
    LONG cycles,
    LONG instructions
    );


__inline
ULONG
RtpCompareExchange (
    ULONG *destination,
    ULONG source,
    ULONG value
    );


ULONGLONG
__cdecl
RtCompareExchange8 (
    ULONGLONG *destination,
    ULONGLONG source,
    ULONGLONG value
    );


NTSTATUS
RtpCalibrateCpuClock (
    ULONG *cyclesperusec
    );


BOOL
RtpTransferControl (
	WORD State,
	ULONG Data,
	BOOL (*DoTransfer)(PVOID),
	PVOID Context
	);


VOID
RtpForceAtomic (
    VOID (*AtomicOperation)(PVOID),
    PVOID Context
    );


VOID
FASTCALL
RtKfAcquireLock (
    IN PKSPIN_LOCK SpinLock
    );


VOID
FASTCALL
RtKfReleaseLock (
    IN PKSPIN_LOCK SpinLock
    );


KIRQL
FASTCALL
RtKfAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );


VOID
FASTCALL
RtKfReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );


#define RtpSimulateRtInterrupt() \
	__asm int TRANSFERCONTROLIDTINDEX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkdev.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkdev.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _BULKUSB_DEV_H
#define _BULKUSB_DEV_H

NTSTATUS
BulkUsb_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
BulkUsb_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
BulkUsb_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
BulkUsb_ResetPipe(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInfo
    );

NTSTATUS
BulkUsb_ResetDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
BulkUsb_GetPortStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG PortStatus
    );

NTSTATUS
BulkUsb_ResetParentPort(
    IN IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkdev.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkdev.c

Abstract:

    This file contains dispatch routines for create, 
    close and selective suspend. 
    The selective suspend feature is enabled if
    the SSRegistryEnable key in the registry is set to 1.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "bulkusb.h"
#include "bulkpnp.h"
#include "bulkpwr.h"
#include "bulkdev.h"
#include "bulkusr.h"
#include "bulkwmi.h"
#include "bulkrwr.h"

NTSTATUS
BulkUsb_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for create.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet.

Return Value:

    NT status value

--*/
{
    ULONG                       i;
    NTSTATUS                    ntStatus;
    PFILE_OBJECT                fileObject;
    PDEVICE_EXTENSION           deviceExtension;
    PIO_STACK_LOCATION          irpStack;
    PBULKUSB_PIPE_CONTEXT       pipeContext;
    PUSBD_INTERFACE_INFORMATION interface;

    PAGED_CODE();

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchCreate - begins\n"));

    //
    // initialize variables
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if(deviceExtension->DeviceState != Working) {

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto BulkUsb_DispatchCreate_Exit;
    }

    if(deviceExtension->UsbInterface) {

        interface = deviceExtension->UsbInterface;
    }
    else {

        BulkUsb_DbgPrint(1, ("UsbInterface not found\n"));

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto BulkUsb_DispatchCreate_Exit;
    }

    //
    // FsContext is Null for the device
    //
    if(fileObject) {
        
        fileObject->FsContext = NULL; 
    }
    else {

        ntStatus = STATUS_INVALID_PARAMETER;
        goto BulkUsb_DispatchCreate_Exit;
    }

    if(0 == fileObject->FileName.Length) {

        //
        // opening a device as opposed to pipe.
        //
        ntStatus = STATUS_SUCCESS;

        InterlockedIncrement(&deviceExtension->OpenHandleCount);

        //
        // the device is idle if it has no open handles or pending PnP Irps
        // since we just received an open handle request, cancel idle req.
        //
        if(deviceExtension->SSEnable) {
        
            CancelSelectSuspend(deviceExtension);
        }

        goto BulkUsb_DispatchCreate_Exit;
    }
    
    pipeContext = BulkUsb_PipeWithName(DeviceObject, &fileObject->FileName);

    if(pipeContext == NULL) {

        ntStatus = STATUS_INVALID_PARAMETER;
        goto BulkUsb_DispatchCreate_Exit;
    }

    ntStatus = STATUS_INVALID_PARAMETER;

    for(i=0; i<interface->NumberOfPipes; i++) {

        if(pipeContext == &deviceExtension->PipeContext[i]) {

            //
            // found a match
            //
            BulkUsb_DbgPrint(3, ("open pipe %d\n", i));

            fileObject->FsContext = &interface->Pipes[i];
            
            ASSERT(fileObject->FsContext);

            pipeContext->PipeOpen = TRUE;

            ntStatus = STATUS_SUCCESS;

            //
            // increment OpenHandleCounts
            //
            InterlockedIncrement(&deviceExtension->OpenHandleCount);

            //
            // the device is idle if it has no open handles or pending PnP Irps
            // since we just received an open handle request, cancel idle req.
            //
            if(deviceExtension->SSEnable) {

                CancelSelectSuspend(deviceExtension);
            }
        }
    }

BulkUsb_DispatchCreate_Exit:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchCreate - ends\n"));
    
    return ntStatus;
}

NTSTATUS
BulkUsb_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for close.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    NTSTATUS               ntStatus;
    PFILE_OBJECT           fileObject;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_STACK_LOCATION     irpStack;
    PBULKUSB_PIPE_CONTEXT  pipeContext;
    PUSBD_PIPE_INFORMATION pipeInformation;
    
    PAGED_CODE();

    //
    // initialize variables
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    pipeContext = NULL;
    pipeInformation = NULL;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchClose - begins\n"));

    if(fileObject && fileObject->FsContext) {

        pipeInformation = fileObject->FsContext;

        if(0 != fileObject->FileName.Length) {

            pipeContext = BulkUsb_PipeWithName(DeviceObject, 
                                               &fileObject->FileName);
        }

        if(pipeContext && pipeContext->PipeOpen) {
            
            pipeContext->PipeOpen = FALSE;
        }
    }

    //
    // set ntStatus to STATUS_SUCCESS 
    //
    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    InterlockedDecrement(&deviceExtension->OpenHandleCount);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchClose - ends\n"));

    return ntStatus;
}

NTSTATUS
BulkUsb_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    Dispatch routine for IRP_MJ_DEVICE_CONTROL

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    ULONG              code;
    PVOID              ioBuffer;
    ULONG              inputBufferLength;
    ULONG              outputBufferLength;
    ULONG              info;
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    info = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    code = irpStack->Parameters.DeviceIoControl.IoControlCode;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if(deviceExtension->DeviceState != Working) {

        BulkUsb_DbgPrint(1, ("Invalid device state\n"));

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = info;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return ntStatus;
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchDevCtrl::"));
    BulkUsb_IoIncrement(deviceExtension);

    //
    // It is true that the client driver cancelled the selective suspend
    // request in the dispatch routine for create.
    // But there is no guarantee that it has indeed been completed.
    // so wait on the NoIdleReqPendEvent and proceed only if this event
    // is signalled.
    //
    BulkUsb_DbgPrint(3, ("Waiting on the IdleReqPendEvent\n"));
    
    //
    // make sure that the selective suspend request has been completed.
    //

    if(deviceExtension->SSEnable) {

        KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
    }

    switch(code) {

    case IOCTL_BULKUSB_RESET_PIPE:
    {
        PFILE_OBJECT           fileObject;
        PUSBD_PIPE_INFORMATION pipe;

        pipe = NULL;
        fileObject = NULL;

        //
        // FileObject is the address of the kernel file object to
        // which the IRP is directed. Drivers use the FileObject
        // to correlate IRPs in a queue.
        //
        fileObject = irpStack->FileObject;

        if(fileObject == NULL) {

            ntStatus = STATUS_INVALID_PARAMETER;

            break;
        }

        pipe = (PUSBD_PIPE_INFORMATION) fileObject->FsContext;

        if(pipe == NULL) {

            ntStatus = STATUS_INVALID_PARAMETER;
        }
        else {
            
            ntStatus = BulkUsb_ResetPipe(DeviceObject, pipe);
        }

        break;
    }

    case IOCTL_BULKUSB_GET_CONFIG_DESCRIPTOR:
    {
        ULONG length;

        if(deviceExtension->UsbConfigurationDescriptor) {

            length = deviceExtension->UsbConfigurationDescriptor->wTotalLength;

            if(outputBufferLength >= length) {

                RtlCopyMemory(ioBuffer,
                              deviceExtension->UsbConfigurationDescriptor,
                              length);

                info = length;

                ntStatus = STATUS_SUCCESS;
            }
            else {
                
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
        }
        else {
            
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        break;
    }

    case IOCTL_BULKUSB_RESET_DEVICE:
        
        ntStatus = BulkUsb_ResetDevice(DeviceObject);

        break;

    default :

        ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        break;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = info;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchDevCtrl::"));
    BulkUsb_IoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
BulkUsb_ResetPipe(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInfo
    )
/*++
 
Routine Description:

    This routine synchronously submits a URB_FUNCTION_RESET_PIPE
    request down the stack.

Arguments:

    DeviceObject - pointer to device object
    PipeInfo - pointer to PipeInformation structure
               to retrieve the pipe handle

Return Value:

    NT status value

--*/
{
    PURB              urb;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    //
    // initialize variables
    //

    urb = NULL;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_PIPE_REQUEST));

    if(urb) {

        urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        urb->UrbPipeRequest.PipeHandle = PipeInfo->PipeHandle;

        ntStatus = CallUSBD(DeviceObject, urb);

        ExFreePool(urb);
    }
    else {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(NT_SUCCESS(ntStatus)) {
    
        BulkUsb_DbgPrint(3, ("BulkUsb_ResetPipe - success\n"));
        ntStatus = STATUS_SUCCESS;
    }
    else {

        BulkUsb_DbgPrint(1, ("BulkUsb_ResetPipe - failed\n"));
    }

    return ntStatus;
}

NTSTATUS
BulkUsb_ResetDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine invokes BulkUsb_ResetParentPort to reset the device

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    NTSTATUS ntStatus;
    ULONG    portStatus;

    BulkUsb_DbgPrint(3, ("BulkUsb_ResetDevice - begins\n"));

    ntStatus = BulkUsb_GetPortStatus(DeviceObject, &portStatus);

    if((NT_SUCCESS(ntStatus))                 &&
       (!(portStatus & USBD_PORT_ENABLED))    &&
       (portStatus & USBD_PORT_CONNECTED)) {

        ntStatus = BulkUsb_ResetParentPort(DeviceObject);
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_ResetDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
BulkUsb_GetPortStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PULONG     PortStatus
    )
/*++
 
Routine Description:

    This routine retrieves the status value

Arguments:

    DeviceObject - pointer to device object
    PortStatus - port status

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    KEVENT             event;
    PIRP               irp;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    *PortStatus = 0;

    BulkUsb_DbgPrint(3, ("BulkUsb_GetPortStatus - begins\n"));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                    IOCTL_INTERNAL_USB_GET_PORT_STATUS,
                    deviceExtension->TopOfStackDeviceObject,
                    NULL,
                    0,
                    NULL,
                    0,
                    TRUE,
                    &event,
                    &ioStatus);

    if(NULL == irp) {

        BulkUsb_DbgPrint(1, ("memory alloc for irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);

    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = PortStatus;

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(STATUS_PENDING == ntStatus) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }
    else {

        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    BulkUsb_DbgPrint(3, ("BulkUsb_GetPortStatus - ends\n"));

    return ntStatus;
}

NTSTATUS
BulkUsb_ResetParentPort(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine sends an IOCTL_INTERNAL_USB_RESET_PORT
    synchronously down the stack.

Arguments:

Return Value:

--*/
{
    NTSTATUS           ntStatus;
    KEVENT             event;
    PIRP               irp;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("BulkUsb_ResetParentPort - begins\n"));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                    IOCTL_INTERNAL_USB_RESET_PORT,
                    deviceExtension->TopOfStackDeviceObject,
                    NULL,
                    0,
                    NULL,
                    0,
                    TRUE,
                    &event,
                    &ioStatus);

    if(NULL == irp) {

        BulkUsb_DbgPrint(1, ("memory alloc for irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);

    ASSERT(nextStack != NULL);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(STATUS_PENDING == ntStatus) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }
    else {

        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    BulkUsb_DbgPrint(3, ("BulkUsb_ResetParentPort - ends\n"));

    return ntStatus;
}


NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine builds an idle request irp with an associated callback routine
    and a completion routine in the driver and passes the irp down the stack.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    PIRP                    irp;
    NTSTATUS                ntStatus;
    KIRQL                   oldIrql;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    PIO_STACK_LOCATION      nextStack;

    //
    // initialize variables
    //
    
    irp = NULL;
    idleCallbackInfo = NULL;

    BulkUsb_DbgPrint(3, ("SubmitIdleRequest - begins\n"));

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    if(PowerDeviceD0 != DeviceExtension->DevPower) {

        ntStatus = STATUS_POWER_STATE_INVALID;

        goto SubmitIdleRequestIrp_Exit;
    }

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(InterlockedExchange(&DeviceExtension->IdleReqPend, 1)) {

        BulkUsb_DbgPrint(1, ("Idle request pending..\n"));

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_DEVICE_BUSY;

        goto SubmitIdleRequestIrp_Exit;
    }

    //
    // clear the NoIdleReqPendEvent because we are about 
    // to submit an idle request. Since we are so early
    // to clear this event, make sure that if we fail this
    // request we set back the event.
    //
    KeClearEvent(&DeviceExtension->NoIdleReqPendEvent);

    idleCallbackInfo = ExAllocatePool(NonPagedPool, 
                                      sizeof(struct _USB_IDLE_CALLBACK_INFO));

    if(idleCallbackInfo) {

        idleCallbackInfo->IdleCallback = IdleNotificationCallback;

        idleCallbackInfo->IdleContext = (PVOID)DeviceExtension;

        ASSERT(DeviceExtension->IdleCallbackInfo == NULL);

        DeviceExtension->IdleCallbackInfo = idleCallbackInfo;

        //
        // we use IoAllocateIrp to create an irp to selectively suspend the 
        // device. This irp lies pending with the hub driver. When appropriate
        // the hub driver will invoked callback, where we power down. The completion
        // routine is invoked when we power back.
        //
        irp = IoAllocateIrp(DeviceExtension->TopOfStackDeviceObject->StackSize,
                            FALSE);

        if(irp == NULL) {

            BulkUsb_DbgPrint(1, ("cannot build idle request irp\n"));

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            ExFreePool(idleCallbackInfo);

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto SubmitIdleRequestIrp_Exit;
        }

        nextStack = IoGetNextIrpStackLocation(irp);

        nextStack->MajorFunction = 
                    IRP_MJ_INTERNAL_DEVICE_CONTROL;

        nextStack->Parameters.DeviceIoControl.IoControlCode = 
                    IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;

        nextStack->Parameters.DeviceIoControl.Type3InputBuffer =
                    idleCallbackInfo;

        nextStack->Parameters.DeviceIoControl.InputBufferLength =
                    sizeof(struct _USB_IDLE_CALLBACK_INFO);


        IoSetCompletionRoutine(irp, 
                               IdleNotificationRequestComplete,
                               DeviceExtension, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        DeviceExtension->PendingIdleIrp = irp;

        //
        // we initialize the count to 2.
        // The reason is, if the CancelSelectSuspend routine manages
        // to grab the irp from the device extension, then the last of the
        // CancelSelectSuspend routine/IdleNotificationRequestComplete routine 
        // to execute will free this irp. We need to have this schema so that
        // 1. completion routine does not attempt to touch the irp freed by 
        //    CancelSelectSuspend routine.
        // 2. CancelSelectSuspend routine doesnt wait for ever for the completion
        //    routine to complete!
        //
        DeviceExtension->FreeIdleIrpCount = 2;

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        //
        // check if the device is idle.
        // A check here ensures that a race condition did not 
        // completely reverse the call sequence of SubmitIdleRequestIrp
        // and CancelSelectiveSuspend
        //

        if(!CanDeviceSuspend(DeviceExtension) ||
           PowerDeviceD0 != DeviceExtension->DevPower) {

            //
            // IRPs created using IoBuildDeviceIoControlRequest should be
            // completed by calling IoCompleteRequest and not merely 
            // deallocated.
            //
     
            BulkUsb_DbgPrint(1, ("Device is not idle\n"));

            KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

            DeviceExtension->IdleCallbackInfo = NULL;

            DeviceExtension->PendingIdleIrp = NULL;

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            if(idleCallbackInfo) {

                ExFreePool(idleCallbackInfo);
            }

            //
            // it is still safe to touch the local variable "irp" here.
            // the irp has not been passed down the stack, the irp has
            // no cancellation routine. The worse position is that the
            // CancelSelectSuspend has run after we released the spin 
            // lock above. It is still essential to free the irp.
            //
            if(irp) {

                IoFreeIrp(irp);
            }

            goto SubmitIdleRequestIrp_Exit;
        }

        BulkUsb_DbgPrint(3, ("Cancel the timers\n"));
        //
        // Cancel the timer so that the DPCs are no longer fired.
        // Thus, we are making judicious usage of our resources.
        // we do not need DPCs because we already have an idle irp pending.
        // The timers are re-initialized in the completion routine.
        //
        KeCancelTimer(&DeviceExtension->Timer);

        ntStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject, irp);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(1, ("IoCallDriver failed\n"));

            goto SubmitIdleRequestIrp_Exit;
        }
    }
    else {

        BulkUsb_DbgPrint(1, ("Memory allocation for idleCallbackInfo failed\n"));

        KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                   IO_NO_INCREMENT,
                   FALSE);

        InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

SubmitIdleRequestIrp_Exit:

    BulkUsb_DbgPrint(3, ("SubmitIdleRequest - ends\n"));

    return ntStatus;
}


VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  "A pointer to a callback function in your driver is passed down the stack with
   this IOCTL, and it is this callback function that is called by USBHUB when it
   safe for your device to power down."

  "When the callback in your driver is called, all you really need to do is to
   to first ensure that a WaitWake Irp has been submitted for your device, if 
   remote wake is possible for your device and then request a SetD2 (or DeviceWake)"

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KEVENT                  irpCompletionEvent;
    PIRP_COMPLETION_CONTEXT irpContext;

    BulkUsb_DbgPrint(3, ("IdleNotificationCallback - begins\n"));

    //
    // Dont idle, if the device was just disconnected or being stopped
    // i.e. return for the following DeviceState(s)
    // NotStarted, Stopped, PendingStop, PendingRemove, SurpriseRemoved, Removed
    //

    if(DeviceExtension->DeviceState != Working) {

        return;
    }

    //
    // If there is not already a WW IRP pending, submit one now
    //
    if(DeviceExtension->WaitWakeEnable) {

        IssueWaitWake(DeviceExtension);
    }


    //
    // power down the device
    //

    irpContext = (PIRP_COMPLETION_CONTEXT) 
                 ExAllocatePool(NonPagedPool,
                                sizeof(IRP_COMPLETION_CONTEXT));

    if(!irpContext) {

        BulkUsb_DbgPrint(1, ("Failed to alloc memory for irpContext\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        //
        // increment the count. In the HoldIoRequestWorkerRoutine, the
        // count is decremented twice (one for the system Irp and the 
        // other for the device Irp. An increment here compensates for 
        // the sytem irp..The decrement corresponding to this increment 
        // is in the completion function
        //

        BulkUsb_DbgPrint(3, ("IdleNotificationCallback::"));
        BulkUsb_IoIncrement(DeviceExtension);

        powerState.DeviceState = DeviceExtension->PowerDownLevel;

        KeInitializeEvent(&irpCompletionEvent, NotificationEvent, FALSE);

        irpContext->DeviceExtension = DeviceExtension;
        irpContext->Event = &irpCompletionEvent;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpCompletionFunc,
                          irpContext, 
                          NULL);

        if(STATUS_PENDING == ntStatus) {

            BulkUsb_DbgPrint(3, ("IdleNotificationCallback::"
                           "waiting for the power irp to complete\n"));

            KeWaitForSingleObject(&irpCompletionEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
    }
    
    if(!NT_SUCCESS(ntStatus)) {

        if(irpContext) {

            ExFreePool(irpContext);
        }
    }

    BulkUsb_DbgPrint(3, ("IdleNotificationCallback - ends\n"));
}


NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KIRQL                   oldIrql;
    LARGE_INTEGER           dueTime;
    PIRP                    idleIrp;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;

    BulkUsb_DbgPrint(3, ("IdleNotificationRequestCompete - begins\n"));

    idleIrp = NULL;

    //
    // check the Irp status
    //

    ntStatus = Irp->IoStatus.Status;

    if(!NT_SUCCESS(ntStatus) && ntStatus != STATUS_NOT_SUPPORTED) {

        BulkUsb_DbgPrint(1, ("Idle irp completes with error::"));

        switch(ntStatus) {
            
        case STATUS_INVALID_DEVICE_REQUEST:

            BulkUsb_DbgPrint(1, ("STATUS_INVALID_DEVICE_REQUEST\n"));

            break;

        case STATUS_CANCELLED:

            BulkUsb_DbgPrint(1, ("STATUS_CANCELLED\n"));

            break;

        case STATUS_POWER_STATE_INVALID:

            BulkUsb_DbgPrint(1, ("STATUS_POWER_STATE_INVALID\n"));

            goto IdleNotificationRequestComplete_Exit;

        case STATUS_DEVICE_BUSY:

            BulkUsb_DbgPrint(1, ("STATUS_DEVICE_BUSY\n"));

            break;

        default:

            BulkUsb_DbgPrint(1, ("default: status = %X\n", ntStatus));

            break;
        }

        //
        // if in error, issue a SetD0
        //

        BulkUsb_DbgPrint(3, ("IdleNotificationRequestComplete::"));
        BulkUsb_IoIncrement(DeviceExtension);

        powerState.DeviceState = PowerDeviceD0;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpAsyncCompletionFunc, 
                          DeviceExtension, 
                          NULL);

        if(!NT_SUCCESS(ntStatus)) {
    
            BulkUsb_DbgPrint(1, ("PoRequestPowerIrp failed\n"));
        }

    }

IdleNotificationRequestComplete_Exit:

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    idleCallbackInfo = DeviceExtension->IdleCallbackInfo;

    DeviceExtension->IdleCallbackInfo = NULL;

    idleIrp = (PIRP) InterlockedExchangePointer(
                                        &DeviceExtension->PendingIdleIrp,
                                        NULL);

    InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    if(idleCallbackInfo) {

        ExFreePool(idleCallbackInfo);
    }

    //
    // since the irp was created using IoAllocateIrp, 
    // the Irp needs to be freed using IoFreeIrp.
    // Also return STATUS_MORE_PROCESSING_REQUIRED so that 
    // the kernel does not reference this in the near future.
    //

    if(idleIrp) {

        BulkUsb_DbgPrint(3, ("completion routine has a valid irp and frees it\n"));
        IoFreeIrp(Irp);
        KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
    else {

        //
        // The CancelSelectiveSuspend routine has grabbed the Irp from the device 
        // extension. Now the last one to decrement the FreeIdleIrpCount should
        // free the irp.
        //
        if(0 == InterlockedDecrement(&DeviceExtension->FreeIdleIrpCount)) {

            BulkUsb_DbgPrint(3, ("completion routine frees the irp\n"));
            IoFreeIrp(Irp);

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }

    if(DeviceExtension->SSEnable) {

        BulkUsb_DbgPrint(3, ("Set the timer to fire DPCs\n"));

        dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

        KeSetTimerEx(&DeviceExtension->Timer, 
                     dueTime,
                     IDLE_INTERVAL,                              // 5000 ms
                     &DeviceExtension->DeferredProcCall);

        BulkUsb_DbgPrint(3, ("IdleNotificationRequestCompete - ends\n"));
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine is invoked to cancel selective suspend request.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    None.

--*/
{
    PIRP  irp;
    KIRQL oldIrql;

    irp = NULL;

    BulkUsb_DbgPrint(3, ("CancelSelectSuspend - begins\n"));

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(!CanDeviceSuspend(DeviceExtension))
    {
        BulkUsb_DbgPrint(3, ("Device is not idle\n"));
    
        irp = (PIRP) InterlockedExchangePointer(
                            &DeviceExtension->PendingIdleIrp, 
                            NULL);
    }

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    //
    // since we have a valid Irp ptr,
    // we can call IoCancelIrp on it,
    // without the fear of the irp 
    // being freed underneath us.
    //
    if(irp) {

        //
        // This routine has the irp pointer.
        // It is safe to call IoCancelIrp because we know that
        // the compleiton routine will not free this irp unless...
        // 
        //        
        if(IoCancelIrp(irp)) {

            BulkUsb_DbgPrint(3, ("IoCancelIrp returns TRUE\n"));
        }
        else {
            BulkUsb_DbgPrint(3, ("IoCancelIrp returns FALSE\n"));
        }

        //
        // ....we decrement the FreeIdleIrpCount from 2 to 1.
        // if completion routine runs ahead of us, then this routine 
        // decrements the FreeIdleIrpCount from 1 to 0 and hence shall
        // free the irp.
        //
        if(0 == InterlockedDecrement(&DeviceExtension->FreeIdleIrpCount)) {

            BulkUsb_DbgPrint(3, ("CancelSelectSuspend frees the irp\n"));
            IoFreeIrp(irp);

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }

    BulkUsb_DbgPrint(3, ("CancelSelectSuspend - ends\n"));

    return;
}

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for power irp PoRequested in 
    IdleNotificationCallback.

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.

Return Value:

    None

--*/
{
    PIRP_COMPLETION_CONTEXT irpContext;
    
    //
    // initialize variables
    //

    if(Context) {

        irpContext = (PIRP_COMPLETION_CONTEXT) Context;
    }

    //
    // all we do is set the event and decrement the count
    //

    if(irpContext) {

        KeSetEvent(irpContext->Event, 0, FALSE);

        BulkUsb_DbgPrint(3, ("PoIrpCompletionFunc::"));
        BulkUsb_IoDecrement(irpContext->DeviceExtension);

        ExFreePool(irpContext);
    }

    return;
}

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for power irp PoRequested in IdleNotification
    RequestComplete routine.

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    BulkUsb_DbgPrint(3, ("PoIrpAsyncCompletionFunc::"));
    BulkUsb_IoDecrement(DeviceExtension);

    return;
}

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for PoRequest wait wake irp

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.    

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    BulkUsb_DbgPrint(3, ("WWIrpCompletionFunc::"));
    BulkUsb_IoDecrement(DeviceExtension);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\exe\rwbulk.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    RWBulk.c

Abstract:

    Console test app for BulkUsb.sys driver

Environment:

    user mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1997-1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        11/17/97: created

--*/

#include <windows.h>

#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>

#include "devioctl.h"

#include <setupapi.h>
#include <basetyps.h>
#include "BulkUsr.h"

#include "usbdi.h"

#define NOISY(_x_) printf _x_ ;

char inPipe[32] = "PIPE00";     // pipe name for bulk input pipe on our test board
char outPipe[32] = "PIPE01";    // pipe name for bulk output pipe on our test board
char completeDeviceName[256] = "";  //generated from the GUID registered by the driver itself

BOOL fDumpUsbConfig = FALSE;    // flags set in response to console command line switches
BOOL fDumpReadData = FALSE;
BOOL fRead = FALSE;
BOOL fWrite = FALSE;

int gDebugLevel = 1;      // higher == more verbose, default is 1, 0 turns off all

ULONG IterationCount = 1; //count of iterations of the test we are to perform
int WriteLen = 0;         // #bytes to write
int ReadLen = 0;          // #bytes to read

// functions


HANDLE
OpenOneDevice (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
        IN               char *devName
    )
/*++
Routine Description:

    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific usb device,
    open that device and fill in all the relevant information in the given
    USB_DEVICE_DESCRIPTOR structure.

Arguments:

    HardwareDeviceInfo:  handle to info obtained from Pnp mgr via SetupDiGetClassDevs()
    DeviceInfoData:      ptr to info obtained via SetupDiEnumDeviceInterfaces()

Return Value:

    return HANDLE if the open and initialization was successfull,
        else INVLAID_HANDLE_VALUE.

--*/
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA     functionClassDeviceData = NULL;
    ULONG                                predictedLength = 0;
    ULONG                                requiredLength = 0;
        HANDLE                                                           hOut = INVALID_HANDLE_VALUE;

    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //
    SetupDiGetDeviceInterfaceDetail (
            HardwareDeviceInfo,
            DeviceInfoData,
            NULL, // probing so no output buffer yet
            0, // probing so output buffer length of zero
            &requiredLength,
            NULL); // not interested in the specific dev-node


    predictedLength = requiredLength;
    // sizeof (SP_FNCLASS_DEVICE_DATA) + 512;

    functionClassDeviceData = malloc (predictedLength);
    functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);

    //
    // Retrieve the information from Plug and Play.
    //
    if (! SetupDiGetDeviceInterfaceDetail (
               HardwareDeviceInfo,
               DeviceInfoData,
               functionClassDeviceData,
               predictedLength,
               &requiredLength,
               NULL)) {
                free( functionClassDeviceData );
        return INVALID_HANDLE_VALUE;
    }

        strcpy( devName,functionClassDeviceData->DevicePath) ;
        printf( "Attempting to open %s\n", devName );

    hOut = CreateFile (
                  functionClassDeviceData->DevicePath,
                  GENERIC_READ | GENERIC_WRITE,
                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                  NULL, // no SECURITY_ATTRIBUTES structure
                  OPEN_EXISTING, // No special create flags
                  0, // No special attributes
                  NULL); // No template file

    if (INVALID_HANDLE_VALUE == hOut) {
                printf( "FAILED to open %s\n", devName );
    }
        free( functionClassDeviceData );
        return hOut;
}


HANDLE
OpenUsbDevice( LPGUID  pGuid, char *outNameBuf)
/*++
Routine Description:

   Do the required PnP things in order to find
   the next available proper device in the system at this time.

Arguments:

    pGuid:      ptr to GUID registered by the driver itself
    outNameBuf: the generated name for this device

Return Value:

    return HANDLE if the open and initialization was successful,
        else INVLAID_HANDLE_VALUE.
--*/
{
   ULONG NumberDevices;
   HANDLE hOut = INVALID_HANDLE_VALUE;
   HDEVINFO                 hardwareDeviceInfo;
   SP_DEVICE_INTERFACE_DATA deviceInfoData;
   ULONG                    i;
   BOOLEAN                  done;
   PUSB_DEVICE_DESCRIPTOR   usbDeviceInst;
   PUSB_DEVICE_DESCRIPTOR       *UsbDevices = &usbDeviceInst;

   *UsbDevices = NULL;
   NumberDevices = 0;

   //
   // Open a handle to the plug and play dev node.
   // SetupDiGetClassDevs() returns a device information set that contains info on all
   // installed devices of a specified class.
   //
   hardwareDeviceInfo = SetupDiGetClassDevs (
                           pGuid,
                           NULL, // Define no enumerator (global)
                           NULL, // Define no
                           (DIGCF_PRESENT | // Only Devices present
                            DIGCF_DEVICEINTERFACE)); // Function class devices.

   //
   // Take a wild guess at the number of devices we have;
   // Be prepared to realloc and retry if there are more than we guessed
   //
   NumberDevices = 4;
   done = FALSE;
   deviceInfoData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

   i=0;
   while (!done) {
      NumberDevices *= 2;

      if (*UsbDevices) {
         *UsbDevices =
               realloc (*UsbDevices, (NumberDevices * sizeof (USB_DEVICE_DESCRIPTOR)));
      } else {
         *UsbDevices = calloc (NumberDevices, sizeof (USB_DEVICE_DESCRIPTOR));
      }

      if (NULL == *UsbDevices) {

         // SetupDiDestroyDeviceInfoList destroys a device information set
         // and frees all associated memory.

         SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
         return INVALID_HANDLE_VALUE;
      }

      usbDeviceInst = *UsbDevices + i;

      for (; i < NumberDevices; i++) {

         // SetupDiEnumDeviceInterfaces() returns information about device interfaces
         // exposed by one or more devices. Each call returns information about one interface;
         // the routine can be called repeatedly to get information about several interfaces
         // exposed by one or more devices.

         if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                         0, // We don't care about specific PDOs
                                                                                 pGuid,
                                         i,
                                         &deviceInfoData)) {

            hOut = OpenOneDevice (hardwareDeviceInfo, &deviceInfoData, outNameBuf);
                        if ( hOut != INVALID_HANDLE_VALUE ) {
               done = TRUE;
               break;
                        }
         } else {
            if (ERROR_NO_MORE_ITEMS == GetLastError()) {
               done = TRUE;
               break;
            }
         }
      }
   }

   NumberDevices = i;

   // SetupDiDestroyDeviceInfoList() destroys a device information set
   // and frees all associated memory.

   SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
   free ( *UsbDevices );
   return hOut;
}




BOOL
GetUsbDeviceFileName( LPGUID  pGuid, char *outNameBuf)
/*++
Routine Description:

    Given a ptr to a driver-registered GUID, give us a string with the device name
    that can be used in a CreateFile() call.
    Actually briefly opens and closes the device and sets outBuf if successfull;
    returns FALSE if not

Arguments:

    pGuid:      ptr to GUID registered by the driver itself
    outNameBuf: the generated zero-terminated name for this device

Return Value:

    TRUE on success else FALSE

--*/
{
        HANDLE hDev = OpenUsbDevice( pGuid, outNameBuf );
        if ( hDev != INVALID_HANDLE_VALUE )
        {
                CloseHandle( hDev );
                return TRUE;
        }
        return FALSE;

}

HANDLE
open_dev()
/*++
Routine Description:

    Called by dumpUsbConfig() to open an instance of our device

Arguments:

    None

Return Value:

    Device handle on success else NULL

--*/
{

        HANDLE hDEV = OpenUsbDevice( (LPGUID)&GUID_CLASS_I82930_BULK, completeDeviceName);


        if (hDEV == INVALID_HANDLE_VALUE) {
                printf("Failed to open (%s) = %d", completeDeviceName, GetLastError());
        } else {
                printf("DeviceName = (%s)\n", completeDeviceName);
    }           

        return hDEV;
}


HANDLE
open_file( char *filename)
/*++
Routine Description:

    Called by main() to open an instance of our device after obtaining its name

Arguments:

    None

Return Value:

    Device handle on success else NULL

--*/
{

        int success = 1;
        HANDLE h;

        if ( !GetUsbDeviceFileName(
                (LPGUID) &GUID_CLASS_I82930_BULK,
                completeDeviceName) )
        {
                NOISY(("Failed to GetUsbDeviceFileName\n", GetLastError()));
                return  INVALID_HANDLE_VALUE;
        }

    strcat (completeDeviceName,
                        "\\"
                        );                      

    strcat (completeDeviceName,
                        filename
                        );                                      

        printf("completeDeviceName = (%s)\n", completeDeviceName);

        h = CreateFile(completeDeviceName,
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_WRITE | FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);

        if (h == INVALID_HANDLE_VALUE) {
                NOISY(("Failed to open (%s) = %d", completeDeviceName, GetLastError()));
                success = 0;
        } else {
                        NOISY(("Opened successfully.\n"));
    }           

        return h;
}

void
usage()
/*++
Routine Description:

    Called by main() to dump usage info to the console when
    the app is called with no parms or with an invalid parm

Arguments:

    None

Return Value:

    None

--*/
{
    static int i=1;

    if (i) {
        printf("Usage for Read/Write test:\n");
        printf("-r [n] where n is number of bytes to read\n");
        printf("-w [n] where n is number of bytes to write\n");
        printf("-c [n] where n is number of iterations (default = 1)\n");
        printf("-i [s] where s is the input pipe\n");
        printf("-o [s] where s is the output pipe\n");
        printf("-v verbose -- dumps read data\n");

        printf("\nUsage for USB and Endpoint info:\n");
        printf("-u to dump USB configuration and pipe info \n");
        i = 0;
    }
}


void
parse(
    int argc,
    char *argv[] )
/*++
Routine Description:

    Called by main() to parse command line parms

Arguments:

    argc and argv that was passed to main()

Return Value:

    Sets global flags as per user function request

--*/
{
    int i;

        if ( argc < 2 ) // give usage if invoked with no parms
                usage();

    for (i=0; i<argc; i++) {
        if (argv[i][0] == '-' ||
            argv[i][0] == '/') {
            switch(argv[i][1]) {
            case 'r':
            case 'R':
                ReadLen = atoi(&argv[i+1][0]);
                                fRead = TRUE;
                i++;
                break;
            case 'w':
            case 'W':
                WriteLen = atoi(&argv[i+1][0]);
                                fWrite = TRUE;
                i++;
                break;
            case 'c':
            case 'C':
                IterationCount = atoi(&argv[i+1][0]);
                i++;
                break;
            case 'i':
            case 'I':
                strcpy(inPipe, &argv[i+1][0]);
                i++;
                break;
            case 'u':
            case 'U':
                fDumpUsbConfig = TRUE;
                                i++;
                break;
            case 'v':
            case 'V':
                fDumpReadData = TRUE;
                                i++;
                break;
                         case 'o':
             case 'O':
                strcpy(outPipe, &argv[i+1][0]);
                i++;
                break;
            default:
                usage();
            }
        }
    }
}

BOOL
compare_buffs(char *buff1, char *buff2, int length)
/*++
Routine Description:

    Called to verify read and write buffers match for loopback test

Arguments:

    buffers to compare and length

Return Value:

    TRUE if buffers match, else FALSE

--*/
{
    int ok = 1;

        if (memcmp(buff1, buff2, length )) {

                // Edi, and Esi point to the mismatching char and ecx indicates the
                // remaining length.
                ok = 0;
        }


    return ok;
}

#define NPERLN 8

void
dump(
   UCHAR *b,
   int len
)
/*++
Routine Description:

    Called to do formatted ascii dump to console of the io buffer

Arguments:

    buffer and length

Return Value:

    none

--*/
{
    ULONG i;
        ULONG longLen = (ULONG)len / sizeof( ULONG );
        PULONG pBuf = (PULONG) b;

        // dump an ordinal ULONG for each sizeof(ULONG)'th byte
    printf("\n****** BEGIN DUMP LEN decimal %d, 0x%x\n", len,len);
    for (i=0; i<longLen; i++) {
        printf("%04X ", *pBuf++);
        if (i % NPERLN == (NPERLN - 1)) {
            printf("\n");
        }
    }
    if (i % NPERLN != 0) {
        printf("\n");
    }
    printf("\n****** END DUMP LEN decimal %d, 0x%x\n", len,len);
}





// Begin, routines for USB configuration dump (Cmdline "rwbulk -u" )


char
*usbDescriptorTypeString(UCHAR bDescriptorType )
/*++
Routine Description:

    Called to get ascii string of USB descriptor

Arguments:

        PUSB_ENDPOINT_DESCRIPTOR->bDescriptorType or
        PUSB_DEVICE_DESCRIPTOR->bDescriptorType or
        PUSB_INTERFACE_DESCRIPTOR->bDescriptorType or
        PUSB_STRING_DESCRIPTOR->bDescriptorType or
        PUSB_POWER_DESCRIPTOR->bDescriptorType or
        PUSB_CONFIGURATION_DESCRIPTOR->bDescriptorType

Return Value:

    ptr to string

--*/{

        switch(bDescriptorType) {

        case USB_DEVICE_DESCRIPTOR_TYPE:
                return "USB_DEVICE_DESCRIPTOR_TYPE";

        case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                return "USB_CONFIGURATION_DESCRIPTOR_TYPE";
                

        case USB_STRING_DESCRIPTOR_TYPE:
                return "USB_STRING_DESCRIPTOR_TYPE";
                

        case USB_INTERFACE_DESCRIPTOR_TYPE:
                return "USB_INTERFACE_DESCRIPTOR_TYPE";
                

        case USB_ENDPOINT_DESCRIPTOR_TYPE:
                return "USB_ENDPOINT_DESCRIPTOR_TYPE";
                

#ifdef USB_POWER_DESCRIPTOR_TYPE // this is the older definintion which is actually obsolete
    // workaround for temporary bug in 98ddk, older USB100.h file
        case USB_POWER_DESCRIPTOR_TYPE:
                return "USB_POWER_DESCRIPTOR_TYPE";
#endif
                
#ifdef USB_RESERVED_DESCRIPTOR_TYPE  // this is the current version of USB100.h as in NT5DDK

        case USB_RESERVED_DESCRIPTOR_TYPE:
                return "USB_RESERVED_DESCRIPTOR_TYPE";

        case USB_CONFIG_POWER_DESCRIPTOR_TYPE:
                return "USB_CONFIG_POWER_DESCRIPTOR_TYPE";

        case USB_INTERFACE_POWER_DESCRIPTOR_TYPE:
                return "USB_INTERFACE_POWER_DESCRIPTOR_TYPE";
#endif // for current nt5ddk version of USB100.h

        default:
                return "??? UNKNOWN!!"; 
        }
}


char
*usbEndPointTypeString(UCHAR bmAttributes)
/*++
Routine Description:

    Called to get ascii string of endpt descriptor type

Arguments:

        PUSB_ENDPOINT_DESCRIPTOR->bmAttributes

Return Value:

    ptr to string

--*/
{
        UINT typ = bmAttributes & USB_ENDPOINT_TYPE_MASK;


        switch( typ) {
        case USB_ENDPOINT_TYPE_INTERRUPT:
                return "USB_ENDPOINT_TYPE_INTERRUPT";

        case USB_ENDPOINT_TYPE_BULK:
                return "USB_ENDPOINT_TYPE_BULK";        

        case USB_ENDPOINT_TYPE_ISOCHRONOUS:
                return "USB_ENDPOINT_TYPE_ISOCHRONOUS"; 
                
        case USB_ENDPOINT_TYPE_CONTROL:
                return "USB_ENDPOINT_TYPE_CONTROL";     
                
        default:
                return "??? UNKNOWN!!"; 
        }
}


char
*usbConfigAttributesString(UCHAR bmAttributes)
/*++
Routine Description:

    Called to get ascii string of USB_CONFIGURATION_DESCRIPTOR attributes

Arguments:

        PUSB_CONFIGURATION_DESCRIPTOR->bmAttributes

Return Value:

    ptr to string

--*/
{
        UINT typ = bmAttributes & USB_CONFIG_POWERED_MASK;


        switch( typ) {

        case USB_CONFIG_BUS_POWERED:
                return "USB_CONFIG_BUS_POWERED";

        case USB_CONFIG_SELF_POWERED:
                return "USB_CONFIG_SELF_POWERED";
                
        case USB_CONFIG_REMOTE_WAKEUP:
                return "USB_CONFIG_REMOTE_WAKEUP";

                
        default:
                return "??? UNKNOWN!!"; 
        }
}


void
print_USB_CONFIGURATION_DESCRIPTOR(PUSB_CONFIGURATION_DESCRIPTOR cd)
/*++
Routine Description:

    Called to do formatted ascii dump to console of a USB config descriptor

Arguments:

    ptr to USB configuration descriptor

Return Value:

    none

--*/
{
    printf("\n===================\nUSB_CONFIGURATION_DESCRIPTOR\n");

    printf(
    "bLength = 0x%x, decimal %d\n", cd->bLength, cd->bLength
    );

    printf(
    "bDescriptorType = 0x%x ( %s )\n", cd->bDescriptorType, usbDescriptorTypeString( cd->bDescriptorType )
    );

    printf(
    "wTotalLength = 0x%x, decimal %d\n", cd->wTotalLength, cd->wTotalLength
    );

    printf(
    "bNumInterfaces = 0x%x, decimal %d\n", cd->bNumInterfaces, cd->bNumInterfaces
    );

    printf(
    "bConfigurationValue = 0x%x, decimal %d\n", cd->bConfigurationValue, cd->bConfigurationValue
    );

    printf(
    "iConfiguration = 0x%x, decimal %d\n", cd->iConfiguration, cd->iConfiguration
    );

    printf(
    "bmAttributes = 0x%x ( %s )\n", cd->bmAttributes, usbConfigAttributesString( cd->bmAttributes )
    );

    printf(
    "MaxPower = 0x%x, decimal %d\n", cd->MaxPower, cd->MaxPower
    );
}


void
print_USB_INTERFACE_DESCRIPTOR(PUSB_INTERFACE_DESCRIPTOR id, UINT ix)
/*++
Routine Description:

    Called to do formatted ascii dump to console of a USB interface descriptor

Arguments:

    ptr to USB interface descriptor

Return Value:

    none

--*/
{
    printf("\n-----------------------------\nUSB_INTERFACE_DESCRIPTOR #%d\n", ix);


    printf(
    "bLength = 0x%x\n", id->bLength
    );


    printf(
    "bDescriptorType = 0x%x ( %s )\n", id->bDescriptorType, usbDescriptorTypeString( id->bDescriptorType )
    );


    printf(
    "bInterfaceNumber = 0x%x\n", id->bInterfaceNumber
    );
    printf(
    "bAlternateSetting = 0x%x\n", id->bAlternateSetting
    );
    printf(
    "bNumEndpoints = 0x%x\n", id->bNumEndpoints
    );
    printf(
    "bInterfaceClass = 0x%x\n", id->bInterfaceClass
    );
    printf(
    "bInterfaceSubClass = 0x%x\n", id->bInterfaceSubClass
    );
    printf(
    "bInterfaceProtocol = 0x%x\n", id->bInterfaceProtocol
    );
    printf(
    "bInterface = 0x%x\n", id->iInterface
    );
}


void
print_USB_ENDPOINT_DESCRIPTOR(PUSB_ENDPOINT_DESCRIPTOR ed, int i)
/*++
Routine Description:

    Called to do formatted ascii dump to console of a USB endpoint descriptor

Arguments:

    ptr to USB endpoint descriptor,
        index of this endpt in interface desc

Return Value:

    none

--*/
{
    printf(
        "------------------------------\nUSB_ENDPOINT_DESCRIPTOR for Pipe%02d\n", i
        );

    printf(
    "bLength = 0x%x\n", ed->bLength
    );

    printf(
    "bDescriptorType = 0x%x ( %s )\n", ed->bDescriptorType, usbDescriptorTypeString( ed->bDescriptorType )
    );


        if ( USB_ENDPOINT_DIRECTION_IN( ed->bEndpointAddress ) ) {
                printf(
                "bEndpointAddress= 0x%x ( INPUT )\n", ed->bEndpointAddress
                );
        } else {
                printf(
                "bEndpointAddress= 0x%x ( OUTPUT )\n", ed->bEndpointAddress
                );
        }

    printf(
    "bmAttributes= 0x%x ( %s )\n", ed->bmAttributes, usbEndPointTypeString ( ed->bmAttributes )
    );


    printf(
    "wMaxPacketSize= 0x%x, decimal %d\n", ed->wMaxPacketSize, ed->wMaxPacketSize
    );
    printf(
    "bInterval = 0x%x, decimal %d\n", ed->bInterval, ed->bInterval
    );
}

void
rw_dev( HANDLE hDEV )
/*++
Routine Description:

    Called to do formatted ascii dump to console of  USB
    configuration, interface, and endpoint descriptors
    (Cmdline "rwbulk -u" )

Arguments:

    handle to device

Return Value:

    none

--*/
{
        UINT success;
        int siz, nBytes;
        char buf[256];
    PUSB_CONFIGURATION_DESCRIPTOR cd;
    PUSB_INTERFACE_DESCRIPTOR id;
    PUSB_ENDPOINT_DESCRIPTOR ed;

        siz = sizeof(buf);

        if (hDEV == INVALID_HANDLE_VALUE) {
                NOISY(("DEV not open"));
                return;
        }
        
        success = DeviceIoControl(hDEV,
                        IOCTL_BULKUSB_GET_CONFIG_DESCRIPTOR,
                        buf,
                        siz,
                        buf,
                        siz,
                        &nBytes,
                        NULL);

        NOISY(("request complete, success = %d nBytes = %d\n", success, nBytes));
        
        if (success) {
        ULONG i;
                UINT  j, n;
        char *pch;

        pch = buf;
                n = 0;

        cd = (PUSB_CONFIGURATION_DESCRIPTOR) pch;

        print_USB_CONFIGURATION_DESCRIPTOR( cd );

        pch += cd->bLength;

        do {

            id = (PUSB_INTERFACE_DESCRIPTOR) pch;

            print_USB_INTERFACE_DESCRIPTOR(id, n++);

            pch += id->bLength;
            for (j=0; j<id->bNumEndpoints; j++) {

                ed = (PUSB_ENDPOINT_DESCRIPTOR) pch;

                print_USB_ENDPOINT_DESCRIPTOR(ed,j);

                pch += ed->bLength;
            }
            i = (ULONG)(pch - buf);
        } while (i<cd->wTotalLength);

        }
        
        return;

}


int  dumpUsbConfig()
/*++
Routine Description:

    Called to do formatted ascii dump to console of  USB
    configuration, interface, and endpoint descriptors
    (Cmdline "rwbulk -u" )

Arguments:

    none

Return Value:

    none

--*/
{

        HANDLE hDEV = open_dev();

        if ( hDEV )
        {
                rw_dev( hDEV );
                CloseHandle(hDEV);
        }

        return 0;
}
//  End, routines for USB configuration and pipe info dump  (Cmdline "rwbulk -u" )



int _cdecl main(
    int argc,
        char *argv[])
/*++
Routine Description:

    Entry point to rwbulk.exe
    Parses cmdline, performs user-requested tests

Arguments:

    argc, argv  standard console  'c' app arguments

Return Value:

    Zero

--*/

{
    char *pinBuf = NULL, *poutBuf = NULL;
    int nBytesRead, nBytesWrite, nBytes;
        ULONG i, j;
    int ok;
    UINT success;
    HANDLE hRead = INVALID_HANDLE_VALUE, hWrite = INVALID_HANDLE_VALUE;
        char buf[1024];
        clock_t start, finish;
        ULONG totalBytes = 0L;
        double seconds;
        ULONG fail = 0L;

    parse(argc, argv );

        // dump USB configuation and pipe info
        if( fDumpUsbConfig ) {
                dumpUsbConfig();
        }


        // doing a read, write, or both test
        if ((fRead) || (fWrite)) {

            if (fRead) {
            //
            // open the output file
            //
                        if ( fDumpReadData ) { // round size to sizeof ULONG for readable dumping
                                while( ReadLen % sizeof( ULONG ) )
                                                ReadLen++;
                        }

            hRead = open_file( inPipe);
        
                pinBuf = malloc(ReadLen);

            }

            if (fWrite) {

                        if ( fDumpReadData ) { // round size to sizeof ULONG for readable dumping
                                while( WriteLen % sizeof( ULONG ) )
                                                WriteLen++;
                        }

                hWrite = open_file( outPipe);
                poutBuf = malloc(WriteLen);
            }


        for (i=0; i<IterationCount; i++) {

            if (fWrite && poutBuf && hWrite != INVALID_HANDLE_VALUE) {

                                PULONG pOut = (PULONG) poutBuf;
                                ULONG  numLongs = WriteLen / sizeof( ULONG );
                //
                // put some data in the output buffer
                //

                for (j=0; j<numLongs; j++) {
                    *(pOut+j) = j;
                }

                //
                // send the write
                //

                    WriteFile(hWrite,
                              poutBuf,
                              WriteLen,
                              &nBytesWrite,
                              NULL);

                    printf("<%s> W (%04.4d) : request %06.6d bytes -- %06.6d bytes written\n",
                            outPipe, i, WriteLen, nBytesWrite);
                assert(nBytesWrite == WriteLen);
                }

                if (fRead && pinBuf) {

                    success = ReadFile(hRead,
                                  pinBuf,
                              ReadLen,
                                  &nBytesRead,
                                  NULL);

                    printf("<%s> R (%04.4d) : request %06.6d bytes -- %06.6d bytes read\n",
                        inPipe, i, ReadLen, nBytesRead);

                if (fWrite) {

                    //
                    // validate the input buffer against what
                    // we sent to the 82930 (loopback test)
                    //

                    ok = compare_buffs(pinBuf, poutBuf,  nBytesRead);

                                        if( fDumpReadData ) {
                                                printf("Dumping read buffer\n");
                                                dump( pinBuf, nBytesRead );     
                                                printf("Dumping write buffer\n");
                                                dump( poutBuf, nBytesRead );

                                        }

                    assert(ok);

                                        if(ok != 1)
                                                fail++;

                    assert(ReadLen == WriteLen);
                    assert(nBytesRead == ReadLen);
                    assert(nBytesWrite == WriteLen);
                }
                }
        
        }


        if (pinBuf) {
            free(pinBuf);
        }

        if (poutBuf) {
            free(poutBuf);
        }


                // close devices if needed
                if(hRead != INVALID_HANDLE_VALUE)
                        CloseHandle(hRead);
                if(hWrite != INVALID_HANDLE_VALUE)
                        CloseHandle(hWrite);

    }           

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\x86.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation.  All Rights Reserved.


Module Name:

    x86.h

Abstract:

    This module contains private x86 processor specific defines, structures, inline
    functions and macros.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/


// CR0 floating point unit flags.

#define FPUMONITOR 0x2
#define FPUEMULATION 0x4
#define FPUTASKSWITCHED 0x8
#define FPU387COMPATIBLE 0x10
#define FPUEXCEPTION 0x20
#define FPUMASK (FPUEXCEPTION|FPU387COMPATIBLE|FPUTASKSWITCHED|FPUEMULATION|FPUMONITOR)




#pragma pack(push,1)


typedef struct {
	DWORD offset;
	WORD selector;
	} SPTR;


// x86 interrupt descriptor table base register

typedef struct {
	WORD limit;
	DWORD base;
	} IDT;


// x86 interrupt descriptor.

typedef struct {
	WORD lowoffset;
	WORD selector;
	WORD flags;
	WORD highoffset;
	} ID;


// x86 task state segment

typedef struct {
	WORD link;					WORD reserved0;
	DWORD esp0;
	WORD ss0;					WORD reserved1;
	DWORD esp1;
	WORD ss1;					WORD reserved2;
	DWORD esp2;
	WORD ss2;					WORD reserved3;
	DWORD cr3;
	DWORD eip;
	DWORD eflags;
	DWORD eax;
	DWORD ecx;
	DWORD edx;
	DWORD ebx;
	DWORD esp;
	DWORD ebp;
	DWORD esi;
	DWORD edi;
	WORD es;					WORD reserved4;
	WORD cs;					WORD reserved5;
	WORD ss;					WORD reserved6;
	WORD ds;					WORD reserved7;
	WORD fs;					WORD reserved8;
	WORD gs;					WORD reserved9;
	WORD ldt;					WORD reserved10;
	WORD t;
	WORD iomap;
	} TSS;

#pragma pack(pop)




#pragma warning ( disable : 4035 )


//
// __inline
// ULONG
// ReadCR0 (
//     VOID
//     )
//
//*++
//
// Routine Description:
//
//      This routine returns the current contents of the processor CR0 register.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      32 bit contents of CR0.
//
//*--

__inline
ULONG
ReadCR0 (
    VOID
    )
{

    __asm {
        mov eax,cr0
        }

}

// __inline
// VOID
// WriteCR0 (
//     ULONG data
//     )
//
//*++
//
// Routine Description:
//
//      Loads processor CR0 register with the value passed in data.
//
// Arguments:
//
//      data - Supplies the value to be loaded into processor CR0 register.
//
// Return Value:
//
//      None.
//
//*--

__inline
VOID
WriteCR0 (
    ULONG data
    )
{

    __asm {
        mov eax,data
        mov cr0,eax
        }

}

// __inline
// ULONG
// ReadCR3 (
//     VOID
//     )
//
//*++
//
// Routine Description:
//
//      This routine returns the current contents of the processor CR3 register.
//
// Arguments:
//
// Return Value:
//
//      32 bit contents of CR3.
//
//*--

__inline
ULONG
ReadCR3 (
    VOID
    )
{

    __asm {
        __asm _emit 0xf __asm _emit 0x20 __asm _emit 0xd8 //mov eax,cr3
        }

}

// __inline
// ULONG
// ReadCR4 (
//     VOID
//     )
//
//*++
//
// Routine Description:
//
//      This routine returns the current contents of the processor CR4 register.
//
// Arguments:
//
// Return Value:
//
//      32 bit contents of CR4.
//
//*--

__inline
ULONG
ReadCR4 (
    VOID
    )
{

    __asm {
        __asm _emit 0xf __asm _emit 0x20 __asm _emit 0xe0 //mov eax,cr4
        }

}

// __inline
// VOID
// WriteCR4 (
//     ULONG data
//     )
//
//*++
//
// Routine Description:
//
//      Loads processor CR4 register with the value passed in data.
//
// Arguments:
//
// Return Value:
//
//      None.
//
//*--

__inline
VOID
WriteCR4 (
    ULONG data
    )
{

    __asm {
        mov eax,data
        __asm _emit 0xf __asm _emit 0x22 __asm _emit 0xe0 // mov cr4,eax
        }

}

#pragma warning ( default : 4035 )



// __inline
// VOID
// LoadCR0 (
//     ULONG value
//     )
//
//*++
//
// Macro Description:
//
//      Loads processor CR0 register with the value passed in value.  Uses CS (code
//      segment) override to read contents of value so that it can be used when the
//      contents of DS (data segment) are indeterminate/invalid.
//
// Arguments:
//
//      value - Supplies the variable whose value is to be loaded into processor CR0 register.
//
//      (assumed) CS - code segment pointer is used to access value parameter.
//
// Return Value:
//
//      None.
//
//*--

#define LoadCR0(value) \
__asm {	\
	__asm mov eax,cs:value \
	__asm mov cr0,eax	\
	}


// __inline
// VOID
// SaveIDT (
//     IDT IDT
//     )
//
//*++
//
// Macro Description:
//
//      Saves processor IDT register into variable IDT.
//
// Arguments:
//
//      IDT - Supplies variable into which processor IDT value is written.
//
// Return Value:
//
//      None.
//
//*--

#define SaveIDT( IDT ) \
	__asm sidt IDT


// __inline
// VOID
// LoadIDT (
//     IDT IDT
//     )
//
//*++
//
// Macro Description:
//
//      Loads processor IDT register from variable IDT.
//
// Arguments:
//
//      IDT - Supplies value which is loaded into processor IDT.  Uses CS (code
//      segment) override to read contents of value so that it can be used when the
//      contents of DS (data segment) are indeterminate/invalid.
//
//      (assumed) CS - code segment pointer is used to access IDT parameter.
//
// Return Value:
//
//      None.
//
//*--

#define LoadIDT( IDT ) \
	__asm lidt cs:IDT


// __inline
// VOID
// Return (
//     VOID
//     )
//
//*++
//
// Macro Description:
//
//      Performs an IRETD.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      None.
//
//*--

#define Return() \
	__asm iretd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\rt\exec\spinlock.c ===
#include "common.h"
#include "rtinfo.h"
#include <rt.h>
#include "rtp.h"


//#define SPEW 1


extern volatile ULONG currentthread;
extern volatile ULONG windowsthread;

#define INITIALSPINLOCKVALUE 0


// We need to make the Acquire and Release spinlock calls safe for
// real time threads.  We do this by  ALWAYS acquiring
// the spinlock.  We have to acquire spinlocks now since real time threads
// can run when normal windows threads are running at raised irql.


volatile ULONG *pCurrentRtThread=&(volatile ULONG)currentthread;
BOOL (*TransferControl)(WORD State, ULONG Data, BOOL (*DoTransfer)(PVOID), PVOID Context)=RtpTransferControl;
VOID (*ForceAtomic)(VOID (*AtomicOperation)(PVOID), PVOID Context)=RtpForceAtomic;



BOOL True(PVOID Context)
{

return TRUE;

}


#pragma warning( disable : 4035 )

// If value==*destination, then *destination=source and function returns
// true.  Otherwise *destination is unchanged and function returns false.

ULONG __inline CompareExchange(ULONG *destination, ULONG source, ULONG value)
{

ASSERT( destination!=NULL );
ASSERT( source!=value );

__asm {
	mov eax,value
	mov ecx,source
	mov edx,destination
	lock cmpxchg [edx],ecx
	mov	eax,0
	jnz done
	inc eax
done:
	}

}

#pragma warning( default : 4035 )

/*

To enable realtime threads to be switched out while they are holding spinlocks,
I had to extend the significance and use of the KSPIN_LOCK variable.

Previous NT spinlock code only ever sets or clears the bottom bit of a spinlock.
Previous 9x spinlock code never touched the spinlock at all, since 9x is a 
uniprocessor platform - spinlocks simply raised and lowered irql.  That is
no longer true.  Spinlocks in the rt world do more than they ever did on either
NT or 9x.

The bottom 2 bits (bits 0 and 1) mean the following

If bit 0 is set, the spinlock is claimed.  This is compatible with existing NT usage.
If bit 1 is set, the spinlock has a next in line claim.

The bottom 2 bits can transition between the following states:

00 -> 01    ; spinlock free -> spinlock claimed
01 -> 00    ; spinlock claimed -> spinlock free
01 -> 11    ; spinlock claimed -> spinlock claimed and next in line claimed
11 -> 10    ; spinlock claimed and next in line claimed -> spinlock not claimed and next in line claimed
10 -> 01    ; spinlock not claimed and next in line claimed -> spinlock claimed


The top 30 bits hold a realtime thread handle.  They identify which
realtime thread is either holding the lock or is next in line.

If bit 1 is set, then the top 30 bits identify the next in line thread
otherwise the top 30 bits identify the current owner.

Normally we have the following state transitions:

00->01 followed by 01->00

That is the no contention for the lock case.

Otherwise we have the following sequence:

00->01, 01->11, 11->10, 10->01  

after which we can have either 01->00 or 01->11

*/


typedef struct {
    PKSPIN_LOCK SpinLock;
    ULONG YieldToThisThread;
    } YIELDINFO, *PYIELDINFO;



BOOL NextInLine(PVOID Context)
{

PYIELDINFO YieldInfo=(PYIELDINFO)Context;

return CompareExchange(YieldInfo->SpinLock, 3|*pCurrentRtThread, 1|(YieldInfo->YieldToThisThread&~(3)));

}



BOOL YieldToNextInLine(PVOID Context)
{

PYIELDINFO YieldInfo=(PYIELDINFO)Context;

return CompareExchange(YieldInfo->SpinLock, YieldInfo->YieldToThisThread&~(1), YieldInfo->YieldToThisThread);

}



VOID
FASTCALL
RtKfAcquireLock(
    IN PKSPIN_LOCK SpinLock
    )
{

YIELDINFO YieldInfo;
ULONG SpinCount;

SpinCount=0;

while (TRUE) {

    if (CompareExchange(SpinLock, 1|*pCurrentRtThread, INITIALSPINLOCKVALUE) || CompareExchange(SpinLock, 1|*pCurrentRtThread, 2|*pCurrentRtThread)) {
        // We got the spinlock.  We're outa here.
        break;
        }

    // If we get here, then someone else is holding the spinlock.  We will
    // try to queue up after them and ensure that we get it next.
    YieldInfo.SpinLock=SpinLock;
    YieldInfo.YieldToThisThread=*(volatile ULONG *)SpinLock;

    // Make sure the spinlock is not currently free.
    if (YieldInfo.YieldToThisThread==INITIALSPINLOCKVALUE) {
        continue;
        }

    // Make sure that someone is NOT trying to acquire a spinlock they already
    // acquired.
    if (((YieldInfo.YieldToThisThread^*pCurrentRtThread)&~(3))==0) {
        // Someone is trying to acquire a spinlock more than once.
#ifdef SPEW
        if (!RtThread()) {
            DbgPrint("BugCheck 0xf: Acquiring already owned spinlock 0x%x.\n", SpinLock);
            }
        Break();
#endif
        break;
        }

    // Make sure the spinlock is not in an invalid state.
    // ie: Make sure it has been initialized properly.
    if ((YieldInfo.YieldToThisThread&(3))==0 ||
        !(YieldInfo.YieldToThisThread&~(3))) {
        // Spinlock has either been trashed, or was not initialized properly.
#ifdef SPEW
        if (!RtThread()) {
            DbgPrint("BugCheck 0x81: Invalid spinlock state 0x%x.\n", SpinLock);
            }
        Break();
#endif
        break;
        }

    if (TransferControl!=NULL) {
        // Try to claim the lock next - so that we will get
        // Yielded to when the lock is released.

        if ((*TransferControl)(BLOCKEDONSPINLOCK, YieldInfo.YieldToThisThread, NextInLine, &YieldInfo)) {
            // We successfully queued up to get control when the lock is released,
            // and we updated our state atomically and transferred control up to the
            // realtime executive.  All with one nasty call.
            // That means when control comes back, we should be able to get the spinlock
            // on the next try.
            // UNLESS this is the windows thread.  In that case, we CAN come back
            // so that interrupts can get serviced.
            if (!RtThread()) {
                // Windows thread.  We allow windows threads to get switched to even
                // when they are blocked on a spinlock so that interrupts can be
                // serviced.
                while (*SpinLock!=(2|*pCurrentRtThread)) {
                    // If we get here, then the spinlock is still held by the realtime
                    // thread, so we simply yield back again to it - now that interrupts
                    // have all been serviced.
                    if (SpinCount++>100) {
                        Break();
                        }
                    (*TransferControl)(BLOCKEDONSPINLOCK, YieldInfo.YieldToThisThread, True, NULL);
                    }
                }
            
            if (*SpinLock!=(2|*pCurrentRtThread)) {
                // If the spinlock doesn't have above state at this point, something
                // is horribly wrong.
                Break();
                }
            continue;
            }
        else {

            // We failed to get in line behind the owner.  So, see if the owner
            // just released the lock.
            if (!SpinCount++) {
                continue;
                }
            else {

                //Break();  - TURN OFF FOR NOW  - ADD a test based on whether windows
                // or not.

                // There must have been multiple threads queued up on this lock.
                // Yield.

                // OR the other possibility is that we yielded the spinlock to windows
                // which is servicing interrupts before it marks the spinlock as ready
                // to be queued up on - so we are stuck waiting for Windows to get around
                // to the compare exchange where it claims the spinlock.
                (*TransferControl)(SPINNINGONSPINLOCK, YieldInfo.YieldToThisThread, True, NULL);
                }
            }
        
        }
    else {
        // If we get here, then we are NOT running RT, and someone is trying to
        // acquire a held spinlock.  That is a fatal error.
        // Break into debugger if present.
#ifdef SPEW
        DbgPrint("BugCheck 0xf: Acquiring already owned spinlock 0x%x.\n", SpinLock);
        Break();
#endif
        break;
        }

    }

}



VOID
FASTCALL
RtKfReleaseLock(
    IN PKSPIN_LOCK SpinLock
    )
{

// Release the spinlock.  Break if spinlock not owned.

if (!CompareExchange(SpinLock, INITIALSPINLOCKVALUE, 1|*pCurrentRtThread)) {

    // If we get here, then someone queued up behind us and tried to acquire
    // the lock while we were holding it - and they yielded their processor
    // time to us, so we must yield back to them.  The nice thing about this
    // is that this yield happens before IRQL is lowered - so when this is the
    // windows thread we do not have to wait for all of the DPCs and preemtible
    // events to be processed before the realtime thread waiting on the lock
    // gets to run.  He runs as soon as we yield, and when control again
    // comes around to us, we can then continue on and lower irql.
    
    if (TransferControl!=NULL) {

        YIELDINFO YieldInfo;

        YieldInfo.SpinLock=SpinLock;
        YieldInfo.YieldToThisThread=*SpinLock;

        if ((YieldInfo.YieldToThisThread&3)!=3) {
            // It is an ERROR if we get here and both low order bits are not set 
            // in the spinlock.
#ifdef SPEW
            if (!RtThread()) {
                DbgPrint("BugCheck 0x10: Releasing unowned spinlock 0x%x.\n", SpinLock);
                }
            Break();
#endif
            return;
            }

        // Try to release the lock to the thread queued up behind us and then
        // transfer control to him and we're done.  When he wakes up he will
        // claim the lock and someone else can get in behind him if needed.
        if ((*TransferControl)(YIELDAFTERSPINLOCKRELEASE, YieldInfo.YieldToThisThread, YieldToNextInLine, &YieldInfo)) {
            return;
            }
        else {
            // It is an ERROR to get here.  We should never fail to release
            // the thread blocked on us.
            Break();
            }

        }
    else {
        // We get here if the realtime executive is not running, but we could
        // not release the spinlock.  That will only happen if either the spinlock
        // was not owned, or InitialWindowsThread or pCurrentRtThread have 
        // been corrupted.
#ifdef SPEW
        DbgPrint("BugCheck 0x10: Releasing unowned spinlock 0x%x.\n", SpinLock);
        Break();
#endif
    	}

	}

}



KIRQL
FASTCALL
RtKfAcquireSpinLock(
    IN PKSPIN_LOCK SpinLock
    )
{

KIRQL OldIrql;

//ASSERT( KeGetCurrentIrql() <= DISPATCH_LEVEL );

//KeRaiseIrql( DISPATCH_LEVEL, &OldIrql );

OldIrql=*pCurrentIrql;

if (OldIrql>DISPATCH_LEVEL) {
    DbgPrint("Acquiring spinlock 0x%x with IRQL == %d.\n", SpinLock, (ULONG)OldIrql);
    Trap();
    }

*pCurrentIrql=DISPATCH_LEVEL;

RtKfAcquireLock(SpinLock);

return ( OldIrql );

}



VOID
FASTCALL
RtKefAcquireSpinLockAtDpcLevel(
    IN PKSPIN_LOCK  SpinLock)
{

ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

RtKfAcquireLock(SpinLock);

}



KIRQL
FASTCALL
RtKeAcquireSpinLockRaiseToSynch(
    IN PKSPIN_LOCK SpinLock
    )
{

KIRQL OldIrql;

ASSERT( KeGetCurrentIrql() <= SYNCH_LEVEL );

KeRaiseIrql( SYNCH_LEVEL, &OldIrql );

RtKfAcquireLock(SpinLock);

return ( OldIrql );

}



VOID
FASTCALL
RtKfReleaseSpinLock(
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    )
{

KIRQL OldIrql;

// We better be at DISPATCH_LEVEL if we are releasing a spinlock.

OldIrql=*pCurrentIrql;

if (OldIrql!=DISPATCH_LEVEL) {
    DbgPrint("Releasing spinlock 0x%x with IRQL == %d.\n", SpinLock, (ULONG)OldIrql);
    Trap();
    }

// First release the spinlock.

RtKfReleaseLock(SpinLock);

// Set the new IRQL level.

//ASSERT( NewIrql >= 0 && NewIrql < 32 );

if ( !(NewIrql >= 0 && NewIrql < 32) ) {
    Trap();
    }

// We only lower irql on non RT threads, since RT threads should always be running
// at DISPATCH_LEVEL anyway.

if (currentthread==windowsthread) {

    KeLowerIrql( NewIrql );

    }

}



VOID
FASTCALL
RtKefReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    ) 
{

// Release the spinlock.

RtKfReleaseLock(SpinLock);

ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkpnp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkpnp.c

Abstract:

	Bulk USB device driver for Intel 82930 USB test board
	Plug and Play module.
    This file contains routines to handle pnp requests.
    These routines are not USB specific but is required
    for every driver which conforms to the WDM model.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "bulkusb.h"
#include "bulkpnp.h"
#include "bulkpwr.h"
#include "bulkdev.h"
#include "bulkrwr.h"
#include "bulkwmi.h"
#include "bulkusr.h"

NTSTATUS
BulkUsb_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    The plug and play dispatch routines.
    Most of these requests the driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status value

--*/
{
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    KEVENT             startDeviceEvent;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // since the device is removed, fail the Irp.
    //

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    BulkUsb_DbgPrint(3, ("///////////////////////////////////////////\n"));
    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPnP::"));
    BulkUsb_IoIncrement(deviceExtension);

    if(irpStack->MinorFunction == IRP_MN_START_DEVICE) {

        ASSERT(deviceExtension->IdleReqPend == 0);
    }
    else {

        if(deviceExtension->SSEnable) {

            CancelSelectSuspend(deviceExtension);
        }
    }

    BulkUsb_DbgPrint(2, (PnPMinorFunctionString(irpStack->MinorFunction)));

    switch(irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:

        ntStatus = HandleStartDevice(DeviceObject, Irp);

        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        //
        // if we cannot stop the device, we fail the query stop irp
        //

        ntStatus = CanStopDevice(DeviceObject, Irp);

        if(NT_SUCCESS(ntStatus)) {

            ntStatus = HandleQueryStopDevice(DeviceObject, Irp);

            return ntStatus;
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        ntStatus = HandleCancelStopDevice(DeviceObject, Irp);

        break;
     
    case IRP_MN_STOP_DEVICE:

        ntStatus = HandleStopDevice(DeviceObject, Irp);

        BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPnP::IRP_MN_STOP_DEVICE::"));
        BulkUsb_IoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        //
        // if we cannot remove the device, we fail the query remove irp
        //
        ntStatus = HandleQueryRemoveDevice(DeviceObject, Irp);

        return ntStatus;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        ntStatus = HandleCancelRemoveDevice(DeviceObject, Irp);

        break;

    case IRP_MN_SURPRISE_REMOVAL:

        ntStatus = HandleSurpriseRemoval(DeviceObject, Irp);

        BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPnP::IRP_MN_SURPRISE_REMOVAL::"));
        BulkUsb_IoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_REMOVE_DEVICE:

        ntStatus = HandleRemoveDevice(DeviceObject, Irp);

        return ntStatus;

    case IRP_MN_QUERY_CAPABILITIES:

        ntStatus = HandleQueryCapabilities(DeviceObject, Irp);

        break;

    default:

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPnP::default::"));
        BulkUsb_IoDecrement(deviceExtension);

        return ntStatus;

    } // switch

//
// complete request 
//

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

//
// decrement count
//
    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPnP::"));
    BulkUsb_IoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP              Irp
    )
/*++
 
Routine Description:

    This is the dispatch routine for IRP_MN_START_DEVICE

Arguments:

    DeviceObject - pointer to a device object.

    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            startDeviceEvent;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER     dueTime;

    BulkUsb_DbgPrint(3, ("HandleStartDevice - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    deviceExtension->UsbConfigurationDescriptor = NULL;
    deviceExtension->UsbInterface = NULL;
    deviceExtension->PipeContext = NULL;

    //
    // We cannot touch the device (send it any non pnp irps) until a
    // start device has been passed down to the lower drivers.
    // first pass the Irp down
    //

    KeInitializeEvent(&startDeviceEvent, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&startDeviceEvent, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&startDeviceEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("Lower drivers failed this Irp\n"));
        return ntStatus;
    }

    //
    // Read the device descriptor, configuration descriptor 
    // and select the interface descriptors
    //

    ntStatus = ReadandSelectDescriptors(DeviceObject);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("ReadandSelectDescriptors failed\n"));
        return ntStatus;
    }

    //
    // enable the symbolic links for system components to open
    // handles to the device
    //

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         TRUE);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("IoSetDeviceInterfaceState:enable:failed\n"));
        return ntStatus;
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Working);
    deviceExtension->QueueState = AllowRequests;

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // initialize wait wake outstanding flag to false.
    // and issue a wait wake.
    
    deviceExtension->FlagWWOutstanding = 0;
    deviceExtension->FlagWWCancel = 0;
    deviceExtension->WaitWakeIrp = NULL;
    
    if(deviceExtension->WaitWakeEnable) {

        IssueWaitWake(deviceExtension);
    }

    ProcessQueuedRequests(deviceExtension);


    if(WinXpOrBetter == deviceExtension->WdmVersion) {


        deviceExtension->SSEnable = deviceExtension->SSRegistryEnable;

        //
        // set timer.for selective suspend requests
        //

        if(deviceExtension->SSEnable) {

            dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

            KeSetTimerEx(&deviceExtension->Timer, 
                         dueTime,
                         IDLE_INTERVAL,                              // 5000 ms
                         &deviceExtension->DeferredProcCall);

            deviceExtension->FreeIdleIrpCount = 0;
        }
    }

    BulkUsb_DbgPrint(3, ("HandleStartDevice - ends\n"));

    return ntStatus;
}


NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine configures the USB device.
    In this routines we get the device descriptor, 
    the configuration descriptor and select the
    configuration descriptor.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NTSTATUS - NT status value.

--*/
{
    PURB                   urb;
    ULONG                  siz;
    NTSTATUS               ntStatus;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor;
    
    //
    // initialize variables
    //

    urb = NULL;
    deviceDescriptor = NULL;

    //
    // 1. Read the device descriptor
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_DEVICE_DESCRIPTOR);
        deviceDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(deviceDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_DEVICE_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    deviceDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(NT_SUCCESS(ntStatus)) {

                ASSERT(deviceDescriptor->bNumConfigurations);
                ntStatus = ConfigureDevice(DeviceObject);    
            }
                            
            ExFreePool(urb);                
            ExFreePool(deviceDescriptor);
        }
        else {

            BulkUsb_DbgPrint(1, ("Failed to allocate memory for deviceDescriptor"));

            ExFreePool(urb);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        BulkUsb_DbgPrint(1, ("Failed to allocate memory for urb"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
ConfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This helper routine reads the configuration descriptor
    for the device in couple of steps.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NTSTATUS - NT status value

--*/
{
    PURB                          urb;
    ULONG                         siz;
    NTSTATUS                      ntStatus;
    PDEVICE_EXTENSION             deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;

    //
    // initialize the variables
    //

    urb = NULL;
    configurationDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Read the first configuration descriptor
    // This requires two steps:
    // 1. Read the fixed sized configuration desciptor (CD)
    // 2. Read the CD with all embedded interface and endpoint descriptors
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR);
        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    configurationDescriptor,
                    NULL, 
                    sizeof(USB_CONFIGURATION_DESCRIPTOR), 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                BulkUsb_DbgPrint(1, ("UsbBuildGetDescriptorRequest failed\n"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            BulkUsb_DbgPrint(1, ("Failed to allocate mem for config Descriptor\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }

        siz = configurationDescriptor->wTotalLength;

        ExFreePool(configurationDescriptor);

        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE,
                    0, 
                    0, 
                    configurationDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                BulkUsb_DbgPrint(1,("Failed to read configuration descriptor"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            BulkUsb_DbgPrint(1, ("Failed to alloc mem for config Descriptor\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }
    }
    else {

        BulkUsb_DbgPrint(1, ("Failed to allocate memory for urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto ConfigureDevice_Exit;
    }

    if(configurationDescriptor) {

        //
        // save a copy of configurationDescriptor in deviceExtension
        // remember to free it later.
        //
        deviceExtension->UsbConfigurationDescriptor = configurationDescriptor;

        if(configurationDescriptor->bmAttributes & REMOTE_WAKEUP_MASK)
        {
            //
            // this configuration supports remote wakeup
            //
            deviceExtension->WaitWakeEnable = 1;
        }
        else
        {
            deviceExtension->WaitWakeEnable = 0;
        }

        ntStatus = SelectInterfaces(DeviceObject, configurationDescriptor);
    }
    else {

        deviceExtension->UsbConfigurationDescriptor = NULL;
    }

ConfigureDevice_Exit:

    if(urb) {

        ExFreePool(urb);
    }

    return ntStatus;
}

NTSTATUS
SelectInterfaces(
    IN PDEVICE_OBJECT                DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/*++
 
Routine Description:

    This helper routine selects the configuration

Arguments:

    DeviceObject - pointer to device object
    ConfigurationDescriptor - pointer to the configuration
    descriptor for the device

Return Value:

    NT status value

--*/
{
    LONG                        numberOfInterfaces, 
                                interfaceNumber, 
                                interfaceindex;
    ULONG                       i;
    PURB                        urb;
    PUCHAR                      pInf;
    NTSTATUS                    ntStatus;
    PDEVICE_EXTENSION           deviceExtension;
    PUSB_INTERFACE_DESCRIPTOR   interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY  interfaceList, 
                                tmp;
    PUSBD_INTERFACE_INFORMATION Interface;

    //
    // initialize the variables
    //

    urb = NULL;
    Interface = NULL;
    interfaceDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;
    interfaceindex = interfaceNumber = 0;

    //
    // Parse the configuration descriptor for the interface;
    //

    tmp = interfaceList =
        ExAllocatePool(
               NonPagedPool, 
               sizeof(USBD_INTERFACE_LIST_ENTRY) * (numberOfInterfaces + 1));

    if(!tmp) {

        BulkUsb_DbgPrint(1, ("Failed to allocate mem for interfaceList\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    while(interfaceNumber < numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                            ConfigurationDescriptor, 
                                            ConfigurationDescriptor,
                                            interfaceindex,
                                            0, -1, -1, -1);

        if(interfaceDescriptor) {

            interfaceList->InterfaceDescriptor = interfaceDescriptor;
            interfaceList->Interface = NULL;
            interfaceList++;
            interfaceNumber++;
        }

        interfaceindex++;
    }

    interfaceList->InterfaceDescriptor = NULL;
    interfaceList->Interface = NULL;
    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, tmp);

    if(urb) {

        Interface = &urb->UrbSelectConfiguration.Interface;

        for(i=0; i<Interface->NumberOfPipes; i++) {

            //
            // perform pipe initialization here
            // set the transfer size and any pipe flags we use
            // USBD sets the rest of the Interface struct members
            //

            Interface->Pipes[i].MaximumTransferSize = 
                                USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;
        }

        ntStatus = CallUSBD(DeviceObject, urb);

        if(NT_SUCCESS(ntStatus)) {

            //
            // save a copy of interface information in the device extension.
            //
            deviceExtension->UsbInterface = ExAllocatePool(NonPagedPool,
                                                           Interface->Length);

            if(deviceExtension->UsbInterface) {
                
                RtlCopyMemory(deviceExtension->UsbInterface,
                              Interface,
                              Interface->Length);
            }
            else {

                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                BulkUsb_DbgPrint(1, ("memory alloc for UsbInterface failed\n"));
            }

            //
            // Dump the interface to the debugger
            //

            Interface = &urb->UrbSelectConfiguration.Interface;

            BulkUsb_DbgPrint(3, ("---------\n"));
            BulkUsb_DbgPrint(3, ("NumberOfPipes 0x%x\n", 
                                 Interface->NumberOfPipes));
            BulkUsb_DbgPrint(3, ("Length 0x%x\n", 
                                 Interface->Length));
            BulkUsb_DbgPrint(3, ("Alt Setting 0x%x\n", 
                                 Interface->AlternateSetting));
            BulkUsb_DbgPrint(3, ("Interface Number 0x%x\n", 
                                 Interface->InterfaceNumber));
            BulkUsb_DbgPrint(3, ("Class, subclass, protocol 0x%x 0x%x 0x%x\n",
                                 Interface->Class,
                                 Interface->SubClass,
                                 Interface->Protocol));
            //
            // Initialize the PipeContext
            // Dump the pipe info
            //

            deviceExtension->PipeContext = ExAllocatePool(
                                                NonPagedPool,
                                                Interface->NumberOfPipes *
                                                sizeof(BULKUSB_PIPE_CONTEXT));

            if(deviceExtension->PipeContext) {
                
                for(i=0; i<Interface->NumberOfPipes; i++) {

                    deviceExtension->PipeContext[i].PipeOpen = FALSE;
                }
            }
            else {
                    
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                BulkUsb_DbgPrint(1, ("memory alloc for UsbInterface failed\n"));
            }

            for(i=0; i<Interface->NumberOfPipes; i++) {

                BulkUsb_DbgPrint(3, ("---------\n"));
                BulkUsb_DbgPrint(3, ("PipeType 0x%x\n", 
                                     Interface->Pipes[i].PipeType));
                BulkUsb_DbgPrint(3, ("EndpointAddress 0x%x\n", 
                                     Interface->Pipes[i].EndpointAddress));
                BulkUsb_DbgPrint(3, ("MaxPacketSize 0x%x\n", 
                                    Interface->Pipes[i].MaximumPacketSize));
                BulkUsb_DbgPrint(3, ("Interval 0x%x\n", 
                                     Interface->Pipes[i].Interval));
                BulkUsb_DbgPrint(3, ("Handle 0x%x\n", 
                                     Interface->Pipes[i].PipeHandle));
                BulkUsb_DbgPrint(3, ("MaximumTransferSize 0x%x\n", 
                                    Interface->Pipes[i].MaximumTransferSize));
            }

            BulkUsb_DbgPrint(3, ("---------\n"));
        }
        else {

            BulkUsb_DbgPrint(1, ("Failed to select an interface\n"));
        }
    }
    else {
        
        BulkUsb_DbgPrint(1, ("USBD_CreateConfigurationRequestEx failed\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(tmp) {

        ExFreePool(tmp);
    }

    if(urb) {

        ExFreePool(urb);
    }

    return ntStatus;
}


NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine is invoked when the device is removed or stopped.
    This routine de-configures the usb device.

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    PURB     urb;
    ULONG    siz;
    NTSTATUS ntStatus;
    
    //
    // initialize variables
    //

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);
    urb = ExAllocatePool(NonPagedPool, siz);

    if(urb) {

        UsbBuildSelectConfigurationRequest(urb, (USHORT)siz, NULL);

        ntStatus = CallUSBD(DeviceObject, urb);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(3, ("Failed to deconfigure device\n"));
        }

        ExFreePool(urb);
    }
    else {

        BulkUsb_DbgPrint(1, ("Failed to allocate urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    )
/*++
 
Routine Description:

    This routine synchronously submits an urb down the stack.

Arguments:

    DeviceObject - pointer to device object
    Urb - USB request block

Return Value:

--*/
{
    PIRP               irp;
    KEVENT             event;
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize the variables
    //

    irp = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB, 
                                        deviceExtension->TopOfStackDeviceObject,
                                        NULL, 
                                        0, 
                                        NULL, 
                                        0, 
                                        TRUE, 
                                        &event, 
                                        &ioStatus);

    if(!irp) {

        BulkUsb_DbgPrint(1, ("IoBuildDeviceIoControlRequest failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->Parameters.Others.Argument1 = Urb;

    BulkUsb_DbgPrint(3, ("CallUSBD::"));
    BulkUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = ioStatus.Status;
    }
    
    BulkUsb_DbgPrint(3, ("CallUSBD::"));
    BulkUsb_IoDecrement(deviceExtension);
    return ntStatus;
}

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services the Irps of minor type IRP_MN_QUERY_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleQueryStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can stop the device, we need to set the QueueState to 
    // HoldRequests so further requests will be queued.
    //

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
    
    SET_NEW_PNP_STATE(deviceExtension, PendingStop);
    deviceExtension->QueueState = HoldRequests;
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // wait for the existing ones to be finished.
    // first, decrement this operation
    //

    BulkUsb_DbgPrint(3, ("HandleQueryStopDevice::"));
    BulkUsb_IoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("HandleQueryStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_CANCEL_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT value

--*/
{
    KIRQL             oldIrql;    
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleCancelStopDevice - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Send this IRP down and wait for it to come back.
    // Set the QueueState flag to AllowRequests, 
    // and process all the previously queued up IRPs.
    //
    // First check to see whether you have received cancel-stop
    // without first receiving a query-stop. This could happen if someone
    // above us fails a query-stop and passes down the subsequent
    // cancel-stop.
    //

    if(PendingStop == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);
            deviceExtension->QueueState = AllowRequests;
            ASSERT(deviceExtension->DeviceState == Working);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }

    }
    else {

        // spurious Irp
        ntStatus = STATUS_SUCCESS;
    }

    BulkUsb_DbgPrint(3, ("HandleCancelStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    This routine services Irp of minor type IRP_MN_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        if(deviceExtension->SSEnable) {

            //
            // Cancel the timer so that the DPCs are no longer fired.
            // Thus, we are making judicious usage of our resources.
            // we do not need DPCs because the device is stopping.
            // The timers are re-initialized while handling the start
            // device irp.
            //

            KeCancelTimer(&deviceExtension->Timer);

            //
            // after the device is stopped, it can be surprise removed.
            // we set this to 0, so that we do not attempt to cancel
            // the timer while handling surprise remove or remove irps.
            // when we get the start device request, this flag will be
            // reinitialized.
            //
            deviceExtension->SSEnable = 0;

            //
            // make sure that if a DPC was fired before we called cancel timer,
            // then the DPC and work-time have run to their completion
            //
            KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            //
            // make sure that the selective suspend request has been completed.
            //
            KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
        }
    }

    //
    // after the stop Irp is sent to the lower driver object, 
    // the driver must not send any more Irps down that touch 
    // the device until another Start has occurred.
    //

    if(deviceExtension->WaitWakeEnable) {
    
        CancelWaitWake(deviceExtension);
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Stopped);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // This is the right place to actually give up all the resources used
    // This might include calls to IoDisconnectInterrupt, MmUnmapIoSpace, 
    // etc.
    //

    ReleaseMemory(DeviceObject);

    ntStatus = DeconfigureDevice(DeviceObject);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    
    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("HandleStopDevice - ends\n"));
    
    return ntStatus;
}

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_QUERY_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleQueryRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can allow removal of the device, we should set the QueueState
    // to HoldRequests so further requests will be queued. This is required
    // so that we can process queued up requests in cancel-remove just in 
    // case somebody else in the stack fails the query-remove. 
    // 

    ntStatus = CanRemoveDevice(DeviceObject, Irp);

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = HoldRequests;
    SET_NEW_PNP_STATE(deviceExtension, PendingRemove);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    BulkUsb_DbgPrint(3, ("HandleQueryRemoveDevice::"));
    BulkUsb_IoDecrement(deviceExtension);

    //
    // wait for all the requests to be completed
    //

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive,
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("HandleQueryRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_CANCEL_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleCancelRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // We need to reset the QueueState flag to ProcessRequest, 
    // since the device resume its normal activities.
    //

    //
    // First check to see whether you have received cancel-remove
    // without first receiving a query-remove. This could happen if 
    // someone above us fails a query-remove and passes down the 
    // subsequent cancel-remove.
    //

    if(PendingRemove == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);
        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            deviceExtension->QueueState = AllowRequests;
            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
            //
            // process the queued requests that arrive between 
            // QUERY_REMOVE and CANCEL_REMOVE
            //
            
            ProcessQueuedRequests(deviceExtension);
            
        }
    }
    else {

        // 
        // spurious cancel-remove
        //
        ntStatus = STATUS_SUCCESS;
    }

    BulkUsb_DbgPrint(3, ("HandleCancelRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_SURPRISE_REMOVAL

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleSurpriseRemoval - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // 1. fail pending requests
    // 2. return device and memory resources
    // 3. disable interfaces
    //

    if(deviceExtension->WaitWakeEnable) {
    
        CancelWaitWake(deviceExtension);
    }


    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        if(deviceExtension->SSEnable) {

            //
            // Cancel the timer so that the DPCs are no longer fired.
            // we do not need DPCs because the device has been surprise
            // removed
            //  
        
            KeCancelTimer(&deviceExtension->Timer);

            deviceExtension->SSEnable = 0;

            //  
            // make sure that if a DPC was fired before we called cancel timer,
            // then the DPC and work-time have run to their completion
            //
            KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            //
            // make sure that the selective suspend request has been completed.
            //
            KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
        }
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = FailRequests;
    SET_NEW_PNP_STATE(deviceExtension, SurpriseRemoved);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    ProcessQueuedRequests(deviceExtension);

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         FALSE);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
    }

    BulkUsb_AbortPipes(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("HandleSurpriseRemoval - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    ULONG             requestCount;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    BulkUsb_DbgPrint(3, ("HandleRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // The Plug & Play system has dictated the removal of this device.  We
    // have no choice but to detach and delete the device object.
    // (If we wanted to express an interest in preventing this removal,
    // we should have failed the query remove IRP).
    //

    if(SurpriseRemoved != deviceExtension->DeviceState) {

        //
        // we are here after QUERY_REMOVE
        //

        KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

        deviceExtension->QueueState = FailRequests;
        
        KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

        if(deviceExtension->WaitWakeEnable) {
        
            CancelWaitWake(deviceExtension);
        }

        if(WinXpOrBetter == deviceExtension->WdmVersion) {

            if(deviceExtension->SSEnable) {

                //
                // Cancel the timer so that the DPCs are no longer fired.
                // we do not need DPCs because the device has been removed
                //            
                KeCancelTimer(&deviceExtension->Timer);

                deviceExtension->SSEnable = 0;

                //
                // make sure that if a DPC was fired before we called cancel timer,
                // then the DPC and work-time have run to their completion
                //
                KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                      Executive, 
                                      KernelMode, 
                                      FALSE, 
                                      NULL);

                //
                // make sure that the selective suspend request has been completed.
                //  
                KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                      Executive, 
                                      KernelMode, 
                                      FALSE, 
                                      NULL);
            }
        }

        ProcessQueuedRequests(deviceExtension);

        ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                             FALSE);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
        }

        BulkUsb_AbortPipes(DeviceObject);
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Removed);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
    
    BulkUsb_WmiDeRegistration(deviceExtension);

    //
    // need 2 decrements
    //

    BulkUsb_DbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = BulkUsb_IoDecrement(deviceExtension);

    ASSERT(requestCount > 0);

    BulkUsb_DbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = BulkUsb_IoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->RemoveEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    ReleaseMemory(DeviceObject);
    //
    // We need to send the remove down the stack before we detach,
    // but we don't need to wait for the completion of this operation
    // (and to register a completion routine).
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    //
    // Detach the FDO from the device stack
    //
    IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
    IoDeleteDevice(DeviceObject);

    BulkUsb_DbgPrint(3, ("HandleRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_QUERY_CAPABILITIES

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value  

--*/
{
    ULONG                i;
    KEVENT               event;
    NTSTATUS             ntStatus;
    PDEVICE_EXTENSION    deviceExtension;
    PDEVICE_CAPABILITIES pdc;
    PIO_STACK_LOCATION   irpStack;

    BulkUsb_DbgPrint(3, ("HandleQueryCapabilities - begins\n"));

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    pdc = irpStack->Parameters.DeviceCapabilities.Capabilities;

    //
    // We will provide here an example of an IRP that is processed
    // both on its way down and on its way up: there might be no need for
    // a function driver process this Irp (the bus driver will do that).
    // The driver will wait for the lower drivers (the bus driver among 
    // them) to process this IRP, then it processes it again.
    //

    if(pdc->Version < 1 || pdc->Size < sizeof(DEVICE_CAPABILITIES)) {
        
        BulkUsb_DbgPrint(1, ("HandleQueryCapabilities::request failed\n"));
        ntStatus = STATUS_UNSUCCESSFUL;
        return ntStatus;
    }

    //
    // Add in the SurpriseRemovalOK bit before passing it down.
    //
    pdc->SurpriseRemovalOK = TRUE;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
        
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&event, 
                           TRUE, 
                           TRUE, 
                           TRUE);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
        ntStatus = Irp->IoStatus.Status;
    }

    //
    // initialize PowerDownLevel to disabled
    //

    deviceExtension->PowerDownLevel = PowerDeviceUnspecified;

    if(NT_SUCCESS(ntStatus)) {

        deviceExtension->DeviceCapabilities = *pdc;
       
        for(i = PowerSystemSleeping1; i <= PowerSystemSleeping3; i++) {

            if(deviceExtension->DeviceCapabilities.DeviceState[i] < 
                                                            PowerDeviceD3) {

                deviceExtension->PowerDownLevel = 
                    deviceExtension->DeviceCapabilities.DeviceState[i];
            }
        }

        //
        // since its safe to surprise-remove this device, we shall
        // set the SurpriseRemoveOK flag to supress any dialog to 
        // user.
        //

        pdc->SurpriseRemovalOK = 1;
    }

    if(deviceExtension->PowerDownLevel == PowerDeviceUnspecified ||
       deviceExtension->PowerDownLevel <= PowerDeviceD0) {
    
        deviceExtension->PowerDownLevel = PowerDeviceD2;
    }

    BulkUsb_DbgPrint(3, ("HandleQueryCapabilities - ends\n"));

    return ntStatus;
}


VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
 
Routine Description:

    DPC routine triggered by the timer to check the idle state
    of the device and submit an idle request for the device.

Arguments:

    DeferredContext - context for the dpc routine.
                      DeviceObject in our case.

Return Value:

    None

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PIO_WORKITEM      item;

    BulkUsb_DbgPrint(3, ("DpcRoutine - begins\n"));

    deviceObject = (PDEVICE_OBJECT)DeferredContext;
    deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

    //
    // Clear this event since a DPC has been fired!
    //
    KeClearEvent(&deviceExtension->NoDpcWorkItemPendingEvent);

    if(CanDeviceSuspend(deviceExtension)) {

        BulkUsb_DbgPrint(3, ("Device is Idle\n"));

        item = IoAllocateWorkItem(deviceObject);

        if(item) {

            IoQueueWorkItem(item, 
                            IdleRequestWorkerRoutine,
                            DelayedWorkQueue, 
                            item);

            ntStatus = STATUS_PENDING;

        }
        else {
        
            BulkUsb_DbgPrint(3, ("Cannot alloc memory for work item\n"));
            
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            //
            // signal the NoDpcWorkItemPendingEvent.
            //
            KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }
    else {
        
        BulkUsb_DbgPrint(3, ("Idle event not signaled\n"));

        //
        // signal the NoDpcWorkItemPendingEvent.
        //
        KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }

    BulkUsb_DbgPrint(3, ("DpcRoutine - ends\n"));
}    


VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the work item fired from the DPC.
    This workitem checks the idle state of the device
    and submits an idle request.

Arguments:

    DeviceObject - pointer to device object
    Context - context for the work item.

Return Value:

    None

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_WORKITEM           workItem;

    BulkUsb_DbgPrint(3, ("IdleRequestWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    workItem = (PIO_WORKITEM) Context;

    if(CanDeviceSuspend(deviceExtension)) {

        BulkUsb_DbgPrint(3, ("Device is idle\n"));

        ntStatus = SubmitIdleRequestIrp(deviceExtension);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(1, ("SubmitIdleRequestIrp failed\n"));
        }
    }
    else {

        BulkUsb_DbgPrint(3, ("Device is not idle\n"));
    }

    IoFreeWorkItem(workItem);

    //
    // signal the NoDpcWorkItemPendingEvent.
    //
    KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
               IO_NO_INCREMENT,
               FALSE);

    BulkUsb_DbgPrint(3, ("IdleRequestsWorkerRoutine - ends\n"));
}


VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    Remove and process the entries in the queue. If this routine is called
    when processing IRP_MN_CANCEL_STOP_DEVICE, IRP_MN_CANCEL_REMOVE_DEVICE
    or IRP_MN_START_DEVICE, the requests are passed to the next lower driver.
    If the routine is called when IRP_MN_REMOVE_DEVICE is received, the IRPs
    are complete with STATUS_DELETE_PENDING

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    None

--*/
{
    KIRQL       oldIrql;
    PIRP        nextIrp,
                cancelledIrp;
    PVOID       cancelRoutine;
    LIST_ENTRY  cancelledIrpList;
    PLIST_ENTRY listEntry;

    BulkUsb_DbgPrint(3, ("ProcessQueuedRequests - begins\n"));

    //
    // initialize variables
    //

    cancelRoutine = NULL;
    InitializeListHead(&cancelledIrpList);

    //
    // 1.  dequeue the entries in the queue
    // 2.  reset the cancel routine
    // 3.  process them
    // 3a. if the device is active, send them down
    // 3b. else complete with STATUS_DELETE_PENDING
    //

    while(1) {

        KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

        if(IsListEmpty(&DeviceExtension->NewRequestsQueue)) {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
            break;
        }
    
        //
        // Remove a request from the queue
        //

        listEntry = RemoveHeadList(&DeviceExtension->NewRequestsQueue);
        nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        //
        // set the cancel routine to NULL
        //

        cancelRoutine = IoSetCancelRoutine(nextIrp, NULL);

        //
        // check if its already cancelled
        //

        if(nextIrp->Cancel) {
            if(cancelRoutine) {

                //
                // the cancel routine for this IRP hasnt been called yet
                // so queue the IRP in the cancelledIrp list and complete
                // after releasing the lock
                //
                
                InsertTailList(&cancelledIrpList, listEntry);
            }
            else {

                //
                // the cancel routine has run
                // it must be waiting to hold the queue lock
                // so initialize the IRPs listEntry
                //

                InitializeListHead(listEntry);
            }

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
        }
        else {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

            if(FailRequests == DeviceExtension->QueueState) {

                nextIrp->IoStatus.Information = 0;
                nextIrp->IoStatus.Status = STATUS_DELETE_PENDING;
                IoCompleteRequest(nextIrp, IO_NO_INCREMENT);
            }
            else {

                PIO_STACK_LOCATION irpStack;

                BulkUsb_DbgPrint(3, ("ProcessQueuedRequests::"));
                BulkUsb_IoIncrement(DeviceExtension);

                IoSkipCurrentIrpStackLocation(nextIrp);
                IoCallDriver(DeviceExtension->TopOfStackDeviceObject, nextIrp);
               
                BulkUsb_DbgPrint(3, ("ProcessQueuedRequests::"));
                BulkUsb_IoDecrement(DeviceExtension);
            }
        }
    } // while loop

    //
    // walk through the cancelledIrp list and cancel them
    //

    while(!IsListEmpty(&cancelledIrpList)) {

        PLIST_ENTRY listEntry = RemoveHeadList(&cancelledIrpList);
        
        cancelledIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        cancelledIrp->IoStatus.Information = 0;

        IoCompleteRequest(cancelledIrp, IO_NO_INCREMENT);
    }

    BulkUsb_DbgPrint(3, ("ProcessQueuedRequests - ends\n"));

    return;
}

NTSTATUS
BulkUsb_GetRegistryDword(
    IN     PWCHAR RegPath,
    IN     PWCHAR ValueName,
    IN OUT PULONG Value
    )
/*++
 
Routine Description:

    This routine reads the specified reqistry value.

Arguments:

    RegPath - registry path
    ValueName - property to be fetched from the registry
    Value - corresponding value read from the registry.

Return Value:

    NT status value

--*/
{
    ULONG                    defaultData;
    WCHAR                    buffer[MAXIMUM_FILENAME_LENGTH];
    NTSTATUS                 ntStatus;
    UNICODE_STRING           regPath;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];

    BulkUsb_DbgPrint(3, ("BulkUsb_GetRegistryDword - begins\n"));

    regPath.Length = 0;
    regPath.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR);
    regPath.Buffer = buffer;

    RtlZeroMemory(regPath.Buffer, regPath.MaximumLength);
    RtlMoveMemory(regPath.Buffer,
                  RegPath,
                  wcslen(RegPath) * sizeof(WCHAR));

    RtlZeroMemory(paramTable, sizeof(paramTable));

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = ValueName;
    paramTable[0].EntryContext = Value;
    paramTable[0].DefaultType = REG_DWORD;
    paramTable[0].DefaultData = &defaultData;
    paramTable[0].DefaultLength = sizeof(ULONG);

    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE |
                                      RTL_REGISTRY_OPTIONAL,
                                      regPath.Buffer,
                                      paramTable,
                                      NULL,
                                      NULL);

    if(NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(3, ("success Value = %X\n", *Value));
        return STATUS_SUCCESS;
    }
    else {

        *Value = 0;
        return STATUS_UNSUCCESSFUL;
    }
}


NTSTATUS
BulkUsb_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for IRP_MJ_CLEANUP

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager

Return Value:

    NT status value

--*/
{
    PDEVICE_EXTENSION  deviceExtension;
    KIRQL              oldIrql;
    LIST_ENTRY         cleanupList;
    PLIST_ENTRY        thisEntry, 
                       nextEntry, 
                       listHead;
    PIRP               pendingIrp;
    PIO_STACK_LOCATION pendingIrpStack, 
                       irpStack;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    InitializeListHead(&cleanupList);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchClean::"));
    BulkUsb_IoIncrement(deviceExtension);

    //
    // acquire queue lock
    //
    KeAcquireSpinLock(&deviceExtension->QueueLock, &oldIrql);

    //
    // remove all Irp's that belong to input Irp's fileobject
    //

    listHead = &deviceExtension->NewRequestsQueue;

    for(thisEntry = listHead->Flink, nextEntry = thisEntry->Flink;
       thisEntry != listHead;
       thisEntry = nextEntry, nextEntry = thisEntry->Flink) {

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrpStack = IoGetCurrentIrpStackLocation(pendingIrp);

        if(irpStack->FileObject == pendingIrpStack->FileObject) {

            RemoveEntryList(thisEntry);

            //
            // set the cancel routine to NULL
            //
            if(NULL == IoSetCancelRoutine(pendingIrp, NULL)) {

                InitializeListHead(thisEntry);
            }
            else {

                InsertTailList(&cleanupList, thisEntry);
            }
        }
    }

    //
    // Release the spin lock
    //

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // walk thru the cleanup list and cancel all the Irps
    //

    while(!IsListEmpty(&cleanupList)) {

        //
        // complete the Irp
        //
        thisEntry = RemoveHeadList(&cleanupList);

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrp->IoStatus.Information = 0;
        pendingIrp->IoStatus.Status = STATUS_CANCELLED;

        IoCompleteRequest(pendingIrp, IO_NO_INCREMENT);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchClean::"));
    BulkUsb_IoDecrement(deviceExtension);

    return STATUS_SUCCESS;
}


BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the routine where we check if the device
    can selectively suspend. 

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    TRUE - if the device can suspend
    FALSE - otherwise.

--*/
{
    BulkUsb_DbgPrint(3, ("CanDeviceSuspend\n"));

    if((DeviceExtension->OpenHandleCount == 0) &&
        (DeviceExtension->OutStandingIO == 1)) {
        
        return TRUE;
    }
    else {

        return FALSE;
    }
}

NTSTATUS
BulkUsb_AbortPipes(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description

    sends an abort pipe request for open pipes.

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    PURB                        urb;
    ULONG                       i;
    NTSTATUS                    ntStatus;
    PDEVICE_EXTENSION           deviceExtension;
    PBULKUSB_PIPE_CONTEXT       pipeContext;
    PUSBD_PIPE_INFORMATION      pipeInformation;
    PUSBD_INTERFACE_INFORMATION interfaceInfo;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    pipeContext = deviceExtension->PipeContext;
    interfaceInfo = deviceExtension->UsbInterface;
    
    BulkUsb_DbgPrint(3, ("BulkUsb_AbortPipes - begins\n"));
    
    if(interfaceInfo == NULL || pipeContext == NULL) {

        return STATUS_SUCCESS;
    }

    for(i=0; i<interfaceInfo->NumberOfPipes; i++) {

        if(pipeContext[i].PipeOpen) {

            BulkUsb_DbgPrint(3, ("Aborting open pipe %d\n", i));
    
            urb = ExAllocatePool(NonPagedPool,
                                 sizeof(struct _URB_PIPE_REQUEST));

            if(urb) {

                urb->UrbHeader.Length = sizeof(struct _URB_PIPE_REQUEST);
                urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
                urb->UrbPipeRequest.PipeHandle = 
                                        interfaceInfo->Pipes[i].PipeHandle;

                ntStatus = CallUSBD(DeviceObject, urb);

                ExFreePool(urb);
            }
            else {

                BulkUsb_DbgPrint(1, ("Failed to alloc memory for urb\n"));

                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                return ntStatus;
            }

            if(NT_SUCCESS(ntStatus)) {

                pipeContext[i].PipeOpen = FALSE;
            }
        }
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_AbortPipes - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This routine is a completion routine.
    In this routine we set an event.

    Since the completion routine returns 
    STATUS_MORE_PROCESSING_REQUIRED, the Irps,
    which set this routine as the completion routine,
    should be marked pending.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    Context - 

Return Value:

    NT status value

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


LONG
BulkUsb_IoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine bumps up the I/O count.
    This routine is typically invoked when any of the
    dispatch routines handle new irps for the driver.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    new value

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedIncrement(&DeviceExtension->OutStandingIO);

    //
    // when OutStandingIO bumps from 1 to 2, clear the StopEvent
    //

    if(result == 2) {

        KeClearEvent(&DeviceExtension->StopEvent);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    BulkUsb_DbgPrint(3, ("BulkUsb_IoIncrement::%d\n", result));

    return result;
}

LONG
BulkUsb_IoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine decrements the outstanding I/O count
    This is typically invoked after the dispatch routine
    has finished processing the irp.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    new value

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedDecrement(&DeviceExtension->OutStandingIO);

    if(result == 1) {

        KeSetEvent(&DeviceExtension->StopEvent, IO_NO_INCREMENT, FALSE);
    }

    if(result == 0) {

        ASSERT(Removed == DeviceExtension->DeviceState);

        KeSetEvent(&DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    BulkUsb_DbgPrint(3, ("BulkUsb_IoDecrement::%d\n", result));

    return result;
}

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine determines whether the device can be safely stopped. In our 
    particular case, we'll assume we can always stop the device.
    A device might fail the request if it doesn't have a queue for the
    requests it might come or if it was notified that it is in the paging
    path. 
  
Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the current IRP.

Return Value:

    STATUS_SUCCESS if the device can be safely stopped, an appropriate 
    NT Status if not.

--*/
{
   //
   // We assume we can stop the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine determines whether the device can be safely removed. In our 
    particular case, we'll assume we can always remove the device.
    A device shouldn't be removed if, for example, it has open handles or
    removing the device could result in losing data (plus the reasons 
    mentioned at CanStopDevice). The PnP manager on Windows 2000 fails 
    on its own any attempt to remove, if there any open handles to the device. 
    However on Win9x, the driver must keep count of open handles and fail 
    query_remove if there are any open handles.

Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the current IRP.
    
Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate 
    NT Status if not.

--*/
{
   //
   // We assume we can remove the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
ReleaseMemory(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine returns all the memory allocations acquired during
    device startup. 
    
Arguments:

    DeviceObject - pointer to the device object.
        
    
Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate 
    NT Status if not.

--*/
{
    //
    // Disconnect from the interrupt and unmap any I/O ports
    //
    
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if(deviceExtension->UsbConfigurationDescriptor) {

        ExFreePool(deviceExtension->UsbConfigurationDescriptor);
        deviceExtension->UsbConfigurationDescriptor = NULL;
    }

    if(deviceExtension->UsbInterface) {
        
        ExFreePool(deviceExtension->UsbInterface);
        deviceExtension->UsbInterface = NULL;
    }

    if(deviceExtension->PipeContext) {

        ExFreePool(deviceExtension->PipeContext);
        deviceExtension->PipeContext = NULL;
    }

    return STATUS_SUCCESS;
}

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE\n";

        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE\n";

        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE\n";

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE\n";

        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE\n";

        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE\n";

        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE\n";

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS\n";

        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE\n";

        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES\n";

        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES\n";

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT\n";

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG\n";

        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG\n";

        case IRP_MN_EJECT:
            return "IRP_MN_EJECT\n";

        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK\n";

        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID\n";

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE\n";

        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION\n";

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION\n";

        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkpnp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkpnp.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _BULKUSB_PNP_H
#define _BULKUSB_PNP_H

#define REMOTE_WAKEUP_MASK 0x20

NTSTATUS
BulkUsb_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ConfigureDevice(
	IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SelectInterfaces(
	IN PDEVICE_OBJECT                DeviceObject,
	IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    );

VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
BulkUsb_GetRegistryDword(
    IN     PWCHAR RegPath,
    IN     PWCHAR ValueName,
    IN OUT PULONG Value
    );

NTSTATUS
BulkUsb_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
BulkUsb_AbortPipes(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReleaseMemory(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG
BulkUsb_IoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

LONG
BulkUsb_IoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

PCHAR
PnPMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkpwr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkpwr.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _BULKUSB_POWER_H
#define _BULKUSB_POWER_H

typedef struct _POWER_COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           SIrp;
} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;

typedef struct _WORKER_THREAD_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           Irp;
    PIO_WORKITEM   WorkItem;
} WORKER_THREAD_CONTEXT, *PWORKER_THREAD_CONTEXT;

NTSTATUS
BulkUsb_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    );

NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject, 
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP                  Irp
    );

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkrwr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkrwr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/
#ifndef _BULKUSB_RWR_H
#define _BULKUSB_RWR_H

typedef struct _BULKUSB_RW_CONTEXT {

    PURB              Urb;
    PMDL              Mdl;
    ULONG             Length;         // remaining to xfer
    ULONG             Numxfer;        // cumulate xfer
    ULONG_PTR         VirtualAddress; // va for next segment of xfer.
    PDEVICE_EXTENSION DeviceExtension;

} BULKUSB_RW_CONTEXT, * PBULKUSB_RW_CONTEXT;

PBULKUSB_PIPE_CONTEXT
BulkUsb_PipeWithName(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PUNICODE_STRING FileName
    );

NTSTATUS
BulkUsb_DispatchReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
BulkUsb_ReadWriteCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkrwr.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkrwr.c

Abstract:

    This file has routines to perform reads and writes.
    The read and writes are for bulk transfers.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "bulkusb.h"
#include "bulkpnp.h"
#include "bulkpwr.h"
#include "bulkdev.h"
#include "bulkrwr.h"
#include "bulkwmi.h"
#include "bulkusr.h"

PBULKUSB_PIPE_CONTEXT
BulkUsb_PipeWithName(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PUNICODE_STRING FileName
    )
/*++
 
Routine Description:

    This routine will pass the string pipe name and
    fetch the pipe number.

Arguments:

    DeviceObject - pointer to DeviceObject
    FileName - string pipe name

Return Value:

    The device extension maintains a pipe context for 
    the pipes on 82930 board.
    This routine returns the pointer to this context in
    the device extension for the "FileName" pipe.

--*/
{
    LONG                  ix;
    ULONG                 uval; 
    ULONG                 nameLength;
    ULONG                 umultiplier;
    PDEVICE_EXTENSION     deviceExtension;
    PBULKUSB_PIPE_CONTEXT pipeContext;

    //
    // initialize variables
    //
    pipeContext = NULL;
    //
    // typedef WCHAR *PWSTR;
    //
    nameLength = (FileName->Length / sizeof(WCHAR));
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("BulkUsb_PipeWithName - begins\n"));

    if(nameLength != 0) {
    
        BulkUsb_DbgPrint(3, ("Filename = %ws nameLength = %d\n", FileName->Buffer, nameLength));

        //
        // Parse the pipe#
        //
        ix = nameLength - 1;

        // if last char isn't digit, decrement it.
        while((ix > -1) &&
              ((FileName->Buffer[ix] < (WCHAR) '0')  ||
               (FileName->Buffer[ix] > (WCHAR) '9')))             {

            ix--;
        }

        if(ix > -1) {

            uval = 0;
            umultiplier = 1;

            // traversing least to most significant digits.

            while((ix > -1) &&
                  (FileName->Buffer[ix] >= (WCHAR) '0') &&
                  (FileName->Buffer[ix] <= (WCHAR) '9'))          {
        
                uval += (umultiplier *
                         (ULONG) (FileName->Buffer[ix] - (WCHAR) '0'));

                ix--;
                umultiplier *= 10;
            }
        }

        if(uval < 6 && deviceExtension->PipeContext) {
        
            pipeContext = &deviceExtension->PipeContext[uval];
        }
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_PipeWithName - ends\n"));

    return pipeContext;
}

NTSTATUS
BulkUsb_DispatchReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for read and write.
    This routine creates a BULKUSB_RW_CONTEXT for a read/write.
    This read/write is performed in stages of BULKUSB_MAX_TRANSFER_SIZE.
    once a stage of transfer is complete, then the irp is circulated again, 
    until the requested length of tranfer is performed.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    PMDL                   mdl;
    PURB                   urb;
    ULONG                  totalLength;
    ULONG                  stageLength;
    ULONG                  urbFlags;
    BOOLEAN                read;
    NTSTATUS               ntStatus;
    ULONG_PTR              virtualAddress;
    PFILE_OBJECT           fileObject;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_STACK_LOCATION     irpStack;
    PIO_STACK_LOCATION     nextStack;
    PBULKUSB_RW_CONTEXT    rwContext;
    PUSBD_PIPE_INFORMATION pipeInformation;

    //
    // initialize variables
    //
    urb = NULL;
    mdl = NULL;
    rwContext = NULL;
    totalLength = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    read = (irpStack->MajorFunction == IRP_MJ_READ) ? TRUE : FALSE;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchReadWrite - begins\n"));

    if(deviceExtension->DeviceState != Working) {

        BulkUsb_DbgPrint(1, ("Invalid device state\n"));

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto BulkUsb_DispatchReadWrite_Exit;
    }

    //
    // It is true that the client driver cancelled the selective suspend
    // request in the dispatch routine for create Irps.
    // But there is no guarantee that it has indeed completed.
    // so wait on the NoIdleReqPendEvent and proceed only if this event
    // is signalled.
    //
    BulkUsb_DbgPrint(3, ("Waiting on the IdleReqPendEvent\n"));
    
    //
    // make sure that the selective suspend request has been completed.
    //

    if(deviceExtension->SSEnable) {

        KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
    }

    if(fileObject && fileObject->FsContext) {

        pipeInformation = fileObject->FsContext;

        if(UsbdPipeTypeBulk != pipeInformation->PipeType) {
            
            BulkUsb_DbgPrint(1, ("Usbd pipe type is not bulk\n"));

            ntStatus = STATUS_INVALID_HANDLE;
            goto BulkUsb_DispatchReadWrite_Exit;
        }
    }
    else {

        BulkUsb_DbgPrint(1, ("Invalid handle\n"));

        ntStatus = STATUS_INVALID_HANDLE;
        goto BulkUsb_DispatchReadWrite_Exit;
    }

    rwContext = (PBULKUSB_RW_CONTEXT)
                ExAllocatePool(NonPagedPool,
                               sizeof(BULKUSB_RW_CONTEXT));

    if(rwContext == NULL) {
        
        BulkUsb_DbgPrint(1, ("Failed to alloc mem for rwContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto BulkUsb_DispatchReadWrite_Exit;
    }

    if(Irp->MdlAddress) {

        totalLength = MmGetMdlByteCount(Irp->MdlAddress);
    }

    if(totalLength > BULKUSB_TEST_BOARD_TRANSFER_BUFFER_SIZE) {

        BulkUsb_DbgPrint(1, ("Transfer length > circular buffer\n"));

        ntStatus = STATUS_INVALID_PARAMETER;

        ExFreePool(rwContext);

        goto BulkUsb_DispatchReadWrite_Exit;
    }

    if(totalLength == 0) {

        BulkUsb_DbgPrint(1, ("Transfer data length = 0\n"));

        ntStatus = STATUS_SUCCESS;

        ExFreePool(rwContext);

        goto BulkUsb_DispatchReadWrite_Exit;
    }

    urbFlags = USBD_SHORT_TRANSFER_OK;
    virtualAddress = (ULONG_PTR) MmGetMdlVirtualAddress(Irp->MdlAddress);

    if(read) {

        urbFlags |= USBD_TRANSFER_DIRECTION_IN;
        BulkUsb_DbgPrint(3, ("Read operation\n"));
    }
    else {

        urbFlags |= USBD_TRANSFER_DIRECTION_OUT;
        BulkUsb_DbgPrint(3, ("Write operation\n"));
    }

    //
    // the transfer request is for totalLength.
    // we can perform a max of BULKUSB_MAX_TRANSFER_SIZE
    // in each stage.
    //
    if(totalLength > BULKUSB_MAX_TRANSFER_SIZE) {

        stageLength = BULKUSB_MAX_TRANSFER_SIZE;
    }
    else {

        stageLength = totalLength;
    }

    mdl = IoAllocateMdl((PVOID) virtualAddress,
                        totalLength,
                        FALSE,
                        FALSE,
                        NULL);

    if(mdl == NULL) {
    
        BulkUsb_DbgPrint(1, ("Failed to alloc mem for mdl\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;

        ExFreePool(rwContext);

        goto BulkUsb_DispatchReadWrite_Exit;
    }

    //
    // map the portion of user-buffer described by an mdl to another mdl
    //
    IoBuildPartialMdl(Irp->MdlAddress,
                      mdl,
                      (PVOID) virtualAddress,
                      stageLength);

    urb = ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));

    if(urb == NULL) {

        BulkUsb_DbgPrint(1, ("Failed to alloc mem for urb\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;

        ExFreePool(rwContext);
        IoFreeMdl(mdl);

        goto BulkUsb_DispatchReadWrite_Exit;
    }

    UsbBuildInterruptOrBulkTransferRequest(
                            urb,
                            sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
                            pipeInformation->PipeHandle,
                            NULL,
                            mdl,
                            stageLength,
                            urbFlags,
                            NULL);

    //
    // set BULKUSB_RW_CONTEXT parameters.
    //
    
    rwContext->Urb             = urb;
    rwContext->Mdl             = mdl;
    rwContext->Length          = totalLength - stageLength;
    rwContext->Numxfer         = 0;
    rwContext->VirtualAddress  = virtualAddress + stageLength;
    rwContext->DeviceExtension = deviceExtension;

    //
    // use the original read/write irp as an internal device control irp
    //

    nextStack = IoGetNextIrpStackLocation(Irp);
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.Others.Argument1 = (PVOID) urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                             IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)BulkUsb_ReadWriteCompletion,
                           rwContext,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // since we return STATUS_PENDING call IoMarkIrpPending.
    // This is the boiler plate code.
    // This may cause extra overhead of an APC for the Irp completion
    // but this is the correct thing to do.
    //

    IoMarkIrpPending(Irp);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchReadWrite::"));
    BulkUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            Irp);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("IoCallDriver fails with status %X\n", ntStatus));

        //
        // if the device was yanked out, then the pipeInformation 
        // field is invalid.
        // similarly if the request was cancelled, then we need not
        // invoked reset pipe/device.
        //
        if((ntStatus != STATUS_CANCELLED) && 
           (ntStatus != STATUS_DEVICE_NOT_CONNECTED)) {
            
            ntStatus = BulkUsb_ResetPipe(DeviceObject,
                                     pipeInformation);
    
            if(!NT_SUCCESS(ntStatus)) {

                BulkUsb_DbgPrint(1, ("BulkUsb_ResetPipe failed\n"));

                ntStatus = BulkUsb_ResetDevice(DeviceObject);
            }
        }
        else {

            BulkUsb_DbgPrint(3, ("ntStatus is STATUS_CANCELLED or "
                                 "STATUS_DEVICE_NOT_CONNECTED\n"));
        }
    }

    //
    // we return STATUS_PENDING and not the status returned by the lower layer.
    //
    return STATUS_PENDING;

BulkUsb_DispatchReadWrite_Exit:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchReadWrite - ends\n"));

    return ntStatus;
}

NTSTATUS
BulkUsb_ReadWriteCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the completion routine for reads/writes
    If the irp completes with success, we check if we
    need to recirculate this irp for another stage of
    transfer. In this case return STATUS_MORE_PROCESSING_REQUIRED.
    if the irp completes in error, free all memory allocs and
    return the status.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    Context - context passed to the completion routine.

Return Value:

    NT status value

--*/
{
    ULONG               stageLength;
    NTSTATUS            ntStatus;
    PIO_STACK_LOCATION  nextStack;
    PBULKUSB_RW_CONTEXT rwContext;

    //
    // initialize variables
    //
    rwContext = (PBULKUSB_RW_CONTEXT) Context;
    ntStatus = Irp->IoStatus.Status;

    UNREFERENCED_PARAMETER(DeviceObject);
    BulkUsb_DbgPrint(3, ("BulkUsb_ReadWriteCompletion - begins\n"));

    //
    // successfully performed a stageLength of transfer.
    // check if we need to recirculate the irp.
    //
    if(NT_SUCCESS(ntStatus)) {

        if(rwContext) {

            rwContext->Numxfer += 
              rwContext->Urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
        
            if(rwContext->Length) {

                //
                // another stage transfer
                //
                BulkUsb_DbgPrint(3, ("Another stage transfer...\n"));

                if(rwContext->Length > BULKUSB_MAX_TRANSFER_SIZE) {
            
                    stageLength = BULKUSB_MAX_TRANSFER_SIZE;
                }
                else {
                
                    stageLength = rwContext->Length;
                }

                IoBuildPartialMdl(Irp->MdlAddress,
                                  rwContext->Mdl,
                                  (PVOID) rwContext->VirtualAddress,
                                  stageLength);
            
                //
                // reinitialize the urb
                //
                rwContext->Urb->UrbBulkOrInterruptTransfer.TransferBufferLength 
                                                                  = stageLength;
                rwContext->VirtualAddress += stageLength;
                rwContext->Length -= stageLength;

                nextStack = IoGetNextIrpStackLocation(Irp);
                nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                nextStack->Parameters.Others.Argument1 = rwContext->Urb;
                nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                            IOCTL_INTERNAL_USB_SUBMIT_URB;

                IoSetCompletionRoutine(Irp,
                                       BulkUsb_ReadWriteCompletion,
                                       rwContext,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                IoCallDriver(rwContext->DeviceExtension->TopOfStackDeviceObject, 
                             Irp);

                return STATUS_MORE_PROCESSING_REQUIRED;
            }
            else {

                //
                // this is the last transfer
                //

                Irp->IoStatus.Information = rwContext->Numxfer;
            }
        }
    }
    else {

        BulkUsb_DbgPrint(1, ("ReadWriteCompletion - failed with status = %X\n", ntStatus));
    }
    
    if(rwContext) {

        //
        // dump rwContext
        //
        BulkUsb_DbgPrint(3, ("rwContext->Urb             = %X\n", 
                             rwContext->Urb));
        BulkUsb_DbgPrint(3, ("rwContext->Mdl             = %X\n", 
                             rwContext->Mdl));
        BulkUsb_DbgPrint(3, ("rwContext->Length          = %d\n", 
                             rwContext->Length));
        BulkUsb_DbgPrint(3, ("rwContext->Numxfer         = %d\n", 
                             rwContext->Numxfer));
        BulkUsb_DbgPrint(3, ("rwContext->VirtualAddress  = %X\n", 
                             rwContext->VirtualAddress));
        BulkUsb_DbgPrint(3, ("rwContext->DeviceExtension = %X\n", 
                             rwContext->DeviceExtension));

        BulkUsb_DbgPrint(3, ("BulkUsb_ReadWriteCompletion::"));
        BulkUsb_IoDecrement(rwContext->DeviceExtension);

        ExFreePool(rwContext->Urb);
        IoFreeMdl(rwContext->Mdl);
        ExFreePool(rwContext);
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_ReadWriteCompletion - ends\n"));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkusr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSUsr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _BULKUSB_USER_H
#define _BULKUSB_USER_H

#include <initguid.h>

// {6068EB61-98E7-4c98-9E20-1F068295909A}
DEFINE_GUID(GUID_CLASS_I82930_BULK, 
0x873fdf, 0x61a8, 0x11d1, 0xaa, 0x5e, 0x0, 0xc0, 0x4f, 0xb1, 0x72, 0x8b);

#define BULKUSB_IOCTL_INDEX             0x0000


#define IOCTL_BULKUSB_GET_CONFIG_DESCRIPTOR CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     BULKUSB_IOCTL_INDEX,     \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)
                                                   
#define IOCTL_BULKUSB_RESET_DEVICE          CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     BULKUSB_IOCTL_INDEX + 1, \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)

#define IOCTL_BULKUSB_RESET_PIPE            CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     BULKUSB_IOCTL_INDEX + 2, \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkusb.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkusb.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include <initguid.h>
#include <wdm.h>
#include <wmilib.h>
#include <wmistr.h>
#include "usbdi.h"
#include "usbdlib.h"

#ifndef _BULKUSB_H
#define _BULKUSB_H

#define BULKTAG (ULONG) 'KluB'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
    ExAllocatePoolWithTag(type, size, BULKTAG);

#if DBG

#define BulkUsb_DbgPrint(level, _x_) \
            if((level) <= DebugLevel) { \
                DbgPrint _x_; \
            }

#else

#define BulkUsb_DbgPrint(level, _x_)

#endif

typedef struct _GLOBALS {

    UNICODE_STRING BulkUsb_RegistryPath;

} GLOBALS;

#define IDLE_INTERVAL 5000

typedef enum _DEVSTATE {

    NotStarted,         // not started
    Stopped,            // device stopped
    Working,            // started and working
    PendingStop,        // stop pending
    PendingRemove,      // remove pending
    SurpriseRemoved,    // removed by surprise
    Removed             // removed

} DEVSTATE;

typedef enum _QUEUE_STATE {

    HoldRequests,       // device is not started yet
    AllowRequests,      // device is ready to process
    FailRequests        // fail both existing and queued up requests

} QUEUE_STATE;

typedef enum _WDM_VERSION {

    WinXpOrBetter,
    Win2kOrBetter,
    WinMeOrBetter,
    Win98OrBetter

} WDM_VERSION;

#define INITIALIZE_PNP_STATE(_Data_)    \
        (_Data_)->DeviceState =  NotStarted;\
        (_Data_)->PrevDevState = NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_) \
        (_Data_)->PrevDevState =  (_Data_)->DeviceState;\
        (_Data_)->DeviceState = (_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)   \
        (_Data_)->DeviceState =   (_Data_)->PrevDevState;


#define BULKUSB_MAX_TRANSFER_SIZE   256
#define BULKUSB_TEST_BOARD_TRANSFER_BUFFER_SIZE (64 *1024 )

//
// registry path used for parameters 
// global to all instances of the driver
//

#define BULKUSB_REGISTRY_PARAMETERS_PATH  \
	L"\\REGISTRY\\Machine\\System\\CurrentControlSet\\SERVICES\\BULKUSB\\Parameters"


typedef struct _BULKUSB_PIPE_CONTEXT {

    BOOLEAN PipeOpen;

} BULKUSB_PIPE_CONTEXT, *PBULKUSB_PIPE_CONTEXT;

//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _DEVICE_EXTENSION {

    // Functional Device Object
    PDEVICE_OBJECT FunctionalDeviceObject;

    // Device object we call when submitting Urbs
    PDEVICE_OBJECT TopOfStackDeviceObject;

    // The bus driver object
    PDEVICE_OBJECT PhysicalDeviceObject;

    // Name buffer for our named Functional device object link
    // The name is generated based on the driver's class GUID
    UNICODE_STRING InterfaceName;

    // Bus drivers set the appropriate values in this structure in response
    // to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
    // alter the capabilities set by the bus driver.
    DEVICE_CAPABILITIES DeviceCapabilities;

    // Configuration Descriptor
    PUSB_CONFIGURATION_DESCRIPTOR UsbConfigurationDescriptor;

    // Interface Information structure
    PUSBD_INTERFACE_INFORMATION UsbInterface;

    // Pipe context for the bulkusb driver
    PBULKUSB_PIPE_CONTEXT PipeContext;

    // current state of device
    DEVSTATE DeviceState;

    // state prior to removal query
    DEVSTATE PrevDevState;

    // obtain and hold this lock while changing the device state,
    // the queue state and while processing the queue.
    KSPIN_LOCK DevStateLock;

    // current system power state
    SYSTEM_POWER_STATE SysPower;

    // current device power state
    DEVICE_POWER_STATE DevPower;

    // Pending I/O queue state
    QUEUE_STATE QueueState;

    // Pending I/O queue
    LIST_ENTRY NewRequestsQueue;

    // I/O Queue Lock
    KSPIN_LOCK QueueLock;

    KEVENT RemoveEvent;

    KEVENT StopEvent;
    
    ULONG OutStandingIO;

    KSPIN_LOCK IOCountLock;

    // selective suspend variables

    LONG SSEnable;

    LONG SSRegistryEnable;

    PUSB_IDLE_CALLBACK_INFO IdleCallbackInfo;
	
    PIRP PendingIdleIrp;
	
    LONG IdleReqPend;

    LONG FreeIdleIrpCount;

    KSPIN_LOCK IdleReqStateLock;

    KEVENT NoIdleReqPendEvent;

    // default power state to power down to on self-susped
    ULONG PowerDownLevel;
    
    // remote wakeup variables
    PIRP WaitWakeIrp;

    LONG FlagWWCancel;

    LONG FlagWWOutstanding;

    LONG WaitWakeEnable;

    // open handle count
    LONG OpenHandleCount;

    // selective suspend model uses timers, dpcs and work item.
    KTIMER Timer;

    KDPC DeferredProcCall;

    // This event is cleared when a DPC/Work Item is queued.
    // and signaled when the work-item completes.
    // This is essential to prevent the driver from unloading
    // while we have DPC or work-item queued up.
    KEVENT NoDpcWorkItemPendingEvent;

    // WMI information
    WMILIB_CONTEXT WmiLibInfo;

    // WDM version
    WDM_VERSION WdmVersion;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct _IRP_COMPLETION_CONTEXT {

    PDEVICE_EXTENSION DeviceExtension;

    PKEVENT Event;

} IRP_COMPLETION_CONTEXT, *PIRP_COMPLETION_CONTEXT;

extern GLOBALS Globals;
extern ULONG DebugLevel;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkpwr.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    bulkpwr.c

Abstract:

    The power management related processing.

    The Power Manager uses IRPs to direct drivers to change system
    and device power levels, to respond to system wake-up events,
    and to query drivers about their devices. All power IRPs have
    the major function code IRP_MJ_POWER.

    Most function and filter drivers perform some processing for
    each power IRP, then pass the IRP down to the next lower driver
    without completing it. Eventually the IRP reaches the bus driver,
    which physically changes the power state of the device and completes
    the IRP.

    When the IRP has been completed, the I/O Manager calls any
    IoCompletion routines set by drivers as the IRP traveled
    down the device stack. Whether a driver needs to set a completion
    routine depends upon the type of IRP and the driver's individual
    requirements.

    This code is not USB specific. It is essential for every WDM driver
    to handle power irps.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "bulkusb.h"
#include "bulkpwr.h"
#include "bulkpnp.h"
#include "bulkdev.h"
#include "bulkrwr.h"
#include "bulkwmi.h"
#include "bulkusr.h"

NTSTATUS
BulkUsb_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    The power dispatch routine.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code

--*/
{
    NTSTATUS           ntStatus;
    PIO_STACK_LOCATION irpStack;
    PUNICODE_STRING    tagString;
    PDEVICE_EXTENSION  deviceExtension;
	
    //
    // initialize the variables
    //
	
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // We don't queue power Irps, we'll only check if the
    // device was removed, otherwise we'll take appropriate
    // action and send it to the next lower driver. In general
    // drivers should not cause long delays while handling power
    // IRPs. If a driver cannot handle a power IRP in a brief time,
    // it should return STATUS_PENDING and queue all incoming
    // IRPs until the IRP completes.
    //

    if(Removed == deviceExtension->DeviceState) {

        //
        // Even if a driver fails the IRP, it must nevertheless call
        // PoStartNextPowerIrp to inform the Power Manager that it
        // is ready to handle another power IRP.
        //

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    if(NotStarted == deviceExtension->DeviceState) {

        //
        // if the device is not started yet, pass it down
        //

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        return PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPower::"));
    BulkUsb_IoIncrement(deviceExtension);
    
    switch(irpStack->MinorFunction) {
    
    case IRP_MN_SET_POWER:

        //
        // The Power Manager sends this IRP for one of the
        // following reasons:
        // 1) To notify drivers of a change to the system power state.
        // 2) To change the power state of a device for which
        //    the Power Manager is performing idle detection.
        // A driver sends IRP_MN_SET_POWER to change the power
        // state of its device if it's a power policy owner for the
        // device.
        //

        IoMarkIrpPending(Irp);

        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:

            HandleSystemSetPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;

        case DevicePowerState:

            HandleDeviceSetPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;
        }

        break;

    case IRP_MN_QUERY_POWER:

        //
        // The Power Manager sends a power IRP with the minor
        // IRP code IRP_MN_QUERY_POWER to determine whether it
        // can safely change to the specified system power state
        // (S1-S5) and to allow drivers to prepare for such a change.
        // If a driver can put its device in the requested state,
        // it sets status to STATUS_SUCCESS and passes the IRP down.
        //

        IoMarkIrpPending(Irp);
    
        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:
            
            HandleSystemQueryPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;

        case DevicePowerState:

            HandleDeviceQueryPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;
        }

        break;

    case IRP_MN_WAIT_WAKE:

        //
        // The minor power IRP code IRP_MN_WAIT_WAKE provides
        // for waking a device or waking the system. Drivers
        // of devices that can wake themselves or the system
        // send IRP_MN_WAIT_WAKE. The system sends IRP_MN_WAIT_WAKE
        // only to devices that always wake the system, such as
        // the power-on switch.
        //

        IoMarkIrpPending(Irp);

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                        Irp,
                        (PIO_COMPLETION_ROUTINE)WaitWakeCompletionRoutine,
                        deviceExtension, 
                        TRUE, 
                        TRUE, 
                        TRUE);

        PoStartNextPowerIrp(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(1, ("Lower drivers failed the wait-wake Irp"));
        }

        ntStatus = STATUS_PENDING;

        //
        // push back the count HERE and NOT in completion routine
        // a pending Wait Wake Irp should not impede stopping the device
        //

        BulkUsb_DbgPrint(3, ("IRP_MN_WAIT_WAKE::"));
        BulkUsb_IoDecrement(deviceExtension);

        break;

    case IRP_MN_POWER_SEQUENCE:

        //
        // A driver sends this IRP as an optimization to determine
        // whether its device actually entered a specific power state.
        // This IRP is optional. Power Manager cannot send this IRP.
        //

    default:

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(1, ("Lower drivers failed this Irp"));
        }
        
        BulkUsb_DbgPrint(3, ("BulkUsb_DispatchPower::"));
        BulkUsb_IoDecrement(deviceExtension);

        break;
    }

    return ntStatus;
}

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine handles the irp with minor function of type IRP_MN_QUERY_POWER
    for the system power states.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager.

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    BulkUsb_DbgPrint(3, ("HandleSystemQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    BulkUsb_DbgPrint(3, ("Query for system power state S%X\n"
                         "Current system power state S%X\n",
                         systemState - 1,
                         deviceExtension->SysPower - 1));

    //
    // Fail a query for a power state incompatible with waking up the system
    //

    if((deviceExtension->WaitWakeEnable) &&
       (systemState > deviceExtension->DeviceCapabilities.SystemWake)) {

        BulkUsb_DbgPrint(1, ("Query for an incompatible system power state\n"));

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        BulkUsb_DbgPrint(3, ("HandleSystemQueryPower::"));
        BulkUsb_IoDecrement(deviceExtension);

        return ntStatus;
    }

    //
    // if querying for a lower S-state, issue a wait-wake
    //

    if((systemState > deviceExtension->SysPower) &&
       (deviceExtension->WaitWakeEnable)) {

        IssueWaitWake(deviceExtension);
    }

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("HandleSystemQueryPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_SET_POWER
    for the system power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value:

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    BulkUsb_DbgPrint(3, ("HandleSystemSetPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    BulkUsb_DbgPrint(3, ("Set request for system power state S%X\n"
                         "Current system power state S%X\n",
                         systemState - 1,
                         deviceExtension->SysPower - 1));

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("HandleSystemSetPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_QUERY_POWER
    for the device power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE deviceState;

    BulkUsb_DbgPrint(3, ("HandleDeviceQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceState = irpStack->Parameters.Power.State.DeviceState;

    BulkUsb_DbgPrint(3, ("Query for device power state D%X\n"
                         "Current device power state D%X\n",
                         deviceState - 1,
                         deviceExtension->DevPower - 1));

    if(deviceExtension->WaitWakeEnable &&
       deviceState > deviceExtension->DeviceCapabilities.DeviceWake) {

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        BulkUsb_DbgPrint(3, ("HandleDeviceQueryPower::"));
        BulkUsb_IoDecrement(deviceExtension);

        return ntStatus;
    }

    if(deviceState < deviceExtension->DevPower) {

        ntStatus = STATUS_SUCCESS;
    }
    else {

        ntStatus = HoldIoRequests(DeviceObject, Irp);

        if(STATUS_PENDING == ntStatus) {

            return ntStatus;
        }
    }

    //
    // on error complete the Irp.
    // on success pass it to the lower layers
    //

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    if(!NT_SUCCESS(ntStatus)) {

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    BulkUsb_DbgPrint(3, ("HandleDeviceQueryPower::"));
    BulkUsb_IoDecrement(deviceExtension);

    BulkUsb_DbgPrint(3, ("HandleDeviceQueryPower - ends\n"));

    return ntStatus;
}


NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the completion routine for the system power irps of minor
    function types IRP_MN_QUERY_POWER and IRP_MN_SET_POWER.
    This completion routine sends the corresponding device power irp and
    returns STATUS_MORE_PROCESSING_REQUIRED. The system irp is passed as a
    context to the device power irp completion routine and is completed in
    the device power irp completion routine.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
 	PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);


    BulkUsb_DbgPrint(3, ("SysPoCompletionRoutine - begins\n"));

    //
    // lower drivers failed this Irp
    //

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        BulkUsb_DbgPrint(3, ("SysPoCompletionRoutine::"));
        BulkUsb_IoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    //
    // ..otherwise update the cached system power state (IRP_MN_SET_POWER)
    //

    if(irpStack->MinorFunction == IRP_MN_SET_POWER) {

        DeviceExtension->SysPower = irpStack->Parameters.Power.State.SystemState;
    }

    //
    // queue device irp and return STATUS_MORE_PROCESSING_REQUIRED
    //
	
    SendDeviceIrp(DeviceObject, Irp);

    BulkUsb_DbgPrint(3, ("SysPoCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP SIrp
    )
/*++
 
Routine Description:

    This routine is invoked from the completion routine of the system power
    irp. This routine will PoRequest a device power irp. The system irp is 
    passed as a context to the the device power irp.

Arguments:

    DeviceObject - pointer to device object
    SIrp - system power irp.

Return Value:

    None

--*/
{
    NTSTATUS                  ntStatus;
    POWER_STATE               powState;
    PDEVICE_EXTENSION         deviceExtension;
    PIO_STACK_LOCATION        irpStack;
    SYSTEM_POWER_STATE        systemState;
    DEVICE_POWER_STATE        devState;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(SIrp);
    systemState = irpStack->Parameters.Power.State.SystemState;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("SendDeviceIrp - begins\n"));

    //
    // Read out the D-IRP out of the S->D mapping array captured in QueryCap's.
    // we can choose deeper sleep states than our mapping but never choose
    // lighter ones.
    //

    devState = deviceExtension->DeviceCapabilities.DeviceState[systemState];
    powState.DeviceState = devState;
    
    powerContext = (PPOWER_COMPLETION_CONTEXT) 
                   ExAllocatePool(NonPagedPool,
                                  sizeof(POWER_COMPLETION_CONTEXT));

    if(!powerContext) {

        BulkUsb_DbgPrint(1, ("Failed to alloc memory for powerContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        powerContext->DeviceObject = DeviceObject;
        powerContext->SIrp = SIrp;
   
        //
        // in win2k PoRequestPowerIrp can take fdo or pdo.
        //

        ntStatus = PoRequestPowerIrp(
                            deviceExtension->PhysicalDeviceObject, 
                            irpStack->MinorFunction,
                            powState,
                            (PREQUEST_POWER_COMPLETE)DevPoCompletionRoutine,
                            powerContext, 
                            NULL);
    }

    if(!NT_SUCCESS(ntStatus)) {

        if(powerContext) {

            ExFreePool(powerContext);
        }

        PoStartNextPowerIrp(SIrp);

        SIrp->IoStatus.Status = ntStatus;
        SIrp->IoStatus.Information = 0;
        
        IoCompleteRequest(SIrp, IO_NO_INCREMENT);

        BulkUsb_DbgPrint(3, ("SendDeviceIrp::"));
        BulkUsb_IoDecrement(deviceExtension);

    }

    BulkUsb_DbgPrint(3, ("SendDeviceIrp - ends\n"));
}


VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject, 
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    This is the PoRequest - completion routine for the device power irp.
    This routine is responsible for completing the system power irp, 
    received as a context.

Arguments:

    DeviceObject - pointer to device object
    MinorFunction - minor function of the irp.
    PowerState - power state of the irp.
    Context - context passed to the completion routine.
    IoStatus - status of the device power irp.

Return Value:

    None

--*/
{
    PIRP                      sIrp;
    PDEVICE_EXTENSION         deviceExtension;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    powerContext = (PPOWER_COMPLETION_CONTEXT) Context;
    sIrp = powerContext->SIrp;
    deviceExtension = powerContext->DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("DevPoCompletionRoutine - begins\n"));

    //
    // copy the D-Irp status into S-Irp
    //

    sIrp->IoStatus.Status = IoStatus->Status;

    //
    // complete the system Irp
    //
    
    PoStartNextPowerIrp(sIrp);

    sIrp->IoStatus.Information = 0;

    IoCompleteRequest(sIrp, IO_NO_INCREMENT);

    //
    // cleanup
    //
    
    BulkUsb_DbgPrint(3, ("DevPoCompletionRoutine::"));
    BulkUsb_IoDecrement(deviceExtension);

    ExFreePool(powerContext);

    BulkUsb_DbgPrint(3, ("DevPoCompletionRoutine - ends\n"));

}

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_SET_POWER
    for the device power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;    
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    BulkUsb_DbgPrint(3, ("HandleDeviceSetPower - begins\n"));
	
    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    oldDevState = deviceExtension->DevPower;
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;

    BulkUsb_DbgPrint(3, ("Set request for device power state D%X\n"
                         "Current device power state D%X\n",
                         newDevState - 1,
                         deviceExtension->DevPower - 1));

    if(newDevState < oldDevState) {

        //
        // adding power
        //
        BulkUsb_DbgPrint(3, ("Adding power to the device\n"));

        //
        // send the power IRP to the next driver in the stack
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE)FinishDevPoUpIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

	}
    else {

        //
        // newDevState >= oldDevState 
        //
        // hold I/O if transition from D0 -> DX (X = 1, 2, 3)
        // if transition from D1 or D2 to deeper sleep states, 
        // I/O queue is already on hold.
        //

        if(PowerDeviceD0 == oldDevState && newDevState > oldDevState) {

            //
            // D0 -> DX transition
            //

            BulkUsb_DbgPrint(3, ("Removing power from the device\n"));

            ntStatus = HoldIoRequests(DeviceObject, Irp);

            if(!NT_SUCCESS(ntStatus)) {

                PoStartNextPowerIrp(Irp);

                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);

                BulkUsb_DbgPrint(3, ("HandleDeviceSetPower::"));
                BulkUsb_IoDecrement(deviceExtension);

                return ntStatus;
            }
            else {

                goto HandleDeviceSetPower_Exit;
            }

        }
        else if(PowerDeviceD0 == oldDevState && PowerDeviceD0 == newDevState) {

            //
            // D0 -> D0
            // unblock the queue which may have been blocked processing
            // query irp
            //

            BulkUsb_DbgPrint(3, ("A SetD0 request\n"));

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
              
            deviceExtension->QueueState = AllowRequests;

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }   

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            BulkUsb_DbgPrint(1, ("Lower drivers failed a power Irp\n"));
        }

    }

HandleDeviceSetPower_Exit:

    BulkUsb_DbgPrint(3, ("HandleDeviceSetPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    completion routine for the device power UP irp with minor function
    IRP_MN_SET_POWER.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
                        
    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;

    BulkUsb_DbgPrint(3, ("FinishDevPoUpIrp - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        BulkUsb_DbgPrint(3, ("FinishDevPoUpIrp::"));
        BulkUsb_IoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    SetDeviceFunctional(DeviceObject, Irp, DeviceExtension);

    BulkUsb_DbgPrint(3, ("FinishDevPoUpIrp - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine processes queue of pending irps.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;
    oldDevState = DeviceExtension->DevPower;

    BulkUsb_DbgPrint(3, ("SetDeviceFunctional - begins\n"));

    //
    // update the cached state
    //
    DeviceExtension->DevPower = newDevState;

    //
    // restore appropriate amount of state to our h/w
    // this driver does not implement partial context
    // save/restore.
    //

    PoSetPowerState(DeviceObject, DevicePowerState, newState);

    if(PowerDeviceD0 == newDevState) {

    //
    // empty existing queue of all pending irps.
    //

        KeAcquireSpinLock(&DeviceExtension->DevStateLock, &oldIrql);

        DeviceExtension->QueueState = AllowRequests;
        
        KeReleaseSpinLock(&DeviceExtension->DevStateLock, oldIrql);

        ProcessQueuedRequests(DeviceExtension);
    }

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("SetDeviceFunctional::"));
    BulkUsb_IoDecrement(DeviceExtension);

    BulkUsb_DbgPrint(3, ("SetDeviceFunctional - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine is the completion routine for device power DOWN irp.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;

    BulkUsb_DbgPrint(3, ("FinishDevPoDnIrp - begins\n"));

    if(NT_SUCCESS(ntStatus) && irpStack->MinorFunction == IRP_MN_SET_POWER) {

        //
        // update the cache;
        //

        BulkUsb_DbgPrint(3, ("updating cache..\n"));

        DeviceExtension->DevPower = newState.DeviceState;

        PoSetPowerState(DeviceObject, DevicePowerState, newState);
    }

    PoStartNextPowerIrp(Irp);

    BulkUsb_DbgPrint(3, ("FinishDevPoDnIrp::"));
    BulkUsb_IoDecrement(DeviceExtension);

    BulkUsb_DbgPrint(3, ("FinishDevPoDnIrp - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine is called on query or set power DOWN irp for the device.
    This routine queues a workitem.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    NTSTATUS               ntStatus;
    PIO_WORKITEM           item;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, ("HoldIoRequests - begins\n"));

    deviceExtension->QueueState = HoldRequests;

    context = ExAllocatePool(NonPagedPool, sizeof(WORKER_THREAD_CONTEXT));

    if(context) {

        item = IoAllocateWorkItem(DeviceObject);

        context->Irp = Irp;
        context->DeviceObject = DeviceObject;
        context->WorkItem = item;

        if(item) {

            IoMarkIrpPending(Irp);
            
            IoQueueWorkItem(item, HoldIoRequestsWorkerRoutine,
                            DelayedWorkQueue, context);
            
            ntStatus = STATUS_PENDING;
        }
        else {

            BulkUsb_DbgPrint(3, ("Failed to allocate memory for workitem\n"));
            ExFreePool(context);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        BulkUsb_DbgPrint(1, ("Failed to alloc memory for worker thread context\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    BulkUsb_DbgPrint(3, ("HoldIoRequests - ends\n"));

    return ntStatus;
}

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This routine waits for the I/O in progress to finish and then
    sends the device power irp (query/set) down the stack.

Arguments:

    DeviceObject - pointer to device object
    Context - context passed to the work-item.

Return Value:

    None

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    BulkUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    context = (PWORKER_THREAD_CONTEXT) Context;
    irp = (PIRP) context->Irp;


    //
    // wait for I/O in progress to finish.
    // the stop event is signalled when the counter drops to 1.
    // invoke BulkUsb_IoDecrement twice: once each for the S-Irp and D-Irp.
    //
    BulkUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    BulkUsb_IoDecrement(deviceExtension);
    BulkUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    BulkUsb_IoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, Executive,
                          KernelMode, FALSE, NULL);

    //
    // Increment twice to restore the count
    //
    BulkUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    BulkUsb_IoIncrement(deviceExtension);
    BulkUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    BulkUsb_IoIncrement(deviceExtension);

    // 
    // now send the Irp down
    //

    IoCopyCurrentIrpStackLocationToNext(irp);

    IoSetCompletionRoutine(irp, (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                           deviceExtension, TRUE, TRUE, TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("Lower driver fail a power Irp\n"));
    }

    IoFreeWorkItem(context->WorkItem);
    ExFreePool((PVOID)context);

    BulkUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine - ends\n"));

}

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    Queue the Irp in the device queue

Arguments:

    DeviceExtension - pointer to device extension
    Irp - I/O request packet.

Return Value:

    NT status value

--*/
{
    KIRQL    oldIrql;
    NTSTATUS ntStatus;

    //
    // initialize variables
    //
    ntStatus = STATUS_PENDING;

    BulkUsb_DbgPrint(3, ("QueueRequests - begins\n"));

    ASSERT(HoldRequests == DeviceExtension->QueueState);

    KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

    InsertTailList(&DeviceExtension->NewRequestsQueue, 
                   &Irp->Tail.Overlay.ListEntry);

    IoMarkIrpPending(Irp);

    //
    // Set the cancel routine
    //

    IoSetCancelRoutine(Irp, CancelQueued);

    KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

    BulkUsb_DbgPrint(3, ("QueueRequests - ends\n"));

    return ntStatus;
}

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine removes the irp from the queue and completes it with
    STATUS_CANCELLED

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    KIRQL             oldIrql;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    oldIrql = Irp->CancelIrql;

    BulkUsb_DbgPrint(3, ("CancelQueued - begins\n"));

    //
    // Release the cancel spin lock
    //

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // Acquire the queue lock
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->QueueLock);

    //
    // Remove the cancelled Irp from queue and release the lock
    //
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // complete with STATUS_CANCELLED
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("CancelQueued - ends\n"));

    return;
}

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine will PoRequest a WAIT WAKE irp for the device

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value.

--*/
{
    POWER_STATE poState;
    NTSTATUS    ntStatus;

    BulkUsb_DbgPrint(3, ("IssueWaitWake - begins\n"));

    if(InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 1)) {

        return STATUS_DEVICE_BUSY;
    }

    InterlockedExchange(&DeviceExtension->FlagWWCancel, 0);

    //
    // lowest state from which this Irp will wake the system
    //

    poState.SystemState = DeviceExtension->DeviceCapabilities.SystemWake;

    ntStatus = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_WAIT_WAKE,
                                 poState, 
                                 (PREQUEST_POWER_COMPLETE) WaitWakeCallback,
                                 DeviceExtension, 
                                 &DeviceExtension->WaitWakeIrp);

    if(!NT_SUCCESS(ntStatus)) {

        InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 0);
    }

    BulkUsb_DbgPrint(3, ("IssueWaitWake - ends\n"));

    return ntStatus;
}

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine cancels the Wait Wake request.

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    None.

--*/
{
    PIRP Irp;

    BulkUsb_DbgPrint(3, ("CancelWaitWake - begins\n"));

    Irp = (PIRP) InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, 
                                            NULL);

    if(Irp) {

        IoCancelIrp(Irp);

        if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

            PoStartNextPowerIrp(Irp);

            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }    
    }

    BulkUsb_DbgPrint(3, ("CancelWaitWake - ends\n"));
}

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the IoSet completion routine for the wait wake irp.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    BulkUsb_DbgPrint(3, ("WaitWakeCompletionRoutine - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    //
    // Nullify the WaitWakeIrp pointer-the Irp is released 
    // as part of the completion process. If it's already NULL, 
    // avoid race with the CancelWaitWake routine.
    //

    if(InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, NULL)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_SUCCESS;
    }

    //
    // CancelWaitWake has run. 
    // If FlagWWCancel != 0, complete the Irp.
    // If FlagWWCancel == 0, CancelWaitWake completes it.
    //
    if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_CANCELLED;
    }

    BulkUsb_DbgPrint(3, ("WaitWakeCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    This is the PoRequest completion routine for the wait wake irp.

Arguments:

    DeviceObject - pointer to device object
    MinorFunction - irp minor function
    PowerState - power state of the irp.
    Context - context passed to the completion routine.
    IoStatus - status block.

Return Value:

    None

--*/
{
    NTSTATUS               ntStatus;
    POWER_STATE            powerState;
    PDEVICE_EXTENSION      deviceExtension;

    BulkUsb_DbgPrint(3, ("WaitWakeCallback - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) Context;

    InterlockedExchange(&deviceExtension->FlagWWOutstanding, 0);

    if(!NT_SUCCESS(IoStatus->Status)) {

        return;
    }

    //
    // wake up the device
    //

    if(deviceExtension->DevPower == PowerDeviceD0) {

        BulkUsb_DbgPrint(3, ("device already powered up...\n"));

        return;
    }

    BulkUsb_DbgPrint(3, ("WaitWakeCallback::"));
    BulkUsb_IoIncrement(deviceExtension);

    powerState.DeviceState = PowerDeviceD0;

    ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_SET_POWER, 
                                 powerState, 
                                 (PREQUEST_POWER_COMPLETE) WWIrpCompletionFunc,
                                 deviceExtension, 
                                 NULL);

    if(deviceExtension->WaitWakeEnable) {

        IssueWaitWake(deviceExtension);
    }

    BulkUsb_DbgPrint(3, ("WaitWakeCallback - ends\n"));

    return;
}


PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER\n";

        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER\n";

        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE\n";

        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkusb.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkusb.c

Abstract:

    Bulk USB device driver for Intel 82930 USB test board
	Main module

Author:

Environment:

    kernel mode only

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "bulkusb.h"
#include "bulkpnp.h"
#include "bulkpwr.h"
#include "bulkdev.h"
#include "bulkwmi.h"
#include "bulkusr.h"
#include "bulkrwr.h"

//
// Globals
//

GLOBALS Globals;
ULONG   DebugLevel = 1;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    );

VOID
BulkUsb_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
BulkUsb_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, BulkUsb_DriverUnload)
#endif
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    )
/*++ 

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.    

Arguments:
    
    DriverObject - pointer to driver object 

    RegistryPath - pointer to a unicode string representing the path to driver 
                   specific key in the registry.

Return Values:

    NT status value
    
--*/
{

    NTSTATUS        ntStatus;
    PUNICODE_STRING registryPath;
    
    //
    // initialization of variables
    //

    registryPath = &Globals.BulkUsb_RegistryPath;

    //
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //

    registryPath->MaximumLength = UniRegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length        = UniRegistryPath->Length;
    registryPath->Buffer        = ExAllocatePool(PagedPool,
                                                 registryPath->MaximumLength);

    if (!registryPath->Buffer) {

        BulkUsb_DbgPrint(1, ("Failed to allocate memory for registryPath\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntry_Exit;
    } 


    RtlZeroMemory (registryPath->Buffer, 
                   registryPath->MaximumLength);
    RtlMoveMemory (registryPath->Buffer, 
                   UniRegistryPath->Buffer, 
                   UniRegistryPath->Length);

    ntStatus = STATUS_SUCCESS;

    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = BulkUsb_DispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = BulkUsb_DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = BulkUsb_DispatchPnP;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = BulkUsb_DispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = BulkUsb_DispatchClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = BulkUsb_DispatchClean;
    DriverObject->MajorFunction[IRP_MJ_READ]           =
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = BulkUsb_DispatchReadWrite;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = BulkUsb_DispatchSysCtrl;
    DriverObject->DriverUnload                         = BulkUsb_DriverUnload;
    DriverObject->DriverExtension->AddDevice           = (PDRIVER_ADD_DEVICE)
                                                         BulkUsb_AddDevice;
DriverEntry_Exit:

    return ntStatus;
}

VOID
BulkUsb_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Description:

    This function will free the memory allocations in DriverEntry.

Arguments:

    DriverObject - pointer to driver object 

Return:
	
    None

--*/
{
    PUNICODE_STRING registryPath;

    BulkUsb_DbgPrint(3, ("BulkUsb_DriverUnload - begins\n"));

    registryPath = &Globals.BulkUsb_RegistryPath;

    if(registryPath->Buffer) {

        ExFreePool(registryPath->Buffer);
        registryPath->Buffer = NULL;
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_DriverUnload - ends\n"));

    return;
}

NTSTATUS
BulkUsb_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Description:

Arguments:

    DriverObject - Store the pointer to the object representing us.

    PhysicalDeviceObject - Pointer to the device object created by the
                           undelying bus driver.

Return:
	
    STATUS_SUCCESS - if successful 
    STATUS_UNSUCCESSFUL - otherwise

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    POWER_STATE       state;
    KIRQL             oldIrql;

    BulkUsb_DbgPrint(3, ("BulkUsb_AddDevice - begins\n"));

    deviceObject = NULL;

    ntStatus = IoCreateDevice(
                    DriverObject,                   // our driver object
                    sizeof(DEVICE_EXTENSION),       // extension size for us
                    NULL,                           // name for this device
                    FILE_DEVICE_UNKNOWN,
                    FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                    FALSE,                          // Not exclusive
                    &deviceObject);                 // Our device object

    if(!NT_SUCCESS(ntStatus)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //                
        BulkUsb_DbgPrint(1, ("Failed to create device object\n"));
        return ntStatus;
    }

    //
    // Initialize the device extension
    //

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
    deviceExtension->FunctionalDeviceObject = deviceObject;
    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    deviceObject->Flags |= DO_DIRECT_IO;

    //
    // initialize the device state lock and set the device state
    //

    KeInitializeSpinLock(&deviceExtension->DevStateLock);
    INITIALIZE_PNP_STATE(deviceExtension);

    //
    //initialize OpenHandleCount
    //
    deviceExtension->OpenHandleCount = 0;

    //
    // Initialize the selective suspend variables
    //
    KeInitializeSpinLock(&deviceExtension->IdleReqStateLock);
    deviceExtension->IdleReqPend = 0;
    deviceExtension->PendingIdleIrp = NULL;

    //
    // Hold requests until the device is started
    //

    deviceExtension->QueueState = HoldRequests;

    //
    // Initialize the queue and the queue spin lock
    //

    InitializeListHead(&deviceExtension->NewRequestsQueue);
    KeInitializeSpinLock(&deviceExtension->QueueLock);

    //
    // Initialize the remove event to not-signaled.
    //

    KeInitializeEvent(&deviceExtension->RemoveEvent, 
                      SynchronizationEvent, 
                      FALSE);

    //
    // Initialize the stop event to signaled.
    // This event is signaled when the OutstandingIO becomes 1
    //

    KeInitializeEvent(&deviceExtension->StopEvent, 
                      SynchronizationEvent, 
                      TRUE);

    //
    // OutstandingIo count biased to 1.
    // Transition to 0 during remove device means IO is finished.
    // Transition to 1 means the device can be stopped
    //

    deviceExtension->OutStandingIO = 1;
    KeInitializeSpinLock(&deviceExtension->IOCountLock);

    //
    // Delegating to WMILIB
    //
    ntStatus = BulkUsb_WmiRegistration(deviceExtension);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_DbgPrint(1, ("BulkUsb_WmiRegistration failed with %X\n", ntStatus));
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    //
    // set the flags as underlying PDO
    //

    if(PhysicalDeviceObject->Flags & DO_POWER_PAGABLE) {

        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    //
    // Typically, the function driver for a device is its 
    // power policy owner, although for some devices another 
    // driver or system component may assume this role. 
    // Set the initial power state of the device, if known, by calling 
    // PoSetPowerState.
    // 

    deviceExtension->DevPower = PowerDeviceD0;
    deviceExtension->SysPower = PowerSystemWorking;

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState(deviceObject, DevicePowerState, state);

    //
    // attach our driver to device stack
    // The return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //

    deviceExtension->TopOfStackDeviceObject = 
                IoAttachDeviceToDeviceStack(deviceObject,
                                            PhysicalDeviceObject);

    if(NULL == deviceExtension->TopOfStackDeviceObject) {

        BulkUsb_WmiDeRegistration(deviceExtension);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }
        
    //
    // Register device interfaces
    //

    ntStatus = IoRegisterDeviceInterface(deviceExtension->PhysicalDeviceObject, 
                                         &GUID_CLASS_I82930_BULK, 
                                         NULL, 
                                         &deviceExtension->InterfaceName);

    if(!NT_SUCCESS(ntStatus)) {

        BulkUsb_WmiDeRegistration(deviceExtension);
        IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    if(IoIsWdmVersionAvailable(1, 0x20)) {

        deviceExtension->WdmVersion = WinXpOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x10)) {

        deviceExtension->WdmVersion = Win2kOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x5)) {

        deviceExtension->WdmVersion = WinMeOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x0)) {

        deviceExtension->WdmVersion = Win98OrBetter;
    }

    deviceExtension->SSRegistryEnable = 0;
    deviceExtension->SSEnable = 0;

    //
    // WinXP only
    // check the registry flag -
    // whether the device should selectively
    // suspend when idle
    //

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        BulkUsb_GetRegistryDword(BULKUSB_REGISTRY_PARAMETERS_PATH,
                                 L"BulkUsbEnable",
                                 &deviceExtension->SSRegistryEnable);

        if(deviceExtension->SSRegistryEnable) {

            //
            // initialize DPC
            //
            KeInitializeDpc(&deviceExtension->DeferredProcCall, 
                            DpcRoutine, 
                            deviceObject);

            //
            // initialize the timer.
            // the DPC and the timer in conjunction, 
            // monitor the state of the device to 
            // selectively suspend the device.
            //
            KeInitializeTimerEx(&deviceExtension->Timer,
                                NotificationTimer);

            //
            // Initialize the NoDpcWorkItemPendingEvent to signaled state.
            // This event is cleared when a Dpc is fired and signaled
            // on completion of the work-item.
            //
            KeInitializeEvent(&deviceExtension->NoDpcWorkItemPendingEvent, 
                              NotificationEvent, 
                              TRUE);

            //
            // Initialize the NoIdleReqPendEvent to ensure that the idle request
            // is indeed complete before we unload the drivers.
            //
            KeInitializeEvent(&deviceExtension->NoIdleReqPendEvent,
                              NotificationEvent,
                              TRUE);
        }
    }

    //
    // Clear the DO_DEVICE_INITIALIZING flag.
    // Note: Do not clear this flag until the driver has set the
    // device power state and the power DO flags. 
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    BulkUsb_DbgPrint(3, ("BulkUsb_AddDevice - ends\n"));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkwmi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    bulkwmi.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "bulkusb.h"
#include "bulkpwr.h"
#include "bulkpnp.h"
#include "bulkdev.h"
#include "bulkrwr.h"
#include "bulkwmi.h"
#include "bulkusr.h"

#define MOFRESOURCENAME L"MofResourceName"

#define WMI_BULKUSB_DRIVER_INFORMATION 0

DEFINE_GUID (BULKUSB_WMI_STD_DATA_GUID, 
0xBBA21300, 0x6DD3, 0x11d2, 0xB8, 0x44, 0x00, 0xC0, 0x4F, 0xAD, 0x51, 0x71);

WMIGUIDREGINFO BulkWmiGuidList[1] = { {

        &BULKUSB_WMI_STD_DATA_GUID, 1, 0 // driver information
    }
};

NTSTATUS
BulkUsb_WmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Registers with WMI as a data provider for this
    instance of the device

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    
    PAGED_CODE();

    DeviceExtension->WmiLibInfo.GuidCount = 
          sizeof (BulkWmiGuidList) / sizeof (WMIGUIDREGINFO);

    DeviceExtension->WmiLibInfo.GuidList           = BulkWmiGuidList;
    DeviceExtension->WmiLibInfo.QueryWmiRegInfo    = BulkUsb_QueryWmiRegInfo;
    DeviceExtension->WmiLibInfo.QueryWmiDataBlock  = BulkUsb_QueryWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataBlock    = BulkUsb_SetWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataItem     = BulkUsb_SetWmiDataItem;
    DeviceExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DeviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //
    
    ntStatus = IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                        WMIREG_ACTION_REGISTER);

    return ntStatus;
    
}

NTSTATUS
BulkUsb_WmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

     Inform WMI to remove this DeviceObject from its 
     list of providers. This function also 
     decrements the reference count of the deviceobject.

Arguments:

Return Value:

--*/
{

    PAGED_CODE();

    return IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                    WMIREG_ACTION_DEREGISTER);

}

NTSTATUS
BulkUsb_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION  disposition;
    NTSTATUS                ntStatus;
    PIO_STACK_LOCATION      irpStack;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    BulkUsb_DbgPrint(3, (WMIMinorFunctionString(irpStack->MinorFunction)));

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchSysCtrl::"));
    BulkUsb_IoIncrement(deviceExtension);

    ntStatus = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                DeviceObject, 
                                Irp,
                                &disposition);

    switch(disposition) {

        case IrpProcessed: 
        {
            //
            // This irp has been processed and may be completed or pending.
            //

            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            //

            IoCompleteRequest(Irp, IO_NO_INCREMENT);                

            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targeted
            // at a device lower in the stack.
            //

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                    Irp);

            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            //

            ASSERT(FALSE);

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                  Irp);
            break;
        }        
    }

    BulkUsb_DbgPrint(3, ("BulkUsb_DispatchSysCtrl::"));
    BulkUsb_IoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
BulkUsb_QueryWmiRegInfo(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT ULONG           *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo	    
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    BulkUsb_DbgPrint(3, ("BulkUsb_QueryWmiRegInfo - begins\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    *RegFlags     = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.BulkUsb_RegistryPath;
    *Pdo          = deviceExtension->PhysicalDeviceObject;
    RtlInitUnicodeString(MofResourceName, MOFRESOURCENAME);

    BulkUsb_DbgPrint(3, ("BulkUsb_QueryWmiRegInfo - ends\n"));
    
    return STATUS_SUCCESS;
}

NTSTATUS
BulkUsb_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instances expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.        
            
    OutBufferSize has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             size;
    WCHAR             modelName[] = L"Aishverya\0\0";
    USHORT            modelNameLen;

    PAGED_CODE();

    BulkUsb_DbgPrint(3, ("BulkUsb_QueryWmiDataBlock - begins\n"));

    size = 0;
    modelNameLen = (wcslen(modelName) + 1) * sizeof(WCHAR);

    //
    // Only ever registers 1 instance per guid
    //

    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_BULKUSB_DRIVER_INFORMATION:

        size = sizeof(ULONG) + modelNameLen + sizeof(USHORT);

        if (OutBufferSize < size ) {

            BulkUsb_DbgPrint(3, ("OutBuffer too small\n"));

            ntStatus = STATUS_BUFFER_TOO_SMALL;

            break;
        }

        * (PULONG) Buffer = DebugLevel;

        Buffer += sizeof(ULONG);

        //
        // put length of string ahead of string
        //

        *((PUSHORT)Buffer) = modelNameLen;

        Buffer = (PUCHAR)Buffer + sizeof(USHORT);

        RtlCopyBytes((PVOID)Buffer, (PVOID)modelName, modelNameLen);

        *InstanceLengthArray = size ;

        ntStatus = STATUS_SUCCESS;

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                size,
                                IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_QueryWmiDataBlock - ends\n"));

    return ntStatus;
}


NTSTATUS
BulkUsb_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;
    
    PAGED_CODE();

    BulkUsb_DbgPrint(3, ("BulkUsb_SetWmiDataItem - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    switch(GuidIndex) {
    
    case WMI_BULKUSB_DRIVER_INFORMATION:

        if(DataItemId == 1) {

            if(BufferSize == sizeof(ULONG)) {

                DebugLevel = *((PULONG)Buffer);

                ntStatus = STATUS_SUCCESS;

                info = sizeof(ULONG);
            }
            else {

                ntStatus = STATUS_INFO_LENGTH_MISMATCH;
            }
        }
        else {

            ntStatus = STATUS_WMI_READ_ONLY;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_SetWmiDataItem - ends\n"));

    return ntStatus;
}

NTSTATUS
BulkUsb_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    BulkUsb_DbgPrint(3, ("BulkUsb_SetWmiDataBlock - begins\n"));

    switch(GuidIndex) {
    
    case WMI_BULKUSB_DRIVER_INFORMATION:

        if(BufferSize == sizeof(ULONG)) {

            DebugLevel = *(PULONG) Buffer;
                    
            ntStatus = STATUS_SUCCESS;

            info = sizeof(ULONG);
        }
        else {

            ntStatus = STATUS_INFO_LENGTH_MISMATCH;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    BulkUsb_DbgPrint(3, ("BulkUsb_SetWmiDataBlock - ends\n"));

    return ntStatus;
}

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
            return "IRP_MN_CHANGE_SINGLE_INSTANCE\n";

        case IRP_MN_CHANGE_SINGLE_ITEM:
            return "IRP_MN_CHANGE_SINGLE_ITEM\n";

        case IRP_MN_DISABLE_COLLECTION:
            return "IRP_MN_DISABLE_COLLECTION\n";

        case IRP_MN_DISABLE_EVENTS:
            return "IRP_MN_DISABLE_EVENTS\n";

        case IRP_MN_ENABLE_COLLECTION:
            return "IRP_MN_ENABLE_COLLECTION\n";

        case IRP_MN_ENABLE_EVENTS:
            return "IRP_MN_ENABLE_EVENTS\n";

        case IRP_MN_EXECUTE_METHOD:
            return "IRP_MN_EXECUTE_METHOD\n";

        case IRP_MN_QUERY_ALL_DATA:
            return "IRP_MN_QUERY_ALL_DATA\n";

        case IRP_MN_QUERY_SINGLE_INSTANCE:
            return "IRP_MN_QUERY_SINGLE_INSTANCE\n";

        case IRP_MN_REGINFO:
            return "IRP_MN_REGINFO\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\makefile.inc ===
mofcomp: bulkusb.bmf

bulkusb.bmf: bulkusb.mof
        mofcomp -B:bulkusb.bmf bulkusb.mof
        wmimofck bulkusb.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\filter\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pnp.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, VA_PnP)
        #pragma alloc_text(PAGE, GetDeviceCapabilities)
        #ifdef HANDLE_DEVICE_USAGE
            #pragma alloc_text(PAGE, VA_DeviceUsageNotification)
        #endif // HANDLE_DEVICE_USAGE
#endif


NTSTATUS VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for PnP IRPs (MajorFunction == IRP_MJ_PNP)

Arguments:

    devExt - device extension for the targetted device object
    irp - IO Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN completeIrpHere = FALSE;
    BOOLEAN justReturnStatus = FALSE;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(("VA_PnP, minorFunc = %d ", (ULONG)irpSp->MinorFunction));

    switch (irpSp->MinorFunction){

    case IRP_MN_START_DEVICE:
        DBGOUT(("START_DEVICE"));

        devExt->state = STATE_STARTING;

        /*
         *  First, send the START_DEVICE irp down the stack
         *  synchronously to start the lower stack.
         *  We cannot do anything with our device object
         *  before propagating the START_DEVICE this way.
         */
        IoCopyCurrentIrpStackLocationToNext(irp);
        status = CallNextDriverSync(devExt, irp);

        if (NT_SUCCESS(status)){
            /*
             *  Now that the lower stack is started,
             *  do any initialization required by this device object.
             */
            status = GetDeviceCapabilities(devExt);
            if (NT_SUCCESS(status)){
                devExt->state = STATE_STARTED;
            }
            else {
                devExt->state = STATE_START_FAILED;
            }
        }
        else {
            devExt->state = STATE_START_FAILED;
        }
        completeIrpHere = TRUE;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
#ifdef HANDLE_DEVICE_USAGE
        //
        // Need to fail these IRPs if a paging, hibernation, or crashdump
        // file is currently open on this device
        //
        if(    devExt->pagingFileCount      != 0
            || devExt->hibernationFileCount != 0
            || devExt->crashdumpFileCount   != 0 )
        {
            // Fail the IRP
            DBGOUT(( "Failing QUERY_(STOP,REMOVE)_DEVICE request b/c "
                     "paging, hiber, or crashdump file is present on device." ));
            status = STATUS_UNSUCCESSFUL;
            completeIrpHere = TRUE;
        }
        else
        {
            // We'll just pass this IRP down the driver stack.  But
            // first, must change the IRP's status to STATUS_SUCCESS
            // (default is STATUS_NOT_SUPPORTED)
            irp->IoStatus.Status = STATUS_SUCCESS;
        }
#else
        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        irp->IoStatus.Status = STATUS_SUCCESS;
#endif

        break;

    case IRP_MN_STOP_DEVICE:
        if (devExt->state == STATE_SUSPENDED){
            status = STATUS_DEVICE_POWER_FAILURE;
            completeIrpHere = TRUE;
        }
        else {
            /*
             *  Only set state to STOPPED if the device was
             *  previously started successfully.
             */
            if (devExt->state == STATE_STARTED){
                devExt->state = STATE_STOPPED;
            }
        }
        break;


    case IRP_MN_SURPRISE_REMOVAL:
        DBGOUT(("SURPRISE_REMOVAL"));

        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        irp->IoStatus.Status = STATUS_SUCCESS;

        /*
         *  For now just set the STATE_REMOVING state so that
         *  we don't do any more IO.  We are guaranteed to get
         *  IRP_MN_REMOVE_DEVICE soon; we'll do the rest of
         *  the remove processing there.
         */
        devExt->state = STATE_REMOVING;

        break;

    case IRP_MN_REMOVE_DEVICE:
        /*
         *  Check the current state to guard against multiple
         *  REMOVE_DEVICE IRPs.
         */
        DBGOUT(("REMOVE_DEVICE"));
        if (devExt->state != STATE_REMOVED){

            devExt->state = STATE_REMOVED;

            /*
             *  Send the REMOVE IRP down the stack asynchronously.
             *  Do not synchronize sending down the REMOVE_DEVICE
             *  IRP, because the REMOVE_DEVICE IRP must be sent
             *  down and completed all the way back up to the sender
             *  before we continue.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = IoCallDriver(devExt->topDevObj, irp);
            justReturnStatus = TRUE;

            DBGOUT(("REMOVE_DEVICE - waiting for %d irps to complete...",
                    devExt->pendingActionCount));

            /*
             *  We must for all outstanding IO to complete before
             *  completing the REMOVE_DEVICE IRP.
             *
             *  First do an extra decrement on the pendingActionCount.
             *  This will cause pendingActionCount to eventually
             *  go to -1 once all asynchronous actions on this
             *  device object are complete.
             *  Then wait on the event that gets set when the
             *  pendingActionCount actually reaches -1.
             */
            DecrementPendingActionCount(devExt);
            KeWaitForSingleObject(  &devExt->removeEvent,
                                    Executive,      // wait reason
                                    KernelMode,
                                    FALSE,          // not alertable
                                    NULL );         // no timeout

            DBGOUT(("REMOVE_DEVICE - ... DONE waiting. "));

#ifdef HANDLE_DEVICE_USAGE
            /*
             *  If we locked-down certain paged code sections earlier
             *  because of this device, then need to unlock them now
             *  (before calling IoDeleteDevice)
             */
            if( NULL != devExt->pagingPathUnlockHandle )
            {
                DBGOUT(( "UNLOCKing some driver code (non-pageable) (b/c paging path)" ));
                MmUnlockPagableImageSection( devExt->pagingPathUnlockHandle );
                devExt->pagingPathUnlockHandle = NULL;
            }

            if( NULL != devExt->initUnlockHandle )
            {
                DBGOUT(( "UNLOCKing some driver code (non-pageable) (b/c init conditions)" ));
                MmUnlockPagableImageSection( devExt->initUnlockHandle );
                devExt->initUnlockHandle = NULL;
            }
#endif // HANDLE_DEVICE_USAGE

            /*
             *  Detach our device object from the lower
             *  device object stack.
             */
            IoDetachDevice(devExt->topDevObj);

            /*
             *  Delete our device object.
             *  This will also delete the associated device extension.
             */
            IoDeleteDevice(devExt->filterDevObj);
        }
        break;

#ifdef HANDLE_DEVICE_USAGE
    case IRP_MN_DEVICE_USAGE_NOTIFICATION:


        //
        // Make sure the Type of this UsageNotification is one that we handle
        //
        if(    irpSp->Parameters.UsageNotification.Type != DeviceUsageTypePaging
            && irpSp->Parameters.UsageNotification.Type != DeviceUsageTypeHibernation
            && irpSp->Parameters.UsageNotification.Type != DeviceUsageTypeDumpFile )
        {
            break; // out of the big switch statement (and just forward this IRP)
        }

        status = VA_DeviceUsageNotification(devExt, irp);
        justReturnStatus = TRUE;
        break;
#endif // HANDLE_DEVICE_USAGE

#ifdef HANDLE_DEVICE_USAGE
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        //
        // If a paging, hibernation, or crashdump file is currently open
        // on this device, must set NOT_DISABLEABLE flag in DeviceState
        //
        if(    devExt->pagingFileCount      != 0
            || devExt->hibernationFileCount != 0
            || devExt->crashdumpFileCount   != 0  )
        {
            // Mark the device as not disableable
            PPNP_DEVICE_STATE pDeviceState;
            pDeviceState = (PPNP_DEVICE_STATE) &irp->IoStatus.Information;
            *pDeviceState |= PNP_DEVICE_NOT_DISABLEABLE;
        }

        //
        // We _did_ handle this IRP (as best we could), so set IRP's
        // status to STATUS_SUCCESS (default is STATUS_NOT_SUPPORTED)
        // before passing it down the driver stack
        //
        irp->IoStatus.Status = STATUS_SUCCESS;

        break;
#endif // HANDLE_DEVICE_USAGE

    case IRP_MN_QUERY_DEVICE_RELATIONS:
    default:
        break;


    }

    if (justReturnStatus){
        /*
         *  We've already sent this IRP down the stack.
         */
    }
    else if (completeIrpHere){
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
    else {
        IoCopyCurrentIrpStackLocationToNext(irp);
        status = IoCallDriver(devExt->topDevObj, irp);
    }

    return status;
}

#ifdef HANDLE_DEVICE_USAGE
NTSTATUS
VA_DeviceUsageNotification(struct DEVICE_EXTENSION *devExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    BOOLEAN fSetPagable = FALSE;  // whether we set the PAGABLE bit
                                  /// before we passed-on this IRP

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(( "DEVICE_USAGE_NOTIFICATION (Type==%d , InPath==%d)"
             , irpSp->Parameters.UsageNotification.Type
             , irpSp->Parameters.UsageNotification.InPath
          ));
    DBGOUT(( "    [devExt=0x%08X fltrDevObj=0x%08X]", devExt, devExt->filterDevObj ));

    //
    // Wait on the paging path event (to prevent several instances of
    // this IRP from being processed at once)
    //
    status = KeWaitForSingleObject( &devExt->deviceUsageNotificationEvent
                                    , Executive    // wait reason
                                    , KernelMode
                                    , FALSE        // not alertable
                                    , NULL         // no timeout
                                  );


    /*
     * IMPORTANT NOTE: When to modify our DO_POWER_PAGABLE bit depends
     * on whether it needs to be set or cleared.  If the IRP indicates
     * our PAGABLE bit should be set, then we must set it _before_
     * forwarding the IRP down the driver stack (and possibly clear it
     * afterward, if lower drivers fail the IRP).  But if the IRP
     * indicates that our PAGABLE bit should be cleared, then we must
     * first forward the IRP to lower drivers, and then clear our bit
     * only if the lower drivers return STATUS_SUCCESS.
     */

    //
    // If removing last paging file from this device...
    //
    if(    irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging
        && !irpSp->Parameters.UsageNotification.InPath
        && devExt->pagingFileCount == 1       )
    {
        //
        // Set DO_POWER_PAGABLE bit (if it was set at startup).
        // If lower drivers fail this IRP, we'll clear it later.
        //
        DBGOUT(( "Removing last paging file..." ));

        if( devExt->initialFlags & DO_POWER_PAGABLE )
        {
            DBGOUT(( "...so RE-setting PAGABLE bit" ));
            devExt->filterDevObj->Flags |= DO_POWER_PAGABLE;
            fSetPagable = TRUE;
        }
        else
        {
            DBGOUT(( "...but PAGABLE bit wasn't set initially, so not setting it now." ));
        }

    }


    //
    // Forward the irp synchronously
    //
    IoCopyCurrentIrpStackLocationToNext( irp );
    status = CallNextDriverSync( devExt, irp );


    //
    // Now deal with the failure and success cases.
    //
    if( ! NT_SUCCESS(status) )
    {
        //
        // Lower drivers failed the IRP, so _undo_ any changes we
        // made before passing-on the IRP to those drivers.
        //
        if( fSetPagable )
        {
            DBGOUT(( "IRP was failed, so UN-setting PAGABLE bit" ));
            devExt->filterDevObj->Flags &= ~DO_POWER_PAGABLE;
        }
    }
    else
    {
        //
        // Lower drivers returned SUCCESS, so we can do everything
        // that must be done in response to this IRP...
        //

        switch( irpSp->Parameters.UsageNotification.Type )
        {
        case DeviceUsageTypeHibernation:

            // Adjust counter
            IoAdjustPagingPathCount( &devExt->hibernationFileCount,
                                     irpSp->Parameters.UsageNotification.InPath );
            DBGOUT(( "Num. Hibernation files is now %d", devExt->hibernationFileCount ));
            ASSERT( devExt->hibernationFileCount >= 0 );
            break;

        case DeviceUsageTypeDumpFile:

            // Adjust counter
            IoAdjustPagingPathCount( &devExt->crashdumpFileCount,
                                     irpSp->Parameters.UsageNotification.InPath );
            DBGOUT(( "Num. Crashdump files is now %d", devExt->crashdumpFileCount ));
            ASSERT( devExt->crashdumpFileCount >= 0 );
            break;

        case DeviceUsageTypePaging:

            // Adjust counter
            IoAdjustPagingPathCount( &devExt->pagingFileCount,
                                     irpSp->Parameters.UsageNotification.InPath );
            DBGOUT(( "Num. Paging files is now %d", devExt->pagingFileCount ));
            ASSERT( devExt->pagingFileCount >= 0 );

            //
            // If we've just switched between being pageable<->nonpageable...
            //
            if(    irpSp->Parameters.UsageNotification.InPath
                && devExt->pagingFileCount == 1  )
            {
                //
                // Just added a paging file, so clear the PAGABLE
                // flag, and lock-down the code for all routines
                // that could be called at IRQL >= DISPATCH_LEVEL
                // (so that they're _non-pageable_).
                //
                DBGOUT(( "Just added first paging file..." ));
                DBGOUT(( "...so clearing PAGABLE bit" ));
                devExt->filterDevObj->Flags &= ~DO_POWER_PAGABLE;

                DBGOUT(( "LOCKing some driver code (non-pageable) (b/c paging path)" ));
                devExt->pagingPathUnlockHandle = MmLockPagableCodeSection( VA_Power );  // some func that's inside the code section that we want to lock
                ASSERT( NULL != devExt->pagingPathUnlockHandle );
            }
            else if (    !irpSp->Parameters.UsageNotification.InPath
                      && devExt->pagingFileCount == 0  )
            {
                //
                // Just removed the last paging file, but we
                // already set the PAGABLE flag (if necessary)
                // before forwarding IRP, so just remove the
                // _paging-path_ lock from this driver. (NOTE:
                // initial-condition lock might still be in place,
                // but that's what we want.)
                //
                DBGOUT(( "UNLOCKing some driver code (pageable) (b/c paging path)" ));
                ASSERT( NULL != devExt->pagingPathUnlockHandle );
                MmUnlockPagableImageSection( devExt->pagingPathUnlockHandle );
                devExt->pagingPathUnlockHandle = NULL;
            }
            break;

        default:
            ASSERT( FALSE );  // should never get here (b/c checked for invalid Type earlier)

        } //END: switch on Type of special-file


        //
        // Invalidate state, so that certain flags will get updated
        //
        IoInvalidateDeviceState( devExt->physicalDevObj );

    }//END: handling of irp success/failure cases


    //
    // Set event so that the next DEVICE_USAGE_NOTIFICATION IRP that
    // comes along can be processed.
    //
    KeSetEvent( &devExt->deviceUsageNotificationEvent
                , IO_NO_INCREMENT
                , FALSE
              );

    //
    // Complete the irp
    //
    IoCompleteRequest( irp, IO_NO_INCREMENT );
    return status;
}
#endif // HANDLE_DEVICE_USAGE



NTSTATUS GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

    Function retrieves the DEVICE_CAPABILITIES descriptor from the device

Arguments:

    devExt - device extension for targetted device object

Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIRP irp;

    PAGED_CODE();

    irp = IoAllocateIrp(devExt->topDevObj->StackSize, FALSE);
    if (irp){
        PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(irp);

        // must initialize DeviceCapabilities before sending...
        RtlZeroMemory(  &devExt->deviceCapabilities,
                        sizeof(DEVICE_CAPABILITIES));
        devExt->deviceCapabilities.Size = sizeof(DEVICE_CAPABILITIES);
        devExt->deviceCapabilities.Version = 1;
        devExt->deviceCapabilities.Address = -1;
        devExt->deviceCapabilities.UINumber = -1;

        // setup irp stack location...
        nextSp->MajorFunction = IRP_MJ_PNP;
        nextSp->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        nextSp->Parameters.DeviceCapabilities.Capabilities =
                        &devExt->deviceCapabilities;

        /*
         *  For any IRP you create, you must set the default status
         *  to STATUS_NOT_SUPPORTED before sending it.
         */
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = CallNextDriverSync(devExt, irp);

        IoFreeIrp(irp);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\filter\filter.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    filter.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(INIT, DriverEntry)
        #pragma alloc_text(PAGE, VA_AddDevice)
        #pragma alloc_text(PAGE, VA_DriverUnload)
#endif


NTSTATUS DriverEntry(
                        IN PDRIVER_OBJECT DriverObject, 
                        IN PUNICODE_STRING RegistryPath
                    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG i;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(RegistryPath);

    DBGOUT(("DriverEntry")); 

    /*
     *  Route all IRPs on device objects created by this driver
     *  to our IRP dispatch routine.
     */
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++){
        DriverObject->MajorFunction[i] = VA_Dispatch; 
    }

    DriverObject->DriverExtension->AddDevice = VA_AddDevice;
    DriverObject->DriverUnload = VA_DriverUnload;

    return STATUS_SUCCESS;
}


NTSTATUS VA_AddDevice(
                        IN PDRIVER_OBJECT driverObj, 
                        IN PDEVICE_OBJECT physicalDevObj
                     )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new 
    PDO (Physical Device Object), for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY non pnp IRPS to the given driver
    stack, UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    driverObj - pointer to a device object.

    physicalDevObj -    pointer to a physical device object pointer 
                        created by the  underlying bus driver.

Return Value:

    NT status code.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT filterDevObj = NULL;
    
    PAGED_CODE();

    DBGOUT(("VA_AddDevice: drvObj=%ph, pdo=%ph", driverObj, physicalDevObj)); 

    status = IoCreateDevice(    driverObj, 
                                sizeof(struct DEVICE_EXTENSION),
                                NULL,           // name for this device
                                FILE_DEVICE_UNKNOWN, 
                                FILE_AUTOGENERATED_DEVICE_NAME,                // device characteristics
                                FALSE,          // not exclusive
                                &filterDevObj); // our device object
    //
    // It is important that you choose correctly the file type for this
    // device object.  Here we use FILE_DEVICE_UNKNOWN because this is
    // a generic filter, however as will all filters, the creator needs
    // to understand to which stack this filter is attaching.
    // E.G. if you are writing a CD filter driver you need to use
    // FILE_DEVICE_CD_ROM.  IoCreateDevice actually creates device object
    // with different properties dependent on this field.
    //


    if (NT_SUCCESS(status)){
        struct DEVICE_EXTENSION *devExt;

        ASSERT(filterDevObj);

        /*
         *  Initialize device extension for new device object
         */
        devExt = (struct DEVICE_EXTENSION *)filterDevObj->DeviceExtension;
        RtlZeroMemory(devExt, sizeof(struct DEVICE_EXTENSION));
        devExt->signature = DEVICE_EXTENSION_SIGNATURE;
        devExt->state = STATE_INITIALIZED;
        devExt->filterDevObj = filterDevObj;
        devExt->physicalDevObj = physicalDevObj;
        
        devExt->pendingActionCount = 0;
        KeInitializeEvent(&devExt->removeEvent, NotificationEvent, FALSE);
#ifdef HANDLE_DEVICE_USAGE
        KeInitializeEvent(&devExt->deviceUsageNotificationEvent, SynchronizationEvent, TRUE);
#endif // HANDLE_DEVICE_USAGE

        /*
         *  Attach the new device object to the top of the device stack.
         */
        devExt->topDevObj = IoAttachDeviceToDeviceStack(filterDevObj, physicalDevObj);

        ASSERT(devExt->topDevObj);
        DBGOUT(("created filterDevObj %ph attached to %ph.", filterDevObj, devExt->topDevObj));


        //
        // As a filter driver, we do not want to change the power or I/O
        // behavior of the driver stack in any way.  Recall that a filter
        // driver should "appear" the same (almost) as the underlying device.
        // Therefore we must copy some bits from the device object _directly_
        // below us in the device stack (notice: DON'T copy from the PDO!)
        //


        /* Various I/O-related flags which should be maintained */
        /* (copy from lower device object) */
        filterDevObj->Flags |=
            (devExt->topDevObj->Flags & (DO_BUFFERED_IO | DO_DIRECT_IO));

        /* Various Power-related flags which should be maintained */
        /* (copy from lower device object) */
        filterDevObj->Flags |= (devExt->topDevObj->Flags &
            (DO_POWER_INRUSH | DO_POWER_PAGABLE /*| DO_POWER_NOOP*/)); 

#ifdef HANDLE_DEVICE_USAGE
        //
        // To determine whether some of our routines should initially be
        // pageable, we must consider the DO_POWER_xxxx flags of the
        // device object directly below us in the device stack.
        //
        // * We make ourselves pageable if:
        //     - that devobj has its PAGABLE bit set (so we know our power
        //       routines won't be called at DISPATCH_LEVEL)
        // -OR-
        //     - that devobj has its NOOP bit set (so we know we won't be
        //       participating in power-management at all).  NOTE, currently
        //       DO_POWER_NOOP is not implemented.
        //
        // * Otherwise, we make ourselves non-pageable because either:
        //     - that devobj has its INRUSH bit set (so we also have to be
        //       INRUSH, and code that handles INRUSH irps can't be pageable)
        // -OR-
        //     - that devobj does NOT have its PAGABLE bit set (and NOOP isn't
        //       set, so some of our code might be called at DISPATCH_LEVEL)
        //
        if ((devExt->topDevObj->Flags & DO_POWER_PAGABLE)
             /*|| (devExt->topDevObj->Flags & DO_POWER_NOOP)*/)
        {
            // We're initially pageable.
            //
            // Don't need to do anything else here, for now.
        }
        else
        {
            // We're initially non-pageable.
            //
            // We need to lock-down the code for all routines
            // that could be called at IRQL >= DISPATCH_LEVEL.
            DBGOUT(( "LOCKing some driver code (non-pageable) (b/c init conditions)" ));
            devExt->initUnlockHandle = MmLockPagableCodeSection( VA_Power );  // some func that's inside the code section that we want to lock
            ASSERT( NULL != devExt->initUnlockHandle );
        }

        /*
         *  Remember our initial flag settings.
         *  (Need remember initial settings to correctly handle
         *  setting of PAGABLE bit later.)
         */
        devExt->initialFlags = filterDevObj->Flags & ~DO_DEVICE_INITIALIZING;
#endif // HANDLE_DEVICE_USAGE

        /*
         *  Clear the initializing bit from the new device object's flags.
         *  NOTE: must not do this until *after* setting DO_POWER_xxxx flags
         */
        filterDevObj->Flags &= ~DO_DEVICE_INITIALIZING;

        /*
         *  This is a do-nothing call to a sample function which
         *  demonstrates how to read the device's registry area.
         *  Note that you cannot make this call on devExt->filterDevObj
         *  because a filter device object does not have a devNode.
         *  We pass devExt->physicalDevObj, which is the device object
         *  for which this driver is a filter driver.
         */
        RegistryAccessSample(devExt, devExt->physicalDevObj);
    } 

    ASSERT(NT_SUCCESS(status));
    return status;
}


VOID VA_DriverUnload(IN PDRIVER_OBJECT DriverObject)
/*++

Routine Description:

    Free all the allocated resources, etc.

    Note:  Although the DriverUnload function often does nothing,
           the driver must set a DriverUnload function in 
           DriverEntry; otherwise, the kernel will never unload
           the driver.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE();

    DBGOUT(("VA_DriverUnload")); 
}


NTSTATUS VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Common entrypoint for all Io Request Packets

Arguments:

    DeviceObject - pointer to a device object.
    Irp - Io Request Packet

Return Value:

    NT status code.

--*/

{
    struct DEVICE_EXTENSION *devExt;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN passIrpDown = TRUE;
    UCHAR majorFunc, minorFunc;
    NTSTATUS status;

    devExt = DeviceObject->DeviceExtension;
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Get major/minor function codes in private variables
     *  so we can access them after the IRP is completed.
     */
    majorFunc = irpSp->MajorFunction;
    minorFunc = irpSp->MinorFunction;

    DBGOUT(("VA_Dispatch: majorFunc=%d, minorFunc=%d", 
            (ULONG)majorFunc, (ULONG)minorFunc)); 

    /*
     *  For all IRPs except REMOVE, we increment the PendingActionCount
     *  across the dispatch routine in order to prevent a race condition with
     *  the REMOVE_DEVICE IRP (without this increment, if REMOVE_DEVICE
     *  preempted another IRP, device object and extension might get
     *  freed while the second thread was still using it).
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        IncrementPendingActionCount(devExt);
    }

    if ((majorFunc != IRP_MJ_PNP) &&
        (majorFunc != IRP_MJ_CLOSE) &&
        ((devExt->state == STATE_REMOVING) ||
         (devExt->state == STATE_REMOVED))){

        /*
         *  While the device is being removed, 
         *  we only pass down the PNP and CLOSE IRPs.
         *  We fail all other IRPs.
         */
        status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        passIrpDown = FALSE;
    }
    else {
        switch (majorFunc){

            case IRP_MJ_PNP:
                status = VA_PnP(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_POWER:
                status = VA_Power(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_CREATE:
            case IRP_MJ_CLOSE:
            case IRP_MJ_DEVICE_CONTROL:
            case IRP_MJ_SYSTEM_CONTROL:
            case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            default:
                /*
                 *  For unsupported IRPs, we simply send the IRP
                 *  down the driver stack.
                 */
                break;
        }
    }

    if (passIrpDown){
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = IoCallDriver(devExt->topDevObj, Irp);
    }

    /*
     *  Balance the increment to PendingActionCount above.
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        DecrementPendingActionCount(devExt);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\hub.pnp\busif.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    busif.c

Abstract:

    Links to new usb 2.0 stack

    The effect is that when running on the USB2 stack the hub
    is no longer depenent on the port driver archetecture or
    USBD for the PnP services:

    CreateDevice
    InitailiazeDevice
    RemoveDevice


Environment:

    kernel mode only

Notes:



Revision History:

    10-29-95 : created

--*/

#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */
#include "usbhub.h"

#ifdef USB2

NTSTATUS
USBD_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;


    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
USBHUB_GetBusInterface(
    IN PDEVICE_OBJECT RootHubPdo,
    IN PUSB_HUB_BUS_INTERFACE BusInterface
    )
/*++

Routine Description:

Arguments:

Return Value:

    returns success if USB2 stack

--*/
{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    irp = IoAllocateIrp(RootHubPdo->StackSize, FALSE);

    if (!irp) {
        return STATUS_UNSUCCESSFUL;
    }

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED.
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           USBD_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_INTERFACE;

    // init busif
    //busIf->
    nextStack->Parameters.QueryInterface.Interface = (PINTERFACE) BusInterface;
    nextStack->Parameters.QueryInterface.InterfaceSpecificData =
        RootHubPdo;
    nextStack->Parameters.QueryInterface.InterfaceType =
        &USB_BUS_INTERFACE_HUB_GUID;
    nextStack->Parameters.QueryInterface.Size =
        sizeof(*BusInterface);
    nextStack->Parameters.QueryInterface.Version =
        HUB_BUSIF_VERSION;

    ntStatus = IoCallDriver(RootHubPdo,
                            irp);

    if (ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);

        ntStatus = irp->IoStatus.Status;
    }

    if (NT_SUCCESS(ntStatus)) {
        // we have a bus interface

        ASSERT(BusInterface->Version == HUB_BUSIF_VERSION);
        ASSERT(BusInterface->Size == sizeof(*BusInterface));

    }

    IoFreeIrp(irp);
    // get the bus interface

    return ntStatus;
}


NTSTATUS
USBD_CreateDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PUSB_DEVICE_HANDLE *DeviceData,
    IN PDEVICE_OBJECT RootHubPdo,
    IN ULONG MaxPacketSize_Endpoint0,
    IN OUT PULONG DeviceHackFlags,
    IN USHORT PortStatus,
    IN USHORT PortNumber
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS                    ntStatus;
    PUSB_DEVICE_HANDLE          hubDeviceHandle;
    PUSB_HUB_BUS_INTERFACE   busIf;

    // note no device extension for USBD if running on
    // usb 2 stack


    // If the HUB was ever reset through USBH_ResetDevice, the HUB PDO
    // DeviceExtensionPort->DeviceData could have changed.  Instead of trying
    // to propagate a change in the HUB PDO DeviceExtensionPort->DeviceData
    // through to the HUB FDO DeviceExtensionHub when a change happens, let's
    // just retrieve the HubDeviceHandle every time we use it (which is only
    // in this routine) instead of keeping a cached copy.
    //
    hubDeviceHandle =
        USBH_SyncGetDeviceHandle(DeviceExtensionHub->TopOfStackDeviceObject);


    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->CreateUsbDevice) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->CreateUsbDevice(busIf->BusContext,
                                          DeviceData,
                                          hubDeviceHandle,
                                          PortStatus,
                                          // ttnumber
                                          PortNumber);
    }

    // get the hack flags

    return ntStatus;
}


NTSTATUS
USBD_InitUsb2Hub(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS                    ntStatus;
    PUSB_DEVICE_HANDLE          hubDeviceHandle;
    PUSB_HUB_BUS_INTERFACE   busIf;
    ULONG ttCount = 1;
    
    // note no device extension for USBD if running on
    // usb 2 stack

    // should only call this on a usb 2.0 hub
    USBH_ASSERT(DeviceExtensionHub->HubFlags & HUBFLAG_USB20_HUB);

    if (DeviceExtensionHub->HubFlags & HUBFLAG_USB20_MULTI_TT) {
        PUSB_HUB_DESCRIPTOR hubDescriptor;
    
        hubDescriptor = DeviceExtensionHub->HubDescriptor;
        USBH_ASSERT(NULL != hubDescriptor);

        ttCount = hubDescriptor->bNumberOfPorts;
    }

    // If the HUB was ever reset through USBH_ResetDevice, the HUB PDO
    // DeviceExtensionPort->DeviceData could have changed.  Instead of trying
    // to propagate a change in the HUB PDO DeviceExtensionPort->DeviceData
    // through to the HUB FDO DeviceExtensionHub when a change happens, let's
    // just retrieve the HubDeviceHandle every time we use it (which is only
    // in this routine) instead of keeping a cached copy.
    //
    hubDeviceHandle =
        USBH_SyncGetDeviceHandle(DeviceExtensionHub->TopOfStackDeviceObject);


    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->Initialize20Hub) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->Initialize20Hub(busIf->BusContext,
                                          hubDeviceHandle,
                                          ttCount);
    }

    return ntStatus;
}


NTSTATUS
USBD_InitializeDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_DEVICE_HANDLE DeviceData,
    IN PDEVICE_OBJECT RootHubPdo,
    IN OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
    IN ULONG DeviceDescriptorLength,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor,
    IN ULONG ConfigDescriptorLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{

    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->InitializeUsbDevice || !busIf->GetUsbDescriptors) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->InitializeUsbDevice(busIf->BusContext,
                                              DeviceData);
    }

    // if successful fetch the descriptors
    if (NT_SUCCESS(ntStatus)) {

        ntStatus = busIf->GetUsbDescriptors(busIf->BusContext,
                                              DeviceData,
                                              (PUCHAR) DeviceDescriptor,
                                              &DeviceDescriptorLength,
                                              (PUCHAR) ConfigDescriptor,
                                              &ConfigDescriptorLength);
    }

    return ntStatus;
}


NTSTATUS
USBD_RemoveDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_DEVICE_HANDLE DeviceData,
    IN PDEVICE_OBJECT RootHubPdo,
    IN ULONG Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    // flags are currently not used by usb2 stack

    if (!busIf->RemoveUsbDevice) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->RemoveUsbDevice(busIf->BusContext,
                                          DeviceData,
                                          Flags);
    }

    return ntStatus;
}


NTSTATUS
USBD_GetDeviceInformationEx(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_NODE_CONNECTION_INFORMATION_EX DeviceInformation,
    IN ULONG DeviceInformationLength,
    IN PUSB_DEVICE_HANDLE DeviceData
    )
/*
    This function maps the new port service on to the 
    old hub api.
*/
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;
    ULONG length, lengthCopied;
    ULONG i, need;
    PUSB_DEVICE_INFORMATION_0 level_0 = NULL;
    PUSB_NODE_CONNECTION_INFORMATION_EX localDeviceInfo;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->QueryDeviceInformation) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
        return ntStatus;
    }

    // call the new API and map the data to the old format

//    USBH_KdPrint((0, "'Warning: Caller is using old style IOCTL.\n"));
//    USBH_KdPrint((0, "'If this is a WinOS component or Test Application please fix it.\n"));
//    TEST_TRAP();

    length = sizeof(*level_0);

    do {
        ntStatus = STATUS_SUCCESS;

        level_0 = UsbhExAllocatePool(PagedPool, length);
        if (level_0 == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (NT_SUCCESS(ntStatus)) {
            level_0->InformationLevel = 0;

            ntStatus = busIf->QueryDeviceInformation(busIf->BusContext,
                                                     DeviceData,
                                                     level_0,
                                                     length,
                                                     &lengthCopied);

            if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                length = level_0->ActualLength;
                UsbhExFreePool(level_0);
            }
        }

    } while (ntStatus == STATUS_BUFFER_TOO_SMALL);

    // do we have enough to satisfiy the API?

    need = level_0->NumberOfOpenPipes * sizeof(USB_PIPE_INFO) +
            sizeof(USB_NODE_CONNECTION_INFORMATION);

    localDeviceInfo = UsbhExAllocatePool(PagedPool, need);
    if (localDeviceInfo == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus)) {

        USBH_KdPrint((2, "'level_0 %x\n", level_0 ));

        // BUGBUG
        // DeviceInformation has some preset fields, save them
        // in the loacl info buffer
        localDeviceInfo->DeviceIsHub =
            DeviceInformation->DeviceIsHub;

        localDeviceInfo->ConnectionIndex =
            DeviceInformation->ConnectionIndex;

        localDeviceInfo->ConnectionStatus =
            DeviceInformation->ConnectionStatus;

        localDeviceInfo->DeviceIsHub =
            DeviceInformation->DeviceIsHub;

        // map to the old format
        localDeviceInfo->DeviceDescriptor =
            level_0->DeviceDescriptor;

        localDeviceInfo->CurrentConfigurationValue =
            level_0->CurrentConfigurationValue;

        localDeviceInfo->Speed = (UCHAR) level_0->DeviceSpeed;

        // draw this from our extension
        localDeviceInfo->DeviceIsHub =
            (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB)
                ? TRUE : FALSE;

        localDeviceInfo->DeviceAddress =
            level_0->DeviceAddress;

        localDeviceInfo->NumberOfOpenPipes =
            level_0->NumberOfOpenPipes;

        // BUGBUG - hardcode to 'connected' ?
        // is this used by callers?
//        DeviceInformation->ConnectionStatus =
//            DeviceConnected;

        for (i=0; i< level_0->NumberOfOpenPipes; i++) {

            localDeviceInfo->PipeList[i].EndpointDescriptor =
                level_0->PipeList[i].EndpointDescriptor;

            localDeviceInfo->PipeList[i].ScheduleOffset =
                level_0->PipeList[i].ScheduleOffset;
        }
    }

    if (level_0 != NULL) {
        UsbhExFreePool(level_0);
        level_0 = NULL;
    }

    if (localDeviceInfo != NULL) {
        if (need > DeviceInformationLength) {
            // return what we can
            RtlCopyMemory(DeviceInformation,
                          localDeviceInfo,
                          DeviceInformationLength);

            ntStatus = STATUS_BUFFER_TOO_SMALL;
        } else {
            // return what is appropriate
            RtlCopyMemory(DeviceInformation,
                          localDeviceInfo ,
                          need);
        }

        UsbhExFreePool(localDeviceInfo);
        localDeviceInfo = NULL;
    }

    return ntStatus;
}


//ULONG
//USBD_GetHackFlags(
//    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
//    )
//{
//    NTSTATUS ntStatus;
//    ULONG flags;
//    PUSB_HUB_BUS_INTERFACE busIf;
//
//    busIf = &DeviceExtensionHub->BusIf;
//
//    // flags are currently not used by usb2 stack
//
//    ntStatus = busIf->GetPortHackFlags(busIf->BusContext, &flags);
//
//    return flags;
//}


NTSTATUS
USBD_MakePdoNameEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PUNICODE_STRING PdoNameUnicodeString,
    IN ULONG Index
    )
/*++

Routine Description:

    This service Creates a name for a PDO created by the HUB

Arguments:

Return Value:


--*/
{
    PWCHAR nameBuffer = NULL;
    WCHAR rootName[] = L"\\Device\\USBPDO-";
    UNICODE_STRING idUnicodeString;
    WCHAR buffer[32];
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USHORT length;

    length = sizeof(buffer)+sizeof(rootName);

    //
    // use ExAllocate because client will free it
    //
    nameBuffer = UsbhExAllocatePool(PagedPool, length);

    if (nameBuffer) {
        RtlCopyMemory(nameBuffer, rootName, sizeof(rootName));

        RtlInitUnicodeString(PdoNameUnicodeString,
                             nameBuffer);
        PdoNameUnicodeString->MaximumLength =
            length;

        RtlInitUnicodeString(&idUnicodeString,
                             &buffer[0]);
        idUnicodeString.MaximumLength =
            sizeof(buffer);

        ntStatus = RtlIntegerToUnicodeString(
                  Index,
                  10,
                  &idUnicodeString);

        if (NT_SUCCESS(ntStatus)) {
             ntStatus = RtlAppendUnicodeStringToString(PdoNameUnicodeString,
                                                       &idUnicodeString);
        }

        USBH_KdPrint((2, "'USBD_MakeNodeName string = %x\n",
            PdoNameUnicodeString));

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(ntStatus) && nameBuffer) {
        UsbhExFreePool(nameBuffer);
    }

    return ntStatus;
}


NTSTATUS
USBD_RestoreDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PUSB_DEVICE_HANDLE OldDeviceData,
    IN OUT PUSB_DEVICE_HANDLE NewDeviceData,
    IN PDEVICE_OBJECT RootHubPdo
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->RestoreUsbDevice) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->RestoreUsbDevice(busIf->BusContext,
                                        OldDeviceData,
                                        NewDeviceData);
    }

    return ntStatus;
}


NTSTATUS
USBD_QuerySelectiveSuspendEnabled(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PBOOLEAN SelectiveSuspendEnabled
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;
    USB_CONTROLLER_INFORMATION_0 controllerInfo;
    ULONG dataLen = 0;

    controllerInfo.InformationLevel = 0;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->GetControllerInformation) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->GetControllerInformation(busIf->BusContext,
                                                &controllerInfo,
                                                sizeof(controllerInfo),
                                                &dataLen);
    }

    USBH_ASSERT(dataLen);

    if (dataLen) {
        *SelectiveSuspendEnabled = controllerInfo.SelectiveSuspendEnabled;
    }

    return ntStatus;
}


VOID 
USBHUB_RhHubCallBack(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
{
    DeviceExtensionHub->HubFlags |= HUBFLAG_OK_TO_ENUMERATE;

    // if irp is null'ed out then it must have been stopped or removed before 
    // our callback   we just check for NULL here instead of the dozen or so 
    // flags the hub has.
    if (DeviceExtensionHub->Irp != NULL) {
    
        USBH_SubmitInterruptTransfer(DeviceExtensionHub);

        USBH_IoInvalidateDeviceRelations(DeviceExtensionHub->PhysicalDeviceObject,
                                         BusRelations);
    }                                                 
}


NTSTATUS
USBD_RegisterRhHubCallBack(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->RootHubInitNotification) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->RootHubInitNotification(busIf->BusContext,
                                             DeviceExtensionHub,
                                             USBHUB_RhHubCallBack);
    }

    return ntStatus;
}


NTSTATUS
USBD_UnRegisterRhHubCallBack(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->RootHubInitNotification) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->RootHubInitNotification(busIf->BusContext,
                                             NULL,
                                             NULL);
    }

    return ntStatus;
}


NTSTATUS
USBD_SetSelectiveSuspendEnabled(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN BOOLEAN SelectiveSuspendEnabled
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->ControllerSelectiveSuspend) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->ControllerSelectiveSuspend(busIf->BusContext,
                                                    SelectiveSuspendEnabled);
    }

    return ntStatus;
}


BOOLEAN
USBH_ValidateConfigurationDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    USBD_STATUS *UsbdStatus
    )
/*++

Routine Description:

    Validate a configuration descriptor

Arguments:

    ConfigurationDescriptor -

    Urb -

Return Value:

    TRUE if it looks valid

--*/
{
    BOOLEAN valid = TRUE;

    if (ConfigurationDescriptor->bDescriptorType !=
        USB_CONFIGURATION_DESCRIPTOR_TYPE) {

        valid = FALSE;

        *UsbdStatus = USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR;
    }

    // USB 1.1, Section 9.5 Descriptors:
    //
    // If a descriptor returns with a value in its length field that is
    // less than defined by this specification, the descriptor is invalid and
    // should be rejected by the host.  If the descriptor returns with a
    // value in its length field that is greater than defined by this
    // specification, the extra bytes are ignored by the host, but the next
    // descriptor is located using the length returned rather than the length
    // expected.

    if (ConfigurationDescriptor->bLength <
        sizeof(USB_CONFIGURATION_DESCRIPTOR)) {

        valid = FALSE;

        *UsbdStatus = USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR;
    }

    return valid;

}


NTSTATUS
USBHUB_GetBusInterfaceUSBDI(
    IN PDEVICE_OBJECT HubPdo,
    IN PUSB_BUS_INTERFACE_USBDI_V2 BusInterface
    )
/*++

Routine Description:

Arguments:

Return Value:

    returns success if USB2 stack

--*/
{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    irp = IoAllocateIrp(HubPdo->StackSize, FALSE);

    if (!irp) {
        return STATUS_UNSUCCESSFUL;
    }

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED.
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           USBD_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_INTERFACE;

    // init busif
    //busIf->
    nextStack->Parameters.QueryInterface.Interface = (PINTERFACE) BusInterface;
    // this is the device handle, filled in as we pass down the 
    // stack
    nextStack->Parameters.QueryInterface.InterfaceSpecificData =
        NULL;
    nextStack->Parameters.QueryInterface.InterfaceType =
        &USB_BUS_INTERFACE_USBDI_GUID;
    nextStack->Parameters.QueryInterface.Size =
        sizeof(*BusInterface);
    nextStack->Parameters.QueryInterface.Version =
        USB_BUSIF_USBDI_VERSION_2;

    ntStatus = IoCallDriver(HubPdo,
                            irp);

    if (ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);

        ntStatus = irp->IoStatus.Status;
    }

    if (NT_SUCCESS(ntStatus)) {
        // we have a bus interface

        ASSERT(BusInterface->Version == USB_BUSIF_USBDI_VERSION_2);
        ASSERT(BusInterface->Size == sizeof(*BusInterface));

    }

    IoFreeIrp(irp);
    // get the bus interface

    return ntStatus;
}


NTSTATUS
USBHUB_GetBusInfoDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PUSB_BUS_NOTIFICATION BusInfo
    )
/*++

Routine Description:

    Return the bus information relative to a specific device
    
Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;
    PVOID busContext;

    busIf = &DeviceExtensionHub->BusIf;

    busContext = busIf->GetDeviceBusContext(busIf->BusContext,
                                            DeviceExtensionPort->DeviceData);
                                  
    // get the TT handle for this device and query the 
    // bus information relative to it

    ntStatus = USBHUB_GetBusInfo(DeviceExtensionHub,
                      BusInfo,
                      busContext);
                      
    return ntStatus;
}


NTSTATUS
USBHUB_GetBusInfo(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_BUS_NOTIFICATION BusInfo,
    IN PVOID BusContext
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PUSB_BUS_INFORMATION_LEVEL_1 level_1;
    PUSB_BUS_INTERFACE_USBDI_V2 busIf;
    ULONG length, actualLength;
    NTSTATUS ntStatus;

    busIf = &DeviceExtensionHub->UsbdiBusIf;

    if (!busIf->QueryBusInformation) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
        return ntStatus;
    }

    length = sizeof(USB_BUS_INFORMATION_LEVEL_1);

    do {
        level_1 = UsbhExAllocatePool(PagedPool, length);
        if (level_1 != NULL) {
            if (BusContext == NULL) {
                BusContext = busIf->BusContext;
            }                
        
            ntStatus = busIf->QueryBusInformation(BusContext,
                                                  1,
                                                  level_1,
                                                  &length,
                                                  &actualLength);

            if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                length = actualLength;
                UsbhExFreePool(level_1);
                level_1 = NULL;
            }
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

    } while (ntStatus == STATUS_BUFFER_TOO_SMALL);

    if (NT_SUCCESS(ntStatus)) {

        LOGENTRY(LOG_PNP, "lev1", level_1, 0, 0);

        BusInfo->TotalBandwidth = level_1->TotalBandwidth;
        BusInfo->ConsumedBandwidth = level_1->ConsumedBandwidth;

        /* length of the UNICODE symbolic name (in bytes) for the controller
           that this device is attached to.
           not including NULL */
        BusInfo->ControllerNameLength = level_1->ControllerNameLength;
        UsbhExFreePool(level_1);
    }

    return ntStatus;
}


NTSTATUS
USBHUB_GetExtendedHubInfo(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_EXTHUB_INFORMATION_0 ExtendedHubInfo
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;
    PVOID busContext;
    ULONG length;

    busIf = &DeviceExtensionHub->BusIf;
    
    ntStatus = busIf->GetExtendedHubInformation(busIf->BusContext,
                                                DeviceExtensionHub->PhysicalDeviceObject,
                                                ExtendedHubInfo,
                                                sizeof(*ExtendedHubInfo),
                                                &length);
                                  
    return ntStatus;
}


PUSB_DEVICE_HANDLE
USBH_SyncGetDeviceHandle(
    IN PDEVICE_OBJECT DeviceObject
    )
 /* ++
  *
  * Routine Description:
  *
  * Arguments:
  *
  * Return Value:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
    PUSB_DEVICE_HANDLE handle = NULL;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_SyncGetDeviceHandle\n"));

    //
    // issue a synchronous request to the RootHubBdo
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,  // INTERNAL
                                         &event,
                                         &ioStatus);

    if (NULL == irp) {
        goto USBH_SyncGetDeviceHandle_Done;
    }
    //
    // Call the class driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    //
    // pass the URB to the USBD 'class driver'
    //
    nextStack->Parameters.Others.Argument1 =  &handle;

    ntStatus = IoCallDriver(DeviceObject, irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
        USBH_KdPrint((2,"'Wait for single object\n"));

        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));
    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    USBH_KdPrint((2,"'exit USBH_SyncGetDeviceHandle (%x)\n", ntStatus));

USBH_SyncGetDeviceHandle_Done:

    return handle;
}


USB_DEVICE_TYPE
USBH_GetDeviceType(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_DEVICE_HANDLE DeviceData
    )
/*
    This function maps the new port service on to the
    old hub api.
*/
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;
    ULONG length, lengthCopied;
    ULONG i, need;
    PUSB_DEVICE_INFORMATION_0 level_0 = NULL;
    // if all else fails assum it is 11
    USB_DEVICE_TYPE deviceType = Usb11Device;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->QueryDeviceInformation) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
        return ntStatus;
    }

    length = sizeof(*level_0);

    do {
        ntStatus = STATUS_SUCCESS;

        level_0 = UsbhExAllocatePool(PagedPool, length);
        if (level_0 == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (NT_SUCCESS(ntStatus)) {
            level_0->InformationLevel = 0;

            ntStatus = busIf->QueryDeviceInformation(busIf->BusContext,
                                                     DeviceData,
                                                     level_0,
                                                     length,
                                                     &lengthCopied);

            if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                length = level_0->ActualLength;
                UsbhExFreePool(level_0);
            }
        }

    } while (ntStatus == STATUS_BUFFER_TOO_SMALL);

    // do we have enough to satisfiy the API?

    need = level_0->NumberOfOpenPipes * sizeof(USB_PIPE_INFO) +
            sizeof(USB_NODE_CONNECTION_INFORMATION);

    if (NT_SUCCESS(ntStatus)) {
        deviceType = level_0->DeviceType;
    }

    if (level_0 != NULL) {
        UsbhExFreePool(level_0);
        level_0 = NULL;
    }

    USBH_KdPrint((2,"'exit USBH_GetDeviceType (%x)\n", deviceType));

    return deviceType;
}


VOID
USBH_InitializeUSB2Hub(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS            ntStatus;
    PUSB_DEVICE_HANDLE  hubDeviceHandle;

    // NOTE: if we are running on the old 1.1 stack a NULL
    // is returned
    hubDeviceHandle =
        USBH_SyncGetDeviceHandle(DeviceExtensionHub->TopOfStackDeviceObject);

    // if we are a USB 2 hub then set the hub flag so we ignore
    // failed resets
    if (hubDeviceHandle != NULL &&
        USBH_GetDeviceType(DeviceExtensionHub,
                           hubDeviceHandle) == Usb20Device) {

        DeviceExtensionHub->HubFlags |= HUBFLAG_USB20_HUB;
    }

#ifdef TEST_2X_UI
    if (IS_ROOT_HUB(DeviceExtensionHub)) {
        // To test the UI, mark the root hub as 2.x capable.
        DeviceExtensionHub->HubFlags |= HUBFLAG_USB20_HUB;
    }
#endif

}

NTSTATUS
USBHUB_GetControllerName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_HUB_NAME Buffer,
    IN ULONG BufferLength
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PUSB_BUS_INFORMATION_LEVEL_1 level_1;
    PUSB_BUS_INTERFACE_USBDI_V2 busIf;
    ULONG lenToCopy, length, actualLength;
    NTSTATUS ntStatus;

    busIf = &DeviceExtensionHub->UsbdiBusIf;

    if (!busIf->QueryBusInformation) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
        return ntStatus;
    }

    length = sizeof(USB_BUS_INFORMATION_LEVEL_1);

    do {
        level_1 = UsbhExAllocatePool(PagedPool, length);
        if (level_1 != NULL) {
            ntStatus = busIf->QueryBusInformation(busIf->BusContext,
                                                  1,
                                                  level_1,
                                                  &length,
                                                  &actualLength);

            if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                length = actualLength;
                UsbhExFreePool(level_1);
                level_1 = NULL;
            }
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

    } while (ntStatus == STATUS_BUFFER_TOO_SMALL);

    if (NT_SUCCESS(ntStatus)) {

        LOGENTRY(LOG_PNP, "lev1", level_1, 0, 0);

        // not sure if BufferLength includes size of the
        // ActualLength field, we will assume it does
        Buffer->ActualLength = level_1->ControllerNameLength;

        if ((BufferLength - sizeof(Buffer->ActualLength))
            >= level_1->ControllerNameLength) {
            lenToCopy = level_1->ControllerNameLength;
        } else {
            lenToCopy = BufferLength - sizeof(Buffer->ActualLength);
        }

        // copy what we can
        RtlCopyMemory(&Buffer->HubName[0],
                      &level_1->ControllerNameUnicodeString[0],
                      lenToCopy);

        UsbhExFreePool(level_1);
    }

    return ntStatus;
}


NTSTATUS
USBHUB_GetRootHubName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PVOID Buffer,
    IN PULONG BufferLength
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->GetRootHubSymbolicName) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        ntStatus = busIf->GetRootHubSymbolicName(
                            busIf->BusContext,
                            Buffer,
                            *BufferLength,
                            BufferLength);
    }

    return ntStatus;
}


VOID
USBHUB_FlushAllTransfers(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
{
    NTSTATUS ntStatus;
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    if (!busIf->FlushTransfers) {
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_ASSERT(FALSE);
    } else {
        busIf->FlushTransfers(busIf->BusContext,
                              NULL);
    }

    return;
}


VOID
USBHUB_SetDeviceHandleData(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    PDEVICE_OBJECT PdoDeviceObject,
    PVOID DeviceData 
    )
{
    PUSB_HUB_BUS_INTERFACE busIf;

    busIf = &DeviceExtensionHub->BusIf;

    // associate this PDO with the device handle
    // (if we can)
    if (!busIf->SetDeviceHandleData) {
        USBH_ASSERT(FALSE);
    } else { 
        busIf->SetDeviceHandleData(busIf->BusContext,
                                   DeviceData,
                                   PdoDeviceObject);
    }                                           

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\filter\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, CallNextDriverSync)
        #pragma alloc_text(PAGE, CallDriverSync)
        #pragma alloc_text(PAGE, QueryDeviceKey)
        #pragma alloc_text(PAGE, RegistryAccessSample)
#endif


NTSTATUS CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

        Pass the IRP down to the next device object in the stack
        synchronously, and bump the pendingActionCount around
        the call to prevent the current device object from getting
        removed before the IRP completes.

Arguments:

    devExt - device extension of one of our device objects
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    IncrementPendingActionCount(devExt);
    status = CallDriverSync(devExt->topDevObj, irp);
    DecrementPendingActionCount(devExt);

    return status;
}



NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp)
/*++

Routine Description:

      Call IoCallDriver to send the irp to the device object;
      then, synchronize with the completion routine.
      When CallDriverSync returns, the action has completed
      and the irp again belongs to the current driver.

      NOTE:  In order to keep the device object from getting freed
             while this IRP is pending, you should call
             IncrementPendingActionCount() and 
             DecrementPendingActionCount()
             around the CallDriverSync call.

Arguments:

    devObj - targetted device object
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( irp, 
                            CallDriverSyncCompletion, 
                            &event,     // context
                            TRUE, TRUE, TRUE);

    status = IoCallDriver(devObj, irp);

    KeWaitForSingleObject(  &event,
                            Executive,      // wait reason
                            KernelMode,
                            FALSE,          // not alertable
                            NULL );         // no timeout

    status = irp->IoStatus.Status;

    ASSERT(NT_SUCCESS(status));

    return status;
}


NTSTATUS CallDriverSyncCompletion(
                                    IN PDEVICE_OBJECT devObjOrNULL, 
                                    IN PIRP irp, 
                                    IN PVOID context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    devObjOrNULL - 
            Usually, this is this driver's device object.
             However, if this driver created the IRP, 
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync. 

    
Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PKEVENT event = context;

    ASSERT(irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Increment the pendingActionCount for a device object.
      This keeps the device object from getting freed before
      the action is completed.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedIncrement(&devExt->pendingActionCount);    
}



VOID DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Decrement the pendingActionCount for a device object.
      This is called when an asynchronous action is completed
      AND ALSO when we get the REMOVE_DEVICE IRP.
      If the pendingActionCount goes to -1, that means that all
      actions are completed and we've gotten the REMOVE_DEVICE IRP;
      in this case, set the removeEvent event so we can finish
      unloading.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedDecrement(&devExt->pendingActionCount);    

    if (devExt->pendingActionCount < 0){
        /*
         *  All pending actions have completed and we've gotten
         *  the REMOVE_DEVICE IRP.
         *  Set the removeEvent so we'll stop waiting on REMOVE_DEVICE.
         */
        ASSERT((devExt->state == STATE_REMOVING) || 
               (devExt->state == STATE_REMOVED));
        KeSetEvent(&devExt->removeEvent, 0, FALSE);
    }
}


NTSTATUS
QueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    )
/*++

Routine Description:

    Retrieve the data associated with a specified registry value.

Arguments:

    Handle - handle of key for which value entry is to be read
    ValueNameString - name of value whose data is to be retrieved
    Data - buffer to receive the data
    DataLength - length of data buffer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    ULONG           length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    PAGED_CODE();

    RtlInitUnicodeString (&valueName, ValueNameString);

    length = sizeof (KEY_VALUE_FULL_INFORMATION)
           + valueName.MaximumLength
           + DataLength;

    fullInfo = ExAllocatePool (PagedPool, length);

    if (fullInfo) {
        status = ZwQueryValueKey (Handle,
                                  &valueName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS (status)) {
            ASSERT (DataLength == fullInfo->DataLength);
            RtlCopyMemory (Data,
                           ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                           fullInfo->DataLength);
        }

        ExFreePool (fullInfo);
    } else {
        status = STATUS_NO_MEMORY;
    }

    return status;
}


VOID RegistryAccessSample(struct DEVICE_EXTENSION *devExt,
                          PDEVICE_OBJECT devObj)
/*++

Routine Description:

    SAMPLE showing how to access the device-specific registry key 

Arguments:

    devExt - device extension (for our _filter_ device object)
    devObj - device object pointer
             NOTE: This must not be the functional device object
                   created by this filter driver, because that
                   device object does not have a devnode area
                   in the registry; pass the device object of
                   the device object for which this driver is
                   a filter.  This is the device object passed
                   to VA_AddDevice.

Return Value:

    VOID

--*/
{
    NTSTATUS status;
    HANDLE hRegDevice;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(   devObj, 
                                        PLUGPLAY_REGKEY_DEVICE, 
                                        KEY_READ, 
                                        &hRegDevice);

    if (NT_SUCCESS(status)){
        ULONG value, otherValue;

        if (NT_SUCCESS(QueryDeviceKey( hRegDevice,
                                       L"SampleFilterParam",
                                       &value,
                                       sizeof(value)))) {
            //
            // Perform whatever operation is necessary 
            //
        }

        if (NT_SUCCESS(QueryDeviceKey( hRegDevice,
                                       L"SampleFilterParam2",
                                       &otherValue,
                                       sizeof(otherValue)))) {
            //
            // Perform whatever operation is necessary 
            //
        }

        ZwClose(hRegDevice);
    }
    else {
        DBGOUT(("IoOpenDeviceRegistryKey failed with %xh.", status));
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\bulkusb\sys\bulkwmi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bulkwmi.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _BULKUSB_WMI_H
#define _BULKUSB_WMI_H

NTSTATUS
BulkUsb_WmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
BulkUsb_WmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
BulkUsb_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
BulkUsb_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo	    
    );

NTSTATUS
BulkUsb_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
BulkUsb_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
BulkUsb_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    );

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\filter\filter.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    filter.h

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/


//
// If this driver is going to be a filter in the paging, hibernation, or dump
// file path, then HANDLE_DEVICE_USAGE should be defined.
//
// #define HANDLE_DEVICE_USAGE 1

enum deviceState {
        STATE_INITIALIZED,
        STATE_STARTING,
        STATE_STARTED,
        STATE_START_FAILED,
        STATE_STOPPED,  // implies device was previously started successfully
        STATE_SUSPENDED,
        STATE_REMOVING,
        STATE_REMOVED
};


/*
 *  Memory tag for memory blocks allocated by this driver
 *  (used in ExAllocatePoolWithTag() call).
 *  This DWORD appears as "Filt" in a little-endian memory byte dump.
 *
 *  NOTE:  PLEASE change this value to be unique for your driver!  Otherwise,
 *  your allocations will show up with every other driver that uses 'tliF' as
 *  an allocation tag.
 *  
 */
#define FILTER_TAG (ULONG)'tliF'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, FILTER_TAG)



#define DEVICE_EXTENSION_SIGNATURE 'rtlF'

typedef struct DEVICE_EXTENSION {

    /*
     *  Memory signature of a device extension, for debugging.
     */
    ULONG signature;

    /*
     *  Plug-and-play state of this device object.
     */
    enum deviceState state;

    /*
     *  The device object that this filter driver created.
     */
    PDEVICE_OBJECT filterDevObj;

    /*
     *  The device object created by the next lower driver.
     */
    PDEVICE_OBJECT physicalDevObj;

    /*
     *  The device object at the top of the stack that we attached to.
     *  This is often (but not always) the same as physicalDevObj.
     */
    PDEVICE_OBJECT topDevObj;

    /*
     *  deviceCapabilities includes a
     *  table mapping system power states to device power states.
     */
    DEVICE_CAPABILITIES deviceCapabilities;

    /*
     *  pendingActionCount is used to keep track of outstanding actions.
     *  removeEvent is used to wait until all pending actions are
     *  completed before complete the REMOVE_DEVICE IRP and let the
     *  driver get unloaded.
     */
    LONG pendingActionCount;
    KEVENT removeEvent;

#ifdef HANDLE_DEVICE_USAGE
    /*
     *  Keep track of the number of paging/hibernation/crashdump
     *  files that are opened on this device.
     */
    ULONG  pagingFileCount, hibernationFileCount, crashdumpFileCount;
    KEVENT deviceUsageNotificationEvent;
    PVOID  pagingPathUnlockHandle;  /* handle to lock certain code as non-pageable */

    /*
     *  Also, might need to lock certain driver code as non-pageable, based on
     *  initial conditions (as opposed to paging-file considerations).
     */
    PVOID  initUnlockHandle;
    ULONG  initialFlags;
#endif // HANDLE_DEVICE_USAGE 

};




#if DBG
    #define DBGOUT(params_in_parentheses)   \
        {                                               \
            DbgPrint("'FILTER> "); \
            DbgPrint params_in_parentheses; \
            DbgPrint("\n"); \
        }
    #define TRAP(msg)  \
        {   \
            DBGOUT(("TRAP at file %s, line %d: '%s'.", __FILE__, __LINE__, msg)); \
            DbgBreakPoint(); \
        }
#else
    #define DBGOUT(params_in_parentheses)
    #define TRAP(msg)
#endif


/*
 *  Function externs
 */
NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS    VA_AddDevice(IN PDRIVER_OBJECT driverObj, IN PDEVICE_OBJECT pdo);
VOID        VA_DriverUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS    VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp);
#ifdef HANDLE_DEVICE_USAGE
NTSTATUS    VA_DeviceUsageNotification(struct DEVICE_EXTENSION *devExt, PIRP irp);
#endif // HANDLE_DEVICE_USAGE 
NTSTATUS    VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_PowerComplete(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS    GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt);
NTSTATUS    CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);
NTSTATUS    CallDriverSyncCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID Context);
VOID        IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
NTSTATUS    QueryDeviceKey(HANDLE Handle, PWCHAR ValueNameString, PVOID Data, ULONG DataLength);
VOID        RegistryAccessSample(struct DEVICE_EXTENSION *devExt, PDEVICE_OBJECT devObj);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\filter\power.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    power.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
    #ifdef HANDLE_DEVICE_USAGE
        #pragma alloc_text(PAGEPOWR, VA_Power)
    #endif // HANDLE_DEVICE_USAGE
#endif


NTSTATUS VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for Power IRPs (MajorFunction == IRP_MJ_Power)


    Note:
        If HANDLE_DEVICE_USAGE is defined     
     
           This function may or may not be locked down, depending on the lower
           device object and if the device is in the paging path, so we can't
           use the PAGED_CODE() macro.  Furthermore, we can't use PagedPool. 
           
        Otherwise

            This function is left locked down.        

Arguments:

    devExt - device extension for targetted device object
    irp - Io Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(("VA_Power, minorFunc = %d ", (ULONG)irpSp->MinorFunction)); 


    switch (irpSp->MinorFunction){

        case IRP_MN_SET_POWER:

            switch (irpSp->Parameters.Power.Type) {

                case SystemPowerState:
                    /*
                     *  For system power states, just pass the IRP down.
                     */
                    break;

                case DevicePowerState:

                    switch (irpSp->Parameters.Power.State.DeviceState) {

                        case PowerDeviceD0:
                            /*
                             *  Resume from APM Suspend
                             *
                             *  Do nothing here; 
                             *  Send down the read IRPs in the completion
                             *  routine for this (the power) IRP.
                             */
                            break;

                        case PowerDeviceD1:
                        case PowerDeviceD2:
                        case PowerDeviceD3:
                            /*
                             *  Suspend
                             */
                            if (devExt->state == STATE_STARTED){
                                devExt->state = STATE_SUSPENDED;
                            }
                            break;

                    }
                    break;

            }
            break;

    }


    /*
     *  Send the IRP down the driver stack,
     *  using PoCallDriver (not IoCallDriver, as for non-power irps).
     */
    IncrementPendingActionCount(devExt);
    IoCopyCurrentIrpStackLocationToNext(irp);
    IoSetCompletionRoutine( irp, 
                            VA_PowerComplete, 
                            (PVOID)devExt,  // context
                            TRUE, 
                            TRUE, 
                            TRUE);
    status = PoCallDriver(devExt->topDevObj, irp);

    return status;
}


NTSTATUS VA_PowerComplete(
                            IN PDEVICE_OBJECT devObj, 
                            IN PIRP irp, 
                            IN PVOID context)
/*++

Routine Description:

      Completion routine for Power IRPs (MajorFunction == IRP_MJ_Power)

Arguments:

    devObj - targetted device object
    irp - Io Request Packet
    context - context value passed to IoSetCompletionRoutine by VA_Power

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    struct DEVICE_EXTENSION *devExt = (struct DEVICE_EXTENSION *)context;

    ASSERT(devExt);
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE); 

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also.
     */
    if (irp->PendingReturned){
        IoMarkIrpPending(irp);
    }

    irpSp = IoGetCurrentIrpStackLocation(irp);
    ASSERT(irpSp->MajorFunction == IRP_MJ_POWER);

    if (NT_SUCCESS(irp->IoStatus.Status)){
        switch (irpSp->MinorFunction){

            case IRP_MN_SET_POWER:

                switch (irpSp->Parameters.Power.Type){

                    case DevicePowerState:
                        switch (irpSp->Parameters.Power.State.DeviceState){
                            case PowerDeviceD0:
                                if (devExt->state == STATE_SUSPENDED){
                                    devExt->state = STATE_STARTED;
                                }
                                break;
                        }
                        break;

                }
                break;
        }

    }
    
    
    /*
     *  Whether we are completing or relaying this power IRP,
     *  we must call PoStartNextPowerIrp.
     */
    PoStartNextPowerIrp(irp);

    /*
     *  Decrement the pendingActionCount, which we incremented in VA_Power.
     */
    DecrementPendingActionCount(devExt);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\hub.pnp\hubpwr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    HUBPWR.C

Abstract:

    This module contains functions to handle power irps
    to the hub PDOs and FDOs.

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    7-1-97 : created

--*/

#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */
#include "usbhub.h"

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBH_SetPowerD0)
#pragma alloc_text(PAGE, USBH_SetPowerD1orD2)
#pragma alloc_text(PAGE, USBH_PdoSetPower)
#pragma alloc_text(PAGE, USBH_PdoPower)
#pragma alloc_text(PAGE, USBH_IdleCompletePowerHubWorker)
#pragma alloc_text(PAGE, USBH_CompletePortIdleIrpsWorker)
#pragma alloc_text(PAGE, USBH_CompletePortWakeIrpsWorker)
#pragma alloc_text(PAGE, USBH_HubAsyncPowerWorker)
#pragma alloc_text(PAGE, USBH_IdleCancelPowerHubWorker)
#endif
#endif


VOID
USBH_CompletePowerIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN NTSTATUS NtStatus)
 /* ++
  *
  * Description:
  *
  * This function complete the specified Irp with no priority boost. It also
  * sets up the IoStatusBlock.
  *
  * Arguments:
  *
  * Irp - the Irp to be completed by us NtStatus - the status code we want to
  * return
  *
  * Return:
  *
  * None
  *
  * -- */
{
    Irp->IoStatus.Status = NtStatus;

    PoStartNextPowerIrp(Irp);

    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return;
}


NTSTATUS
USBH_SetPowerD3(
    IN PIRP Irp,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
/*++

Routine Description:

    Put the PDO in D3

Arguments:

    DeviceExtensionPort - port PDO deviceExtension

    Irp - Power Irp.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;
    KIRQL irql;
    PIRP hubWaitWake = NULL;
    LONG pendingPortWWs;
    PIRP idleIrp = NULL;
    PIRP waitWakeIrp = NULL;

    USBH_KdPrint((2,"'PdoSetPower D3\n"));

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    portNumber = DeviceExtensionPort->PortNumber;

    LOGENTRY(LOG_PNP, "spD3", deviceExtensionHub, DeviceExtensionPort->DeviceState, 0);

    if (DeviceExtensionPort->DeviceState == PowerDeviceD3) {
        // already in D3
        USBH_KdPrint((0,"'PDO is already in D3\n"));

        ntStatus = STATUS_SUCCESS;
        goto USBH_SetPowerD3_Done;
    }

    //
    // Keep track of what PNP thinks is the current power state of the
    // port is.  Do this now so that we will refuse another WW IRP that may be
    // posted after the cancel below.
    //

    DeviceExtensionPort->DeviceState = PowerDeviceD3;

    //
    // kill our wait wake irp
    //
    // we take the cancel spinlock here to ensure our cancel routine does
    // not complete the irp for us.
    //

    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionPort->IdleNotificationIrp) {
        idleIrp = DeviceExtensionPort->IdleNotificationIrp;
        DeviceExtensionPort->IdleNotificationIrp = NULL;
        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;

        IoSetCancelRoutine(idleIrp, NULL);

        LOGENTRY(LOG_PNP, "IdlX", deviceExtensionHub, DeviceExtensionPort, idleIrp);
        USBH_KdPrint((1,"'PDO %x going to D3, failing idle notification request IRP %x\n",
                        DeviceExtensionPort->PortPhysicalDeviceObject, idleIrp));
    }

    if (DeviceExtensionPort->PortPdoFlags &
        PORTPDO_REMOTE_WAKEUP_ENABLED) {

        LOGENTRY(LOG_PNP, "cmWW", deviceExtensionHub, DeviceExtensionPort->WaitWakeIrp, 0);

        USBH_KdPrint((1,"'Power state is incompatible with wakeup\n"));

        if (DeviceExtensionPort->WaitWakeIrp) {

            waitWakeIrp = DeviceExtensionPort->WaitWakeIrp;
            DeviceExtensionPort->WaitWakeIrp = NULL;
            DeviceExtensionPort->PortPdoFlags &=
                ~PORTPDO_REMOTE_WAKEUP_ENABLED;

            if (waitWakeIrp->Cancel || IoSetCancelRoutine(waitWakeIrp, NULL) == NULL) {
                waitWakeIrp = NULL;

                // Must decrement pending request count here because
                // we don't complete the IRP below and USBH_WaitWakeCancel
                // won't either because we have cleared the IRP pointer
                // in the device extension above.

                USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
            }

            pendingPortWWs =
                InterlockedDecrement(&deviceExtensionHub->NumberPortWakeIrps);

            if (0 == pendingPortWWs && deviceExtensionHub->PendingWakeIrp) {
                hubWaitWake = deviceExtensionHub->PendingWakeIrp;
                deviceExtensionHub->PendingWakeIrp = NULL;
            }
        }
    }

    //
    // Finally, release the cancel spin lock
    //
    IoReleaseCancelSpinLock(irql);

    if (idleIrp) {
        idleIrp->IoStatus.Status = STATUS_POWER_STATE_INVALID;
        IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
    }

    if (waitWakeIrp) {
        USBH_CompletePowerIrp(deviceExtensionHub, waitWakeIrp,
            STATUS_POWER_STATE_INVALID);
    }

    //
    // If there are no more outstanding WW irps, we need to cancel the WW
    // to the hub.
    //
    if (hubWaitWake) {
        USBH_HubCancelWakeIrp(deviceExtensionHub, hubWaitWake);
    }

    //
    // first suspend the port, this will cause the
    // device to draw minimum power.
    //
    // we don't turn the port off because if we do we
    // won't be able to detect plug/unplug.
    //

    USBH_SyncSuspendPort(deviceExtensionHub,
                         portNumber);

    //
    // note that powering off the port disables connect/disconnect
    // detection by the hub and effectively removes the device from
    // the bus.
    //

    DeviceExtensionPort->PortPdoFlags |= PORTPDO_NEED_RESET;
    RtlCopyMemory(&DeviceExtensionPort->OldDeviceDescriptor,
                  &DeviceExtensionPort->DeviceDescriptor,
                  sizeof(DeviceExtensionPort->DeviceDescriptor));

    USBH_KdPrint((1, "'Setting HU pdo(%x) to D3, status = %x complt\n",
            DeviceExtensionPort->PortPhysicalDeviceObject, ntStatus));

USBH_SetPowerD3_Done:

    USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_HubSetD0Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    PKEVENT pEvent = Context;

    KeSetEvent(pEvent, 1, FALSE);

    ntStatus = IoStatus->Status;

    return ntStatus;
}


NTSTATUS
USBH_HubSetD0(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Set the hub to power state D0

Arguments:

    DeviceExtensionPort - Hub FDO deviceExtension

Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_EXTENSION_HUB rootHubDevExt;
    KEVENT event;
    POWER_STATE powerState;
    NTSTATUS ntStatus;

    rootHubDevExt = USBH_GetRootHubDevExt(DeviceExtensionHub);

    // Skip powering up the hub if the system is not at S0.

    if (rootHubDevExt->CurrentSystemPowerState != PowerSystemWorking) {
        USBH_KdPrint((1,"'HubSetD0, skip power up hub %x because system not at S0\n",
            DeviceExtensionHub));

        return STATUS_INVALID_DEVICE_STATE;
    }

    USBH_KdPrint((1,"'HubSetD0, power up hub %x\n", DeviceExtensionHub));

    LOGENTRY(LOG_PNP, "H!D0", DeviceExtensionHub,
        DeviceExtensionHub->CurrentPowerState,
        rootHubDevExt->CurrentSystemPowerState);

    // If the parent hub is currently in the process of idling out,
    // wait until that is done.

    if (DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_IDLE_IRP) {

        USBH_KdPrint((2,"'Wait for single object\n"));

        ntStatus = KeWaitForSingleObject(&DeviceExtensionHub->SubmitIdleEvent,
                                         Suspended,
                                         KernelMode,
                                         FALSE,
                                         NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", ntStatus));
    }

    // Now, send the actual power up request.

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    powerState.DeviceState = PowerDeviceD0;

    // Power up the hub.
    ntStatus = PoRequestPowerIrp(DeviceExtensionHub->PhysicalDeviceObject,
                                 IRP_MN_SET_POWER,
                                 powerState,
                                 USBH_HubSetD0Completion,
                                 &event,
                                 NULL);

    USBH_ASSERT(ntStatus == STATUS_PENDING);
    if (ntStatus == STATUS_PENDING) {

        USBH_KdPrint((2,"'Wait for single object\n"));

        ntStatus = KeWaitForSingleObject(&event,
                                         Suspended,
                                         KernelMode,
                                         FALSE,
                                         NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", ntStatus));
    }

    return ntStatus;
}


NTSTATUS
USBH_SetPowerD0(
    IN PIRP Irp,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
/*++

Routine Description:

    Put the PDO in D0

Arguments:

    DeviceExtensionPort - port PDO deviceExtension

    Irp - Power Irp.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;
    PPORT_DATA portData;
    PORT_STATE state;

    PAGED_CODE();
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    portNumber = DeviceExtensionPort->PortNumber;
    portData = &deviceExtensionHub->PortData[portNumber - 1];

    USBH_KdPrint((2,"'PdoSetPower D0\n"));
    LOGENTRY(LOG_PNP, "P>D0", deviceExtensionHub, DeviceExtensionPort,
        DeviceExtensionPort->DeviceState);

    if (DeviceExtensionPort->DeviceState == PowerDeviceD3) {

        //
        // device was in D3, port may be off or suspended
        // we will need to reset the port state in any case
        //

        // get port state
        ntStatus = USBH_SyncGetPortStatus(deviceExtensionHub,
                                          portNumber,
                                          (PUCHAR) &state,
                                          sizeof(state));

        // refresh our internal port state.
        portData->PortState = state;

        LOGENTRY(LOG_PNP, "PD0s", deviceExtensionHub, *((PULONG) &state), ntStatus);

        if (NT_SUCCESS(ntStatus)) {

            // port state should be suspended or OFF
            // if the hub was powered off then the port
            // state will be powered but disabled

            if ((state.PortStatus & PORT_STATUS_SUSPEND)) {
                //
                // resume the port if it was suspended
                //
                ntStatus = USBH_SyncResumePort(deviceExtensionHub,
                                               portNumber);

            } else if (!(state.PortStatus & PORT_STATUS_POWER)) {
                //
                // probably some kind of selective OFF by the device
                // driver -- we just need to power on the port
                //
                // this requires a hub with individual port power
                // switching.
                //
                ntStatus = USBH_SyncPowerOnPort(deviceExtensionHub,
                                                portNumber,
                                                TRUE);
            }

        } else {
            // the hub driver will notify thru WMI
            USBH_KdPrint((0, "'Hub failed after power change from D3\n"));
//            USBH_ASSERT(FALSE);
        }

        //
        // if port power switched on this is just like plugging
        // in the device for the first time.

        // NOTE:
        // ** the driver should know that the device needs to be
        // re-initialized since it allowed it's PDO to go in to
        // the D3 state.

        //
        // We always call restore device even though we don't need
        // to if the port was only suspended, we do this so that
        // drivers don't relay on the suspend behavior by mistake.
        //

        if (NT_SUCCESS(ntStatus)) {

            //
            // if we still have a device connected attempt to
            // restore it.
            //
            //
            // Note: we check here to see if the device object still
            // exists in case a change is asserted during the resume.
            //

            // Note also that we now ignore the connect status bit because
            // some machines (e.g. Compaq Armada 7800) are slow to power
            // up the ports on the resume and thus port status can show
            // no device connected when in fact one is.  It shouldn't
            // hurt to try to restore the device if it had been removed
            // during the suspend/hibernate.  In fact, this code handled the
            // case where the device had been swapped for another, so this
            // is really no different.

            if (portData->DeviceObject) {
                //
                // if this fails the device must have changed
                // during power off, in that case we succeed the
                // power on.
                //
                // it will be tossed on the next enumeration
                // and relaced with this new device
                //
                if (USBH_RestoreDevice(DeviceExtensionPort, TRUE) != STATUS_SUCCESS) {
                
                    PDEVICE_OBJECT pdo = portData->DeviceObject;
                    
                    LOGENTRY(LOG_PNP, "PD0!", DeviceExtensionPort, 0, pdo);
                    USBH_KdPrint((1,"'Device appears to have been swapped during power off\n"));
                    USBH_KdPrint((1,"'Marking PDO %x for removal\n", portData->DeviceObject));

                    // leave ref to hub since device data wll need to be 
                    // deleted on remove.
                    portData->DeviceObject = NULL;
                    portData->ConnectionStatus = NoDeviceConnected;

                    // track the Pdo so we no to remove it after we tell PnP it 
                    // is gone
                    // device should be present if we do this
                    USBH_ASSERT(PDO_EXT(pdo)->PnPFlags & PDO_PNPFLAG_DEVICE_PRESENT);
            
                    InsertTailList(&deviceExtensionHub->DeletePdoList, 
                                   &PDO_EXT(pdo)->DeletePdoLink);
                }
            }

            DeviceExtensionPort->DeviceState =
                irpStack->Parameters.Power.State.DeviceState;
        }

    } else if (DeviceExtensionPort->DeviceState == PowerDeviceD2 ||
               DeviceExtensionPort->DeviceState == PowerDeviceD1) {

        // get port state
        ntStatus = USBH_SyncGetPortStatus(deviceExtensionHub,
                                          portNumber,
                                          (PUCHAR) &state,
                                          sizeof(state));

        //
        // if we got an error assume then the hub is hosed
        // just set our flag and bail
        //

        if (NT_SUCCESS(ntStatus)) {
        // see if suspeneded (according to spec). Otherwise only
        // try to resume if the port is really suspended.
        //
            if (state.PortStatus & PORT_STATUS_OVER_CURRENT) {
                //
                // overcurrent condition indicates this port
                // (and hub) are hosed

                ntStatus = STATUS_UNSUCCESSFUL;

            } else if (state.PortStatus & PORT_STATUS_SUSPEND) {

                ntStatus = USBH_SyncResumePort(deviceExtensionHub,
                                               portNumber);

            } else {
                //
                // Most OHCI controllers enable all the ports after a usb
                // resume on any port (in violation of the USB spec), in this
                // case we should detect that the port is no longer in suspend
                // and not try to resume it.
                //
                // Also, if the device where removed while suspended or the HC
                // lost power we should end up here.
                //

                ntStatus = STATUS_SUCCESS;
            }
        } else {
            USBH_KdPrint((0, "'Hub failed after power change from D2/D1\n"));
//            USBH_ASSERT(FALSE);
        }

        //
        // port is now in D0
        //

        DeviceExtensionPort->DeviceState =
            irpStack->Parameters.Power.State.DeviceState;

        USBH_CompletePortIdleNotification(DeviceExtensionPort);

        if (NT_SUCCESS(ntStatus)) {

            if (DeviceExtensionPort->PortPdoFlags &
                PORTPDO_NEED_CLEAR_REMOTE_WAKEUP) {

                NTSTATUS status;

                //
                // disable remote wakeup
                //

                status = USBH_SyncFeatureRequest(DeviceExtensionPort->PortPhysicalDeviceObject,
                                                 USB_FEATURE_REMOTE_WAKEUP,
                                                 0,
                                                 TO_USB_DEVICE,
                                                 TRUE);

                DeviceExtensionPort->PortPdoFlags &=
                    ~PORTPDO_NEED_CLEAR_REMOTE_WAKEUP;
            }
        }
    }

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdPrint((1,"'Set D0 Failure, status = %x\n", ntStatus));

        // we return success to PNP, we will let
        // the driver handle the fact that the
        // device has lost its brains
        //
        // NB: This can result in a redundant suspend request for this port
        // later on.  (Since if we fail here port will remain suspended,
        // but our state will indicate that we are in D0.)

        ntStatus = STATUS_SUCCESS;
    }

    DeviceExtensionPort->DeviceState =
           irpStack->Parameters.Power.State.DeviceState;

    USBH_KdPrint((1, "'Setting HU pdo(%x) to D0, status = %x  complt IRP (%x)\n",
            DeviceExtensionPort->PortPhysicalDeviceObject, ntStatus, Irp));

    USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

    return ntStatus;
}


VOID
USBH_IdleCancelPowerHubWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to power up a hub on completion of an Idle request
  * for the hub.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_PORT_IDLE_POWER_WORK_ITEM workItemIdlePower;
    PIRP irp;

    PAGED_CODE();

    workItemIdlePower = Context;

    USBH_HubSetD0(workItemIdlePower->DeviceExtensionHub);

    irp = workItemIdlePower->Irp;
    irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(irp, IO_NO_INCREMENT);

    USBH_DEC_PENDING_IO_COUNT(workItemIdlePower->DeviceExtensionHub);
    UsbhExFreePool(workItemIdlePower);
}


VOID
USBH_PortIdleNotificationCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:


Arguments:

    DeviceObject -

    Irp - Power Irp.

Return Value:


--*/
{
    PUSBH_PORT_IDLE_POWER_WORK_ITEM workItemIdlePower;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PIRP irpToCancel = NULL;

    USBH_KdPrint((1,"'Idle notification IRP %x cancelled\n", Irp));

    deviceExtensionPort = DeviceObject->DeviceExtension;

    USBH_ASSERT(deviceExtensionPort->IdleNotificationIrp == NULL ||
                deviceExtensionPort->IdleNotificationIrp == Irp);

    deviceExtensionPort->IdleNotificationIrp = NULL;
    deviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;

    deviceExtensionHub = deviceExtensionPort->DeviceExtensionHub;

    if (deviceExtensionHub &&
        deviceExtensionHub->HubFlags & HUBFLAG_PENDING_IDLE_IRP) {
        irpToCancel = deviceExtensionHub->PendingIdleIrp;
        deviceExtensionHub->PendingIdleIrp = NULL;
    } else {
        ASSERT(!deviceExtensionHub->PendingIdleIrp);
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    // Cancel the Idle request to the hub if there is one.
    if (irpToCancel) {
        USBH_HubCancelIdleIrp(deviceExtensionHub, irpToCancel);
    }

    // Also, power up the hub here before we complete this Idle IRP.
    //
    // (HID will start to send requests immediately upon its completion,
    // which may be before the hub's Idle IRP cancel routine is called
    // which powers up the hub.)

    if (deviceExtensionHub->CurrentPowerState != PowerDeviceD0) {

        // Since we are at DPC we must use a work item to power up the
        // hub synchronously, because that function yields and we can't
        // yield at DPC level.

        workItemIdlePower = UsbhExAllocatePool(NonPagedPool,
                                sizeof(USBH_PORT_IDLE_POWER_WORK_ITEM));

        if (workItemIdlePower) {

            workItemIdlePower->DeviceExtensionHub = deviceExtensionHub;
            workItemIdlePower->Irp = Irp;

            ExInitializeWorkItem(&workItemIdlePower->WorkQueueItem,
                                 USBH_IdleCancelPowerHubWorker,
                                 workItemIdlePower);

            LOGENTRY(LOG_PNP, "icIT", deviceExtensionHub,
                &workItemIdlePower->WorkQueueItem, 0);

            USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);
            ExQueueWorkItem(&workItemIdlePower->WorkQueueItem,
                            DelayedWorkQueue);

            // The WorkItem is freed by USBH_IdleCancelPowerHubWorker()
            // Don't try to access the WorkItem after it is queued.
        }

    } else {
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
}


VOID
USBH_CompletePortIdleNotification(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
{
    NTSTATUS status;
    KIRQL irql;
    PIRP irp = NULL;
    PDRIVER_CANCEL oldCancelRoutine;

    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionPort->IdleNotificationIrp) {

        irp = DeviceExtensionPort->IdleNotificationIrp;

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (oldCancelRoutine) {
            USBH_ASSERT(oldCancelRoutine == USBH_PortIdleNotificationCancelRoutine);
            DeviceExtensionPort->IdleNotificationIrp = NULL;
            DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;
        }
#if DBG
        else {
            USBH_ASSERT(irp->Cancel);
        }
#endif
    }

    IoReleaseCancelSpinLock(irql);

    if (irp) {
        USBH_KdPrint((1,"'Completing idle request IRP %x\n", irp));
        irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}


NTSTATUS
USBH_SetPowerD1orD2(
    IN PIRP Irp,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
/*++

Routine Description:

    Put the PDO in D1/D2 ie suspend

Arguments:

    DeviceExtensionPort - port PDO deviceExtension

    Irp - Worker Irp.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    portNumber = DeviceExtensionPort->PortNumber;

    USBH_KdPrint((2,"'PdoSetPower D1/D2\n"));

    if (DeviceExtensionPort->DeviceState == PowerDeviceD1  ||
        DeviceExtensionPort->DeviceState == PowerDeviceD2) {
        return STATUS_SUCCESS;
    }

    //
    // Enable the device for remote wakeup if necessary
    //

    if (DeviceExtensionPort->PortPdoFlags &
        PORTPDO_REMOTE_WAKEUP_ENABLED) {
        NTSTATUS status;

        status = USBH_SyncFeatureRequest(DeviceExtensionPort->PortPhysicalDeviceObject,
                                         USB_FEATURE_REMOTE_WAKEUP,
                                         0,
                                         TO_USB_DEVICE,
                                         FALSE);

        DeviceExtensionPort->PortPdoFlags |= PORTPDO_NEED_CLEAR_REMOTE_WAKEUP;

#if DBG
        // With the new Selective Suspend support, people are complaining
        // about this noise.  Let's display it only if debug trace level
        // is 1 or higher.

        if (USBH_Debug_Trace_Level > 0) {
            UsbhWarning(DeviceExtensionPort,
                        "Device is Enabled for REMOTE WAKEUP\n",
                        FALSE);
        }
#endif

        // what do we do about an error here?
        // perhaps signal the waitwake irp??
    }

    ntStatus = USBH_SyncSuspendPort(deviceExtensionHub,
                                    portNumber);

    //
    // keep track of what OS thinks is the current power state of the
    // the device on this port.
    //

    DeviceExtensionPort->DeviceState =
            irpStack->Parameters.Power.State.DeviceState;

    DeviceExtensionPort->PortPdoFlags |= PORTPDO_USB_SUSPEND;

    USBH_KdPrint((2,"'DeviceExtensionPort->DeviceState = %x\n",
        DeviceExtensionPort->DeviceState));


    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdPrint((1,"'Set D1/D2 Failure, status = %x\n", ntStatus));

        // don't pass an error to PnP
        ntStatus = STATUS_SUCCESS;
    }

    USBH_KdPrint((1, "'Setting HU pdo(%x) to D%d, status = %x complt\n",
            DeviceExtensionPort->PortPhysicalDeviceObject,
            irpStack->Parameters.Power.State.DeviceState - 1,
            ntStatus));

    USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_PdoQueryPower(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  *     Handles a power irp to a hub PDO
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;
    PPORT_DATA portData;
    POWER_STATE powerState;

    PAGED_CODE();
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    USBH_ASSERT( DeviceExtensionPort->PortNumber < 1000);
    portNumber = DeviceExtensionPort->PortNumber;
    portData = &deviceExtensionHub->PortData[portNumber - 1];

    USBH_KdPrint((2,"'USBH_PdoQueryPower pdo(%x)\n", deviceObject));

    switch (irpStack->Parameters.Power.Type) {
    case SystemPowerState:
    {
        //
        // We are currently faced with the decision to fail or allow the
        // transition to the given S power state.  In order to make an
        // informed decision, we must first calculate the maximum amount
        // of D power allowed in the given S state, and then see if this
        // conflicts with a pending Wait Wake IRP.
        //

        //
        // The maximum amount of D power allowed in this S state.
        //
        powerState.DeviceState =
            deviceExtensionHub->DeviceState[irpStack->Parameters.Power.State.SystemState];

        //
        // These tables should have already been fixed up by the root hub
        // (usbd.sys) to not contain an entry of unspecified.
        //
        ASSERT (PowerDeviceUnspecified != powerState.DeviceState);

        //
        // The presence of a pending wait wake irp together with a D state that
        // will not support waking of the machine means we should fail this
        // query.
        //
        // However, if we are going into Hibernate (or power off) then we
        // should not fail this query.
        //
        if (powerState.DeviceState == PowerDeviceD3 &&
            DeviceExtensionPort->WaitWakeIrp &&
            irpStack->Parameters.Power.State.SystemState < PowerSystemHibernate) {

            ntStatus = STATUS_UNSUCCESSFUL;
            USBH_KdPrint(
                (1, "'IRP_MJ_POWER HU pdo(%x) MN_QUERY_POWER Failing Query\n", deviceObject));
        } else {
            ntStatus = STATUS_SUCCESS;
        }

        LOGENTRY(LOG_PNP, "QPWR", DeviceExtensionPort->PortPhysicalDeviceObject,
            irpStack->Parameters.Power.State.SystemState,
            powerState.DeviceState);

        USBH_KdPrint(
        (1, "'IRP_MJ_POWER HU pdo(%x) MN_QUERY_POWER(S%x -> D%x), complt %x\n",
            DeviceExtensionPort->PortPhysicalDeviceObject,
            irpStack->Parameters.Power.State.SystemState - 1,
            powerState.DeviceState - 1,
            ntStatus));

#if DBG
        if (!NT_SUCCESS(ntStatus)) {
            LOGENTRY(LOG_PNP, "QPW!", deviceExtensionHub,
                DeviceExtensionPort->WaitWakeIrp,
                ntStatus);
        }
#endif

        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

        }
        break;

    case DevicePowerState:
        // Return success on this one or NDIS will choke on the suspend.
        ntStatus = STATUS_SUCCESS;
        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
        break;

    default:
        TEST_TRAP();
        ntStatus = STATUS_INVALID_PARAMETER;
        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
    } /* power type */

    return ntStatus;
}


NTSTATUS
USBH_PdoSetPower(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  *     Handles a power irp to a hub PDO
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;
    PPORT_DATA portData;

    PAGED_CODE();
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    USBH_ASSERT( DeviceExtensionPort->PortNumber < 1000);
    portNumber = DeviceExtensionPort->PortNumber;
    portData = &deviceExtensionHub->PortData[portNumber - 1];

    USBH_KdPrint((2,"'USBH_PdoSetPower pdo(%x)\n", deviceObject));

    switch (irpStack->Parameters.Power.Type) {
    case SystemPowerState:
        {
        //
        // see if the current state of this pdo is valid for the
        // system state , if is not then we will need to set the
        // pdo to a valid D state.
        //
        ntStatus = STATUS_SUCCESS;

        USBH_KdPrint(
        (1, "'IRP_MJ_POWER HU pdo(%x) MN_SET_POWER(SystemPowerState S%x), complt\n",
            DeviceExtensionPort->PortPhysicalDeviceObject,
            irpStack->Parameters.Power.State.DeviceState - 1,
            ntStatus));

        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

        }
        break;

    case DevicePowerState:
        USBH_KdPrint(
            (1, "'IRP_MJ_POWER HU pdo(%x) MN_SET_POWER(DevicePowerState D%x)\n",
            DeviceExtensionPort->PortPhysicalDeviceObject,
            irpStack->Parameters.Power.State.DeviceState - 1));
        LOGENTRY(LOG_PNP, "P>Dx", deviceExtensionHub,
             DeviceExtensionPort->PortPhysicalDeviceObject,
             irpStack->Parameters.Power.State.DeviceState);

        // If we are already in the requested power state,
        // just complete the request.

        if (DeviceExtensionPort->DeviceState ==
            irpStack->Parameters.Power.State.DeviceState) {

            // If we are skipping this set power request and it is a SetD0
            // request, assert that the parent hub is in D0.

            USBH_ASSERT(DeviceExtensionPort->DeviceState != PowerDeviceD0 ||
                deviceExtensionHub->CurrentPowerState == PowerDeviceD0);

            ntStatus = STATUS_SUCCESS;
            goto PdoSetPowerCompleteIrp;
        }

//        USBH_ASSERT(deviceExtensionHub->CurrentPowerState == PowerDeviceD0);

        switch (irpStack->Parameters.Power.State.DeviceState) {
        case PowerDeviceD0:
            ntStatus = USBH_SetPowerD0(Irp, DeviceExtensionPort);
            break;
        case PowerDeviceD1:
        case PowerDeviceD2:
            ntStatus = USBH_SetPowerD1orD2(Irp, DeviceExtensionPort);
            break;
        case PowerDeviceD3:
            //
            // In the case of D3 we need to complete any pending WaitWake
            // Irps with the status code STATUS_POWER_STATE_INVALID.
            // This is done in USBH_SetPowerD3.
            //
            ntStatus = USBH_SetPowerD3(Irp, DeviceExtensionPort);
            break;
        default:
            USBH_KdTrap(("Bad Power State\n"));
            ntStatus = STATUS_INVALID_PARAMETER;
            USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
        }
        break;

    default:
        TEST_TRAP();
        ntStatus = STATUS_INVALID_PARAMETER;
PdoSetPowerCompleteIrp:
        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
    } /* power type */

    return ntStatus;
}


VOID
USBH_WaitWakeCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    NTSTATUS ntStatus = STATUS_CANCELLED;
    LONG pendingPortWWs;
    PIRP hubWaitWake = NULL;

    USBH_KdPrint((1,"'WaitWake Irp %x for PDO cancelled\n", Irp));
    USBH_ASSERT(DeviceObject);

    deviceExtensionPort = (PDEVICE_EXTENSION_PORT) Irp->IoStatus.Information;
    deviceExtensionHub = deviceExtensionPort->DeviceExtensionHub;

    LOGENTRY(LOG_PNP, "WWca", Irp, deviceExtensionPort, deviceExtensionHub);

    if (Irp != deviceExtensionPort->WaitWakeIrp) {
        //
        // Nothing to do
        // This Irp has already been taken care of.
        // We are in the process of completing this IRP in
        // USBH_HubCompletePortWakeIrps.
        //
        TEST_TRAP();
        IoReleaseCancelSpinLock(Irp->CancelIrql);

    } else {
        deviceExtensionPort->WaitWakeIrp = NULL;
        deviceExtensionPort->PortPdoFlags &=
                ~PORTPDO_REMOTE_WAKEUP_ENABLED;
        IoSetCancelRoutine(Irp, NULL);

        pendingPortWWs = InterlockedDecrement(&deviceExtensionHub->NumberPortWakeIrps);
        if (0 == pendingPortWWs && deviceExtensionHub->PendingWakeIrp) {
            // Set PendingWakeIrp to NULL since we cancel it below.
            hubWaitWake = deviceExtensionHub->PendingWakeIrp;
            deviceExtensionHub->PendingWakeIrp = NULL;
        }
        IoReleaseCancelSpinLock(Irp->CancelIrql);

        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

        //
        // If there are no more outstanding WW irps, we need to cancel the WW
        // to the hub.
        //

        if (hubWaitWake) {
            USBH_HubCancelWakeIrp(deviceExtensionHub, hubWaitWake);
        }
//        else {
            // This assert is no longer valid as I now clear the PendingWakeIrp
            // pointer for the hub in USBH_FdoWaitWakeIrpCompletion, instead
            // of waiting to do it here when NumberPortWakeIrps reaches zero.
            // So it is completely normal to arrive here with no port wake
            // IRP's and a NULL PendingWakeIrp for the hub.

//            ASSERT (0 < pendingPortWWs);
//        }
    }
}


NTSTATUS
USBH_PdoWaitWake(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;
    PPORT_DATA portData;
    KIRQL irql;
    PDRIVER_CANCEL oldCancel;
    LONG pendingPortWWs = 0;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    USBH_ASSERT( DeviceExtensionPort->PortNumber < 1000);
    portNumber = (USHORT) DeviceExtensionPort->PortNumber;
    portData = &deviceExtensionHub->PortData[portNumber - 1];

    USBH_KdPrint((2,"'PnP WaitWake Irp passed to PDO %x\n", deviceObject));
    LOGENTRY(LOG_PNP, "PWW_", deviceObject, DeviceExtensionPort, deviceExtensionHub);

    if (DeviceExtensionPort->DeviceState != PowerDeviceD0 ||
        deviceExtensionHub->HubFlags & HUBFLAG_DEVICE_STOPPING) {

        LOGENTRY(LOG_PNP, "!WWh", DeviceExtensionPort, deviceExtensionHub, 0);

        UsbhWarning(NULL,
                    "Client driver should not be submitting WW IRPs at this time.\n",
                    TRUE);

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
        return ntStatus;
    }

    //
    // First verify that there is not already a WaitWake Irp pending for
    // this PDO.
    //

    //
    // make sure that this device can support remote wakeup.
    //
    // NOTE: that we treat all hubs as capable of remote
    // wakeup regardless of what the device reports. The reason
    // is that all hubs must propagate resume signalling regardless
    // of their abilty to generate resume signalling on a
    // plug-in/out event.
    //

#if DBG
    if (UsbhPnpTest & PNP_TEST_FAIL_WAKE_REQUEST) {
        DeviceExtensionPort->PortPdoFlags &=
                ~PORTPDO_REMOTE_WAKEUP_SUPPORTED;
    }
#endif

    if (DeviceExtensionPort->PortPdoFlags &
        PORTPDO_REMOTE_WAKEUP_SUPPORTED) {

        IoAcquireCancelSpinLock(&irql);
        if (DeviceExtensionPort->WaitWakeIrp != NULL) {
            LOGENTRY(LOG_PNP, "PWWx", deviceObject, DeviceExtensionPort,
                DeviceExtensionPort->WaitWakeIrp);
            ntStatus = STATUS_DEVICE_BUSY;
            IoReleaseCancelSpinLock(irql);
            USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);

        } else {

            // set a cancel routine
            oldCancel = IoSetCancelRoutine(Irp, USBH_WaitWakeCancel);
            USBH_ASSERT (NULL == oldCancel);

            if (Irp->Cancel) {

                oldCancel = IoSetCancelRoutine(Irp, NULL);

                if (oldCancel) {
                    //
                    // Cancel routine hasn't fired.
                    //
                    ASSERT(oldCancel == USBH_WaitWakeCancel);

                    ntStatus = STATUS_CANCELLED;
                    IoReleaseCancelSpinLock(irql);
                    USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
                } else {
                    //
                    // Cancel routine WAS called
                    //
                    IoMarkIrpPending(Irp);
                    ntStatus = Irp->IoStatus.Status = STATUS_PENDING;
                    IoReleaseCancelSpinLock(irql);
                }

            } else {

                USBH_KdPrint(
                    (1, "'enabling remote wakeup for USB device PDO (%x)\n",
                        DeviceExtensionPort->PortPhysicalDeviceObject));

                // flag this device as "enabled for wakeup"
                DeviceExtensionPort->WaitWakeIrp = Irp;
                DeviceExtensionPort->PortPdoFlags |=
                    PORTPDO_REMOTE_WAKEUP_ENABLED;
                Irp->IoStatus.Information = (ULONG_PTR) DeviceExtensionPort;
                pendingPortWWs =
                    InterlockedIncrement(&deviceExtensionHub->NumberPortWakeIrps);
                IoMarkIrpPending(Irp);
                LOGENTRY(LOG_PNP, "PWW+", DeviceExtensionPort, Irp, pendingPortWWs);
                IoReleaseCancelSpinLock(irql);

                ntStatus = STATUS_PENDING;
            }
        }

        //
        // Now we must enable the hub for wakeup.
        //
        // We may already have a WW IRP pending if this hub were previously
        // selective suspended, but we had to power it back on (USBH_HubSetD0)
        // for a PnP request.  Don't post a new WW IRP if there is already
        // one pending.
        //
        if (ntStatus == STATUS_PENDING && 1 == pendingPortWWs &&
            !(deviceExtensionHub->HubFlags & HUBFLAG_PENDING_WAKE_IRP)) {

            USBH_FdoSubmitWaitWakeIrp(deviceExtensionHub);
        }

    } else {

        ntStatus = STATUS_NOT_SUPPORTED;
        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
    }

    return ntStatus;
}


VOID
USBH_HubAsyncPowerWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to handle a hub ESD failure.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_HUB_ASYNC_POWER_WORK_ITEM context;
    NTSTATUS ntStatus;

    PAGED_CODE();

    context = Context;

    if (context->Irp->PendingReturned) {
        IoMarkIrpPending(context->Irp);
    }

    switch (context->MinorFunction) {

    case IRP_MN_SET_POWER:

        ntStatus = USBH_PdoSetPower(context->DeviceExtensionPort,
                                    context->Irp);
        break;

    case IRP_MN_QUERY_POWER:

        ntStatus = USBH_PdoQueryPower(context->DeviceExtensionPort,
                                      context->Irp);
        break;

    default:
        // Should never get here.
        USBH_ASSERT(FALSE);
    }

    UsbhExFreePool(context);
}


NTSTATUS
USBH_HubAsyncPowerSetD0Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PUSBH_HUB_ASYNC_POWER_WORK_ITEM context;
    NTSTATUS ntStatus, status;

    context = Context;

    ntStatus = IoStatus->Status;

    // We schedule the work item regardless of whether the hub power up
    // request was successful or not.

    ExInitializeWorkItem(&context->WorkQueueItem,
                         USBH_HubAsyncPowerWorker,
                         context);

    LOGENTRY(LOG_PNP, "HAPW", context->DeviceExtensionPort,
        &context->WorkQueueItem, 0);

    // critical saves time on resume
    ExQueueWorkItem(&context->WorkQueueItem,
                    CriticalWorkQueue);

    // The WorkItem is freed by USBH_HubAsyncPowerWorker()
    // Don't try to access the WorkItem after it is queued.

    return ntStatus;
}


NTSTATUS
USBH_PdoPower(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp,
    IN UCHAR MinorFunction
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl Power for the PDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO extension Irp - the request packet
  * uchMinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    POWER_STATE powerState;
    PUSBH_HUB_ASYNC_POWER_WORK_ITEM context;

    PAGED_CODE();
    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;

    USBH_KdPrint((2,"'USBH_PdoPower pdo(%x)\n", deviceObject));

    // special case device removed

    if (deviceExtensionHub == NULL) {
        // if there is no backpointer to the parent hub then there 
        // is a delete/remove comming.  just complete this power 
        // request with success

        USBH_KdPrint((1,"'complete power on orphan Pdo %x\n", deviceObject));
        
        if (MinorFunction == IRP_MN_SET_POWER ||
            MinorFunction == IRP_MN_QUERY_POWER) {
            Irp->IoStatus.Status = ntStatus = STATUS_SUCCESS;

            PoStartNextPowerIrp(Irp);
        } else {
            Irp->IoStatus.Status = ntStatus = STATUS_NOT_SUPPORTED;
        }

        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return ntStatus;
    }

    USBH_ASSERT(deviceExtensionHub);

    // specail case device not in D0

    // one more item pending in the hub
    USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);

    // If the hub has been selectively suspended, then we need to power it up
    // to service QUERY or SET POWER requests.  However, we can't block on
    // this power IRP waiting for the parent hub to power up, so we need to
    // power up the parent hub asynchronously and handle this IRP after the
    // hub power up request has completed.  Major PITA.

    if (deviceExtensionHub->CurrentPowerState != PowerDeviceD0 &&
        (MinorFunction == IRP_MN_SET_POWER ||
         MinorFunction == IRP_MN_QUERY_POWER)) {

        // Allocate buffer for context.

        context = UsbhExAllocatePool(NonPagedPool,
                    sizeof(USBH_HUB_ASYNC_POWER_WORK_ITEM));

        if (context) {
            context->DeviceExtensionPort = DeviceExtensionPort;
            context->Irp = Irp;
            context->MinorFunction = MinorFunction;

            // We'll complete this IRP in the completion routine for the hub's
            // Set D0 IRP.

            IoMarkIrpPending(Irp);

            powerState.DeviceState = PowerDeviceD0;

            // Power up the hub.
            ntStatus = PoRequestPowerIrp(deviceExtensionHub->PhysicalDeviceObject,
                                         IRP_MN_SET_POWER,
                                         powerState,
                                         USBH_HubAsyncPowerSetD0Completion,
                                         context,
                                         NULL);

            // We need to return STATUS_PENDING here because we marked the
            // IRP pending above with IoMarkIrpPending.

            USBH_ASSERT(ntStatus == STATUS_PENDING);

            // In the case where an allocation failed, PoRequestPowerIrp can
            // return a status code other than STATUS_PENDING.  In this case,
            // we need to complete the IRP passed to us, but we still need
            // to return STATUS_PENDING from this routine.

            if (ntStatus != STATUS_PENDING) {
                USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
            }

            ntStatus = STATUS_PENDING;

        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
        }

    } else switch (MinorFunction) {

    case IRP_MN_SET_POWER:

        ntStatus = USBH_PdoSetPower(DeviceExtensionPort, Irp);
        break;

    case IRP_MN_WAIT_WAKE:

        ntStatus = USBH_PdoWaitWake(DeviceExtensionPort, Irp);
        USBH_KdPrint((1, "'IRP_MN_WAIT_WAKE pdo(%x), status = 0x%x\n",
                      DeviceExtensionPort->PortPhysicalDeviceObject, ntStatus));
        break;

    case IRP_MN_QUERY_POWER:

        ntStatus = USBH_PdoQueryPower(DeviceExtensionPort, Irp);
        break;

    default:

        ntStatus = Irp->IoStatus.Status;

        USBH_KdPrint((1, "'IRP_MN_[%d](%x), status = 0x%x (not handled)\n",
            MinorFunction,
            DeviceExtensionPort->PortPhysicalDeviceObject,
            ntStatus));

        USBH_KdBreak(("PdoPower unknown\n"));
        //
        // return the original status passed to us
        //
        USBH_CompletePowerIrp(deviceExtensionHub, Irp, ntStatus);
    }

    USBH_KdPrint((2,"'USBH_PdoPower pdo exit %x\n", ntStatus));

    return ntStatus;
}


VOID
USBH_SetPowerD0Worker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to handle a Set Power D0 IRP for the hub.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_SET_POWER_D0_WORK_ITEM    workItemSetPowerD0;
    PDEVICE_EXTENSION_HUB           deviceExtensionHub;
    PIRP                            irp;
    PPORT_DATA                      portData;
    ULONG                           p, numberOfPorts;
    NTSTATUS                        ntStatus = STATUS_SUCCESS;

    workItemSetPowerD0 = Context;
    deviceExtensionHub = workItemSetPowerD0->DeviceExtensionHub;
    irp = workItemSetPowerD0->Irp;

    USBH_KdPrint((2,"'Hub Set Power D0 work item\n"));
    LOGENTRY(LOG_PNP, "HD0W", deviceExtensionHub, irp, 0);

    // restore the hub from OFF

    // the device has lost its brains, we need to go thru the
    // init process again

    // our ports will be indicating status changes at this
    // point.  We need to flush out any change indications
    // before we re-enable the hub

    // first clear out our port status info

    portData = deviceExtensionHub->PortData;

    if (portData &&
        deviceExtensionHub->HubDescriptor) {

        numberOfPorts = deviceExtensionHub->HubDescriptor->bNumberOfPorts;

        // first clear out our port status info

        for (p = 1;
             p <= numberOfPorts;
             p++, portData++) {

            portData->PortState.PortChange = 0;
            portData->PortState.PortStatus = 0;
        }
        portData = deviceExtensionHub->PortData;

        // power up the hub

        ntStatus = USBH_SyncPowerOnPorts(deviceExtensionHub);

// Probably need to enable this code for Mike Mangum's bug.
//        UsbhWait(500);  // Allow USB storage devices some time to power up.

        // flush out any change indications

        if (NT_SUCCESS(ntStatus)) {
            for (p = 1;
                 p <= numberOfPorts;
                 p++, portData++) {

                if (portData->DeviceObject) {
                    ntStatus = USBH_FlushPortChange(deviceExtensionHub,
                                                    portData->DeviceObject->DeviceExtension);
                    if (NT_ERROR(ntStatus)) {
                        LOGENTRY(LOG_PNP, "flsX", deviceExtensionHub, p,
                                    portData->DeviceObject);
                        USBH_KdPrint((1,"'USBH_FlushPortChange failed!\n"));
                    }
                }
            }
        }

        // Since we just flushed all port changes we now don't
        // know if there were any real port changes (e.g. a
        // device was unplugged).  We must call
        // IoInvalidateDeviceRelations to trigger a QBR
        // so that we can see if the devices are still there.

        USBH_IoInvalidateDeviceRelations(deviceExtensionHub->PhysicalDeviceObject,
                                         BusRelations);
    }

    if (!(deviceExtensionHub->HubFlags &
            HUBFLAG_HUB_STOPPED)) {
        USBH_SubmitInterruptTransfer(deviceExtensionHub);
    }

    // Tell ACPI that we are ready for another power IRP and complete
    // the IRP.

    irp->IoStatus.Status = ntStatus;
    PoStartNextPowerIrp(irp);
    IoCompleteRequest(irp, IO_NO_INCREMENT);

    USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
    UsbhExFreePool(workItemSetPowerD0);
}


NTSTATUS
USBH_PowerIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = Context;
    DEVICE_POWER_STATE oldPowerState;
    PUSBH_SET_POWER_D0_WORK_ITEM workItemSetPowerD0;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ntStatus = Irp->IoStatus.Status;

    USBH_ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);

    LOGENTRY(LOG_PNP, "PwrC", deviceExtensionHub, Irp,
                irpStack->Parameters.Power.State.DeviceState);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    if (NT_SUCCESS(ntStatus)) {
        switch (irpStack->Parameters.Power.State.DeviceState) {
        case PowerDeviceD0:

            oldPowerState = deviceExtensionHub->CurrentPowerState;

            deviceExtensionHub->CurrentPowerState =
               irpStack->Parameters.Power.State.DeviceState;

            deviceExtensionHub->HubFlags &= ~HUBFLAG_SET_D0_PENDING;

            if ((deviceExtensionHub->HubFlags & HUBFLAG_HIBER) && 
                 oldPowerState != PowerDeviceD3) {

                ULONG p, numberOfPorts;
                PPORT_DATA portData;
                PDEVICE_EXTENSION_PORT deviceExtensionPort;
                
                // we are going to d0 from hibernate, we may 
                // have been in D2 but we want to always go 
                // thru the D3->D0 codepath since the bus was reset.

                oldPowerState = PowerDeviceD3;

                // modify children
                numberOfPorts = deviceExtensionHub->HubDescriptor->bNumberOfPorts;
                portData = deviceExtensionHub->PortData;
                
                for (p = 1;
                     p <= numberOfPorts;
                     p++, portData++) {
                    
                    if (portData->DeviceObject) {
                        deviceExtensionPort = 
                            portData->DeviceObject->DeviceExtension;    
                        deviceExtensionPort->DeviceState = PowerDeviceD3;

                        deviceExtensionPort->PortPdoFlags |= PORTPDO_NEED_RESET;
                    }       
                }       
            }                
            
            deviceExtensionHub->HubFlags &= ~HUBFLAG_HIBER;

            if (oldPowerState == PowerDeviceD3) {
                //
                // Schedule a work item to process this.
                //
                workItemSetPowerD0 = UsbhExAllocatePool(NonPagedPool,
                                        sizeof(USBH_SET_POWER_D0_WORK_ITEM));

                if (workItemSetPowerD0) {

                    workItemSetPowerD0->DeviceExtensionHub = deviceExtensionHub;
                    workItemSetPowerD0->Irp = Irp;

                    ExInitializeWorkItem(&workItemSetPowerD0->WorkQueueItem,
                                         USBH_SetPowerD0Worker,
                                         workItemSetPowerD0);

                    LOGENTRY(LOG_PNP, "HD0Q", deviceExtensionHub,
                        &workItemSetPowerD0->WorkQueueItem, 0);

                    USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);
                    // critical saves time on resume
                    ExQueueWorkItem(&workItemSetPowerD0->WorkQueueItem,
                                    CriticalWorkQueue);

                    // The WorkItem is freed by USBH_SetPowerD0Worker()
                    // Don't try to access the WorkItem after it is queued.

                    ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
                } else {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

            } else {
                if (!(deviceExtensionHub->HubFlags &
                        HUBFLAG_HUB_STOPPED)) {
                    USBH_SubmitInterruptTransfer(deviceExtensionHub);
                }
            }

            // If we're not going to complete the PowerDeviceD0 request later
            // in USBH_SetPowerD0Worker(), start the next power IRP here now.
            //
            if (ntStatus != STATUS_MORE_PROCESSING_REQUIRED) {
                PoStartNextPowerIrp(Irp);
            }
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
            deviceExtensionHub->CurrentPowerState =
                irpStack->Parameters.Power.State.DeviceState;

            break;
        }

        USBH_KdPrint((1, "'Setting HU fdo(%x) to D%d, status = %x\n",
                deviceExtensionHub->FunctionalDeviceObject,
                irpStack->Parameters.Power.State.DeviceState - 1,
                ntStatus));
    } else {

        if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0) {
            // Don't forget to start the next power IRP if this is set D0
            // and it failed.
            PoStartNextPowerIrp(Irp);

            deviceExtensionHub->HubFlags &= ~HUBFLAG_SET_D0_PENDING;
        }
    }

    return ntStatus;
}


NTSTATUS
USBH_FdoDeferPoRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PDEVICE_EXTENSION_FDO deviceExtension;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = NULL;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpStack;

    deviceExtension = Context;
    irp = deviceExtension->PowerIrp;
    // return the status of this operation
    ntStatus = IoStatus->Status;

    USBH_KdPrint((2,"'USBH_FdoDeferPoRequestCompletion, ntStatus = %x\n",
        ntStatus));

// It is normal for the power IRP to fail if a hub was removed during
// hibernate.
//
//#if DBG
//    if (NT_ERROR(ntStatus)) {
//        USBH_KdTrap(("Device Power Irp Failed (%x)\n", ntStatus));
//    }
//#endif

    if (deviceExtension->ExtensionType == EXTENSION_TYPE_HUB) {
        deviceExtensionHub = Context;
    }

    irpStack = IoGetCurrentIrpStackLocation(irp);

    if (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking &&
        deviceExtensionHub != NULL &&
        IS_ROOT_HUB(deviceExtensionHub)) {

        // Allow selective suspend once again now that the root hub has
        // been powered up.

        LOGENTRY(LOG_PNP, "ESus", deviceExtensionHub, 0, 0);
        USBH_KdPrint((1,"'Selective Suspend possible again because Root Hub is now at D0\n"));

        // We know this is the root hub so we don't need to call
        // USBH_GetRootHubDevExt to get it.

        deviceExtensionHub->CurrentSystemPowerState =
            irpStack->Parameters.Power.State.SystemState;
    }

    USBH_KdPrint((2,"'irp = %x devobj = %x\n",
        irp, deviceExtension->TopOfStackDeviceObject));

    IoCopyCurrentIrpStackLocationToNext(irp);
    PoStartNextPowerIrp(irp);
    PoCallDriver(deviceExtension->TopOfStackDeviceObject,
                 irp);

    return ntStatus;
}


VOID
USBH_HubQueuePortWakeIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PLIST_ENTRY IrpsToComplete
    )
/*++

Routine Description:

    Called to queue all the pending child port WW IRPs of a given
    hub into a private queue.

Arguments:


Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    PPORT_DATA portData;
    PIRP irp;
    KIRQL irql;
    ULONG numberOfPorts, i;
    LONG pendingPortWWs;

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    USBH_ASSERT(NULL != hubDescriptor);

    numberOfPorts = hubDescriptor->bNumberOfPorts;

    InitializeListHead(IrpsToComplete);

    // First, queue all the port wake IRPs into a local list while
    // the cancel spinlock is held.  This will prevent new WW IRPs for
    // these ports from being submitted while we are traversing the list.
    // Once we have queued them all we will release the spinlock (because
    // the list no longer needs protection), then complete the IRPs.

    IoAcquireCancelSpinLock(&irql);

    for (i=0; i<numberOfPorts; i++) {

        portData = &DeviceExtensionHub->PortData[i];
        if (portData->DeviceObject) {

            deviceExtensionPort = portData->DeviceObject->DeviceExtension;

            irp = deviceExtensionPort->WaitWakeIrp;
            deviceExtensionPort->WaitWakeIrp = NULL;
            // signal the waitwake irp if we have one
            if (irp) {

                IoSetCancelRoutine(irp, NULL);

                deviceExtensionPort->PortPdoFlags &=
                    ~PORTPDO_REMOTE_WAKEUP_ENABLED;

                pendingPortWWs =
                    InterlockedDecrement(&DeviceExtensionHub->NumberPortWakeIrps);

                InsertTailList(IrpsToComplete, &irp->Tail.Overlay.ListEntry);
            }
        }
    }

    USBH_ASSERT(DeviceExtensionHub->PendingWakeIrp == NULL);

    IoReleaseCancelSpinLock(irql);
}


VOID
USBH_HubCompleteQueuedPortWakeIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PLIST_ENTRY IrpsToComplete,
    IN NTSTATUS NtStatus
    )
/*++

Routine Description:

    Called to complete all the pending child port WW IRPs in the given
    private queue.

Arguments:


Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PLIST_ENTRY listEntry;

    while (!IsListEmpty(IrpsToComplete)) {
        listEntry = RemoveHeadList(IrpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        USBH_KdPrint((1,"'Signaling WaitWake IRP (%x)\n", irp));
        USBH_CompletePowerIrp(DeviceExtensionHub, irp, NtStatus);
    }
}


VOID
USBH_HubCompletePortWakeIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN NTSTATUS NtStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a hub
    Propagates the wake irp completion to all the ports.

Arguments:

    DeviceExtensionHub

Return Value:

    The function value is the final status from the operation.

--*/
{
    LIST_ENTRY irpsToComplete;

    LOGENTRY(LOG_PNP, "pWWc", DeviceExtensionHub, NtStatus, 0);

    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

        // Hub has already been removed and child WW IRP's should have already
        // been completed.

        return;
    }

    USBH_HubQueuePortWakeIrps(DeviceExtensionHub, &irpsToComplete);

    // Ok, we have queued all the port wake IRPs and have released the
    // cancel spinlock.  Let's complete all the IRPs.

    USBH_HubCompleteQueuedPortWakeIrps(DeviceExtensionHub, &irpsToComplete,
        NtStatus);
}


VOID
USBH_HubQueuePortIdleIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PLIST_ENTRY IrpsToComplete
    )
/*++

Routine Description:

    Called to queue all the pending child port Idle IRPs of a given
    hub into a private queue.

Arguments:


Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    PPORT_DATA portData;
    PIRP irp;
    PDRIVER_CANCEL oldCancelRoutine;
    KIRQL irql;
    ULONG numberOfPorts, i;

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    USBH_ASSERT(NULL != hubDescriptor);

    numberOfPorts = hubDescriptor->bNumberOfPorts;

    InitializeListHead(IrpsToComplete);

    // First, queue all the port idle IRPs into a local list while
    // the cancel spinlock is held.  This will prevent new WW IRPs for
    // these ports from being submitted while we are traversing the list.
    // Once we have queued them all we will release the spinlock (because
    // the list no longer needs protection), then complete the IRPs.

    IoAcquireCancelSpinLock(&irql);

    for (i=0; i<numberOfPorts; i++) {

        portData = &DeviceExtensionHub->PortData[i];
        if (portData->DeviceObject) {

            deviceExtensionPort = portData->DeviceObject->DeviceExtension;

            irp = deviceExtensionPort->IdleNotificationIrp;
            deviceExtensionPort->IdleNotificationIrp = NULL;
            // Complete the Idle IRP if we have one.
            if (irp) {

                oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
                if (oldCancelRoutine) {
                    deviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;

                    InsertTailList(IrpsToComplete, &irp->Tail.Overlay.ListEntry);
                }
#if DBG
                  else {
                    //
                    //  The IRP was cancelled and the cancel routine was called.
                    //  The cancel routine will dequeue and complete the IRP,
                    //  so don't do it here.

                    USBH_ASSERT(irp->Cancel);
                }
#endif
            }
        }
    }

    if (DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_IDLE_IRP) {
        irp = DeviceExtensionHub->PendingIdleIrp;
        DeviceExtensionHub->PendingIdleIrp = NULL;
    } else {
        irp = NULL;
        ASSERT(!DeviceExtensionHub->PendingIdleIrp);
    }

    IoReleaseCancelSpinLock(irql);

    if (irp) {
        USBH_HubCancelIdleIrp(DeviceExtensionHub, irp);
    }
}


VOID
USBH_HubCompleteQueuedPortIdleIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PLIST_ENTRY IrpsToComplete,
    IN NTSTATUS NtStatus
    )
/*++

Routine Description:

    Called to complete all the pending child port Idle IRPs in the given
    private queue.

Arguments:


Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PLIST_ENTRY listEntry;

    while (!IsListEmpty(IrpsToComplete)) {
        listEntry = RemoveHeadList(IrpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        USBH_KdPrint((1,"'Completing port Idle IRP (%x)\n", irp));
        irp->IoStatus.Status = NtStatus;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}


VOID
USBH_HubCompletePortIdleIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN NTSTATUS NtStatus
    )
/*++

Routine Description:

    Complete all the Idle IRPs for the given hub.

Arguments:

    DeviceExtensionHub

Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    PPORT_DATA portData;
    PIRP irp;
    PDRIVER_CANCEL oldCancelRoutine;
    LIST_ENTRY irpsToComplete;
    PLIST_ENTRY listEntry;
    KIRQL irql;
    ULONG numberOfPorts, i;

    LOGENTRY(LOG_PNP, "pIIc", DeviceExtensionHub, NtStatus, 0);

    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

        // Hub has already been removed and child Idle IRP's should have already
        // been completed.

        return;
    }

    USBH_HubQueuePortIdleIrps(DeviceExtensionHub, &irpsToComplete);

    // Ok, we have queued all the port idle IRPs and have released the
    // cancel spinlock.  Let's complete all the IRPs.

    USBH_HubCompleteQueuedPortIdleIrps(DeviceExtensionHub, &irpsToComplete,
        NtStatus);
}


VOID
USBH_HubCancelWakeIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/*++

Routine Description:

    Called to cancel the pending WaitWake IRP for a hub.
    This routine safely cancels the IRP.  Note that the pending WaitWake
    IRP pointer in the hub's device extension should have been already
    cleared before calling this function.

Arguments:

    Irp - Irp to cancel.

Return Value:

--*/
{
    IoCancelIrp(Irp);

    if (InterlockedExchange(&DeviceExtensionHub->WaitWakeIrpCancelFlag, 1)) {

        // This IRP has been completed on another thread and the other thread
        // did not complete the IRP.  So, we must complete it here.
        //
        // Note that we do not use USBH_CompletePowerIrp as the hub's pending
        // I/O counter was already decremented on the other thread in the
        // completion routine.

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = STATUS_CANCELLED;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
}


VOID
USBH_HubCancelIdleIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/*++

Routine Description:

    Called to cancel the pending Idle IRP for a hub.
    This routine safely cancels the IRP.  Note that the pending Idle
    IRP pointer in the hub's device extension should have been already
    cleared before calling this function.

Arguments:

    Irp - Irp to cancel.

Return Value:

--*/
{
    IoCancelIrp(Irp);

    if (InterlockedExchange(&DeviceExtensionHub->IdleIrpCancelFlag, 1)) {

        // This IRP has been completed on another thread and the other thread
        // did not free the IRP.  So, we must free it here.

        IoFreeIrp(Irp);
    }
}


NTSTATUS
USBH_FdoPoRequestD0Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    Called when the hub has entered D0 as a result of a
    wake irp completeing

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = Context;

    ntStatus = IoStatus->Status;

    USBH_KdPrint((1,"'WaitWake D0 completion(%x) for HUB VID %x, PID %x\n",
        ntStatus,
        deviceExtensionHub->DeviceDescriptor.idVendor, \
        deviceExtensionHub->DeviceDescriptor.idProduct));

    LOGENTRY(LOG_PNP, "hWD0", deviceExtensionHub,
                              deviceExtensionHub->PendingWakeIrp,
                              0);

    // Since we can't easily determine which ports are asserting resume
    // signalling we complete the WW IRPs for all of them.
    //
    // Ken says that we will need to determine what caused the hub WW
    // to complete and then only complete the WW Irp for that port, if any.
    // It is possible for more than one port to assert WW (e.g. user bumped
    // the mouse at the same time a pressing a key), and it is also possible
    // for a port with no device to have caused the hub WW to complete (e.g.
    // device insertion or removal).

    USBH_HubCompletePortWakeIrps(deviceExtensionHub, STATUS_SUCCESS);

    // Ok to idle hub again.

    deviceExtensionHub->HubFlags &= ~HUBFLAG_WW_SET_D0_PENDING;

    // Also ok to remove hub.

    USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);

    return ntStatus;
}


NTSTATUS
USBH_FdoWaitWakeIrpCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a hub

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;

    ntStatus = IoStatus->Status;

    return ntStatus;
}


NTSTATUS
USBH_FdoWWIrpIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This is the IoCompletionRoutine for the WW IRP for the hub, not to be
    confused with the PoRequestCompletionRoutine.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PUSBH_COMPLETE_PORT_IRPS_WORK_ITEM workItemCompletePortIrps;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = Context;
    POWER_STATE powerState;
    KIRQL irql;
    PIRP irp;

    ntStatus = Irp->IoStatus.Status;

    USBH_KdPrint((1,"'WaitWake completion(%x) for HUB VID %x, PID %x\n",
        ntStatus,
        deviceExtensionHub->DeviceDescriptor.idVendor, \
        deviceExtensionHub->DeviceDescriptor.idProduct));

    LOGENTRY(LOG_PNP, "hWWc", deviceExtensionHub,
                              ntStatus,
                              deviceExtensionHub->PendingWakeIrp);

    // We have to clear the PendingWakeIrp pointer here because in the case
    // where a device is unplugged between here and when the port loop is
    // processed in HubCompletePortWakeIrps, we will miss one of the port
    // WW IRP's, NumberPortWakeIrps will not decrement to zero, and we will
    // not clear the PendingWakeIrp pointer.  This is bad because the IRP
    // has been completed and the pointer is no longer valid.
    //
    // Hopefully the WW IRP for the port will be completed and
    // NumberPortWakeIrps adjusted properly when the device processes MN_REMOVE.
    //
    // BUT: Make sure that we have a PendingWakeIrp first before clearing
    // because it may have already been cleared when the last port WW was
    // canceled in USBH_WaitWakeCancel.

    IoAcquireCancelSpinLock(&irql);

    // We clear the flag regardless of whether PendingWakeIrp is present or
    // not because if the WW IRP request in FdoSubmitWaitWakeIrp fails
    // immediately, PendingWakeIrp will be NULL.

    deviceExtensionHub->HubFlags &= ~HUBFLAG_PENDING_WAKE_IRP;
    irp = InterlockedExchangePointer(&deviceExtensionHub->PendingWakeIrp, NULL);

    // deref the hub, no wake irp is pending
    USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);

    IoReleaseCancelSpinLock(irql);

    if (NT_SUCCESS(ntStatus)) {

        //
        // this means that either we were the source for
        // the wakeup or a device attached to one of our
        // ports is.
        //
        // our mission now is to discover what caused the
        // wakeup
        //

        USBH_KdPrint((1,"'Remote Wakeup Detected for HUB VID %x, PID %x\n",
            deviceExtensionHub->DeviceDescriptor.idVendor, \
            deviceExtensionHub->DeviceDescriptor.idProduct));

        // Prevent idling hub until this Set D0 request completes.

        deviceExtensionHub->HubFlags |= HUBFLAG_WW_SET_D0_PENDING;

        // Also prevent hub from being removed before Set D0 is complete.

        USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);

        powerState.DeviceState = PowerDeviceD0;

        // first we need to power up the hub
        PoRequestPowerIrp(deviceExtensionHub->PhysicalDeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              USBH_FdoPoRequestD0Completion,
                              deviceExtensionHub,
                              NULL);

        ntStatus = STATUS_SUCCESS;
    } else {

        // We complete the port Wake IRPs in a workitem on another
        // thread so that we don't fail a new Wake IRP for the hub
        // which might arrive in the same context, before we've
        // finished completing the old one.

        workItemCompletePortIrps = UsbhExAllocatePool(NonPagedPool,
                                    sizeof(USBH_COMPLETE_PORT_IRPS_WORK_ITEM));

        if (workItemCompletePortIrps) {

            workItemCompletePortIrps->DeviceExtensionHub = deviceExtensionHub;
            workItemCompletePortIrps->ntStatus = ntStatus;

            USBH_HubQueuePortWakeIrps(deviceExtensionHub,
                &workItemCompletePortIrps->IrpsToComplete);

            ExInitializeWorkItem(&workItemCompletePortIrps->WorkQueueItem,
                                 USBH_CompletePortWakeIrpsWorker,
                                 workItemCompletePortIrps);

            LOGENTRY(LOG_PNP, "wITM", deviceExtensionHub,
                &workItemCompletePortIrps->WorkQueueItem, 0);

            USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);
            // critical saves time on resume
            ExQueueWorkItem(&workItemCompletePortIrps->WorkQueueItem,
                            CriticalWorkQueue);

            // The WorkItem is freed by USBH_CompletePortWakeIrpsWorker()
            // Don't try to access the WorkItem after it is queued.
        }
    }

    if (!irp) {

        // If we have no IRP here this means that another thread wants to
        // cancel the IRP.  Handle accordingly.

        if (!InterlockedExchange(&deviceExtensionHub->WaitWakeIrpCancelFlag, 1)) {

            // We got the cancel flag before the other thread did.  Hold
            // on to the IRP here and let the cancel routine complete it.

            ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
        }
    }

    IoMarkIrpPending(Irp);

    if (ntStatus != STATUS_MORE_PROCESSING_REQUIRED) {
        PoStartNextPowerIrp(Irp);
    }

    return ntStatus;
}


NTSTATUS
USBH_FdoSubmitWaitWakeIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    called when a child Pdo is enabled for wakeup, this
    function allocates a wait wake irp and passes it to
    the parents PDO.


Arguments:

Return Value:

--*/
{
    PIRP irp;
    KIRQL irql;
    NTSTATUS ntStatus;
    POWER_STATE powerState;

    USBH_ASSERT(DeviceExtensionHub->PendingWakeIrp == NULL);

    USBH_KdPrint((1,"'USBH_FdoSubmitWaitWakeIrp (%x)\n", DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "hWW_", DeviceExtensionHub, 0, 0);

    powerState.DeviceState = DeviceExtensionHub->SystemWake;

    DeviceExtensionHub->HubFlags |= HUBFLAG_PENDING_WAKE_IRP;
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    InterlockedExchange(&DeviceExtensionHub->WaitWakeIrpCancelFlag, 0);
    ntStatus = PoRequestPowerIrp(DeviceExtensionHub->PhysicalDeviceObject,
                                      IRP_MN_WAIT_WAKE,
                                      powerState,
                                      USBH_FdoWaitWakeIrpCompletion,
                                      DeviceExtensionHub,
                                      &irp);

    USBH_ASSERT(ntStatus == STATUS_PENDING);

    IoAcquireCancelSpinLock(&irql);

    if (ntStatus == STATUS_PENDING) {

        // Must check flag here because in the case where the WW IRP failed
        // immediately, this flag will be cleared in the completion routine
        // and if that happens we don't want to save this IRP because it
        // will soon be invalid if it isn't already.

        if (DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_WAKE_IRP) {

            // Successfully posted a Wake IRP.
            // This hub is now enabled for wakeup.

            LOGENTRY(LOG_PNP, "hWW+", DeviceExtensionHub, irp, 0);
            DeviceExtensionHub->PendingWakeIrp = irp;
        }

    } else {
        USBH_ASSERT(FALSE);     // Want to know if we ever hit this.
        DeviceExtensionHub->HubFlags &= ~HUBFLAG_PENDING_WAKE_IRP;
        USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);
    }

    IoReleaseCancelSpinLock(irql);

    return ntStatus;
}


VOID
USBH_FdoIdleNotificationCallback(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Called when it is time to idle out the hub device itself.

Arguments:

Return Value:

--*/
{
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    PDEVICE_EXTENSION_PORT childDeviceExtensionPort;
    KIRQL irql;
    PIRP idleIrp;
    PIRP irpToCancel = NULL;
    POWER_STATE powerState;
    NTSTATUS ntStatus;
    ULONG i;
    BOOLEAN bIdleOk = TRUE;

    LOGENTRY(LOG_PNP, "hId!", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);
    USBH_KdPrint((1,"'Hub %x going idle!\n", DeviceExtensionHub));

    if (DeviceExtensionHub->HubFlags &
        (HUBFLAG_DEVICE_STOPPING |
         HUBFLAG_HUB_GONE |
         HUBFLAG_HUB_FAILURE |
         HUBFLAG_CHILD_DELETES_PENDING |
         HUBFLAG_WW_SET_D0_PENDING |
         HUBFLAG_POST_ESD_ENUM_PENDING |
         HUBFLAG_HUB_HAS_LOST_BRAINS)) {

        // Don't idle this hub if it was just disconnected or otherwise
        // being stopped.

        LOGENTRY(LOG_PNP, "hId.", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);
        USBH_KdPrint((1,"'Hub %x being stopped, in low power, etc., abort idle\n", DeviceExtensionHub));
        return;
    }

    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_WAKE_IRP)) {

        // If there is not already a WW IRP pending for the hub, submit
        // one now.  This will ensure that the hub will wakeup on connect
        // change events while it is suspended.

        ntStatus = USBH_FdoSubmitWaitWakeIrp(DeviceExtensionHub);
        if (ntStatus != STATUS_PENDING) {
            LOGENTRY(LOG_PNP, "hIdX", DeviceExtensionHub, ntStatus, 0);

            UsbhWarning(NULL,
                "Could not post WW IRP for hub, aborting IDLE.\n",
                FALSE);

            return;
        }
    }

    // Ensure that child port configuration does not change while in this
    // function, i.e. don't allow QBR.

    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    for (i = 0; i < DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

        if (DeviceExtensionHub->PortData[i].DeviceObject) {

            childDeviceExtensionPort = DeviceExtensionHub->PortData[i].DeviceObject->DeviceExtension;
            idleIrp = childDeviceExtensionPort->IdleNotificationIrp;

            if (idleIrp) {
                idleCallbackInfo = (PUSB_IDLE_CALLBACK_INFO)
                    IoGetCurrentIrpStackLocation(idleIrp)->\
                        Parameters.DeviceIoControl.Type3InputBuffer;

                USBH_ASSERT(idleCallbackInfo && idleCallbackInfo->IdleCallback);

                if (idleCallbackInfo && idleCallbackInfo->IdleCallback) {

                    // Here we actually call the driver's callback routine,
                    // telling the driver that it is OK to suspend their
                    // device now.

                    LOGENTRY(LOG_PNP, "IdCB", childDeviceExtensionPort,
                        idleCallbackInfo, idleCallbackInfo->IdleCallback);
                    USBH_KdPrint((1,"'FdoIdleNotificationCallback: Calling driver's idle callback routine! %x %x\n",
                        idleCallbackInfo, idleCallbackInfo->IdleCallback));

                    idleCallbackInfo->IdleCallback(idleCallbackInfo->IdleContext);

                    // Be sure that the child actually powered down.
                    // This is important in the case where the child is also
                    // a hub.  Abort if the child aborted.

                    if (childDeviceExtensionPort->DeviceState == PowerDeviceD0) {

                        LOGENTRY(LOG_PNP, "IdAb", childDeviceExtensionPort,
                            idleCallbackInfo, idleCallbackInfo->IdleCallback);
                        USBH_KdPrint((1,"'FdoIdleNotificationCallback: Driver's idle callback routine did not power down! %x %x\n",
                            idleCallbackInfo, idleCallbackInfo->IdleCallback));

                        bIdleOk = FALSE;
                        break;
                    }

                } else {

                    // No callback

                    bIdleOk = FALSE;
                    break;
                }

            } else {

                // No Idle IRP

                bIdleOk = FALSE;
                break;
            }
        }
    }

    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    if (bIdleOk) {

        // If all the port PDOs have been powered down,
        // it is time to power down the hub.

        powerState.DeviceState = DeviceExtensionHub->DeviceWake;

        PoRequestPowerIrp(DeviceExtensionHub->PhysicalDeviceObject,
                          IRP_MN_SET_POWER,
                          powerState,
                          NULL,
                          NULL,
                          NULL);
    } else {

        // One or more of the port PDOs did not have an Idle IRP
        // (i.e. it was just cancelled), or the Idle IRP did not have a
        // callback function pointer.  Abort this Idle procedure and cancel
        // the Idle IRP to the hub.

        LOGENTRY(LOG_PNP, "hIdA", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);
        USBH_KdPrint((1,"'Aborting Idle for Hub %x\n", DeviceExtensionHub));

        IoAcquireCancelSpinLock(&irql);

        if (DeviceExtensionHub && DeviceExtensionHub->PendingIdleIrp) {
            irpToCancel = DeviceExtensionHub->PendingIdleIrp;
            DeviceExtensionHub->PendingIdleIrp = NULL;
        }

        IoReleaseCancelSpinLock(irql);

        // Cancel the Idle request to the hub if there is one.

        if (irpToCancel) {
            USBH_HubCancelIdleIrp(DeviceExtensionHub, irpToCancel);
        }

        USBH_HubCompletePortIdleIrps(DeviceExtensionHub, STATUS_CANCELLED);
    }
}


VOID
USBH_IdleCompletePowerHubWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to power up a hub on completion of an Idle request
  * for the hub.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_HUB_IDLE_POWER_WORK_ITEM workItemIdlePower;

    PAGED_CODE();

    workItemIdlePower = Context;

    USBH_HubSetD0(workItemIdlePower->DeviceExtensionHub);
    USBH_HubCompletePortIdleIrps(workItemIdlePower->DeviceExtensionHub,
                                 workItemIdlePower->ntStatus);

    USBH_DEC_PENDING_IO_COUNT(workItemIdlePower->DeviceExtensionHub);
    UsbhExFreePool(workItemIdlePower);
}


VOID
USBH_CompletePortIdleIrpsWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to complete the child port Idle IRPs
  * for the hub.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_COMPLETE_PORT_IRPS_WORK_ITEM workItemCompletePortIrps;

    PAGED_CODE();

    workItemCompletePortIrps = Context;

    USBH_HubCompleteQueuedPortIdleIrps(
        workItemCompletePortIrps->DeviceExtensionHub,
        &workItemCompletePortIrps->IrpsToComplete,
        workItemCompletePortIrps->ntStatus);

    USBH_DEC_PENDING_IO_COUNT(workItemCompletePortIrps->DeviceExtensionHub);
    UsbhExFreePool(workItemCompletePortIrps);
}


VOID
USBH_CompletePortWakeIrpsWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to complete the child port Idle IRPs
  * for the hub.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_COMPLETE_PORT_IRPS_WORK_ITEM workItemCompletePortIrps;

    PAGED_CODE();

    workItemCompletePortIrps = Context;

    USBH_HubCompleteQueuedPortWakeIrps(
        workItemCompletePortIrps->DeviceExtensionHub,
        &workItemCompletePortIrps->IrpsToComplete,
        workItemCompletePortIrps->ntStatus);

    USBH_DEC_PENDING_IO_COUNT(workItemCompletePortIrps->DeviceExtensionHub);
    UsbhExFreePool(workItemCompletePortIrps);
}


NTSTATUS
USBH_FdoIdleNotificationRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Completion routine for the Idle request IRP for the hub device.

Arguments:

Return Value:

--*/
{
    PUSBH_HUB_IDLE_POWER_WORK_ITEM workItemIdlePower;
    PUSBH_COMPLETE_PORT_IRPS_WORK_ITEM workItemCompletePortIrps;
    NTSTATUS ntStatus;
    KIRQL irql;
    PIRP irp;
    BOOLEAN bHoldIrp = FALSE;

    //
    // DeviceObject is NULL because we sent the irp
    //
    UNREFERENCED_PARAMETER(DeviceObject);

    LOGENTRY(LOG_PNP, "hIdC", DeviceExtensionHub, Irp, Irp->IoStatus.Status);
    USBH_KdPrint((1,"'Idle notification IRP for hub %x completed %x\n",
            DeviceExtensionHub, Irp->IoStatus.Status));

    USBH_ASSERT(Irp->IoStatus.Status != STATUS_DEVICE_BUSY);

    IoAcquireCancelSpinLock(&irql);

    irp = InterlockedExchangePointer(&DeviceExtensionHub->PendingIdleIrp, NULL);
    DeviceExtensionHub->HubFlags &= ~HUBFLAG_PENDING_IDLE_IRP;
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    IoReleaseCancelSpinLock(irql);

    ntStatus = Irp->IoStatus.Status;

    // Complete port Idle IRPs w/error if hub Idle IRP failed.
    //
    // Skip this if the hub is stopping or has been removed as HubDescriptor
    // might have already been freed and FdoCleanup will complete these anyway.

    if (!NT_SUCCESS(ntStatus) && (ntStatus != STATUS_POWER_STATE_INVALID) &&
        !(DeviceExtensionHub->HubFlags & (HUBFLAG_HUB_GONE | HUBFLAG_HUB_STOPPED))) {

        if (DeviceExtensionHub->CurrentPowerState != PowerDeviceD0) {

            // Since we are at DPC we must use a work item to power up the
            // hub synchronously, because that function yields and we can't
            // yield at DPC level.

            workItemIdlePower = UsbhExAllocatePool(NonPagedPool,
                                    sizeof(USBH_HUB_IDLE_POWER_WORK_ITEM));

            if (workItemIdlePower) {

                workItemIdlePower->DeviceExtensionHub = DeviceExtensionHub;
                workItemIdlePower->ntStatus = ntStatus;

                ExInitializeWorkItem(&workItemIdlePower->WorkQueueItem,
                                     USBH_IdleCompletePowerHubWorker,
                                     workItemIdlePower);

                LOGENTRY(LOG_PNP, "iITM", DeviceExtensionHub,
                    &workItemIdlePower->WorkQueueItem, 0);

                USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
                ExQueueWorkItem(&workItemIdlePower->WorkQueueItem,
                                DelayedWorkQueue);

                // The WorkItem is freed by USBH_IdleCompletePowerHubWorker()
                // Don't try to access the WorkItem after it is queued.
            }

        } else {

            // We complete the port Idle IRPs in a workitem on another
            // thread so that we don't fail a new Idle IRP for the hub
            // which might arrive in the same context, before we've
            // finished completing the old one.

            workItemCompletePortIrps = UsbhExAllocatePool(NonPagedPool,
                                        sizeof(USBH_COMPLETE_PORT_IRPS_WORK_ITEM));

            if (workItemCompletePortIrps) {

                workItemCompletePortIrps->DeviceExtensionHub = DeviceExtensionHub;
                workItemCompletePortIrps->ntStatus = ntStatus;

                USBH_HubQueuePortIdleIrps(DeviceExtensionHub,
                    &workItemCompletePortIrps->IrpsToComplete);

                ExInitializeWorkItem(&workItemCompletePortIrps->WorkQueueItem,
                                     USBH_CompletePortIdleIrpsWorker,
                                     workItemCompletePortIrps);

                LOGENTRY(LOG_PNP, "iIT2", DeviceExtensionHub,
                    &workItemCompletePortIrps->WorkQueueItem, 0);

                USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
                ExQueueWorkItem(&workItemCompletePortIrps->WorkQueueItem,
                                DelayedWorkQueue);

                // The WorkItem is freed by USBH_CompletePortIdleIrpsWorker()
                // Don't try to access the WorkItem after it is queued.
            }
        }
    }

    if (!irp) {

        // If we have no IRP here this means that another thread wants to
        // cancel the IRP.  Handle accordingly.

        if (!InterlockedExchange(&DeviceExtensionHub->IdleIrpCancelFlag, 1)) {

            // We got the cancel flag before the other thread did.  Hold
            // on to the IRP here and let the cancel routine complete it.

            bHoldIrp = TRUE;
        }
    }

    // Since we allocated the IRP we must free it, but return
    // STATUS_MORE_PROCESSING_REQUIRED so the kernel does not try to touch
    // the IRP after we've freed it.

    if (!bHoldIrp) {
        IoFreeIrp(Irp);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
USBH_FdoSubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Called when all children PDO's are idled (or there are no children).
    This function allocates an idle request IOCTL IRP and passes it to
    the parent's PDO.

Arguments:

Return Value:

--*/
{
    PIRP irp = NULL;
    PIO_STACK_LOCATION nextStack;
    KIRQL irql;
    NTSTATUS ntStatus;

    USBH_KdPrint((1,"'USBH_FdoSubmitIdleRequestIrp %x\n", DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "hId_", DeviceExtensionHub, 0, 0);

    USBH_ASSERT(DeviceExtensionHub->PendingIdleIrp == NULL);

    if (DeviceExtensionHub->PendingIdleIrp) {
        // Probably don't want to clear the flag here because an Idle IRP
        // is pending.
        KeSetEvent(&DeviceExtensionHub->SubmitIdleEvent, 1, FALSE);
        return STATUS_DEVICE_BUSY;
    }

    DeviceExtensionHub->IdleCallbackInfo.IdleCallback = USBH_FdoIdleNotificationCallback;
    DeviceExtensionHub->IdleCallbackInfo.IdleContext = (PVOID)DeviceExtensionHub;

    irp = IoAllocateIrp(DeviceExtensionHub->PhysicalDeviceObject->StackSize,
                        FALSE);

    if (irp == NULL) {
        // Be sure to set the event and clear the flag on error before exiting.
        DeviceExtensionHub->HubFlags &= ~HUBFLAG_PENDING_IDLE_IRP;
        KeSetEvent(&DeviceExtensionHub->SubmitIdleEvent, 1, FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;
    nextStack->Parameters.DeviceIoControl.Type3InputBuffer = &DeviceExtensionHub->IdleCallbackInfo;
    nextStack->Parameters.DeviceIoControl.InputBufferLength = sizeof(struct _USB_IDLE_CALLBACK_INFO);

    IoSetCompletionRoutine(irp,
                           USBH_FdoIdleNotificationRequestComplete,
                           DeviceExtensionHub,
                           TRUE,
                           TRUE,
                           TRUE);

    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    InterlockedExchange(&DeviceExtensionHub->IdleIrpCancelFlag, 0);
    ntStatus = IoCallDriver(DeviceExtensionHub->PhysicalDeviceObject, irp);

    IoAcquireCancelSpinLock(&irql);

    if (ntStatus == STATUS_PENDING) {

        // Must check flag here because in the case where the Idle IRP failed
        // immediately, this flag will be cleared in the completion routine
        // and if that happens we don't want to save this IRP because it
        // will soon be invalid if it isn't already.

        if (DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_IDLE_IRP) {

            // Successfully posted an Idle IRP.

            LOGENTRY(LOG_PNP, "hId+", DeviceExtensionHub, irp, 0);
            DeviceExtensionHub->PendingIdleIrp = irp;
        }
    }

    IoReleaseCancelSpinLock(irql);

    KeSetEvent(&DeviceExtensionHub->SubmitIdleEvent, 1, FALSE);

    return ntStatus;
}


NTSTATUS
USBH_FdoPower(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN UCHAR MinorFunction
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl PnPPower for the FDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionHub - the FDO extension pIrp - the request packet
  * MinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_HUB rootHubDevExt;
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    BOOLEAN allPDOsAreOff, bHubNeedsWW;
    PPORT_DATA portData;
    ULONG i, numberOfPorts;
    KIRQL irql;
    PIRP hubWaitWake = NULL;
    POWER_STATE powerState;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;
    USBH_KdPrint((2,"'Power Request, FDO %x minor %x\n", deviceObject, MinorFunction));

    switch (MinorFunction) {
        //
        // Pass it down to Pdo to handle these
        //
    case IRP_MN_SET_POWER:

        //
        // Hub is being asked to change power state
        //

        switch (irpStack->Parameters.Power.Type) {
        case SystemPowerState:
            {
            POWER_STATE powerState;

            LOGENTRY(LOG_PNP, "sysP", DeviceExtensionHub,
                     DeviceExtensionHub->FunctionalDeviceObject,
                     0);

            // Track the current system power state in the hub's device ext.
            // Note that we only set this back to S0 (i.e. allow selective
            // suspend once again) once the root hub is fully powered up.

            if (irpStack->Parameters.Power.State.SystemState != PowerSystemWorking) {

                LOGENTRY(LOG_PNP, "DSus", DeviceExtensionHub, 0, 0);
                USBH_KdPrint((1,"'Selective Suspend disabled because system is suspending\n"));

                rootHubDevExt = USBH_GetRootHubDevExt(DeviceExtensionHub);

                rootHubDevExt->CurrentSystemPowerState =
                    irpStack->Parameters.Power.State.SystemState;
            }

            if (irpStack->Parameters.Power.State.SystemState == 
                PowerSystemHibernate) {
                DeviceExtensionHub->HubFlags |= HUBFLAG_HIBER;
                     USBH_KdPrint((1, "'Hibernate Detected\n"));
                     //TEST_TRAP();
            }
            
            // map the system state to the appropriate D state.
            // our policy is:
            //      if we are enabled for wakeup -- go to D2
            //      else go to D3

            USBH_KdPrint(
                (1, "'IRP_MJ_POWER HU fdo(%x) MN_SET_POWER(SystemPowerState S%x)\n",
                    DeviceExtensionHub->FunctionalDeviceObject,
                    irpStack->Parameters.Power.State.SystemState - 1));

            //
            // walk are list of PDOs, if all are in D3 yje set the
            // allPDOsAreOff flag

            allPDOsAreOff = TRUE;
            portData = DeviceExtensionHub->PortData;

            //
            // NOTE: if we are stopped the HubDescriptor will be NULL
            //

            if (portData &&
                DeviceExtensionHub->HubDescriptor) {
                numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

                for (i=0; i < numberOfPorts; i++) {
                    PDEVICE_EXTENSION_PORT deviceExtensionPort;

                    LOGENTRY(LOG_PNP, "cPRT", portData->DeviceObject,
                          0,
                          0);

                    if (portData->DeviceObject) {
                        deviceExtensionPort = portData->DeviceObject->DeviceExtension;
                        if (deviceExtensionPort->DeviceState != PowerDeviceD3) {
                            allPDOsAreOff = FALSE;
                            break;
                        }
                    }
                    portData++;
                }

#if DBG
                // if all PDOs are in D3 then this means the hub itself is a
                // wakeup source
                if (DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_WAKE_IRP) {
                    if (allPDOsAreOff) {
                        USBH_KdPrint(
                           (1, "'**Hub enabled for wakeup -- hub is only potential wakeup source\n"));
                    } else {
                         USBH_KdPrint(
                           (1, "'**Hub enabled for wakeup -- device is potential wakeup source\n"));
                    }
                }
#endif
            }

            if (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking) {
                //
                // go to ON
                //
                powerState.DeviceState = PowerDeviceD0;
                LOGENTRY(LOG_PNP, "syON", 0,
                          0,
                          0);

            } else if ((DeviceExtensionHub->HubFlags &
                            HUBFLAG_PENDING_WAKE_IRP) ||
                        !allPDOsAreOff) {

                //
                // based on the system power state
                // request a setting to the appropriate
                // Dx state.
                //
                // all low power states have already been mapped
                // to suspend

                powerState.DeviceState =
                    DeviceExtensionHub->DeviceState[irpStack->Parameters.Power.State.SystemState];

                //
                // These tables should have already been fixed up by the root hub
                // (usbd.sys) to not contain an entry of unspecified.
                //
                ASSERT (PowerDeviceUnspecified != powerState.DeviceState);

                LOGENTRY(LOG_PNP, "syDX", powerState.DeviceState,
                          0,
                          0);
                USBH_KdPrint((1,"'System state maps to device state 0x%x (D%x)\n",
                    powerState.DeviceState,
                    powerState.DeviceState - 1));

            } else {
                powerState.DeviceState = PowerDeviceD3;
                LOGENTRY(LOG_PNP, "syD3", powerState.DeviceState,
                          0,
                          0);
            }

            //
            // only make the request if it is for a different power
            // state then the one we are in, and it is a valid state for the
            // request.  Also, make sure the hub has been started.
            //

            LOGENTRY(LOG_PNP, "H>Sx", DeviceExtensionHub,
                     DeviceExtensionHub->FunctionalDeviceObject,
                     powerState.DeviceState);

            if (powerState.DeviceState != PowerDeviceUnspecified &&
                powerState.DeviceState != DeviceExtensionHub->CurrentPowerState &&
                (DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

                DeviceExtensionHub->PowerIrp = Irp;
                IoMarkIrpPending(Irp);

                ntStatus = PoRequestPowerIrp(DeviceExtensionHub->PhysicalDeviceObject,
                                             IRP_MN_SET_POWER,
                                             powerState,
                                             USBH_FdoDeferPoRequestCompletion,
                                             DeviceExtensionHub,
                                             NULL);

                USBH_KdPrint((2,"'PoRequestPowerIrp returned 0x%x\n", ntStatus));

                // We need to return STATUS_PENDING here because we marked the
                // IRP pending above with IoMarkIrpPending.

                USBH_ASSERT(ntStatus == STATUS_PENDING);

                // In the case where an allocation failed, PoRequestPowerIrp
                // can return a status code other than STATUS_PENDING.  In this
                // case, we still need to pass the IRP down to the lower driver,
                // but we still need to return STATUS_PENDING from this routine.

                if (ntStatus != STATUS_PENDING) {
                    IoCopyCurrentIrpStackLocationToNext(Irp);
                    PoStartNextPowerIrp(Irp);
                    ntStatus = PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                                            Irp);
                }

                ntStatus = STATUS_PENDING;

            } else {

                IoCopyCurrentIrpStackLocationToNext(Irp);
                PoStartNextPowerIrp(Irp);
                ntStatus = PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                                        Irp);
            }
            }
            break; //SystemPowerState

        case DevicePowerState:

            USBH_KdPrint(
                (1, "'IRP_MJ_POWER HU fdo(%x) MN_SET_POWER(DevicePowerState D%x)\n",
                    DeviceExtensionHub->FunctionalDeviceObject,
                    irpStack->Parameters.Power.State.DeviceState - 1));

            LOGENTRY(LOG_PNP, "H>Dx", DeviceExtensionHub,
                     DeviceExtensionHub->FunctionalDeviceObject,
                     irpStack->Parameters.Power.State.DeviceState);

            // If we are already in the requested power state, or if this is
            // a Set D0 request and we already have one pending,
            // just pass the request on.

            if ((DeviceExtensionHub->CurrentPowerState ==
                irpStack->Parameters.Power.State.DeviceState) ||
                (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0 &&
                 (DeviceExtensionHub->HubFlags & HUBFLAG_SET_D0_PENDING))) {

                LOGENTRY(LOG_PNP, "HDxP", DeviceExtensionHub, 0, 0);

                IoCopyCurrentIrpStackLocationToNext(Irp);

                PoStartNextPowerIrp(Irp);

                IoMarkIrpPending(Irp);
                PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                             Irp);

                ntStatus = STATUS_PENDING;

                break;
            }

            switch (irpStack->Parameters.Power.State.DeviceState) {

            case PowerDeviceD0:

                USBH_ASSERT(DeviceExtensionHub->CurrentPowerState != PowerDeviceD0);

                DeviceExtensionHub->HubFlags &=
                    ~(HUBFLAG_DEVICE_STOPPING | HUBFLAG_DEVICE_LOW_POWER);
                DeviceExtensionHub->HubFlags |= HUBFLAG_SET_D0_PENDING;

                //
                // must pass this on to our PDO
                //

                IoCopyCurrentIrpStackLocationToNext(Irp);

                IoSetCompletionRoutine(Irp,
                                       USBH_PowerIrpCompletion,
                                       DeviceExtensionHub,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                IoMarkIrpPending(Irp);
                PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                             Irp);

                // For some strange PnP reason, we have to return
                // STATUS_PENDING here if our completion routine will also
                // pend (e.g. return STATUS_MORE_PROCESSING_REQUIRED).
                // (Ignore the PoCallDriver return value.)

                ntStatus = STATUS_PENDING;

                break;

            case PowerDeviceD1:
            case PowerDeviceD2:
            case PowerDeviceD3:

                // If there is a ChangeIndicationWorkitem pending, then we
                // must wait for that to complete.

                if (DeviceExtensionHub->ChangeIndicationWorkitemPending) {

                    USBH_KdPrint((2,"'Wait for single object\n"));

                    ntStatus = KeWaitForSingleObject(&DeviceExtensionHub->CWKEvent,
                                                     Suspended,
                                                     KernelMode,
                                                     FALSE,
                                                     NULL);

                    USBH_KdPrint((2,"'Wait for single object, returned %x\n", ntStatus));
                }

                //
                // set our stop flag so that ChangeIndication does not submit
                // any more transfers
                //
                // note that we skip this if the hub is 'stopped'

                if (!(DeviceExtensionHub->HubFlags &
                        HUBFLAG_HUB_STOPPED)) {

                    NTSTATUS status;
                    BOOLEAN bRet;

                    DeviceExtensionHub->HubFlags |=
                        (HUBFLAG_DEVICE_STOPPING | HUBFLAG_DEVICE_LOW_POWER);

                    bRet = IoCancelIrp(DeviceExtensionHub->Irp);

                    // Only wait on the abort event if the IRP was actually
                    // cancelled.

                    if (bRet) {
                    LOGENTRY(LOG_PNP, "aWAT", DeviceExtensionHub,
                            &DeviceExtensionHub->AbortEvent,  0);

                    status = KeWaitForSingleObject(
                               &DeviceExtensionHub->AbortEvent,
                               Suspended,
                               KernelMode,
                               FALSE,
                               NULL);
                    }
                }

                //
                // must pass this on to our PDO
                //

                IoCopyCurrentIrpStackLocationToNext(Irp);

                IoSetCompletionRoutine(Irp,
                                       USBH_PowerIrpCompletion,
                                       DeviceExtensionHub,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                PoStartNextPowerIrp(Irp);
                IoMarkIrpPending(Irp);
                PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                             Irp);
                // toss status and return status pending
                // we do this because our completion routine
                // stalls completion but we do not block here
                // in dispatch.
                // OS code only waits if status_pending is returned
                ntStatus = STATUS_PENDING;
                break;
            }

            break; //DevicePowerState
        }

        break; // MN_SET_POWER

    case IRP_MN_QUERY_POWER:

        USBH_KdPrint((1, "'IRP_MJ_POWER HU fdo(%x) MN_QUERY_POWER\n",
            DeviceExtensionHub->FunctionalDeviceObject));

        // Cancel our WW IRP if we are going to D3, the hub is idled
        // (selectively suspended), and the hub is empty.  We don't want
        // to prevent going to D3 if the hub is selectively suspended and
        // there are no children that would require the hub be wake-enabled.

        powerState.DeviceState =
            DeviceExtensionHub->DeviceState[irpStack->Parameters.Power.State.SystemState];

        bHubNeedsWW = USBH_DoesHubNeedWaitWake(DeviceExtensionHub);

        IoAcquireCancelSpinLock(&irql);

        if (powerState.DeviceState == PowerDeviceD3 &&
            DeviceExtensionHub->PendingWakeIrp &&
            !bHubNeedsWW) {

            hubWaitWake = DeviceExtensionHub->PendingWakeIrp;
            DeviceExtensionHub->PendingWakeIrp = NULL;
        }

        IoReleaseCancelSpinLock(irql);

        if (hubWaitWake) {
            USBH_KdPrint((1, "'Cancelling hub's WW because we are going to D3 and there are no children\n"));

            USBH_HubCancelWakeIrp(DeviceExtensionHub, hubWaitWake);
        }

        //
        // Now pass this on to our PDO.
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);

        PoStartNextPowerIrp(Irp);
        ntStatus = PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                                Irp);

        break;

    case IRP_MN_WAIT_WAKE:

        USBH_KdPrint((1, "'IRP_MJ_POWER HU fdo(%x) MN_WAIT_WAKE\n",
            DeviceExtensionHub->FunctionalDeviceObject));

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(Irp,
                               USBH_FdoWWIrpIoCompletion,
                               DeviceExtensionHub,
                               TRUE,
                               TRUE,
                               TRUE);

        PoStartNextPowerIrp(Irp);
        IoMarkIrpPending(Irp);
        PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                     Irp);

        // For some strange PnP reason, we have to return
        // STATUS_PENDING here if our completion routine will also
        // pend (e.g. return STATUS_MORE_PROCESSING_REQUIRED).
        // (Ignore the PoCallDriver return value.)

        ntStatus = STATUS_PENDING;
        break;

        //
        // otherwise pass the Irp down
        //

    default:

        USBH_KdPrint((2,"'Unhandled Power request to fdo %x  %x, passed to PDO\n",
                          deviceObject, MinorFunction));

        IoCopyCurrentIrpStackLocationToNext(Irp);

        PoStartNextPowerIrp(Irp);
        ntStatus = PoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                                Irp);

        break;
    }

    USBH_KdPrint((2,"'FdoPower exit %x\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\hub.pnp\dbg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    DBG.C

Abstract:

    This module contains debug only code for USB Hub driver

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    11-5-96 : created

--*/


#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */

#include "stdarg.h"
#include "stdio.h"
#include "usbhub.h"

#ifdef MAX_DEBUG
#define DEBUG_HEAP
#endif

typedef struct _HEAP_TAG_BUFFER {
    ULONG Sig;
    ULONG Length;
} HEAP_TAG_BUFFER, *PHEAP_TAG_BUFFER;


#if DBG 

// this flag causes us to write a ' in the format string 
// so that the string goes to the NTKERN buffer
// this trick causes problems with driver verifier on NT
// and the trace buffer isn't in NT anyway 
ULONG USBH_W98_Debug_Trace = 
#ifdef NTKERN_TRACE
1;
#else 
0;
#endif

VOID
USBH_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    )
/*++

Routine Description:

    Debug Assert function. 

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
#ifdef NTKERN  
    // this makes the compiler generate a ret
    ULONG stop = 1;
    
assert_loop:
#endif
    // just call the NT assert function and stop
    // in the debugger.
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );

    // loop here to prevent users from going past
    // are assert before we can look at it
#ifdef NTKERN    
    DBGBREAK();
    if (stop) {
        goto assert_loop;
    }        
#endif
    return;
}


ULONG
_cdecl
USBH_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    )
{
    va_list list;
    int i;
    int arg[6];
    
    if (USBH_Debug_Trace_Level >= l) {    
        if (l <= 1) {
            if (USBH_W98_Debug_Trace) {             
                //override trace buffer
#ifdef USBHUB20  
                DbgPrint("USBHUB20.SYS: ");
#else
                DbgPrint("USBHUB.SYS: ");
#endif                
                *Format = ' ';
            } else {
#ifdef USBHUB20  
                DbgPrint("USBHUB20.SYS: ");
#else
                DbgPrint("USBHUB.SYS: ");
#endif                 
            }
        } else {
#ifdef USBHUB20 
            DbgPrint("USBHUB20.SYS: ");
#else
            DbgPrint("USBHUB.SYS: ");
#endif             
        }
        va_start(list, Format);
        for (i=0; i<6; i++) 
            arg[i] = va_arg(list, int);
        
        DbgPrint(Format, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5]);    
    } 

    return 0;
}


VOID
UsbhWarning(
    PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    PUCHAR Message,
    BOOLEAN DebugBreak
    )
{                                                                                               
    DbgPrint("USBHUB: Warning **************************************************************\n");
    if (DeviceExtensionPort) {
        DbgPrint("Device PID %04.4x, VID %04.4x\n",     
                 DeviceExtensionPort->DeviceDescriptor.idProduct, 
                 DeviceExtensionPort->DeviceDescriptor.idVendor); 
    }
    DbgPrint("%s", Message);

    DbgPrint("******************************************************************************\n");

    if (DebugBreak) {
        DBGBREAK();
    }
      
}


VOID 
UsbhInfo(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
{
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    ULONG i;

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    
    USBH_KdPrint((1, "'*****************************************************\n"));
    
    if (USBH_HubIsBusPowered(DeviceExtensionHub->FunctionalDeviceObject,
                             DeviceExtensionHub->ConfigurationDescriptor)) {
        USBH_KdPrint((1, "'*** Hub VID %04.4x PID %04.4x is BUS POWERED \n",
                DeviceExtensionHub->DeviceDescriptor.idVendor,
                DeviceExtensionHub->DeviceDescriptor.idProduct));                             
    } else {
        USBH_KdPrint((1, "'*** Hub VID %04.4x PID %04.4x is SELF POWERED \n",
                DeviceExtensionHub->DeviceDescriptor.idVendor,
                DeviceExtensionHub->DeviceDescriptor.idProduct));
    }                
    USBH_KdPrint((1, "'*** has %d ports\n", 
            hubDescriptor->bNumberOfPorts));
    if (HUB_IS_GANG_POWER_SWITCHED(hubDescriptor->wHubCharacteristics)) {
        USBH_KdPrint((1,"'*** is 'gang power switched'\n"));
    } else if (HUB_IS_NOT_POWER_SWITCHED(hubDescriptor->wHubCharacteristics)) {
        USBH_KdPrint((1,"'*** is 'not power switched'\n"));
    } else if (HUB_IS_PORT_POWER_SWITCHED(hubDescriptor->wHubCharacteristics)) {
        USBH_KdPrint((1,"'*** is 'port power switched'\n"));
    } else {
        TEST_TRAP();
    }

    for (i=0; i< hubDescriptor->bNumberOfPorts; i++) {
    
        if (PORT_ALWAYS_POWER_SWITCHED(hubDescriptor, i+1)) {
            USBH_KdPrint((1,"'*** port (%d) is power switched\n", i+1));    
        }
        
        if (PORT_DEVICE_NOT_REMOVABLE(hubDescriptor, i+1)) {
            USBH_KdPrint((1,"'*** port (%d) device is not removable\n", i+1));    
        }
    }
    
    USBH_KdPrint((1, "'*****************************************************\n"));    
}        


PVOID
UsbhGetHeap(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since 
    most NT debug functions are not supported by NTKERN.
    
Arguments:

    PoolType - pool type passed to ExAllocatePool
    
    NumberOfBytes - number of bytes for item

    Signature - four byte signature supplied by caller

    TotalAllocatedHeapSpace - pointer to variable where client stores
                the total accumulated heap space allocated.

Return Value:

    pointer to allocated memory

--*/
{
    PUCHAR p;
#ifdef DEBUG_HEAP
    PHEAP_TAG_BUFFER tagBuffer;
    
    // we call ExAllocatePoolWithTag but no tag will be added
    // when running under NTKERN

    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes + sizeof(HEAP_TAG_BUFFER)*2,
                                       Signature);

    if (p) {
        tagBuffer = (PHEAP_TAG_BUFFER) p;
        tagBuffer->Sig = Signature;
        tagBuffer->Length = NumberOfBytes;        
        p += sizeof(HEAP_TAG_BUFFER);
        *TotalAllocatedHeapSpace += NumberOfBytes;

        tagBuffer = (PHEAP_TAG_BUFFER) (p + NumberOfBytes);
        tagBuffer->Sig = Signature;
        tagBuffer->Length = NumberOfBytes;     
    }                                            

//    LOGENTRY(LOG_MISC, (PUCHAR) &Signature, 0, 0, 0);
//    LOGENTRY(LOG_MISC, "GetH", p, NumberOfBytes, stk[1] & 0x00FFFFFF);
#else    
    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes,
                                       Signature);

#endif /* DEBUG_HEAP */                
    return p;
}


VOID
UsbhRetHeap(
    IN PVOID P,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since 
    most NT debug functions are not supported by NTKERN.
    
Arguments:

    P - pointer to free

Return Value:

    none.

--*/
{
#ifdef DEBUG_HEAP
    PHEAP_TAG_BUFFER endTagBuffer;    
    PHEAP_TAG_BUFFER beginTagBuffer;

    USBH_ASSERT(P != 0);
    
    beginTagBuffer = (PHEAP_TAG_BUFFER) ((PUCHAR)P  - sizeof(HEAP_TAG_BUFFER));
    endTagBuffer = (PHEAP_TAG_BUFFER) ((PUCHAR)P + beginTagBuffer->Length);

    *TotalAllocatedHeapSpace -= beginTagBuffer->Length;

//    LOGENTRY(LOG_MISC, (PUCHAR) &Signature, 0, 0, 0);    
//    LOGENTRY(LOG_MISC, "RetH", P, tagBuffer->Length, stk[1] & 0x00FFFFFF);

    USBH_ASSERT(*TotalAllocatedHeapSpace >= 0);
    USBH_ASSERT(beginTagBuffer->Sig == Signature);
    USBH_ASSERT(endTagBuffer->Sig == Signature);
    USBH_ASSERT(endTagBuffer->Length == beginTagBuffer->Length);
    
    // fill the buffer with bad data
    RtlFillMemory(P, beginTagBuffer->Length, 0xff);
    beginTagBuffer->Sig = USBHUB_FREE_TAG;

    // free the original block
    ExFreePool(beginTagBuffer);    
#else
    ExFreePool(P);        
#endif /* DEBUG_HEAP */
}

#endif /* DBG */

#ifdef DEBUG_LOG

KSPIN_LOCK LogSpinLock;

struct USBH_LOG_ENTRY {
    CHAR         le_name[4];      // Identifying string
    ULONG_PTR    le_info1;        // entry specific info
    ULONG_PTR    le_info2;        // entry specific info
    ULONG_PTR    le_info3;        // entry specific info
}; /* USBD_LOG_ENTRY */


struct USBH_LOG_ENTRY *HubLStart = 0;    // No log yet
struct USBH_LOG_ENTRY *HubLPtr;
struct USBH_LOG_ENTRY *HubLEnd;
#ifdef PROFILE
ULONG LogMask = LOG_PROFILE;
#else 
ULONG LogMask = 0xFFFFFFFF;
#endif

VOID
USBH_Debug_LogEntry(
    IN ULONG Mask,
    IN CHAR *Name, 
    IN ULONG_PTR Info1, 
    IN ULONG_PTR Info2, 
    IN ULONG_PTR Info3
    )
/*++

Routine Description:

    Adds an Entry to USBH log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;

    if (HubLStart == 0) {
        return;
    }        

    if ((Mask & LogMask) == 0) {
        return;
    }

    irql = KeGetCurrentIrql();
    if (irql < DISPATCH_LEVEL) {
        KeAcquireSpinLock(&LogSpinLock, &irql);
    } else {
        KeAcquireSpinLockAtDpcLevel(&LogSpinLock);
    }        
    
    if (HubLPtr > HubLStart) {
        HubLPtr -= 1;    // Decrement to next entry
    } else {
        HubLPtr = HubLEnd;
    }        

    if (irql < DISPATCH_LEVEL) {
        KeReleaseSpinLock(&LogSpinLock, irql);
    } else {
        KeReleaseSpinLockFromDpcLevel(&LogSpinLock);
    }        

    USBH_ASSERT(HubLPtr >= HubLStart);
    
    RtlCopyMemory(HubLPtr->le_name, Name, 4);
//    LPtr->le_ret = (stk[1] & 0x00ffffff) | (CurVMID()<<24);
    HubLPtr->le_info1 = Info1;
    HubLPtr->le_info2 = Info2;
    HubLPtr->le_info3 = Info3;

    return;
}


VOID
USBH_LogInit(
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:
    
Return Value:

    None.

--*/
{
#ifdef MAX_DEBUG
    ULONG logSize = 4096*6;    
#else
    ULONG logSize = 4096*3;    
#endif

    
    KeInitializeSpinLock(&LogSpinLock);

    HubLStart = ExAllocatePoolWithTag(NonPagedPool, 
                                      logSize,
                                      USBHUB_HEAP_TAG); 

    if (HubLStart) {
        HubLPtr = HubLStart;

        // Point the end (and first entry) 1 entry from the end of the segment
        HubLEnd = HubLStart + (logSize / sizeof(struct USBH_LOG_ENTRY)) - 1;
    } else {
        USBH_KdBreak(("no mem for log!\n"));
    }

    return;
}

VOID
USBH_LogFree(
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:
    
Return Value:

    None.

--*/
{
    if (HubLStart) {
        ExFreePool(HubLStart);
    }
}

#endif /* DEBUG_LOG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\hub.pnp\globals.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    GLOBALS.C

Abstract:

    This module's only purpose is to host global variables defined in usbhub.h.

Author:

    John Lee

Environment:

    kernel mode only

Notes:


Revision History:

    2-2-96 : created

--*/

#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */

#define HOST_GLOBALS
#include "usbhub.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\hub.pnp\ioctli.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    IOCTLI.C

Abstract:

    This module implements usb IOCTL requests to usb hub.

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:

    1-2-97 : re-wriiten

--*/

/*

//
// ** User mode IOCTLS **
//

//
// IOCTL_USB_GET_NODE_INFORMATION
//

input:
None

output:
outputbufferlength = sizeof(USB_BUS_NODE_INFORMATION)
outputbuffer = filled in with USB_BUS_NODE_INFORMATION structure.

//
// IOCTL_USB_GET_NODE_CONNECTION_INFORMATION
//

input:
inputbufferlength = size of user supplied buffer
inpubuffer =  ptr to USB_NODE_CONNECTION_INFORMATION structure with
    connectionIndex set to the requested connection.

output:
outputbufferlength = size of user supplied buffer
outputbuffer = filled in with USB_NODE_CONNECTION_INFORMATION structure.

//
// IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION
//

input:
inputbufferlength = size of user supplied buffer.
inputbuffer = ptr to USB_DESCRIPTOR_REQUEST, includes setup packet
                and connection index.

output:
outputbufferlength = length of descriptor data plus sizeof sizeof(USB_DESCRIPTOR_REQUEST).
outputbuffer = ptr to USB_DESCRIPTOR_REQUEST filled in with returned data.

//
// ** Internal IOCTLS **
//

//
// IOCTL_INTERNAL_USB_RESET_PORT
//

*/

#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmistr.h>
#include <wdmguid.h>
#endif /* WMI_SUPPORT */
#include "usbhub.h"

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBH_IoctlGetNodeInformation)
#pragma alloc_text(PAGE, USBH_IoctlGetHubCapabilities)
#pragma alloc_text(PAGE, USBH_IoctlGetNodeConnectionInformation)
#pragma alloc_text(PAGE, USBH_IoctlGetNodeConnectionDriverKeyName)
#pragma alloc_text(PAGE, USBH_IoctlGetNodeName)
#pragma alloc_text(PAGE, USBH_PdoIoctlGetPortStatus)
#pragma alloc_text(PAGE, USBH_PdoIoctlEnablePort)
#pragma alloc_text(PAGE, USBH_IoctlGetDescriptorForPDO)
#pragma alloc_text(PAGE, USBH_SystemControl)
#pragma alloc_text(PAGE, USBH_PortSystemControl)
#pragma alloc_text(PAGE, USBH_ExecuteWmiMethod)
#pragma alloc_text(PAGE, USBH_QueryWmiRegInfo)
#pragma alloc_text(PAGE, USBH_CheckLeafHubsIdle)
#endif
#endif

NTSTATUS
USBH_IoctlGetNodeInformation(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    PUSB_NODE_INFORMATION outputBuffer;
    ULONG outputBufferLength;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlGetNodeInformation\n"));

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    outputBuffer = (PUSB_NODE_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;

    RtlZeroMemory(outputBuffer, outputBufferLength);

    if (outputBufferLength >= sizeof(USB_NODE_INFORMATION)) {

        //
        // for now everything is a hub
        //

        outputBuffer->NodeType = UsbHub;
        RtlCopyMemory(&outputBuffer->u.HubInformation.HubDescriptor,
                      DeviceExtensionHub->HubDescriptor,
                      sizeof(outputBuffer->u.HubInformation));

        // 100 milliamps/port means bus powered
        outputBuffer->u.HubInformation.HubIsBusPowered =
            USBH_HubIsBusPowered(DeviceExtensionHub->FunctionalDeviceObject,
                                 DeviceExtensionHub->ConfigurationDescriptor);

        Irp->IoStatus.Information = sizeof(USB_NODE_INFORMATION);
    } else {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_IoctlCycleHubPort(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    PULONG buffer;
    ULONG bufferLength;
    ULONG port;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlCycleHubPort\n"));

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and its length.
    //

    buffer = (PULONG) Irp->AssociatedIrp.SystemBuffer;
    bufferLength = ioStack->Parameters.DeviceIoControl.InputBufferLength;

    if (bufferLength < sizeof(port)) {    
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        goto USBH_IoctlCycleHubPort_Done;
    } 

    // port number is input only
    port = *buffer;
    Irp->IoStatus.Information = 0;

    USBH_KdPrint((1,"'Request Cycle Port %d\n", port));

    if (port <= DeviceExtensionHub->HubDescriptor->bNumberOfPorts && 
        port > 0) {
    
        PPORT_DATA portData;
        PDEVICE_EXTENSION_PORT deviceExtensionPort;

        portData = &DeviceExtensionHub->PortData[port-1];
        if (portData->DeviceObject) {
            deviceExtensionPort = portData->DeviceObject->DeviceExtension;
            
            USBH_InternalCyclePort(DeviceExtensionHub, 
                                   (USHORT) port,
                                   deviceExtensionPort);
        } else {
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        USBH_KdPrint((1,"'Cycle Port %d %x\n", port, ntStatus));
    }
    
USBH_IoctlCycleHubPort_Done:

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_IoctlGetHubCapabilities(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    PUSB_HUB_CAPABILITIES outputBuffer;
    ULONG outputBufferLength, copyLen;
    USB_HUB_CAPABILITIES localBuffer;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlGetHubCapabilities\n"));

    RtlZeroMemory(&localBuffer, sizeof(USB_HUB_CAPABILITIES));

    // Fill in the data in the local buffer first, then copy as much of
    // this data to the user's buffer as requested (as indicated by the
    // size of the request buffer).

    localBuffer.HubIs2xCapable =
        (DeviceExtensionHub->HubFlags & HUBFLAG_USB20_HUB) ? 1:0;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and its length.
    //
    

    outputBuffer = (PUSB_HUB_CAPABILITIES) Irp->AssociatedIrp.SystemBuffer;
    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (outputBufferLength <= sizeof(localBuffer)) {
        copyLen = outputBufferLength;
    } else {
        copyLen = sizeof(localBuffer);
    }

    // zero buffer passed in
    RtlZeroMemory(outputBuffer,
                  outputBufferLength);

    // Only give the user the amount of data that they ask for
    // this may only be part of our info strucure

    RtlCopyMemory(outputBuffer,
                  &localBuffer,
                  copyLen);

    Irp->IoStatus.Information = copyLen;

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_IoctlGetNodeConnectionDriverKeyName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * ConnectionIndex - The one-based port index to which a device is attached.
  * The devnode name of the will be returned, if there is sufficient buffer space.
  *
  * ActualLength - The structure size in bytes necessary to hold the NULL
  * terminated name.  This includes the entire structure, not
  * just the name.
  *
  * NodeName - The UNICODE NULL terminated name of the devnode for the device
  * attached to this port.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    PUSB_NODE_CONNECTION_DRIVERKEY_NAME outputBuffer;
    ULONG outputBufferLength, length, i;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlGetNodeConnectionDriverKeyName\n"));

    portData = DeviceExtensionHub->PortData;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;
    outputBuffer = (PUSB_NODE_CONNECTION_DRIVERKEY_NAME) Irp->AssociatedIrp.SystemBuffer;

    // find the PDO

    if (outputBufferLength >= sizeof(USB_NODE_CONNECTION_DRIVERKEY_NAME)) {
        USBH_KdPrint((2,"'Connection = %d\n", outputBuffer->ConnectionIndex));

        ntStatus = STATUS_INVALID_PARAMETER;

        for(i=1; i<=DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

            PDEVICE_EXTENSION_PORT deviceExtensionPort;

            if (i == outputBuffer->ConnectionIndex) {

                portData = &DeviceExtensionHub->PortData[outputBuffer->ConnectionIndex - 1];

                if (portData->DeviceObject) {

                    deviceExtensionPort = portData->DeviceObject->DeviceExtension;

                    // Validate the PDO for PnP purposes.  (PnP will bugcheck
                    // if passed a not-quite-initialized PDO.)

                    if (deviceExtensionPort->PortPdoFlags &
                        PORTPDO_VALID_FOR_PNP_FUNCTION) {

                        // we have the PDO, now attempt to
                        // get the devnode name and return it

                        length = outputBufferLength -
                                    sizeof(USB_NODE_CONNECTION_DRIVERKEY_NAME);

                        ntStatus = IoGetDeviceProperty(
                            portData->DeviceObject,
                            DevicePropertyDriverKeyName,
                            length,
                            outputBuffer->DriverKeyName,
                            &length);

                        if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                            ntStatus = STATUS_SUCCESS;
                        }

                        outputBuffer->ActualLength =
                            length + sizeof(USB_NODE_CONNECTION_DRIVERKEY_NAME);

                        // see how much data we actully copied
                        if (outputBufferLength > outputBuffer->ActualLength) {
                            // user buffer is bigger, just indicate how much we copied
                            Irp->IoStatus.Information = outputBuffer->ActualLength;
                        } else {
                            // we copied as much as would fit
                            Irp->IoStatus.Information = outputBufferLength;
                        }

                    } else {
                        ntStatus = STATUS_INVALID_DEVICE_STATE;
                    }
                }
            }
        }
    } else {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_IoctlGetNodeConnectionInformation(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN BOOLEAN ExApi
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    PUSB_NODE_CONNECTION_INFORMATION_EX outputBuffer;
    ULONG outputBufferLength, length, i;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlGetNodeConnectionInformation\n"));

    portData = DeviceExtensionHub->PortData;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;
    outputBuffer = (PUSB_NODE_CONNECTION_INFORMATION_EX) Irp->AssociatedIrp.SystemBuffer;

    if (outputBufferLength >= sizeof(USB_NODE_CONNECTION_INFORMATION)) {

        ULONG index;

        USBH_KdPrint((2,"'Connection = %d\n", outputBuffer->ConnectionIndex));


        // Clear the buffer in case we don't call USBD_GetDeviceInformation
        // below, but make sure to keep the ConnectionIndex!

        index = outputBuffer->ConnectionIndex;
        RtlZeroMemory(outputBuffer, outputBufferLength);
        outputBuffer->ConnectionIndex = index;

        ntStatus = STATUS_INVALID_PARAMETER;

        for(i=1; i<=DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

            PDEVICE_EXTENSION_PORT deviceExtensionPort;

            if (i == outputBuffer->ConnectionIndex) {
                length = sizeof(USB_NODE_CONNECTION_INFORMATION);

                if (portData->DeviceObject) {

                    deviceExtensionPort = portData->DeviceObject->DeviceExtension;

                    outputBuffer->ConnectionStatus =
                        portData->ConnectionStatus;

                    outputBuffer->DeviceIsHub =
                        (deviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB)
                            ? TRUE : FALSE;
                    USBH_KdPrint((2,"'outputbuffer = %x\n", outputBuffer));

                    RtlCopyMemory(&outputBuffer->DeviceDescriptor,
                                  &deviceExtensionPort->DeviceDescriptor,
                                  sizeof(outputBuffer->DeviceDescriptor));

                    if (deviceExtensionPort->DeviceData) {
#ifdef USB2
                        USBH_KdPrint((2,"'devicedata = %x\n",
                            deviceExtensionPort->DeviceData));

                        ntStatus = USBD_GetDeviceInformationEx(
                                         deviceExtensionPort,
                                         DeviceExtensionHub,
                                         outputBuffer,
                                         outputBufferLength,
                                         deviceExtensionPort->DeviceData);
#else
                        ntStatus = USBD_GetDeviceInformation(outputBuffer,
                                         outputBufferLength,
                                         deviceExtensionPort->DeviceData);
#endif
                    } else {
                        //
                        // We have a device connected, but it failed to start.
                        // Since it hasn't started, there are no open pipes, so
                        // we don't need to get pipe information. We are going
                        // to return some relevant information, however, so
                        // return STATUS_SUCCESS.
                        //

                        ntStatus = STATUS_SUCCESS;
                    }

                    USBH_KdPrint((2,"'status from USBD_GetDeviceInformation %x\n",
                            ntStatus));

                    if (NT_SUCCESS(ntStatus)) {
                        ULONG j;

                        USBH_KdPrint((2,"'status %x \n", outputBuffer->ConnectionStatus));
    //                    USBH_KdPrint((2,"'NodeName %s\n", outputBuffer->NodeName));
                        USBH_KdPrint((2,"'PID 0x%x\n",
                            outputBuffer->DeviceDescriptor.idProduct));
                        USBH_KdPrint((2,"'VID 0x%x\n",
                            outputBuffer->DeviceDescriptor.idVendor));
                        USBH_KdPrint((2,"'Current Configuration Value 0x%x\n",
                            outputBuffer->CurrentConfigurationValue));

                        // map the speed field for the old API which returned 
                        // a BOOLEAN
                        if (!ExApi) {  
                            PUSB_NODE_CONNECTION_INFORMATION tmp =
                                (PUSB_NODE_CONNECTION_INFORMATION) outputBuffer;

                            tmp->LowSpeed = (outputBuffer->Speed == UsbLowSpeed) 
                                ? TRUE : FALSE;
                        }

                        USBH_KdPrint((2,"'Speed = %x\n", outputBuffer->Speed));
                        USBH_KdPrint((2,"'Address = %x\n", outputBuffer->DeviceAddress));

                        USBH_KdPrint((2,"'NumberOfOpenPipes = %d\n",
                            outputBuffer->NumberOfOpenPipes));

                        for(j=0; j< outputBuffer->NumberOfOpenPipes; j++) {
                            USBH_KdPrint((2,"'Max Packet %x\n",
                                outputBuffer->PipeList[j].EndpointDescriptor.wMaxPacketSize));
                            USBH_KdPrint((2,"'Interval %x \n",
                                outputBuffer->PipeList[j].EndpointDescriptor.bInterval));
                        }

                        Irp->IoStatus.Information =
                            sizeof(USB_NODE_CONNECTION_INFORMATION) +
                            sizeof(USB_PIPE_INFO) * outputBuffer->NumberOfOpenPipes;
                    } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                        Irp->IoStatus.Information =
                            sizeof(USB_NODE_CONNECTION_INFORMATION);
                        ntStatus = STATUS_SUCCESS;
                    }


                } else { //no device object

//                  This assert is no longer valid because we now support
//                  displaying the UI on device enumeration failure.
//
//                    USBH_ASSERT(portData->ConnectionStatus == NoDeviceConnected ||
//                                portData->ConnectionStatus == DeviceCausedOvercurrent);
                    outputBuffer->ConnectionStatus = portData->ConnectionStatus;
                    Irp->IoStatus.Information =
                        sizeof(USB_NODE_CONNECTION_INFORMATION);
                    ntStatus = STATUS_SUCCESS;
                }

                break;
            }

            portData++;
        } /* for */

    } else {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}

NTSTATUS
USBH_IoctlGetNodeConnectionAttributes(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    PUSB_NODE_CONNECTION_ATTRIBUTES outputBuffer;
    ULONG outputBufferLength, length, i;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlGetNodeConnectionInformation\n"));

    portData = DeviceExtensionHub->PortData;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;
    outputBuffer = (PUSB_NODE_CONNECTION_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer;

    if (outputBufferLength >= sizeof(USB_NODE_CONNECTION_ATTRIBUTES)) {

        ULONG index;

        USBH_KdPrint((2,"'Connection = %d\n", outputBuffer->ConnectionIndex));

        // Clear the buffer in case we don't call USBD_GetDeviceInformation
        // below, but make sure to keep the ConnectionIndex!

        index = outputBuffer->ConnectionIndex;
        RtlZeroMemory(outputBuffer, outputBufferLength);
        outputBuffer->ConnectionIndex = index;

        ntStatus = STATUS_INVALID_PARAMETER;

        for(i=1; i<=DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

            if (i == outputBuffer->ConnectionIndex) {

                length = sizeof(USB_NODE_CONNECTION_ATTRIBUTES);

                outputBuffer->ConnectionStatus =
                    portData->ConnectionStatus;

                USBH_KdPrint((2,"'outputbuffer = %x\n", outputBuffer));

                // map extended hub info here
                outputBuffer->PortAttributes = portData->PortAttributes;

                Irp->IoStatus.Information =
                            sizeof(USB_NODE_CONNECTION_ATTRIBUTES);
                ntStatus = STATUS_SUCCESS;

                break;
            }

            portData++;
        } /* for */

    } else {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_IoctlHubSymbolicName(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Takes as input and output a pointer to the following structure:
  *
  * typedef struct _USB_HUB_NAME {
  *     ULONG ActualLength;    // OUTPUT
  *     WCHAR HubName[1];      // OUTPUT
  * } USB_HUB_NAME;
  *
  * Arguments:
  *
  * ActualLength - The structure size in bytes necessary to hold the NULL
  * terminated symbolic link name.  This includes the entire structure, not
  * just the name.
  *
  * NodeName - The UNICODE NULL terminated symbolic link name of the external
  * hub attached to the port.  If there is no external hub attached to the port
  * a single NULL is returned.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION          ioStack;
    PUSB_HUB_NAME               outputBuffer;
    ULONG                       outputBufferLength;

    PAGED_CODE();

    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    // Get the pointer to the input/output buffer and it's length
    //
    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;

    outputBuffer = (PUSB_HUB_NAME) Irp->AssociatedIrp.SystemBuffer;

    // Make sure that the output buffer is large enough for the base
    // structure that will be returned.
    //
    if (outputBufferLength < sizeof(USB_HUB_NAME)) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        goto GetHubDone;
    }

    if ((DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) &&
        (DeviceExtensionPort->PortPdoFlags & PORTPDO_STARTED) &&
        (DeviceExtensionPort->PortPdoFlags & PORTPDO_SYM_LINK)) {

        PUNICODE_STRING hubNameUnicodeString;
        ULONG length, offset=0;
        WCHAR *pwch;


        // Device is a hub, get the name of the hub
        //
        hubNameUnicodeString = &DeviceExtensionPort->SymbolicLinkName;

        // assuming the string is \n\name strip of '\n\' where
        // n is zero or more chars

        pwch = &hubNameUnicodeString->Buffer[0];

        USBH_ASSERT(*pwch == '\\');
        if (*pwch == '\\') {
            pwch++;
            while (*pwch != '\\' && *pwch) {
                pwch++;
            }
            USBH_ASSERT(*pwch == '\\');
            if (*pwch == '\\') {
                pwch++;
            }
            offset = (ULONG)((PUCHAR)pwch -
                (PUCHAR)&hubNameUnicodeString->Buffer[0]);
        }

        // Strip off the '\DosDevices\' prefix.
        // Length does not include a terminating NULL.
        //
        length = hubNameUnicodeString->Length - offset;
        RtlZeroMemory(outputBuffer, outputBufferLength);

        if (outputBufferLength >= length +
            sizeof(USB_HUB_NAME)) {
            RtlCopyMemory(&outputBuffer->HubName[0],
                          &hubNameUnicodeString->Buffer[offset/2],
                          length);

            Irp->IoStatus.Information = length+
                                        sizeof(USB_HUB_NAME);
            outputBuffer->ActualLength = (ULONG)Irp->IoStatus.Information;
            ntStatus = STATUS_SUCCESS;

        } else {

            // Output buffer is too small to hold the entire
            // string.  Return just the length needed to hold
            // the entire string.
            //
            outputBuffer->ActualLength =
                length + sizeof(USB_HUB_NAME);

            outputBuffer->HubName[0] = (WCHAR)0;

            Irp->IoStatus.Information =  sizeof(USB_HUB_NAME);

        }

    } else {

        // Device is not a hub or does not currently have a symbolic link
        // allocated, just return a NULL terminated string.
        //
        outputBuffer->ActualLength = sizeof(USB_HUB_NAME);

        outputBuffer->HubName[0] = 0;

        Irp->IoStatus.Information = sizeof(USB_HUB_NAME);

    }

GetHubDone:

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;

}


NTSTATUS
USBH_IoctlGetNodeName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Takes as input and output a pointer to the following structure:
  *
  * typedef struct _USB_NODE_CONNECTION_NAME {
  *     ULONG ConnectionIndex;  // INPUT
  *     ULONG ActualLength;     // OUTPUT
  *     WCHAR NodeName[1];      // OUTPUT
  * } USB_NODE_CONNECTION_NAME;
  *
  * Arguments:
  *
  * ConnectionIndex - The one-based port index to which a device is attached.
  * If an external hub is attached to this port, the symbolic link name of the
  * hub will be returned, if there is sufficient buffer space.
  *
  * ActualLength - The structure size in bytes necessary to hold the NULL
  * terminated symbolic link name.  This includes the entire structure, not
  * just the name.
  *
  * NodeName - The UNICODE NULL terminated symbolic link name of the external
  * hub attached to the port.  If there is no external hub attached to the port
  * a single NULL is returned.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION          ioStack;
    PUSB_NODE_CONNECTION_NAME   outputBuffer;
    ULONG                       outputBufferLength;
    PPORT_DATA                  portData;
    PDEVICE_EXTENSION_PORT      deviceExtensionPort;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlGetNodeName\n"));

    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    // Get the pointer to the input/output buffer and it's length
    //
    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;
    outputBuffer = (PUSB_NODE_CONNECTION_NAME) Irp->AssociatedIrp.SystemBuffer;

    // Make sure that the output buffer is large enough for the base
    // structure that will be returned.
    //
    if (outputBufferLength < sizeof(USB_NODE_CONNECTION_NAME)) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        goto GetNodeNameDone;
    }

    USBH_KdPrint((2,"'Connection = %d\n", outputBuffer->ConnectionIndex));

    // Make sure that the (one-based) port index is valid.
    //
    if ((outputBuffer->ConnectionIndex == 0) ||
        (outputBuffer->ConnectionIndex >
         DeviceExtensionHub->HubDescriptor->bNumberOfPorts)) {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto GetNodeNameDone;
    }

    // Get a pointer to the data associated with the specified (one-based) port
    //

    portData = &DeviceExtensionHub->PortData[outputBuffer->ConnectionIndex - 1];

    if (portData->DeviceObject) {

        deviceExtensionPort = portData->DeviceObject->DeviceExtension;

        if ((deviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) &&
            (deviceExtensionPort->PortPdoFlags & PORTPDO_STARTED) &&
            (deviceExtensionPort->PortPdoFlags & PORTPDO_SYM_LINK)) {
            PUNICODE_STRING nodeNameUnicodeString;
            ULONG length, offset=0;
            WCHAR *pwch;


            // Device is a hub, get the name of the hub
            //
            nodeNameUnicodeString = &deviceExtensionPort->SymbolicLinkName;

            // assuming the string is \n\name strip of '\n\' where
            // n is zero or more chars

            pwch = &nodeNameUnicodeString->Buffer[0];

            USBH_ASSERT(*pwch == '\\');
            if (*pwch == '\\') {
                pwch++;
                while (*pwch != '\\' && *pwch) {
                    pwch++;
                }
                USBH_ASSERT(*pwch == '\\');
                if (*pwch == '\\') {
                    pwch++;
                }
                offset = (ULONG)((PUCHAR)pwch -
                    (PUCHAR)&nodeNameUnicodeString->Buffer[0]);
            }

            // Strip off the '\DosDevices\' prefix.
            // Length does not include a terminating NULL.
            //
            length = nodeNameUnicodeString->Length - offset;
            RtlZeroMemory(outputBuffer, outputBufferLength);

            if (outputBufferLength >= length +
                sizeof(USB_NODE_CONNECTION_NAME)) {
                RtlCopyMemory(&outputBuffer->NodeName[0],
                              &nodeNameUnicodeString->Buffer[offset/2],
                              length);

                Irp->IoStatus.Information = length+
                                            sizeof(USB_NODE_CONNECTION_NAME);
                outputBuffer->ActualLength = (ULONG)Irp->IoStatus.Information;
                ntStatus = STATUS_SUCCESS;

            } else {

                // Output buffer is too small to hold the entire
                // string.  Return just the length needed to hold
                // the entire string.
                //
                outputBuffer->ActualLength =
                    length + sizeof(USB_NODE_CONNECTION_NAME);

                outputBuffer->NodeName[0] = (WCHAR)0;

                Irp->IoStatus.Information =  sizeof(USB_NODE_CONNECTION_NAME);

            }

        } else {

            // Device is not a hub or does not currently have a symbolic link
            // allocated, just return a NULL terminated string.
            //
            outputBuffer->ActualLength = sizeof(USB_NODE_CONNECTION_NAME);

            outputBuffer->NodeName[0] = 0;

            Irp->IoStatus.Information = sizeof(USB_NODE_CONNECTION_NAME);

        }

    } else {

        // No device attached, just return a NULL terminated string.

        Irp->IoStatus.Information = sizeof(USB_NODE_CONNECTION_NAME);

        outputBuffer->ActualLength = sizeof(USB_NODE_CONNECTION_NAME);

        outputBuffer->NodeName[0] = 0;

    }

GetNodeNameDone:

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_PdoIoctlGetPortStatus(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PDEVICE_OBJECT deviceObject;
    PPORT_DATA portData;
    PULONG portStatus;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_PdoIoctlGetPortStatus DeviceExtension %x Irp %x\n",
        DeviceExtensionPort, Irp));

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;

    USBH_KdPrint((2,"'***WAIT hub mutex %x\n", deviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);
    KeWaitForSingleObject(&deviceExtensionHub->HubMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT hub mutex done %x\n", deviceExtensionHub));
    portData = &deviceExtensionHub->PortData[DeviceExtensionPort->PortNumber - 1];
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    portStatus = ioStackLocation->Parameters.Others.Argument1;

    USBH_ASSERT(portStatus != NULL);

    *portStatus = 0;

    // Refresh our notion of what the port status actually is.
    ntStatus = USBH_SyncGetPortStatus(deviceExtensionHub,
                                      DeviceExtensionPort->PortNumber,
                                      (PUCHAR) &portData->PortState,
                                      sizeof(portData->PortState));

    if (DeviceExtensionPort->PortPhysicalDeviceObject == portData->DeviceObject) {

        // translate hup port status bits
        if (portData->PortState.PortStatus & PORT_STATUS_ENABLE) {
            *portStatus |= USBD_PORT_ENABLED;
        }

        if (portData->PortState.PortStatus & PORT_STATUS_CONNECT ) {
            *portStatus |= USBD_PORT_CONNECTED;
        }
    }

    USBH_KdPrint((2,"'***RELEASE hub mutex %x\n", deviceExtensionHub));
    KeReleaseSemaphore(&deviceExtensionHub->HubMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_PdoIoctlEnablePort(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PDEVICE_OBJECT deviceObject;
    PPORT_DATA portData;
    PORT_STATE portState;

    USBH_KdPrint((2,"'USBH_PdoIoctlEnablePort DeviceExtension %x Irp %x\n",
        DeviceExtensionPort, Irp));

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;

    USBH_KdPrint((2,"'***WAIT hub mutex %x\n", deviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);
    KeWaitForSingleObject(&deviceExtensionHub->HubMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT hub mutex done %x\n", deviceExtensionHub));

    portData = &deviceExtensionHub->PortData[DeviceExtensionPort->PortNumber - 1];
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);

      // validate that there is actually a device still conected
    ntStatus = USBH_SyncGetPortStatus(deviceExtensionHub,
                                      DeviceExtensionPort->PortNumber,
                                      (PUCHAR) &portState,
                                      sizeof(portState));

    if ((NT_SUCCESS(ntStatus) &&
        (portState.PortStatus & PORT_STATUS_CONNECT))) {

        LOGENTRY(LOG_PNP, "estE",
                deviceExtensionHub,
                DeviceExtensionPort->PortNumber,
                0);
        ntStatus = USBH_SyncEnablePort(deviceExtensionHub,
                                       DeviceExtensionPort->PortNumber);
    } else {

        // error or no device connected or
        // can't be sure, fail the request

        LOGENTRY(LOG_PNP, "estx",
                deviceExtensionHub,
                DeviceExtensionPort->PortNumber,
                0);

        ntStatus = STATUS_UNSUCCESSFUL;
    }

    USBH_KdPrint((2,"'***RELEASE hub mutex %x\n", deviceExtensionHub));
    KeReleaseSemaphore(&deviceExtensionHub->HubMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_IoctlGetDescriptorForPDO(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
/* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStack;
    ULONG outputBufferLength;
    PUCHAR outputBuffer;
    PUSB_DESCRIPTOR_REQUEST request;
    PPORT_DATA portData;
    ULONG i;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_IoctlDescriptorRequest\n"));

    portData = DeviceExtensionHub->PortData;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //
    outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;
    if (outputBufferLength < sizeof(USB_DESCRIPTOR_REQUEST)) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        goto USBH_IoctlGetDescriptorForPDO_Complete;
    }

    request = (PUSB_DESCRIPTOR_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    outputBuffer = &request->Data[0];

    //
    // do some parameter checking
    //
    // the wLength in the setup packet better be the size of the
    // outputbuffer minus header
    //
    if (request->SetupPacket.wLength >
        outputBufferLength - sizeof(USB_DESCRIPTOR_REQUEST)) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        goto USBH_IoctlGetDescriptorForPDO_Complete;
    } else {
        // request won't return more than wLength
        outputBufferLength = request->SetupPacket.wLength;
    }

    // return invalid parameter if conn index is out 
    // of bounds
    ntStatus = STATUS_INVALID_PARAMETER;

    for(i=1; i<=DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

        if (i == request->ConnectionIndex) {

            PDEVICE_EXTENSION_PORT deviceExtensionPort;

            // make sure we have a valid devobj for this index
            if (portData->DeviceObject == NULL) {
                goto USBH_IoctlGetDescriptorForPDO_Complete;
            }

            deviceExtensionPort =
                portData->DeviceObject->DeviceExtension;

            if (request->SetupPacket.wValue ==
                ((USB_CONFIGURATION_DESCRIPTOR_TYPE << 8) | 0) &&
                outputBufferLength == sizeof(USB_CONFIGURATION_DESCRIPTOR)) {
                //
                // Only wants the basic configuration descriptor without the
                // rest of them tacked on (ie. interface, endpoint descriptors).
                //
                USBH_ASSERT(deviceExtensionPort->ExtensionType == EXTENSION_TYPE_PORT);

                RtlCopyMemory(outputBuffer,
                              &deviceExtensionPort->ConfigDescriptor,
                              outputBufferLength);
                Irp->IoStatus.Information =
                    outputBufferLength + sizeof(USB_DESCRIPTOR_REQUEST);
                ntStatus = STATUS_SUCCESS;                    
            } else {

                PURB urb;

                //
                // OK send the request
                //

                USBH_KdPrint((2,"'sending descriptor request for ioclt\n"));

                //
                // Allocate an Urb and descriptor buffer.
                //

                urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

                if (urb) {

                    UsbBuildGetDescriptorRequest(urb,
                                                 (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                                 request->SetupPacket.wValue >> 8,
                                                 request->SetupPacket.wValue & 0xff,
                                                 0,
                                                 outputBuffer,
                                                 NULL,
                                                 outputBufferLength,
                                                 NULL);

                    RtlCopyMemory(&urb->UrbControlDescriptorRequest.Reserved1,
                                  &request->SetupPacket.bmRequest,
                                  8);

                    ntStatus = USBH_SyncSubmitUrb(deviceExtensionPort->PortPhysicalDeviceObject, urb);

                    Irp->IoStatus.Information =
                        urb->UrbControlDescriptorRequest.TransferBufferLength +
                        sizeof(USB_DESCRIPTOR_REQUEST);

                    UsbhExFreePool(urb);

                } else {
                    USBH_KdBreak(("SyncGetDeviceConfigurationDescriptor fail alloc Urb\n"));
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            break;
        }

        portData++;

    }

USBH_IoctlGetDescriptorForPDO_Complete:

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}

NTSTATUS
USBH_PdoIoctlResetPort(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  *     driver is requesting us to reset the port to which the device
  *     is attached.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_PdoIoctlResetPort DeviceExtension %x Irp %x\n",
        DeviceExtensionPort, Irp));

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    if (!deviceExtensionHub) {
        ntStatus = STATUS_UNSUCCESSFUL;
        goto USBH_PdoIoctlResetPortExit;
    }

    USBH_KdPrint((2,"'***WAIT hub mutex %x\n", deviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(deviceExtensionHub);
    KeWaitForSingleObject(&deviceExtensionHub->HubMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT hub mutex done %x\n", deviceExtensionHub));

    portData =
        &deviceExtensionHub->PortData[DeviceExtensionPort->PortNumber - 1];

    LOGENTRY(LOG_PNP, "Drst", deviceExtensionHub,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                portData->DeviceObject);

    if (DeviceExtensionPort->PortPhysicalDeviceObject ==
        portData->DeviceObject && DeviceExtensionPort->DeviceData != NULL) {

#ifdef USB2
        USBD_RemoveDeviceEx(deviceExtensionHub,
                          DeviceExtensionPort->DeviceData,
                          deviceExtensionHub->RootHubPdo,
                          USBD_MARK_DEVICE_BUSY);
#else
        USBD_RemoveDevice(DeviceExtensionPort->DeviceData,
                          deviceExtensionHub->RootHubPdo,
                          USBD_MARK_DEVICE_BUSY);
#endif

        ntStatus = USBH_ResetDevice(deviceExtensionHub,
                                    DeviceExtensionPort->PortNumber,
                                    TRUE,
                                    0);         // RetryIteration
    } else {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    USBH_KdPrint((1,"'Warning: driver has reset the port (%x)\n",
        ntStatus));

    USBH_KdPrint((2,"'***RELEASE hub mutex %x\n", deviceExtensionHub));
    KeReleaseSemaphore(&deviceExtensionHub->HubMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);
    USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);

USBH_PdoIoctlResetPortExit:

    // Must do this before completing the IRP because client driver may want
    // to post URB transfers in the completion routine.  These transfers will
    // fail if this flag is still set.

    DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_RESET_PENDING;

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


VOID
USBH_InternalCyclePort(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /*
  * Description:
  *
  * "Cycles" the requested port, i.e. causes PnP REMOVE and reenumeration
  * of the device.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PPORT_DATA portData;
    PWCHAR sernumbuf = NULL;
    
    portData = &DeviceExtensionHub->PortData[PortNumber-1];

    LOGENTRY(LOG_PNP, "WMIo", DeviceExtensionHub,
                PortNumber,
                DeviceExtensionPort);

    // synchronize with QBR
    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    {
    PDEVICE_OBJECT pdo;
    pdo = portData->DeviceObject;
    portData->DeviceObject = NULL;
    portData->ConnectionStatus = NoDeviceConnected;

    if (pdo) {
        // device should be present if we do this
        USBH_ASSERT(PDO_EXT(pdo)->PnPFlags & PDO_PNPFLAG_DEVICE_PRESENT);
        
        InsertTailList(&DeviceExtensionHub->DeletePdoList, 
                        &PDO_EXT(pdo)->DeletePdoLink);
    }
    }

    // in some overcurrent scenarios we may not have a PDO.
    
    // this function is synchronous, so the device should have 
    // no tranfsers on completion
    if (DeviceExtensionPort) {
        USBD_RemoveDeviceEx(DeviceExtensionHub,
                            DeviceExtensionPort->DeviceData,
                            DeviceExtensionHub->RootHubPdo,
                            0);
                        
        DeviceExtensionPort->DeviceData = NULL;                          
         // this prevents resets by the client
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_CYCLED;
        // keep ref until removeal of hub OR child
        //DeviceExtensionPort->DeviceExtensionHub = NULL;

    
        // disable the port so no traffic passes to the device until reset
        USBH_SyncDisablePort(DeviceExtensionHub,
                             DeviceExtensionPort->PortNumber);
    
    
        sernumbuf = InterlockedExchangePointer(
                        &DeviceExtensionPort->SerialNumberBuffer,
                        NULL);
    }

    if (sernumbuf) {
        UsbhExFreePool(sernumbuf);
    }

    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);
    
    USBH_IoInvalidateDeviceRelations(DeviceExtensionHub->PhysicalDeviceObject,
                                     BusRelations);
}


NTSTATUS
USBH_PdoIoctlCyclePort(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  *     driver is requesting us to reset the port to which the device
  *     is attached.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    USHORT portNumber;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_PdoIoctlResetPort DeviceExtension %x Irp %x\n",
        DeviceExtensionPort, Irp));

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    portNumber = DeviceExtensionPort->PortNumber;

    USBH_InternalCyclePort(deviceExtensionHub, portNumber, DeviceExtensionPort);

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}

#ifdef WMI_SUPPORT
NTSTATUS
USBH_BuildConnectionNotification(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN PUSB_CONNECTION_NOTIFICATION Notification
    )
 /*
  * Description:
  *
  *     driver is requesting us to reset the port to which the device
  *     is attached.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS, status;
    USB_CONNECTION_STATUS connectStatus;
    USB_HUB_NAME hubName;
    PPORT_DATA portData;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;

    portData =
        &DeviceExtensionHub->PortData[PortNumber-1];

    if (portData->DeviceObject &&
        portData->ConnectionStatus != DeviceHubNestedTooDeeply) {

        deviceExtensionPort = portData->DeviceObject->DeviceExtension;
        connectStatus = UsbhGetConnectionStatus(deviceExtensionPort);
    } else {
        deviceExtensionPort = NULL;
        connectStatus = portData->ConnectionStatus;
    }

    RtlZeroMemory(Notification, sizeof(*Notification));

    Notification->ConnectionNumber = PortNumber;

    if (IS_ROOT_HUB(DeviceExtensionHub)) {
        hubName.ActualLength = sizeof(hubName) - sizeof(hubName.ActualLength);
        status = USBHUB_GetRootHubName(DeviceExtensionHub,
                                       &hubName.HubName,
                                       &hubName.ActualLength);
    } else {
        status = USBH_SyncGetHubName(DeviceExtensionHub->TopOfStackDeviceObject,
                                     &hubName,
                                     sizeof(hubName));
    }

    USBH_KdPrint((1,"'Notification, hub name length = %d\n",
        hubName.ActualLength));

    if (NT_SUCCESS(status)) {
        Notification->HubNameLength = hubName.ActualLength;
    } else {
        Notification->HubNameLength = 0;
    }

    switch(connectStatus) {
    case DeviceFailedEnumeration:
        // need to track some some reasons
        if (deviceExtensionPort) {
            Notification->EnumerationFailReason =
                deviceExtensionPort->FailReasonId;
        } else {
            Notification->EnumerationFailReason = 0;
        }
        Notification->NotificationType = EnumerationFailure;
        break;

    case DeviceCausedOvercurrent:
        Notification->NotificationType = OverCurrent;
        break;

    case DeviceNotEnoughPower:
        Notification->NotificationType = InsufficentPower;
        if (deviceExtensionPort) {
            Notification->PowerRequested =
                deviceExtensionPort->PowerRequested;
        }
        break;

    case DeviceNotEnoughBandwidth:
        Notification->NotificationType = InsufficentBandwidth;
        if (deviceExtensionPort) {
            Notification->RequestedBandwidth =
                deviceExtensionPort->RequestedBandwidth;
        }
        break;

    case DeviceHubNestedTooDeeply:
        Notification->NotificationType = HubNestedTooDeeply;
        break;

    case DeviceInLegacyHub:
        Notification->NotificationType = ModernDeviceInLegacyHub;
        break;

    case DeviceGeneralFailure:
    default:
        // nothing wrong?
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    return ntStatus;
}

#endif


NTSTATUS
USBH_PdoEvent(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber
    )
 /*
  * Description:
  *
  * Triggers a WMI event based on the current connection status of the port
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

#ifdef WMI_SUPPORT
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PPORT_DATA portData;
    PUSB_CONNECTION_NOTIFICATION notification;

    portData =
        &DeviceExtensionHub->PortData[PortNumber-1];

    if (portData->DeviceObject) {
        deviceExtensionPort = portData->DeviceObject->DeviceExtension;
    }

    USBH_KdPrint((1,"'Fire WMI Event for Port Ext %x on hub ext %x\n",
        deviceExtensionPort, DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "WMIe", DeviceExtensionHub,
                deviceExtensionPort,
                0);


    notification = ExAllocatePoolWithTag(PagedPool,
                                         sizeof(USB_CONNECTION_NOTIFICATION),
                                         USBHUB_HEAP_TAG);

    if (notification) {

        ntStatus = USBH_BuildConnectionNotification(
                        DeviceExtensionHub,
                        PortNumber,
                        notification);

        if (NT_SUCCESS(ntStatus)) {
            ntStatus = WmiFireEvent(
                                    DeviceExtensionHub->FunctionalDeviceObject,
                                    (LPGUID)&GUID_USB_WMI_STD_NOTIFICATION,
                                    0,
                                    sizeof(*notification),
                                    notification);
        } else {

            // Since we did not call WmiFireEvent then we must free the buffer
            // ourselves.

            ExFreePool(notification);
        }

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

#endif /* WMI_SUPPORT */

    return ntStatus;
}

#ifdef WMI_SUPPORT

NTSTATUS
USBH_SystemControl (
    IN  PDEVICE_EXTENSION_FDO DeviceExtensionFdo,
    IN  PIRP Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and
    call into the WMI system library and let it handle this IRP for us.

--*/
{
    SYSCTL_IRP_DISPOSITION IrpDisposition;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ntStatus = WmiSystemControl(
                &DeviceExtensionFdo->WmiLibInfo,
                DeviceExtensionFdo->FunctionalDeviceObject,
                Irp,
                &IrpDisposition);

    switch (IrpDisposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            ntStatus = USBH_PassIrp(Irp, DeviceExtensionFdo->TopOfStackDeviceObject);
            break;
        }

        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            ntStatus = USBH_PassIrp(Irp, DeviceExtensionFdo->TopOfStackDeviceObject);
            break;
        }
    }

    return(ntStatus);
}


NTSTATUS
USBH_PortSystemControl (
    IN  PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN  PIRP Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and
    call into the WMI system library and let it handle this IRP for us.

--*/
{
    SYSCTL_IRP_DISPOSITION IrpDisposition;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ntStatus = WmiSystemControl(
                &DeviceExtensionPort->WmiLibInfo,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                Irp,
                &IrpDisposition);

    switch (IrpDisposition)
    {
    case IrpNotWmi:
        // Don't change status of IRP we don't know about.
        ntStatus = Irp->IoStatus.Status;
        // fall through
    case IrpNotCompleted:
    case IrpForward:
    default:
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IrpProcessed:
        // Don't complete the IRP in this case.
        break;
    }

    return(ntStatus);
}


PDEVICE_EXTENSION_PORT
USBH_GetPortPdoExtension(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN ULONG PortNumber
    )
 /*
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PPORT_DATA portData;
    USHORT nextPortNumber;
    USHORT numberOfPorts;

    portData = DeviceExtensionHub->PortData;

    //
    // hub descriptor will be null if the hub is already stopped
    //

    if (portData &&
        DeviceExtensionHub->HubDescriptor) {

        numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

        for (nextPortNumber = 1;
             nextPortNumber <= numberOfPorts;
             nextPortNumber++, portData++) {

            USBH_KdPrint((1,"'portdata %x, do %x\n", portData, portData->DeviceObject));

            if (PortNumber == nextPortNumber) {

                if (portData->DeviceObject)
                    return portData->DeviceObject->DeviceExtension;
                else
                    return NULL;

            }
        }

    }

    return NULL;
}


VOID
USBH_CheckLeafHubsIdle(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * This function walks the chain of hubs downstream from the specified hub,
  * and idles the leaf hubs if ready.
  *
  * Arguments:
  *
  * DeviceExtensionHub
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_PORT childDeviceExtensionPort;
    PDEVICE_EXTENSION_HUB childDeviceExtensionHub;
    BOOLEAN bHaveChildrenHubs = FALSE;
    ULONG i;

    PAGED_CODE();

    // Ensure that child port configuration does not change while in this
    // function, i.e. don't allow QBR.

//    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
//    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
//    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
//                          Executive,
//                          KernelMode,
//                          FALSE,
//                          NULL);
//    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    for (i = 0; i < DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

        if (DeviceExtensionHub->PortData[i].DeviceObject) {

            childDeviceExtensionPort = DeviceExtensionHub->PortData[i].DeviceObject->DeviceExtension;

            if (childDeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) {

                PDRIVER_OBJECT hubDriver;
                PDEVICE_OBJECT childHubPdo, childHubFdo;
                 
                // We have a child hub.  This means that we are not a leaf hub.
                // Indicate this and recurse down to the child hub.

                bHaveChildrenHubs = TRUE;

                hubDriver = DeviceExtensionHub->FunctionalDeviceObject->DriverObject;
                childHubPdo = childDeviceExtensionPort->PortPhysicalDeviceObject;
 
                do {
                     childHubFdo = childHubPdo->AttachedDevice;
                     childHubPdo = childHubFdo;
                } while (childHubFdo->DriverObject != hubDriver);

                childDeviceExtensionHub = childHubFdo->DeviceExtension;
 
                USBH_CheckLeafHubsIdle(childDeviceExtensionHub);
            }
        }
    }

//    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
//    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
//                       LOW_REALTIME_PRIORITY,
//                       1,
//                       FALSE);
//
//    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    if (!bHaveChildrenHubs) {

        // If this hub has no children then it is a leaf hub.  See if
        // it is ready to be idled out.

        USBH_CheckHubIdle(DeviceExtensionHub);
    }
}


//
// WMI System Call back functions
//


NTSTATUS
USBH_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION_FDO   deviceExtensionFdo;
    PDEVICE_EXTENSION_HUB   deviceExtensionHub;
    NTSTATUS status;
    ULONG size = 0;
    BOOLEAN bEnableSS, bSelectiveSuspendEnabled = FALSE, globaDisableSS;

    deviceExtensionFdo = (PDEVICE_EXTENSION_FDO) DeviceObject->DeviceExtension;
    deviceExtensionHub = (PDEVICE_EXTENSION_HUB) DeviceObject->DeviceExtension;

    switch(GuidIndex) {
    case WMI_USB_DRIVER_INFORMATION:

        status = /*STATUS_WMI_READ_ONLY*/STATUS_INVALID_DEVICE_REQUEST;
        break;

    case WMI_USB_POWER_DEVICE_ENABLE:

        // We only support this for the Root Hub but this WMI request should
        // only occur for the Root Hub because we only register this GUID
        // for the Root Hub.  We perform a sanity check anyway.

        USBH_ASSERT(deviceExtensionFdo->ExtensionType == EXTENSION_TYPE_HUB);
        USBH_ASSERT(IS_ROOT_HUB(deviceExtensionHub));
    
        USBH_RegQueryUSBGlobalSelectiveSuspend(&globaDisableSS);
        
        if (deviceExtensionFdo->ExtensionType == EXTENSION_TYPE_HUB &&
            IS_ROOT_HUB(deviceExtensionHub) && 
            !globaDisableSS) {

            size = sizeof(BOOLEAN);

            if (BufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
            } else if (0 != InstanceIndex) {
                status = STATUS_INVALID_DEVICE_REQUEST;
            } else {
                bEnableSS = *(PBOOLEAN)Buffer;

                status = USBD_QuerySelectiveSuspendEnabled(deviceExtensionHub,
                                                    &bSelectiveSuspendEnabled);

                if (NT_SUCCESS(status) &&
                    bEnableSS != bSelectiveSuspendEnabled) {

                    // Update global flag and registry with new setting.

                    status = USBD_SetSelectiveSuspendEnabled(deviceExtensionHub,
                                                            bEnableSS);

                    if (NT_SUCCESS(status)) {

                        if (bEnableSS) {
                            // We are being asked to enable Selective Suspend
                            // when it was previously disabled.

                            // Find the end hubs in the chain and idle them
                            // out if ready.  This will trickle down to
                            // the parent hubs if all hubs are idle.

                            USBH_CheckLeafHubsIdle(deviceExtensionHub);

                            status = STATUS_SUCCESS;

                        } else {
                            // We are being asked to disable Selective Suspend
                            // when it was previously enabled.

                            if (deviceExtensionHub->CurrentPowerState != PowerDeviceD0 &&
                                (deviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

                                USBH_HubSetD0(deviceExtensionHub);
                            } else {
                                USBH_HubCompletePortIdleIrps(deviceExtensionHub,
                                                             STATUS_CANCELLED);
                            }

                            status = STATUS_SUCCESS;
                        }
                    }

                }
            }

        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                0,
                                IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
USBH_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION_FDO deviceExtensionFdo;
    PUSB_NOTIFICATION notification;
    NTSTATUS    status;
    ULONG       size = 0;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    BOOLEAN bSelectiveSuspendEnabled = FALSE,globaDisableSS;

    deviceExtensionFdo = (PDEVICE_EXTENSION_FDO) DeviceObject->DeviceExtension;
    deviceExtensionHub = (PDEVICE_EXTENSION_HUB) DeviceObject->DeviceExtension;

    notification = (PUSB_NOTIFICATION) Buffer;
    USBH_KdPrint((1,"'WMI Query Data Block on hub ext %x\n",
        deviceExtensionHub));

    switch (GuidIndex) {
    case WMI_USB_DRIVER_INFORMATION:

        if (InstanceLengthArray != NULL) {
            *InstanceLengthArray = 0;
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case WMI_USB_POWER_DEVICE_ENABLE:

        // We only support this for the Root Hub but this WMI request should
        // only occur for the Root Hub because we only register this GUID
        // for the Root Hub.  We perform a sanity check anyway.

        USBH_ASSERT(deviceExtensionFdo->ExtensionType == EXTENSION_TYPE_HUB);
        USBH_ASSERT(IS_ROOT_HUB(deviceExtensionHub));

        USBH_RegQueryUSBGlobalSelectiveSuspend(&globaDisableSS);

        if (deviceExtensionFdo->ExtensionType == EXTENSION_TYPE_HUB &&
            IS_ROOT_HUB(deviceExtensionHub) &&
            !globaDisableSS) {

            //
            // Only registers 1 instance for this GUID.
            //
            if ((0 != InstanceIndex) || (1 != InstanceCount)) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            size = sizeof(BOOLEAN);

            if (OutBufferSize < size) {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            status = USBD_QuerySelectiveSuspendEnabled(deviceExtensionHub,
                                                &bSelectiveSuspendEnabled);

            if (!NT_SUCCESS(status)) {
                break;
            }

            *(PBOOLEAN)Buffer = bSelectiveSuspendEnabled;
            *InstanceLengthArray = size;
            status = STATUS_SUCCESS;

        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                size,
                                IO_NO_INCREMENT);

    return status;
}


NTSTATUS
USBH_PortQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PUSB_DEVICE_UI_FIRMWARE_REVISION fwRevBuf;
    NTSTATUS    status;
    ULONG       size = 0;
    PWCHAR      revstr;
    USHORT      bcdDevice;
    USHORT      stringsize;

    deviceExtensionPort = (PDEVICE_EXTENSION_PORT) DeviceObject->DeviceExtension;

    USBH_KdPrint((1,"'WMI Query Data Block on PORT PDO ext %x\n",
        deviceExtensionPort));

    switch (GuidIndex) {
    case 0:

        // Return USB device FW revision # in the following format "xx.xx".
        // Need buffer large enough for this string plus NULL terminator.

        stringsize = 6 * sizeof(WCHAR);

        size = sizeof(USB_DEVICE_UI_FIRMWARE_REVISION) + (ULONG)stringsize;

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        bcdDevice = deviceExtensionPort->DeviceDescriptor.bcdDevice;

        fwRevBuf = (PUSB_DEVICE_UI_FIRMWARE_REVISION)Buffer;

        revstr = &fwRevBuf->FirmwareRevisionString[0];

        *revstr = BcdNibbleToAscii(bcdDevice >> 12);
        *(revstr+1) = BcdNibbleToAscii((bcdDevice >> 8) & 0x000f);
        *(revstr+2) = '.';
        *(revstr+3) = BcdNibbleToAscii((bcdDevice >> 4) & 0x000f);
        *(revstr+4) = BcdNibbleToAscii(bcdDevice & 0x000f);
        *(revstr+5) = 0;

        fwRevBuf->Length = stringsize;

        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;
        USBH_KdPrint((1,"'WMI Query Data Block, returning FW rev # '%ws'\n",
            revstr));
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                size,
                                IO_NO_INCREMENT);

    return status;
}


NTSTATUS
USBH_ExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being called.

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer on entry has the input data block and on return has the output
        output data block.


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION_FDO deviceExtensionFdo;
    PUSB_NOTIFICATION notification;

    NTSTATUS    ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    ULONG       size = 0;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PDEVICE_EXTENSION_PORT portPdoExt;
    BOOLEAN bDoCheckHubIdle = FALSE;

    deviceExtensionFdo = (PDEVICE_EXTENSION_FDO) DeviceObject->DeviceExtension;

    if (deviceExtensionFdo->ExtensionType == EXTENSION_TYPE_PARENT) {

        // Looks like a child PDO of a composite device is causing the problem.
        // Let's be sure to get the correct device extension for the hub.

        portPdoExt = deviceExtensionFdo->PhysicalDeviceObject->DeviceExtension;
        deviceExtensionHub = portPdoExt->DeviceExtensionHub;
    } else {
        deviceExtensionHub = (PDEVICE_EXTENSION_HUB) DeviceObject->DeviceExtension;
    }

    USBH_ASSERT(EXTENSION_TYPE_HUB == deviceExtensionHub->ExtensionType);

    // If this hub is currently Selective Suspended, then we need to
    // power up the hub first before sending any requests along to it.
    // Make sure hub has been started, though.

    if (deviceExtensionHub->CurrentPowerState != PowerDeviceD0 &&
        (deviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

        bDoCheckHubIdle = TRUE;
        USBH_HubSetD0(deviceExtensionHub);
    }

    notification = (PUSB_NOTIFICATION) Buffer;
    USBH_KdPrint((1,"'WMI Execute Method on hub ext %x\n",
        deviceExtensionHub));

    switch (GuidIndex) {
    case WMI_USB_DRIVER_INFORMATION:
        size = sizeof(*notification);
        if (OutBufferSize < size) {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        // switch(MethodId) {
        switch (notification->NotificationType) {
        case EnumerationFailure:
            {
            PUSB_CONNECTION_NOTIFICATION connectionNotification;

            USBH_KdPrint((1,"'Method EnumerationFailure %x\n"));

            connectionNotification = (PUSB_CONNECTION_NOTIFICATION) Buffer;
            size = sizeof(*connectionNotification);
            if (OutBufferSize < size) {
                USBH_KdPrint((1,"'pwr - buff too small\n"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                portPdoExt =
                    USBH_GetPortPdoExtension(deviceExtensionHub,
                                             connectionNotification->ConnectionNumber);
                if (portPdoExt) {
                    connectionNotification->EnumerationFailReason =
                        portPdoExt->FailReasonId;
                    ntStatus = STATUS_SUCCESS;
                } else {
                    USBH_KdPrint((1,"'ef - bad connection index\n"));
                    ntStatus = STATUS_INVALID_PARAMETER;
                }
            }
            }
            break;

        case InsufficentBandwidth:
            {
            PUSB_CONNECTION_NOTIFICATION connectionNotification;

            USBH_KdPrint((1,"'Method InsufficentBandwidth\n"));

            connectionNotification = (PUSB_CONNECTION_NOTIFICATION) Buffer;
            size = sizeof(*connectionNotification);
            if (OutBufferSize < size) {
                USBH_KdPrint((1,"'pwr - buff too small\n"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                portPdoExt =
                    USBH_GetPortPdoExtension(deviceExtensionHub,
                                             connectionNotification->ConnectionNumber);
                if (portPdoExt) {
                    connectionNotification->RequestedBandwidth =
                        portPdoExt->RequestedBandwidth;
                    ntStatus = STATUS_SUCCESS;
                 } else {
                    USBH_KdPrint((1,"'bw - bad connection index\n"));
                    ntStatus = STATUS_INVALID_PARAMETER;
                 }
            }
            }
            break;

        case OverCurrent:
            // nothing to do here
            USBH_KdPrint((1,"'Method OverCurrent\n"));
            ntStatus = STATUS_SUCCESS;
            size = 0;
            break;
        case InsufficentPower:
            {
            PUSB_CONNECTION_NOTIFICATION connectionNotification;

            USBH_KdPrint((1,"'Method InsufficentPower\n"));
            size = sizeof(*connectionNotification);
            if (OutBufferSize < size) {
                USBH_KdPrint((1,"'pwr - buff too small\n"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                connectionNotification = (PUSB_CONNECTION_NOTIFICATION) Buffer;
                USBH_KdPrint((1,"'pwr - connection %d\n",
                    connectionNotification->ConnectionNumber));
                if (connectionNotification->ConnectionNumber) {
                    if (portPdoExt = USBH_GetPortPdoExtension(deviceExtensionHub,
                                                              connectionNotification->ConnectionNumber)) {
                        connectionNotification->PowerRequested =
                            portPdoExt->PowerRequested;
                        ntStatus = STATUS_SUCCESS;
                    }
                } else {
                    USBH_KdPrint((1,"'pwr - bad connection index\n"));
                    ntStatus = STATUS_INVALID_PARAMETER;
                }
            }
            }
            break;
        case ResetOvercurrent:
            {
            PUSB_CONNECTION_NOTIFICATION connectionNotification;

            USBH_KdPrint((1,"'Method ResetOvercurrent\n"));
            size = sizeof(*connectionNotification);
            if (OutBufferSize < size) {
                USBH_KdPrint((1,"'reset - buff too small\n"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                connectionNotification = (PUSB_CONNECTION_NOTIFICATION) Buffer;
                if (connectionNotification->ConnectionNumber) {
                    USBH_KdPrint((1,"'reset - port %d\n", connectionNotification->ConnectionNumber));
                    portPdoExt = USBH_GetPortPdoExtension(deviceExtensionHub,
                                                          connectionNotification->ConnectionNumber);
                    ntStatus = USBH_ResetPortOvercurrent(deviceExtensionHub,
                                                         (USHORT)connectionNotification->ConnectionNumber,
                                                         portPdoExt);
//                    } else {
//                        // bad connection index
//                        USBH_KdPrint((1,"'reset - bad connection index\n"));
//                        ntStatus = STATUS_INVALID_PARAMETER;
//                    }
                } else {
                    // this is a reset for the whole hub
                    USBH_KdPrint((1,"'not implemented yet\n"));
                    TEST_TRAP();
                    ntStatus = STATUS_NOT_IMPLEMENTED;
                }
            }
            }
            break;

        case AcquireBusInfo:
            {
            PUSB_BUS_NOTIFICATION busNotification;

            USBH_KdPrint((1,"'Method AcquireBusInfo\n"));
            size = sizeof(*busNotification);
            if (OutBufferSize < size) {
                USBH_KdPrint((1,"'AcquireBusInfo - buff too small\n"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                busNotification = (PUSB_BUS_NOTIFICATION) Buffer;
//                ntStatus = USBH_SyncGetControllerInfo(
//                                deviceExtensionHub->TopOfStackDeviceObject,
//                                busNotification,
//                                sizeof(*busNotification),
//                                IOCTL_INTERNAL_USB_GET_BUS_INFO);

                ntStatus = USBHUB_GetBusInfo(deviceExtensionHub,
                                             busNotification,
                                             NULL);

                USBH_KdPrint((1,"'Notification, controller name length = %d\n",
                    busNotification->ControllerNameLength));
            }
            }
            break;

        case AcquireHubName:
            {
            PUSB_HUB_NAME hubName;
            PUSB_ACQUIRE_INFO acquireInfo;

            USBH_KdPrint((1,"'Method AcquireHubName\n"));

            size = sizeof(USB_ACQUIRE_INFO);
            acquireInfo = (PUSB_ACQUIRE_INFO) Buffer;

            if (OutBufferSize < size) {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            size = acquireInfo->TotalSize;
            hubName = (PUSB_HUB_NAME) &acquireInfo->TotalSize;
            // TotalSize contains the size of the notification type as well
            hubName->ActualLength -= sizeof(USB_NOTIFICATION_TYPE);

            if (IS_ROOT_HUB(deviceExtensionHub)) {
                hubName->ActualLength -= sizeof(hubName->ActualLength);
                ntStatus = USBHUB_GetRootHubName(deviceExtensionHub,
                                                 hubName->HubName,
                                                 &hubName->ActualLength);
//                hubName->ActualLength += sizeof(hubName->ActualLength);
            } else {
                ntStatus = USBH_SyncGetHubName(
                                deviceExtensionHub->TopOfStackDeviceObject,
                                hubName,
                                hubName->ActualLength);
            }

            // readjust to previous value
            hubName->ActualLength += sizeof(USB_NOTIFICATION_TYPE);
            }
            break;
        case AcquireControllerName:
            {
            PUSB_HUB_NAME controllerName;
            PUSB_ACQUIRE_INFO acquireInfo;

            USBH_KdPrint((1,"'Method AcquireControllerName\n"));

            size = sizeof(USB_ACQUIRE_INFO);
            acquireInfo = (PUSB_ACQUIRE_INFO) Buffer;

            if (OutBufferSize < size) {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            USBH_KdPrint((1,"'TotalSize %d\n", acquireInfo->TotalSize));
            USBH_KdPrint((1,"'NotificationType %x\n", acquireInfo->NotificationType));

            size = acquireInfo->TotalSize;
            controllerName = (PUSB_HUB_NAME) &acquireInfo->TotalSize;
            // TotalSize contains the size of the notification type as well
            controllerName->ActualLength -= sizeof(USB_NOTIFICATION_TYPE);
//            ntStatus = USBH_SyncGetControllerInfo(deviceExtensionHub->TopOfStackDeviceObject,
//                                                  controllerName,
//                                                  controllerName->ActualLength,
//                                                  IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME);

            ntStatus = USBHUB_GetControllerName(deviceExtensionHub,
                                                controllerName,
                                                controllerName->ActualLength);

            // readjust to previous value
            controllerName->ActualLength += sizeof(USB_NOTIFICATION_TYPE);

            USBH_KdPrint((1,"'Method AcquireControllerName %x - %d\n",
                acquireInfo, controllerName->ActualLength));
            }
            break;

        case HubOvercurrent:
            USBH_KdPrint((1,"'Method HubOvercurrent\n"));
            USBH_KdPrint((1,"'not implemented yet\n"));
            ntStatus = STATUS_SUCCESS;
            size = 0;
            break;

        case HubPowerChange:
            USBH_KdPrint((1,"'Method HubPowerChange\n"));
            USBH_KdPrint((1,"'not implemented yet\n"));
            ntStatus = STATUS_SUCCESS;
            size = 0;
            break;

        case HubNestedTooDeeply:
            // nothing to do here
            USBH_KdPrint((1,"'Method HubNestedTooDeeply\n"));
            ntStatus = STATUS_SUCCESS;
            size = 0;
            break;

        case ModernDeviceInLegacyHub:
            // nothing to do here
            USBH_KdPrint((1,"'Method ModernDeviceInLegacyHub\n"));
            ntStatus = STATUS_SUCCESS;
            size = 0;
            break;
        }
        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                  Irp,
                                  ntStatus,
                                  size,
                                  IO_NO_INCREMENT);

    if (bDoCheckHubIdle) {
        USBH_CheckHubIdle(deviceExtensionHub);
    }

    return ntStatus;
}

NTSTATUS
USBH_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION_HUB deviceExtensionHub;  // pointer to our device
                                               // extension

    deviceExtensionHub = (PDEVICE_EXTENSION_HUB) DeviceObject->DeviceExtension;

    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &UsbhRegistryPath;
    *Pdo = deviceExtensionHub->PhysicalDeviceObject;

    return STATUS_SUCCESS;
}

NTSTATUS
USBH_PortQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort;

    deviceExtensionPort = (PDEVICE_EXTENSION_PORT) DeviceObject->DeviceExtension;

    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &UsbhRegistryPath;
    *Pdo = deviceExtensionPort->PortPhysicalDeviceObject;

    return STATUS_SUCCESS;
}

#endif /* WMI_SUPPORT */


NTSTATUS
USBH_ResetPortOvercurrent(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /*
  * Description:
  *
  * Reset the overcurrent condition for a port
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS, status;
    PORT_STATE portState;
    PPORT_DATA portData;

    USBH_KdPrint((0,"'Reset Overcurrent for port %d\n", PortNumber));

    // we will need to re-enable and re-power the port

    ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                      PortNumber,
                                      (PUCHAR) &portState,
                                      sizeof(portState));

    //
    // port should be powered off at this point
    //
    LOGENTRY(LOG_PNP, "WMIo", DeviceExtensionHub,
                portState.PortStatus,
                portState.PortChange);

    if (portState.PortStatus & PORT_STATUS_POWER) {
        ntStatus = STATUS_INVALID_PARAMETER;
    } else {

        if (NT_SUCCESS(ntStatus) && DeviceExtensionPort) {

            // clear overcurrent Flags
            DeviceExtensionPort->PortPdoFlags &=
                 ~PORTPDO_OVERCURRENT;

        }

        // power up the port
        ntStatus = USBH_SyncPowerOnPort(DeviceExtensionHub,
                                        PortNumber,
                                        TRUE);

        USBH_InternalCyclePort(DeviceExtensionHub, PortNumber, DeviceExtensionPort);
    }

    return ntStatus;
}


NTSTATUS
USBH_CalculateInterfaceBandwidth(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PUSBD_INTERFACE_INFORMATION Interface,
    IN OUT PULONG Bandwidth // in kenr units?
    )
 /*
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG i, bw;

    // we'll need to walk through the interface
    // and figure out how much BW it requires

    for (i=0; i<Interface->NumberOfPipes; i++) {

//#ifdef USB2
//        bw = USBD_CalculateUsbBandwidthEx(
//                (ULONG) Interface->Pipes[i].MaximumPacketSize,
//                (UCHAR) Interface->Pipes[i].PipeType,
//                (BOOLEAN) (DeviceExtensionPort->PortPdoFlags &
//                            PORTPDO_LOW_SPEED_DEVICE));
//#else
        bw = USBD_CalculateUsbBandwidth(
                (ULONG) Interface->Pipes[i].MaximumPacketSize,
                (UCHAR) Interface->Pipes[i].PipeType,
                (BOOLEAN) (DeviceExtensionPort->PortPdoFlags &
                            PORTPDO_LOW_SPEED_DEVICE));
//#endif
        USBH_KdPrint((1,"'ept = %d packetsize =  %d  bw = %d\n",
            Interface->Pipes[i].PipeType,
            Interface->Pipes[i].MaximumPacketSize, bw));

        *Bandwidth += bw;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\hub.pnp\parent.c ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:

    PARENT.C

Abstract:

    This module contains code that manages composite devices on USB.

Author:

    jdunn

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */
#include <wdmguid.h>
#include "usbhub.h"


#define COMP_RESET_TIMEOUT  3000     // Timeout in ms (3 sec)


#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBH_ParentFdoStopDevice)
#pragma alloc_text(PAGE, USBH_ParentFdoRemoveDevice)
#pragma alloc_text(PAGE, UsbhParentFdoCleanup)
#pragma alloc_text(PAGE, USBH_ParentQueryBusRelations)
#pragma alloc_text(PAGE, USBH_ParentFdoStartDevice)
#pragma alloc_text(PAGE, USBH_FunctionPdoQueryId)
#pragma alloc_text(PAGE, USBH_FunctionPdoQueryDeviceText)
#pragma alloc_text(PAGE, USBH_FunctionPdoPnP)
#pragma alloc_text(PAGE, USBH_ParentCreateFunctionList)
#endif
#endif

VOID
UsbhParentFdoCleanup(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    )
 /* ++
  *
  * Description:
  *
  * This routine is called to shut down the hub.
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    PSINGLE_LIST_ENTRY listEntry;
    ULONG i;
    PDEVICE_EXTENSION_FUNCTION deviceExtensionFunction;
    KIRQL irql;
    PIRP wWIrp;

    USBH_KdPrint((2,"'UsbhParentFdoCleanup Fdo extension %x\n",
        DeviceExtensionParent));

    LOGENTRY(LOG_PNP, "pfdc", DeviceExtensionParent,
                DeviceExtensionParent->PendingWakeIrp,
                0);

    //
    // dump our wake request
    //
    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionParent->PendingWakeIrp) {
        USBH_ASSERT(DeviceExtensionParent->ParentFlags & HUBFLAG_PENDING_WAKE_IRP);

        wWIrp = DeviceExtensionParent->PendingWakeIrp;
        IoSetCancelRoutine(wWIrp, NULL);
        DeviceExtensionParent->PendingWakeIrp = NULL;
        IoReleaseCancelSpinLock(irql);

        IoCancelIrp(wWIrp);
    } else {
        IoReleaseCancelSpinLock(irql);
    }

    if (DeviceExtensionParent->ConfigurationDescriptor) {
        UsbhExFreePool(DeviceExtensionParent->ConfigurationDescriptor);
        DeviceExtensionParent->ConfigurationDescriptor = NULL;
    }

    USBH_ParentCompleteFunctionWakeIrps (DeviceExtensionParent,
                                         STATUS_DELETE_PENDING);

    do {
        listEntry = PopEntryList(&DeviceExtensionParent->FunctionList);

        LOGENTRY(LOG_PNP, "dFU1", 0, listEntry, 0);

        if (listEntry != NULL) {

            deviceExtensionFunction =
                CONTAINING_RECORD(listEntry,
                                  DEVICE_EXTENSION_FUNCTION,
                                  ListEntry);
            ASSERT_FUNCTION(deviceExtensionFunction);
            LOGENTRY(LOG_PNP, "dFUN", deviceExtensionFunction, 0, 0);

            for (i=0; i< deviceExtensionFunction->InterfaceCount; i++) {
                LOGENTRY(LOG_PNP, "dFUi", deviceExtensionFunction,
                    deviceExtensionFunction->FunctionInterfaceList[i].InterfaceInformation,
                    0);
                UsbhExFreePool(deviceExtensionFunction->FunctionInterfaceList[i].InterfaceInformation);
            }

            //
            // Sometimes the FunctionPhysicalDeviceObject == deviceExtensionFunction.
            // In other words the device object about to be deleted is the
            // same one being used.  So do not use the extions after it has been
            // deleted.
            //

            deviceObject = deviceExtensionFunction->FunctionPhysicalDeviceObject;
            deviceExtensionFunction->FunctionPhysicalDeviceObject = NULL;

            LOGENTRY(LOG_PNP, "dFUo", deviceExtensionFunction,
                    deviceObject,
                    0);

            IoDeleteDevice(deviceObject);

        }

    } while (listEntry != NULL);

    DeviceExtensionParent->NeedCleanup = FALSE;

    USBH_KdPrint((2,"'UsbhParentFdoCleanup done Fdo extension %x\n",
        DeviceExtensionParent));


    return;
}


NTSTATUS
USBH_ParentFdoRemoveDevice(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    NTSTATUS ntStatus;

    PAGED_CODE();
    deviceObject = DeviceExtensionParent->FunctionalDeviceObject;
    USBH_KdPrint((2,"'ParentFdoRemoveDevice Fdo %x\n", deviceObject));

    DeviceExtensionParent->ParentFlags |= HUBFLAG_DEVICE_STOPPING;

    //
    // see if we need cleanup
    //
    if (DeviceExtensionParent->NeedCleanup) {
        UsbhParentFdoCleanup(DeviceExtensionParent);
    }

#ifdef WMI_SUPPORT
    // de-register with WMI
    IoWMIRegistrationControl(deviceObject,
                             WMIREG_ACTION_DEREGISTER);

#endif

    //
    // And we need to pass this message on to lower level driver
    //

    // IrpAssert: Set IRP status before passing on.
    Irp->IoStatus.Status = STATUS_SUCCESS;

    ntStatus = USBH_PassIrp(Irp, DeviceExtensionParent->TopOfStackDeviceObject);

    //
    // Detach FDO from PDO
    //
    IoDetachDevice(DeviceExtensionParent->TopOfStackDeviceObject);

    // delete FDO of the parent
    IoDeleteDevice(deviceObject);

    return ntStatus;
}


NTSTATUS
USBH_ParentCreateFunctionList(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PUSBD_INTERFACE_LIST_ENTRY InterfaceList,
    IN PURB Urb
    )
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    PUSBD_INTERFACE_LIST_ENTRY interfaceList, tmp, baseInterface;
    PDEVICE_EXTENSION_FUNCTION deviceExtensionFunction;
    ULONG nameIndex = 0, numberOfInterfacesThisFunction, k;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
    UNICODE_STRING uniqueIdUnicodeString;

    PAGED_CODE();
    DeviceExtensionParent->FunctionCount = 0;
    tmp = interfaceList = InterfaceList;

    DeviceExtensionParent->FunctionList.Next = NULL;
    configurationDescriptor = DeviceExtensionParent->ConfigurationDescriptor;

    for (;;) {

        nameIndex = 0;

        if (interfaceList->InterfaceDescriptor) {

            //
            // interfaceList contains all the interfaces on the device
            // in sequential order.
            //
            //
            // We will create nodes based on the following criteria:
            //
            // For each interface create one function (node)
            //
            //
            // For Each group of class/subclass interface create one
            // node iff the class is audio
            //
            // This means:
            // **
            //  Class=1
            //      subclass=0
            //  Class=1
            //      subclass=0
            // creates 2 nodes
            //
            // ** we will only do this for the audio class
            // **
            //  Class=1
            //      subclass=0
            //  Class=2
            //      subclass=1
            // creates 2 nodes
            //
            // **
            //  Class=1
            //      subclass=0
            //  Class=1
            //      subclass=1
            // creates 1 node

            //
            // Create the node to represent this device
            //

            do {
                if (NT_SUCCESS(ntStatus)) {
                    ntStatus = IoCreateDevice(UsbhDriverObject,    // Driver Object
                                     sizeof(DEVICE_EXTENSION_FUNCTION),    // Device Extension size
                                     NULL, // Device name
                                     FILE_DEVICE_UNKNOWN,  // Device Type
                                                    // should look device
                                                    // class
                                     FILE_AUTOGENERATED_DEVICE_NAME,// Device Chars
                                     FALSE,    // Exclusive
                                     &deviceObject);  // Bus Device Object

                }
                nameIndex++;
            } while (ntStatus == STATUS_OBJECT_NAME_COLLISION);


            if (!NT_SUCCESS(ntStatus)) {
                USBH_KdTrap(("IoCreateDevice for function fail\n"));
                USBH_ASSERT(deviceObject == NULL);
                deviceExtensionFunction = NULL;
                // bail on whole node
                break;
            }

            deviceObject->StackSize =
            DeviceExtensionParent->TopOfStackDeviceObject->StackSize + 1;
                USBH_KdPrint((2,"'CreateFunctionPdo StackSize=%d\n", deviceObject->StackSize));

            deviceExtensionFunction =
                    (PDEVICE_EXTENSION_FUNCTION) deviceObject->DeviceExtension;

            RtlFillMemory(deviceExtensionFunction,
                          sizeof(PDEVICE_EXTENSION_FUNCTION),
                          0);

            //
            // initialize this function extension
            //
            deviceExtensionFunction->ConfigurationHandle =
                Urb->UrbSelectConfiguration.ConfigurationHandle;

            deviceExtensionFunction->FunctionPhysicalDeviceObject =
                deviceObject;

            deviceExtensionFunction->ExtensionType =
                EXTENSION_TYPE_FUNCTION;

            deviceExtensionFunction->DeviceExtensionParent =
                DeviceExtensionParent;

            //
            // remember the base interface for this function
            //
            baseInterface = interfaceList;

            USBH_KdPrint((2,"baseInterface = %x config descr = %x\n",
                baseInterface, configurationDescriptor));

            //
            // now compile the group of interfaces that will make up
            // this function.
            //
            {
            PUSBD_INTERFACE_LIST_ENTRY interface;

            interface = interfaceList;
            interface++;

            numberOfInterfacesThisFunction = 1;
            while (interface->InterfaceDescriptor) {
                if ((interface->InterfaceDescriptor->bInterfaceClass !=
                     baseInterface->InterfaceDescriptor->bInterfaceClass) ||
                    (interface->InterfaceDescriptor->bInterfaceSubClass ==
                     baseInterface->InterfaceDescriptor->bInterfaceSubClass) ||
                    (interface->InterfaceDescriptor->bInterfaceClass !=
                     USB_DEVICE_CLASS_AUDIO)) {
                    break;
                }
                numberOfInterfacesThisFunction++;
                interface++;
            }

            USBH_ASSERT(numberOfInterfacesThisFunction <=
                USBH_MAX_FUNCTION_INTERFACES);

            }

            //
            // now we know how many interfaces we are dealing with
            //

            deviceExtensionFunction->InterfaceCount = 0;

            for (k=0; k< numberOfInterfacesThisFunction; k++) {

                PFUNCTION_INTERFACE functionInterface;

                functionInterface =
                    &deviceExtensionFunction->FunctionInterfaceList[deviceExtensionFunction->InterfaceCount];

                if (functionInterface->InterfaceInformation =
                    UsbhExAllocatePool(NonPagedPool,
                                       interfaceList->Interface->Length)) {

                    RtlCopyMemory(functionInterface->InterfaceInformation,
                                  interfaceList->Interface,
                                  interfaceList->Interface->Length);

                    functionInterface->InterfaceDescriptor
                        = interfaceList->InterfaceDescriptor;

                    //
                    // calculate the length of this interface now
                    //
                    // the length of the descriptor is the difference
                    // between the start of this interface and the
                    // start of the next one.
                    //

                    {
                    PUCHAR start, end;
                    PUSBD_INTERFACE_LIST_ENTRY tmp;

                    tmp = interfaceList;
                    tmp++;

                    end = (PUCHAR) configurationDescriptor;
                    end += configurationDescriptor->wTotalLength;

                    start = (PUCHAR) functionInterface->InterfaceDescriptor;

                    if (tmp->InterfaceDescriptor) {
                        end = (PUCHAR) tmp->InterfaceDescriptor;
                    }

                    USBH_ASSERT(end > start);
                    functionInterface->InterfaceDescriptorLength =
                        (ULONG)(end - start);
                    }

                    USBH_KdPrint((2,"functionInterface = %x\n",
                        functionInterface));

                    deviceExtensionFunction->InterfaceCount++;
                } else {
                    USBH_KdTrap(("failure to create function interface\n"));
                }

                interfaceList++;
            }

            //
            // use the interface number from our 'base' interface
            // for the unique id
            //

            RtlInitUnicodeString(&uniqueIdUnicodeString,
                     &deviceExtensionFunction->UniqueIdString[0]);

            uniqueIdUnicodeString.MaximumLength =
                     sizeof(deviceExtensionFunction->UniqueIdString);

            ntStatus = RtlIntegerToUnicodeString(
                (ULONG) baseInterface->InterfaceDescriptor->bInterfaceNumber,
                10,
                &uniqueIdUnicodeString);

            //
            // add this function to the list
            //

            DeviceExtensionParent->FunctionCount++;

            PushEntryList(&DeviceExtensionParent->FunctionList,
                          &deviceExtensionFunction->ListEntry);

            USBH_KdPrint((2,"deviceExtensionFunction = %x\n", deviceExtensionFunction));

            deviceObject->Flags |= DO_POWER_PAGABLE;
            deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        } else {
            // end of interface list
            break;
        }
    } /* for */

    return STATUS_SUCCESS;
}


NTSTATUS
USBH_ParentFdoStopDevice(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    NTSTATUS ntStatus;

    PAGED_CODE();
    deviceObject = DeviceExtensionParent->FunctionalDeviceObject;
    USBH_KdPrint((2,"'ParentFdoStopDevice Fdo %x\n", deviceObject));

    //
    // set the device to the unconfigured state
    //
    ntStatus = USBH_CloseConfiguration((PDEVICE_EXTENSION_FDO) DeviceExtensionParent);

    //
    // And we need to pass this message on to lower level driver
    //

    ntStatus = USBH_PassIrp(Irp, DeviceExtensionParent->TopOfStackDeviceObject);

    return ntStatus;
}


NTSTATUS
USBH_ParentFdoStartDevice(
    IN OUT PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp,
    IN BOOLEAN NewList
    )
 /* ++ Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS ntStatus;
    PURB urb = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY interfaceList, tmp;
    LONG numberOfInterfaces, interfaceNumber, i;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
    ULONG nameIndex = 0;
    DEVICE_CAPABILITIES deviceCapabilities;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter Parent StartDevice\n"));
    USBH_ASSERT(EXTENSION_TYPE_PARENT == DeviceExtensionParent->ExtensionType);


    KeInitializeEvent(&DeviceExtensionParent->PnpStartEvent, NotificationEvent, FALSE);

    USBH_KdPrint((2,"'Set PnPIrp Completion Routine\n"));

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           USBH_PnPIrp_Complete,
                           // always pass FDO to completion routine
                           DeviceExtensionParent,
                           TRUE,
                           TRUE,
                           TRUE);

    IoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject,
                 Irp);


    KeWaitForSingleObject(&DeviceExtensionParent->PnpStartEvent,
                          Suspended,
                          KernelMode,
                          FALSE,
                          NULL);

    DeviceExtensionParent->NeedCleanup = FALSE;

    // WARN STARTS OF OLD GENERIC PARENT

    UsbhWarning(NULL,
                "This device is using obsolete USB Generic Parent!\nPlease fix your INF file.\n",
                TRUE);

//    ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
//    goto USBH_ParentFdoStartDevice_Done;


    // END WARN STARTS OF OLD GENERIC PARENT


    //
    // configure the device
    //

    // Initialize DeviceCapabilities structure in case USBH_QueryCapabilities
    // is unsuccessful.

    RtlZeroMemory(&deviceCapabilities, sizeof(DEVICE_CAPABILITIES));

    USBH_QueryCapabilities(DeviceExtensionParent->TopOfStackDeviceObject,
                           &deviceCapabilities);
    //
    // save the system state mapping
    //

    RtlCopyMemory(&DeviceExtensionParent->DeviceState[0],
                  &deviceCapabilities.DeviceState[0],
                  sizeof(DeviceExtensionParent->DeviceState));

    // always enabled for wakeup
    DeviceExtensionParent->ParentFlags |= HUBFLAG_ENABLED_FOR_WAKEUP;

    DeviceExtensionParent->DeviceWake = deviceCapabilities.DeviceWake;
    DeviceExtensionParent->SystemWake = deviceCapabilities.SystemWake;
    DeviceExtensionParent->CurrentPowerState = PowerDeviceD0;

    KeInitializeSemaphore(&DeviceExtensionParent->ParentMutex, 1, 1);

    ntStatus = USBH_GetDeviceDescriptor(DeviceExtensionParent->FunctionalDeviceObject,
                                        &DeviceExtensionParent->DeviceDescriptor);

    if (!NT_SUCCESS(ntStatus)) {
        goto USBH_ParentFdoStartDevice_Done;
    }

    if (NewList) {
        ntStatus =
            USBH_GetConfigurationDescriptor(DeviceExtensionParent->FunctionalDeviceObject,
                                            &configurationDescriptor);
    } else {
        //
        // use the old config descriptor if this is a re-start
        // the reason is that our interface structures in the function
        // extension point in to this same buffer.

        configurationDescriptor =
            DeviceExtensionParent->ConfigurationDescriptor;
    }


    if (!NT_SUCCESS(ntStatus)) {
        goto USBH_ParentFdoStartDevice_Done;
    }

    DeviceExtensionParent->ConfigurationDescriptor =
        configurationDescriptor;

    // we will likely define some registry keys to guide us
    // in the configuration of the device -- the default will
    // be to select the first congiguration and the first
    // alternate interface for each interface.
    //

    USBH_KdPrint((2,"' Parent StartDevice cd = %x\n",
        configurationDescriptor));

    DeviceExtensionParent->CurrentConfig =
        configurationDescriptor->bConfigurationValue;

    //
    // Build an interface list structure, this is an array
    // of strucutres for each interface on the device.
    // We keep a pointer to the interface descriptor for each interface
    // within the configuration descriptor
    //

    numberOfInterfaces = configurationDescriptor->bNumInterfaces;

    tmp = interfaceList =
        UsbhExAllocatePool(PagedPool, sizeof(USBD_INTERFACE_LIST_ENTRY) *
                       (numberOfInterfaces+1));

    if (tmp == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBH_ParentFdoStartDevice_Done;
    }

    //
    // just grab the first alt setting we find for each interface
    //

    i = interfaceNumber = 0;

    while (i< numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                        configurationDescriptor,
                        configurationDescriptor,
                        interfaceNumber,
                        0, // assume alt setting zero here
                        -1,
                        -1,
                        -1);

        if (interfaceDescriptor) {
            interfaceList->InterfaceDescriptor =
                interfaceDescriptor;
            interfaceList++;
            i++;
        }

        interfaceNumber++;
    }

    //
    // terminate the list
    //
    interfaceList->InterfaceDescriptor = NULL;

    urb = USBD_CreateConfigurationRequestEx(configurationDescriptor,
                                            tmp);

    if (urb) {

        ntStatus = USBH_FdoSyncSubmitUrb(DeviceExtensionParent->FunctionalDeviceObject, urb);

        if (NT_SUCCESS(ntStatus)) {
            if (NewList) {

                //
                // first time create our function list
                //

                ntStatus = USBH_ParentCreateFunctionList(
                                DeviceExtensionParent,
                                tmp,
                                urb);
            } else {

                //
                // update our function list with the new handles
                //

                PDEVICE_OBJECT deviceObject;
                PSINGLE_LIST_ENTRY listEntry;
                SINGLE_LIST_ENTRY tempList;
                ULONG i;
                PDEVICE_EXTENSION_FUNCTION deviceExtensionFunction;

                USBH_KdBreak(("re-init function list %x\n",
                        DeviceExtensionParent));

                deviceObject = DeviceExtensionParent->FunctionalDeviceObject;

                tempList.Next = NULL;
                //
                // process all entries in the function list
                //
                do {
                    listEntry = PopEntryList(&DeviceExtensionParent->FunctionList);

                    if (listEntry != NULL) {
                        PushEntryList(&tempList, listEntry);

                        deviceExtensionFunction =
                            CONTAINING_RECORD(listEntry,
                                              DEVICE_EXTENSION_FUNCTION,
                                              ListEntry);

                        USBH_KdPrint((2,"'re-init function %x\n",
                            deviceExtensionFunction));

                        deviceExtensionFunction->ConfigurationHandle =
                            urb->UrbSelectConfiguration.ConfigurationHandle;

                        for (i=0; i< deviceExtensionFunction->InterfaceCount; i++) {
                            //
                            // now we need to find the matching interface
                            // information from the new configuration request
                            // and attach it to the function

                            {
                            PUSBD_INTERFACE_INFORMATION interfaceInformation;

                            interfaceInformation =
                                deviceExtensionFunction->FunctionInterfaceList[i].InterfaceInformation;

                            interfaceList = tmp;
                            while (interfaceList->InterfaceDescriptor) {

                                PFUNCTION_INTERFACE functionInterface;

                                functionInterface =
                                     &deviceExtensionFunction->FunctionInterfaceList[i];

                                if (interfaceList->InterfaceDescriptor->bInterfaceNumber
                                     == interfaceInformation->InterfaceNumber) {

                                    USBH_KdPrint((2,
                                        "'re-init matched interface %d %x %x\n",
                                        interfaceInformation->InterfaceNumber,
                                        interfaceList,
                                        interfaceInformation));

                                    if (interfaceList->InterfaceDescriptor->bAlternateSetting !=
                                        interfaceInformation->AlternateSetting) {

                                        USBH_KdPrint((2,
                                            "'re-init no match alt interface %d %x %x\n",
                                            interfaceInformation->InterfaceNumber,
                                            interfaceList,
                                            interfaceInformation));

                                        // we have a different alt setting
                                        // switch our info to match the new
                                        // setting

                                        UsbhExFreePool(interfaceInformation);

                                        interfaceInformation =
                                            functionInterface ->InterfaceInformation =
                                            UsbhExAllocatePool(NonPagedPool,
                                                               interfaceList->Interface->Length);

                                        if (interfaceInformation) {
                                            RtlCopyMemory(interfaceInformation,
                                                          interfaceList->Interface,
                                                          interfaceList->Interface->Length);

                                            functionInterface->InterfaceDescriptor =
                                                interfaceList->InterfaceDescriptor;
                                        }
                                    } else {

                                        USBH_KdPrint((2,
                                            "'re-init matched alt interface %d %x %x\n",
                                            interfaceInformation->InterfaceNumber,
                                            interfaceList,
                                            interfaceInformation));

                                        USBH_ASSERT(interfaceList->Interface->Length ==
                                               interfaceInformation->Length);
                                        RtlCopyMemory(interfaceInformation,
                                                      interfaceList->Interface,
                                                      interfaceList->Interface->Length);
                                    }
                                    break;
                                }
                                interfaceList++;
                            }
                            }
                        }
                    }

                } while (listEntry != NULL);

                // now put the entries back
                do {
                    listEntry = PopEntryList(&tempList);
                    if (listEntry != NULL) {
                        PushEntryList(&DeviceExtensionParent->FunctionList, listEntry);
                    }
                } while (listEntry != NULL);
            }
        }

        ExFreePool(urb);

        //
        // Tell the OS that this PDO can have kids.
        //
//
// Workaround for PnP bug #406381 - RC3SS: Bluescreen failure when
//                                  installing/deinstalling communication ports
//
//===== Assigned by santoshj on 09/23/99 10:27:20 to kenray =====
// This is a race condition between IopInitializeSystemDrivers and
// IoInvalidateDeviceRelations. The real fix is too big a change at this
// stage of the product and has potential of exposing other problems. This
// problem can be solved if USBHUB does not invalidate device relations on
// every start which is redundant anyway (and also exposes this bug).
//
//        USBH_IoInvalidateDeviceRelations(DeviceExtensionParent->PhysicalDeviceObject,
//                                         BusRelations);

        DeviceExtensionParent->NeedCleanup = TRUE;

    } else {
        // failed to allocate URB
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    UsbhExFreePool(tmp);

USBH_ParentFdoStartDevice_Done:

    //
    // complete the start Irp now since we pended it with
    // our completion handler.
    //

    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


NTSTATUS
USBH_ParentQueryBusRelations(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This function responds to Bus_Reference_Next_Device, Bus_Query_Bus_Check,
  * //Bus_Query_Id: Bus_Id, HardwareIDs, CompatibleIDs and InstanceID.
  *
  * Arguments:
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    PIO_STACK_LOCATION ioStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_RELATIONS deviceRelations;
    PDEVICE_OBJECT deviceObject;
    PSINGLE_LIST_ENTRY listEntry;
    PDEVICE_EXTENSION_FUNCTION deviceExtensionFunction;

    PAGED_CODE();


    USBH_KdPrint((1, "'Query Bus Relations (PAR) %x\n",
        DeviceExtensionParent->PhysicalDeviceObject));

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    USBH_KdPrint((2,"'QueryBusRelations (parent) ext = %x\n", DeviceExtensionParent));
    USBH_KdPrint((2,"'QueryBusRelations (parent) %x\n", ioStack->Parameters.QueryDeviceRelations.Type));

    USBH_ASSERT(ioStack->Parameters.QueryDeviceRelations.Type == BusRelations);

    USBH_KdPrint((2,"'ParentQueryBusRelations enumerate device\n"));

    //
    // It should be Function device object.
    //

    USBH_ASSERT(EXTENSION_TYPE_PARENT == DeviceExtensionParent->ExtensionType);

    //
    // Must use ExAllocatePool directly here because the OS
    // will free the buffer
    //
    deviceRelations = ExAllocatePoolWithTag(PagedPool, sizeof(*deviceRelations) +
        (DeviceExtensionParent->FunctionCount - 1) * sizeof(PDEVICE_OBJECT),
        USBHUB_HEAP_TAG);

    if (deviceRelations == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBH_ParentQueryBusRelations_Done;
    }

    deviceRelations->Count = 0;

    //
    // Functions on a composite device are always present
    // we just need to return the PDO
    //

    listEntry = DeviceExtensionParent->FunctionList.Next;

    while (listEntry) {

        deviceExtensionFunction =
             CONTAINING_RECORD(listEntry,
                               DEVICE_EXTENSION_FUNCTION,
                               ListEntry);

        USBH_KdPrint((2,"'deviceExtensionFunction = %x\n", deviceExtensionFunction));

        deviceObject = deviceExtensionFunction->FunctionPhysicalDeviceObject;
        ObReferenceObject(deviceObject);
        deviceObject->Flags |= DO_POWER_PAGABLE;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        deviceRelations->Objects[deviceRelations->Count] = deviceObject;
        deviceRelations->Count++;

        listEntry = listEntry->Next;
    }

USBH_ParentQueryBusRelations_Done:

    Irp->IoStatus.Information=(ULONG_PTR) deviceRelations;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    USBH_KdPrint((1, "'Query Bus Relations (PAR) %x pass on\n",
        DeviceExtensionParent->PhysicalDeviceObject));

    ntStatus = USBH_PassIrp(Irp,
                            DeviceExtensionParent->TopOfStackDeviceObject);

    return ntStatus;
}


NTSTATUS
USBH_FunctionPdoQueryId(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IRP_MJ_PNP, IRP_MN_QUERY_ID.
  *
  * Arguments:
  *
  * DeviceExtensionPort - should be the PDO we created for the port device Irp
  * - the Irp
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    PIO_STACK_LOCATION       ioStack;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PDEVICE_EXTENSION_PORT   deviceExtensionPort;
    PDEVICE_EXTENSION_HUB    deviceExtensionHub;
#ifdef USB2
//    ULONG                    diagnosticFlags;
#else
    PUSBD_EXTENSION          deviceExtensionUsbd;
#endif
    USHORT                   idVendor;
    USHORT                   idProduct;
    LONG                     miId;
    NTSTATUS                 ntStatus = STATUS_SUCCESS;
    BOOLEAN                  diagnosticMode;

    PAGED_CODE();
    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;

    ioStack = IoGetCurrentIrpStackLocation(Irp);

    USBH_KdPrint((2,"'IRP_MN_QUERY_ID function Pdo extension=%x\n", DeviceExtensionFunction));

    //
    // It should be physical device object.
    //

    USBH_ASSERT(EXTENSION_TYPE_FUNCTION == DeviceExtensionFunction->ExtensionType);

    // It might not be too clean to reach into the RootHubPdo USBD extension,
    // but there doesn't seem to be any other easy way to determine if diag
    // mode is on.  If diagnostic mode is on, report the VID & PID as 0xFFFF
    // so that the diagnostic driver gets loaded for each interface of the
    // device.
    //
    deviceExtensionPort = (PDEVICE_EXTENSION_PORT)deviceExtensionParent->PhysicalDeviceObject->DeviceExtension;
    deviceExtensionHub = deviceExtensionPort->DeviceExtensionHub;

#ifdef USB2
//    diagnosticFlags = USBD_GetHackFlags(deviceExtensionHub);
//    diagnosticMode = (BOOLEAN)(USBD_DEVHACK_SET_DIAG_ID & diagnosticFlags);
    diagnosticMode = FALSE;
#else
    deviceExtensionUsbd = ((PUSBD_EXTENSION)deviceExtensionHub->RootHubPdo->DeviceExtension)->TrueDeviceExtension;
    diagnosticMode = deviceExtensionUsbd->DiagnosticMode;
#endif

    if (diagnosticMode)
    {
        idVendor  = 0xFFFF;
        idProduct = 0xFFFF;
        miId      = -1;
    }
    else
    {
        idVendor  = deviceExtensionParent->DeviceDescriptor.idVendor;
        idProduct = deviceExtensionParent->DeviceDescriptor.idProduct;
        miId      = DeviceExtensionFunction->FunctionInterfaceList[0].InterfaceInformation->InterfaceNumber;
    }

    switch (ioStack->Parameters.QueryId.IdType) {
    case BusQueryDeviceID:
        Irp->IoStatus.Information =
          (ULONG_PTR)
          USBH_BuildDeviceID(idVendor,
                             idProduct,
                             miId,
                             FALSE);
        break;

    case BusQueryHardwareIDs:

        Irp->IoStatus.Information =
            (ULONG_PTR)
            USBH_BuildHardwareIDs(idVendor,
                                  idProduct,
                                  deviceExtensionParent->DeviceDescriptor.bcdDevice,
                                  miId,
                                  FALSE);

        break;

    case BusQueryCompatibleIDs:
        //
        // always use first interface
        //
        Irp->IoStatus.Information =
            (ULONG_PTR) USBH_BuildCompatibleIDs(
                "",
                "",
                DeviceExtensionFunction->FunctionInterfaceList[0].InterfaceInformation->Class,
                DeviceExtensionFunction->FunctionInterfaceList[0].InterfaceInformation->SubClass,
                DeviceExtensionFunction->FunctionInterfaceList[0].InterfaceInformation->Protocol,
                FALSE,
                FALSE);

        break;

    case BusQueryInstanceID:

        Irp->IoStatus.Information =
            (ULONG_PTR) USBH_BuildInstanceID(&DeviceExtensionFunction->UniqueIdString[0],
                                         sizeof(DeviceExtensionFunction->UniqueIdString));
        break;

    default:
        USBH_KdBreak(("PdoBusExtension Unknown BusQueryId\n"));
        // IrpAssert: Must not change Irp->IoStatus.Status for bogus IdTypes,
        // so return original status here.
        return Irp->IoStatus.Status;
    }

    if (Irp->IoStatus.Information == 0) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
USBH_FunctionPdoQueryDeviceText(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES).
  * Supposedly, this is a message forwarded by port device Fdo.
  *
  * Argument:
  *
  * DeviceExtensionPort - This is a a Pdo extension we created for the port
  * device. Irp - the request
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION ioStack;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    DEVICE_TEXT_TYPE deviceTextType;
    LANGID languageId;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STRING_DESCRIPTOR usbString;
    PWCHAR deviceText;

    PAGED_CODE();
    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;
    deviceExtensionPort = (PDEVICE_EXTENSION_PORT)deviceExtensionParent->PhysicalDeviceObject->DeviceExtension;
    deviceObject = deviceExtensionPort->PortPhysicalDeviceObject;
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    deviceExtensionHub = deviceExtensionPort->DeviceExtensionHub;

    deviceTextType = ioStack->
            Parameters.QueryDeviceText.DeviceTextType;

    // Validate DeviceTextType for IrpAssert

    if (deviceTextType != DeviceTextDescription &&
        deviceTextType != DeviceTextLocationInformation) {

        USBH_KdPrint((2, "'PdoQueryDeviceText called with bogus DeviceTextType\n"));
        //
        // return the original status passed to us
        //
        ntStatus = Irp->IoStatus.Status;
        goto USBH_FunctionPdoQueryDeviceTextDone;
    }

    // we don't care about the hiword
    //languageId = (USHORT) (ioStack->Parameters.QueryDeviceText.LocaleId >>16);
    // always specify english for now.
    languageId = 0x0409;
    USBH_KdPrint((2,"'PdoQueryDeviceText Pdo %x type = %x, lang = %x locale %x\n",
            deviceObject, deviceTextType, languageId, ioStack->Parameters.QueryDeviceText.LocaleId));

    //
    // see if the device supports strings, for non complient device mode
    // we won't even try
    //

    if (deviceExtensionPort->DeviceData == NULL ||
        deviceExtensionPort->DeviceDescriptor.iProduct == 0 ||
        (deviceExtensionPort->DeviceHackFlags & USBD_DEVHACK_DISABLE_SN) ||
        (deviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_ENUM_ERROR)) {
        // string descriptor
        USBH_KdBreak(("no product string\n", deviceObject));
        ntStatus = STATUS_NOT_SUPPORTED;
    }

    if (NT_SUCCESS(ntStatus)) {

        usbString = UsbhExAllocatePool(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);

        if (usbString) {

            ntStatus = USBH_CheckDeviceLanguage(deviceObject,
                                                languageId);

            if (NT_SUCCESS(ntStatus)) {
                //
                // device supports are language, get the string
                //

                ntStatus = USBH_SyncGetStringDescriptor(deviceObject,
                                                        deviceExtensionPort->DeviceDescriptor.iProduct, //index
                                                        languageId, //langid
                                                        usbString,
                                                        MAXIMUM_USB_STRING_LENGTH,
                                                        NULL,
                                                        TRUE);

                if (NT_SUCCESS(ntStatus) &&
                    usbString->bLength <= sizeof(UNICODE_NULL)) {

                    ntStatus = STATUS_UNSUCCESSFUL;
                }

                if (NT_SUCCESS(ntStatus)) {
                    //
                    // return the string
                    //

                    //
                    // must use stock alloc function because the caller frees the
                    // buffer
                    //
                    // note: the descriptor header is the same size as
                    // a unicode NULL so we don't have to adjust the size
                    //

                    deviceText = ExAllocatePoolWithTag(PagedPool, usbString->bLength, USBHUB_HEAP_TAG);
                    if (deviceText) {
                        RtlZeroMemory(deviceText, usbString->bLength);
                        RtlCopyMemory(deviceText, &usbString->bString[0],
                            usbString->bLength - sizeof(UNICODE_NULL));

                        Irp->IoStatus.Information = (ULONG_PTR) deviceText;

                        USBH_KdBreak(("Returning Device Text %x\n", deviceText));
                    } else {
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }

            UsbhExFreePool(usbString);
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

USBH_FunctionPdoQueryDeviceTextDone:

    return ntStatus;
}


NTSTATUS
USBH_FunctionPdoPnP(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp,
    IN UCHAR MinorFunction,
    IN OUT PBOOLEAN IrpNeedsCompletion
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl PnPPower for the PDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO extension Irp - the request packet
  * uchMinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
#if DBG
    PDEVICE_OBJECT deviceObject = DeviceExtensionFunction->FunctionPhysicalDeviceObject;
#endif
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    *IrpNeedsCompletion = TRUE;

    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    USBH_KdPrint((2,"'PnP Power Pdo %x minor %x\n", deviceObject, MinorFunction));

    switch (MinorFunction) {
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
// Ken says take this out
//    case IRP_MN_SURPRISE_REMOVAL:
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_START_DEVICE:
        USBH_KdPrint((1,
            "'Starting composite PDO %x\n",
                DeviceExtensionFunction->FunctionPhysicalDeviceObject));

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:
        USBH_KdPrint((1,
            "'Stopping composite PDO %x\n",
                DeviceExtensionFunction->FunctionPhysicalDeviceObject));

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_REMOVE_DEVICE:
        USBH_KdPrint((1,
            "'Removing composite PDO %x\n",
                DeviceExtensionFunction->FunctionPhysicalDeviceObject));

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_CAPABILITIES:
        {
        PDEVICE_CAPABILITIES deviceCapabilities;
        PIO_STACK_LOCATION ioStack;

        USBH_KdPrint((2,"'IRP_MN_QUERY_CAPABILITIES Function Pdo %x\n", deviceObject));
        ntStatus = STATUS_SUCCESS;

        ioStack = IoGetCurrentIrpStackLocation(Irp);

        deviceCapabilities = ioStack->
            Parameters.DeviceCapabilities.Capabilities;
        //
        // clone the capabilities for the parent
        //
        //

        // fill in the the device state capabilities from the
        // table we saved from the pdo.
        //

        RtlCopyMemory(&deviceCapabilities->DeviceState[0],
                      &deviceExtensionParent->DeviceState[0],
                      sizeof(deviceExtensionParent->DeviceState));

        //
        // clone the device wake capabilities for children
        // from the parent.
        //
        deviceCapabilities->DeviceWake =
            deviceExtensionParent->DeviceWake;
        deviceCapabilities->SystemWake =
            deviceExtensionParent->SystemWake;

        //
        // we will need to modify these based on information
        // returned in the power descriptor
        //

        deviceCapabilities->Removable = FALSE;
        deviceCapabilities->UniqueID = FALSE;
//      SurpriseRemovalOK is FALSE by default, and some clients (NDIS)
//      set it to true on the way down, in accordance with the DDK.
//        deviceCapabilities->SurpriseRemovalOK = FALSE;
        deviceCapabilities->RawDeviceOK = FALSE;

        }
        break;

    case IRP_MN_QUERY_ID:
        USBH_KdPrint((2,"'IRP_MN_QUERY_ID Pdo %x\n", deviceObject));
        ntStatus = USBH_FunctionPdoQueryId(DeviceExtensionFunction, Irp);
        break;

    case IRP_MN_QUERY_DEVICE_TEXT:
        USBH_KdPrint((2,"'IRP_MN_QUERY_DEVICE_TEXT Pdo %x\n", deviceObject));
        ntStatus = USBH_FunctionPdoQueryDeviceText(DeviceExtensionFunction, Irp);
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        // this is a leaf node, we return the status passed
        // to us unless it is a call to TargetRelations
        if (irpStack->Parameters.QueryDeviceRelations.Type ==
            TargetDeviceRelation) {

            PDEVICE_RELATIONS deviceRelations = NULL;


            deviceRelations = ExAllocatePoolWithTag(PagedPool,
                sizeof(*deviceRelations), USBHUB_HEAP_TAG);

            if (deviceRelations == NULL) {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                ObReferenceObject(
                    DeviceExtensionFunction->FunctionPhysicalDeviceObject);
                deviceRelations->Count = 1;
                deviceRelations->Objects[0] =
                    DeviceExtensionFunction->FunctionPhysicalDeviceObject;
                ntStatus = STATUS_SUCCESS;
            }

            USBH_KdPrint((1, "'Query Target Relations (FUN) PDO %x complt\n",
                DeviceExtensionFunction->FunctionPhysicalDeviceObject));


            Irp->IoStatus.Information=(ULONG_PTR) deviceRelations;

        } else {
            ntStatus = Irp->IoStatus.Status;
        }
        break;

    case IRP_MN_QUERY_INTERFACE:

        USBH_KdPrint((1,"'IRP_MN_QUERY_INTERFACE, xface type: %x\n",
            irpStack->Parameters.QueryInterface.InterfaceType));

        // Pass this on to the parent.
        ntStatus = USBH_PassIrp(Irp, deviceExtensionParent->FunctionalDeviceObject);
        *IrpNeedsCompletion = FALSE;
        break;

    default:
        USBH_KdBreak(("PdoPnP unknown (%d) PnP message Pdo %x\n",
                      MinorFunction, deviceObject));
        ntStatus = Irp->IoStatus.Status;
    }

    USBH_KdPrint((2,"'FunctionPdoPnP exit %x\n", ntStatus));

    return ntStatus;
}


VOID
USBH_ParentWaitWakeCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PDEVICE_EXTENSION_HEADER devExtHeader;
    PDEVICE_EXTENSION_FUNCTION function;
    PDEVICE_EXTENSION_PARENT parent;
    NTSTATUS ntStatus = STATUS_CANCELLED;
    LONG pendingChildWWs;
    PIRP parentWaitWake = NULL;

    USBH_KdPrint((1,"'Function WaitWake Irp %x cancelled\n", Irp));

    USBH_ASSERT(DeviceObject);

    devExtHeader = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;
    USBH_ASSERT(devExtHeader->ExtensionType == EXTENSION_TYPE_FUNCTION);

    function = (PDEVICE_EXTENSION_FUNCTION) devExtHeader;
    parent = function->DeviceExtensionParent;

    if (Irp != function->WaitWakeIrp) {
        //
        // Nothing to do
        // This Irp has already been taken care of.
        // We are in the process of completing this IRP in
        // USBH_ParentCompleteFunctionWakeIrps.
        //
        IoReleaseCancelSpinLock(Irp->CancelIrql);

    } else {
        function->WaitWakeIrp = NULL;
        IoSetCancelRoutine(Irp, NULL);

        pendingChildWWs = InterlockedDecrement (&parent->NumberFunctionWakeIrps);
        parentWaitWake = parent->PendingWakeIrp;
        if (0 == pendingChildWWs) {
            // Set PendingWakeIrp to NULL since we cancel it below.
            parent->PendingWakeIrp = NULL;
            parent->ParentFlags &= ~HUBFLAG_PENDING_WAKE_IRP;
        }
        IoReleaseCancelSpinLock(Irp->CancelIrql);

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        //
        // If there are no more outstanding WW irps, we need to cancel the WW
        // to our parent.
        //
        if (0 == pendingChildWWs) {
            IoCancelIrp (parentWaitWake);
        } else {
            ASSERT (0 < pendingChildWWs);
        }
    }
}


NTSTATUS
USBH_FunctionPdoPower(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp,
    IN UCHAR MinorFunction
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl Power for the PDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO extension Irp - the request packet
  * uchMinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
#if DBG
    PDEVICE_OBJECT deviceObject = DeviceExtensionFunction->FunctionPhysicalDeviceObject;
#endif
    PIO_STACK_LOCATION irpStack;
    USHORT feature;
    KIRQL irql;
    PIRP wWIrp;
    PIRP parentWaitWake;
    LONG pendingFunctionWWs;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PDRIVER_CANCEL oldCancel;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    USBH_KdPrint((2,"'Power Pdo %x minor %x\n", deviceObject, MinorFunction));
    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;

    switch (MinorFunction) {

    case IRP_MN_SET_POWER:

        USBH_KdPrint((2,"'IRP_MN_SET_POWER\n"));

        //
        // we just return success here, pnp will make sure
        // all children have entred the low power state
        // before putting the parent in a low power state
        //

        //
        // send the setpower feature request here if the device
        // wants it
        //

        ntStatus = STATUS_SUCCESS;

        switch (irpStack->Parameters.Power.Type) {
        case SystemPowerState:
            USBH_KdPrint(
                (1, "'IRP_MJ_POWER PA pdo(%x) MN_SET_POWER(SystemPowerState) complt\n",
                    DeviceExtensionFunction->FunctionPhysicalDeviceObject));

            ntStatus = STATUS_SUCCESS;
            break;

        case DevicePowerState:
            ntStatus = STATUS_SUCCESS;
            USBH_KdPrint(
                (1, "'IRP_MJ_POWER PA pdo(%x) MN_SET_POWER(DevicePowerState) complt\n",
                    DeviceExtensionFunction->FunctionPhysicalDeviceObject));

            break;
        } // switch irpStack->Parameters.Power.Type
        break; //IRP_MN_SET_POWER

    case IRP_MN_QUERY_POWER:

        ntStatus = STATUS_SUCCESS;
        USBH_KdPrint(
            (1, "'IRP_MJ_POWER PA pdo(%x) MN_QUERY_POWER, status = %x complt\n",
            DeviceExtensionFunction->FunctionPhysicalDeviceObject, ntStatus));

        break;

    case IRP_MN_WAIT_WAKE:

        USBH_KdPrint(
            (1, "'enabling remote wakeup for USB child PDO (%x)\n",
                DeviceExtensionFunction->FunctionPhysicalDeviceObject));

        if (deviceExtensionParent->CurrentPowerState != PowerDeviceD0 ||
            deviceExtensionParent->ParentFlags & HUBFLAG_DEVICE_STOPPING) {

            LOGENTRY(LOG_PNP, "!WWp", deviceExtensionParent, 0, 0);

            UsbhWarning(NULL,
                        "Client driver should not be submitting WW IRPs at this time.\n",
                        TRUE);

            ntStatus = STATUS_INVALID_DEVICE_STATE;
            break;
        }

        IoAcquireCancelSpinLock(&irql);
        if (DeviceExtensionFunction->WaitWakeIrp != NULL) {
            ntStatus = STATUS_DEVICE_BUSY;
            IoReleaseCancelSpinLock(irql);

        } else {

            // set a cancel routine
            oldCancel = IoSetCancelRoutine(Irp, USBH_ParentWaitWakeCancel);
            USBH_ASSERT (NULL == oldCancel);

            if (Irp->Cancel) {
                TEST_TRAP();

                IoSetCancelRoutine (Irp, NULL);
                IoReleaseCancelSpinLock(irql);
                ntStatus = STATUS_CANCELLED;

            } else {

                // flag this device as "enabled for wakeup"
                DeviceExtensionFunction->WaitWakeIrp = Irp;
                pendingFunctionWWs =
                    InterlockedIncrement (&deviceExtensionParent->NumberFunctionWakeIrps);
                IoMarkIrpPending(Irp);
                IoReleaseCancelSpinLock(irql);

                //
                // now we must enable the parent PDO for wakeup
                //
                if (1 == pendingFunctionWWs) {
                    // What if this fails?
                    ntStatus = USBH_ParentSubmitWaitWakeIrp(deviceExtensionParent);
                } else {
                    ntStatus = STATUS_PENDING;
                }

                ntStatus = STATUS_PENDING;
                goto USBH_FunctionPdoPower_Done;
            }
        }

        break;

    default:
        USBH_KdBreak(("PdoPnP unknown (%d) PnP message Pdo %x\n",
                      MinorFunction, deviceObject));
        //
        // return the original status passed to us
        //
        ntStatus = Irp->IoStatus.Status;
    }

    USBH_KdPrint((2,"'FunctionPdoPower exit %x\n", ntStatus));

    PoStartNextPowerIrp(Irp);
    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

USBH_FunctionPdoPower_Done:

    return ntStatus;
}

NTSTATUS
USBH_ParentQCapsComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Called when lower device completes Q_CAPS.
    This gives us a chance to mark the device as SurpriseRemovalOK.

Arguments:
    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Context - NULL ptr

Return Value:

    STATUS_SUCCESS

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_CAPABILITIES pDevCaps = irpStack->Parameters.DeviceCapabilities.Capabilities;
    NTSTATUS ntStatus;

    USBH_KdPrint((1, "'USBH_ParentQCapsComplete\n"));

    ntStatus = Irp->IoStatus.Status;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Set SurpriseRemoval flag to TRUE
    //
    pDevCaps->SurpriseRemovalOK = TRUE;

    return ntStatus;
}



NTSTATUS
USBH_ParentPnP(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp,
    IN UCHAR MinorFunction
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl PnP for the FDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionParent - the FDO extension pIrp - the request packet
  * MinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceObject = DeviceExtensionParent->FunctionalDeviceObject;
    USBH_KdPrint((2,"'PnP Fdo %x minor %x\n", deviceObject, MinorFunction));

    switch (MinorFunction) {
    case IRP_MN_START_DEVICE:
        USBH_KdBreak(("'IRP_MN_START_DEVICE Parent Fdo %x\n", deviceObject));
        // we get here as a result of re-start.
        // note: our parent hub already checked to see if the device is the same.
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = USBH_ParentFdoStartDevice(DeviceExtensionParent, Irp, FALSE);
        break;

    case IRP_MN_STOP_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_STOP_DEVICE Fdo %x\n", deviceObject));
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = USBH_ParentFdoStopDevice(DeviceExtensionParent, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_REMOVE_DEVICE Fdo %x\n", deviceObject));
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = USBH_ParentFdoRemoveDevice(DeviceExtensionParent, Irp);
        break;

//
// This one should be passed down.  Let the default case handle it.
//
//    case IRP_MN_QUERY_PNP_DEVICE_STATE:
//        USBH_KdPrint((2,"IRP_MN_QUERY_PNP_DEVICE_STATE Pdo %x\n", deviceObject));
//        ntStatus = STATUS_SUCCESS;
//        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        switch (irpStack->Parameters.QueryDeviceRelations.Type) {
        case BusRelations:

            ntStatus = USBH_ParentQueryBusRelations(DeviceExtensionParent, Irp);
            break;

        case TargetDeviceRelation:
            //
            // this one gets passed on
            //

            USBH_KdPrint((1, "'Query Relations, TargetRelations (PAR) %x\n",
                DeviceExtensionParent->PhysicalDeviceObject));

            ntStatus = USBH_PassIrp(Irp,
                                    DeviceExtensionParent->TopOfStackDeviceObject);
            break;

        default:

            USBH_KdPrint((1, "'Query Relations (?) (PAR) %x pass on\n",
                DeviceExtensionParent->PhysicalDeviceObject));

            ntStatus = USBH_PassIrp(Irp,
                                    DeviceExtensionParent->TopOfStackDeviceObject);

        }
        break;

    case IRP_MN_QUERY_CAPABILITIES:
        USBH_KdPrint((1, "'Query Capabilities (PAR) %x\n",
            DeviceExtensionParent->PhysicalDeviceObject));

        IoCopyCurrentIrpStackLocationToNext(Irp);

        // Set up a completion routine to handle marking the IRP.
        IoSetCompletionRoutine(Irp,
                               USBH_ParentQCapsComplete,
                               DeviceExtensionParent,
                               TRUE,
                               TRUE,
                               TRUE);

        // Now pass down the IRP.

        ntStatus = IoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject, Irp);

        break;

    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
// Ken says take this out
//    case IRP_MN_SURPRISE_REMOVAL:
    case IRP_MN_DEVICE_USAGE_NOTIFICATION:
        // IrpAssert: Must set IRP status before passing IRP down.
        Irp->IoStatus.Status = STATUS_SUCCESS;
        // fall through

        //
        // Pass it down to Pdo to handle all other MN functions
        //
    default:
        USBH_KdPrint((2,"'Query/Cancel/Power request on parent fdo %x  %x\n",
                      deviceObject, MinorFunction));
        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionParent->TopOfStackDeviceObject);
        break;
    }

    USBH_KdPrint((2,"'ParentPnP exit %x\n", ntStatus));
    return ntStatus;
}


NTSTATUS
USBH_ParentPower(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp,
    IN UCHAR MinorFunction
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl Power for the FDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionParent - the FDO extension pIrp - the request packet
  * MinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceObject = DeviceExtensionParent->FunctionalDeviceObject;
    USBH_KdPrint((2,"'Power Fdo %x minor %x\n", deviceObject, MinorFunction));

    switch (MinorFunction) {

    case IRP_MN_QUERY_POWER:

        USBH_KdPrint(
            (1, "'IRP_MJ_POWER PA fdo(%x) MN_QUERY_POWER\n",
            DeviceExtensionParent->FunctionalDeviceObject));

        IoCopyCurrentIrpStackLocationToNext(Irp);
        PoStartNextPowerIrp(Irp);
        //
        // must pass this on to our PDO
        //
        ntStatus = PoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject,
                                Irp);

        break;

    case IRP_MN_SET_POWER:

        USBH_KdPrint(
            (1, "'IRP_MJ_POWER PA fdo(%x) MN_QUERY_POWER\n",
            DeviceExtensionParent->FunctionalDeviceObject));

        switch (irpStack->Parameters.Power.Type) {
        case SystemPowerState:
            {
            POWER_STATE powerState;

            USBH_KdPrint(
                (1, "IRP_MJ_POWER PA fdo(%x) MN_SET_POWER(SystemPowerState)\n",
                    DeviceExtensionParent->FunctionalDeviceObject));

            if (irpStack->Parameters.Power.State.SystemState ==
                PowerSystemWorking) {
                powerState.DeviceState = PowerDeviceD0;
            } else if (DeviceExtensionParent->ParentFlags &
                       HUBFLAG_ENABLED_FOR_WAKEUP) {
                //
                // based on the system power state
                // request a setting to the appropriate
                // Dx state.
                //
                powerState.DeviceState =
                    DeviceExtensionParent->DeviceState[irpStack->Parameters.Power.State.SystemState];

                //
                // These tables should have already been fixed up by the root hub
                // (usbd.sys) to not contain an entry of unspecified.
                //
                ASSERT (PowerDeviceUnspecified != powerState.DeviceState);

                USBH_KdPrint((2,"'Parent System state maps to device state 0x%x\n",
                              powerState.DeviceState));

            } else {
                TEST_TRAP();
                powerState.DeviceState = PowerDeviceD3;
            } // irpStack->Parameters.Power.State.SystemState

            //
            // only make the request if it is for a differnt power
            // state then the one we are in.
            //

            if (powerState.DeviceState !=
                DeviceExtensionParent->CurrentPowerState) {

                DeviceExtensionParent->PowerIrp = Irp;
                ntStatus = PoRequestPowerIrp(DeviceExtensionParent->PhysicalDeviceObject,
                                          IRP_MN_SET_POWER,
                                          powerState,
                                          USBH_FdoDeferPoRequestCompletion,
                                          DeviceExtensionParent,
                                          NULL);

            } else {
                IoCopyCurrentIrpStackLocationToNext(Irp);
                PoStartNextPowerIrp(Irp);
                ntStatus = PoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject,
                                        Irp);
            }
            }
            break;

        case DevicePowerState:

            USBH_KdPrint(
                (1, "IRP_MJ_POWER PA fdo(%x) MN_SET_POWER(DevicePowerState)\n",
                    DeviceExtensionParent->FunctionalDeviceObject));

            DeviceExtensionParent->CurrentPowerState =
                    irpStack->Parameters.Power.State.DeviceState;


            LOGENTRY(LOG_PNP, "prD>", DeviceExtensionParent, DeviceExtensionParent->CurrentPowerState , 0);
            //
            // all of our pdos need to be at or below the
            // expected D-state
            //

            IoCopyCurrentIrpStackLocationToNext(Irp);
            PoStartNextPowerIrp(Irp);
            ntStatus = PoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject,
                                    Irp);

            USBH_KdPrint((2,"'Parent Device Power State PoCallDriver() = %x\n",
                               ntStatus));

            break;
        }

        break; // MN_SET_POWER

    default:
        USBH_KdPrint((2,"'Power request on parent not handled, fdo %x  %x\n",
                      deviceObject, MinorFunction));

        IoCopyCurrentIrpStackLocationToNext(Irp);
        PoStartNextPowerIrp(Irp);
        ntStatus = PoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject,
                                Irp);
        break;
    }

    USBH_KdPrint((2,"'ParentPnP exit %x\n", ntStatus));
    return ntStatus;
}

NTSTATUS
USBH_ParentDispatch(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Handles calls to a FDO associated with a composite device
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_OBJECT deviceObject;

    USBH_KdPrint((2,"'FdoDispatch DeviceExtension %x Irp %x\n",
        DeviceExtensionParent, Irp));
    deviceObject = DeviceExtensionParent->FunctionalDeviceObject;

    //
    // Get a pointer to IoStackLocation so we can retrieve parameters.
    //
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);

    //
    // the called functions will complete the irp if necessary
    //

    switch (ioStackLocation->MajorFunction) {
    case IRP_MJ_CREATE:

        USBH_KdPrint((2,"'IRP_MJ_CREATE\n"));
        USBH_CompleteIrp(Irp, STATUS_SUCCESS);
        break;

    case IRP_MJ_CLOSE:

        USBH_KdPrint((2,"'IRP_MJ_CLOSE\n"));
        USBH_CompleteIrp(Irp, STATUS_SUCCESS);
        break;

    case IRP_MJ_DEVICE_CONTROL:
        //
        // Note: if we ever do find a reason to handle this, be sure to
        // not forward IOCTL_KS_PROPERTY / KSPROPSETID_DrmAudioStream /
        // KSPROPERTY_DRMAUDIOSTREAM_SETCONTENTID to next driver!  Otherwise
        // this might not be DRM compliant.
        //
        USBH_KdPrint((2,"'IRP_MJ_DEVICE_CONTROL\n"));
        UsbhWarning(NULL,"Should not be hitting this code\n", FALSE);
        ntStatus = STATUS_UNSUCCESSFUL;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:

        USBH_KdPrint((2,"'InternlDeviceControl IOCTL unknown pass on\n"));
        UsbhWarning(NULL,"Should not be hitting this code\n", FALSE);
        ntStatus = STATUS_UNSUCCESSFUL;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_PNP:

        USBH_KdPrint((2,"'IRP_MJ_PNP\n"));

        ntStatus = USBH_ParentPnP(DeviceExtensionParent, Irp, ioStackLocation->MinorFunction);
        break;

    case IRP_MJ_POWER:

        USBH_KdPrint((2,"'IRP_MJ_POWER\n"));

        ntStatus = USBH_ParentPower(DeviceExtensionParent, Irp, ioStackLocation->MinorFunction);
        break;

    case IRP_MJ_SYSTEM_CONTROL:

        USBH_KdPrint((2,"'IRP_MJ_SYSTEM_CONTROL\n"));
#ifdef WMI_SUPPORT
        ntStatus =
            USBH_SystemControl ((PDEVICE_EXTENSION_FDO) DeviceExtensionParent, Irp);
#else
        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionParent->TopOfStackDeviceObject);
#endif
        break;

    default:
        //
        // Unknown Irp -- complete with error
        //
        USBH_KdBreak(("Unknown Irp for Fdo %x Irp_Mj %x\n",
                  deviceObject, ioStackLocation->MajorFunction));
        ntStatus = STATUS_NOT_IMPLEMENTED;
        USBH_CompleteIrp(Irp, ntStatus);
        break;
    }

    USBH_KdPrint((2,"' exit USBH_ParentDispatch Object %x Status %x\n",
                  deviceObject, ntStatus));

    //
    // always return a status code
    //

    return ntStatus;
}


NTSTATUS
USBH_FunctionUrbFilter(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PURB urb;
    USHORT function;

    USBH_KdPrint((2,"'USBH_FunctionUrbFilter DeviceExtension %x Irp %x\n",
        DeviceExtensionFunction, Irp));

    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;

    LOGENTRY(LOG_PNP, "fURB", DeviceExtensionFunction, deviceExtensionParent,
        deviceExtensionParent->ParentFlags);

    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    urb = ioStackLocation->Parameters.Others.Argument1;

    // check the command code code the URB

    function = urb->UrbHeader.Function;

    if (deviceExtensionParent->CurrentPowerState !=
        PowerDeviceD0) {

        // the child devices should not be passing in urbs
        // unless th eparent is in D0

        UsbhWarning(NULL,
           "Parent Not in D0.\n",
           TRUE);

    }

    switch(function) {
    case URB_FUNCTION_SELECT_CONFIGURATION:
        {
        //
        // if the requested config matches the current config
        // then go ahead and return the current interface
        // information for all interfaces requested.
        //
        PUSBD_INTERFACE_INFORMATION interface;

        if (urb->UrbSelectConfiguration.ConfigurationDescriptor == NULL) {
            USBH_KdBreak(("closing config on a composite device\n"));

            //
            // closing the configuration,
            // just return success.
            //

            urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
            ntStatus = STATUS_SUCCESS;
        } else {
            ULONG i;

            //
            // Normally the URB will contain only one interface.
            // the special case is audio which may contain two
            // so we have to have a check to handle this.
            //

            interface = &urb->UrbSelectConfiguration.Interface;

USBH_FunctionUrbFilter_Next:

            USBH_KdPrint((2,"'interface = %x\n",
                    interface));

            //
            // should validate the requested interface against the
            // current config.
            //
            USBH_KdBreak(("need some validation here!\n"));

            USBH_ASSERT(urb->UrbSelectConfiguration.ConfigurationDescriptor->bConfigurationValue
                    == deviceExtensionParent->CurrentConfig);

            // find the interface we are interested in
            for (i=0; i< DeviceExtensionFunction->InterfaceCount; i++) {
                PFUNCTION_INTERFACE functionInterface;

                functionInterface =
                    &DeviceExtensionFunction->FunctionInterfaceList[i];

                USBH_KdPrint((2,"'functionInterface  = %x, %x\n",
                   functionInterface, functionInterface->InterfaceInformation));

                if (functionInterface->InterfaceInformation->InterfaceNumber ==
                    interface->InterfaceNumber) {
                    break;
                }
            }

            if (i < DeviceExtensionFunction->InterfaceCount) {
                PFUNCTION_INTERFACE functionInterface;

                functionInterface =
                    &DeviceExtensionFunction->FunctionInterfaceList[i];

                if (functionInterface->InterfaceInformation->AlternateSetting !=
                    interface->AlternateSetting) {

                    PURB iUrb;
                    NTSTATUS localStatus;
                    PUSBD_INTERFACE_INFORMATION localInterface;
                    USHORT siz;

                    // client is requesting a different alternate setting
                    // we need to do a select_interface

                    siz =
                        (USHORT)(GET_SELECT_INTERFACE_REQUEST_SIZE(interface->NumberOfPipes));

                    iUrb = UsbhExAllocatePool(NonPagedPool, siz);
                    if (iUrb) {
                        localInterface = &iUrb->UrbSelectInterface.Interface;

                        iUrb->UrbSelectInterface.Hdr.Function =
                            URB_FUNCTION_SELECT_INTERFACE;
                        iUrb->UrbSelectInterface.Hdr.Length = siz;
                        iUrb->UrbSelectInterface.ConfigurationHandle =
                            DeviceExtensionFunction->ConfigurationHandle;

                        USBH_KdPrint((2,"'localInterface = %x\n",
                            localInterface));

                        RtlCopyMemory(localInterface,
                                      interface,
                                      interface->Length);

                        localStatus = USBH_SyncSubmitUrb(
                            deviceExtensionParent->TopOfStackDeviceObject,
                            iUrb);


                        UsbhExFreePool(functionInterface->InterfaceInformation);

                        functionInterface->InterfaceInformation =
                            UsbhExAllocatePool(NonPagedPool,
                                               interface->Length);

                        RtlCopyMemory(functionInterface->InterfaceInformation,
                                      localInterface,
                                      localInterface->Length);

                        UsbhExFreePool(iUrb);
                        iUrb = NULL;
                    }

                }

                USBH_ASSERT(interface->Length ==
                      functionInterface->InterfaceInformation->Length);

                RtlCopyMemory(interface,
                              functionInterface->InterfaceInformation,
                              functionInterface->InterfaceInformation->Length);

                urb->UrbSelectConfiguration.ConfigurationHandle =
                    DeviceExtensionFunction->ConfigurationHandle;

                urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
                ntStatus = STATUS_SUCCESS;
            } else {
                ntStatus = STATUS_INVALID_PARAMETER;
            }

            //
            // check for multiple interfaces e.g. audio
            //

            if (DeviceExtensionFunction->InterfaceCount > 1) {

                interface = (PUSBD_INTERFACE_INFORMATION)
                    (((PUCHAR) interface) + interface->Length);

                if ((PUCHAR)interface < (((PUCHAR) urb) +
                    urb->UrbSelectConfiguration.Hdr.Length)) {
                    goto USBH_FunctionUrbFilter_Next;
                }
            }
        }

        USBH_CompleteIrp(Irp, ntStatus);
        }

        break;

    case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
        {
        PUCHAR userBuffer = NULL;
        ULONG bytesReturned;

        //
        // if we requesting the configuration descriptor then we
        // will return it based on the information in our extension.
        //
        if (urb->UrbControlDescriptorRequest.DescriptorType ==
            USB_CONFIGURATION_DESCRIPTOR_TYPE) {

            if (urb->UrbControlDescriptorRequest.TransferBufferMDL) {
                ntStatus = STATUS_INVALID_PARAMETER;
            } else {
                userBuffer =
                    urb->UrbControlDescriptorRequest.TransferBuffer;

                ntStatus = USBH_BuildFunctionConfigurationDescriptor(
                                DeviceExtensionFunction,
                                userBuffer,
                                urb->UrbControlDescriptorRequest.TransferBufferLength,
                                &bytesReturned);

                urb->UrbControlDescriptorRequest.TransferBufferLength =
                    bytesReturned;

                urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
            }

            USBH_CompleteIrp(Irp, ntStatus);

        } else {
            ntStatus = USBH_PassIrp(Irp,
                                    deviceExtensionParent->TopOfStackDeviceObject);
        }
        }
        break;

    default:
        //
        // forward the request to the parents PDO
        //
        ntStatus = USBH_PassIrp(Irp,
                                deviceExtensionParent->TopOfStackDeviceObject);
        break;
    }

    return ntStatus;
}


VOID
USBH_CancelAllIrpsInList(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    )
 /*
  * Description:
  *
  *     This function walks the list of devices and cancels all the queued
  *     ResetIrps in the list.
  *
  * Arguments:
  *
  * Return:
  *
  *
  * -- */
{
    PSINGLE_LIST_ENTRY          listEntry;
    PDEVICE_EXTENSION_FUNCTION  deviceExtensionFunction;

    listEntry = DeviceExtensionParent->FunctionList.Next;

    while (listEntry) {
        deviceExtensionFunction =
            CONTAINING_RECORD(listEntry,
                              DEVICE_EXTENSION_FUNCTION,
                              ListEntry);
        ASSERT_FUNCTION(deviceExtensionFunction);

        if (deviceExtensionFunction->ResetIrp) {
            USBH_CompleteIrp(deviceExtensionFunction->ResetIrp, STATUS_UNSUCCESSFUL);
            deviceExtensionFunction->ResetIrp = NULL;
        }

        listEntry = listEntry->Next;
    }
}


VOID
USBH_CompResetTimeoutWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to handle a composite reset timeout.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_COMP_RESET_TIMEOUT_WORK_ITEM  workItemCompResetTimeout;
    PDEVICE_EXTENSION_PARENT            deviceExtensionParent;

    workItemCompResetTimeout = Context;
    deviceExtensionParent = workItemCompResetTimeout->DeviceExtensionParent;

    USBH_KdPrint((2,"'CompReset timeout\n"));
    LOGENTRY(LOG_PNP, "CRTO", deviceExtensionParent, 0, 0);

    USBH_KdPrint((2,"'*** (CRTW) WAIT parent mutex %x\n", deviceExtensionParent));
    KeWaitForSingleObject(&deviceExtensionParent->ParentMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'*** (CRTW) WAIT parent mutex done %x\n", deviceExtensionParent));

    USBH_CancelAllIrpsInList(deviceExtensionParent);

    USBH_KdPrint((2,"'*** (CRTW) RELEASE parent mutex %x\n", deviceExtensionParent));
    KeReleaseSemaphore(&deviceExtensionParent->ParentMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    UsbhExFreePool(workItemCompResetTimeout);
}


VOID
USBH_CompResetTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.



Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext -

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PCOMP_RESET_TIMEOUT_CONTEXT compResetTimeoutContext = DeferredContext;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent =
                                compResetTimeoutContext->DeviceExtensionParent;
    BOOLEAN cancelFlag;
    PUSBH_COMP_RESET_TIMEOUT_WORK_ITEM workItemCompResetTimeout;

    USBH_KdPrint((2,"'COMP_RESET_TIMEOUT\n"));

    // Take SpinLock here so that main routine won't write CancelFlag
    // in the timeout context while we free the timeout context.

    KeAcquireSpinLockAtDpcLevel(&deviceExtensionParent->ParentSpinLock);

    cancelFlag = compResetTimeoutContext->CancelFlag;
    deviceExtensionParent->CompResetTimeoutContext = NULL;

    KeReleaseSpinLockFromDpcLevel(&deviceExtensionParent->ParentSpinLock);

    UsbhExFreePool(compResetTimeoutContext);

    if (!cancelFlag) {
        //
        // Schedule a work item to process this.
        //
        workItemCompResetTimeout = UsbhExAllocatePool(NonPagedPool,
                                    sizeof(USBH_COMP_RESET_TIMEOUT_WORK_ITEM));

        if (workItemCompResetTimeout) {

            workItemCompResetTimeout->DeviceExtensionParent = deviceExtensionParent;

            ExInitializeWorkItem(&workItemCompResetTimeout->WorkQueueItem,
                                 USBH_CompResetTimeoutWorker,
                                 workItemCompResetTimeout);

            LOGENTRY(LOG_PNP, "crER", deviceExtensionParent,
                &workItemCompResetTimeout->WorkQueueItem, 0);

            ExQueueWorkItem(&workItemCompResetTimeout->WorkQueueItem,
                            DelayedWorkQueue);

            // The WorkItem is freed by USBH_CompResetTimeoutWorker()
            // Don't try to access the WorkItem after it is queued.
        }
    }
}


BOOLEAN
USBH_ListReadyForReset(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    )
 /*
  * Description:
  *
  *     This function walks the list of devices to see if we are ready
  *     to do the actual reset.
  *
  * Arguments:
  *
  * Return:
  *
  * TRUE if we're ready, FALSE if we're not.
  *
  * -- */
{
    PSINGLE_LIST_ENTRY          listEntry;
    PDEVICE_EXTENSION_FUNCTION  deviceExtensionFunction;

    listEntry = DeviceExtensionParent->FunctionList.Next;

    while (listEntry) {
        deviceExtensionFunction =
            CONTAINING_RECORD(listEntry,
                              DEVICE_EXTENSION_FUNCTION,
                              ListEntry);
        ASSERT_FUNCTION(deviceExtensionFunction);

        if (!deviceExtensionFunction->ResetIrp)
            return FALSE;

        listEntry = listEntry->Next;
    }

    return TRUE;
}


NTSTATUS
USBH_ResetParentPort(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    )
/*++

Routine Description:

    Calls the parent device to reset its port.

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;

    USBH_KdPrint((2,"'CompReset parent port\n"));
    LOGENTRY(LOG_PNP, "CRPP", DeviceExtensionParent, 0, 0);

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_RESET_PORT,
                DeviceExtensionParent->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    ntStatus = IoCallDriver(DeviceExtensionParent->TopOfStackDeviceObject,
                            irp);

    if (ntStatus == STATUS_PENDING) {

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);
    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    return ntStatus;
}


VOID
USBH_CompositeResetPortWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to process a composite port reset.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_COMP_RESET_WORK_ITEM  workItemCompReset;
    PSINGLE_LIST_ENTRY          listEntry;
    PDEVICE_EXTENSION_PARENT    deviceExtensionParent;
    PDEVICE_EXTENSION_FUNCTION  deviceExtensionFunction;

    USBH_KdPrint((2,"'Composite Reset Executing!\n"));

    workItemCompReset = Context;
    deviceExtensionParent = workItemCompReset->DeviceExtensionParent;

    LOGENTRY(LOG_PNP, "CRW_", deviceExtensionParent, 0, 0);

    // Send reset to parent (IoCallDriver)

    USBH_ResetParentPort(deviceExtensionParent);

    // Now, complete all Irps in list and set the Irps in the list to NULL.

    USBH_KdPrint((2,"'*** (CRW) WAIT parent mutex %x\n", deviceExtensionParent));
    KeWaitForSingleObject(&deviceExtensionParent->ParentMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'*** (CRW) WAIT parent mutex done %x\n", deviceExtensionParent));

    listEntry = deviceExtensionParent->FunctionList.Next;

    while (listEntry) {
        deviceExtensionFunction =
            CONTAINING_RECORD(listEntry,
                              DEVICE_EXTENSION_FUNCTION,
                              ListEntry);
        ASSERT_FUNCTION(deviceExtensionFunction);

        // Although ResetIrp should usually be set here, we check anyway in
        // case it had already been completed in USBH_CompleteAllIrpsInList.
        //
        if (deviceExtensionFunction->ResetIrp) {
            USBH_CompleteIrp(deviceExtensionFunction->ResetIrp, STATUS_SUCCESS);
            deviceExtensionFunction->ResetIrp = NULL;
        }

        listEntry = listEntry->Next;
    }

    USBH_KdPrint((2,"'*** (CRW) RELEASE parent mutex %x\n", deviceExtensionParent));
    KeReleaseSemaphore(&deviceExtensionParent->ParentMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    UsbhExFreePool(workItemCompReset);
}


NTSTATUS
USBH_FunctionPdoDispatch(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  *     This function handles calls to PDOs we have created
  *     since we are the bottom driver for the PDO it is up
  *     to us to complete the irp -- with one exception.
  *
  *     api calls to the USB stack are forwarded directly
  *     to the PDO for the root hub which is owned by the USB
  *     HC.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PCOMP_RESET_TIMEOUT_CONTEXT compResetTimeoutContext = NULL;
    LARGE_INTEGER dueTime;
    KIRQL irql;
    BOOLEAN bCompleteIrp;

    USBH_KdPrint((2,"'FunctionPdoDispatch DeviceExtension %x Irp %x\n",
        DeviceExtensionFunction, Irp));
    deviceObject = DeviceExtensionFunction->FunctionPhysicalDeviceObject;
    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;

    //
    // Get a pointer to IoStackLocation so we can retrieve parameters.
    //
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);

    switch (ioStackLocation->MajorFunction) {
    case IRP_MJ_CREATE:
        USBH_KdPrint((2,"'PARENT PDO IRP_MJ_CREATE\n"));
        ntStatus = STATUS_SUCCESS;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_CLOSE:
        USBH_KdPrint((2,"'PARENT PDO IRP_MJ_CLOSE\n"));
        ntStatus = STATUS_SUCCESS;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        {
        ULONG ioControlCode;

        USBH_KdPrint((2,"'Internal Device Control\n"));

        if (deviceExtensionParent->ParentFlags & HUBFLAG_DEVICE_STOPPING) {
            UsbhWarning(NULL,
                "Client Device Driver is sending requests to a device that has been removed.\n",
                FALSE);

            ntStatus = STATUS_DEVICE_REMOVED;
            USBH_CompleteIrp(Irp, ntStatus);
            break;
        }

        ioControlCode = ioStackLocation->Parameters.DeviceIoControl.IoControlCode;

        switch (ioControlCode) {
        case IOCTL_INTERNAL_USB_GET_PORT_STATUS:
            USBH_KdPrint((2,"'Composite GetPortStatus, pass on\n"));
            ntStatus = USBH_PassIrp(Irp, deviceExtensionParent->TopOfStackDeviceObject);
            break;

        case IOCTL_INTERNAL_USB_RESET_PORT:

            LOGENTRY(LOG_PNP, "fRES", deviceExtensionParent, 0, 0);

            USBH_KdPrint((2,"'Composite Reset Requested\n"));
            if (deviceExtensionParent->CurrentPowerState !=
                 PowerDeviceD0) {

                // the child devices should not be resetting
                // unless the parent is in D0

                UsbhWarning(NULL,
                   "Parent Not in D0.\n",
                   TRUE);

            }

            if (DeviceExtensionFunction->ResetIrp) {
                ntStatus = STATUS_UNSUCCESSFUL;
                USBH_CompleteIrp(Irp, ntStatus);
            } else {
                ntStatus = STATUS_PENDING;

                USBH_KdPrint((2,"'***WAIT parent mutex %x\n", deviceExtensionParent));
                KeWaitForSingleObject(&deviceExtensionParent->ParentMutex,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
                USBH_KdPrint((2,"'***WAIT parent mutex done %x\n", deviceExtensionParent));

                DeviceExtensionFunction->ResetIrp = Irp;
                if (USBH_ListReadyForReset(deviceExtensionParent)) {

                    PUSBH_COMP_RESET_WORK_ITEM workItemCompReset;

                    //
                    // "Cancel" watchdog timer.
                    //
                    // Take SpinLock here so that DPC routine won't free
                    // the timeout context while we write the CancelFlag
                    // in the timeout context.
                    //
                    KeAcquireSpinLock(&deviceExtensionParent->ParentSpinLock,
                                        &irql);

                    if (deviceExtensionParent->CompResetTimeoutContext) {

                        compResetTimeoutContext = deviceExtensionParent->CompResetTimeoutContext;
                        compResetTimeoutContext->CancelFlag = TRUE;

                        if (KeCancelTimer(&compResetTimeoutContext->TimeoutTimer)) {
                            //
                            // We cancelled the timer before it could run.  Free the context.
                            //
                            deviceExtensionParent->CompResetTimeoutContext = NULL;
                            UsbhExFreePool(compResetTimeoutContext);
                        }
                    }

                    KeReleaseSpinLock(&deviceExtensionParent->ParentSpinLock,
                                        irql);

                    //
                    // Schedule a work item to process this reset.
                    //
                    workItemCompReset = UsbhExAllocatePool(NonPagedPool,
                                            sizeof(USBH_COMP_RESET_WORK_ITEM));

                    USBH_ASSERT(workItemCompReset);

                    if (workItemCompReset) {

                        workItemCompReset->DeviceExtensionParent = deviceExtensionParent;

                        ExInitializeWorkItem(&workItemCompReset->WorkQueueItem,
                                             USBH_CompositeResetPortWorker,
                                             workItemCompReset);

                        LOGENTRY(LOG_PNP, "rCMP", deviceExtensionParent,
                            &workItemCompReset->WorkQueueItem, 0);

                        ExQueueWorkItem(&workItemCompReset->WorkQueueItem,
                                        DelayedWorkQueue);

                        // The WorkItem is freed by USBH_CompositeResetPortWorker()
                        // Don't try to access the WorkItem after it is queued.

                    } else {
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }

                } else if (!deviceExtensionParent->CompResetTimeoutContext) {
                    // Start watchdog timer if not already started.
                    //
                    // When timer expires, timer routine should
                    // complete all Irps in the list with an error
                    // and clear the Irps in the list.

                    USBH_KdPrint((2,"'Start composite port reset timeout\n"));
                    compResetTimeoutContext = UsbhExAllocatePool(NonPagedPool,
                                            sizeof(*compResetTimeoutContext));

                    USBH_ASSERT(compResetTimeoutContext);

                    if (compResetTimeoutContext) {

                        compResetTimeoutContext->CancelFlag = FALSE;

                        // Maintain links between the device extension and the
                        // timeout context.
                        deviceExtensionParent->CompResetTimeoutContext = compResetTimeoutContext;
                        compResetTimeoutContext->DeviceExtensionParent = deviceExtensionParent;

                        KeInitializeTimer(&compResetTimeoutContext->TimeoutTimer);
                        KeInitializeDpc(&compResetTimeoutContext->TimeoutDpc,
                                        USBH_CompResetTimeoutDPC,
                                        compResetTimeoutContext);

                        dueTime.QuadPart = -10000 * COMP_RESET_TIMEOUT;

                        KeSetTimer(&compResetTimeoutContext->TimeoutTimer,
                                   dueTime,
                                   &compResetTimeoutContext->TimeoutDpc);

                    } else {
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (ntStatus == STATUS_PENDING) {
                    IoMarkIrpPending(Irp);
                } else {
                    USBH_CompleteIrp(Irp, ntStatus);
                }

                USBH_KdPrint((2,"'***RELEASE parent mutex %x\n", deviceExtensionParent));
                KeReleaseSemaphore(&deviceExtensionParent->ParentMutex,
                                   LOW_REALTIME_PRIORITY,
                                   1,
                                   FALSE);
            }
            break;

        case IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO:
            TEST_TRAP(); //shouldn't see this
            break;

        case IOCTL_INTERNAL_USB_SUBMIT_URB:
            ntStatus = USBH_FunctionUrbFilter(DeviceExtensionFunction, Irp);
            break;

        case IOCTL_INTERNAL_USB_GET_BUS_INFO:
            // this api returns some BW info that drivers
            // may need -- pass it on
            ntStatus = USBH_PassIrp(Irp, deviceExtensionParent->TopOfStackDeviceObject);
            break;

        default:
            USBH_KdPrint((2,"'InternalDeviceControl IOCTL unknown pass on\n"));
            ntStatus = STATUS_INVALID_PARAMETER;
            USBH_CompleteIrp(Irp, ntStatus);
        }
        break;

        }

    case IRP_MJ_PNP:

        USBH_KdPrint((2,"'IRP_MJ_PNP\n"));
        ntStatus = USBH_FunctionPdoPnP(DeviceExtensionFunction, Irp,
                        ioStackLocation->MinorFunction, &bCompleteIrp);

        if (bCompleteIrp) {
            USBH_CompleteIrp(Irp, ntStatus);
        }
        break;

    case IRP_MJ_POWER:

        USBH_KdPrint((2,"'IRP_MJ_POWER\n"));
        ntStatus = USBH_FunctionPdoPower(DeviceExtensionFunction, Irp, ioStackLocation->MinorFunction);
        break;

    case IRP_MJ_SYSTEM_CONTROL:

        USBH_KdPrint((2,"'IRP_MJ_SYSTEM_CONTROL\n"));
        ntStatus = STATUS_NOT_SUPPORTED;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_DEVICE_CONTROL:
        //
        // Note: if we ever do find a reason to handle this, be sure to
        // not forward IOCTL_KS_PROPERTY / KSPROPSETID_DrmAudioStream /
        // KSPROPERTY_DRMAUDIOSTREAM_SETCONTENTID to next driver!  Otherwise
        // this might not be DRM compliant.
        //
        USBH_KdBreak(("Unhandled IRP_MJ_DEVICE_CONTROL for Pdo %x Irp_Mj %x\n",
                       deviceObject, ioStackLocation->MajorFunction));
        ntStatus = STATUS_INVALID_PARAMETER;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    default:

        // Unknown Irp, shouldn't be here.
        USBH_KdBreak(("Unhandled Irp for Pdo %x Irp_Mj %x\n",
                       deviceObject, ioStackLocation->MajorFunction));
        ntStatus = STATUS_INVALID_PARAMETER;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    }

    USBH_KdPrint((2,"' exit USBH_FunctionPdoDispatch Object %x -- Status %x\n",
                  deviceObject, ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_BuildFunctionConfigurationDescriptor(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN OUT PUCHAR Buffer,
    IN ULONG BufferLength,
    OUT PULONG BytesReturned
    )
 /*
  * Description:
  *
  *  This function creates a configuration descriptor (with all interface &
  *  endpoints) for a give function.
  *
  * Arguments:
  *
  *     Buffer - buffer to put descriptor in
  *
  *     BufferLength - max size of this buffer.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
    PVOID scratch;
    ULONG length, i;
    PUCHAR pch;

    USBH_KdPrint((2,"'USBH_BuildFunctionConfigurationDescriptor\n"));

    deviceExtensionParent = DeviceExtensionFunction->DeviceExtensionParent;

    //
    // scratch area to build descriptor in
    //

    *BytesReturned = 0;

    configurationDescriptor = deviceExtensionParent->ConfigurationDescriptor;
    if (!configurationDescriptor || !configurationDescriptor->wTotalLength) {
        return STATUS_INVALID_PARAMETER;
    }

    scratch = UsbhExAllocatePool(PagedPool, configurationDescriptor->
                                 wTotalLength);

    if (scratch) {

        configurationDescriptor = scratch;
        pch = scratch;

        length = sizeof(USB_CONFIGURATION_DESCRIPTOR);
        RtlCopyMemory(pch,
                      deviceExtensionParent->ConfigurationDescriptor,
                      length);
        pch+=length;

        //
        // now copy the interfaces
        //

        for (i=0; i< DeviceExtensionFunction->InterfaceCount; i++) {
            PFUNCTION_INTERFACE functionInterface;

            functionInterface =
                &DeviceExtensionFunction->FunctionInterfaceList[i];

            RtlCopyMemory(pch,
                          functionInterface->InterfaceDescriptor,
                          functionInterface->InterfaceDescriptorLength);


            pch+=functionInterface->InterfaceDescriptorLength;
            length+=functionInterface->InterfaceDescriptorLength;
        }

        configurationDescriptor->bNumInterfaces = (UCHAR) DeviceExtensionFunction->InterfaceCount;
        configurationDescriptor->wTotalLength = (USHORT) length;

        //
        // now copy what we can in to the user buffer
        //
        if (BufferLength >= configurationDescriptor->wTotalLength) {
            *BytesReturned = configurationDescriptor->wTotalLength;
        } else {
            *BytesReturned = BufferLength;
        }

        RtlCopyMemory(Buffer,
                      scratch,
                      *BytesReturned);

        USBH_KdBreak(("'USBH_BuildFunctionConfigurationDescriptor, buffer = %x scratch = %x\n",
            Buffer, scratch));

        UsbhExFreePool(scratch);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


VOID
USBH_ParentCompleteFunctionWakeIrps(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN NTSTATUS NtStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a hub
    Propagates the wake irp completion to all the function (children).

Arguments:

    DeviceObject - Pointer to the device object for the class device.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_EXTENSION_FUNCTION deviceExtensionFunction;
    PSINGLE_LIST_ENTRY listEntry;
    PIRP irp;
    KIRQL irql;
    LONG pendingFunctionWWs;
    ULONG i;
    PIRP irpArray[128];     // Limited to 127 functions in the list.

    LOGENTRY(LOG_PNP, "fWWc", DeviceExtensionParent, NtStatus, 0);

    //
    // Here we are walking the list of child PDOs, which should never change.
    // (The number of interfaces on a USB device is fixed so long as the parent
    // is here the number of children stay constant.)
    //
    // Therefore we need no protection for parent->FunctionList.
    //
    // Wrongo!  The list may not change, but the WW IRPs attributed to the
    // list can, so we must take the spinlock here.

    IoAcquireCancelSpinLock(&irql);

    listEntry = DeviceExtensionParent->FunctionList.Next;
    i = 0;

    while (listEntry) {

        deviceExtensionFunction =
             CONTAINING_RECORD(listEntry,
                               DEVICE_EXTENSION_FUNCTION,
                               ListEntry);

        irp = deviceExtensionFunction->WaitWakeIrp;
        deviceExtensionFunction->WaitWakeIrp = NULL;
        if (irp) {

            IoSetCancelRoutine(irp, NULL);

            pendingFunctionWWs =
                InterlockedDecrement(&DeviceExtensionParent->NumberFunctionWakeIrps);

            if (0 == pendingFunctionWWs) {
                LOGENTRY(LOG_PNP, "fWWx", DeviceExtensionParent,
                    DeviceExtensionParent->PendingWakeIrp, 0);
                DeviceExtensionParent->PendingWakeIrp = NULL;
                DeviceExtensionParent->ParentFlags &= ~HUBFLAG_PENDING_WAKE_IRP;
            }

            irpArray[i++] = irp;
        }

        listEntry = listEntry->Next;
    }

    irpArray[i] = NULL;     // Terminate array

    IoReleaseCancelSpinLock(irql);

    USBH_ASSERT(DeviceExtensionParent->PendingWakeIrp == NULL);

    // Ok, we have queued all the function wake IRPs and have released the
    // cancel spinlock.  Let's complete all the IRPs.

    i = 0;

    while (irpArray[i]) {
        USBH_KdPrint((1,"'completing function WaitWake irp(%x) for PARENT VID %x, PID %x\n\n",
                        NtStatus,
                        DeviceExtensionParent->DeviceDescriptor.idVendor, \
                        DeviceExtensionParent->DeviceDescriptor.idProduct));

        irpArray[i]->IoStatus.Status = NtStatus;
        PoStartNextPowerIrp(irpArray[i]);
        IoCompleteRequest(irpArray[i], IO_NO_INCREMENT);

        i++;
    }
}


NTSTATUS
USBH_ParentPoRequestD0Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a hub

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent = Context;

    ntStatus = IoStatus->Status;

    USBH_KdPrint((1,"'WaitWake D0 completion(%x) for PARENT VID %x, PID %x\n",
        ntStatus,
        deviceExtensionParent->DeviceDescriptor.idVendor, \
        deviceExtensionParent->DeviceDescriptor.idProduct));

    LOGENTRY(LOG_PNP, "pWD0", deviceExtensionParent,
                              deviceExtensionParent->PendingWakeIrp,
                              0);
    //
    // Device has been powered on.  Now we must complete the function that
    // caused the parent to awake.
    //
    // Since of course we cannot tell them apart we must complete all function
    // WW Irps.
    //
    USBH_ParentCompleteFunctionWakeIrps(deviceExtensionParent, STATUS_SUCCESS);

    return ntStatus;
}


NTSTATUS
USBH_ParentWaitWakeIrpCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a composite device

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION_PARENT deviceExtensionParent = Context;
    POWER_STATE powerState;

    ntStatus = IoStatus->Status;

    USBH_KdPrint((1,"'WaitWake completion(%x) for PARENT VID %x, PID %x\n",
        ntStatus,
        deviceExtensionParent->DeviceDescriptor.idVendor, \
        deviceExtensionParent->DeviceDescriptor.idProduct));

    LOGENTRY(LOG_PNP, "pWWc", deviceExtensionParent,
                              ntStatus,
                              0);

    // first we power our device back on

    if (NT_SUCCESS(ntStatus)) {

        powerState.DeviceState = PowerDeviceD0;

        PoRequestPowerIrp(deviceExtensionParent->PhysicalDeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              USBH_ParentPoRequestD0Completion,
                              deviceExtensionParent,
                              NULL);

        // USBH_ParentPoRequestD0Completion must complete the
        // wake irp
        ntStatus = STATUS_SUCCESS;
    } else {
        // complete the child wake requests with an error
        USBH_ParentCompleteFunctionWakeIrps(deviceExtensionParent,
                                            ntStatus);
    }

    return ntStatus;
}


NTSTATUS
USBH_ParentSubmitWaitWakeIrp(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    )
/*++

Routine Description:

    called when a child Pdo is enabled for wakeup, this
    function allocates a wait wake irp and passes it to
    the parents PDO.


Arguments:

Return Value:

--*/
{
    PIRP irp;
    NTSTATUS ntStatus;
    POWER_STATE powerState;

    USBH_ASSERT (NULL == DeviceExtensionParent->PendingWakeIrp);

    LOGENTRY(LOG_PNP, "prWI", DeviceExtensionParent,
             0,
             0);

    USBH_ASSERT(DeviceExtensionParent->PendingWakeIrp == NULL);

    DeviceExtensionParent->ParentFlags |= HUBFLAG_PENDING_WAKE_IRP;
    powerState.DeviceState = DeviceExtensionParent->SystemWake;

    ntStatus = PoRequestPowerIrp(DeviceExtensionParent->PhysicalDeviceObject,
                                 IRP_MN_WAIT_WAKE,
                                 powerState,
                                 USBH_ParentWaitWakeIrpCompletion,
                                 DeviceExtensionParent,
                                 &irp);

    if (ntStatus == STATUS_PENDING) {
        if (DeviceExtensionParent->ParentFlags & HUBFLAG_PENDING_WAKE_IRP) {
            DeviceExtensionParent->PendingWakeIrp = irp;
        }
    }
    USBH_KdPrint((2,
                  "'ntStatus from PoRequestPowerIrp for wait_wake to parent PDO = 0x%x\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\hub.pnp\sync.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    SYNC.C

Abstract:

    This module contains Synchronous calls for USB Hub driver

Author:

    John Lee

Environment:

    kernel mode only

Notes:


Revision History:

    04-01-96 : created
    10-27-96 : jd modified to use a single transact function for calls to usb stack

--*/
#include <wdm.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */
#include "usbhub.h"
#include <stdio.h>

// delay after usb reset (in milliseconds), spec calls for 10ms
ULONG USBH_PostResetDelay = 10;

//
// expect string descriptor header on list of supported languages
//
#define HEADER

#define DEADMAN_TIMER
#define DEADMAN_TIMEOUT     5000     //timeout in ms
                                     //use a 5 second timeout

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBH_SyncSubmitUrb)
#pragma alloc_text(PAGE, UsbhWait)
#pragma alloc_text(PAGE, USBH_SyncGetRootHubPdo)
#pragma alloc_text(PAGE, USBH_FdoSyncSubmitUrb)
#pragma alloc_text(PAGE, USBH_Transact)
#pragma alloc_text(PAGE, USBH_SyncGetPortStatus)
#pragma alloc_text(PAGE, USBH_SyncGetHubStatus)
#pragma alloc_text(PAGE, USBH_SyncClearHubStatus)
#pragma alloc_text(PAGE, USBH_SyncClearPortStatus)
#pragma alloc_text(PAGE, USBH_SyncPowerOnPort)
#pragma alloc_text(PAGE, USBH_SyncPowerOnPorts)
#pragma alloc_text(PAGE, USBH_SyncSuspendPort)
#pragma alloc_text(PAGE, USBH_SyncDisablePort)
#pragma alloc_text(PAGE, USBH_SyncEnablePort)
#pragma alloc_text(PAGE, USBH_SyncPowerOffPort)
#pragma alloc_text(PAGE, USBH_SyncResumePort)
#pragma alloc_text(PAGE, USBH_SyncResetPort)
#pragma alloc_text(PAGE, USBH_SyncResetDevice)
#pragma alloc_text(PAGE, USBH_SyncGetDeviceConfigurationDescriptor)
#pragma alloc_text(PAGE, USBH_GetConfigurationDescriptor)
#pragma alloc_text(PAGE, USBH_GetDeviceDescriptor)
#pragma alloc_text(PAGE, USBH_GetDeviceQualifierDescriptor)
#pragma alloc_text(PAGE, USBH_SyncGetHubDescriptor)
#pragma alloc_text(PAGE, USBH_GetSerialNumberString)
#pragma alloc_text(PAGE, USBH_SyncGetStatus)
#pragma alloc_text(PAGE, USBH_SyncGetStringDescriptor)
#pragma alloc_text(PAGE, USBH_SyncFeatureRequest)
#pragma alloc_text(PAGE, USBH_CheckDeviceLanguage)
#endif
#endif


VOID
UsbhWait(
    IN ULONG MiliSeconds)
 /* ++
  *
  * Descriptor:
  *
  * This causes the thread execution delayed for ulMiliSeconds.
  *
  * Argument:
  *
  * Mili-seconds to delay.
  *
  * Return:
  *
  * VOID
  * 
  * -- */
{
    LARGE_INTEGER time;
    ULONG timerIncerent;

    USBH_KdPrint((2,"'Wait for %d ms\n", MiliSeconds));

    //
    // work only when LowPart is not overflown.
    //
    USBH_ASSERT(21474 > MiliSeconds);

    //
    // wait ulMiliSeconds( 10000 100ns unit)
    //
    timerIncerent = KeQueryTimeIncrement() - 1;
    
    time.HighPart = -1;
    // round up to the next highest timer increment
    time.LowPart = -1 * (10000 * MiliSeconds + timerIncerent);
    KeDelayExecutionThread(KernelMode, FALSE, &time);

    USBH_KdPrint((2,"'Wait done\n"));

    return;
}

#ifdef DEADMAN_TIMER
VOID
UsbhTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL. 

    
    
Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - 

    SystemArgument1 - not used.
    
    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PHUB_TIMEOUT_CONTEXT hubTimeoutContext = DeferredContext;
    BOOLEAN complete, status;
    KIRQL irql;

    KeAcquireSpinLock(&hubTimeoutContext->TimeoutSpin, &irql);
    complete = hubTimeoutContext->Complete;
    LOGENTRY(LOG_PNP, "dpTO", hubTimeoutContext->Irp, 0, complete); 
    KeReleaseSpinLock(&hubTimeoutContext->TimeoutSpin, irql);

    if (!complete) {

        LOGENTRY(LOG_PNP, "TOca", hubTimeoutContext->Irp, 0, complete);         
        IoCancelIrp(hubTimeoutContext->Irp);

    }

    //OK to free it
    KeSetEvent(&hubTimeoutContext->Event, 1, FALSE);
}


NTSTATUS
USBH_SyncIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PHUB_TIMEOUT_CONTEXT hubTimeoutContext = Context;
    KIRQL irql;
    BOOLEAN cancelled;
    
    KeAcquireSpinLock(&hubTimeoutContext->TimeoutSpin, &irql);
    
    LOGENTRY(LOG_PNP, "klTO", hubTimeoutContext->Irp, 0, Context); 
    hubTimeoutContext->Complete = TRUE;
    cancelled = KeCancelTimer(&hubTimeoutContext->TimeoutTimer);    
    
    KeReleaseSpinLock(&hubTimeoutContext->TimeoutSpin, irql);

    // see if the timer was in the queue, if it was then it is safe to free 
    // it
    
    if (cancelled) {
        // safe to free it
        KeSetEvent(&hubTimeoutContext->Event, 1, FALSE);
    }

    return STATUS_SUCCESS;
}

#endif /* DEADMAN_TIMER */


NTSTATUS 
USBH_SyncSubmitUrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb)
 /* ++
  * 
  * Routine Description:
  * 
  * Passes a URB to the USBD class driver, and wait for return.
  *
  * Arguments:
  *
  * pDeviceObject - the hub device pUrb - pointer to the URB to send to USBD
  *
  * Return Value:
  *
  * STATUS_SUCCESS if successful, STATUS_UNSUCCESSFUL otherwise
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
    BOOLEAN haveTimer = FALSE;
    PHUB_TIMEOUT_CONTEXT hubTimeoutContext = NULL;

    USBH_KdPrint((2,"'enter USBH_SyncSubmitUrb\n"));

    PAGED_CODE();

    //
    // null out device handle in case we are the root hub
    Urb->UrbHeader.UsbdDeviceHandle = NULL;

    //
    // issue a synchronous request to the RootHubBdo
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                                         IOCTL_INTERNAL_USB_SUBMIT_URB,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,  // INTERNAL
                                         &event,
                                         &ioStatus);

    if (NULL == irp) {
        USBH_KdBreak(("CallUsbd build Irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    //
    // pass the URB to the USBD 'class driver'
    //
    nextStack->Parameters.Others.Argument1 = Urb;

#ifdef DEADMAN_TIMER
    hubTimeoutContext = UsbhExAllocatePool(NonPagedPool, 
                                           sizeof(*hubTimeoutContext));
    if (hubTimeoutContext) {
        LARGE_INTEGER dueTime;

        hubTimeoutContext->Irp = irp;
        hubTimeoutContext->Complete = FALSE;

        KeInitializeEvent(&hubTimeoutContext->Event, NotificationEvent, FALSE);
        KeInitializeSpinLock(&hubTimeoutContext->TimeoutSpin);
        KeInitializeTimer(&hubTimeoutContext->TimeoutTimer);
        KeInitializeDpc(&hubTimeoutContext->TimeoutDpc,
                        UsbhTimeoutDPC,
                        hubTimeoutContext);

        dueTime.QuadPart = -10000 * DEADMAN_TIMEOUT;

        KeSetTimer(&hubTimeoutContext->TimeoutTimer,
                   dueTime,
                   &hubTimeoutContext->TimeoutDpc);        

        haveTimer = TRUE;
        
        IoSetCompletionRoutine(irp,
                           USBH_SyncIrp_Complete,
                           // always pass FDO to completion routine
                           hubTimeoutContext,
                           TRUE,
                           TRUE,
                           TRUE);
    }
#endif 
                           

    USBH_KdPrint((2,"'calling USBD\n"));

    LOGENTRY(LOG_PNP, "ssUR", irp, 0, Urb);
    ntStatus = IoCallDriver(DeviceObject, irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));
    
    if (ntStatus == STATUS_PENDING) {

        USBH_KdPrint((2,"'Wait for single object\n"));

        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));
    } else {
        ioStatus.Status = ntStatus;
    }

#ifdef DEADMAN_TIMER
    // the completion routine should have canceled the timer
    // so we should never find it in the queue
    //
    // remove our timeoutDPC from the queue
    //
    if (haveTimer) {
        USBH_ASSERT(KeCancelTimer(&hubTimeoutContext->TimeoutTimer) == FALSE);
        KeWaitForSingleObject(&hubTimeoutContext->Event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
        LOGENTRY(LOG_PNP, "frTO", irp, 0, Urb);                               
        UsbhExFreePool(hubTimeoutContext);
    }  
#endif /* DEADMAN_TIMER */
    
    USBH_KdPrint((2,"'URB status = %x status = %x irp status %x\n",
                  Urb->UrbHeader.Status, status, ioStatus.Status));

    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    USBH_KdPrint((2,"'exit USBH_SyncSubmitUrb (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS 
USBH_SyncGetRootHubPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PDEVICE_OBJECT *RootHubPdo,
    IN OUT PDEVICE_OBJECT *TopOfHcdStackDeviceObject,
    IN OUT PULONG Count
    )
 /* ++
  * 
  * Routine Description:
  *
  *     call pdo to get the root hub PDO for our fastpath to the
  *         usb stack.
  *     if Count is non-null then return th ehub count, otherwise return
  *         the root hub PDO
  * Arguments:
  * 
  * Return Value:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_SyncSubmitUrb\n"));

    //
    // issue a synchronous request to the RootHubBdo
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest( Count == NULL ? 
                                          IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO :
                                          IOCTL_INTERNAL_USB_GET_HUB_COUNT,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,  // INTERNAL
                                         &event,
                                         &ioStatus);

    if (NULL == irp) {
        USBH_KdBreak(("USBH_SyncGetRootHubPdo build Irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    //
    // pass the URB to the USBD 'class driver'
    //
    if (Count == NULL) {
        nextStack->Parameters.Others.Argument1 = RootHubPdo;
        nextStack->Parameters.Others.Argument2 = TopOfHcdStackDeviceObject;
    } else {
        nextStack->Parameters.Others.Argument1 = Count;
    }

    ntStatus = IoCallDriver(DeviceObject, irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
        USBH_KdPrint((2,"'Wait for single object\n"));

        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));
    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    USBH_KdPrint((2,"'exit USBH_SyncGetRootHubPdo (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS 
USBH_SyncGetControllerInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG Ioctl
    )
 /* ++
  * 
  * Routine Description:
  *
  *     call pdo to get the root hub PDO for our fastpath to the
  *         usb stack.
  *     if Count is non-null then return th ehub count, otherwise return
  *         the root hub PDO
  * Arguments:
  * 
  * Return Value:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_SyncGetControllerName\n"));

    //
    // issue a synchronous request to the RootHubBdo
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest( Ioctl,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,  // INTERNAL
                                         &event,
                                         &ioStatus);

    if (NULL == irp) {
        USBH_KdBreak(("USBH_SyncGetControllerName build Irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);
    nextStack->Parameters.Others.Argument1 = Buffer;
    nextStack->Parameters.Others.Argument2 = ULongToPtr(BufferLength);

    ntStatus = IoCallDriver(DeviceObject, irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
        USBH_KdPrint((2,"'Wait for single object\n"));

        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));
    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    USBH_KdPrint((2,"'exit USBH_SyncGetHubName (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS 
USBH_SyncGetHubName(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )
 /* ++
  * 
  * Routine Description:
  *
  *     call pdo to get the root hub PDO for our fastpath to the
  *         usb stack.
  *     if Count is non-null then return th ehub count, otherwise return
  *         the root hub PDO
  * Arguments:
  * 
  * Return Value:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_SyncGetHubName\n"));

    //
    // issue a synchronous request to the RootHubBdo
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest( IOCTL_INTERNAL_USB_GET_HUB_NAME,
                                         DeviceObject,
                                         Buffer,
                                         BufferLength,
                                         Buffer,
                                         BufferLength,
                                         TRUE,  // INTERNAL
                                         &event,
                                         &ioStatus);

    if (NULL == irp) {
        USBH_KdBreak(("USBH_SyncGetHubName build Irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    ntStatus = IoCallDriver(DeviceObject, irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
        USBH_KdPrint((2,"'Wait for single object\n"));

        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));
    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    USBH_KdPrint((2,"'exit USBH_SyncGetHubName (%x)\n", ntStatus));

    return ntStatus;
}



NTSTATUS 
USBH_FdoSyncSubmitUrb(
    IN PDEVICE_OBJECT HubDeviceObject,
    IN PURB Urb)
 /* ++
  * 
  * Routine Description:
  * 
  * Arguments:
  * 
  * Return Value:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION_HEADER deviceExtensionHeader;
    PDEVICE_EXTENSION_FDO deviceExtensionFdo;
    
    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_FdoSyncSubmitUrb\n"));

    deviceExtensionHeader = (PDEVICE_EXTENSION_HEADER) HubDeviceObject->DeviceExtension;
    deviceExtensionFdo = (PDEVICE_EXTENSION_FDO) HubDeviceObject->DeviceExtension;
    USBH_ASSERT(EXTENSION_TYPE_HUB == deviceExtensionHeader->ExtensionType || 
           EXTENSION_TYPE_PARENT == deviceExtensionHeader->ExtensionType );
    

    ntStatus = USBH_SyncSubmitUrb(deviceExtensionFdo->TopOfStackDeviceObject, Urb);

    USBH_KdPrint((2,"'return from USBH_FdoSyncSubmitUrb %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS 
USBH_Transact(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUCHAR DataBuffer,
    IN ULONG DataBufferLength,
    IN BOOLEAN DataOutput,
    IN USHORT Function,
    IN UCHAR RequestType,
    IN UCHAR Request,
    IN USHORT Feature,
    IN USHORT Port,
    OUT PULONG BytesTransferred)
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PURB urb = NULL;
    PUCHAR transferBuffer = NULL;
    ULONG transferFlags;
    ULONG localDataBuferLength;
#if DBG || defined(DEBUG_LOG)
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
#endif

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter USBH_Transact\n"));
    USBH_ASSERT(DeviceExtensionHub);

    // round DataTransferLength
    localDataBuferLength = DataBufferLength+sizeof(ULONG);
    // make sure we are dword aligned
    localDataBuferLength &= 0xFFFFFFFC;
    USBH_ASSERT(localDataBuferLength >= DataBufferLength);
    //
    // Allocate a transaction buffer and Urb from the non-paged pool
    //

    transferBuffer = UsbhExAllocatePool(NonPagedPool, localDataBuferLength );
    urb = UsbhExAllocatePool(NonPagedPool,
                             sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));

    if (transferBuffer && urb) {
        USBH_KdPrint((2,"'Transact transfer buffer = %x urb = %x\n",
            transferBuffer, urb));

        transferFlags = 0;

        if (DataOutput) {
            // copy output data to transfer buffer
            if (DataBufferLength) {
                RtlCopyMemory(transferBuffer,
                              DataBuffer,
                              DataBufferLength);
            }

            transferFlags = USBD_TRANSFER_DIRECTION_OUT;

        } else {
            // zero the input buffer

            if (DataBufferLength) {
                RtlZeroMemory(DataBuffer,
                              DataBufferLength);
            }

            transferFlags = USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK;
        }

        UsbhBuildVendorClassUrb(urb,
                                NULL,
                                Function,
                                transferFlags,
                                RequestType,
                                Request,
                                Feature,
                                Port,
                                DataBufferLength,
                                DataBufferLength ? transferBuffer : NULL);

        //
        // pass the URB to the USBD 'class driver'
        //

        ntStatus = USBH_FdoSyncSubmitUrb(DeviceExtensionHub->FunctionalDeviceObject,
                                         urb);

        if (!DataOutput && DataBufferLength) {
            RtlCopyMemory(DataBuffer,
                          transferBuffer,
                          DataBufferLength);
        }

#if DBG || defined(DEBUG_LOG)
        usbdStatus = urb->UrbHeader.Status;
#endif

        UsbhExFreePool(transferBuffer);
        UsbhExFreePool(urb);
    } else {
        if (transferBuffer) {
            UsbhExFreePool(transferBuffer);
        }

        if (urb) {
            UsbhExFreePool(urb);
        }

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    LOGENTRY(LOG_PNP, "Xact", DeviceExtensionHub, usbdStatus, ntStatus);

    USBH_KdPrint((2,"'Exit USBH_Transact %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS 
USBH_SyncGetPortStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    OUT PUCHAR DataBuffer,
    IN ULONG DataBufferLength)
 /* ++
  * 
  * Description:
  * 
  * Arguments:
  *      PortNumber
  * 
  * Return:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus;

    PAGED_CODE();
    USBH_ASSERT(DeviceExtensionHub);
    ntStatus = USBH_Transact(DeviceExtensionHub,
                         DataBuffer,
                         DataBufferLength,
                         FALSE,
                         URB_FUNCTION_CLASS_OTHER,
                         REQUEST_TYPE_GET_PORT_STATUS,
                         REQUEST_GET_STATUS,
                         0,
                         PortNumber,
                         NULL);
#if DBG
    {
    PPORT_STATE portState;
    portState = (PPORT_STATE) DataBuffer;
    LOGENTRY(LOG_PNP, "pSTS", PortNumber, portState->PortChange, portState->PortStatus); 
    }
#endif
    USBH_KdPrint((2,"'GetPortStatus ntStatus %x port %x state %x\n", ntStatus, 
                    PortNumber, *DataBuffer));                         
    LOGENTRY(LOG_PNP, "pSTA", DeviceExtensionHub, PortNumber, ntStatus); 
    
    return ntStatus;                             
}


NTSTATUS 
USBH_SyncGetHubStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    OUT PUCHAR DataBuffer,
    IN ULONG DataBufferLength)
 /* ++
  * 
  * Description:
  * 
  * Arguments:
  *      PortNumber
  * 
  * Return:
  * 
  * NTSTATUS
  * 
  * -- */
{
    PAGED_CODE();
    return USBH_Transact(DeviceExtensionHub,
                         DataBuffer,
                         DataBufferLength,
                         FALSE,
                         URB_FUNCTION_CLASS_DEVICE,
                         REQUEST_TYPE_GET_HUB_STATUS,
                         REQUEST_GET_STATUS,
                         0,
                         0,
                         NULL);    
}


NTSTATUS 
USBH_SyncClearHubStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT Feature)
 /* ++
  * 
  * Description:
  * 
  * Arguments:
  *      PortNumber
  * 
  * Return:
  * 
  * NTSTATUS
  * 
  * -- */
{
    PAGED_CODE();
    return USBH_Transact(DeviceExtensionHub,
                         NULL,
                         0,
                         TRUE, // Host to Device
                         URB_FUNCTION_CLASS_DEVICE,
                         REQUEST_TYPE_SET_HUB_FEATURE,
                         REQUEST_CLEAR_FEATURE,
                         Feature,
                         0,
                         NULL);    
}


NTSTATUS 
USBH_SyncClearPortStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN USHORT Feature)
 /* ++
  * 
  * Description:
  * 
  * Arguments:
  *      PortNumber
  * 
  * Return:
  * 
  * NTSTATUS
  * 
  * -- */
{
    PAGED_CODE();
    return USBH_Transact(DeviceExtensionHub,
                         NULL,
                         0,
                         TRUE,
                         URB_FUNCTION_CLASS_OTHER,
                         REQUEST_TYPE_SET_PORT_FEATURE,
                         REQUEST_CLEAR_FEATURE,
                         Feature,
                         PortNumber,
                         NULL);    
}


NTSTATUS
USBH_SyncPowerOnPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN BOOLEAN WaitForPowerGood)
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    PPORT_DATA portData;
    ULONG numberOfPorts;
//    ULONG i;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter SyncPowerOnPort pDE %x Port %x\n", DeviceExtensionHub, PortNumber));

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    USBH_ASSERT(NULL != hubDescriptor);
    
    portData = &DeviceExtensionHub->PortData[PortNumber - 1];
    numberOfPorts = hubDescriptor->bNumberOfPorts;
    USBH_ASSERT(PortNumber <= hubDescriptor->bNumberOfPorts);

    if (portData->PortState.PortStatus & PORT_STATUS_POWER) {
        //
        // our state flags indicate the port is already powered
        // just exit with success

        USBH_KdPrint((2,"'Exit SyncPowerOnPort port is on\n"));
        
        return STATUS_SUCCESS;
    }
// USB 1.1 spec change requires all ports to be powered on
// regardless of hub characteristics
#if 0
    if (HUB_IS_NOT_POWER_SWITCHED(hubDescriptor->wHubCharacteristics) && 
        !PORT_DEVICE_NOT_REMOVABLE(hubDescriptor, PortNumber)) {

        //
        // Ports always on when hub is on.
        // As soon as we power the first non-removable port mark all ports 
        // as powered
        //
        
        //
        // mark all ports as powered
        //
 
        for (i=0; i<numberOfPorts; i++) {
            DeviceExtensionHub->PortData[i].PortState.PortStatus |= PORT_STATUS_POWER; 
            USBH_KdPrint((1,"'POWER ON PORT --> marking port(%d) powered\n", i));
        }

        USBH_KdPrint((1,"'POWER ON PORT --> hub is not power switched\n"));
        
        return STATUS_SUCCESS;
        
    }
#endif    

    //
    // Turn the power on
    //

    USBH_KdPrint((1,"'POWER ON PORT --> port(%d)\n", PortNumber));
    
    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_SET_PORT_FEATURE,
                             REQUEST_SET_FEATURE,
                             FEATURE_PORT_POWER,
                             PortNumber,
                             NULL);    


    if (NT_SUCCESS(ntStatus)) {

        // wait powerOnToPowerGood good for this hub to come up
        if (WaitForPowerGood) {
            UsbhWait(2*hubDescriptor->bPowerOnToPowerGood); 
        }            
#ifdef DEBUG
        USBH_KdPrint((1,"'Power On -> Power Good delay is: %d ms\n",
            2*hubDescriptor->bPowerOnToPowerGood));
#endif
        LOGENTRY(LOG_PNP, "PO2G", DeviceExtensionHub, PortNumber , 
            2*hubDescriptor->bPowerOnToPowerGood);
        
        //
        // mark this port as powered
        //
        portData->PortState.PortStatus |= PORT_STATUS_POWER;  
        
// USB 1.1 spec change requires all ports to be powered on
// regardless of hub characteristics        
#if 0
        if (HUB_IS_GANG_POWER_SWITCHED(hubDescriptor->wHubCharacteristics)) {

            // since the hub is gang switched we need to loop thru
            // all the ports and mark them as powered

            USBH_KdPrint((1,"'POWER ON PORT --> gang switched hub\n"));

            for (i=0; i<numberOfPorts; i++) {
                PPORT_STATE portState;

                portState = &DeviceExtensionHub->PortData[i].PortState;

                // if the port is not marked powered and the power mask
                // is not set for this port (ie it is affected by gang
                // mode power switching) then  mark it as powered

                if (!(portState->PortStatus & PORT_STATUS_POWER) &&
                    !(PORT_ALWAYS_POWER_SWITCHED(hubDescriptor, i+1)))  {

                    USBH_KdPrint((1,"'POWER ON PORT --> marking port(%d) powered\n", i));

                    DeviceExtensionHub->PortData[i].PortState.PortStatus |= PORT_STATUS_POWER;
                }
            }

        }
#endif
        //
        // port power is on
        //

    }
#if DBG
      else {
         UsbhWarning(NULL,
                    "SyncPowerOnPort unsuccessful\n",
                    FALSE);
    }
#endif

    return ntStatus;
}


NTSTATUS 
USBH_SyncPowerOnPorts(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  * 
  * Description:
  * 
  * We will turn on the power of all ports unless this hub is not switched.
  * 
  * Argument:
  * 
  * Return:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    ULONG numberOfPorts, i;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter SyncPowerOnPorts pDE %x\n", DeviceExtensionHub));

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    USBH_ASSERT(NULL != hubDescriptor);
    numberOfPorts = hubDescriptor->bNumberOfPorts;

    for (i=0; i<numberOfPorts; i++) {
#ifdef RESUME_PERF    
        ntStatus = USBH_SyncPowerOnPort(DeviceExtensionHub,
                                        (USHORT) (i+1),
                                        FALSE);
#else 
        ntStatus = USBH_SyncPowerOnPort(DeviceExtensionHub,
                                        (USHORT) (i+1),
                                        TRUE);
#endif

        if (!NT_SUCCESS(ntStatus)) {
            break;
        }
    }   

#ifdef RESUME_PERF
    // if you want to fix bug 516250 the uncomment this line and 
    // pass FALSE to USBH_SyncPowerOnPort
    // do the power-on to power good wait here 
    UsbhWait(2*hubDescriptor->bPowerOnToPowerGood); 
#endif     

    USBH_KdPrint((2,"'Exit SyncPowerOnPorts status %x\n", ntStatus));
    
    return ntStatus;
}

#if 0
NTSTATUS 
USBH_SyncPowerOffPorts(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  * 
  * Description:
  * 
  * We will turn off the power of all ports.
  * 
  * Argument:
  * 
  * Return:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    ULONG numberOfPorts, i;

    USBH_KdPrint((2,"'Enter SyncPowerOffPorts pDE %x\n", DeviceExtensionHub));

    TEST_TRAP();

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    USBH_ASSERT(NULL != hubDescriptor);
    numberOfPorts = hubDescriptor->bNumberOfPorts;

    for (i=0; i<numberOfPorts; i++) {
        ntStatus = USBH_SyncPowerOffPort(DeviceExtensionHub,
                                        (USHORT) (i+1));
        if (!NT_SUCCESS(ntStatus)) {
            break;
        }
    }    

    USBH_KdPrint((2,"'Exit SyncPowerOffPorts status %x\n", ntStatus));
    
    return ntStatus;
}
#endif

NTSTATUS 
USBH_SyncSuspendPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber)
 /* ++
  * 
  * Description:
  * 
  * We will suspend the port specified on this hub
  * 
  * Argument:
  * 
  * Return:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter SyncSuspendPort pDE %x\n", DeviceExtensionHub));
    

    portData = &DeviceExtensionHub->PortData[PortNumber - 1];

    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_SET_PORT_FEATURE,
                             REQUEST_SET_FEATURE,
                             FEATURE_PORT_SUSPEND,
                             PortNumber,
                             NULL);    

    if (NT_SUCCESS(ntStatus)) {
        portData->PortState.PortStatus |= PORT_STATUS_SUSPEND;          
    }

    USBH_KdPrint((2,"'Exit SyncSuspendPort  %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS 
USBH_SyncDisablePort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber)
 /* ++
  * 
  * Description:
  * 
  * Argument:
  * 
  * Return:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter SyncDisablePort pDE %x\n", DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "DISp", DeviceExtensionHub, PortNumber , 0);

    portData = &DeviceExtensionHub->PortData[PortNumber - 1];

    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_CLEAR_PORT_FEATURE,
                             REQUEST_CLEAR_FEATURE,
                             FEATURE_PORT_ENABLE,
                             PortNumber,
                             NULL);    

    if (NT_SUCCESS(ntStatus)) {
        portData->PortState.PortStatus &= ~PORT_STATUS_ENABLE;          
    }

    return ntStatus;
}


NTSTATUS 
USBH_SyncEnablePort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber)
 /* ++
  * 
  * Description:
  * 
  * Argument:
  * 
  * Return:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PPORT_DATA portData;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter SyncEnablePort pDE %x port %d\n", DeviceExtensionHub, 
        PortNumber));

    portData = &DeviceExtensionHub->PortData[PortNumber - 1];

    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_SET_PORT_FEATURE,
                             REQUEST_SET_FEATURE,
                             FEATURE_PORT_ENABLE,
                             PortNumber,
                             NULL);    

    if (NT_SUCCESS(ntStatus)) {
        portData->PortState.PortStatus |= PORT_STATUS_ENABLE;          
    }

    return ntStatus;
}


NTSTATUS 
USBH_SyncPowerOffPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber)
 /* ++
  * 
  * Description:
  * 
  * We will suspend the port specified on this hub
  * 
  * Argument:
  * 
  * Return:
  * 
  * NTSTATUS
  * 
  * -- */
{
    NTSTATUS ntStatus;
    PUSB_HUB_DESCRIPTOR hubDescriptor;
    PPORT_DATA portData;
    ULONG numberOfPorts;

    USBH_KdPrint((2,"'Enter SyncPowerOffPort pDE %x Port %x\n", DeviceExtensionHub, PortNumber));

    hubDescriptor = DeviceExtensionHub->HubDescriptor;
    USBH_ASSERT(NULL != hubDescriptor);
    
    portData = &DeviceExtensionHub->PortData[PortNumber - 1];
    numberOfPorts = hubDescriptor->bNumberOfPorts;
    USBH_ASSERT(PortNumber <= hubDescriptor->bNumberOfPorts);

    //
    // Turn the power off
    //
    
    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_CLEAR_PORT_FEATURE,
                             REQUEST_CLEAR_FEATURE,
                             FEATURE_PORT_POWER,
                             PortNumber,
                             NULL);    


    if (NT_SUCCESS(ntStatus)) {

        //
        // mark this port as not powered
        //
        portData->PortState.PortStatus &= ~PORT_STATUS_POWER;        

    }
#if DBG    
      else {
        // hub failed the power off request
        TEST_TRAP();
    }
#endif

    return ntStatus;
}


NTSTATUS
USBH_SyncResumePort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber)
 /* ++
  *
  * Description:
  *
  * We will resume the port by clearing Port_Feature_Suspend which transits the
  * state to Enable according to the spec.
  *
  * Argument:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    KEVENT suspendEvent;
    LARGE_INTEGER dueTime;

    PAGED_CODE();

    USBH_KdPrint((2,"'Enter SyncResumePort pDE %x\n", DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "rspE", DeviceExtensionHub, PortNumber, 0);

    USBH_KdPrint((2,"'***WAIT hub port resume mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->HubPortResetMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT hub port resume mutex done %x\n", DeviceExtensionHub));

    USBH_ASSERT(DeviceExtensionHub->Event == NULL);

    KeInitializeEvent(&suspendEvent, NotificationEvent, FALSE);
    InterlockedExchangePointer(&DeviceExtensionHub->Event, &suspendEvent);

    //
    // first clear the suspend for this port
    //

    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_CLEAR_PORT_FEATURE,
                             REQUEST_CLEAR_FEATURE,
                             FEATURE_PORT_SUSPEND,
                             PortNumber,
                             NULL);

    //
    // now wait for the hub to signal us
    // that the port has resumed
    //

    dueTime.QuadPart = -10000 * DEADMAN_TIMEOUT;

    LOGENTRY(LOG_PNP, "rspW", DeviceExtensionHub,
            PortNumber, ntStatus);

    if (NT_SUCCESS(ntStatus)) {

        status = KeWaitForSingleObject(
                           &suspendEvent,
                           Suspended,
                           KernelMode,
                           FALSE,
                           &dueTime);

        if (status == STATUS_TIMEOUT) {
            // the resume timed out
            LOGENTRY(LOG_PNP, "rsTO", DeviceExtensionHub, PortNumber, 0);

            //
            // resume timed out return an error
            //
            InterlockedExchangePointer(&DeviceExtensionHub->Event, NULL);
            LOGENTRY(LOG_PNP, "rspO", DeviceExtensionHub,
                PortNumber, ntStatus);

            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

    } else {

        // Clear the hub's event pointer for the next time if the call to
        // USBH_Transact was unsuccessful.

        InterlockedExchangePointer(&DeviceExtensionHub->Event, NULL);
    }

    //
    // resume has completed
    //

    //
    // chap 11 USB 1.1 change wait 10 ms after resume is complete
    //
    UsbhWait(10);

    LOGENTRY(LOG_PNP, "rspX", DeviceExtensionHub,
            PortNumber, ntStatus);

    USBH_KdPrint((2,"'***RELEASE hub port resume mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->HubPortResetMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    return ntStatus;
}


NTSTATUS
USBH_SyncResetPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber)
 /* ++
  *
  * Description:
  *
  * We will resume the port by clearing Port_Feature_Suspend which transits the
  * state to Enable according to the spec.
  *
    This is a synchronous function that resets the port on a usb hub.  This
    function assumes exclusive access to the hub, it sends the request and
    waits for the hub to indicate the request is complete via a change on the
    interrupt pipe.

    There is one problem -- the hub may report a connect or other status
    change and if it does it is possible that another interrupt transfer
    (listen) will not be posted to here the reset completeion.  The result
    is the infamous port reset timeout.  We handle this case by completing
    reset with an error so that it can be retried later.

  * Argument:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    KEVENT resetEvent;
    LARGE_INTEGER dueTime;
    ULONG retry = 0;
    PORT_STATE portState;

    //

    PAGED_CODE();

    USBH_KdPrint((2,"'Enter SyncResetPort pDE %x\n", DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "srpE", DeviceExtensionHub, PortNumber, 0);

    USBH_KdPrint((2,"'***WAIT hub port reset mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->HubPortResetMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT hub port reset mutex done %x\n", DeviceExtensionHub));

    USBH_ASSERT(DeviceExtensionHub->Event == NULL);

    // first verify that we have something to reset

    ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                      PortNumber,
                                      (PUCHAR) &portState,
                                      sizeof(portState));

    if (NT_SUCCESS(ntStatus)) {

        DBG_ONLY(USBH_ShowPortState(PortNumber,
                                    &portState));

        if (!(portState.PortStatus & PORT_STATUS_CONNECT)) {
            USBH_KdPrint((0,"'port %d has no device --> fail\n", PortNumber));
            LOGENTRY(LOG_PNP, "srpF", DeviceExtensionHub,
                PortNumber, 0);
            ntStatus = STATUS_UNSUCCESSFUL;
            goto USBH_SyncResetPortDone;
        }
    }

    DeviceExtensionHub->HubFlags |= HUBFLAG_PENDING_PORT_RESET;

USBH_SyncResetPort_Retry:

    KeInitializeEvent(&resetEvent, NotificationEvent, FALSE);
    InterlockedExchangePointer(&DeviceExtensionHub->Event, &resetEvent);

    ntStatus = USBH_Transact(DeviceExtensionHub,
                             NULL,
                             0,
                             TRUE,
                             URB_FUNCTION_CLASS_OTHER,
                             REQUEST_TYPE_SET_PORT_FEATURE,
                             REQUEST_SET_FEATURE,
                             FEATURE_PORT_RESET,
                             PortNumber,
                             NULL);

    //
    // now wait for the hub to signal us
    // that the port has resumed
    //

    dueTime.QuadPart = -10000 * DEADMAN_TIMEOUT;

    LOGENTRY(LOG_PNP, "srpW", DeviceExtensionHub,
            PortNumber, ntStatus);

    if (NT_SUCCESS(ntStatus)) {

        status = KeWaitForSingleObject(
                           &resetEvent,
                           Suspended,
                           KernelMode,
                           FALSE,
                           &dueTime);

        if (status == STATUS_TIMEOUT) {
            // the reset timed out, get the current state of the hub port
            LOGENTRY(LOG_PNP, "srTO", DeviceExtensionHub, PortNumber, retry);

            status = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                            PortNumber,
                                            (PUCHAR) &portState,
                                            sizeof(portState));

            LOGENTRY(LOG_PNP, "srT1", PortNumber,
                portState.PortStatus, portState.PortChange);

            if (NT_SUCCESS(status) &&
                portState.PortStatus & PORT_STATUS_CONNECT) {

                // device is still connected, we may have a flaky connection
                // attempt a retry

                USBH_KdPrint((0,"'port %d failed to reset --> retry\n", PortNumber));
                if (retry < 3) {
                    retry++;
                    LOGENTRY(LOG_PNP, "rtry", DeviceExtensionHub, PortNumber, retry);

                    // we may have a weak connection -- we will retry in case
                    // it has stabilized
                    USBH_KdPrint((0,"'device still present -- retry reset\n"));
                    goto USBH_SyncResetPort_Retry;
                }
#if DBG
                  else {
                    UsbhWarning(NULL,
                                "Port RESET timed out --> this is bad\n",
                                FALSE);
                }
#endif
            }
                // nothing connected, device must have been removed
#if DBG
              else {

                USBH_KdPrint((0,"'-->device removed during reset\n"));
            }
#endif

            //
            // reset timed out return an error
            //
            InterlockedExchangePointer(&DeviceExtensionHub->Event, NULL);
            LOGENTRY(LOG_PNP, "srpO", DeviceExtensionHub,
                PortNumber, ntStatus);

            ntStatus = STATUS_DEVICE_DATA_ERROR;
        } else {
            // check the port status, if this is a high speed reset then we 
            // need to return an error if the connection dropped so that 
            // the hub stops enumeration
    
            if (DeviceExtensionHub->HubFlags & HUBFLAG_USB20_HUB) {
                status = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                                PortNumber,
                                                (PUCHAR) &portState,
                                                sizeof(portState));
                                                
                if (NT_SUCCESS(status) && 
                    !(portState.PortStatus & PORT_STATUS_CONNECT)) {
                    
                    ntStatus = STATUS_DEVICE_DATA_ERROR;
                }
            }
        }

    } else {

        // Clear the hub's event pointer for the next time if the call to
        // USBH_Transact was unsuccessful.

        InterlockedExchangePointer(&DeviceExtensionHub->Event, NULL);
    }

    //
    // Reset has completed.
    //

    //
    // Wait 10 ms after reset according to section 7.1.4.3
    // of the USB specification.
    //
    UsbhWait(USBH_PostResetDelay);

#if DBG
    if (UsbhPnpTest & PNP_TEST_FAIL_PORT_RESET) {
        ntStatus = STATUS_UNSUCCESSFUL;
    }
#endif

    DeviceExtensionHub->HubFlags &= ~HUBFLAG_PENDING_PORT_RESET;

USBH_SyncResetPortDone:

    LOGENTRY(LOG_PNP, "srpX", DeviceExtensionHub,
            PortNumber, ntStatus);

    USBH_KdPrint((2,"'***RELEASE hub port reset mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->HubPortResetMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    return ntStatus;
}


//******************************************************************************
//
// USBH_SyncCompletionRoutine()
//
// If the Irp is one we allocated ourself, DeviceObject is NULL.
//
//******************************************************************************

NTSTATUS
USBH_SyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT kevent;

    kevent = (PKEVENT)Context;

    KeSetEvent(kevent,
               IO_NO_INCREMENT,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

#ifndef USBHUB20
//******************************************************************************
//
// USBH_SyncResetDevice()
//
// This routine resets the device (actually it resets the port to which the
// device is attached).
//
// This routine runs at PASSIVE level.
//
//******************************************************************************

NTSTATUS
USBH_SyncResetDevice (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PIRP                    irp;
    KEVENT                  localevent;
    PIO_STACK_LOCATION      nextStack;
    ULONG                   portStatus;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    // Allocate the Irp
    //
    irp = IoAllocateIrp((CCHAR)(DeviceObject->StackSize),
                        FALSE);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the event we'll wait on.
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_RESET_PORT;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutineEx(DeviceObject,
                             irp,
                             USBH_SyncCompletionRoutine,
                             &localevent,
                             TRUE,      // InvokeOnSuccess
                             TRUE,      // InvokeOnError
                             TRUE);     // InvokeOnCancel

    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(DeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    return ntStatus;
}
#endif


NTSTATUS
USBH_SyncGetDeviceConfigurationDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUCHAR DataBuffer,
    IN ULONG DataBufferLength,
    OUT PULONG BytesReturned)
 /* ++
  *
  * Description:
  *
  * DeviceObject hub/parent FDO or device/function PDO
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    PDEVICE_EXTENSION_HEADER deviceExtensionHeader;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter SyncGetDeviceConfigurationDescriptor\n"));

    deviceExtensionHeader = DeviceObject->DeviceExtension;

    if (BytesReturned) {
        *BytesReturned = 0;
    }

    //
    // Allocate an Urb and descriptor buffer.
    //

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("SyncGetDeviceConfigurationDescriptor fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus)) {

        UsbBuildGetDescriptorRequest(urb,
                                     (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                     0,
                                     0,
                                     DataBuffer,
                                     NULL,
                                     DataBufferLength,
                                     NULL);

        switch (deviceExtensionHeader->ExtensionType) {
        case EXTENSION_TYPE_HUB:
        case EXTENSION_TYPE_PARENT:
            ntStatus = USBH_FdoSyncSubmitUrb(DeviceObject, urb);
            break;
        default:
            ntStatus = USBH_SyncSubmitUrb(DeviceObject, urb);
        }

        if (BytesReturned) {
            *BytesReturned =
                urb->UrbControlDescriptorRequest.TransferBufferLength;
        }

    } else {
        USBH_KdBreak(("SyncGetDeviceConfigurationDescriptor fail alloc memory\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (urb != NULL) {
        UsbhExFreePool(urb);
    }
    return ntStatus;
}


NTSTATUS
USBH_GetConfigurationDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR *ConfigurationDescriptor
    )
 /* ++
  *
  * Description:
  *
  * ConfigurationDescriptor - filled in with a pointer to the config
  *     descriptor or NULL if an error.
  *
  * DeviceObject hub/parent FDO or device/function PDO
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{

    ULONG bufferLength, bytesReturned;
    PUCHAR buffer = NULL;
    NTSTATUS ntStatus;

    PAGED_CODE();
    // some versions of the philips hub ignore
    // the low byte of the requested data length

    bufferLength = 255;

USBH_GetConfigurationDescriptor_Retry:

    buffer = UsbhExAllocatePool(NonPagedPool, bufferLength);

    if (buffer) {

        ntStatus =
        USBH_SyncGetDeviceConfigurationDescriptor(
            DeviceObject,
            buffer,
            bufferLength,
            &bytesReturned);

        //
        // if the device returns no data report an error
        //
        if (bytesReturned < sizeof(USB_CONFIGURATION_DESCRIPTOR)) {
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

        if (NT_SUCCESS(ntStatus)) {
            *ConfigurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR) buffer;

            if ((*ConfigurationDescriptor)->wTotalLength > bufferLength) {
                bufferLength = (*ConfigurationDescriptor)->wTotalLength;
                UsbhExFreePool(buffer);
                buffer = NULL;
                *ConfigurationDescriptor = NULL;
                goto USBH_GetConfigurationDescriptor_Retry;
            }
        }
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus)) {
        if (bytesReturned < (*ConfigurationDescriptor)->wTotalLength) {
            USBH_KdBreak(("device returned truncated config descriptor!!!\n"))
            // device returned trucated config descriptor
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }
    }

    if (!NT_SUCCESS(ntStatus)) {
        //
        // something went wrong return no descriptor data
        //

        if (buffer) {
            UsbhExFreePool(buffer);
            buffer = NULL;
        }
        *ConfigurationDescriptor = NULL;
    }

    USBH_ASSERT((PUCHAR) (*ConfigurationDescriptor) == buffer);

    return ntStatus;
}


NTSTATUS
USBH_SyncGetStringDescriptor(
    IN PDEVICE_OBJECT DevicePDO,
    IN UCHAR Index,
    IN USHORT LangId,
    IN OUT PUSB_STRING_DESCRIPTOR Buffer,
    IN ULONG BufferLength,
    IN PULONG BytesReturned,
    IN BOOLEAN ExpectHeader
    )
 /* ++
  *
  * Description:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_SyncGetStringDescriptor\n"));

    //
    // Allocate an Urb .
    //

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("USBH_SyncGetStringDescriptor fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (urb) {

        //
        // got the urb no try to get descriptor data
        //

        UsbBuildGetDescriptorRequest(urb,
                                     (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     Index,
                                     LangId,
                                     Buffer,
                                     NULL,
                                     BufferLength,
                                     NULL);

        ntStatus = USBH_SyncSubmitUrb(DevicePDO, urb);

        if (NT_SUCCESS(ntStatus) &&
            urb->UrbControlDescriptorRequest.TransferBufferLength > BufferLength) {

            USBH_KdBreak(("Invalid length returned in USBH_SyncGetStringDescriptor, possible buffer overrun\n"));
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

        if (NT_SUCCESS(ntStatus) && BytesReturned) {
            *BytesReturned =
                urb->UrbControlDescriptorRequest.TransferBufferLength;
        }

        if (NT_SUCCESS(ntStatus) &&
            urb->UrbControlDescriptorRequest.TransferBufferLength != Buffer->bLength &&
            ExpectHeader) {

            USBH_KdBreak(("Bogus Descriptor from devce xfer buf %d descriptor %d\n",
                urb->UrbControlDescriptorRequest.TransferBufferLength,
                Buffer->bLength));
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

        USBH_KdPrint((2,"'GetDeviceDescriptor, string descriptor = %x\n",
                Buffer));

        UsbhExFreePool(urb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
USBH_CheckDeviceLanguage(
    IN PDEVICE_OBJECT DevicePDO,
    IN LANGID LanguageId
    )
 /* ++
  *
  * Description:
  *
  * queries the device for a supported language id -- if the device supports
  * the language then the index for this language is returned .
  *
  * DevicePDO - device object to call with urb request
  *
  * LanguageId -
  *
  * Return:
  *
  * success if a particular language is is supported by a device
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STRING_DESCRIPTOR usbString;
    PUSHORT supportedLangId;
    ULONG numLangIds, i;
    ULONG length;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_CheckDeviceLanguage\n"));

    usbString = UsbhExAllocatePool(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);

    if (usbString) {
        //
        // first get the array of supported languages
        //
        ntStatus = USBH_SyncGetStringDescriptor(DevicePDO,
                                                0, //index 0
                                                0, //langid 0
                                                usbString,
                                                MAXIMUM_USB_STRING_LENGTH,
                                                &length,
#ifdef HEADER
                                                TRUE);
#else
                                                FALSE);
#endif /* HEADER */

        //
        // now check for the requested language in the array of supported
        // languages
        //

        //
        // NOTE: this seems a bit much -- we should be able to just ask for
        // the string with a given language id and expect it to fail but since
        // the array of supported languages is part of the USB spec we may as
        // well check it.
        //

        if (NT_SUCCESS(ntStatus)) {

#ifdef HEADER
            if (length < 2) {
                numLangIds = 0;
            } else {
                // subtract size of header
                numLangIds = (length - 2)/2;
            }
            supportedLangId = (PUSHORT) &usbString->bString;
#else
            numLangIds = length/2;
            supportedLangId = (PUSHORT) usbString;
#endif /* HEADER */

            USBH_KdPrint((2,"'NumLangIds = %d\n", numLangIds));

#if DBG
            for (i=0; i<numLangIds; i++) {
                USBH_KdPrint((2,"'LangId = %x\n", *supportedLangId));
                supportedLangId++;
            }

#ifdef HEADER
            supportedLangId = (PUSHORT) &usbString->bString;
#else
            supportedLangId = (PUSHORT) usbString;
#endif /* HEADER */
#endif /* DBG */

            ntStatus = STATUS_NOT_SUPPORTED;
            for (i=0; i<numLangIds; i++) {
                if (*supportedLangId == LanguageId) {

                    ntStatus = STATUS_SUCCESS;
                    break;
                }
                supportedLangId++;
            }
        }

        UsbhExFreePool(usbString);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

#if DBG
    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("'Language %x -- not supported by this device = %x\n",
            LanguageId));
    }
#endif

    return ntStatus;

}


NTSTATUS
USBH_GetSerialNumberString(
    IN PDEVICE_OBJECT DevicePDO,
    IN OUT PWCHAR *SerialNumberBuffer,
    IN OUT PUSHORT SerialNumberBufferLength,
    IN LANGID LanguageId,
    IN UCHAR StringIndex
    )
 /* ++
  *
  * Description:
  *
  * queries the device for the serial number string then allocates a buffer
  * just big enough to hold it.
  *
  * *SerialNumberBuffer is null if an error occurs, otherwise it is filled in
  *  with a pointer to the NULL terminated UNICODE serial number for the device
  *
  * DeviceObject - deviceobject to call with urb request
  *
  * LanguageId - 16 bit language id
  *
  * StringIndex - USB string Index to fetch
  *
  * Return:
  *
  * NTSTATUS code
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STRING_DESCRIPTOR usbString;
    PVOID tmp;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter GetSerialNumberString\n"));

    *SerialNumberBuffer = NULL;
    *SerialNumberBufferLength = 0;

    usbString = UsbhExAllocatePool(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);

    if (usbString) {

        ntStatus = USBH_CheckDeviceLanguage(DevicePDO,
                                            LanguageId);

        if (NT_SUCCESS(ntStatus)) {
            //
            // this device supports our language,
            // go ahead and try to get the serial number
            //

            ntStatus = USBH_SyncGetStringDescriptor(DevicePDO,
                                                    StringIndex, //index
                                                    LanguageId, //langid
                                                    usbString,
                                                    MAXIMUM_USB_STRING_LENGTH,
                                                    NULL,
                                                    TRUE);

            if (NT_SUCCESS(ntStatus)) {

                //
                // device returned a string!!!
                //

                USBH_KdPrint((2,"'device returned serial number string = %x\n",
                    usbString));

                //
                // allocate a buffer and copy the string to it
                //
                // NOTE: must use stock alloc function because
                // PnP frees this string.

                tmp = UsbhExAllocatePool(PagedPool, usbString->bLength);
                if (tmp) {
                    USBH_KdPrint((2,"'SN = %x \n", tmp));
                    RtlZeroMemory(tmp, usbString->bLength);
                    RtlCopyMemory(tmp,
                                  &usbString->bString,
                                  usbString->bLength-2);
                    *SerialNumberBuffer = tmp;
                    *SerialNumberBufferLength = usbString->bLength;
                } else {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        UsbhExFreePool(usbString);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
USBH_SyncGetStatus(
    IN PDEVICE_OBJECT HubFDO,
    IN OUT PUSHORT StatusBits,
    IN USHORT function,
    IN USHORT Index
    )
 /* ++
  *
  * Description:
  *
  * HubFDO - device object for hub (FDO)
  * function - (targets a device, interface or endpoint)
  * Index - wIndex value
  *
  *
  * Return:
  *
  *     ntStatus
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    USHORT tmpStatusBits;

    PAGED_CODE();

    USBH_KdPrint((2,"'enter USBH_SyncGetStatus\n"));

    //
    // Allocate an Urb and descriptor buffer.
    //

    urb = UsbhExAllocatePool(NonPagedPool,
                 sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("GetStatus fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (urb) {

        UsbBuildGetStatusRequest(urb,
                                 function,
                                 Index,
                                 &tmpStatusBits,
                                 NULL,
                                 NULL);

        ntStatus = USBH_FdoSyncSubmitUrb(HubFDO, urb);

        *StatusBits = tmpStatusBits;

        UsbhExFreePool(urb);
    }

    return ntStatus;
}


NTSTATUS
USBH_GetDeviceDescriptor(
    IN PDEVICE_OBJECT HubFDO,
    OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor
    )
 /* ++
  *
  * Description:
  *
  * Get our configuration info.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter GetDeviceDescriptor\n"));

    //
    // Allocate an Urb and descriptor buffer.
    //

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("GetDeviceDescriptor fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (urb) {

        //
        // got the urb no try to get descriptor data
        //

        UsbBuildGetDescriptorRequest(urb,
                                     (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_DEVICE_DESCRIPTOR_TYPE,
                                     0,
                                     0,
                                     DeviceDescriptor,
                                     NULL,
                                     sizeof(USB_DEVICE_DESCRIPTOR),
                                     NULL);

        ntStatus = USBH_FdoSyncSubmitUrb(HubFDO, urb);

        UsbhExFreePool(urb);
    }

    return ntStatus;
}


NTSTATUS
USBH_GetDeviceQualifierDescriptor(
    IN PDEVICE_OBJECT DevicePDO,
    OUT PUSB_DEVICE_QUALIFIER_DESCRIPTOR DeviceQualifierDescriptor
    )
 /* ++
  *
  * Description:
  *
  * Get the USB_DEVICE_QUALIFIER_DESCRIPTOR for the device.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter GetDeviceQualifierDescriptor\n"));

    //
    // Allocate an Urb and descriptor buffer.
    //

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("GetDeviceQualifierDescriptor fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (urb) {

        //
        // got the urb no try to get descriptor data
        //

        UsbBuildGetDescriptorRequest(urb,
                                     (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE,
                                     0,
                                     0,
                                     DeviceQualifierDescriptor,
                                     NULL,
                                     sizeof(USB_DEVICE_QUALIFIER_DESCRIPTOR),
                                     NULL);

        ntStatus = USBH_SyncSubmitUrb(DevicePDO, urb);

        UsbhExFreePool(urb);
    }

    return ntStatus;
}


VOID
USBH_SyncRefreshPortAttributes(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  * -- */
{
    PUSB_EXTHUB_INFORMATION_0 extHubInfo;
    PPORT_DATA p;
    ULONG numberOfPorts, i;
    NTSTATUS localStatus;

    numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
    
    // get extended hub info if any
    extHubInfo = UsbhExAllocatePool(NonPagedPool, sizeof(*extHubInfo));
    if (extHubInfo != NULL) {
        NTSTATUS localStatus;
        // get extended hub info
        localStatus = USBHUB_GetExtendedHubInfo(DeviceExtensionHub, extHubInfo);
        if (!NT_SUCCESS(localStatus)) {
            UsbhExFreePool(extHubInfo);
            extHubInfo = NULL;
        }
    }

    p = DeviceExtensionHub->PortData;
    for (i=0; extHubInfo && i<numberOfPorts; i++, p++) {
        p->PortAttributes = extHubInfo->Port[i].PortAttributes;
    }

    if (extHubInfo) {
        UsbhExFreePool(extHubInfo);
    }
}    


NTSTATUS
USBH_SyncGetHubDescriptor(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  * Get hub descriptor. If successful, we have allocated memory for the hub
  * descriptor and have a the pointer to the memory recorded in the device
  * extension. The memory also has the info filled. An array of port_data is
  * also allocated and a pointer to the array recorded in the device
  * extension.
  *
  * Arguments:
  *
  * pDeviceObject - the hub device
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS ntStatus;
    ULONG numBytes;
    PUSB_HUB_DESCRIPTOR hubDescriptor = NULL;
    PPORT_DATA portData;
    ULONG numberOfPorts;
    PDEVICE_OBJECT deviceObject;
    USHORT descriptorTypeAndIndex = 0x0000;
    PUSB_EXTHUB_INFORMATION_0 extHubInfo;
    
    PAGED_CODE();
    USBH_KdPrint((2,"'enter GetHubDescriptor\n"));

    USBH_ASSERT(EXTENSION_TYPE_HUB == DeviceExtensionHub->ExtensionType);

    // get extended hub info if any
    extHubInfo = UsbhExAllocatePool(NonPagedPool, sizeof(*extHubInfo));
    if (extHubInfo != NULL) {
        NTSTATUS localStatus;
        // get extended hub info
        localStatus = USBHUB_GetExtendedHubInfo(DeviceExtensionHub, extHubInfo);
        if (!NT_SUCCESS(localStatus)) {
            UsbhExFreePool(extHubInfo);
            extHubInfo = NULL;
        }
    }

    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;

    numBytes = sizeof(USB_HUB_DESCRIPTOR);

USBH_SyncGetHubDescriptor_Retry2:

    hubDescriptor = UsbhExAllocatePool(NonPagedPool, numBytes);

    if (hubDescriptor) {

USBH_SyncGetHubDescriptor_Retry:

        ntStatus = USBH_Transact(DeviceExtensionHub,
                                 (PUCHAR) hubDescriptor,
                                 numBytes,
                                 FALSE, // input
                                 URB_FUNCTION_CLASS_DEVICE,
                                 REQUEST_TYPE_GET_HUB_DESCRIPTOR,
                                 REQUEST_GET_DESCRIPTOR,
                                 descriptorTypeAndIndex,
                                 0,
                                 NULL);

        if (!NT_SUCCESS(ntStatus) && descriptorTypeAndIndex == 0) {
            descriptorTypeAndIndex = 0x2900;
            goto USBH_SyncGetHubDescriptor_Retry;
        } else {

            if (hubDescriptor->bDescriptorLength > numBytes) {
                numBytes = hubDescriptor->bDescriptorLength;
                UsbhExFreePool(hubDescriptor);
                goto USBH_SyncGetHubDescriptor_Retry2;
            }

        }

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (NT_SUCCESS(ntStatus)) {
        PPORT_DATA p;
        ULONG i;

        //
        // So, we have obtained hub descriptor. Now prepare port data
        //

        numberOfPorts = (ULONG) hubDescriptor->bNumberOfPorts;

        USBH_KdPrint((2,"'GetHubDescriptor %x Hub has %d ports\n", hubDescriptor, numberOfPorts));

        if (DeviceExtensionHub->PortData) {
            // we already have port data, re-init the flags
            p = portData = DeviceExtensionHub->PortData;
            for (i=0; i<numberOfPorts; i++, p++) {
                p->PortState.PortStatus = 0;
                p->PortState.PortChange = 0;
                if (extHubInfo != NULL) {
                    p->PortAttributes = extHubInfo->Port[i].PortAttributes;
                } else {
                    p->PortAttributes = 0;
                }                    

                // In the case of hub start after stop, we want ConnectionStatus
                // to accurately reflect the status of the port, depending on
                // if there is a device connected or not.  Note that QBR
                // used to do this but this broke the UI in the case of
                // overcurrent, bandwidth error, etc., so now we do this here.

                if (p->DeviceObject) {
                    p->ConnectionStatus = DeviceConnected;
                } else {
                    p->ConnectionStatus = NoDeviceConnected;
                }
            }
        } else {

            // Weird.  Test found a case where if they had DriverVerifier
            // fault injection turned on we bugcheck in the following call.
            // We bugchecked because we were asking for zero bytes, so it
            // is somehow possible to end up here with ntStatus == STATUS_SUCCESS
            // and numberOfPorts == 0.  So, we have to guard for that here.

            if (numberOfPorts) {
                portData = UsbhExAllocatePool(NonPagedPool,
                                sizeof(PORT_DATA) * numberOfPorts);
            } else {
                portData = NULL;
            }

            if (portData) {
                RtlZeroMemory(portData, sizeof(PORT_DATA) * numberOfPorts);
                p = portData;
                for (i=0; i<numberOfPorts; i++, p++) {
                    p->ConnectionStatus = NoDeviceConnected;
                    
                    if (extHubInfo != NULL) {
                        p->PortAttributes = extHubInfo->Port[i].PortAttributes;
                    }
                }
            }
        }

        if (NULL == portData) {
            USBH_KdBreak(("GetHubDescriptor alloc port_data failed\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        } 
        
    }

    if (NT_SUCCESS(ntStatus)) {
        //
        // Remember our HubDescriptor and PortData
        //
        DeviceExtensionHub->HubDescriptor = hubDescriptor;
        DeviceExtensionHub->PortData = portData;
    } else {
        if (hubDescriptor) {
            UsbhExFreePool(hubDescriptor);
        }
    }

    if (extHubInfo != NULL) {
        UsbhExFreePool(extHubInfo);
    }

    USBH_KdPrint((2,"'Exit GetHubDescriptor %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_SyncFeatureRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT FeatureSelector,
    IN USHORT Index,
    IN USHORT Target,
    IN BOOLEAN ClearFeature
    )
 /* ++
  * 
  * Description:
  *
  * DeviceObject - may be either a device PDO or the TopOfDeviceStack for the 
  *         hub
  *
  * Return:
  * 
  * NTSTATUS
  * 
  * -- */
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_SyncFeatureRequest\n"));

    //
    // Allocate an Urb .
    //

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_FEATURE_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("USBH_SyncFeatureRequest fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    
    if (urb) {
        USHORT op;    
        //
        // got the urb no try to get descriptor data
        //

        if (ClearFeature) {
            switch(Target) {
            case TO_USB_DEVICE:
                op = URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE;
                break;
                
            case TO_USB_INTERFACE:
                op = URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE;
                break;
                
            case TO_USB_ENDPOINT:
                op = URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT;
                break;
            }
        } else {
            switch(Target) {
            case TO_USB_DEVICE:
                op = URB_FUNCTION_SET_FEATURE_TO_DEVICE;
                break;
                
            case TO_USB_INTERFACE:
                op = URB_FUNCTION_SET_FEATURE_TO_INTERFACE;
                break;
                
            case TO_USB_ENDPOINT:
                op = URB_FUNCTION_SET_FEATURE_TO_ENDPOINT;
                break;
            }
        }

        UsbBuildFeatureRequest(urb,
                               op,
                               FeatureSelector,
                               Index,
                               NULL);

        ntStatus = USBH_SyncSubmitUrb(DeviceObject, urb);

        UsbhExFreePool(urb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\hub.pnp\pnppower.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    PNPPOWER.C

Abstract:

    This module contains functions to access registry.

Author:

    John Lee

Environment:

    kernel mode only

Notes:


Revision History:

    4-2-96 : created

--*/

#include <wdm.h>
#include <windef.h>
#include <unknown.h>
#ifdef DRM_SUPPORT
#include <ks.h>
#include <ksmedia.h>
#include <drmk.h>
#include <ksdrmhlp.h>
#endif
#ifdef WMI_SUPPORT
#include <wmilib.h>
#endif /* WMI_SUPPORT */
#include <initguid.h>
#include <wdmguid.h>
#include <ntddstor.h>   // Needed for IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER
#include "usbhub.h"


#define BANDWIDTH_TIMEOUT   1000     // Timeout in ms (1 sec)


#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBH_BuildDeviceID)
#pragma alloc_text(PAGE, USBH_BuildHardwareIDs)
#pragma alloc_text(PAGE, USBH_BuildCompatibleIDs)
#pragma alloc_text(PAGE, USBH_BuildInstanceID)
#pragma alloc_text(PAGE, USBH_ProcessDeviceInformation)
#pragma alloc_text(PAGE, USBH_ValidateSerialNumberString)
#pragma alloc_text(PAGE, USBH_CreateDevice)
#pragma alloc_text(PAGE, USBH_PdoQueryId)
#pragma alloc_text(PAGE, USBH_PdoPnP)
#pragma alloc_text(PAGE, USBH_PdoQueryCapabilities)
#pragma alloc_text(PAGE, USBH_PdoQueryDeviceText)
#pragma alloc_text(PAGE, USBH_CheckDeviceIDUnique)
#pragma alloc_text(PAGE, USBH_GetPdoRegistryParameter)
#pragma alloc_text(PAGE, USBH_OsVendorCodeQueryRoutine)
#pragma alloc_text(PAGE, USBH_GetMsOsVendorCode)
#pragma alloc_text(PAGE, USBH_GetMsOsFeatureDescriptor)
#pragma alloc_text(PAGE, USBH_InstallExtPropDesc)
#pragma alloc_text(PAGE, USBH_InstallExtPropDescSections)
#pragma alloc_text(PAGE, USBH_GetExtConfigDesc)
#pragma alloc_text(PAGE, USBH_ValidateExtConfigDesc)
#ifdef DRM_SUPPORT
#pragma alloc_text(PAGE, USBH_PdoSetContentId)
#endif
#endif
#endif

//
// The macro and the array make conversion from hex to strings easy for building DeviceId etc.
//

#define NibbleToHex( byte ) ((UCHAR)Nibble[byte])
CHAR Nibble[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

#define NibbleToHexW( byte ) (NibbleW[byte])
WCHAR NibbleW[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

#ifdef WMI_SUPPORT
#define NUM_PORT_WMI_SUPPORTED_GUIDS    1

WMIGUIDREGINFO USB_PortWmiGuidList[NUM_PORT_WMI_SUPPORTED_GUIDS];
#endif /* WMI_SUPPORT */


WCHAR VidPidRevString[] = L"USB\\Vid_nnnn&Pid_nnnn&Rev_nnnn&Mi_nn";
WCHAR VidPidString[] = L"USB\\Vid_nnnn&Pid_nnnn&Mi_nn";


USB_CONNECTION_STATUS
UsbhGetConnectionStatus(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /*
  * Description:
  *
  *     returns the connection status for a PDO
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_HUB   deviceExtensionHub;

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;

    if (DeviceExtensionPort->PortPdoFlags &
        PORTPDO_DEVICE_ENUM_ERROR) {
        return DeviceFailedEnumeration;
    } else if (DeviceExtensionPort->PortPdoFlags &
               PORTPDO_NOT_ENOUGH_POWER) {
        return DeviceNotEnoughPower;
    } else if (DeviceExtensionPort->PortPdoFlags &
               PORTPDO_DEVICE_FAILED) {
        return DeviceGeneralFailure;
    } else if (DeviceExtensionPort->PortPdoFlags &
               PORTPDO_OVERCURRENT) {
        return DeviceCausedOvercurrent;
    } else if (DeviceExtensionPort->PortPdoFlags &
               PORTPDO_NO_BANDWIDTH) {
        return DeviceNotEnoughBandwidth;
    } else if (DeviceExtensionPort->PortPdoFlags &
               PORTPDO_USB20_DEVICE_IN_LEGACY_HUB) {
        return DeviceInLegacyHub;
    }

    // otherwise just return "device connected"
    return DeviceConnected;

}


VOID
USBH_BandwidthTimeoutWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to handle a bandwidth timeout.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_BANDWIDTH_TIMEOUT_WORK_ITEM   workItemBandwidthTimeout;
    PDEVICE_EXTENSION_PORT              deviceExtensionPort;

    workItemBandwidthTimeout = Context;
    deviceExtensionPort = workItemBandwidthTimeout->DeviceExtensionPort;

    USBH_KdPrint((2,"'Bandwidth timeout\n"));

    USBH_PdoEvent(deviceExtensionPort->DeviceExtensionHub,
                  deviceExtensionPort->PortNumber);

    UsbhExFreePool(workItemBandwidthTimeout);
}


VOID
USBH_PortTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.



Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext -

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PPORT_TIMEOUT_CONTEXT portTimeoutContext = DeferredContext;
    PDEVICE_EXTENSION_PORT deviceExtensionPort =
                                portTimeoutContext->DeviceExtensionPort;
    BOOLEAN cancelFlag;
    PUSBH_BANDWIDTH_TIMEOUT_WORK_ITEM workItemBandwidthTimeout;

    USBH_KdPrint((2,"'BANDWIDTH_TIMEOUT\n"));

    // Take SpinLock here so that main routine won't write CancelFlag
    // in the timeout context while we free the timeout context.

    KeAcquireSpinLockAtDpcLevel(&deviceExtensionPort->PortSpinLock);

    cancelFlag = portTimeoutContext->CancelFlag;
    deviceExtensionPort->PortTimeoutContext = NULL;

    KeReleaseSpinLockFromDpcLevel(&deviceExtensionPort->PortSpinLock);

    UsbhExFreePool(portTimeoutContext);

    if (!cancelFlag) {
        //
        // Schedule a work item to process this.
        //
        workItemBandwidthTimeout = UsbhExAllocatePool(NonPagedPool,
                                    sizeof(USBH_BANDWIDTH_TIMEOUT_WORK_ITEM));

        if (workItemBandwidthTimeout) {

            workItemBandwidthTimeout->DeviceExtensionPort = deviceExtensionPort;

            ExInitializeWorkItem(&workItemBandwidthTimeout->WorkQueueItem,
                                 USBH_BandwidthTimeoutWorker,
                                 workItemBandwidthTimeout);

            LOGENTRY(LOG_PNP, "bERR", deviceExtensionPort,
                &workItemBandwidthTimeout->WorkQueueItem, 0);

            ExQueueWorkItem(&workItemBandwidthTimeout->WorkQueueItem,
                            DelayedWorkQueue);

            // The WorkItem is freed by USBH_BandwidthTimeoutWorker()
            // Don't try to access the WorkItem after it is queued.
        }
    }
}


NTSTATUS
USBH_SelectConfigOrInterface_Complete(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context
    )
 /* ++
  *
  * Description:
  *
  *     Take some action based on change
  *
  * Arguments:
  *
  * Return:
  *
  *
  * -- */
{
    PDEVICE_EXTENSION_PORT deviceExtensionPort = Context;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = NULL;
    PPORT_DATA portData = NULL;
    NTSTATUS ntStatus;
    PURB urb;
    PIO_STACK_LOCATION ioStackLocation;
    PPORT_TIMEOUT_CONTEXT portTimeoutContext = NULL;
    LARGE_INTEGER dueTime;
    KIRQL irql;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    deviceExtensionHub = deviceExtensionPort->DeviceExtensionHub;
    if (deviceExtensionHub) {
        portData = &deviceExtensionHub->PortData[deviceExtensionPort->PortNumber - 1];
    }

    ntStatus = Irp->IoStatus.Status;
    if (ntStatus == STATUS_SUCCESS) {
        //
        // "Cancel" timer.
        //
        // Take SpinLock here so that DPC routine won't free
        // the timeout context while we write the CancelFlag
        // in the timeout context.
        //
        KeAcquireSpinLock(&deviceExtensionPort->PortSpinLock, &irql);

        if (deviceExtensionPort->PortTimeoutContext) {
            USBH_KdPrint((2,"'Bandwidth allocation successful, cancelling timeout\n"));

            portTimeoutContext = deviceExtensionPort->PortTimeoutContext;
            portTimeoutContext->CancelFlag = TRUE;

            if (KeCancelTimer(&portTimeoutContext->TimeoutTimer)) {
                //
                // We cancelled the timer before it could run.  Free the context.
                //
                UsbhExFreePool(portTimeoutContext);
                deviceExtensionPort->PortTimeoutContext = NULL;
            }
        }

        KeReleaseSpinLock(&deviceExtensionPort->PortSpinLock, irql);

        // clear the error
        deviceExtensionPort->PortPdoFlags &=
               ~(PORTPDO_DEVICE_FAILED | PORTPDO_NO_BANDWIDTH);

        // Don't stomp connection status for a hub that is nested too
        // deeply.

        if (portData &&
            portData->ConnectionStatus != DeviceHubNestedTooDeeply) {

            portData->ConnectionStatus = DeviceConnected;
        }

    } else {
        // extract the URB
        ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
        urb = ioStackLocation->Parameters.Others.Argument1;

        if (urb->UrbHeader.Status == USBD_STATUS_NO_BANDWIDTH) {

            deviceExtensionPort->RequestedBandwidth = 0;

            if (urb->UrbHeader.Function == URB_FUNCTION_SELECT_INTERFACE) {
                USBH_CalculateInterfaceBandwidth(
                    deviceExtensionPort,
                    &urb->UrbSelectInterface.Interface,
                    &deviceExtensionPort->RequestedBandwidth);
            } else if (urb->UrbHeader.Function ==
                       URB_FUNCTION_SELECT_CONFIGURATION){
                // we need to walk through the config
                // and get all the interfcaces
                PUCHAR pch, end;
                PUSBD_INTERFACE_INFORMATION iface;

                end = (PUCHAR) urb;
                end += urb->UrbHeader.Length;
                pch = (PUCHAR) &urb->UrbSelectConfiguration.Interface;
                iface = (PUSBD_INTERFACE_INFORMATION) pch;

                while (pch < end) {
                    USBH_CalculateInterfaceBandwidth(
                        deviceExtensionPort,
                        iface,
                        &deviceExtensionPort->RequestedBandwidth);

                    pch += iface->Length;
                    iface = (PUSBD_INTERFACE_INFORMATION) pch;
                }

            } else {
                // did we miss something?
                TEST_TRAP();
            }

            deviceExtensionPort->PortPdoFlags |=
                PORTPDO_NO_BANDWIDTH;

            if (portData) {
                portData->ConnectionStatus = DeviceNotEnoughBandwidth;
            }

            if (!deviceExtensionPort->PortTimeoutContext) {
                USBH_KdPrint((2,"'Start bandwidth timeout\n"));
                portTimeoutContext = UsbhExAllocatePool(NonPagedPool,
                                        sizeof(*portTimeoutContext));

                if (portTimeoutContext) {

                    portTimeoutContext->CancelFlag = FALSE;

                    // Maintain links between the device extension and the
                    // timeout context.
                    deviceExtensionPort->PortTimeoutContext = portTimeoutContext;
                    portTimeoutContext->DeviceExtensionPort = deviceExtensionPort;

                    KeInitializeTimer(&portTimeoutContext->TimeoutTimer);
                    KeInitializeDpc(&portTimeoutContext->TimeoutDpc,
                                    USBH_PortTimeoutDPC,
                                    portTimeoutContext);
                }

            }
#if DBG
             else {
                USBH_KdPrint((2,"'Reset bandwidth timeout\n"));
            }
#endif

            dueTime.QuadPart = -10000 * BANDWIDTH_TIMEOUT;

            // Take spinlock here in case DPC routine fires and deallocates
            // the timer context before we have had the chance to reset the
            // timer (in the case where we are resetting an existing timer).

            KeAcquireSpinLock(&deviceExtensionPort->PortSpinLock, &irql);

            portTimeoutContext = deviceExtensionPort->PortTimeoutContext;
            if (portTimeoutContext) {
                KeSetTimer(&portTimeoutContext->TimeoutTimer,
                           dueTime,
                           &portTimeoutContext->TimeoutDpc);
            }

            KeReleaseSpinLock(&deviceExtensionPort->PortSpinLock, irql);

        }
    }

    return ntStatus;
}


NTSTATUS
USBH_PdoUrbFilter(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /*
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PURB urb;
    USHORT function;
    PDEVICE_OBJECT deviceObject;
    PPORT_DATA portData;

    USBH_KdPrint((2,"'USBH_PdoUrbFilter DeviceExtension %x Irp %x\n",
        DeviceExtensionPort, Irp));

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;

    LOGENTRY(LOG_PNP, "pURB", DeviceExtensionPort, deviceExtensionHub,
        deviceExtensionHub->HubFlags);

    portData = &deviceExtensionHub->PortData[DeviceExtensionPort->PortNumber - 1];
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    urb = ioStackLocation->Parameters.Others.Argument1;

#if DBG
    if (!(DeviceExtensionPort->PortPdoFlags & PORTPDO_STARTED) &&
        (DeviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET)) {
        UsbhWarning(DeviceExtensionPort,
           "Device Driver is sending requests before passing start irp\n, Please rev your driver.\n",
           TRUE);
    }
#endif

    //
    // in some cases we will need to fail bus requests here.
    //

//    if (DeviceExtensionPort->DeviceState != PowerDeviceD0) {
//        // fail any call that is sent to a PDO for a suspended device
//        UsbhWarning(DeviceExtensionPort,
//                    "Device Driver is sending requests while in low power state!\n",
//                    TRUE);
//        ntStatus = STATUS_INVALID_PARAMETER;
//    }
#if DBG
    if (DeviceExtensionPort->DeviceState != PowerDeviceD0) {
        USBH_KdPrint((1, "'URB request, device not in D0\n"));
    }
#endif

    if (DeviceExtensionPort->PortPdoFlags & (PORTPDO_DEVICE_FAILED | PORTPDO_RESET_PENDING)) {
        USBH_KdPrint((1, "'failing request to failed PDO\n"));
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    // check for error, if we have one, bail
    if (!NT_SUCCESS(ntStatus)) {
        urb->UrbHeader.Status = USBD_STATUS_INVALID_PARAMETER;
        USBH_CompleteIrp(Irp, ntStatus);
        goto USBH_PdoUrbFilter_Done;
    }

    // check the command code code the URB

    function = urb->UrbHeader.Function;

    LOGENTRY(LOG_PNP, "URB+", DeviceExtensionPort,
                function,
                urb);

    switch(function) {
    case URB_FUNCTION_SELECT_CONFIGURATION:

        if (urb->UrbSelectConfiguration.ConfigurationDescriptor != NULL) {
            LONG powerRequired;

            // validate the descriptor passed to us before we
            // attempt to refernce it

            {
            PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
            USBD_STATUS usbdStatus;

            configurationDescriptor =
                urb->UrbSelectConfiguration.ConfigurationDescriptor;

            if (!USBH_ValidateConfigurationDescriptor(
                    configurationDescriptor,
                    &usbdStatus)) {

                urb->UrbHeader.Status =
                    usbdStatus;
                ntStatus = STATUS_INVALID_PARAMETER;
                USBH_CompleteIrp(Irp, ntStatus);

                goto USBH_PdoUrbFilter_Done;
            }
            }

            //
            // make sure there is enough power on this port
            //

            DeviceExtensionPort->PowerRequested =
                powerRequired =
                    ((LONG)urb->UrbSelectConfiguration.ConfigurationDescriptor->MaxPower)*2;

#if DBG
            if (UsbhPnpTest & PNP_TEST_FAIL_DEV_POWER) {
                powerRequired = 99999;
            }
#endif
            USBH_KdPrint((2,"'request power: avail = %d Need = %d\n",
                    deviceExtensionHub->MaximumPowerPerPort, powerRequired));

            if (deviceExtensionHub->MaximumPowerPerPort < powerRequired) {
                USBH_KdPrint((1, "'**insufficient power for device\n"));

                // not enough power for this device

                // mark the PDO
                DeviceExtensionPort->PortPdoFlags |=
                    PORTPDO_NOT_ENOUGH_POWER;

                USBH_InvalidatePortDeviceState(
                        deviceExtensionHub,
                        UsbhGetConnectionStatus(DeviceExtensionPort),
                        DeviceExtensionPort->PortNumber);

                ntStatus = STATUS_INVALID_PARAMETER;
                USBH_CompleteIrp(Irp, ntStatus);

                goto USBH_PdoUrbFilter_Done;
            }
        }

        // check for BW failure

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(Irp,
                           USBH_SelectConfigOrInterface_Complete,
                           // always pass FDO to completion routine
                           DeviceExtensionPort,
                           TRUE,
                           TRUE,
                           TRUE);

        ntStatus = IoCallDriver(deviceExtensionHub->TopOfHcdStackDeviceObject, Irp);
        goto USBH_PdoUrbFilter_Done;
        break;

    case URB_FUNCTION_SELECT_INTERFACE:
        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(Irp,
                           USBH_SelectConfigOrInterface_Complete,
                           // always pass FDO to completion routine
                           DeviceExtensionPort,
                           TRUE,
                           TRUE,
                           TRUE);

        ntStatus = IoCallDriver(deviceExtensionHub->TopOfHcdStackDeviceObject, Irp);
        goto USBH_PdoUrbFilter_Done;
        break;

    //
    // we could fail everything provided we abort
    // all the drivers pipes.
    //
    // fail any transfers if delete is pending
    case URB_FUNCTION_CONTROL_TRANSFER:
    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
    case URB_FUNCTION_ISOCH_TRANSFER:

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DELETE_PENDING) {
            USBH_KdPrint((2,"'failing request with STATUS_DELETE_PENDING\n"));
            ntStatus = STATUS_DELETE_PENDING;

            urb->UrbHeader.Status = USBD_STATUS_INVALID_PARAMETER;
            USBH_CompleteIrp(Irp, ntStatus);
            goto USBH_PdoUrbFilter_Done;
        }
        break;

    case URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR:

        LOGENTRY(LOG_PNP, "MSOS", DeviceExtensionPort,
            DeviceExtensionPort->PortPdoFlags, 0);
        USBH_KdPrint((1,"'URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR\n"));

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DELETE_PENDING) {
            USBH_KdPrint((1,"'GET_MS_FEATURE_DESC: failing request with STATUS_DELETE_PENDING\n"));
            ntStatus = STATUS_DELETE_PENDING;

            urb->UrbHeader.Status = USBD_STATUS_INVALID_PARAMETER;
            USBH_CompleteIrp(Irp, ntStatus);
            goto USBH_PdoUrbFilter_Done;
        }
#ifndef USBHUB20
        ntStatus = USBH_GetMsOsFeatureDescriptor(
                       deviceObject,
                       urb->UrbOSFeatureDescriptorRequest.Recipient,
                       urb->UrbOSFeatureDescriptorRequest.InterfaceNumber,
                       urb->UrbOSFeatureDescriptorRequest.MS_FeatureDescriptorIndex,
                       urb->UrbOSFeatureDescriptorRequest.TransferBuffer,
                       urb->UrbOSFeatureDescriptorRequest.TransferBufferLength,
                       &urb->UrbOSFeatureDescriptorRequest.TransferBufferLength);
#endif
        if (NT_SUCCESS(ntStatus))
        {
            urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
        }
        else
        {
            // arbitrary URB error status...
            //
            urb->UrbHeader.Status = USBD_STATUS_INVALID_PARAMETER;
        }

        USBH_CompleteIrp(Irp, ntStatus);
        goto USBH_PdoUrbFilter_Done;
        break;

    default:
        // just pass thru
        break;
    }

    ntStatus = USBH_PassIrp(Irp,
                            deviceExtensionHub->TopOfHcdStackDeviceObject);


USBH_PdoUrbFilter_Done:

    return ntStatus;
}


PWCHAR
USBH_BuildDeviceID(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN LONG MiId,
    IN BOOLEAN IsHubClass
    )
 /* ++
  *
  * Descrioption:
  *
  * This function build bus Id wide string for the PDO based on the Vendor Id
  * and Product Id. We allocate memory for the string which will be attached
  * to the PDO. L"USB\\Vid_nnnn&Pid_nnnn(&Mi_nn)\0"
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO
  *
  * Return:
  *
  * the pointer to the wide string if successful NULL - otherwise
  *
  * -- */
{
    PWCHAR pwch, p, vid, pid, mi;
    ULONG need;

    PAGED_CODE();

#ifdef USBHUB20
    if (IsHubClass) {
        return USBH_BuildHubDeviceID(IdVendor,
                                     IdProduct,
                                     MiId);
    }
#endif
    USBH_KdPrint((2,"'DeviceId VendorId %04x ProductId %04x interface %04x\n",
        IdVendor, IdProduct, MiId));

    // allow for extra NULL
    need = sizeof(VidPidString) + 2;

    USBH_KdPrint((2,"'allocate %d bytes for device id string\n", need));

    //
    // Must use ExAllocatePool directly here because the OS
    // will free the buffer
    //
    pwch = ExAllocatePoolWithTag(PagedPool, need, USBHUB_HEAP_TAG);
    if (NULL == pwch)
        return NULL;

    RtlZeroMemory(pwch, need);

    p = pwch;

    // BUILD
    // USB\\Vid_nnnn&Pid_nnnn(&Mi_nn){NULL}

    RtlCopyMemory(p, VidPidString, sizeof(VidPidString));

    // now update the id fields
    vid = p + 8;
    pid = p + 17;
    mi = p + 25;

    *vid = NibbleToHex(IdVendor >> 12);
    *(vid+1) = NibbleToHex((IdVendor >> 8) & 0x000f);
    *(vid+2) = NibbleToHex((IdVendor >> 4) & 0x000f);
    *(vid+3) =  NibbleToHex(IdVendor & 0x000f);

    *pid = NibbleToHex(IdProduct >> 12);
    *(pid+1) = NibbleToHex((IdProduct >> 8) & 0x000f);
    *(pid+2) = NibbleToHex((IdProduct >> 4) & 0x000f);
    *(pid+3) = NibbleToHex(IdProduct & 0x000f);

    if (MiId == -1) {
        p = p + 21;
        *p = (WCHAR)NULL;
        p++;
        *p = (WCHAR)NULL;
    } else {
        *mi = NibbleToHex(MiId >> 4);
        *(mi+1) = NibbleToHex(MiId & 0x000f);
    }

    USBH_KdPrint((2,"'Device id string = 0x%x\n", pwch));

    return pwch;
}


PWCHAR
USBH_BuildHardwareIDs(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN USHORT BcdDevice,
    IN LONG MiId,
    IN BOOLEAN IsHubClass
    )
 /* ++
  *
  * Description:
  *
  * This function build HardwareIDs wide multi-string for the PDO based on the
  * Vendor Id, Product Id and Revision Id. We allocate memory for the
  * multi-string which will be attached to the PDO.
  * L"USB\\Vid_nnnn&Pid_nnnn&Rev_nnnn\0USB\\Vid_nnnn&Pid_nnnn\0\0"
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO
  *
  * Return:
  *
  * the pointer to the wide multi-string if successful NULL - otherwise
  *
  * -- */
{
    PWCHAR pwch, p, vid, pid, rev, mi;
    ULONG need;

    PAGED_CODE();

#ifdef USBHUB20
    if (IsHubClass) {
        return USBH_BuildHubHardwareIDs(
                IdVendor,
                IdProduct,
                BcdDevice,
                MiId);
    }
#endif // USBHUB20

    USBH_KdPrint((2,"'HardwareIDs VendorId %04x ProductId %04x Revision %04x interface %04x\n",
        IdVendor, IdProduct, BcdDevice, MiId));

    // allow for extra NULL
    need = sizeof(VidPidRevString) + sizeof(VidPidString) + 2;

    USBH_KdPrint((2,"'allocate %d bytes for id string\n", need));

    //
    // Must use ExAllocatePool directly here because the OS
    // will free the buffer
    //
    pwch = ExAllocatePoolWithTag(PagedPool, need, USBHUB_HEAP_TAG);
    if (NULL == pwch)
        return NULL;

    RtlZeroMemory(pwch, need);

    // build two strings in to buffer:
    // USB\\Vid_nnnn&Pid_nnnn&Rev_nnnn&Mi_nn{NULL}
    // USB\\Vid_nnnn&Pid_nnnn&Mi_nn{NULL}{NULL}

    // BUILD
    // USB\\Vid_nnnn&Pid_nnnn&Rev_nnnn&(Mi_nn){NULL}

    RtlCopyMemory(pwch, VidPidRevString, sizeof(VidPidRevString));

    p = pwch;
    // now update the id fields
    vid = p + 8;
    pid = p + 17;
    rev = p + 26;
    mi = p + 34;

    *vid = NibbleToHex(IdVendor >> 12);
    *(vid+1) = NibbleToHex((IdVendor >> 8) & 0x000f);
    *(vid+2) = NibbleToHex((IdVendor >> 4) & 0x000f);
    *(vid+3) =  NibbleToHex(IdVendor & 0x000f);

    *pid = NibbleToHex(IdProduct >> 12);
    *(pid+1) = NibbleToHex((IdProduct >> 8) & 0x000f);
    *(pid+2) = NibbleToHex((IdProduct >> 4) & 0x000f);
    *(pid+3) = NibbleToHex(IdProduct & 0x000f);

    *rev = BcdNibbleToAscii(BcdDevice >> 12);
    *(rev+1) = BcdNibbleToAscii((BcdDevice >> 8) & 0x000f);
    *(rev+2) = BcdNibbleToAscii((BcdDevice >> 4) & 0x000f);
    *(rev+3) = BcdNibbleToAscii(BcdDevice & 0x000f);

    if (MiId == -1) {
        p = p + 30;
        *p = (WCHAR)NULL;
        p++;
    } else {
        p = p + 37;
        *mi = NibbleToHex(MiId >> 4);
        *(mi+1) = NibbleToHex(MiId & 0x000f);
    }

    // BUILD
    // USB\\Vid_nnnn&Pid_nnnn(&Mi_nn){NULL}

    RtlCopyMemory(p, VidPidString, sizeof(VidPidString));

    // now update the id fields
    vid = p + 8;
    pid = p + 17;
    mi = p + 25;

    *vid = NibbleToHex(IdVendor >> 12);
    *(vid+1) = NibbleToHex((IdVendor >> 8) & 0x000f);
    *(vid+2) = NibbleToHex((IdVendor >> 4) & 0x000f);
    *(vid+3) =  NibbleToHex(IdVendor & 0x000f);

    *pid = NibbleToHex(IdProduct >> 12);
    *(pid+1) = NibbleToHex((IdProduct >> 8) & 0x000f);
    *(pid+2) = NibbleToHex((IdProduct >> 4) & 0x000f);
    *(pid+3) = NibbleToHex(IdProduct & 0x000f);

    if (MiId == -1) {
        p = p + 21;
        *p = (WCHAR)NULL;
        p++;
        *p = (WCHAR)NULL;
    } else {
        *mi = NibbleToHex(MiId >> 4);
        *(mi+1) = NibbleToHex(MiId & 0x000f);
    }

    USBH_KdPrint((2,"'HW id string = 0x%x\n", pwch));

    return pwch;
}


#if 0

PWCHAR
USBH_BuildCompatibleIDs(
    IN UCHAR Class,
    IN UCHAR SubClass,
    IN UCHAR Protocol,
    IN BOOLEAN DeviceClass,
    IN BOOLEAN DeviceIsHighSpeed
    )
 /* ++
  *
  * Descrioption:
  *
  * This function build compatible Ids wide multi-string for the PDO based on
  * the Class and Subclass Ids. We allocate memory for the string which will
  * be attached to the PDO.
  * L"USB\\Class_nn&SubClass_nn&Prot_nn\0"
  * L"USB\\Class_nn&SubClass_nn\0"
  * L"USB\Class_nn\0"
  * L"USB\COMPOSITE\0"
  * L"\0"
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO
  *
  * Return:
  *
  * the pointer to the multi-string if successful NULL - otherwise
  *
  *
  * -- */
{
    PWCHAR pwch, pwch1;
    ULONG ulBytes;
    ULONG ulTotal;
    BOOLEAN ControlerIsHS = FALSE;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter BuildCompatibleIDs\n"));

#ifdef USBHUB20
    ControlerIsHS = TRUE;
#endif
// if this is a high speed controller (USB2) then we must
// generate a different set of compat ids to be backward
// compatible with the goatpack
    if (Class == USB_DEVICE_CLASS_HUB &&
        ControlerIsHS) {
        return USBH_BuildHubCompatibleIDs(
                Class,
                SubClass,
                Protocol,
                DeviceClass,
                DeviceIsHighSpeed);
    }
//#endif

    STRLEN(ulBytes, pwchUsbSlash);
    ulTotal = ulBytes * 3;      // 3 sets of L"USB\\"
    if (DeviceClass) {
        STRLEN(ulBytes, pwchDevClass);
        ulTotal += ulBytes * 3;     // 3 sets of L"DevClass_"
        STRLEN(ulBytes, pwchComposite);
        ulTotal += ulBytes;         // "USB\COMPOSITE"
    } else {
        STRLEN(ulBytes, pwchClass);
        ulTotal += ulBytes * 3;     // 3 sets of L"Class_"
    }
    STRLEN(ulBytes, pwchSubClass);
    ulTotal += ulBytes * 2;     // 2 sets of L"SubClass_"
    STRLEN(ulBytes, pwchProt);
    ulTotal += ulBytes;         // 1 set of L"Prot_"
    ulTotal += sizeof(WCHAR) * (2 * 6 + 3 + 5);   // 6 sets of 2 digits, 3 '&'s,
                                            // and 5 nulls
    //
    // Must use ExAllocatePool directly here because the OS
    // will free the buffer
    //
    pwch = ExAllocatePoolWithTag(PagedPool, ulTotal, USBHUB_HEAP_TAG);
    if (NULL == pwch)
        return NULL;

    USBH_KdPrint((2,"'Interface Class %02x SubClass %02x Protocol %02x\n",
                  Class, SubClass, Protocol));

    //
    // First string
    //
    STRCPY(pwch, pwchUsbSlash);

    //
    // ClassId
    //
    if (DeviceClass) {
        STRCAT(pwch, pwchDevClass);
    } else {
        STRCAT(pwch, pwchClass);
    }
    APPEND(pwch, NibbleToHex((Class) >> 4));
    APPEND(pwch, NibbleToHex((Class) & 0x0f));
    APPEND(pwch, '&');

    //
    // SubClassId
    //
    STRCAT(pwch, pwchSubClass);
    APPEND(pwch, NibbleToHex((SubClass) >> 4));
    APPEND(pwch, NibbleToHex((SubClass) & 0x0f));
    APPEND(pwch, '&');

    //
    // DeviceProtocol
    //
    STRCAT(pwch, pwchProt);
    APPEND(pwch, NibbleToHex((Protocol) >> 4));
    APPEND(pwch, NibbleToHex((Protocol) & 0x0f));

    //
    // Second string
    //
    STRLEN(ulBytes, pwch);
    pwch1 = &pwch[ulBytes / 2 + 1]; // second string
    STRCPY(pwch1, pwchUsbSlash);

    //
    // ClassId
    //
    if (DeviceClass) {
        STRCAT(pwch1, pwchDevClass);
    } else {
        STRCAT(pwch1, pwchClass);
    }
    APPEND(pwch1, NibbleToHex((Class) >> 4));
    APPEND(pwch1, NibbleToHex((Class) & 0x0f));
    APPEND(pwch1, '&');

    //
    // SubClassId
    //
    STRCAT(pwch1, pwchSubClass);
    APPEND(pwch1, NibbleToHex((SubClass) >> 4));
    APPEND(pwch1, NibbleToHex((SubClass) & 0x0f));

    //
    // Third string USB\Class_nn
    //
    STRLEN(ulBytes, pwch1);
    pwch1 = &pwch1[ulBytes / 2 + 1];    // third string
    STRCPY(pwch1, pwchUsbSlash);

    //
    // Class Id
    //
    if (DeviceClass) {
        STRCAT(pwch1, pwchDevClass);
    } else {
        STRCAT(pwch1, pwchClass);
    }
    APPEND(pwch1, NibbleToHex((Class) >> 4));
    APPEND(pwch1, NibbleToHex((Class) & 0x0f));

    //
    // Third string
    //
    // STRLEN( ulBytes, pwch1 );
    // pwch1 = &pwch1[ulBytes /2 + 1];       // third string
    // STRCPY( pwch1, pwchUsbSlash );

    //
    // ClassId
    //
    // APPEND( pwch1, NibbleToHex((pDeviceDescriptor->bDeviceClass)>>4));
    // APPEND( pwch1, NibbleToHex((pDeviceDescriptor->bDeviceClass) & 0x0f));

    //
    // SubClassId
    //
    // APPEND( pwch1, NibbleToHex((pDeviceDescriptor->bDeviceSubClass) >>
    // 4));
    // APPEND( pwch1, NibbleToHex((pDeviceDescriptor->bDeviceSubClass)
    // &0x0f));

    if (DeviceClass) {
        STRLEN(ulBytes, pwch1);
        pwch1 = &pwch1[ulBytes / 2 + 1];
        STRCPY(pwch1, pwchComposite);
    }

    //
    // double null termination
    //

    APPEND(pwch1, 0);

    return pwch;
}

#else

typedef struct _DEVCLASS_COMAPTIBLE_IDS
{
    // L"USB\\DevClass_nn&SubClass_nn&Prot_nn\0"
    //
    WCHAR   ClassStr1[sizeof(L"USB\\DevClass_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex1[2];
    WCHAR   SubClassStr1[sizeof(L"&SubClass_")/sizeof(WCHAR)-1];
    WCHAR   SubClassHex1[2];
    WCHAR   Prot1[sizeof(L"&Prot_")/sizeof(WCHAR)-1];
    WCHAR   ProtHex1[2];
    WCHAR   Null1[1];

    // L"USB\\DevClass_nn&SubClass_nn\0"
    //
    WCHAR   DevClassStr2[sizeof(L"USB\\DevClass_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex2[2];
    WCHAR   SubClassStr2[sizeof(L"&SubClass_")/sizeof(WCHAR)-1];
    WCHAR   SubClassHex2[2];
    WCHAR   Null2[1];

    // L"USB\\DevClass_nn&SubClass_nn\0"
    //
    WCHAR   ClassStr3[sizeof(L"USB\\DevClass_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex3[2];
    WCHAR   Null3[1];

    // L"USB\\COMPOSITE\0"
    //
    WCHAR   CompositeStr[sizeof(L"USB\\COMPOSITE")/sizeof(WCHAR)-1];
    WCHAR   Null4[1];

    WCHAR   DoubleNull[1];

} DEVCLASS_COMAPTIBLE_IDS, *PDEVCLASS_COMAPTIBLE_IDS;


typedef struct _CLASS_COMAPTIBLE_IDS
{
    // L"USB\\Class_nn&SubClass_nn&Prot_nn\0"
    //
    WCHAR   ClassStr1[sizeof(L"USB\\Class_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex1[2];
    WCHAR   SubClassStr1[sizeof(L"&SubClass_")/sizeof(WCHAR)-1];
    WCHAR   SubClassHex1[2];
    WCHAR   Prot1[sizeof(L"&Prot_")/sizeof(WCHAR)-1];
    WCHAR   ProtHex1[2];
    WCHAR   Null1[1];

    // L"USB\\Class_nn&SubClass_nn\0"
    //
    WCHAR   ClassStr2[sizeof(L"USB\\Class_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex2[2];
    WCHAR   SubClassStr2[sizeof(L"&SubClass_")/sizeof(WCHAR)-1];
    WCHAR   SubClassHex2[2];
    WCHAR   Null2[1];

    // L"USB\\Class_nn&SubClass_nn\0"
    //
    WCHAR   ClassStr3[sizeof(L"USB\\Class_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex3[2];
    WCHAR   Null3[1];

    WCHAR   DoubleNull[1];

} CLASS_COMAPTIBLE_IDS, *PCLASS_COMAPTIBLE_IDS;


static DEVCLASS_COMAPTIBLE_IDS DevClassCompatibleIDs =
{
    // L"USB\\DevClass_nn&SubClass_nn&Prot_nn\0"
    //
    {'U','S','B','\\','D','e','v','C','l','a','s','s','_'},
    {'n','n'},
    {'&','S','u','b','C','l','a','s','s','_'},
    {'n','n'},
    {'&','P','r','o','t','_'},
    {'n','n'},
    {0},

    // L"USB\\DevClass_nn&SubClass_nn\0"
    //
    {'U','S','B','\\','D','e','v','C','l','a','s','s','_'},
    {'n','n'},
    {'&','S','u','b','C','l','a','s','s','_'},
    {'n','n'},
    {0},

    // L"USB\\DevClass_nn\0"
    //
    {'U','S','B','\\','D','e','v','C','l','a','s','s','_'},
    {'n','n'},
    {0},

    // L"USB\\COMPOSITE\0"
    //
    {'U','S','B','\\','C','O','M','P','O','S','I','T','E'},
    {0},

    {0}
};

static CLASS_COMAPTIBLE_IDS ClassCompatibleIDs =
{
    // L"USB\\Class_nn&SubClass_nn&Prot_nn\0"
    //
    {'U','S','B','\\','C','l','a','s','s','_'},
    {'n','n'},
    {'&','S','u','b','C','l','a','s','s','_'},
    {'n','n'},
    {'&','P','r','o','t','_'},
    {'n','n'},
    {0},

    // L"USB\\Class_nn&SubClass_nn\0"
    //
    {'U','S','B','\\','C','l','a','s','s','_'},
    {'n','n'},
    {'&','S','u','b','C','l','a','s','s','_'},
    {'n','n'},
    {0},

    // L"USB\\Class_nn\0"
    //
    {'U','S','B','\\','C','l','a','s','s','_'},
    {'n','n'},
    {0},

    {0}
};

PWCHAR
USBH_BuildCompatibleIDs(
    IN PUCHAR   CompatibleID,
    IN PUCHAR   SubCompatibleID,
    IN UCHAR    Class,
    IN UCHAR    SubClass,
    IN UCHAR    Protocol,
    IN BOOLEAN  DeviceClass,
    IN BOOLEAN  DeviceIsHighSpeed
    )
{
    ULONG   ulTotal;
    PWCHAR  pwch;

    WCHAR   ClassHi     = NibbleToHexW((Class) >> 4);
    WCHAR   ClassLo     = NibbleToHexW((Class) & 0x0f);
    WCHAR   SubClassHi  = NibbleToHexW((SubClass) >> 4);
    WCHAR   SubClassLo  = NibbleToHexW((SubClass) & 0x0f);
    WCHAR   ProtocolHi  = NibbleToHexW((Protocol) >> 4);
    WCHAR   ProtocolLo  = NibbleToHexW((Protocol) & 0x0f);

    BOOLEAN ControlerIsHS = FALSE;

    PAGED_CODE();

#ifdef USBHUB20
    ControlerIsHS = TRUE;
#endif
// if this is a high speed controller (USB2) then we must
// generate a different set of compat ids to be backward
// compatible with the goatpack
    if (Class == USB_DEVICE_CLASS_HUB &&
        ControlerIsHS) {
        return USBH_BuildHubCompatibleIDs(
                Class,
                SubClass,
                Protocol,
                DeviceClass,
                DeviceIsHighSpeed);
    }
//#endif

    if (DeviceClass)
    {
        ulTotal = sizeof(DEVCLASS_COMAPTIBLE_IDS);
    }
    else
    {
        ulTotal = sizeof(CLASS_COMAPTIBLE_IDS);

        if (SubCompatibleID[0] != 0)
        {
            ulTotal += sizeof(L"USB\\MS_COMP_xxxxxxxx&MS_SUBCOMP_xxxxxxxx");
        }

        if (CompatibleID[0] != 0)
        {
            ulTotal += sizeof(L"USB\\MS_COMP_xxxxxxxx");
        }
    }

    pwch = ExAllocatePoolWithTag(PagedPool, ulTotal, USBHUB_HEAP_TAG);

    if (pwch)
    {
        if (DeviceClass)
        {
            PDEVCLASS_COMAPTIBLE_IDS pDevClassIds;

            pDevClassIds = (PDEVCLASS_COMAPTIBLE_IDS)pwch;

            // Copy over the constant set of strings:
            // L"USB\\DevClass_nn&SubClass_nn&Prot_nn\0"
            // L"USB\\DevClass_nn&SubClass_nn\0"
            // L"USB\\DevClass_nn&SubClass_nn\0"
            // L"USB\\COMPOSITE\0"
            //
            RtlCopyMemory(pDevClassIds,
                          &DevClassCompatibleIDs,
                          sizeof(DEVCLASS_COMAPTIBLE_IDS));

            // Fill in the 'nn' blanks
            //
            pDevClassIds->ClassHex1[0] =
            pDevClassIds->ClassHex2[0] =
            pDevClassIds->ClassHex3[0] = ClassHi;

            pDevClassIds->ClassHex1[1] =
            pDevClassIds->ClassHex2[1] =
            pDevClassIds->ClassHex3[1] = ClassLo;

            pDevClassIds->SubClassHex1[0] =
            pDevClassIds->SubClassHex2[0] = SubClassHi;

            pDevClassIds->SubClassHex1[1] =
            pDevClassIds->SubClassHex2[1] = SubClassLo;

            pDevClassIds->ProtHex1[0] = ProtocolHi;

            pDevClassIds->ProtHex1[1] = ProtocolLo;
        }
        else
        {
            PCLASS_COMAPTIBLE_IDS   pClassIds;
            PWCHAR                  pwchTmp;
            ULONG                   i;

            pwchTmp = pwch;

            if (SubCompatibleID[0] != 0)
            {
                RtlCopyMemory(pwchTmp,
                              L"USB\\MS_COMP_",
                              sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR));

                (PUCHAR)pwchTmp += sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR);

                for (i = 0; i < 8 && CompatibleID[i] != 0; i++)
                {
                    *pwchTmp++ = (WCHAR)CompatibleID[i];
                }

                RtlCopyMemory(pwchTmp,
                              L"&MS_SUBCOMP_",
                              sizeof(L"&MS_SUBCOMP_")-sizeof(WCHAR));

                (PUCHAR)pwchTmp += sizeof(L"&MS_SUBCOMP_")-sizeof(WCHAR);

                for (i = 0; i < 8 && SubCompatibleID[i] != 0; i++)
                {
                    *pwchTmp++ = (WCHAR)SubCompatibleID[i];
                }

                *pwchTmp++ = '\0';
            }

            if (CompatibleID[0] != 0)
            {
                RtlCopyMemory(pwchTmp,
                              L"USB\\MS_COMP_",
                              sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR));

                (PUCHAR)pwchTmp += sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR);

                for (i = 0; i < 8 && CompatibleID[i] != 0; i++)
                {
                    *pwchTmp++ = (WCHAR)CompatibleID[i];
                }

                *pwchTmp++ = '\0';
            }

            pClassIds = (PCLASS_COMAPTIBLE_IDS)pwchTmp;

            // Copy over the constant set of strings:
            // L"USB\\Class_nn&SubClass_nn&Prot_nn\0"
            // L"USB\\Class_nn&SubClass_nn\0"
            // L"USB\\Class_nn\0"
            //
            RtlCopyMemory(pClassIds,
                          &ClassCompatibleIDs,
                          sizeof(CLASS_COMAPTIBLE_IDS));

            // Fill in the 'nn' blanks
            //
            pClassIds->ClassHex1[0] =
            pClassIds->ClassHex2[0] =
            pClassIds->ClassHex3[0] = ClassHi;

            pClassIds->ClassHex1[1] =
            pClassIds->ClassHex2[1] =
            pClassIds->ClassHex3[1] = ClassLo;

            pClassIds->SubClassHex1[0] =
            pClassIds->SubClassHex2[0] = SubClassHi;

            pClassIds->SubClassHex1[1] =
            pClassIds->SubClassHex2[1] = SubClassLo;

            pClassIds->ProtHex1[0] = ProtocolHi;

            pClassIds->ProtHex1[1] = ProtocolLo;
        }
    }

    return pwch;
}

#endif


PWCHAR
USB_MakeId(
    PWCHAR IdString,
    PWCHAR Buffer,
    PULONG Length,
    USHORT NullCount,
    USHORT Digits,
    USHORT HexId
    )
/*
    given a wide Id string like "FOOnnnn\0"
    add the HexId value to nnnn as hex
    this string is appended to the buffer passed in

    eg
    in  : FOOnnnn\0 , 0x123A
    out : FOO123A\0
*/
{
#define NIBBLE_TO_HEX( byte ) ((WCHAR)Nibble[byte])
    const UCHAR Nibble[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',
        'B', 'C', 'D', 'E', 'F'};

    PWCHAR tmp, id;
    PUCHAR p;
    SIZE_T siz, idLen;

    idLen = wcslen(IdString)*sizeof(WCHAR);
    siz = idLen+(USHORT)*Length+(NullCount*sizeof(WCHAR));
    tmp = ExAllocatePoolWithTag(PagedPool, siz, USBHUB_HEAP_TAG);
    if (tmp == NULL) {
        *Length = 0;
    } else {
        // this takes care of the nulls
        RtlZeroMemory(tmp, siz);
        RtlCopyMemory(tmp, Buffer, *Length);
        p = (PUCHAR) tmp;
        p += *Length;
        RtlCopyMemory(p, IdString, idLen);
        id = (PWCHAR) p;
        *Length = (ULONG)siz;

        // now convert the vaules
        while (*id != (WCHAR)'n' && Digits) {
            id++;
        }

        switch(Digits) {
        case 2:
            *(id) = NIBBLE_TO_HEX((HexId >> 4) & 0x000f);
            *(id+1) =  NIBBLE_TO_HEX(HexId & 0x000f);
            break;
        case 4:
            *(id) = NIBBLE_TO_HEX(HexId >> 12);
            *(id+1) = NIBBLE_TO_HEX((HexId >> 8) & 0x000f);
            *(id+2) = NIBBLE_TO_HEX((HexId >> 4) & 0x000f);
            *(id+3) =  NIBBLE_TO_HEX(HexId & 0x000f);
            break;
        }


    }

    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }

    return tmp;
}



PWCHAR
USBH_BuildHubDeviceID(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN LONG MiId
    )
 /* ++
  *
  * Descrioption:
  *
  * This function build bus Id wide string for the PDO based on the Vendor Id
  *
      USB\HUB_Vid_nnnn&Pid_nnnn\0
  *
  *
  * -- */
{
    PWCHAR id;
    ULONG length;

    id = NULL;
    length = 0;

    id = USB_MakeId(
                   L"USB\\HUB_VID_nnnn\0",
                   id,
                   &length,
                   0,
                   4,  // 4 digits
                   IdVendor);

    id = USB_MakeId(
                   L"&PID_nnnn\0",
                   id,
                   &length,
                   1,  // add a null
                   4,  // 4 digits
                   IdProduct);


    return(id);
}


PWCHAR
USBH_BuildHubHardwareIDs(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN USHORT BcdDevice,
    IN LONG MiId
    )
 /* ++
  *
  * Description:
  *
  * This function build HardwareIDs wide multi-string for the PDO based on the
  * Vendor Id, Product Id and Revision Id.
  *

    USB\HUB_Vid_nnnn&Pid_nnnn&Rev_nnnn\0
    USB\HUB_Vid_nnnn&Pid_nnnn\0
    \0


  * -- */
{
    PWCHAR id;
    ULONG length;

    id = NULL;
    length = 0;

    // USB\HUB_VID_nnnn&PID_nnnn&REV_nnnn\0

    id = USB_MakeId(
                   L"USB\\HUB_VID_nnnn\0",
                   id,
                   &length,
                   0,
                   4,  // 4 digits
                   IdVendor);

    id = USB_MakeId(
                   L"&PID_nnnn\0",
                   id,
                   &length,
                   0,
                   4,
                   IdProduct);

    id = USB_MakeId(
                   L"&REV_nnnn\0",
                   id,
                   &length,
                   1,  // add a null
                   4,
                   BcdDevice);

    // USB\HUB_VID_nnnn&PID_nnnn\0

    id = USB_MakeId(
                   L"USB\\HUB_VID_nnnn\0",
                   id,
                   &length,
                   0,
                   4,  // 4 digits
                   IdVendor);

    id = USB_MakeId(
                   L"&PID_nnnn\0",
                   id,
                   &length,
                   2,  // 2 nulls
                   4,
                   IdProduct);

    return(id);
}


PWCHAR
USBH_BuildHubCompatibleIDs(
    IN UCHAR Class,
    IN UCHAR SubClass,
    IN UCHAR Protocol,
    IN BOOLEAN DeviceClass,
    IN BOOLEAN DeviceIsHighSpeed
    )
 /* ++
  *
  * Descrioption:
  *
  * This function build compatible Ids wide multi-string for the PDO based on
  * the Class and Subclass Ids.
  *
  * This function builds the compatible ids specifically for s USB hub attached
  * to a USB 2.0 host controller

  // build the following set of ids

  L"USB\\HubClass&SubClass_nn&Prot_nn\0"
  L"USB\\HubClass&SubClass_nn\0"
  L"USB\\HubClass\0"
  L"\0"

  * -- */
{
    PWCHAR id;
    ULONG length;

    id = NULL;
    length = 0;

    // "USB\\HubClass&SubClass_nn&Prot_nn\0"

    id = USB_MakeId(
                   L"USB\\HubClass&SubClass_nn\0",
                   id,
                   &length,
                   0,
                   2,  // 2 digits
                   SubClass);

    id = USB_MakeId(
                   L"&Prot_nn\0",
                   id,
                   &length,
                   1,  // add null
                   2,  // 2 digits
                   Protocol);

    // "USB\\HubClass&SubClass_nn\0"

    id = USB_MakeId(
                   L"USB\\HubClass&SubClass_nn\0",
                   id,
                   &length,
                   1,
                   2,  // 2 digits
                   SubClass);

    // "USB\\HubClass\0\0"

    id = USB_MakeId(
                   L"USB\\HubClass\0",
                   id,
                   &length,
                   2,  // 2 nulls
                   0,
                   0);

    return(id);
}

//#endif //USB2_BP


PWCHAR
USBH_BuildInstanceID(
    IN PWCHAR UniqueIdString,
    IN ULONG Length
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * returns a pointer to a copy of our unicode unique id string
  * or NULL if error.
  *
  *
  * -- */
{
    PWCHAR uniqueIdString;

    PAGED_CODE();
    USBH_KdPrint((2,"'BuildInstanceID %x\n",
                    UniqueIdString));

    //
    // Must use ExAllocatePool directly here because the OS
    // will free the buffer
    //
    uniqueIdString = ExAllocatePoolWithTag(PagedPool,
                                           Length,
                                           USBHUB_HEAP_TAG);

    if (NULL != uniqueIdString) {
        RtlCopyMemory(uniqueIdString,
                      UniqueIdString,
                      Length);

    }

    return uniqueIdString;
}


NTSTATUS
USBH_ProcessDeviceInformation(
    IN OUT PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{

    NTSTATUS ntStatus;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    BOOLEAN multiConfig = FALSE;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter USBH_ProcessDeviceInformation\n"));

    USBH_ASSERT(EXTENSION_TYPE_PORT == DeviceExtensionPort->ExtensionType);

    RtlZeroMemory(&DeviceExtensionPort->InterfaceDescriptor,
                  sizeof(DeviceExtensionPort->InterfaceDescriptor));

    USBH_KdPrint((2,"'numConfigs = %d\n",
        DeviceExtensionPort->DeviceDescriptor.bNumConfigurations));
    USBH_KdPrint((2,"'vendor id = %x\n",
        DeviceExtensionPort->DeviceDescriptor.idVendor));
    USBH_KdPrint((2,"'product id = %x\n",
        DeviceExtensionPort->DeviceDescriptor.idProduct));
    USBH_KdPrint((2,"'revision id = %x\n",
        DeviceExtensionPort->DeviceDescriptor.bcdDevice));

    //
    // assume the device is not a hub
    //
    DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_DEVICE_IS_HUB;

    if (DeviceExtensionPort->DeviceDescriptor.bNumConfigurations > 1) {
        //
        // Multi config device, ignore muktiple interfaces
        // ie don't load the generic parent
        //
        // we get the wakeup caps from the first config
        //
        USBH_KdPrint((0,"Detected multiple configurations\n"));
        multiConfig = TRUE;
    }

    //
    // we need to get the whole configuration descriptor and parse it
    //

    ntStatus =
        USBH_GetConfigurationDescriptor(DeviceExtensionPort->PortPhysicalDeviceObject,
                                        &configurationDescriptor);


    if (NT_SUCCESS(ntStatus)) {

        // now parse out the config

        USBH_ASSERT(configurationDescriptor);

        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_REMOTE_WAKEUP_SUPPORTED;
        if (configurationDescriptor->bmAttributes &
                USB_CONFIG_REMOTE_WAKEUP) {
            DeviceExtensionPort->PortPdoFlags |=
                PORTPDO_REMOTE_WAKEUP_SUPPORTED;
        }

#ifndef MULTI_FUNCTION_SUPPORT
        //
        // In Detroit we only support one interface
        //
        configurationDescriptor->bNumInterfaces = 1;
#endif

        if ((configurationDescriptor->bNumInterfaces > 1) &&
            !multiConfig &&
            (DeviceExtensionPort->DeviceDescriptor.bDeviceClass == 0)) {

            //
            // device has multiple interfaces
            // for now we use the first one we find
            //

            // set up the interface descriptor for this
            // port to be the generic parent driver

            DeviceExtensionPort->PortPdoFlags |= PORTPDO_DEVICE_IS_PARENT;

            USBH_KdBreak(("USB device has Multiple Interfaces\n"));

        } else {

            //
            // not a composite device
            // call USBD to locate the interface descriptor
            //
            // there can be only one.

            interfaceDescriptor =
                USBD_ParseConfigurationDescriptorEx(
                    configurationDescriptor,
                    configurationDescriptor,
                    -1, //interface, don't care
                    -1, //alt setting, don't care
                    -1, // class don'care
                    -1, // subclass, don't care
                    -1); // protocol, don't care



            if (interfaceDescriptor) {
                DeviceExtensionPort->InterfaceDescriptor = *interfaceDescriptor;
                //
                // see if this is a hub
                //

                if (interfaceDescriptor->bInterfaceClass ==
                    USB_DEVICE_CLASS_HUB) {
                    DeviceExtensionPort->PortPdoFlags |= PORTPDO_DEVICE_IS_HUB;
                    // all hubs must support remote wakeup (ie at least propigate
                    // resume signalling

                    DeviceExtensionPort->PortPdoFlags |=
                        PORTPDO_REMOTE_WAKEUP_SUPPORTED;
                }

            } else {
                ntStatus = STATUS_UNSUCCESSFUL;
            }
        }
    }

    if (configurationDescriptor) {
        UsbhExFreePool(configurationDescriptor);
    }

    return ntStatus;
}


BOOLEAN
USBH_ValidateSerialNumberString(
    PWCHAR DeviceId
    )

/*++

Routine Description:

    This routine stolen from ntos\io\pnpenum.c, IopFixupDeviceId, and modified
    accordingly.

    Invalid characters are:
        c <= 0x20 (' ')
        c >  0x7F
        c == 0x2C (',')

Arguments:

    DeviceId - specifies a device instance string (or part of one), must be
               null-terminated.

Return Value:

    None.

--*/

{
    PWCHAR p;

    PAGED_CODE();

    for (p = DeviceId; *p; p++) {
        if ((*p < L' ')  || (*p > (WCHAR)0x7F) || (*p == L',')) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
USBH_CheckDeviceIDUnique(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT IDVendor,
    IN USHORT IDProduct,
    IN PWCHAR SerialNumberBuffer,
    IN USHORT SerialNumberBufferLength
    )
 /* ++
  *
  * Description:
  *
  * This function determines if the ID for a device on a hub is unique.
  *
  * Arguments:
  *
  * DeviceExtensionHub
  *
  * IDVendor
  * IDProduct
  * SerialNumberBuffer
  * SerialNumberBufferLength
  *
  * Return:
  *
  * BOOLEAN indicating whether device ID is unique or not.
  *
  * -- */
{
    PDEVICE_EXTENSION_PORT childDeviceExtensionPort;
    BOOLEAN bDeviceIDUnique = TRUE;
    ULONG i;

    PAGED_CODE();

    for (i = 0; i < DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

        if (DeviceExtensionHub->PortData[i].DeviceObject) {

            childDeviceExtensionPort = DeviceExtensionHub->PortData[i].DeviceObject->DeviceExtension;

            if (childDeviceExtensionPort->DeviceDescriptor.idVendor == IDVendor &&
                childDeviceExtensionPort->DeviceDescriptor.idProduct == IDProduct &&
                childDeviceExtensionPort->SerialNumberBufferLength == SerialNumberBufferLength &&
                childDeviceExtensionPort->SerialNumberBuffer != NULL &&
                RtlCompareMemory(childDeviceExtensionPort->SerialNumberBuffer,
                                 SerialNumberBuffer,
                                 SerialNumberBufferLength) == SerialNumberBufferLength) {

                bDeviceIDUnique = FALSE;
                break;
            }
        }
    }

    return bDeviceIDUnique;
}


NTSTATUS
USBH_CreateDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN USHORT PortStatus,
    IN ULONG RetryIteration
    )
 /* ++
  *
  * Description:
  *
  * This is called when there is a new deviced connected, and enabled(via
  * reset). We will call USBD_CreateDevice and USBD_InitializDevice so that
  * it get an address and Device Descriptor. A PDO s also created for this
  * connected device and to record some relevant information such as
  * pDeviceData, puchPath and DeviceDescriptor.
  *
  * Arguments:
  *
  * pDeviceExtensionHub - the hub FDO extension that has a new connected port
  * ulPortNumber - the port that has a device connected. IsLowSpeed - to
  * indicate if the attached device is a low speed one
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PDEVICE_OBJECT deviceObjectPort = NULL;     // Initialize to NULL in case
                                                // USBD_MakePdoName fails.
    PDEVICE_EXTENSION_PORT deviceExtensionPort = NULL;
    BOOLEAN fNeedResetBeforeSetAddress = TRUE;
    UNICODE_STRING uniqueIdUnicodeString;
    ULONG nameIndex = 0;
    UNICODE_STRING pdoNameUnicodeString;
    BOOLEAN bDiagnosticMode = FALSE;
    BOOLEAN bIgnoreHWSerialNumber = FALSE;
    PWCHAR sernumbuf = NULL;
    BOOLEAN isLowSpeed, isHighSpeed;
    PVOID deviceData;

    PAGED_CODE();
    USBH_KdPrint((2,"'CreateDevice for port %x\n", PortNumber));

    isLowSpeed = (PortStatus & PORT_STATUS_LOW_SPEED) ? TRUE : FALSE;
    isHighSpeed = (PortStatus & PORT_STATUS_HIGH_SPEED) ? TRUE : FALSE;


    //
    // First create a PDO for the connected device
    //

    do {
#ifdef USB2
        ntStatus = USBD_MakePdoNameEx(DeviceExtensionHub,
                                     &pdoNameUnicodeString,
                                     nameIndex);
#else
        ntStatus = USBD_MakePdoName(&pdoNameUnicodeString,
                                     nameIndex);
#endif

        if (NT_SUCCESS(ntStatus)) {
            ntStatus = IoCreateDevice(UsbhDriverObject,    // Driver Object
                                      sizeof(DEVICE_EXTENSION_PORT),    // Device Extension size
                                      //NULL, // Device name
                                      &pdoNameUnicodeString,
                                      FILE_DEVICE_UNKNOWN,  // Device Type
                                                            // should look device
                                                            // class
                                      0,// Device Chars
                                      FALSE,    // Exclusive
                                      &deviceObjectPort);  // Bus Device Object
            if (!NT_SUCCESS(ntStatus)) {
                RtlFreeUnicodeString(&pdoNameUnicodeString);
            }
        }
        nameIndex++;

    } while (ntStatus == STATUS_OBJECT_NAME_COLLISION);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdPrint((2,"'IoCreateDevice for port %x fail\n", PortNumber));
        USBH_ASSERT(deviceObjectPort == NULL);
        goto USBH_CreateDevice_Done;
    }

    // use the stack size from the top of the HCD stack
    deviceObjectPort->StackSize = DeviceExtensionHub->TopOfHcdStackDeviceObject->StackSize;
    USBH_KdPrint((2,"'CreatePdo StackSize=%d\n", deviceObjectPort->StackSize));

    //
    // Init port extension fields
    //
    deviceExtensionPort = (PDEVICE_EXTENSION_PORT) deviceObjectPort->DeviceExtension;
    RtlZeroMemory(deviceExtensionPort, sizeof(DEVICE_EXTENSION_PORT));

    //
    // Init port extension fields
    //

    // don't need the name anymore
    RtlFreeUnicodeString(&pdoNameUnicodeString);

    deviceExtensionPort->ExtensionType = EXTENSION_TYPE_PORT;
    deviceExtensionPort->PortPhysicalDeviceObject = deviceObjectPort;
    deviceExtensionPort->HubExtSave =         
        deviceExtensionPort->DeviceExtensionHub = DeviceExtensionHub;
    deviceExtensionPort->PortNumber = PortNumber;
    deviceExtensionPort->DeviceState = PowerDeviceD0;
    if (isLowSpeed) {
        deviceExtensionPort->PortPdoFlags = PORTPDO_LOW_SPEED_DEVICE;
        USBH_ASSERT(isHighSpeed == FALSE);
    } else if (isHighSpeed) {
        deviceExtensionPort->PortPdoFlags = PORTPDO_HIGH_SPEED_DEVICE;
        USBH_ASSERT(isLowSpeed == FALSE);
    }

    KeInitializeSpinLock(&deviceExtensionPort->PortSpinLock);

    //
    // Build a unicode unique id
    //

    USBH_ASSERT(PortNumber < 1000 && PortNumber > 0);


    RtlInitUnicodeString(&uniqueIdUnicodeString,
                         &deviceExtensionPort->UniqueIdString[0]);

    uniqueIdUnicodeString.MaximumLength =
        sizeof(deviceExtensionPort->UniqueIdString);

    ntStatus = RtlIntegerToUnicodeString((ULONG) PortNumber,
                                         10,
                                         &uniqueIdUnicodeString);

    deviceObjectPort->Flags |= DO_POWER_PAGABLE;
    deviceObjectPort->Flags &= ~DO_DEVICE_INITIALIZING;

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("AddDevice for port %x fail %x -- failed to create unique id\n", PortNumber, ntStatus));
        goto USBH_CreateDevice_Done;
    }

    //
    // call usbd to create device for this connection
    //
#ifdef USB2
    ntStatus = USBD_CreateDeviceEx(DeviceExtensionHub,
                                   &deviceExtensionPort->DeviceData,
                                   DeviceExtensionHub->RootHubPdo,
                                   0, // optional default endpoint0 max packet
                                      // size
                                   &deviceExtensionPort->DeviceHackFlags,
                                   PortStatus,
                                   PortNumber);
#else
    ntStatus = USBD_CreateDevice(&deviceExtensionPort->DeviceData,
                                  DeviceExtensionHub->RootHubPdo,
                                  isLowSpeed,
                                  0, // optional default endpoint0 max packet
                                     // size
                                  &deviceExtensionPort->DeviceHackFlags);
                                                    // flag to indicate if
                                                    // we need a second
                                                    // reset
#endif

    if (!NT_SUCCESS(ntStatus)) {
        ENUMLOG(&DeviceExtensionHub->UsbdiBusIf, 
            USBDTAG_HUB, 'cdf!', ntStatus, 0);
        USBH_KdBreak(("AddDevice for port %x fail %x\n", PortNumber, ntStatus));
        goto USBH_CreateDevice_Done;
    }
    //
    // some early versions of USB firmware could not handle the premature
    // termination of a control command.
    //
    if (fNeedResetBeforeSetAddress) {
        USBH_KdPrint((2,"'NeedResetBeforeSetAddress\n"));
        ntStatus = USBH_SyncResetPort(DeviceExtensionHub, PortNumber);
        if (!NT_SUCCESS(ntStatus)) {
           USBH_KdBreak(("Failure on second reset %x fail %x\n", PortNumber, ntStatus));
           goto USBH_CreateDevice_Done;
        }

        // For some reason, the amount of time between the GetDescriptor request
        // and the SetAddress request decreased when we switched from the older
        // monolithic UHCD.SYS to the new USBUHCI.SYS miniport.  And apparently,
        // there have been found at least two devices that were dependent on
        // the longer delay.  According to GlenS who looked at one of these
        // devices on the CATC, delta time was ~80ms with UHCD.SYS and ~35ms
        // with USBUHCI.SYS.  So, Glen found that by inserting a 50ms delay
        // here, it allows at least one of these devices to now enumerate
        // properly.  For performance reasons, we have decided to only insert
        // this delay if a previous enumeration retry has failed, so as not
        // to impact the enumeration time of all devices.

        if (RetryIteration) {
            UsbhWait(50);
        }
    }

#ifdef USB2
    ntStatus = USBD_InitializeDeviceEx(DeviceExtensionHub,
                                     deviceExtensionPort->DeviceData,
                                     DeviceExtensionHub->RootHubPdo,
                                     &deviceExtensionPort->DeviceDescriptor,
                                     sizeof(USB_DEVICE_DESCRIPTOR),
                                     &deviceExtensionPort->ConfigDescriptor,
                                     sizeof(USB_CONFIGURATION_DESCRIPTOR)
                                     );
#else
    ntStatus = USBD_InitializeDevice(deviceExtensionPort->DeviceData,
                                     DeviceExtensionHub->RootHubPdo,
                                     &deviceExtensionPort->DeviceDescriptor,
                                     sizeof(USB_DEVICE_DESCRIPTOR),
                                     &deviceExtensionPort->ConfigDescriptor,
                                     sizeof(USB_CONFIGURATION_DESCRIPTOR)
                                     );
#endif

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdPrint((2,"'InitDevice for port %x fail %x\n", PortNumber, ntStatus));
        // InitializeDevice frees the DeviceData structure on failure
        deviceExtensionPort->DeviceData = NULL;
        goto USBH_CreateDevice_Done;
    }

    // See if we are supposed to ignore the hardware serial number for
    // this device.

    status = USBH_RegQueryDeviceIgnoreHWSerNumFlag(
                    deviceExtensionPort->DeviceDescriptor.idVendor,
                    deviceExtensionPort->DeviceDescriptor.idProduct,
                    &bIgnoreHWSerialNumber);

    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
        // Flag was not there, don't ignore hardware serial number.
        bIgnoreHWSerialNumber = FALSE;
    }

    if (bIgnoreHWSerialNumber) {

        USBH_KdPrint((1,"'Ignoring HW serial number for device Vid_%04x/Pid_%04x\n",
            deviceExtensionPort->DeviceDescriptor.idVendor,
            deviceExtensionPort->DeviceDescriptor.idProduct));

        // Use the same flag that USBD gives us.  According to JD, though,
        // USBD uses this flag globally (e.g. set for all devices).

        deviceExtensionPort->DeviceHackFlags |= USBD_DEVHACK_DISABLE_SN;
    }

// if we can get the core spec changed to stipulate that this serial number
// to the device then we can use it instead of the port number.

    //
    // see if we have a serial number
    //
    if (deviceExtensionPort->DeviceDescriptor.iSerialNumber &&
        !(deviceExtensionPort->DeviceHackFlags & USBD_DEVHACK_DISABLE_SN)) {
#if DBG
        NTSTATUS localStatus;
#endif
        //
        // Wow, we have a device with a serial number
        // we will attempt to get the string and use it for a
        // unique id
        //
        USBH_KdPrint((1, "'Device is reporting a serial number string\n"));

        //
        // lets get that serial number
        //

        InterlockedExchangePointer(&deviceExtensionPort->SerialNumberBuffer,
                                   NULL);

#if DBG
        localStatus =
#endif
        // For now we always look for the serial number in English.

        USBH_GetSerialNumberString(deviceExtensionPort->PortPhysicalDeviceObject,
                                   &sernumbuf,
                                   &deviceExtensionPort->SerialNumberBufferLength,
                                   0x0409, // good'ol american english
                                   deviceExtensionPort->DeviceDescriptor.iSerialNumber);

        if (sernumbuf == NULL) {
            USBH_ASSERT(localStatus != STATUS_SUCCESS);
            UsbhWarning(deviceExtensionPort,
                        "Device reported a serial number string but failed the request for it\n",
                        FALSE);
        } else if (!USBH_ValidateSerialNumberString(sernumbuf)) {

            // Sigh.  The "Visioneer Strobe Pro USB" returns a bogus serial #
            // string so we need to check for that here.  If we return this
            // bogus string to PnP we blue screen.

            UsbhWarning(deviceExtensionPort,
                        "Device reported an invalid serial number string!\n",
                        FALSE);

            UsbhExFreePool(sernumbuf);
            sernumbuf = NULL;
        }

        // Check for like devices with duplicate serial numbers connected
        // to the same hub.

        if (sernumbuf &&
            !USBH_CheckDeviceIDUnique(
                DeviceExtensionHub,
                deviceExtensionPort->DeviceDescriptor.idVendor,
                deviceExtensionPort->DeviceDescriptor.idProduct,
                sernumbuf,
                deviceExtensionPort->SerialNumberBufferLength)) {

            UsbhWarning(deviceExtensionPort,
                        "Like devices with identical serial numbers connected to same hub!\n",
                        TRUE);

            UsbhExFreePool(sernumbuf);
            sernumbuf = NULL;
        }

        InterlockedExchangePointer(&deviceExtensionPort->SerialNumberBuffer,
                                   sernumbuf);
    }

    //
    // Skip serial number generation if we are in diagnostic mode.
    // (e.g. The Vid and Pid are each 0xFFFF.)
    //
    bDiagnosticMode =
        (deviceExtensionPort->DeviceDescriptor.idVendor == 0xFFFF &&
         deviceExtensionPort->DeviceDescriptor.idProduct == 0xFFFF) ? TRUE : FALSE;

    // **
    //
    // Query the device
    // 1. check for multiple interfaces (ie composite device)
    // 2. check for multiple configs (ie need configuring parent)
    // 3. check single interface device -- ie just load driver
    //

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBH_ProcessDeviceInformation(deviceExtensionPort);
        // compute our capabilities we will retiurn to PnP
        USBH_PdoSetCapabilities(deviceExtensionPort);
    }


//#ifdef MAX_DEBUG
//    ntStatus = STATUS_DEVICE_DATA_ERROR;
//#endif
    //
    // Note: Device will be removed when REMOVE MESSAGE is sent to the PDO
    //
    //ntStatus = STATUS_DEVICE_DATA_ERROR;
#if DBG
    if (!NT_SUCCESS(ntStatus)) {
        // error occurred querying the device config descriptor
        USBH_KdBreak(("Get Config Descriptors Failed %x\n", ntStatus));
    }
#endif

USBH_CreateDevice_Done:

#if DBG
    if (UsbhPnpTest & PNP_TEST_FAIL_ENUM) {
        ntStatus = STATUS_UNSUCCESSFUL;
    }
#endif

#ifdef TEST_2X_UI
    if (deviceExtensionPort->DeviceDescriptor.idVendor == 0x045E) {
        // Set the 2.x device flag for MS devices when testing the UI.
        deviceExtensionPort->PortPdoFlags |= PORTPDO_HIGH_SPEED_DEVICE;
    }
#endif

    if (!NT_SUCCESS(ntStatus) && deviceExtensionPort) {
#ifdef MAX_DEBUG
        TEST_TRAP();
#endif
        deviceExtensionPort->PortPdoFlags |= PORTPDO_DEVICE_ENUM_ERROR;

        // remove the deviceData structure now

        deviceData = InterlockedExchangePointer(
                        &deviceExtensionPort->DeviceData,
                        NULL);

        if (deviceData) {
#ifdef USB2
            USBD_RemoveDeviceEx(DeviceExtensionHub,
                                deviceData,
                                DeviceExtensionHub->RootHubPdo,
                                0);
#else
            USBD_RemoveDevice(deviceData,
                              DeviceExtensionHub->RootHubPdo,
                              0);
#endif
        }

        sernumbuf = InterlockedExchangePointer(
                        &deviceExtensionPort->SerialNumberBuffer, NULL);

        if (sernumbuf) {
            UsbhExFreePool(sernumbuf);
        }
    }

    //
    // Note that we keep the PDO until the
    // device is physically disconnected
    // from the bus.
    //

    // According to NT pnp spec this pdo should remain

    USBH_ASSERT(DeviceExtensionHub->PortData[PortNumber - 1].DeviceObject == NULL);
    DeviceExtensionHub->PortData[PortNumber - 1].DeviceObject = deviceObjectPort;

    USBH_KdPrint((2,"'Exit CreateDevice PDO=%x\n", deviceObjectPort));

    return ntStatus;
}


PWCHAR
GetString(PWCHAR pwc, BOOLEAN MultiSZ)
{
    PWCHAR  psz, p;
    ULONG   Size;

    psz=pwc;
    while (*psz!='\0' || (MultiSZ && *(psz+1)!='\0')) {
        psz++;
    }

    Size=(ULONG)((psz-pwc+1+(MultiSZ ? 1: 0))*sizeof(*pwc));

    // We use pool here because these pointers are passed
    // to the PnP code who is responsible for freeing them
    if ((p=ExAllocatePoolWithTag(PagedPool, Size, USBHUB_HEAP_TAG))!=NULL) {
        RtlCopyMemory(p, pwc, Size);
    }

    return(p);
}


NTSTATUS
USBH_PdoQueryId(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IRP_MJ_PNP, IRP_MN_QUERY_ID.
  *
  * Arguments:
  *
  * DeviceExtensionPort - should be the PDO we created for the port device Irp
  * - the Irp
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    PIO_STACK_LOCATION ioStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    USBH_KdPrint((2,"'IRP_MN_QUERY_ID Pdo extension=%x\n", DeviceExtensionPort));

    //
    // It should be physical device object.
    //

    USBH_ASSERT(EXTENSION_TYPE_PORT == DeviceExtensionPort->ExtensionType);

#ifndef USBHUB20
    // Do the MS OS Descriptor stuff the first time around
    //
    if (!(DeviceExtensionPort->PortPdoFlags & PORTPDO_OS_STRING_DESC_REQUESTED))
    {
        PMS_EXT_CONFIG_DESC msExtConfigDesc;

        msExtConfigDesc = NULL;

        // Try to get the MS OS Descriptor Vendor Code from the device.  Do
        // this before any MS OS Descriptor requests.
        //
        USBH_GetMsOsVendorCode(DeviceExtensionPort->PortPhysicalDeviceObject);

        // Don't do the MS OS Descriptor stuff the next time around
        //
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_OS_STRING_DESC_REQUESTED;

        // Try to get an Extended Configuration Descriptor from the device.
        // 
        msExtConfigDesc = USBH_GetExtConfigDesc(DeviceExtensionPort->PortPhysicalDeviceObject);

        // If we got an Extended Configuration Descriptor from the device, make
        // sure it is valid.
        // 
        if (msExtConfigDesc &&
            USBH_ValidateExtConfigDesc(msExtConfigDesc,
                                       &DeviceExtensionPort->ConfigDescriptor)) {

            // If the Extended Configuration Descriptor contains a single
            // function which spans the all of the interfaces of the device,
            // then do not treat the device as a composite device and use the
            // Compatible and SubCompatible IDs optionally contained in the
            // descriptor.
            //
            if (msExtConfigDesc->Header.bCount == 1 &&
                msExtConfigDesc->Function[0].bFirstInterfaceNumber == 0 &&
                msExtConfigDesc->Function[0].bInterfaceCount ==
                DeviceExtensionPort->ConfigDescriptor.bNumInterfaces)
            {
                RtlCopyMemory(DeviceExtensionPort->CompatibleID,
                              msExtConfigDesc->Function[0].CompatibleID,
                              sizeof(DeviceExtensionPort->CompatibleID));

                RtlCopyMemory(DeviceExtensionPort->SubCompatibleID,
                              msExtConfigDesc->Function[0].SubCompatibleID,
                              sizeof(DeviceExtensionPort->SubCompatibleID));

                DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_DEVICE_IS_PARENT;                
            }
        }

        if (msExtConfigDesc)
        {
            UsbhExFreePool(msExtConfigDesc);
        }
    }
#endif

    switch (ioStack->Parameters.QueryId.IdType) {
    case BusQueryDeviceID:
        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_ENUM_ERROR) {
            Irp->IoStatus.Information=
                (ULONG_PTR)
                USBH_BuildDeviceID(0,
                                   0,
                                   -1,
                                   FALSE);
        } else {
            Irp->IoStatus.Information =
                (ULONG_PTR)
                USBH_BuildDeviceID(DeviceExtensionPort->DeviceDescriptor.idVendor,
                                   DeviceExtensionPort->DeviceDescriptor.idProduct,
                                   -1,
                                   DeviceExtensionPort->DeviceDescriptor.bDeviceClass
                                       == USB_DEVICE_CLASS_HUB ? TRUE : FALSE);
        }

        break;

    case BusQueryHardwareIDs:

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_ENUM_ERROR) {
            Irp->IoStatus.Information=(ULONG_PTR)GetString(L"USB\\UNKNOWN\0", TRUE);
        } else {
            Irp->IoStatus.Information =
                (ULONG_PTR)
                USBH_BuildHardwareIDs(DeviceExtensionPort->DeviceDescriptor.idVendor,
                                      DeviceExtensionPort->DeviceDescriptor.idProduct,
                                      DeviceExtensionPort->DeviceDescriptor.bcdDevice,
                                      -1,
                                      DeviceExtensionPort->DeviceDescriptor.bDeviceClass
                                       == USB_DEVICE_CLASS_HUB ? TRUE : FALSE);
        }

        break;

    case BusQueryCompatibleIDs:

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_ENUM_ERROR) {
            Irp->IoStatus.Information=(ULONG_PTR)GetString(L"USB\\UNKNOWN\0", TRUE);
        } else if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_PARENT) {
            //Irp->IoStatus.Information=(ULONG)GetString(L"USB\\COMPOSITE\0", TRUE);
            Irp->IoStatus.Information =
                (ULONG_PTR) USBH_BuildCompatibleIDs(
                    DeviceExtensionPort->CompatibleID,
                    DeviceExtensionPort->SubCompatibleID,
                    DeviceExtensionPort->InterfaceDescriptor.bInterfaceClass,
                    DeviceExtensionPort->InterfaceDescriptor.bInterfaceSubClass,
                    DeviceExtensionPort->InterfaceDescriptor.bInterfaceProtocol,
                    TRUE,
                    DeviceExtensionPort->PortPdoFlags & PORTPDO_HIGH_SPEED_DEVICE ?
                        TRUE : FALSE);
        } else {
            Irp->IoStatus.Information =
                (ULONG_PTR) USBH_BuildCompatibleIDs(
                    DeviceExtensionPort->CompatibleID,
                    DeviceExtensionPort->SubCompatibleID,
                    DeviceExtensionPort->InterfaceDescriptor.bInterfaceClass,
                    DeviceExtensionPort->InterfaceDescriptor.bInterfaceSubClass,
                    DeviceExtensionPort->InterfaceDescriptor.bInterfaceProtocol,
                    FALSE,
                    DeviceExtensionPort->PortPdoFlags & PORTPDO_HIGH_SPEED_DEVICE ?
                        TRUE : FALSE);
        }

        break;

    case BusQueryInstanceID:

        if (DeviceExtensionPort->SerialNumberBuffer) {
            PWCHAR tmp;
            ULONG length;
            //
            // allocate a buffer and copy the string to it
            //
            // NOTE: must use stock alloc function because
            // PnP frees this string.

            length = DeviceExtensionPort->SerialNumberBufferLength;
            tmp = ExAllocatePoolWithTag(PagedPool, length, USBHUB_HEAP_TAG);
            if (tmp) {
                RtlCopyMemory(tmp,
                              DeviceExtensionPort->SerialNumberBuffer,
                              length);
            }

            Irp->IoStatus.Information = (ULONG_PTR) tmp;

#if DBG
            {
            PUCHAR pch, sn;
            PWCHAR pwch;
            pch = sn = ExAllocatePoolWithTag(PagedPool, 500, USBHUB_HEAP_TAG);

            if (sn) {
                pwch = (PWCHAR) tmp;
                while(*pwch) {
                    *pch = (UCHAR) *pwch;
                    pch++;
                    pwch++;
                    if (pch-sn > 499) {
                        break;
                    }
                }
                *pch='\0';
                USBH_KdPrint((1, "'using device supplied serial number\n"));
                USBH_KdPrint((1, "'SN = :%s:\n", sn));

                ExFreePool(sn);
            }
            }
#endif

        } else {
            Irp->IoStatus.Information =
                (ULONG_PTR) USBH_BuildInstanceID(&DeviceExtensionPort->UniqueIdString[0],
                                             sizeof(DeviceExtensionPort->UniqueIdString));
        }
        break;

    default:
        USBH_KdBreak(("PdoBusExtension Unknown BusQueryId\n"));
        // IrpAssert: Must not change Irp->IoStatus.Status for bogus IdTypes,
        // so return original status here.
        return Irp->IoStatus.Status;
    }

    if (Irp->IoStatus.Information == 0) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
USBH_PdoStopDevice(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL irql;
    PIRP idleIrp = NULL;
    PIRP waitWakeIrp = NULL;
    PVOID deviceData;

    USBH_KdPrint((1,
        "'Stopping PDO %x\n",
        DeviceExtensionPort->PortPhysicalDeviceObject));

    LOGENTRY(LOG_PNP, "Spdo", DeviceExtensionPort,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                DeviceExtensionPort->PortPdoFlags);

    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionPort->IdleNotificationIrp) {
        idleIrp = DeviceExtensionPort->IdleNotificationIrp;
        DeviceExtensionPort->IdleNotificationIrp = NULL;
        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;

        if (idleIrp->Cancel) {
            idleIrp = NULL;
        }

        if (idleIrp) {
            IoSetCancelRoutine(idleIrp, NULL);
        }

        LOGENTRY(LOG_PNP, "IdSX", 0, DeviceExtensionPort, idleIrp);
        USBH_KdPrint((1,"'PDO %x stopping, failing idle notification request IRP %x\n",
                        DeviceExtensionPort->PortPhysicalDeviceObject, idleIrp));
    }

    if (DeviceExtensionPort->WaitWakeIrp) {

        waitWakeIrp = DeviceExtensionPort->WaitWakeIrp;
        DeviceExtensionPort->WaitWakeIrp = NULL;
        DeviceExtensionPort->PortPdoFlags &=
            ~PORTPDO_REMOTE_WAKEUP_ENABLED;

        if (waitWakeIrp->Cancel || IoSetCancelRoutine(waitWakeIrp, NULL) == NULL) {
            waitWakeIrp = NULL;

            // Must decrement pending request count here because
            // we don't complete the IRP below and USBH_WaitWakeCancel
            // won't either because we have cleared the IRP pointer
            // in the device extension above.

            USBH_DEC_PENDING_IO_COUNT(DeviceExtensionPort->DeviceExtensionHub);
        }

        USBH_KdPrint((1,
        "'Completing Wake Irp for PDO %x with STATUS_CANCELLED\n",
            DeviceExtensionPort->PortPhysicalDeviceObject));

        LOGENTRY(LOG_PNP, "kilW", DeviceExtensionPort,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                DeviceExtensionPort->PortPdoFlags);

        // JOES: Should we decrement portwakeirps for the hub and cancel
        // hub's WW IRP if zero?
    }

    //
    // Finally, release the cancel spin lock
    //
    IoReleaseCancelSpinLock(irql);

    if (idleIrp) {
        idleIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
    }

    if (waitWakeIrp) {

        USBH_ASSERT(DeviceExtensionPort->DeviceExtensionHub);

        USBH_CompletePowerIrp(DeviceExtensionPort->DeviceExtensionHub,
                              waitWakeIrp,
                              STATUS_CANCELLED);
    }

    DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_STARTED;
    //
    // indicate that we will need a reset if we start up again.
    //
    DeviceExtensionPort->PortPdoFlags |= PORTPDO_NEED_RESET;
    RtlCopyMemory(&DeviceExtensionPort->OldDeviceDescriptor,
                  &DeviceExtensionPort->DeviceDescriptor,
                  sizeof(DeviceExtensionPort->DeviceDescriptor));
    //
    // remove the device data now to free
    // up the bus resources
    //

    deviceData = InterlockedExchangePointer(
                    &DeviceExtensionPort->DeviceData,
                    NULL);

    if (deviceData) {
#ifdef USB2
       ntStatus = USBD_RemoveDeviceEx(DeviceExtensionPort->DeviceExtensionHub,
                                    deviceData,
                                    DeviceExtensionPort->DeviceExtensionHub->RootHubPdo,
                                    0);
#else
       ntStatus = USBD_RemoveDevice(deviceData,
                                    DeviceExtensionPort->DeviceExtensionHub->RootHubPdo,
                                    0);
#endif

       USBH_SyncDisablePort(DeviceExtensionPort->DeviceExtensionHub,
                            DeviceExtensionPort->PortNumber);
    }

    if (DeviceExtensionPort->PortPdoFlags & PORTPDO_SYM_LINK) {
        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_SYM_LINK;
        ntStatus = USBH_SymbolicLink(FALSE,
                                     DeviceExtensionPort,
                                     NULL);
#if DBG
        if (!NT_SUCCESS(ntStatus)) {
            USBH_KdBreak(("StopDevice  USBH_SymbolicLink failed = %x\n",
                           ntStatus));
        }
#endif
    }

    return ntStatus;
}

NTSTATUS
USBH_PdoStartDevice(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    LPGUID lpGuid;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;

    USBH_KdPrint((1,
        "'Starting PDO %x VID %x PID %x\n", deviceObject,
            DeviceExtensionPort->DeviceDescriptor.idVendor,
            DeviceExtensionPort->DeviceDescriptor.idProduct));

    LOGENTRY(LOG_PNP, "Tpdo", DeviceExtensionPort,
            DeviceExtensionPort->PortPhysicalDeviceObject,
            0);

    if (DeviceExtensionPort->DeviceExtensionHub == NULL && 
        DeviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET) {
        // if DeviceExtensionHub is NULL then this is a 
        // restart after remove we need to reset the 
        // backpointer to the owning hub in this case 
        DeviceExtensionPort->DeviceExtensionHub = 
            DeviceExtensionPort->HubExtSave;    
        
    }
    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    if (deviceExtensionHub) {
        ENUMLOG(&deviceExtensionHub->UsbdiBusIf, 
                    USBDTAG_HUB, 'pdoS', 
                    (ULONG_PTR) DeviceExtensionPort->PortPhysicalDeviceObject, 
                    DeviceExtensionPort->PortNumber);  

        USBHUB_SetDeviceHandleData(deviceExtensionHub,
                                   DeviceExtensionPort->PortPhysicalDeviceObject,
                                   DeviceExtensionPort->DeviceData);                        
    }                        
#if DBG
    if (USBH_Debug_Flags & USBH_DEBUGFLAG_BREAK_PDO_START) {
        TEST_TRAP();
    }
#endif
    //
    // create a symbolic link
    //
    ntStatus = STATUS_SUCCESS;

    if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) {
        lpGuid = (LPGUID)&GUID_CLASS_USBHUB;
    } else {
        lpGuid = (LPGUID)&GUID_CLASS_USB_DEVICE;
    }

    ntStatus = USBH_SymbolicLink(TRUE,
                                 DeviceExtensionPort,
                                 lpGuid);
    if (NT_SUCCESS(ntStatus)) {
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_SYM_LINK;
    }
#if DBG
      else {
        USBH_KdBreak(("StartDevice  USBH_SymbolicLink failed = %x\n",
                       ntStatus));
    }
#endif

    if (DeviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET) {
        ntStatus = USBH_RestoreDevice(DeviceExtensionPort, FALSE);
        //
        // note: we will fail the start if we could not
        // restore the device.
        //
    }

    DeviceExtensionPort->DeviceState = PowerDeviceD0;
    DeviceExtensionPort->PortPdoFlags |= PORTPDO_STARTED;

#ifdef WMI_SUPPORT
    if (NT_SUCCESS(ntStatus) &&
        !(DeviceExtensionPort->PortPdoFlags & PORTPDO_WMI_REGISTERED)) {

        PWMILIB_CONTEXT wmiLibInfo;

        wmiLibInfo = &DeviceExtensionPort->WmiLibInfo;

        wmiLibInfo->GuidCount = sizeof (USB_PortWmiGuidList) /
                                 sizeof (WMIGUIDREGINFO);
        ASSERT(NUM_PORT_WMI_SUPPORTED_GUIDS == wmiLibInfo->GuidCount);

        wmiLibInfo->GuidList = USB_PortWmiGuidList;
        wmiLibInfo->QueryWmiRegInfo = USBH_PortQueryWmiRegInfo;
        wmiLibInfo->QueryWmiDataBlock = USBH_PortQueryWmiDataBlock;
        wmiLibInfo->SetWmiDataBlock = NULL;
        wmiLibInfo->SetWmiDataItem = NULL;
        wmiLibInfo->ExecuteWmiMethod = NULL;
        wmiLibInfo->WmiFunctionControl = NULL;

        IoWMIRegistrationControl(DeviceExtensionPort->PortPhysicalDeviceObject,
                                 WMIREG_ACTION_REGISTER
                                 );

        DeviceExtensionPort->PortPdoFlags |= PORTPDO_WMI_REGISTERED;
    }
#endif
    return ntStatus;
    
}


NTSTATUS
USBH_PdoRemoveDevice(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PWCHAR sernumbuf;
    KIRQL irql;
    PIRP idleIrp = NULL;
    PIRP waitWakeIrp = NULL;
    PVOID deviceData;

    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;

    USBH_KdPrint((1,
        "'Removing PDO %x\n",
        DeviceExtensionPort->PortPhysicalDeviceObject));

    LOGENTRY(LOG_PNP, "Rpdo", DeviceExtensionPort,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                DeviceExtensionPort->PortPdoFlags);

    // **
    // no references to hub after first remove is processed
    // if we have access to the parent at the time of 
    // remove this is passed to us as a parameter
    DeviceExtensionPort->DeviceExtensionHub = NULL;

    if (DeviceExtensionHub) {
        ENUMLOG(&DeviceExtensionHub->UsbdiBusIf, 
                        USBDTAG_HUB, 'pdoR', 
                        (ULONG_PTR) DeviceExtensionPort->PortPhysicalDeviceObject, 
                        DeviceExtensionPort->PortNumber);       
                    
    }                        

    // **
    // if we have access to the hub and it is not in D0 then we will 
    // power it.
    //
    // In the case where a device was removed with handles still open,
    // we will receive the remove request at a later time.  Be sure that
    // the hub is not selectively suspended in this case.

    if (DeviceExtensionHub &&
        DeviceExtensionHub->CurrentPowerState != PowerDeviceD0 &&
        (DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

        USBH_HubSetD0(DeviceExtensionHub);
    }

// ***
    // **
    // cancel any notifocation irp that may be pending
    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionPort->IdleNotificationIrp) {
        idleIrp = DeviceExtensionPort->IdleNotificationIrp;
        DeviceExtensionPort->IdleNotificationIrp = NULL;
        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;

        if (idleIrp->Cancel) {
            idleIrp = NULL;
        }

        if (idleIrp) {
            IoSetCancelRoutine(idleIrp, NULL);
        }

        LOGENTRY(LOG_PNP, "IdRX", 0, DeviceExtensionPort, idleIrp);
        USBH_KdPrint((1,"'PDO %x being removed, failing idle notification request IRP %x\n",
                        DeviceExtensionPort->PortPhysicalDeviceObject, idleIrp));
    }

    // ** 
    // Kill any wake irps for this PDO now
    if (DeviceExtensionPort->WaitWakeIrp) {

        waitWakeIrp = DeviceExtensionPort->WaitWakeIrp;
        DeviceExtensionPort->WaitWakeIrp = NULL;
        DeviceExtensionPort->PortPdoFlags &=
            ~PORTPDO_REMOTE_WAKEUP_ENABLED;

                
        if (waitWakeIrp->Cancel || IoSetCancelRoutine(waitWakeIrp, NULL) == NULL) {
            waitWakeIrp = NULL;

            USBH_ASSERT(DeviceExtensionHub);
            // Must decrement pending request count here because
            // we don't complete the IRP below and USBH_WaitWakeCancel
            // won't either because we have cleared the IRP pointer
            // in the device extension above.

            USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);
        }

        USBH_KdPrint((1,
        "'Completing Wake Irp for PDO %x with STATUS_CANCELLED\n",
            DeviceExtensionPort->PortPhysicalDeviceObject));

        LOGENTRY(LOG_PNP, "kilR", DeviceExtensionPort,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                DeviceExtensionPort->PortPdoFlags);

        // JOES: Should we decrement portwakeirps for the hub and cancel
        // hub's WW IRP if zero?
    }

    //
    // Finally, release the cancel spin lock
    //
    IoReleaseCancelSpinLock(irql);
//***

    if (idleIrp) {
        idleIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
    }

    if (waitWakeIrp) {

        USBH_ASSERT(DeviceExtensionHub);

        USBH_CompletePowerIrp(DeviceExtensionHub,
                              waitWakeIrp,
                              STATUS_CANCELLED);
    }

    // 
    // This PDO will need reset if this is a soft-remove from
    // device manager. In this case the PDO will not actually 
    // be deleted.
    // 
    DeviceExtensionPort->PortPdoFlags |= PORTPDO_NEED_RESET;

    if (DeviceExtensionPort->PortPdoFlags & PORTPDO_SYM_LINK) {
        ntStatus = USBH_SymbolicLink(FALSE,
                                     DeviceExtensionPort,
                                     NULL);
        if (NT_SUCCESS(ntStatus)) {
            DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_SYM_LINK;
        }
#if DBG
          else {
            USBH_KdBreak(("RemoveDevice  USBH_SymbolicLink failed = %x\n",
                           ntStatus));
        }
#endif
    }

    deviceData = InterlockedExchangePointer(
                    &DeviceExtensionPort->DeviceData,
                    NULL);

    LOGENTRY(LOG_PNP, "RMdd", DeviceExtensionPort,
                deviceData, DeviceExtensionHub);

    if (deviceData) {

        //
        // DeviceData should have been deleted when the hub was removed
        //

        USBH_ASSERT(DeviceExtensionHub != NULL);
#ifdef USB2
        ntStatus = USBD_RemoveDeviceEx(DeviceExtensionHub,
                                     deviceData,
                                     DeviceExtensionHub->RootHubPdo,
                                     0);
#else
        ntStatus = USBD_RemoveDevice(deviceData,
                                     DeviceExtensionHub->RootHubPdo,
                                     0);
#endif

        // note the special case:
        // if our port data structure still points to this PDO then
        // we need to disable the port (the device is still listening on
        // the address we just freed.
        // otherwise we just leave the port alone -- the device has been
        // replaced with another one.

        if (DeviceExtensionHub->PortData != NULL &&
            (DeviceExtensionHub->PortData[
                DeviceExtensionPort->PortNumber - 1].DeviceObject == deviceObject)) {

            USBH_SyncDisablePort(DeviceExtensionHub,
                                 DeviceExtensionPort->PortNumber);
        }
    }


    // Failure cases:
    //      USBD_RemoveDevice
    //      USBH_SymbolicLink
    // Do we really want to leak a devobj here?
    LOGENTRY(LOG_PNP, "RRR", deviceObject, 0, ntStatus);

    if (NT_SUCCESS(ntStatus)) {

        PPORT_DATA portData = NULL;
        //
        // update our record in the Hub extension
        //

        LOGENTRY(LOG_PNP, "rpdo", deviceObject, 0, 0);

        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_STARTED;

        if (DeviceExtensionHub &&
            DeviceExtensionHub->PortData != NULL) {

            portData =
                &DeviceExtensionHub->PortData[DeviceExtensionPort->PortNumber - 1];
        

            // port data should be valid for this port
            USBH_ASSERT(portData);

            // legacy 'ESD' flag 
            // if this flag is set the hub will loose its reference to this
            // device ie it will be reported gone in the next QBR
            if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DELETE_PENDING) {
                PDEVICE_OBJECT pdo;
                
                pdo = portData->DeviceObject;

                LOGENTRY(LOG_PNP, "pd1", pdo, 0, 0);
                
                // if no Pdo then we will fall thru and delete
                if (pdo) {
                
                    portData->DeviceObject = NULL;
                    portData->ConnectionStatus = NoDeviceConnected;
    
                    // we should only get here if we get a remove for a device 
                    // that is physically gone but we havn't told PnP about it 
                    // yet.
                    // in this case we don't want to del the devobj,hence, the 
                    // assert

                    // not sure how we would really get here 
                    TEST_TRAP(); // could we leak a dev handle here?
                
                    // device should be present if we do this
                    USBH_ASSERT(PDO_EXT(pdo)->PnPFlags & PDO_PNPFLAG_DEVICE_PRESENT);
                
                    InsertTailList(&DeviceExtensionHub->DeletePdoList, 
                                    &PDO_EXT(pdo)->DeletePdoLink);
                }                                    
            }

        }


        // When is a remove really a remove?
        // We must determine if deleting the PDO is the approprite 
        // 
        // if PnP thinks the device is gone then we can delete it
        if (!(DeviceExtensionPort->PnPFlags & PDO_PNPFLAG_DEVICE_PRESENT)) {
        
            LOGENTRY(LOG_PNP, "Dpdo",
                deviceObject, portData, 0);

            // we should only delete one time, this flag indicates the 
            // 'deleted' state so that we can process other irps approriatly
            USBH_ASSERT(!(DeviceExtensionPort->PortPdoFlags & PORTPDO_DELETED_PDO));
                                
            DeviceExtensionPort->PortPdoFlags |= PORTPDO_DELETED_PDO;

            // perform one time delete operations
            
            //
            // Free the device serial number string.  Only do this if we
            // are deleting the device.
            //

            sernumbuf = InterlockedExchangePointer(
                            &DeviceExtensionPort->SerialNumberBuffer,
                            NULL);

                if (sernumbuf) {
                    UsbhExFreePool(sernumbuf);
                }


#ifdef WMI_SUPPORT
            if (DeviceExtensionPort->PortPdoFlags & PORTPDO_WMI_REGISTERED) {
                // de-register with WMI
                IoWMIRegistrationControl(deviceObject,
                                         WMIREG_ACTION_DEREGISTER);

                DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_WMI_REGISTERED;
            }
#endif


            // this is the last step of a successful removal, any transfers 
            // that may be pening will be flushed out by this routine. After 
            // this point the driver may unload.
            
            if (DeviceExtensionHub) {
                USBHUB_FlushAllTransfers(DeviceExtensionHub);    
            }                

            USBH_KdPrint((1,
                "'Deleting PDO %x\n",
                 deviceObject));

            LOGENTRY(LOG_PNP, "Xpdo",
                deviceObject, 0, 0);

            IoDeleteDevice(deviceObject);
        }
    }

    if (DeviceExtensionHub) {
        USBH_CheckHubIdle(DeviceExtensionHub);
    }

    return ntStatus;
}

VOID
USBH_PdoSetCapabilities(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /* ++
  *
  * Description:
  *
  *  Init the internal capabilities structure for the PDO that we 
  *  will return on a query capabilities IRP.
  * Argument:
  *
  * Return:
  *
  *   none
  *
  * -- */
{
    PDEVICE_CAPABILITIES deviceCapabilities;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    SYSTEM_POWER_STATE i;

    PAGED_CODE();

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    USBH_ASSERT(deviceExtensionHub);

    USBH_KdPrint((2,"'PdoQueryCapabilities \n"));

    //
    // Get the packet.
    //
    deviceCapabilities = &DeviceExtensionPort->DevCaps;

    //
    // Set the capabilities.
    //

    deviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    deviceCapabilities->Version = 1;

    deviceCapabilities->Address = DeviceExtensionPort->PortNumber;
    deviceCapabilities->Removable = TRUE;
    if (DeviceExtensionPort->SerialNumberBuffer) {
        deviceCapabilities->UniqueID = TRUE;
    } else {
        deviceCapabilities->UniqueID = FALSE;
    }
    deviceCapabilities->RawDeviceOK = FALSE;

    //
    // fill in the the device state capabilities from the
    // table we saved from the pdo.
    //

    RtlCopyMemory(&deviceCapabilities->DeviceState[0],
                  &deviceExtensionHub->DeviceState[0],
                  sizeof(deviceExtensionHub->DeviceState));

    deviceCapabilities->SystemWake = deviceExtensionHub->SystemWake;
    deviceCapabilities->DeviceWake = deviceExtensionHub->DeviceWake;

    deviceCapabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;

    //
    // deepest device state we can wake up the system with,
    // set to PowerDeviceD0 if wakeup not supported
    // by the device
    //
    if (DeviceExtensionPort->PortPdoFlags & PORTPDO_REMOTE_WAKEUP_SUPPORTED) {
        deviceCapabilities->DeviceWake = PowerDeviceD2;
        deviceCapabilities->WakeFromD2 = TRUE;
        deviceCapabilities->WakeFromD1 = TRUE;
        deviceCapabilities->WakeFromD0 = TRUE;
        deviceCapabilities->DeviceD2 = TRUE;
        deviceCapabilities->DeviceD1 = TRUE;

        for (i=PowerSystemSleeping1; i<=PowerSystemHibernate; i++) {
            if (i > deviceCapabilities->SystemWake) {
                deviceCapabilities->DeviceState[i] = PowerDeviceD3;
            } else {
                deviceCapabilities->DeviceState[i] = PowerDeviceD2;
            }
        }

    } else {
        deviceCapabilities->DeviceWake = PowerDeviceD0;

        for (i=PowerSystemSleeping1; i<=PowerSystemHibernate; i++) {
            deviceCapabilities->DeviceState[i] = PowerDeviceD3;
        }
    }

    return;
}


NTSTATUS
USBH_PdoQueryCapabilities(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES).
  * Supposedly, this is a message forwarded by port device Fdo.
  *
  * Argument:
  *
  * DeviceExtensionPort - This is a a Pdo extension we created for the port
  * device. Irp - the request
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_CAPABILITIES deviceCapabilities;
    PIO_STACK_LOCATION ioStack;
    SYSTEM_POWER_STATE i;
    USHORT sizeSave, versionSave;
    
    PAGED_CODE();
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    USBH_KdPrint((2,"'PdoQueryCapabilities Pdo %x\n", deviceObject));

    //
    // Get the packet.
    //
    deviceCapabilities = ioStack->
        Parameters.DeviceCapabilities.Capabilities;

    // size and length are passed in 
    // we should not modify these, all 
    // others we set as appropriate for 
    // USB (see DDK)

    // save values pased in
    sizeSave = deviceCapabilities->Size;
    versionSave = deviceCapabilities->Version;
    
    //
    // Set the capabilities.
    //
    RtlCopyMemory(deviceCapabilities, 
                  &DeviceExtensionPort->DevCaps,
                  sizeof(*deviceCapabilities));  

    // restore saved values
    deviceCapabilities->Size = sizeSave;
    deviceCapabilities->Version = versionSave;

   
#if DBG
    if (deviceCapabilities->SurpriseRemovalOK) {
        UsbhWarning(DeviceExtensionPort,
                    "QUERY_CAPS called with SurpriseRemovalOK = TRUE\n",
                    FALSE);
    }
#endif

#if DBG
    {
        ULONG i;
        USBH_KdPrint((1, "'HUB PDO: Device Caps\n"));
        USBH_KdPrint(
            (1, "'UniqueId = %d Removable = %d SurpriseOK = %d RawDeviceOK = %x\n",
            deviceCapabilities->UniqueID,
            deviceCapabilities->Removable,
            deviceCapabilities->SurpriseRemovalOK,
            deviceCapabilities->RawDeviceOK));

        USBH_KdPrint((1, "'Device State Map:\n"));

        for (i=0; i< PowerSystemHibernate; i++) {
            USBH_KdPrint((1, "'-->S%d = D%d\n", i-1,
                 deviceCapabilities->DeviceState[i]-1));
        }
    }
#endif

    return (STATUS_SUCCESS);
}


NTSTATUS
USBH_PdoPnP(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp,
    IN UCHAR MinorFunction,
    IN PBOOLEAN CompleteIrp
    )
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl PnPPower for the PDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO extension Irp - the request packet
  * uchMinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    LPGUID lpGuid;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;

    PAGED_CODE();

    // this flag will cause the request to be complete,
    // if we wish to pass it on the we set the flag to FALSE.
    *CompleteIrp = TRUE;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    USBH_KdPrint((2,"'PnP Power Pdo %x minor %x\n", deviceObject, MinorFunction));

    switch (MinorFunction) {
    case IRP_MN_START_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_START_DEVICE Pdo %x", deviceObject));
        ntStatus = USBH_PdoStartDevice(DeviceExtensionPort, Irp);
#if 0        
        USBH_PdoStartDevice
        
        USBH_KdPrint((1,
            "'Starting PDO %x VID %x PID %x\n", deviceObject,
                DeviceExtensionPort->DeviceDescriptor.idVendor,
                DeviceExtensionPort->DeviceDescriptor.idProduct));

        LOGENTRY(LOG_PNP, "Tpdo", DeviceExtensionPort,
                DeviceExtensionPort->PortPhysicalDeviceObject,
                0);

        if (DeviceExtensionPort->DeviceExtensionHub == NULL && 
            DeviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET) {
            // if DeviceExtensionHub is NULL then this is a 
            // restart after remove we need to reset the 
            // backpointer to the owning hub in this case 
            DeviceExtensionPort->DeviceExtensionHub = 
                DeviceExtensionPort->HubExtSave;    
            
        }
        deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
        if (deviceExtensionHub) {
            ENUMLOG(&deviceExtensionHub->UsbdiBusIf, 
                        USBDTAG_HUB, 'pdoS', 
                        (ULONG_PTR) DeviceExtensionPort->PortPhysicalDeviceObject, 
                        DeviceExtensionPort->PortNumber);                
        }                        
#if DBG
        if (USBH_Debug_Flags & USBH_DEBUGFLAG_BREAK_PDO_START) {
            TEST_TRAP();
        }
#endif
        //
        // create a symbolic link
        //
        ntStatus = STATUS_SUCCESS;

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) {
            lpGuid = (LPGUID)&GUID_CLASS_USBHUB;
        } else {
            lpGuid = (LPGUID)&GUID_CLASS_USB_DEVICE;
        }

        ntStatus = USBH_SymbolicLink(TRUE,
                                     DeviceExtensionPort,
                                     lpGuid);
        if (NT_SUCCESS(ntStatus)) {
            DeviceExtensionPort->PortPdoFlags |= PORTPDO_SYM_LINK;
        }
#if DBG
          else {
            USBH_KdBreak(("StartDevice  USBH_SymbolicLink failed = %x\n",
                           ntStatus));
        }
#endif

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET) {
            ntStatus = USBH_RestoreDevice(DeviceExtensionPort, FALSE);
            //
            // note: we will fail the start if we could not
            // restore the device.
            //
        }

        DeviceExtensionPort->DeviceState = PowerDeviceD0;
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_STARTED;

#ifdef WMI_SUPPORT
        if (NT_SUCCESS(ntStatus) &&
            !(DeviceExtensionPort->PortPdoFlags & PORTPDO_WMI_REGISTERED)) {

            PWMILIB_CONTEXT wmiLibInfo;

            wmiLibInfo = &DeviceExtensionPort->WmiLibInfo;

            wmiLibInfo->GuidCount = sizeof (USB_PortWmiGuidList) /
                                     sizeof (WMIGUIDREGINFO);
            ASSERT(NUM_PORT_WMI_SUPPORTED_GUIDS == wmiLibInfo->GuidCount);

            wmiLibInfo->GuidList = USB_PortWmiGuidList;
            wmiLibInfo->QueryWmiRegInfo = USBH_PortQueryWmiRegInfo;
            wmiLibInfo->QueryWmiDataBlock = USBH_PortQueryWmiDataBlock;
            wmiLibInfo->SetWmiDataBlock = NULL;
            wmiLibInfo->SetWmiDataItem = NULL;
            wmiLibInfo->ExecuteWmiMethod = NULL;
            wmiLibInfo->WmiFunctionControl = NULL;

            IoWMIRegistrationControl(DeviceExtensionPort->PortPhysicalDeviceObject,
                                     WMIREG_ACTION_REGISTER
                                     );

            DeviceExtensionPort->PortPdoFlags |= PORTPDO_WMI_REGISTERED;
        }
#endif
#endif
        break;

    case IRP_MN_STOP_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_STOP_DEVICE Pdo %x", deviceObject));
        ntStatus = USBH_PdoStopDevice(DeviceExtensionPort, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_REMOVE_DEVICE Pdo %x", deviceObject));
        // pass the backref to the hub, if this is the fisrt remove 
        // then it will be valid. If it is a second remove the hub
        // is potentially gone
        ntStatus = USBH_PdoRemoveDevice(DeviceExtensionPort, 
                                        DeviceExtensionPort->DeviceExtensionHub,
                                        Irp);
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_QUERY_STOP_DEVICE Pdo %x\n", deviceObject));
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_CANCEL_STOP_DEVICE Pdo %x\n", deviceObject));
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_QUERY_REMOVE_DEVICE Pdo %x\n", deviceObject));
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_CANCEL_REMOVE_DEVICE Pdo %x\n", deviceObject));
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        USBH_KdPrint((1,"'IRP_MN_SURPRISE_REMOVAL Pdo %x\n", deviceObject));
        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_SYM_LINK) {
            ntStatus = USBH_SymbolicLink(FALSE,
                                         DeviceExtensionPort,
                                         NULL);
            if (NT_SUCCESS(ntStatus)) {
                DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_SYM_LINK;
            }
#if DBG
            else {
                USBH_KdBreak(("SurpriseRemove: USBH_SymbolicLink failed = %x\n",
                               ntStatus));
            }
#endif
        }

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        USBH_KdPrint((1,"'IRP_MN_QUERY_PNP_DEVICE_STATE Pdo %x\n", deviceObject));
        if (DeviceExtensionPort->PortPdoFlags &
            (PORTPDO_DEVICE_ENUM_ERROR |
             PORTPDO_DEVICE_FAILED |
             PORTPDO_NOT_ENOUGH_POWER |
             PORTPDO_OVERCURRENT)) {
            Irp->IoStatus.Information
                |= PNP_DEVICE_FAILED;
        }

        LOGENTRY(LOG_PNP, "pnpS", DeviceExtensionPort,
                 DeviceExtensionPort->PortPhysicalDeviceObject,
                 Irp->IoStatus.Information);

        USBH_KdPrint((1,"'IRP_MN_QUERY_PNP_DEVICE_STATE Pdo %x -- state: %x\n",
            deviceObject,
            Irp->IoStatus.Information));

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_CAPABILITIES:
        USBH_KdPrint((2,"'IRP_MN_QUERY_CAPABILITIES Pdo %x\n", deviceObject));
        ntStatus = USBH_PdoQueryCapabilities(DeviceExtensionPort, Irp);
        break;

    case IRP_MN_QUERY_DEVICE_TEXT:
        USBH_KdPrint((2,"'IRP_MN_QUERY_DEVICE_TEXT Pdo %x\n", deviceObject));
        ntStatus = USBH_PdoQueryDeviceText(DeviceExtensionPort, Irp);
        break;

    case IRP_MN_QUERY_ID:
        USBH_KdPrint((2,"'IRP_MN_QUERY_ID Pdo %x\n", deviceObject));
        ntStatus = USBH_PdoQueryId(DeviceExtensionPort, Irp);
        break;

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        // Adrian says that once PnP sends this IRP, the PDO is valid for
        // PnP functions like IoGetDeviceProperty, etc.
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_VALID_FOR_PNP_FUNCTION;
#ifndef USBHUB20
        // And since we know that the PDO is valid and the DevNode now exists,
        // this would also be a good time to handle the MS ExtPropDesc.
        //
        USBH_InstallExtPropDesc(deviceObject);
#endif
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_INTERFACE:
        // forward the Q_INTERFACE to the root hub PDO
        {
        PIO_STACK_LOCATION irpStack;

        *CompleteIrp = FALSE;
        // set the Interface specific data to the device handle

        irpStack = IoGetCurrentIrpStackLocation(Irp);

        if (RtlCompareMemory(irpStack->Parameters.QueryInterface.InterfaceType,
               &USB_BUS_INTERFACE_USBDI_GUID,
               sizeof(GUID)) == sizeof(GUID)) {
            irpStack->Parameters.QueryInterface.InterfaceSpecificData =
                DeviceExtensionPort->DeviceData;
        }

        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionPort->DeviceExtensionHub->RootHubPdo);
        }
        break;

    case  IRP_MN_QUERY_BUS_INFORMATION:
        {
        // return the standard USB GUID
        PPNP_BUS_INFORMATION busInfo;

        USBH_KdPrint((1,"'IRP_MN_QUERY_BUS_INFORMATION Pdo %x\n", deviceObject));

        busInfo = ExAllocatePoolWithTag(PagedPool, sizeof(PNP_BUS_INFORMATION), USBHUB_HEAP_TAG);

        if (busInfo == NULL) {
           ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            busInfo->BusTypeGuid = GUID_BUS_TYPE_USB;
            busInfo->LegacyBusType = PNPBus;
            busInfo->BusNumber = 0;
            Irp->IoStatus.Information = (ULONG_PTR) busInfo;
            ntStatus = STATUS_SUCCESS;
        }
        }

        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        // this is a leaf node, we return the status passed
        // to us unless it is a call to TargetRelations
        USBH_KdPrint((2,"'IRP_MN_QUERY_DEVICE_RELATIONS Pdo %x type = %d\n",
            deviceObject,irpStack->Parameters.QueryDeviceRelations.Type));

        if (irpStack->Parameters.QueryDeviceRelations.Type ==
            TargetDeviceRelation) {

            PDEVICE_RELATIONS deviceRelations = NULL;

            deviceRelations = ExAllocatePoolWithTag(PagedPool,
                sizeof(*deviceRelations), USBHUB_HEAP_TAG);

            if (deviceRelations == NULL) {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                ObReferenceObject(DeviceExtensionPort->PortPhysicalDeviceObject);
                deviceRelations->Count = 1;
                deviceRelations->Objects[0] =
                    DeviceExtensionPort->PortPhysicalDeviceObject;
                ntStatus = STATUS_SUCCESS;
            }

            Irp->IoStatus.Information=(ULONG_PTR) deviceRelations;

            USBH_KdPrint((1, "'Query Relations, TargetDeviceRelation (PDO) %x complete\n",
                DeviceExtensionPort->PortPhysicalDeviceObject));

        } else {
            ntStatus = Irp->IoStatus.Status;
        }
        break;

    default:
        USBH_KdBreak(("PdoPnP unknown (%d) PnP message Pdo %x\n",
                      MinorFunction, deviceObject));
        //
        // return the original status passed to us
        //
        ntStatus = Irp->IoStatus.Status;
    }

    USBH_KdPrint((2,"'PdoPnP exit %x\n", ntStatus));

    return ntStatus;
}


VOID
USBH_ResetPortWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to process a port reset.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_RESET_WORK_ITEM workItemReset;

    workItemReset = Context;
    USBH_PdoIoctlResetPort(workItemReset->DeviceExtensionPort,
                           workItemReset->Irp);

    workItemReset->DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_DEVICE_FAILED;

    UsbhExFreePool(workItemReset);
}


BOOLEAN
USBH_DoesHubNeedWaitWake(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * This function determines if a hub needs a WW IRP posted (i.e. children
  * have WW IRP's posted).
  *
  * Arguments:
  *
  * DeviceExtensionHub
  *
  * Return:
  *
  * BOOLEAN indicating whether the hub needs a WW IRP posted or not.
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_PORT childDeviceExtensionPort;
    KIRQL irql;
    BOOLEAN bHubNeedsWaitWake;
    ULONG i;

    // Ensure that child port configuration does not change while in this
    // function, i.e. don't allow QBR.

    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    IoAcquireCancelSpinLock(&irql);

    bHubNeedsWaitWake = FALSE;  // Assume that the hub does not need a WW IRP.

    for (i = 0; i < DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

        if (DeviceExtensionHub->PortData[i].DeviceObject) {

            childDeviceExtensionPort = DeviceExtensionHub->PortData[i].DeviceObject->DeviceExtension;

            if (childDeviceExtensionPort->PortPdoFlags &
                PORTPDO_REMOTE_WAKEUP_ENABLED) {

                bHubNeedsWaitWake = TRUE;
                break;
            }
        }
    }

    IoReleaseCancelSpinLock(irql);

    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    return bHubNeedsWaitWake;
}


VOID
USBH_CheckHubIdle(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * This function determines if a hub is ready to be idled out, and does so
  * if ready.
  *
  * Arguments:
  *
  * DeviceExtensionHub
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_HUB rootHubDevExt;
    PDEVICE_EXTENSION_PORT childDeviceExtensionPort;
    KIRQL irql;
    BOOLEAN bAllIdle, submitIdle = FALSE;
    ULONG i;

    LOGENTRY(LOG_PNP, "hCkI", DeviceExtensionHub, DeviceExtensionHub->HubFlags,
        DeviceExtensionHub->CurrentPowerState);
    USBH_KdPrint((1,"'Hub Check Idle %x\n", DeviceExtensionHub));

    KeAcquireSpinLock(&DeviceExtensionHub->CheckIdleSpinLock, &irql);

    if (DeviceExtensionHub->HubFlags & HUBFLAG_IN_IDLE_CHECK) {
        KeReleaseSpinLock(&DeviceExtensionHub->CheckIdleSpinLock, irql);
        return;
    }

    D