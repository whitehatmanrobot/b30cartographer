MPVERSION, IDC_COMPTITLE, IDE_COMPDESC
};
#define NCUSTTEXTFIELDS sizeof(s_aCustTextFieldID)/sizeof(WORD)

static WORD s_aCustFieldID[] =
{
    IDE_COMPFILENAME, IDE_COMPPARAM, /* IDE_COMPSIZE,*/ IDE_COMPGUID,
    IDE_COMPCOMMAND, IDE_UNINSTALLKEY, IDE_COMPVERSION, IDC_COMPTITLE,
    IDC_VERIFY, IDC_REMOVECOMP, IDC_BROWSEFILE, IDE_COMPDESC, IDC_PREINSTALL, IDC_POSTINSTALL,
    IDC_REBOOTINSTALL, IDC_INSTALLSUCCESS
};

void updateCifVersions32(PCOMPONENT pComp, BOOL fIgnore, BOOL fUpdate = FALSE);
#define NCUSTFIELDS sizeof(s_aCustFieldID)/sizeof(WORD)

void UpdateInf(LPTSTR szMasterInf, LPTSTR szUserInf);

static BOOL s_fNoCore;
TCHAR g_szTempSign[MAX_PATH] = TEXT("");
static TCHAR s_szSiteData[MAX_URL];
extern BOOL g_fBatch;
extern BOOL g_fBatch2;
BOOL g_fInteg = FALSE;
extern void CheckBatchAdvance(HWND hDlg);
extern void DoBatchAdvance(HWND hDlg);
extern DWORD GetRootFree(LPCTSTR pcszPath);
extern BOOL g_fSilent, g_fStealth;

extern void UpdateIEAK(HWND hDlg);

// trust key defines, this are bit fields to determine which one to add/delete

struct TrustKey
{
    TCHAR szCompanyName[MAX_PATH];
    TCHAR szTrustString[MAX_PATH];
    BOOL fSet;
};

static TrustKey s_tkTrustArray[] =
{{TEXT("Microsoft Corporation"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap jpjmcfmhckkdfknkfemjikfiodeelkbd"), TRUE},
{TEXT("Microsoft Corporation"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap immbkmbpjfdkajbkncahcedfmndgehba"), TRUE},
{TEXT("Microsoft Corporation (Europe)"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap doamnolbnlpmdlpnkcnpckgfimpaaicl"), TRUE},
{TEXT("Microsoft Corporation"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap hbgflemajngobcablgnalaidgojggghj"), TRUE},
{TEXT("Microsoft Corporation"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap debgjcefniaahdamnhbggedppfiianff"), TRUE},   // new MS cert effective from 4/16/99
{TEXT("Microsoft Corporation (Europe)"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap kefdggbdmbmgbogjdcnmkoodcknmmghc"), TRUE},  // new MS Europe cert effective from 4/16/99
{TEXT("VDOnet Corporation"), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap moambfklemnlbmhfoomjdignnbkjfkek"), TRUE},
{TEXT("Progressive Networks, Inc."), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap cdikdekkiddcimdmcgedabijgpeobdhd"), TRUE},
{TEXT("Macromedia, Inc."), TEXT("bhhphijojgfcdocagmhjgjbhmieinfap akhlecfpbbjjngidddpgifggcplpcego"), TRUE}
};

extern BOOL g_fSrcDirChanged;
extern HINSTANCE hBrand;
extern BOOL g_fCD, g_fLAN, g_fDownload, g_fBrandingOnly;

BOOL g_fLocalMode = FALSE;

DWORD BuildCDandMflop(LPVOID);

HANDLE g_hProcessInfEvent = 0;
HANDLE g_hCifEvent = 0;

extern BOOL g_fOCW;

// core section component names for base

#define BASEWIN32 TEXT("BASEIE40_WIN")


// returns the component structure for base IE4 component, if for some
// weird reason its not there just return the first component structure
// in the list

PCOMPONENT FindComp(LPCTSTR szID, BOOL fCore)
{
    PCOMPONENT pComp;
    UINT       i;

    for (pComp = g_paComp, i=0; ((i < g_uiNumCabs) && (*pComp->szSection)); pComp++)
    {
        if (fCore)
        {
            // Note: we are depending on the section name of core IE4 here

            if (StrCmpI(pComp->szSection, BASEWIN32) == 0)
                return pComp;
        }
        else
        {
            if (StrCmpI(pComp->szSection, szID) == 0)
                return pComp;
        }
    }

    if (fCore)
        return g_paComp;
    else
        return NULL;
}

PCOMPONENT FindVisibleComponentName(LPCTSTR pcszCompName)
{
    PCOMPONENT pComp;
    for (pComp = g_paComp; *pComp->szSection; pComp++ )
    {
        if ((StrCmpI(pComp->szDisplayName, pcszCompName) == 0) && pComp->fVisible && 
            !pComp->fAddOnOnly)
            return(pComp);
    }
    return(NULL);

}

PCOMPONENT FindCustComp(LPCTSTR szID)
{
    PCOMPONENT pComp;

    for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
    {
        if (StrCmpI(pComp->szSection, szID) == 0)
            return pComp;
    }

    return NULL;
}

PCOMPONENT FindCustComponentName(LPTSTR szCompName)
{
    int i;
    PCOMPONENT pComp;
    for (i = 0, pComp = g_aCustComponents; i < g_nCustComp; i++, pComp++ )
    {
        if (StrCmp(pComp->szDisplayName, szCompName) == 0) return(pComp);
    }
    return(NULL);

}

PCOMPONENT FindCustComponentIndex(int iList)
{
    int i;
    PCOMPONENT pComp;
    for (i = 0, pComp = g_aCustComponents; i < g_nCustComp; i++, pComp++ )
    {
        if (pComp->iList == iList) return(pComp);
    }
    return(NULL);

}

int GetActiveSetupURL( LPTSTR pSection, LPTSTR szUrl, int /*iSize*/, LPTSTR szCif)
{
    TCHAR szUrlWrk[MAX_URL];

    GetPrivateProfileString( pSection, TEXT("URL1"), TEXT(""), szUrlWrk, MAX_URL, szCif );

    if (*szUrlWrk != TEXT('"')) StrCpy(szUrl, szUrlWrk);
    else
        StrCpy(szUrl, szUrlWrk + 1);
    StrTok(szUrl + 1, TEXT("\" ,"));
    return(lstrlen(szUrl));

}

void WriteActiveSetupURL(PCOMPONENT pComp, LPTSTR szCif)
{
    TCHAR szUrlWrk[MAX_URL] = TEXT("\"");
    StrCat(szUrlWrk, pComp->szUrl);
    StrCat(szUrlWrk, (pComp->iType != INST_CAB) ? TEXT("\",2") : TEXT("\",3"));
    WritePrivateProfileString(pComp->szSection, TEXT("URL1"), szUrlWrk, szCif);
}



//
//  FUNCTION: GetCustComponent(HWND, int)
//
//  PURPOSE:  Gets custom component data entered in the dialog boxes,
//              and saves it in memory
//
void GetCustComponent(HWND hDlg, int iList)
{
    PCOMPONENT pComp = FindCustComponentIndex(iList);
    if (pComp == NULL) return;
    GetDlgItemText( hDlg, IDE_COMPFILENAME, pComp->szPath, countof(pComp->szPath) );
    GetDlgItemText( hDlg, IDE_COMPCOMMAND, pComp->szCommand, countof(pComp->szCommand) );
    GetDlgItemText( hDlg, IDE_COMPPARAM, pComp->szSwitches, countof(pComp->szSwitches) );
    GetDlgItemText( hDlg, IDE_COMPGUID, pComp->szGUID, countof(pComp->szGUID) );
    GetDlgItemText( hDlg, IDE_UNINSTALLKEY, pComp->szUninstall, countof(pComp->szUninstall) );
    GetDlgItemText( hDlg, IDE_COMPVERSION, pComp->szVersion, countof(pComp->szVersion) );
    SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_GETLBTEXT, pComp->iList,(LPARAM) pComp->szDisplayName );
    GetDlgItemText( hDlg, IDE_COMPDESC, pComp->szDesc, countof(pComp->szDesc) );

    if (IsDlgButtonChecked(hDlg, IDC_POSTINSTALL) == BST_CHECKED)
        pComp->iInstallType = 0;
    else
    {
        if (IsDlgButtonChecked(hDlg, IDC_PREINSTALL) == BST_CHECKED)
            pComp->iInstallType = 1;
        else
            pComp->iInstallType = 2;
    }
    pComp->fIEDependency = (IsDlgButtonChecked(hDlg, IDC_INSTALLSUCCESS) == BST_CHECKED);
}

void CheckCompType(HWND hDlg, PCOMPONENT pComp )
{
    HANDLE hFile;
    DWORD dwSize = 0;
    LPTSTR pDot, pBack;
    if (!pComp) return;
    GetDlgItemText( hDlg, IDE_COMPFILENAME, pComp->szPath, countof(pComp->szPath) );

    pComp->dwSize = 0;
    if ((hFile = CreateFile(pComp->szPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
    {
        pComp->dwSize = ((dwSize = GetFileSize(hFile, NULL)) != 0xffffffff) ? (dwSize >> 10) : 0;
        CloseHandle(hFile);
    }
    //SetDlgItemInt( hDlg, IDE_COMPSIZE, dwSize, FALSE);

    pDot = StrRChr(pComp->szPath, NULL, TEXT('.'));
    pBack = StrRChr(pComp->szPath, NULL, TEXT('\\'));
    if ((pDot != NULL) && (StrCmpI(pDot, TEXT(".cab")) == 0))
    {
        EnableDlgItem(hDlg, IDE_COMPCOMMAND);
        pComp->iType = INST_CAB;
        if (pBack != NULL)
        {
            StrCpy(pComp->szUrl, pBack + 1);
        }
        return;
    }
    DisableDlgItem(hDlg, IDE_COMPCOMMAND);

    if ((pDot != NULL) && (StrCmpI(pDot, TEXT(".exe")) == 0))
    {
        pComp->iType = INST_EXE;
        if (pBack != NULL)
        {
            StrCpy(pComp->szCommand, pBack + 1);
            StrCpy(pComp->szUrl, pBack + 1);
            SetDlgItemText( hDlg, IDE_COMPCOMMAND, pComp->szCommand );
        }
    }
}

//
//  FUNCTION: SetCustComponent(HWND, int)
//
//  PURPOSE:  Gets custom component data from memory,
//              and displays it on the screen
//
void SetCustComponent(HWND hDlg, int iList)
{
    PCOMPONENT pComp = FindCustComponentIndex(iList);
    if (!pComp)
    {
        int i;
        SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_SETCURSEL, 0, 0L );
        for (i = 0; i < NCUSTFIELDS ; i++ )
        {
            EnsureDialogFocus(hDlg, s_aCustFieldID[i], IDC_ADDNEWCOMP);
            DisableDlgItem(hDlg, s_aCustFieldID[i]);
        }
        for (i = 0; i < NCUSTTEXTFIELDS ; i++ )
        {
            SetDlgItemText( hDlg, s_aCustTextFieldID[i] , TEXT("") );
        }
        
        for (i = 0; i < NCUSTSTATICTEXTFIELDS ; i++ )
            DisableDlgItem(hDlg, s_aCustStaticTextFieldID[i]);

        CheckDlgButton(hDlg, IDC_PREINSTALL, BST_UNCHECKED);
        return;
    }
    SetDlgItemText( hDlg, IDE_COMPFILENAME, pComp->szPath );
    CheckCompType(hDlg, pComp);
    SetDlgItemText( hDlg, IDE_COMPCOMMAND, pComp->szCommand );
    if (ISNULL(pComp->szGUID))
    {
        GUID guid;

        if (CoCreateGuid(&guid) == NOERROR)
            CoStringFromGUID(guid, pComp->szGUID, countof(pComp->szGUID));
        else
            wnsprintf(pComp->szGUID, countof(pComp->szGUID), TEXT("CUSTOM%i"),iList);
    }
    SetDlgItemText( hDlg, IDE_COMPGUID, pComp->szGUID );
    SetDlgItemText( hDlg, IDE_COMPPARAM, pComp->szSwitches );
    SetDlgItemText( hDlg, IDE_UNINSTALLKEY, pComp->szUninstall );
    SetDlgItemText( hDlg, IDE_COMPVERSION, pComp->szVersion);
    SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_SETCURSEL, pComp->iList, 0L );
    SetDlgItemText( hDlg, IDC_COMPTITLE, pComp->szDisplayName);
    SetDlgItemText(hDlg, IDE_COMPDESC, pComp->szDesc);
    CheckRadioButton(hDlg, IDC_POSTINSTALL, IDC_REBOOTINSTALL, IDC_POSTINSTALL + pComp->iInstallType);
    CheckDlgButton( hDlg, IDC_INSTALLSUCCESS, pComp->fIEDependency ? BST_CHECKED : BST_UNCHECKED);
    EnableDlgItem2(hDlg, IDC_INSTALLSUCCESS, (pComp->iInstallType != 1));

    if (g_nCustComp < MAXCUST)
        EnableDlgItem(hDlg, IDC_ADDNEWCOMP);
    else
    {
        EnsureDialogFocus(hDlg, IDC_ADDNEWCOMP, IDC_REMOVECOMP);
        DisableDlgItem(hDlg, IDC_ADDNEWCOMP);
    }
    SetFocus(GetDlgItem( hDlg, IDC_COMPTITLE ));
}


void InitCustComponents(HWND hDlg)
{
    TCHAR szSectBuf[2048];
    LPTSTR pSection = szSectBuf;
    HWND hCompList;
    PCOMPONENT pComp;
    TCHAR szCustCifName[32];

    if (hDlg) hCompList = GetDlgItem(hDlg, IDC_COMPTITLE);

    StrCpy(szCustCifName, TEXT("CUSTOM.CIF"));
    PathCombine(g_szCustCif, g_szBuildRoot, TEXT("INS"));
    PathAppend(g_szCustCif, GetOutputPlatformDir());
    PathAppend(g_szCustCif, g_szLanguage);
    PathAppend(g_szCustCif, szCustCifName);
    LoadString( g_rvInfo.hInst, IDS_NEWCUST, s_szNewTpl, countof(s_szNewTpl) );

    ZeroMemory(szSectBuf, sizeof(szSectBuf));
    GetPrivateProfileString( NULL, NULL, TEXT(""), szSectBuf, countof(szSectBuf), g_szCustCif );
    pComp = g_aCustComponents;

    g_nCustComp = 0;
    s_nNewCust = 1;
    while (*pSection)
    {
        int i;
        if (StrCmp(pSection, CUSTCMSECT) == 0)
        {
            pSection += lstrlen(pSection) + 1;
            continue;
        }
        StrCpy(pComp->szSection, pSection);
        GetPrivateProfileString( pSection, TEXT("Switches1"), TEXT(""), pComp->szSwitches, countof(pComp->szSwitches), g_szCustCif );
        GetPrivateProfileString( pSection, TEXT("DisplayName"), TEXT(""), pComp->szDisplayName, countof(pComp->szDisplayName), g_szCustCif );
        GetPrivateProfileString( pSection, TEXT("GUID"), TEXT(""), pComp->szGUID, countof(pComp->szGUID), g_szCustCif );
        GetPrivateProfileString( pSection, TEXT("UninstallKey"), TEXT(""), pComp->szUninstall, countof(pComp->szUninstall), g_szCustCif );
        GetActiveSetupURL( pSection, pComp->szUrl, countof(pComp->szUrl), g_szCustCif );
        GetPrivateProfileString( pSection, TEXT("Version"), TEXT(""), pComp->szVersion, countof(pComp->szVersion), g_szCustCif );
        GetPrivateProfileString( pSection, TEXT("Command1"), TEXT(""), pComp->szCommand, countof(pComp->szVersion), g_szCustCif );
        GetPrivateProfileString( pSection, TEXT("Path"), TEXT(""), pComp->szPath, countof(pComp->szPath), g_szCustCif );
        pComp->dwSize = GetPrivateProfileInt( pSection, TEXT("Size"), 0, g_szCustCif );
        pComp->iType = GetPrivateProfileInt( pSection, TEXT("Type1"), 0, g_szCustCif );
        pComp->iInstallType = GetPrivateProfileInt( pSection, TEXT("PreInstall"), 0, g_szCustCif);

        if (hDlg != NULL)
            pComp->iList = (int) SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_ADDSTRING, 0, (LPARAM) pComp->szDisplayName );
        
        GetPrivateProfileString( pSection, TEXT("Details"), TEXT(""), pComp->szDesc, countof(pComp->szDesc), g_szCustCif );
        pComp->fVisible = TRUE;
        pComp->fIEDependency = InsGetBool(pSection, TEXT("Dependency"), 0, g_szCustCif);
        
        if (StrCmpN(pComp->szDisplayName, s_szNewTpl, lstrlen(s_szNewTpl)) == 0)
        {
            i = StrToInt(pComp->szDisplayName + lstrlen(s_szNewTpl));
            if (i >= s_nNewCust) s_nNewCust = i  + 1;
        }
        i = StrToInt(pSection + countof("CUSTOM")-1);
        if (i >= s_nNewCust) s_nNewCust = i  + 1;
        pSection += StrLen(pSection) + 1;
        pComp++;
        g_nCustComp++;
    }

    s_iSelComp = 0;
    s_pSelComp = g_aCustComponents;
    if (hDlg != NULL)
        s_fCustCompInit = TRUE;

    if (g_nCustComp == 0)
    {
        if (hDlg != NULL)
        {
            int i;
            
            for (i = 0; i < NCUSTFIELDS ; i++ )
            {
                EnsureDialogFocus(hDlg, s_aCustFieldID[i], IDC_ADDNEWCOMP);
                DisableDlgItem(hDlg, s_aCustFieldID[i]);
            }
            for (i = 0; i < NCUSTSTATICTEXTFIELDS ; i++ )
                DisableDlgItem(hDlg, s_aCustStaticTextFieldID[i]);
        }
    }
    else
    {
        int i, iComp;

        if (hDlg != NULL)
            SetCustComponent(hDlg, 0);

        for (pComp = g_aCustComponents, iComp = 0; iComp < g_nCustComp ; pComp++, iComp++ )
        {
            TCHAR szModesParam[80] = TEXT("Cust0Modes");
            TCHAR szModes[16] = TEXT("\"");
            if (ISNULL(pComp->szSection)) break;
            szModesParam[4] = (TCHAR)(iComp + TEXT('0'));
            ZeroMemory(pComp->afInstall, sizeof(pComp->afInstall));
            GetPrivateProfileString(IS_STRINGS, szModesParam, TEXT(""), szModes, countof(szModes), g_szCustInf);
            StrCpy(pComp->szModes, szModes);
            if (StrCmpI(szModes, UNUSED) != 0)
            {
                for (i = 0; i < lstrlen(szModes) ; i++ )
                {
                    int j = szModes[i] - TEXT('0');
                    pComp->afInstall[j] = TRUE;
                }
            }

        }
    }
}

void SaveCustComponents()
{
    PCOMPONENT pComp;
    int i;
    TCHAR szSize[8];
    TCHAR szType[8];
    TCHAR szModesParam[80] = TEXT("Cust0Modes");
    TCHAR szTemp[80];

    for (pComp = g_aCustComponents, i = 0; i < g_nCustComp ; pComp++, i++)
    {
        LPTSTR pSection = pComp->szSection;
        wnsprintf(pSection, countof(pComp->szSection), TEXT("CUSTOM%i"), i);
        wnsprintf(szTemp, 80, TEXT("\"%s\""), pComp->szSwitches);
        StrCpy(pComp->szSwitches, szTemp);
        WritePrivateProfileString( pSection, TEXT("Switches1"),  pComp->szSwitches, g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("DisplayName"), pComp->szDisplayName, g_szCustCif );
        pComp->fVisible = TRUE;
        if (ISNULL(pComp->szGUID))
        {
            GUID guid;

            if (CoCreateGuid(&guid) == NOERROR)
                CoStringFromGUID(guid, pComp->szGUID, countof(pComp->szGUID));
            else
                wnsprintf(pComp->szGUID, countof(pComp->szGUID), TEXT("CUSTOM%i"),i);
        }
        WritePrivateProfileString( pSection, TEXT("GUID"),  pComp->szGUID,  g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("UninstallKey"),  pComp->szUninstall,  g_szCustCif );
        WriteActiveSetupURL(pComp,  g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("Version"),  pComp->szVersion, g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("Command1"), pComp->szCommand,  g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("Path"), pComp->szPath, g_szCustCif );
        wnsprintf(szSize, countof(szSize), TEXT("%i"), (int) pComp->dwSize);
        wnsprintf(szType, countof(szType), TEXT("%i"), pComp->iType);
        WritePrivateProfileString( pSection, TEXT("Size"), szSize, g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("Type1"), szType, g_szCustCif );
        WritePrivateProfileString( pSection, TEXT("Details"), pComp->szDesc, g_szCustCif );
        InsWriteInt( pSection, TEXT("PreInstall"), pComp->iInstallType, g_szCustCif );
        InsWriteBool( pSection, TEXT("Dependency"), pComp->fIEDependency, g_szCustCif );
        
        szModesParam[4] = (TCHAR)(i + TEXT('0'));
        WritePrivateProfileString(IS_STRINGS, szModesParam, pComp->szModes, g_szCustInf);
    }
    for (; i <= MAXCUST ; i++ )
    {
        TCHAR szSection[16];
        wnsprintf(szSection, countof(szSection), TEXT("CUSTOM%i"), i);
        WritePrivateProfileString( szSection, NULL, NULL, g_szCustCif );
        szModesParam[4] = (TCHAR)(i + TEXT('0'));
        WritePrivateProfileString(IS_STRINGS, szModesParam, NULL, g_szCustInf);
    }

    WritePrivateProfileString(NULL, NULL, NULL, g_szCustCif);
    WritePrivateProfileString(NULL, NULL, NULL, g_szCustInf);
}

// validate version info so that it can either contain a '.' char or numbers 0 - 9.
BOOL IsValidVersion(HWND hDlg, UINT nVersionCtrlID)
{
    TCHAR szVersion[MAX_PATH];
    int   nInvalidCharPos = -1;
    int   nLen            = 0;
    int   nNumLen         = 0;
    int   nComma          = 0;

    ZeroMemory(szVersion, sizeof(szVersion));
    GetDlgItemText(hDlg, nVersionCtrlID, szVersion, countof(szVersion));

    if (*szVersion == TEXT('\0'))
        return TRUE;

    nLen = StrLen(szVersion);
    for(int i = 0; (i < nLen && nInvalidCharPos == -1); i++)
    {
        if (szVersion[i] != TEXT(',') && !(szVersion[i] >= TEXT('0') && szVersion[i] <= TEXT('9')))
            nInvalidCharPos = i;
        else if (szVersion[i] == TEXT(','))
        {
            nComma++;
            if (i == 0 || szVersion[i - 1] == TEXT(',') || nComma > 3)
                nInvalidCharPos = i;
            nNumLen = 0;
        }
        else
        {
            nNumLen++;
            if (nNumLen > 4)
                nInvalidCharPos = i;
        }
    }
    if (nInvalidCharPos == -1 && (nNumLen == 0 || nComma < 3))
        nInvalidCharPos = nLen;

    if (nInvalidCharPos >= 0)
    {
        ErrorMessageBox(hDlg, IDS_INVALID_VERSION);
        SetFocus(GetDlgItem(hDlg, nVersionCtrlID));
        SendMessage(GetDlgItem(hDlg, nVersionCtrlID), EM_SETSEL, (WPARAM)nInvalidCharPos, (LPARAM)nLen);
        return FALSE;
    }
    return TRUE;
}

//
//  FUNCTION: CustomComponents(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "CustomComponents" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
BOOL APIENTRY CustomComponents(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    int     iComp, iNewSel, i;
    HRESULT res;
    HWND    hComplist;
    DWORD   dwFlags;

    switch (message)
    {
        case WM_INITDIALOG:
            EnableDBCSChars( hDlg, IDE_COMPFILENAME);
            EnableDBCSChars( hDlg, IDC_COMPTITLE);
            EnableDBCSChars( hDlg, IDE_COMPCOMMAND);
            EnableDBCSChars( hDlg, IDE_UNINSTALLKEY);
            EnableDBCSChars( hDlg, IDE_COMPPARAM);
            EnableDBCSChars( hDlg, IDE_COMPDESC);
            DisableDBCSChars(hDlg, IDE_COMPGUID);
            DisableDBCSChars(hDlg, IDE_COMPVERSION);

            // format for version field is XXXX,XXXX,XXXX,XXXX
            Edit_LimitText(GetDlgItem(hDlg, IDE_COMPVERSION), 19);
            Edit_LimitText(GetDlgItem(hDlg, IDC_COMPTITLE), countof(g_paComp->szDisplayName)-1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_COMPDESC), countof(g_paComp->szDesc)-1);

            g_hWizard = hDlg;
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            switch(HIWORD(wParam))
            {
                TCHAR szBuf[MAX_PATH];

                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_ADDNEWCOMP:
                            iComp = g_nCustComp;
                            if (iComp != 0)
                            {
                                GetCustComponent(hDlg, s_iSelComp);
                                if (ISNULL(g_aCustComponents[s_iSelComp].szDisplayName))
                                {
                                    ErrorMessageBox(hDlg, IDS_NOCUSTCOMPNAME);
                                    return TRUE;
                                }

                                dwFlags = FC_NONNULL | FC_FILE | FC_EXISTS;

                                if (!CheckField(hDlg, IDE_COMPFILENAME, dwFlags)
                                    || !IsValidVersion(hDlg, IDE_COMPVERSION))
                                    return TRUE;
                            }
                            else
                            {
                                for (i = 0; i < NCUSTFIELDS ; i++ )
                                {
                                    EnableDlgItem(hDlg, s_aCustFieldID[i]);
                                }

                                for (i = 0; i < NCUSTSTATICTEXTFIELDS ; i++ )
                                    EnableDlgItem(hDlg, s_aCustStaticTextFieldID[i]);
                            }

                            g_nCustComp++;
                            s_pSelComp = &g_aCustComponents[iComp];
                            ZeroMemory(s_pSelComp, sizeof(COMPONENT));
                            wnsprintf(s_pSelComp->szSection, countof(s_pSelComp->szSection), TEXT("CUSTOM%i"), s_nNewCust);
                            wnsprintf(s_pSelComp->szDisplayName, countof(s_pSelComp->szDisplayName), TEXT("%s%i"), s_szNewTpl, s_nNewCust++);
                            StrCpy(s_pSelComp->szModes, g_szAllModes);
                            s_pSelComp->iList = (int) SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_ADDSTRING, 0, (LPARAM) s_pSelComp->szDisplayName );
                            SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_SETCURSEL, s_pSelComp->iList, 0L);
                            s_iSelComp = s_pSelComp->iList;
                            SetCustComponent(hDlg, s_pSelComp->iList);
                            SendMessage(GetDlgItem( hDlg, IDC_COMPTITLE ), CB_SETEDITSEL,
                                0, MAKELPARAM(0, -1));
                            break;
                        case IDC_VERIFY:
                            dwFlags = FC_NONNULL | FC_FILE | FC_EXISTS;

                            if (!CheckField(hDlg, IDE_COMPFILENAME, dwFlags))
                                break;
                            s_pSelComp = &g_aCustComponents[s_iSelComp];
                            res = CheckTrustExWrap(NULL, s_pSelComp->szPath, hDlg, FALSE, NULL);
                            switch (res)
                            {
                                case NOERROR:
// note that the following means that the idiot hit 'no':
                                case TRUST_E_SUBJECT_NOT_TRUSTED:
                                case E_ABORT:
                                    ErrorMessageBox(hDlg, IDS_SIGNEDMSG, MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION);
                                    break;
                                case TRUST_E_NOSIGNATURE:
                                    ErrorMessageBox(hDlg, IDS_PLEASESIGNMSG);
                                    break;
                                case CERT_E_EXPIRED:
                                    ErrorMessageBox(hDlg, IDS_CERTEXPIREDMSG);
                                    break;
                                case TRUST_E_PROVIDER_UNKNOWN:
                                case CERT_E_UNTRUSTEDROOT:
                                    ErrorMessageBox(hDlg, IDS_BADPROVIDERMSG);
                                    break;
                                case CERT_E_MALFORMED:
                                case CERT_E_ISSUERCHAINING:
                                case CERT_E_CHAINING:
                                case CERT_E_CRITICAL:
                                case CERT_E_PATHLENCONST:
                                case CERT_E_ROLE:
                                case DIGSIG_E_DECODE:
                                case DIGSIG_E_ENCODE:
                                case DIGSIG_E_CRYPTO:
                                case DIGSIG_E_EXTENSIBILITY:
                                default:
                                    ErrorMessageBox(hDlg, IDS_CERTERRORMSG);
                                    break;
                            }
                            break;
                        case IDC_REMOVECOMP:
                            s_iSelComp = (int) SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_GETCURSEL, 0, 0L);
                            SendDlgItemMessage( hDlg, IDC_COMPTITLE, CB_DELETESTRING, s_iSelComp, 0L );
                            WritePrivateProfileString( g_aCustComponents[s_iSelComp].szSection, NULL, NULL, g_szCustCif );
                            for (i = s_iSelComp; i < g_nCustComp ; i++ )
                            {
                                g_aCustComponents[i] = g_aCustComponents[i + 1];
                                g_aCustComponents[i].iList--;
                            }
                            ZeroMemory(&g_aCustComponents[g_nCustComp--], sizeof(COMPONENT));
                            if (s_iSelComp >= g_nCustComp) s_iSelComp = g_nCustComp - 1;
                            SetCustComponent(hDlg, s_iSelComp);
                            break;
                        case IDC_BROWSEFILE:
                            GetDlgItemText(hDlg, IDE_COMPFILENAME, szBuf, countof(szBuf));
                            if (BrowseForFile(hDlg, szBuf, countof(szBuf), GFN_EXE | GFN_CAB))
                                SetDlgItemText(hDlg, IDE_COMPFILENAME, szBuf);
                            break;

                        case IDC_POSTINSTALL:
                        case IDC_REBOOTINSTALL:
                            if (HIWORD(wParam) == BN_CLICKED)
                            {
                                EnableDlgItem(hDlg, IDC_INSTALLSUCCESS);
                                break;
                            }
                            return FALSE;

                        case IDC_PREINSTALL:
                            if (HIWORD(wParam) == BN_CLICKED)
                            {
                                CheckDlgButton(hDlg, IDC_INSTALLSUCCESS, BST_UNCHECKED);
                                DisableDlgItem(hDlg, IDC_INSTALLSUCCESS);
                                break;
                            }
                            return FALSE;

                        default:
                            return FALSE;
                    }
                    break;

                case CBN_SELENDOK:
                    hComplist = GetDlgItem(hDlg, IDC_COMPTITLE);
                    iNewSel = (int) SendMessage( hComplist, CB_GETCURSEL, 0, 0L);
                    if (iNewSel != s_iSelComp)
                    {
                        if (ISNULL(g_aCustComponents[s_iSelComp].szDisplayName))
                        {
                            ErrorMessageBox(hDlg, IDS_NOCUSTCOMPNAME);
                            return TRUE;
                        }

                        dwFlags = FC_NONNULL | FC_FILE | FC_EXISTS;

                        if (!CheckField(hDlg, IDE_COMPFILENAME, dwFlags))
                        {
                            return TRUE;
                        }

                        if (!IsValidVersion(hDlg, IDE_COMPVERSION))
                            return TRUE;
                    }

                    GetWindowText( hComplist, s_pSelComp->szDisplayName, 80 );
                    SendMessage( hComplist, CB_DELETESTRING, s_iSelComp, 0L );
                    SendMessage( hComplist, CB_INSERTSTRING, s_iSelComp,
                        (LPARAM) s_pSelComp->szDisplayName);
                    if ((iNewSel != CB_ERR) && (iNewSel != s_iSelComp))
                    {
                        GetCustComponent(hDlg, s_iSelComp);
                        s_iSelComp = iNewSel;
                        s_pSelComp = &g_aCustComponents[s_iSelComp];
                        SetCustComponent(hDlg, s_iSelComp);
                    }
                    if (iNewSel < 0) iNewSel = 0;
                    SendMessage( hComplist, CB_SETCURSEL, iNewSel, 0L );
                    break;

                case CBN_EDITCHANGE:
                    GetWindowText( (HWND) lParam, s_pSelComp->szDisplayName, 80 );
                    break;

                case CBN_CLOSEUP:
                case CBN_SELENDCANCEL:
                case CBN_DROPDOWN:
                case CBN_KILLFOCUS:
                    if (s_iSelComp >= 0)
                    {
                        hComplist = GetDlgItem(hDlg, IDC_COMPTITLE);
                        GetWindowText( hComplist, s_pSelComp->szDisplayName, countof(s_pSelComp->szDisplayName) );
                        SendMessage( hComplist, CB_DELETESTRING, s_iSelComp, 0L );
                        SendMessage( hComplist, CB_INSERTSTRING, s_iSelComp,
                            (LPARAM) s_pSelComp->szDisplayName);
                        SendMessage( hComplist, CB_SETCURSEL, s_iSelComp, 0L );
                    }
                    break;

                case EN_CHANGE:
                    switch (LOWORD(wParam))
                    {
                        case IDE_COMPFILENAME:
                            if (s_pSelComp) CheckCompType(hDlg, s_pSelComp);
                            break;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    if (!s_fCustCompInit)
                        InitCustComponents(hDlg);
                    else
                        SetCustComponent(hDlg, s_iSelComp);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                    CheckBatchAdvance(hDlg);
                    break;


                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    GetCustComponent(hDlg, s_iSelComp);

                    if (g_nCustComp > 0)
                    {
                        if (ISNULL(g_aCustComponents[s_iSelComp].szDisplayName))
                        {
                            ErrorMessageBox(hDlg, IDS_NOCUSTCOMPNAME);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                        dwFlags = FC_NONNULL | FC_FILE | FC_EXISTS;

                        if (!CheckField(hDlg, IDE_COMPFILENAME, dwFlags))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                        if (!IsValidVersion(hDlg, IDE_COMPVERSION))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                    }

                    SaveCustComponents();

                    g_iCurPage = PPAGE_CUSTCOMP;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;

        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

int s_aiIcon[7];
HWND s_hStat,s_hStatus;

extern HWND g_hProgress;
static BOOL s_fComponent = FALSE;

static BOOL s_fNoNet = FALSE;
HWND g_hWait = NULL;

BOOL CALLBACK DownloadStatusDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM)
{
    RECT dlgRect;
    DWORD width, height, left, top;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            if (s_fComponent)
            {
                Animate_Open( GetDlgItem( hDlg, IDC_ANIM ), IDA_DOWNLOAD );
                Animate_Play( GetDlgItem( hDlg, IDC_ANIM ), 0, -1, -1 );
                InitSysFont(hDlg, IDC_DOWNCOMPNAMD);
                InitSysFont(hDlg, IDC_DOWNSTATUS);

                g_hProgress = GetDlgItem( hDlg, IDC_PROGRESS );
                s_hStatus = GetDlgItem( hDlg, IDC_DOWNSTATUS );
                SendMessage(g_hProgress, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
                SendMessage(g_hProgress, PBM_SETPOS, 0, 0L);
            }
            else
            {
                Animate_Open( GetDlgItem( hDlg, IDC_ANIM ), IDA_GEARS );
                Animate_Play( GetDlgItem( hDlg, IDC_ANIM ), 0, -1, -1 );
            }
            GetWindowRect(hDlg, &dlgRect);
            width = dlgRect.right - dlgRect.left;
            height = dlgRect.bottom - dlgRect.top;
            left = (g_dtRect.right - width)/2;
            top = (g_dtRect.bottom - height)/2;
            MoveWindow(hDlg, left, top, width, height, TRUE);
            break;

        case WM_COMMAND:
            if ((LOWORD(wParam) == IDCANCEL) && (HIWORD(wParam) == BN_CLICKED)) g_fCancelled = TRUE;
            break;

        case WM_CLOSE:
            g_hProgress = NULL;
            s_hStatus = NULL;
            EndDialog(hDlg, 0);
            break;

        default:
            return(FALSE);
    }
    return(TRUE);

}


static HINTERNET s_hInet = NULL;
DWORD g_nTotDown = 0;

HRESULT InetDownloadFile(LPTSTR szTempfile, LPTSTR szUrl, HWND hProgress, int sDownload, LPTSTR szFilename)
{
    HRESULT res = NOERROR;
    HINTERNET hInetFile = 0;
    DWORD dwTotDown = 0;
    if (s_hInet == NULL)
        s_hInet = InternetOpen(TEXT("Mozilla/4.0 (compatible; MSIE 4.01; Windows NT);IEAKWIZ"),
        INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);

    hInetFile = InternetOpenUrl(s_hInet, szUrl, TEXT("Accept: */*\r\n"), (DWORD)-1,
        INTERNET_FLAG_DONT_CACHE, 0);

    if (hInetFile  != NULL)
    {
        CHAR szBuf[4096];
        DWORD nRead, nWritten;
        MSG msg;
        DeleteFile(szTempfile);
        HANDLE hFile = CreateFile(szTempfile, GENERIC_WRITE, 0, NULL, CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE) while (1)
        {
            if (g_fCancelled)
            {
                res = -1;
                break;
            }
            while (PeekMessage( &msg, s_hStat, 0, 0, PM_REMOVE ))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            if (InternetReadFile(hInetFile, szBuf, sizeof(szBuf), &nRead))
            {
                if (nRead == 0) break;
                WriteFile( hFile, szBuf, nRead, &nWritten, NULL );
                dwTotDown += nWritten;
                g_nTotDown += nWritten;
                if (hProgress != NULL)
                {
                    int iPercent = g_nTotDown / (sDownload * 10);
                    SendMessage(hProgress, PBM_SETPOS, iPercent, 0L);
                    SetWindowTextSmart( s_hStatus, szFilename );
                }
            }
            else
            {
                res = -1;
                break;
            }
        }
//Code Path never called under NT build environment
//causes build error under MSDev: pFilename not defined
/*
#ifdef _DEBUG
        if (g_nTotDown)
        {
            TCHAR szMsg[MAX_PATH];
            wnsprintf(szMsg, countof(szMsg), "BRANDME: Wrote %i bytes to %s\r\n", g_nTotDown, pFilename);
            OutputDebugString(szMsg);
        }
#endif
*/
        CloseHandle(hFile);
        InternetCloseHandle(hInetFile);
    }
    else  res = -1;
    if (dwTotDown < 512)
        res = -1;

    return(res);
}

BOOL CALLBACK DupeSynchDlgProc (HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    int nResult;
    switch (iMsg)
    {
    case WM_INITDIALOG:
        SetWindowText(hDlg, (TCHAR *)lParam);
        SetTimer(hDlg, 0, 300000, NULL);
        return TRUE;
    case WM_TIMER:
        EndDialog(hDlg, IDIGNORE);
        return TRUE;
    case WM_COMMAND:
        switch (LOWORD (wParam))
        {
        case IDC_NOTOALL:
            nResult = IDIGNORE;
            break;
        case IDC_YESSYNCH:
            nResult = IDYES;
            break;
        case IDC_NOSYNCH:
        default:
            nResult = IDNO;
            break;
        }
        EndDialog(hDlg, nResult);
        return TRUE;
    }
    return FALSE;
}

BOOL CALLBACK ErrDlgProc (HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    int nResult;
    switch (iMsg)
    {
    case WM_INITDIALOG:
        if (GetDlgItem(hDlg, IDC_BADCOMP))
            SetDlgItemText(hDlg, IDC_BADCOMP, (TCHAR *)lParam);
        else
        {
            if (GetDlgItem(hDlg, IDC_BADCOMPSEC))
                SetDlgItemText(hDlg, IDC_BADCOMPSEC, (TCHAR *)lParam);
        }
        SetTimer(hDlg, 0, 300000, NULL);
        return TRUE;
    case WM_TIMER:
        EndDialog(hDlg, IDIGNORE);
        return TRUE;
    case WM_COMMAND:
        switch (LOWORD (wParam))
        {
        case IDC_ERRDLABORT:
            nResult = IDABORT;
            break;
        case IDC_ERRDLRETRY:
        case IDC_SECERRYES:
            nResult = IDRETRY;
            break;
        case IDC_SECERRNO:
        case IDC_ERRDLIGNORE:
        default:
            nResult = IDIGNORE;
            break;
        }
        EndDialog(hDlg, nResult);
        return TRUE;
    }
    return FALSE;
}

int DownloadErrMsg(HWND hWnd, LPTSTR szFilename, LPCTSTR lpTemplateName)
{
    return (int) DialogBoxParam(g_rvInfo.hInst, lpTemplateName, hWnd, (DLGPROC) ErrDlgProc, LPARAM(szFilename));
}

HRESULT DownloadCab(HWND hDlg, LPTSTR szUrl, LPTSTR szFilename, LPCTSTR pcszDisplayname, int sComponent, BOOL &fIgnore)
{
    HRESULT res = NOERROR;
    TCHAR szTempfile[MAX_PATH];
    LPTSTR pBack, pDot, pFile, pSlash;
    int i, iMsgRes;

    StrCpy( szTempfile, szFilename );
    pBack = StrRChr(szTempfile, NULL, TEXT('\\'));
    pDot = StrRChr(szUrl, NULL, TEXT('.'));
    pSlash = StrRChr(szUrl, NULL, TEXT('/'));
    StrCpy(pBack, TEXT("\\TEMPFILE"));
    if (pDot > pSlash)
        StrCat(szTempfile, pDot);
    DeleteFile( szTempfile );

    if (pcszDisplayname)
    {
        s_fComponent = TRUE;
        SetDlgItemText( s_hStat, IDC_DOWNCOMPNAMD, pcszDisplayname );
    }

    pFile = StrRChr(szUrl, NULL, TEXT('/'));
    if (pFile)
        pFile++;
    else
        pFile = szUrl;

    for (i=0; i < 3; i++)
    {
        res = InetDownloadFile(szTempfile, szUrl, g_hProgress, sComponent, szFilename);

        if ((res == NOERROR)||(g_fCancelled))
        {
            break;
        }
    }

    if ((res != NOERROR)&&(!g_fCancelled))
    {
        while( (iMsgRes = DownloadErrMsg(hDlg, pFile, MAKEINTRESOURCE(IDD_DOWNLOADERR))) == IDRETRY)
        {
            res = InetDownloadFile(szTempfile, szUrl, g_hProgress, sComponent, szFilename);

            if (res == NOERROR)
            {
                break;
            }
        }

        if (res != NOERROR)
        {
            if (iMsgRes == IDABORT)
                return res;
            else
            {
                res = NOERROR;
                fIgnore = TRUE;
                StrCat(g_szFailedComps, pFile);
                StrCat(g_szFailedComps, TEXT("\r\n"));
                g_fFailedComp = TRUE;
            }
        }
    }

    if ((!fIgnore)&&(!g_fCancelled))
    {
        DeleteFile(szFilename);
        res = CheckTrustExWrap(szUrl, szTempfile, hDlg, FALSE, NULL);

        if (res != NOERROR)
        {
            iMsgRes = DownloadErrMsg(hDlg, pFile, MAKEINTRESOURCE(IDD_DOWNLOADSEC));
            if (iMsgRes == IDRETRY)
                res = NOERROR;
            else
            {
                StrCat(g_szFailedComps, pFile);
                StrCat(g_szFailedComps, TEXT("\r\n"));
                g_fFailedComp = TRUE;
                res = DONT_SHOW_UPDATES;
            }
        }

        if (res == NOERROR)
        {
            if (!MoveFile( szTempfile, szFilename ))
            {
                res = 0xffffffff;
            }
        }
    }
    DeleteFile(szTempfile);
    return(res);

}

void NeedToSetMSTrustKey()
{
    static BOOL s_fFirst = TRUE;
    HKEY  hKey;
    DWORD dwTmp;

    if (!s_fFirst)
        return;

    s_fFirst = FALSE;

    // Check MS Vendor trust key and set
    if (RegOpenKeyEx(HKEY_CURRENT_USER, RK_TRUSTKEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        for (int i=0; i < countof(s_tkTrustArray); i++)
        {
            if (RegQueryValueEx( hKey, s_tkTrustArray[i].szTrustString, 0, NULL, NULL, &dwTmp ) == ERROR_SUCCESS)
                s_tkTrustArray[i].fSet = FALSE;
        }
        RegCloseKey(hKey);
    }
}

void WriteMSTrustKey(BOOL bSet)
{
    HKEY  hKey;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, RK_TRUSTKEY, 0, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        if (bSet)
        {
            for (int i=0; i < countof(s_tkTrustArray); i++)
            {
                if (s_tkTrustArray[i].fSet)
                    RegSetValueEx( hKey, s_tkTrustArray[i].szTrustString, 0, REG_SZ,
                    (LPBYTE)s_tkTrustArray[i].szCompanyName, sizeof(s_tkTrustArray[i].szCompanyName) );
            }
        }
        else
        {
            for (int i=0; i < countof(s_tkTrustArray); i++)
            {
                if (s_tkTrustArray[i].fSet)
                    RegDeleteValue( hKey, s_tkTrustArray[i].szTrustString );
            }
        }
        RegCloseKey(hKey);
    }
}


void AnyCompSelected(HWND hDlg, BOOL &fSel, BOOL &fSizeChange)  //---- Blue and Brown components change size, and
{                                                               //     need to know to grey out synchronize button
    HWND hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
    fSel           = FALSE;
    fSizeChange    = FALSE;

    PCOMPONENT pComp;

    for (pComp = g_paComp; ; pComp++ )
    {
        if (!pComp || (!(*pComp->szSection))) break;
        if (ListView_GetItemState(hCompList, pComp->iList, LVIS_SELECTED) & LVIS_SELECTED)
            if ((BLUE2 == pComp->iImage) || (BROWN2 == pComp->iImage))
                fSizeChange = TRUE;
            else
                fSel = TRUE;
    }
}

BOOL AnyCompSelected(HWND hDlg)
{

    HWND hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
    
    PCOMPONENT pComp;

    for (pComp = g_paComp; ; pComp++ )
    {
        if (!pComp || (!(*pComp->szSection))) break;
        if ((BLUE2 != pComp->iImage) && (BROWN2 != pComp->iImage))
            if (ListView_GetItemState(hCompList, pComp->iList, LVIS_SELECTED) & LVIS_SELECTED)
                return TRUE;
    }
    return FALSE;
}

void WriteModesToCif(CCifRWComponent_t * pCifRWComponent_t, LPCTSTR pcszModes)
{
    int i;
    TCHAR szCommaModes[32];

    if (pcszModes == NULL || ISNULL(pcszModes))
        szCommaModes[0] = TEXT('\0');
    else
    {
        for (i = 0; pcszModes[i]; i++)
        {
            szCommaModes[i*2] = pcszModes[i];
            szCommaModes[(i*2)+1] = TEXT(',');
        }
        szCommaModes[(i*2)-1] = TEXT('\0');
    }

    pCifRWComponent_t->SetModes(szCommaModes);
}

void writeToCifFile(PCOMPONENT pComp, LPTSTR szCifNew)
{
    ICifRWComponent*   pCifRWComponent;
    CCifRWComponent_t* pCifRWComponent_t;
    LPTSTR             pszSection;
    DWORD              dwVer, dwBuild;

    g_lpCifRWFile->CreateComponent(pComp->szSection, &pCifRWComponent);
    pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
    pCifRWComponent_t->CopyComponent(szCifNew);
    WriteModesToCif(pCifRWComponent_t, pComp->szModes);
    delete pCifRWComponent_t;
    g_lpCifRWFileVer->CreateComponent(pComp->szSection, &pCifRWComponent);
    pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
    pCifRWComponent_t->CopyComponent(szCifNew);
    pCifRWComponent_t->GetVersion(&dwVer, &dwBuild);
    delete pCifRWComponent_t;
    ConvertDwordsToVersionStr(pComp->szVersion, dwVer, dwBuild);

    pszSection = pComp->pszAVSDupeSections;

    while (pszSection != NULL)
    {
        if ((pComp = FindComp(pszSection, FALSE)) != NULL)
        {
            g_lpCifRWFile->CreateComponent(pComp->szSection, &pCifRWComponent);
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            pCifRWComponent_t->CopyComponent(szCifNew);
            WriteModesToCif(pCifRWComponent_t, pComp->szModes);
            delete pCifRWComponent_t;
            g_lpCifRWFileVer->CreateComponent(pComp->szSection, &pCifRWComponent);
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            pCifRWComponent_t->CopyComponent(szCifNew);
            pCifRWComponent_t->GetVersion(&dwVer, &dwBuild);
            delete pCifRWComponent_t;
            ConvertDwordsToVersionStr(pComp->szVersion, dwVer, dwBuild);
        }

        pszSection = StrChr(pszSection, TEXT(','));
        if (pszSection != NULL)
            pszSection++;
    }
}

void updateCifVersions32(PCOMPONENT pComp, BOOL fIgnore, BOOL fUpdate)
{
    TCHAR szCifPath[MAX_PATH];
    
    if ((!fUpdate) && (BLUE2 != pComp->iImage) && (BROWN2 != pComp->iImage))
        if (fIgnore)
            pComp->iImage = YELLOW;
        else
            pComp->iImage = GREEN;

        //---- use other ieupdate.cif for updates
    if ((fUpdate) || (BLUE2 == pComp->iImage) || (BROWN2 == pComp->iImage)) {
        PathCombine(szCifPath, g_szIEAKProg, TEXT("update\\ieupdate.cif"));
        writeToCifFile(pComp, szCifPath);
    }
    else
        writeToCifFile(pComp, s_szCifNew);
}

static s_fNoToAllSynch;

void DownloadComponent32(HWND hDlg, PCOMPONENT pComp, HWND hCompList, BOOL &g_fCancelled,
                         BOOL &fOk, BOOL &fDownloaded, BOOL &fIgnore, BOOL fAll)
{
    TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szCompUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szLocalPath[MAX_PATH];
    TCHAR szUpdateCif[MAX_PATH];
    LPTSTR pCab;
    LV_ITEM lvItem;
    CCifFile_t*     pCifFile = NULL;
    ICifComponent * pCifComponent = NULL;
    CCifComponent_t * pCifComponent_t;
    UINT uiIndex = 0;
    DWORD dwFlags;
    TCHAR tchType = '\0';
    int iRet = IDYES;
    UNREFERENCED_PARAMETER(tchType);

    if ((BLUE2 == pComp->iImage) || (BROWN2 == pComp->iImage)) {
        StrCpy(szUpdateCif, g_szIEAKProg);
        PathAppend(szUpdateCif, TEXT("\\update\\ieupdate.cif"));
        if (!PathFileExists(szUpdateCif))
            return;
        GetICifFileFromFile_t(&pCifFile, szUpdateCif);
        if (g_fCancelled || (FAILED(pCifFile->FindComponent(pComp->szSection, &pCifComponent))))
            return;
    }
    else  
        if (g_fCancelled || (FAILED(g_lpCifFileNew->FindComponent(pComp->szSection, &pCifComponent))))
            return;

    pCifComponent_t = new CCifComponent_t((ICifRWComponent *)pCifComponent);

    // pComp->fIEDependency is used as a guard against circular dependencies here
    if (!pComp->fIEDependency && !pComp->fAVSDupe)
    {
        pComp->fIEDependency = TRUE;
                           //--- now BLUE2 and BROWN2 also mean that the component has already been downloaded
        if (((pComp->iImage != GREEN) && (pComp->iImage != BLUE2) && (pComp->iImage != BROWN2)) || 
            (!fAll && !s_fNoToAllSynch && (( iRet = (int) DialogBoxParam(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_DUPESYNCH),
            s_hStat, (DLGPROC) DupeSynchDlgProc, (LPARAM)pComp->szDisplayName)) == IDYES)))
        {
            while (SUCCEEDED(pCifComponent_t->GetUrl(uiIndex, szUrl, countof(szUrl), &dwFlags)))
            {
                if (dwFlags & URLF_RELATIVEURL)
                {
                    StrCpy(szCompUrl, g_szBaseURL);
                    StrCat(szCompUrl, TEXT("/"));
                    StrCat(szCompUrl, szUrl);
                    pCab = szUrl;
                }
                else
                {
                    StrCpy(szCompUrl, szUrl);
                    pCab = StrRChr(szUrl, NULL, TEXT('/'));
                    if (pCab)
                        pCab++;
                    else
                        pCab = szUrl;
                }
                PathCombine(szLocalPath, g_szIEAKProg, pCab);
                if (pComp->dwSize)
                {
                    if(StrCmpI(pCab, TEXT("oem.cab"))) //special case out the OEMInstall cab
                    {
                        if (DownloadCab(s_hStat, szCompUrl, szLocalPath, pComp->szDisplayName, pComp->dwSize, fIgnore)
                            != NOERROR)
                        {
                            fOk = FALSE;
                            g_fCancelled = TRUE;
                        }
                        else
                            if ((BLUE2 == pComp->iImage) || (BROWN2 == pComp->iImage)) {
                                pComp->iImage = GREEN;
                                updateCifVersions32(pComp, fIgnore);
                            }
                        fDownloaded = TRUE;
                    }
                }
                if (g_fCancelled) break;
                uiIndex++;
            }
        }
        else  //we are not downloading this cab because it's already downloaded
        {
            //process window messages, so we pick up messages like cancel for download status popup
            MSG msg;

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (iRet == IDIGNORE)
            s_fNoToAllSynch = TRUE;

        if (!g_fCancelled)
        {
            if (fIgnore)
                    pComp->iImage = YELLOW;
            else
                if ((BLUE2 != pComp->iImage) && (BROWN2 != pComp->iImage))
                    pComp->iImage = GREEN;

            uiIndex = 0;

            while (SUCCEEDED(pCifComponent_t->GetDependency(uiIndex, szLocalPath, countof(szLocalPath), &tchType, NULL, NULL)))
            {
                PCOMPONENT pDepComp;

                pDepComp = FindComp(szLocalPath, FALSE);

                if (pDepComp && (pDepComp->iCompType == COMP_OPTIONAL))
                {
                    DownloadComponent32(hDlg, pDepComp, hCompList, g_fCancelled, fOk, fDownloaded, fIgnore, fAll);
                    if (g_fCancelled)
                        break;
                }
                uiIndex++;
            }
        }

        if (g_fCancelled)
        {
            pComp->iImage = RED;

            if ((pComp->iCompType == COMP_OPTIONAL) && (pComp->iPlatform <= PLAT_W98)
                && pComp->fVisible)
            {
                ZeroMemory(&lvItem, sizeof(lvItem));
                lvItem.mask = LVIF_IMAGE;
                lvItem.iItem = pComp->iList;
                ListView_GetItem(hCompList, &lvItem);

                lvItem.iImage = RED;
                lvItem.mask = LVIF_IMAGE;
                lvItem.iItem = pComp->iList;
                ListView_SetItem(hCompList, &lvItem);
                ListView_SetItemText(hCompList, pComp->iList, 1, TEXT(""));
            }

            if (SUCCEEDED(pCifComponent_t->GetUrl(0, szUrl, countof(szUrl), &dwFlags)))
            {
                if (dwFlags & URLF_RELATIVEURL)
                {
                    pCab = szUrl;
                }
                else
                {
                    pCab = StrRChr(szUrl, NULL, TEXT('/'));
                    if (pCab)
                        pCab++;
                    else
                        pCab = szUrl;
                }
                PathCombine(szLocalPath, g_szIEAKProg, pCab);
                DeleteFile(szLocalPath);
            }
            return;
        }

        updateCifVersions32(pComp, fIgnore);

        if (pComp->fVisible && ((pComp->iCompType != COMP_OPTIONAL) || (pComp->iPlatform <= PLAT_W98)))
        {
            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.mask = LVIF_IMAGE;
            lvItem.iItem = pComp->iList;
            ListView_GetItem(hCompList, &lvItem);

            if ((BLUE2 == pComp->iImage) || (BROWN2 == pComp->iImage))
                lvItem.iImage = pComp->iImage;
            else
                if (fIgnore)
                    lvItem.iImage = YELLOW;
                else
                    lvItem.iImage = GREEN;
            lvItem.mask = LVIF_IMAGE;
            lvItem.iItem = pComp->iList;
            ListView_SetItem(hCompList, &lvItem);
            ListView_SetItemText(hCompList, pComp->iList, 1, pComp->szVersion);
        }
    }

    delete pCifComponent_t;
}

void DownloadComponent(HWND hDlg, PCOMPONENT pComp, HWND hCompList, BOOL &g_fCancelled,
                       BOOL &fOk, BOOL &fDownloaded, BOOL &fIgnore, BOOL fAll)
{
    PCOMPONENT pCompTemp;
    for (pCompTemp = g_paComp; *pCompTemp->szSection; pCompTemp++)
        pCompTemp->fIEDependency = FALSE;
    DownloadComponent32(hDlg, pComp, hCompList, g_fCancelled, fOk, fDownloaded, fIgnore, fAll);
}

BOOL IsCheyenneSoftwareRunning(HWND hDlg)
{
    if (FindWindow(NULL, TEXT("Inoculan Realtime Manager")) ||
        FindWindow(NULL, TEXT("Cheyenne ANtiVirus Realtime Monitor")))
    {
        TCHAR szMsgBoxText[MAX_PATH];

        LoadString( g_rvInfo.hInst, IDS_VIRUSPROGRAMRUNNING, szMsgBoxText, countof(szMsgBoxText) );
        MessageBox(hDlg, szMsgBoxText, g_szTitle, MB_OK);
        return TRUE;
    }

    return FALSE;
}

void ProcessDownload(HWND hDlg, BOOL fAll)
{
    HWND hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
    TCHAR szWrk[MAX_PATH];
    PCOMPONENT pComp;
    BOOL fDownloaded;
    BOOL fIgnore = FALSE;

    if (IsCheyenneSoftwareRunning(hDlg))
        return;

    g_fCancelled = FALSE;
    s_fComponent = TRUE;
    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
    s_hStat = CreateDialog( g_rvInfo.hInst,  MAKEINTRESOURCE(IDD_DOWNLOAD), NULL,
        (DLGPROC) DownloadStatusDlgProc );
    ShowWindow( s_hStat, SW_SHOWNORMAL );
    g_fFailedComp = FALSE;
    LoadString( g_rvInfo.hInst, IDS_DOWNLOADLIST_ERROR, g_szFailedCompsMsg, countof(g_szFailedCompsMsg) );
    for (pComp = g_paComp; ; pComp++ )
        if ((BROWN2 != pComp->iImage) && (BLUE2 != pComp->iImage))
        {
            LV_ITEM lvItem;
            BOOL fOk = TRUE;
            DWORD dwDestFree;
            PCOMPONENT pSearchComp;
            fDownloaded = FALSE;
            ZeroMemory(&lvItem,sizeof(lvItem));
            if (ISNULL(pComp->szSection)) break;
            lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
            lvItem.stateMask = LVIS_SELECTED;
            lvItem.iItem = pComp->iList;
            ListView_GetItem(hCompList, &lvItem);
            if (!fAll)
            {
                if ((pComp->iList == 0) && (pComp->iCompType == COMP_OPTIONAL)) continue;
                if ((lvItem.state & LVIS_SELECTED) == 0)  continue;
            }
    // BUGBUG fix once we do Alpha version
            if (pComp->iPlatform == PLAT_ALPHA) continue;
            SetDlgItemText( s_hStat, IDC_DOWNCOMPNAMD, pComp->szDisplayName );
            g_nTotDown = 0;
            StrCpy(szWrk, g_szIEAKProg);
            dwDestFree = GetRootFree(szWrk);
            if (dwDestFree < pComp->dwSize)
            {
                TCHAR szTitle[MAX_PATH];
                TCHAR szTemplate[MAX_PATH];
                TCHAR szMsg[MAX_PATH];
                LoadString( g_rvInfo.hInst, IDS_DISKERROR, szTitle, MAX_PATH );
                LoadString( g_rvInfo.hInst, IDS_TEMPDISKMSG, szTemplate, MAX_PATH );
                wnsprintf(szMsg, countof(szMsg), szTemplate, dwDestFree, (pComp->dwSize));
                MessageBox(NULL, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
                DestroyWindow(s_hStat);
                return;
            }

            fIgnore = FALSE;
            DownloadComponent(hDlg, pComp, hCompList, g_fCancelled, fOk, fDownloaded, fIgnore, fAll);
    /*
            if (*(pComp->piPatchInfo.szSection))   // download patch files
            {
                DownloadComponent(pComp->piPatchInfo.szSection, pComp->szDisplayName, pComp->piPatchInfo.dwSize, g_fCancelled, fOk, fDownloaded, fIgnore, fAll);

                if (fOk)
                {
                    TCHAR szSectBuf[1024];

                    GetPrivateProfileSection( pComp->piPatchInfo.szSection, szSectBuf, countof(szSectBuf), s_szCifNew );
                    WritePrivateProfileSection( pComp->piPatchInfo.szSection, szSectBuf, g_szCif );
                }
            }
    */
            if (!fAll && fDownloaded && !g_fCancelled && (pComp->iCompType == COMP_OPTIONAL))
            {
                // search to download comp on other platforms
                for (pSearchComp = g_paComp; ; pSearchComp++)
                {
                    if (ISNULL(pSearchComp->szSection)) break;
                    if ((StrCmpI(pSearchComp->szDisplayName, pComp->szDisplayName) == 0)
                        && (pSearchComp != pComp))
                    {
                        SetDlgItemText( s_hStat, IDC_DOWNCOMPNAMD, pSearchComp->szDisplayName );
                        g_nTotDown = 0;
                        StrCpy(szWrk, g_szIEAKProg);
                        dwDestFree = GetRootFree(szWrk);
                        if (dwDestFree < pSearchComp->dwSize)
                        {
                            TCHAR szTitle[MAX_PATH];
                            TCHAR szTemplate[MAX_PATH];
                            TCHAR szMsg[MAX_PATH];
                            LoadString( g_rvInfo.hInst, IDS_DISKERROR, szTitle, MAX_PATH );
                            LoadString( g_rvInfo.hInst, IDS_TEMPDISKMSG, szTemplate, MAX_PATH );
                            wnsprintf(szMsg, countof(szMsg), szTemplate, dwDestFree, (pSearchComp->dwSize));
                            MessageBox(NULL, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
                            DestroyWindow(s_hStat);
                            return;
                        }
                        DownloadComponent(hDlg, pSearchComp, hCompList, g_fCancelled, fOk, fDownloaded, fIgnore, fAll);

                        if (g_fCancelled) break;
                  /*      if (*(pSearchComp->piPatchInfo.szSection))   // download patch files
                        {
                            DownloadComponent(pSearchComp->piPatchInfo.szSection, pSearchComp->szDisplayName,
                                pSearchComp->piPatchInfo.dwSize, g_fCancelled, fOk, fDownloaded, fIgnore);

                            if (fOk)
                            {
                                TCHAR szSectBuf[1024];

                                GetPrivateProfileSection( pSearchComp->piPatchInfo.szSection, szSectBuf, countof(szSectBuf), s_szCifNew );
                                WritePrivateProfileSection( pSearchComp->piPatchInfo.szSection, szSectBuf, g_szCif );
                            }
                        }*/

                        if (g_fCancelled) break;

                        if (fOk)
                            updateCifVersions32(pSearchComp, fIgnore);
                    }
                }
            }

            if (fOk && !g_fCancelled)
            {
                PCOMPONENT pListComp = pComp;

                if (pComp->iCompType != COMP_OPTIONAL)
                {
                    s_fNoCore = FALSE;
                    pListComp = FindComp(NULL, TRUE);
                }
                if (fIgnore)
                    lvItem.iImage = pComp->iImage = YELLOW;
                else
                    if ((BLUE2 == pComp->iImage) || (BROWN2 == pComp->iImage))
                        lvItem.iImage = pComp->iImage;
                    else
                        lvItem.iImage = pComp->iImage = GREEN;
                lvItem.mask = LVIF_IMAGE;
                lvItem.iItem = pListComp->iList;
                ListView_SetItem(hCompList, &lvItem);

                updateCifVersions32(pComp, fIgnore);

                // Do not try to set the version field for NT optional components or invisible
                // components for win32 since their iList fields will be zeroed

                if (((pComp->fVisible || (StrCmpI(pComp->szSection, BASEWIN32) == 0)) &&
                    ((pComp->iCompType != COMP_OPTIONAL) || (pComp->iPlatform <= PLAT_W98))))
                    ListView_SetItemText(hCompList, pListComp->iList, 1, pListComp->szVersion);
            }
            else
            {
                TCHAR szUrl[MAX_PATH];
                LPTSTR pUrl = szUrl;
                TCHAR szLocalPath[MAX_PATH];
                ICifComponent * pCifComponent;
                CCifComponent_t * pCifComponent_t;
                HRESULT hr;
                DWORD dwFlags;

                if (pComp->iCompType != COMP_OPTIONAL)
                {
                    s_fNoCore = TRUE;
                    pComp = FindComp(NULL, TRUE);
                }
                if ((pComp->iImage != BROWN2) && (pComp->iImage != BLUE2)) {
                    lvItem.iImage = pComp->iImage = RED;
                    lvItem.mask = LVIF_IMAGE;
                    lvItem.iItem = pComp->iList;
                    ListView_SetItem(hCompList, &lvItem);
                    ListView_SetItemText(hCompList, pComp->iList, 1, TEXT(""));
                }

                if (!(SUCCEEDED(g_lpCifFileNew->FindComponent(pComp->szSection, &pCifComponent))))
                    break;

                pCifComponent_t = new CCifComponent_t((ICifRWComponent *)pCifComponent);
                hr = pCifComponent_t->GetUrl(0, szUrl, countof(szUrl), &dwFlags);
                delete pCifComponent_t;

                if (!(SUCCEEDED(hr)))
                    break;

                if (!(dwFlags & URLF_RELATIVEURL))
                {
                    pUrl = StrRChr(szUrl, NULL, TEXT('/'));
                    if (pUrl)
                        pUrl++;
                    else
                        pUrl = szUrl;
                }
            
                PathCombine(szLocalPath, g_szIEAKProg, pUrl);
                DeleteFile(szLocalPath);
                break;
            }

        }
    DestroyWindow(s_hStat);
}

void SetCompRevDependList(PCOMPONENT pComp, CCifComponent_t * pCifComponent_t)
{
    UINT uiIndex = 0;
    PCOMPONENT pCompTemp;
    ICifComponent * pCifCompNew;
    TCHAR szID[128];
    TCHAR tchType;

    while (SUCCEEDED(pCifComponent_t->GetDependency(uiIndex, szID, countof(szID), &tchType, NULL, NULL)))
    {
        if ((pComp->iCompType != COMP_OPTIONAL) ||
            (StrCmpNI(szID, TEXT("BASEIE40"), 8) == 0))
        {
            uiIndex++;
            continue;
        }

        pCompTemp = FindComp(szID, FALSE);

        if (pCompTemp)
        {
            int i;
            BOOL fSet = FALSE;

            if (pCompTemp->fIEDependency)
            {
                uiIndex++;
                continue;
            }

            pCompTemp->fIEDependency = TRUE;

            for (i=0; (i < 10) && pCompTemp->paCompRevDeps[i]; i++)
            {
                if (pCompTemp->paCompRevDeps[i] == pComp)
                    fSet = TRUE;
            }

            if (!fSet && i < 10)
                pCompTemp->paCompRevDeps[i] = pComp;

        }
        if (SUCCEEDED(g_lpCifFileNew->FindComponent(szID, &pCifCompNew)))
        {
            CCifComponent_t * pCifCompNew_t =
                new CCifComponent_t((ICifRWComponent *)pCifCompNew);

            SetCompRevDependList(pComp, pCifCompNew_t);
            delete pCifCompNew_t;
        }
        uiIndex++;
    }
}

void BuildReverseDependencyList(IEnumCifComponents * pEnumCifComponents)
{
    PCOMPONENT pComp;
    ICifComponent * pCifComponent;
    TCHAR szID[128];

    while (pEnumCifComponents->Next(&pCifComponent) == S_OK)
    {
        CCifComponent_t * pCifComponent_t =
            new CCifComponent_t((ICifRWComponent *)pCifComponent);

        pCifComponent_t->GetID(szID, countof(szID));
        pComp = FindComp(szID, FALSE);
        if (pComp)
        {
            PCOMPONENT pCompTemp;

            for (pCompTemp = g_paComp; *pCompTemp->szSection; pCompTemp++)
                pCompTemp->fIEDependency = FALSE;
            pComp->fIEDependency = TRUE;
            SetCompRevDependList(pComp, pCifComponent_t);
        }
        delete pCifComponent_t;
    }
}

void GetUpdateSite() {
    TCHAR             szLang[8], szURL[MAX_URL], szMsg[MAX_PATH];
    CHAR              szSiteDataA[MAX_PATH];
    int               i, j;
    DWORD             dwErr;
    IDownloadSiteMgr* pSiteMgr = NULL;
    IDownloadSite*    pISite   = NULL;
    DOWNLOADSITE*     pSite;

    LoadString(g_rvInfo.hInst, IDS_AVSUPDATEINITFAIL, szMsg, countof(szMsg));
          
    for (j=0; s_szSiteData[j]; j++);
    for (i=j; (i>0) && ('/' != s_szSiteData[i]); i--);
    StrNCpy(g_szUpdateData, (LPCWSTR) s_szSiteData, i+1); 
          
    StrCat(g_szUpdateData, TEXT("/IEUPDATE.DAT"));    

    dwErr = CoCreateInstance(CLSID_DownloadSiteMgr, NULL, CLSCTX_INPROC_SERVER,
                      IID_IDownloadSiteMgr, (void **) &pSiteMgr);

    do {
        dwErr = pSiteMgr->Initialize(T2Abux(g_szUpdateData, szSiteDataA),  NULL);
    }
    while ((dwErr != NOERROR) && (MessageBox(g_hDlg, szMsg, g_szTitle, MB_RETRYCANCEL) == IDRETRY));

    for (i=0; i<NUMSITES; i++) {
        pSiteMgr->EnumSites(i, &pISite);
        if (!pISite) break;
        pISite->GetData(&pSite);
        A2Tbux(pSite->pszLang, szLang);
        if (0 == StrCmpI(szLang, g_szActLang)) {
            A2Tbux(pSite->pszUrl, szURL);
            StrCpy(g_szUpdateURL, szURL);
            break;
        }
    }
    if (pSiteMgr)
        pSiteMgr->Release();
    if (pISite)
        pISite->Release();
}

DWORD InitOptComponents32(LPVOID)
{
    HWND hDlg = g_hWizard;
    int iItem = 0;
    HWND hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
    LV_ITEM lvItemMessage;
    TCHAR szBuf[8];
    DWORD dwType;
    HRESULT hr;
    PCOMPONENT pComp;
    PCOMP_VERSION pCompVer;
    BOOL fNeedCore = TRUE;
    TCHAR szCifName[32];
    TCHAR * lpszProgressMsg;

    CoInitialize(NULL);
    lpszProgressMsg=(TCHAR *) LocalAlloc(LPTR, MAX_PATH * sizeof(TCHAR));

    ResetEvent(g_hCifEvent);
    NeedToSetMSTrustKey();
    WriteMSTrustKey(TRUE);      // Mark MS as a trusted provider

	if(!g_fOCW)
    {
        CreateDirectory( g_szIEAKProg, NULL );
    }
    StrCpy(szCifName, TEXT("IESetup.CIF"));
    PathCombine(g_szCif, g_szBuildRoot, TEXT("INS"));
    PathAppend(g_szCif, GetOutputPlatformDir());
    PathAppend(g_szCif, g_szLanguage);
    PathAppend(g_szCif, szCifName);

    s_dwTotalSize = 0;
    ListView_DeleteAllItems(hCompList);
    ListView_DeleteColumn(hCompList, 1);
    ListView_DeleteColumn(hCompList, 0);
    s_fNoCore = FALSE;

    InitAVSListView(hCompList);      //----- assign image list and create columns
 
    LoadString(g_rvInfo.hInst,IDS_COMPINITDOWNLOAD,lpszProgressMsg,MAX_PATH);

    ZeroMemory(&lvItemMessage, sizeof(lvItemMessage));
    lvItemMessage.mask = LVIF_TEXT | LVIF_IMAGE;
    lvItemMessage.iItem = iItem;
    lvItemMessage.pszText = lpszProgressMsg;
    lvItemMessage.iImage = YELLOW;
    ListView_InsertItem(hCompList, &lvItemMessage);

    StrCpy(szBuf, g_szLanguage + 1);
    szBuf[lstrlen(szBuf) - 1] = 0;
    StrCpy(s_szCifCabURL, g_szBaseURL);
    StrCat(s_szCifCabURL, TEXT("/IECIF.CAB"));
    StrCpy(g_szCifVer, g_szIEAKProg);
    PathAppend(g_szCifVer, TEXT("IEsetup.cif"));
    StrCpy(s_szCifNew, g_szIEAKProg);
    PathAppend(s_szCifNew, TEXT("new"));
    CreateDirectory( s_szCifNew, NULL );
    PathAppend(s_szCifNew, TEXT("IEsetup.cif"));

    if ((!s_fNoNet)&&(!g_fLocalMode))
    {
        BOOL fIgnore = FALSE;
        TCHAR szCifCabDest[MAX_PATH * 4];  //part of fix for bug 13454--trap on long file path.  Rest of fix is not to allow ridiculous paths.  

        if (g_fBatch2)
        {
            //batch2 mode we don't download the cab, we copy the cif.
            PathCombine(s_szCifCabURL, g_szBaseURL, TEXT("INS"));
            PathAppend(s_szCifCabURL, GetOutputPlatformDir());
            PathAppend(s_szCifCabURL, g_szLanguage);
            PathAppend(s_szCifCabURL, szCifName);
            PathCombine(szCifCabDest, g_szIEAKProg, TEXT("new\\IEsetup.cif"));
            if (CopyFile(s_szCifCabURL, szCifCabDest, FALSE))
                hr = NOERROR;
            else
                hr = -1;
        }
        else
        {
            if (!PathCombine(szCifCabDest, g_szIEAKProg, TEXT("new\\IECIF.CAB")))
            {
                //error in path combine, probably due to overly long path on win98
                //user can't continue

                ErrorMessageBox(hDlg, IDS_ERR_PATH);
                ListView_DeleteItem(hCompList, iItem);
                LocalFree(lpszProgressMsg);
                SetEvent(g_hCifEvent);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                PostMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
                g_fOptCompInit = TRUE;
                s_fNoCore = TRUE;
                CoUninitialize();
                return(0);
            }
            hr = DownloadCab(hDlg, s_szCifCabURL, szCifCabDest, NULL, 0, fIgnore);
            if (hr == NOERROR)
            {
                TCHAR szCifCabFilesDest[MAX_PATH * 4];

                PathCombine(szCifCabFilesDest, g_szIEAKProg, TEXT("new"));
                hr = ExtractFilesWrap(szCifCabDest, szCifCabFilesDest, 0, NULL, NULL, 0);
            }
        }

        if (hr != NOERROR)
        {
            if (!PathFileExists(g_szCifVer))
            {
                ListView_DeleteItem(hCompList, iItem);
                LocalFree(lpszProgressMsg);
                SetEvent(g_hCifEvent);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                PostMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
                g_fOptCompInit = TRUE;
                s_fNoCore = TRUE;
                CoUninitialize();
                return(0);
            }
            s_fNoNet = TRUE;
            g_fLocalMode = TRUE;
        }
    }
    if (!PathFileExists(g_szCifVer))
    {
        TCHAR szVerCifCab[MAX_PATH* 4];

        PathCombine(szVerCifCab, g_szIEAKProg, TEXT("IECIF.CAB"));

        // if there is an iecif.cab in the source dir then extract the cif and assume it's valid

        if (!PathFileExists(szVerCifCab) ||
            (ExtractFilesWrap(szVerCifCab, g_szIEAKProg, 0, NULL, NULL, 0) != NOERROR))
        {
            TCHAR szTemp[MAX_PATH* 4];
            WIN32_FIND_DATA fd;
            HANDLE hFind;

            PathCombine(szTemp, g_szIEAKProg, TEXT("*.cab"));

            if ((hFind = FindFirstFile(szTemp, &fd)) != INVALID_HANDLE_VALUE)
            {
                // delete all files in download directory if no versioning cif found, this is for
                // overinstalls

                LoadString(g_rvInfo.hInst, IDS_OLD_CABS, szTemp, countof(szTemp));

                FindClose(hFind);

                if (MessageBox(hDlg, szTemp, g_szTitle, MB_YESNO) == IDYES)
                {
                    PathRemovePath(g_szIEAKProg, ADN_DONT_DEL_SUBDIRS);
                }
                else
                {
                    ListView_DeleteItem(hCompList, iItem);
                    LocalFree(lpszProgressMsg);
                    SetEvent(g_hCifEvent);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                    PostMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
                    g_fOptCompInit = g_fLocalMode = TRUE;
                    s_fNoCore = TRUE;
                    CoUninitialize();
                    return(0);
                }
            }
            CopyFile(s_szCifNew, g_szCifVer, FALSE);
        }
    }
    if (!PathFileExists(g_szCif))
        CopyFile(g_szCifVer, g_szCif, FALSE);

    if (s_fNoNet||g_fLocalMode)
        StrCpy(s_szCifNew, g_szCifVer);

    ListView_DeleteItem(hCompList, iItem);

    LoadString(g_rvInfo.hInst,IDS_COMPINITPROCESSING,lpszProgressMsg,MAX_PATH);
    lvItemMessage.pszText = lpszProgressMsg;
    ListView_InsertItem(hCompList, &lvItemMessage);

    // create our cif objects

    if (g_lpCifFileNew)
    {
        delete g_lpCifFileNew;
        g_lpCifFileNew = NULL;
    }
    hr = GetICifFileFromFile_t(&g_lpCifFileNew, s_szCifNew);

    if (SUCCEEDED(hr))
    {
        if (g_lpCifRWFile)
        {
            delete g_lpCifRWFile;
            g_lpCifRWFile = NULL;
        }
        hr = GetICifRWFileFromFile_t(&g_lpCifRWFile, g_szCif);
        if (SUCCEEDED(hr))
        {
            if (g_lpCifRWFileVer)
            {
                delete g_lpCifRWFileVer;
                g_lpCifRWFileVer = NULL;
            }
            hr = GetICifRWFileFromFile_t(&g_lpCifRWFileVer, g_szCifVer);
        }
    }

    SetEvent(g_hCifEvent);

    // wait for the opt cab download attempt so we can block if there were problems

    while (MsgWaitForMultipleObjects(1, &g_hProcessInfEvent, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
    {
        MSG msg;

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    if (!PathFileExists(g_szMastInf)) // if iesetup.inf doesn't exist in the opt dir, then it
    {                                 // means the opt cab was not downloaded/extracted successfully
        // we should not let the user continue
        ErrorMessageBox(hDlg, IDS_OPTCAB_ERROR);
        ListView_DeleteItem(hCompList, iItem);
        LocalFree(lpszProgressMsg);
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
        PostMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
        g_fOptCompInit = g_fLocalMode = TRUE;
        s_fNoCore = TRUE;
        CoUninitialize();
        return(0);
    }

    ListView_DeleteItem(hCompList, iItem);

    if (SUCCEEDED(hr))
    {
        IEnumCifComponents *pEnumCifComponents = NULL;
        ICifRWComponent * pCifRWComponent;
        ICifComponent *pCifComponent = NULL;

        if (SUCCEEDED(hr))
        {
            // currently not showing alpha comps

            hr = g_lpCifFileNew->EnumComponents(&pEnumCifComponents,
                PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_MILLEN, NULL);

            if (0 != g_uiNumCabs)
                g_uiNumCabs = 0;
            
            while (pEnumCifComponents->Next(&pCifComponent) == S_OK)
                g_uiNumCabs++;

            //bug 17727: we need to allocate enough memory to hold the updated components as well, which is
            //why there is so much extra

            pComp=g_paComp=(PCOMPONENT) LocalAlloc(LPTR, ((g_uiNumCabs*3) + 100) * sizeof(COMPONENT));  
            pCompVer=g_rgCompVer=(PCOMP_VERSION) LocalAlloc(LPTR, ((g_uiNumCabs*3) + 100) * sizeof(COMP_VERSION));

            iItem=0; //reset iItem for filling in the list box

            pEnumCifComponents->Reset();

            while(pEnumCifComponents->Next(&pCifComponent) == S_OK)
            {
                ICifComponent * pCifComponentTemp;
                TCHAR szVerNew[32];
                TCHAR szPatchVerNew[32];
                TCHAR szIEAKVer[32] = TEXT("");
                TCHAR szIEAKVerNew[32];
                TCHAR szCustData[MAX_PATH];
                TCHAR szID[128];
                TCHAR szMode[MAX_PATH];
                UINT uiIndex;
                DWORD dwVer, dwBuild, dwPlatform;
                CCifComponent_t * pCifComponent_t =
                    new CCifComponent_t((ICifRWComponent *)pCifComponent);

                // ignore components that aren't in a group

                if (FAILED(pCifComponent_t->GetGroup(szID, countof(szID))))
                {
                    delete pCifComponent_t;
                    g_uiNumCabs--;
                    continue;
                }

                pComp->fVisible = (pCifComponent_t->IsUIVisible() == S_FALSE) ? FALSE : TRUE;

                dwPlatform = pCifComponent_t->GetPlatform();

                if (dwPlatform & PLATFORM_WIN98)
                {
                    if (dwPlatform & PLATFORM_NT4)
                        pComp->iPlatform = PLAT_I386;
                    else
                        pComp->iPlatform = PLAT_W98;
                }
                else
                    pComp->iPlatform = PLAT_NTx86;

                pCifComponent_t->GetID(szID, countof(szID));

                StrCpy(pCompVer->szID, szID);

                // do not read in the branding.cab entry for microsoft.com

                if (StrCmpI(szID, TEXT("BRANDING.CAB")) == 0)
                {
                    ZeroMemory(pComp, sizeof(COMPONENT));
                    delete pCifComponent_t;
                    g_uiNumCabs--;
                    continue;
                }


                // do not read in exluded components in all modes(128Update) or
                // ISP excluded components(IE4SHELL) or corp excluded comps

                if (((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKExclude"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1'))) ||
                    (!g_fIntranet && (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKISPExclude"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1'))) ||
                    (g_fIntranet && (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKCorpExclude"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1'))))
                {
                    ZeroMemory(pComp, sizeof(COMPONENT));
                    delete pCifComponent_t;
                    continue;
                }

                // add on only components or IEAK show only components

                if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("AddOnOnly"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1')))
                {
                    pComp->fAddOnOnly = TRUE;
                    pComp->fVisible = TRUE;
                }

                if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKVisible"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1')))
                    pComp->fVisible = TRUE;


                pCifComponent_t->GetCustomData(TEXT("IEAKVersion"), szIEAKVerNew, countof(szIEAKVerNew));

                if (SUCCEEDED(g_lpCifRWFileVer->FindComponent(szID, &pCifComponentTemp)))
                {
                    CCifComponent_t * pCifComponentTemp_t =
                        new CCifComponent_t((ICifRWComponent *)pCifComponentTemp);

                    pCifComponentTemp_t->GetVersion(&dwVer, &dwBuild);
                    ConvertDwordsToVersionStr(pComp->szVersion, dwVer, dwBuild);
                    pCifComponentTemp_t->GetCustomData(TEXT("IEAKVersion"), szIEAKVer, countof(szIEAKVer));
                }
                pCifComponent_t->GetVersion(&dwVer, &dwBuild);
                ConvertDwordsToVersionStr(szVerNew, dwVer, dwBuild);

                StrCpy(pCompVer->szVersion, szVerNew);
               
                uiIndex = 0;

                szMode[0] = TEXT('\0');
                if (SUCCEEDED(g_lpCifRWFile->FindComponent(szID, &pCifComponentTemp)))
                {
                    CCifComponent_t * pCifComponentTemp_t =
                        new CCifComponent_t((ICifRWComponent *)pCifComponentTemp);
                    while (SUCCEEDED(pCifComponentTemp_t->GetMode(uiIndex, szMode, countof(szMode))))
                    {
                        pComp->szModes[uiIndex] = szMode[0];
                        pComp->afInstall[szMode[0] - TEXT('0')] = TRUE;
                        uiIndex++;
                    }
                    delete pCifComponentTemp_t;
                }
                else
                {
                    while (SUCCEEDED(pCifComponent_t->GetMode(uiIndex, szMode, countof(szMode))))
                    {
                        pComp->szModes[uiIndex] = szMode[0];
                        pComp->afInstall[szMode[0] - TEXT('0')] = TRUE;
                        uiIndex++;
                    }
                }

                pComp->szModes[uiIndex] = TEXT('\0');

                if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKCore"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1')))
                {
                    pComp->iCompType = COMP_CORE;
                    pComp->fVisible = FALSE;
                }

                // pick up special core comps for OCW

                if (g_fOCW && (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKOCWCore"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1')))
                {
                    pComp->iCompType = COMP_CORE;
                    pComp->fVisible = FALSE;
                }

                if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKServer"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1')))
                    pComp->iCompType = COMP_SERVER;

                // IEAK should ignore these components since they point to the same cabs as
                // another section

                if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKAVSIgnore"), szCustData, countof(szCustData))))
                    && (szCustData[0] == TEXT('1')))
                {
                    pComp->fAVSDupe = TRUE;
                    pComp->fVisible = FALSE;
                }

                // pick up components which point to the same cabs as this section

                if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKAVSLinks"), szCustData, countof(szCustData))))
                    && ISNONNULL(szCustData))
                {
                    StrRemoveWhitespace(szCustData);
                    if ((pComp->pszAVSDupeSections =
                        (LPTSTR)CoTaskMemAlloc((StrLen(szCustData)+1) * sizeof(TCHAR))) != NULL)
                        StrCpy(pComp->pszAVSDupeSections, szCustData);
                }
                else
                    pComp->pszAVSDupeSections = NULL;

                StrCpy(pComp->szSection, szID);

                if (StrCmpI(szID, TEXT("MAILNEWS")) == 0)
                    g_pMNComp = pComp;

                pCifComponent_t->GetGUID(pComp->szGUID, countof(pComp->szGUID));
                pCifComponent_t->GetDescription(pComp->szDisplayName, countof(pComp->szDisplayName));
                pCifComponent_t->GetUrl(0, pComp->szUrl, countof(pComp->szUrl), &dwType);
                if (!(dwType & URLF_RELATIVEURL))
                {
                    LPTSTR pUrl;
                    TCHAR szTempUrl[MAX_PATH];

                    pUrl = StrRChr(pComp->szUrl, NULL, TEXT('/'));
                    if (pUrl)
                        pUrl++;
                    else
                        pUrl = pComp->szUrl;

                    StrCpy(szTempUrl, pUrl);
                    StrCpy(pComp->szUrl, szTempUrl);
                }

                pComp->dwSize = pCifComponent_t->GetDownloadSize();

                if (!pComp->fAVSDupe)
                    s_dwTotalSize += pComp->dwSize;
                // take out patch processing for now

                /*
                // look for a patch entry, special case out patches from 4.0 to 4.01

                if (SUCCEEDED(pCifComponent_t->GetPatchID(pComp->piPatchInfo.szSection, countof(pComp->piPatchInfo.szSection))))
                {
                    CHAR szPatchSect[2048];
                    BOOL fBadPatch = FALSE;

                    if (GetPrivateProfileSection("Patches", szPatchSect, countof(szPatchSect), g_szDefInf))
                    {
                        LPSTR pSectID;

                        for (pSectID = szPatchSect; *pSectID; pSectID += (lstrlen(pSectID)+1))
                        {
                            if (StrCmpI(pSectID, pComp->piPatchInfo.szSection) == 0)
                            {
                                fBadPatch = TRUE;
                                break;
                            }
                        }
                    }

                    if (fBadPatch)
                    {
                        WritePrivateProfileString(pComp->piPatchInfo.szSection, NULL, NULL, g_szCif);
                        WritePrivateProfileString(pComp->piPatchInfo.szSection, NULL, NULL, s_szCifNew);
                        WritePrivateProfileString(szID, "PatchID", NULL, g_szCif);
                        WritePrivateProfileString(szID, "PatchID", NULL, s_szCifNew);
                        *pComp->piPatchInfo.szSection = '\0';
                    }
                    else
                    {
                        if (SUCCEEDED(g_lpCifFile->FindComponent(pComp->piPatchInfo.szSection, &pCifComponentTemp)))
                        {
                            pCifComponentTemp->GetVersion(&dwVer, &dwBuild);
                            ConvertDwordsToVersionStr(pComp->piPatchInfo.szVersion, dwVer, dwBuild);
                        }

                        g_lpCifFileNew->FindComponent(pComp->piPatchInfo.szSection, &pCifComponentTemp);
                        pCifComponentTemp->GetVersion(&dwVer, &dwBuild);
                        ConvertDwordsToVersionStr(szPatchVerNew, dwVer, dwBuild);
                        pComp->piPatchInfo.dwSize = pCifComponentTemp->GetDownloadSize();
                    }
                }
               */

                // Note: we are depending on the section name of core IE4 here.
                if ((fNeedCore && (StrCmpI(szID, BASEWIN32) == 0))
                    || ((pComp->iCompType == COMP_OPTIONAL) && (pComp->iPlatform <= PLAT_W98)
                    && pComp->fVisible))
                {
                    LV_ITEM lvItem;
                    LVFINDINFO lvFind;
                    TCHAR szLocalPath[MAX_PATH];
                    if (StrCmpI(szID, BASEWIN32) == 0)
                    {
                        fNeedCore = FALSE;
                        StrCpy(g_szJobVersion, pComp->szVersion);
                    }
                    ZeroMemory(&lvItem, sizeof(lvItem));
                    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;

                    // BUGBUG: <oliverl> we should adjust iItem here to make sure core browser
                    // is always on top

                    lvItem.iItem = pComp->iList = iItem++;
                    lvItem.pszText = pComp->szDisplayName;
                    StrCpy(szLocalPath, g_szIEAKProg);
                    StrCat(szLocalPath, pComp->szUrl);

                    if (!PathFileExists(szLocalPath))
                    {
                        g_lpCifRWFile->CreateComponent(szID, &pCifRWComponent);
                        pCifRWComponent->SetGroup(NULL);
                        lvItem.iImage = pComp->iImage = RED;
                    }
                    else
                    {
                        CCifRWComponent_t * pCifRWComponent_t;

                        g_lpCifFileNew->FindComponent(szID, &pCifComponent);
                        pCifComponent_t->GetGroup(szLocalPath, countof(szLocalPath));
                        g_lpCifRWFile->CreateComponent(szID, &pCifRWComponent);
                        pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
                        pCifRWComponent_t->SetGroup(szLocalPath);
                        delete pCifRWComponent_t;
                        if (s_fNoNet || g_fLocalMode || (CheckVer(pComp->szVersion, szVerNew) < 0)
                            || (CheckVer(szIEAKVer, szIEAKVerNew) < 0)
                            || ((ISNONNULL(pComp->piPatchInfo.szSection))
                            && (CheckVer(pComp->piPatchInfo.szVersion, szPatchVerNew) < 0)))
                            lvItem.iImage = pComp->iImage = YELLOW;
                        else lvItem.iImage = pComp->iImage = GREEN;
                    }

                    ZeroMemory(&lvFind, sizeof(lvFind));
                    lvFind.flags = LVFI_STRING;
                    lvFind.psz = pComp->szDisplayName;

                    if (ListView_FindItem(hCompList, -1, &lvFind) == -1)
                    {
                        ListView_InsertItem(hCompList, &lvItem);
                        if ((pComp->iCompType == COMP_OPTIONAL) && (pComp->iImage != RED))
                            ListView_SetItemText(hCompList, pComp->iList, 1, pComp->szVersion);
                    }
                }
                else
                {
                    TCHAR szLocalPath[MAX_PATH];

                    PathCombine(szLocalPath, g_szIEAKProg, pComp->szUrl);
                    if (GetFileAttributes(szLocalPath) == 0xFFFFFFFF)
                    {
                        g_lpCifRWFile->CreateComponent(szID, &pCifRWComponent);
                        pCifRWComponent->SetGroup(NULL);
                        pComp->iImage = RED;
                    }
                    else
                    {
                        CCifRWComponent_t * pCifRWComponent_t;

                        g_lpCifFileNew->FindComponent(szID, &pCifComponent);
                        pCifComponent_t->GetGroup(szLocalPath, countof(szLocalPath));
                        g_lpCifRWFile->CreateComponent(szID, &pCifRWComponent);
                        pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
                        pCifRWComponent_t->SetGroup(szLocalPath);
                        delete pCifRWComponent_t;
                        if (s_fNoNet || g_fLocalMode || (CheckVer(pComp->szVersion, szVerNew) < 0)
                            || (CheckVer(szIEAKVer, szIEAKVerNew) < 0)
                            || ((ISNONNULL(pComp->piPatchInfo.szSection))
                            && (CheckVer(pComp->piPatchInfo.szVersion, szPatchVerNew) < 0)))
                            pComp->iImage = YELLOW;
                        else pComp->iImage = GREEN;
                    }
                }

                pComp++;
                pCompVer++;
                delete pCifComponent_t;
            }

            pEnumCifComponents->Reset();
            BuildReverseDependencyList(pEnumCifComponents);
            pEnumCifComponents->Release();

            for (pComp = g_paComp; (pComp && ISNONNULL(pComp->szSection)); pComp++)
            {
                if ((pComp->iCompType != COMP_OPTIONAL) &&
                    (pComp->iImage == RED))
                    s_fNoCore = TRUE;
            }

            if (s_fNoCore)
            {
                LV_ITEM lvItem;

                lvItem.mask = LVIF_IMAGE;
                lvItem.iItem = 0;
                lvItem.iImage = RED;
                ListView_SetItem(hCompList, &lvItem);

                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
            }
            else
            {
                pComp = FindComp(NULL, TRUE);

                if (pComp)
                    ListView_SetItemText(hCompList, pComp->iList, 1, pComp->szVersion);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            }
        }
    }
    
    ProcessUpdateIcons(hDlg);

    if (FAILED(hr))
    {
        s_fNoCore = TRUE;
        g_fLocalMode = TRUE;
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
    }
    else
    {
        IEnumCifModes * pEnumCifModes;
        int i, j;

        // initialize modes

        // currently not getting alpha modes

        if (SUCCEEDED(g_lpCifRWFile->EnumModes(&pEnumCifModes,
            PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_MILLEN, NULL)))
        {
            ICifMode * pCifMode;
            TCHAR szModeID[64];

            i = 0;
            while (SUCCEEDED(pEnumCifModes->Next(&pCifMode)))
            {
                CCifMode_t * pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);

                pCifMode_t->GetID(szModeID, countof(szModeID));
                delete pCifMode_t;
                g_szAllModes[i] = szModeID[0];
                i++;
            }
            pEnumCifModes->Release();
        }

        g_nModes = lstrlen(g_szAllModes);

        for (pComp = g_paComp; ; pComp++ )
        {
            if (*pComp->szSection == '\0') break;

            if (pComp->iCompType == COMP_CORE)
            {
                for (i = 0; i < g_nModes ; i++ )
                {
                    pComp->afInstall[i] = TRUE;
                }
            }
            else
            {
                for (i = 0; i < g_nModes; i++)
                {
                    for (j=0; j < lstrlen(pComp->szModes); j++)
                    {
                        if (pComp->szModes[j] == g_szAllModes[i])
                            pComp->afInstall[i] = TRUE;
                    }
                }

                // for invisible comps, set them to the same modes as the visible components
                // that depend on them

                if (!pComp->fVisible)
                {
                    for (i = 0; pComp->paCompRevDeps[i] && (i < 10); i++)
                    {
                        for (j=0; j < MAX_INSTALL_OPTS; j++)
                        {
                            if (pComp->paCompRevDeps[i]->afInstall[j])
                                pComp->afInstall[j] = TRUE;
                        }
                    }
                }
            }
        }

        InitCustComponents(NULL);
    }

    g_fOptCompInit = TRUE;

    if (!g_fLocalMode)
    {
        EnableDlgItem2(hDlg, IDC_DOWNLOAD, AnyCompSelected(hDlg));
        EnableDlgItem(hDlg, IDC_DOWNLOADALL);
        EnableDlgItem(hDlg, IDC_UPDATE);
    }

    LocalFree(lpszProgressMsg);
    PostMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
    CoUninitialize();
    return(0);
}

BOOL AnySelection(PCOMPONENT pComp)
{
    int i;

    if (!pComp)
        return FALSE;

    for (i = 0; i < 10 ; i++ )
    {
        if (pComp->afInstall[i]) return(TRUE);

    }
    return(FALSE);

}

DWORD GetCompDownloadSize(PCOMPONENT pComp)
{
    PCOMPONENT pCompDep;
    DWORD dwSize = 0;
    ICifComponent * pCifComponent;
    TCHAR szID[128];
    TCHAR tchType;
    UINT uiIndex;

    if (pComp->fIEDependency || pComp->fAVSDupe)
        return 0;

    pComp->fIEDependency = TRUE;

    if (SUCCEEDED(g_lpCifFileNew->FindComponent(pComp->szSection, &pCifComponent)))
    {
        CCifComponent_t * pCifComponent_t =
            new CCifComponent_t((ICifRWComponent *)pCifComponent);

        uiIndex = 0;
        while (SUCCEEDED(pCifComponent_t->GetDependency(uiIndex, szID, countof(szID), &tchType, NULL, NULL)))
        {
            if (StrCmpNI(szID, TEXT("BASEIE40"), 8) != 0)
            {
                if ((pCompDep = FindComp(szID, FALSE)) != NULL)
                    dwSize += GetCompDownloadSize(pCompDep);
            }
            uiIndex++;
        }
        delete pCifComponent_t;
    }

    dwSize += pComp->dwSize;
    return dwSize;
}

void GetDownloadSize(HWND hCompList, HWND hStatusField)
{
    PCOMPONENT pComp, pSearchComp;
    LV_ITEM lvItem;
    DWORD dwSizeNeeded = 0;
    TCHAR szSizeNeeded[32];
    BOOL fCore = FALSE;

    for (pComp = g_paComp; *pComp->szSection; pComp++)
    {
        ZeroMemory(&lvItem,sizeof(lvItem));
        lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
        lvItem.stateMask = LVIS_SELECTED;
        lvItem.iItem = pComp->iList;
        ListView_GetItem(hCompList, &lvItem);
        if (((lvItem.state & LVIS_SELECTED) == 0) || (pComp->fIEDependency))
            continue;

        if (!pComp->fVisible || pComp->fAVSDupe)
            continue;

        if (pComp->iCompType != COMP_OPTIONAL)
        {
            fCore = TRUE;
            continue;
        }

        // REVIEW: <oliverl> we need this check so we don't count NT comps twice
        if (pComp->iList == 0)
            continue;


        dwSizeNeeded += GetCompDownloadSize(pComp);

        // check other platforms

        for (pSearchComp = g_paComp; *pSearchComp->szSection; pSearchComp++)
        {
            if ((pComp != pSearchComp) &&
                (StrCmpI(pComp->szDisplayName, pSearchComp->szDisplayName) == 0))
                dwSizeNeeded += GetCompDownloadSize(pSearchComp);
        }
    }

    if (fCore)
    {
        for (pComp = g_paComp; *pComp->szSection; pComp++)
        {
            if (!pComp->fIEDependency && !pComp->fAVSDupe && (pComp->iCompType != COMP_OPTIONAL))
                dwSizeNeeded += pComp->dwSize;
        }

        // REVIEW: <oliverl> fudge factor for rounding

        dwSizeNeeded += 15;
    }

    for (pComp = g_paComp; *pComp->szSection; pComp++)
        pComp->fIEDependency = FALSE;

    wnsprintf(szSizeNeeded, countof(szSizeNeeded), TEXT("%lu KB"), dwSizeNeeded);
    InsertCommas(szSizeNeeded);
    SetWindowText(hStatusField, szSizeNeeded);
}

//
//  FUNCTION: OptionalDownload(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "OptionalDownload" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//

BOOL APIENTRY OptionalDownload(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    static      TCHAR s_szTotalSize[32];
    TCHAR       szWrk[MAX_PATH];
    TCHAR       szFreeSpace[64];
    DWORD       dwFreeSpace;
    BOOL        fSel, fSizeChange = FALSE;
    static      HCURSOR hOldCur = NULL;
    static      s_fInit = FALSE;
    PCOMPONENT* ppCompUpdateList = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
            InitSysFont( hDlg, IDC_COMPLIST);
            g_hWizard = hDlg;
            break;

        case WM_SETCURSOR:
            if (hOldCur == NULL)
                hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
            else
            {
                if (!s_fInit)
                    SetCursor(LoadCursor(NULL, IDC_WAIT));
            }
            break;

        case IDM_INITIALIZE:
            s_fInit = TRUE;
            // REVIEW: <oliverl> fudge factor for rounding

            s_dwTotalSize += 15;

            wnsprintf(s_szTotalSize, countof(s_szTotalSize), TEXT("%lu KB"), s_dwTotalSize);
            InsertCommas(s_szTotalSize);
            SetDlgItemText(hDlg, IDC_DISKSPACENEEDED, s_szTotalSize);
            StrCpy(szWrk, g_szIEAKProg);
            dwFreeSpace = GetRootFree(szWrk);
            wnsprintf(szFreeSpace, countof(szFreeSpace), TEXT("%lu KB"), dwFreeSpace);
            InsertCommas(szFreeSpace);
            SetDlgItemText(hDlg, IDC_DISKSPACE, szFreeSpace);
            SetCursor(hOldCur);
            while (MsgWaitForMultipleObjects(1, &g_hAVSThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
            {
                MSG msg;

                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }

            if (!g_fLocalMode)
            {
                s_fComponent = FALSE;
                UpdateIEAK(hDlg);
                if (g_fLocalMode)
                {
                    DisableDlgItem(hDlg, IDC_DOWNLOAD);
                    DisableDlgItem(hDlg, IDC_DOWNLOADALL);
                }
            }
            break;
            

        case IDM_BATCHADVANCE:
            EnableDlgItem2(hDlg, IDC_DOWNLOAD, AnyCompSelected(hDlg));
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    TCHAR szTitle[MAX_PATH];

                    case IDC_DOWNLOAD:
                        s_fNoToAllSynch = FALSE;
                        ProcessDownload(hDlg, FALSE);
                        if (g_fFailedComp)
                        {
                            LoadString( g_rvInfo.hInst, IDS_DOWNLOADERR, szTitle, MAX_PATH );
                            wnsprintf(g_szFailedCompsBox, countof(g_szFailedCompsBox), g_szFailedCompsMsg, g_szFailedComps);
                            MessageBox(hDlg, g_szFailedCompsBox, szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
                            g_szFailedComps[0] = TEXT('\0');
                        }
                        break;
                    case IDC_DOWNLOADALL:
                        ProcessDownload(hDlg, TRUE);
                        if (g_fFailedComp)
                        {
                            LoadString( g_rvInfo.hInst, IDS_DOWNLOADERR, szTitle, MAX_PATH );
                            wnsprintf(g_szFailedCompsBox, countof(g_szFailedCompsBox), g_szFailedCompsMsg, g_szFailedComps);
                            MessageBox(hDlg, g_szFailedCompsBox, szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
                            g_szFailedComps[0] = TEXT('\0');
                        }
                        break;
                    case IDC_UPDATE:
                        DisableDlgItem(hDlg, IDC_UPDATE);
                        g_hProgress = NULL;
                                                
                        PCOMPONENT *pCompList,
                                   *pCompEnum;
                        HRESULT    hr;
                        INT_PTR    iResult;

                        pCompList = NULL;
                        iResult   = DialogBoxParam(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_OPTUPDATE), hDlg,
                                                   (DLGPROC)UpdateDlgProc, (LPARAM)&pCompList);
                        if (IDOK == iResult) {
                            ASSERT(NULL != pCompList);
                            if (IsCheyenneSoftwareRunning(hDlg))
                                ErrDlgProc(hDlg, IDC_ERRDLABORT, NULL, 
                                           LPARAM(TEXT("Please turn of all Cheyenne Software")));
                            
                            s_hStat = CreateDialog( g_rvInfo.hInst,  MAKEINTRESOURCE(IDD_DOWNLOAD), NULL,
                                                   (DLGPROC) DownloadStatusDlgProc );
                            ShowWindow( s_hStat, SW_SHOWNORMAL );

                            HWND   hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
                            LVITEM lvi;

                            for (pCompEnum = pCompList; NULL != pCompEnum && NULL != (*pCompEnum); pCompEnum++) {
                                hr = DownloadUpdate(*pCompEnum);
                                ZeroMemory(&lvi, sizeof(lvi));                                    
                                
                                if (DONT_SHOW_UPDATES != hr)
                                    if (BLUE == (*pCompEnum)->iImage)
                                        UpdateBlueIcon(hCompList, *pCompEnum);
                                    else 
                                        UpdateBrownIcon(hCompList, *pCompEnum);
                                
                                LocalFree(*pCompEnum);
                            }
                            DestroyWindow(s_hStat);
                        }
                         
                        EnableDlgItem(hDlg, IDC_UPDATE);
                        break;
                }

                ShowWindow(GetDlgItem(hDlg, IDC_DISKSPACETEXT), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_DISKSPACETEXT2), SW_HIDE);
                SetDlgItemText(hDlg, IDC_DISKSPACENEEDED, s_szTotalSize);
                StrCpy(szWrk, g_szIEAKProg);
                dwFreeSpace = GetRootFree(szWrk);
                wnsprintf(szFreeSpace, countof(szFreeSpace), TEXT("%lu KB"), dwFreeSpace);
                InsertCommas(szFreeSpace);
                SetDlgItemText(hDlg, IDC_DISKSPACE, szFreeSpace);

                if (!g_fLocalMode)  EnableDlgItem2(hDlg, IDC_DOWNLOAD, AnyCompSelected(hDlg));
                if (!s_fNoCore)
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    //processing that was formerly in the downloads page has to go here
                    g_iDownloadState = DOWN_STATE_SAVE_URL;
                    SetEvent(g_hDownloadEvent);

                    if (!g_fBatch && !g_fBatch2 && (!g_fOptCompInit || g_fSrcDirChanged))
                    {
                        DWORD dwTid;

                        g_hWizard = hDlg;

                        g_hDlg = hDlg;

                        g_fSrcDirChanged = FALSE;

                        DisableDlgItem(hDlg, IDC_DOWNLOAD);
                        DisableDlgItem(hDlg, IDC_DOWNLOADALL);
                        DisableDlgItem(hDlg, IDC_UPDATE);
						g_hAVSThread = CreateThread(NULL, 4096, InitOptComponents32, &g_hWizard, 0, &dwTid);
                        PropSheet_SetWizButtons(GetParent(hDlg), 0);
                    }
                    else
                    {
                        if (s_fNoCore)
                            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                        else PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                        if (!g_fLocalMode)
                            EnableDlgItem2(hDlg, IDC_DOWNLOAD, AnyCompSelected(hDlg));
                    }
                    CheckBatchAdvance(hDlg);
                    break;

                case LVN_ITEMCHANGED:
                    if (hOldCur == NULL)
                        hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
                    else
                    {
                        if (!s_fInit)
                            SetCursor(LoadCursor(NULL, IDC_WAIT));
                    }
                    AnyCompSelected(hDlg, fSel, fSizeChange);
                    if (!g_fLocalMode && g_fOptCompInit) EnableDlgItem2(hDlg, IDC_DOWNLOAD, fSel);
                    if (g_fOptCompInit)
                    {
                        if (fSizeChange || fSel)
                        {
                            ShowWindow(GetDlgItem(hDlg, IDC_DISKSPACETEXT), SW_HIDE);
                            GetDownloadSize(GetDlgItem(hDlg, IDC_COMPLIST), GetDlgItem(hDlg, IDC_DISKSPACENEEDED));
                            ShowWindow(GetDlgItem(hDlg, IDC_DISKSPACETEXT2), SW_SHOW);
                        }
                        else
                        {
                            ShowWindow(GetDlgItem(hDlg, IDC_DISKSPACETEXT), SW_SHOW);
                            ShowWindow(GetDlgItem(hDlg, IDC_DISKSPACETEXT2), SW_HIDE);
                            SetDlgItemText(hDlg, IDC_DISKSPACENEEDED, s_szTotalSize);
                        }
                    }
                    break;


                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    
                    if (!g_fOptCompInit && !g_fBatch && !g_fBatch2)
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        g_fCancelled = FALSE;
                        return(TRUE);
                    }

                    // show OE pages if OE is synchronized for win32

                    if (g_pMNComp)
                        g_fMailNews95 = (g_pMNComp->iImage != RED);

                    g_iCurPage = PPAGE_OPTDOWNLOAD;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;

        }
        break;

        case WM_LV_GETITEMS:
            LVGetItems(GetDlgItem(hDlg, IDC_COMPLIST));
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

void InstallComp(PCOMPONENT pComp, INT iOpt, BOOL fInstall)
{
    PCOMPONENT pSearchComp;

    for (pSearchComp = g_paComp; *pSearchComp->szSection; pSearchComp++)
    {
        if (!pSearchComp->fAddOnOnly &&
            (StrCmpI(pSearchComp->szDisplayName, pComp->szDisplayName) == 0))
            pSearchComp->afInstall[iOpt] = fInstall;
    }

    for (pSearchComp = g_aCustComponents; *pSearchComp->szSection; pSearchComp++)
    {
        if (StrCmpI(pSearchComp->szDisplayName, pComp->szDisplayName) == 0)
            pSearchComp->afInstall[iOpt] = fInstall;
    }
}

void SetInstallOption(HWND hDlg, int iOpt)
{
    TCHAR szOptName[80];
    TCHAR szOptDesc[MAX_PATH];
    TCHAR szOptDescParam[16] = TEXT("0_DESC");
    TCHAR szOpt[2];
    int iComp;
    PCOMPONENT pComp, pCoreComp;
    ICifMode * pCifMode;
    CCifMode_t * pCifMode_t;

    szOpt[1] = 0;
    SendDlgItemMessage( hDlg, IDC_LISTAVAIL, LB_RESETCONTENT, 0, 0 );
    SendDlgItemMessage( hDlg, IDC_LISTINSTALL, LB_RESETCONTENT, 0, 0 );
    SendDlgItemMessage( hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST, CB_SETCURSEL, iOpt, 0 );
    SendDlgItemMessage( hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST, CB_GETLBTEXT, iOpt, (LPARAM) szOptName );
    szOptDescParam[0] = szOpt[0]= (TCHAR)(iOpt + TEXT('0'));
    WritePrivateProfileString( STRINGS, INSTALLMODE, szOpt, g_szCustInf );

    g_lpCifRWFile->FindMode(szOpt, &pCifMode);
    pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);
    pCifMode_t->GetDetails(szOptDesc, countof(szOptDesc));
    delete pCifMode_t;
    
    SetDlgItemText( hDlg, IDC_OPTDESC, szOptDesc );
    pCoreComp = FindComp(NULL, TRUE);
    for (pComp = g_paComp; ; pComp++ )
    {
        if (ISNULL(pComp->szSection)) break;
        if (pComp->fAddOnOnly) continue;
        if (pComp->iImage == RED)
        {
            int i;
            for (i = 0; i < MAX_INSTALL_OPTS ; i++ )
            {
                pComp->afInstall[i] = FALSE;
            }
            continue;
        }
        if (pComp == pCoreComp)
        {
            InstallComp(pComp, iOpt, TRUE);
            SendDlgItemMessage( hDlg, IDC_LISTINSTALL, LB_INSERTSTRING, 0, (LPARAM) pComp->szDisplayName );
        }
        else if ((pComp->iCompType != COMP_CORE) && (pComp->iPlatform <= PLAT_W98))
        {
            if (pComp->fVisible)
            {
                SendDlgItemMessage( hDlg, pComp->afInstall[iOpt] ? IDC_LISTINSTALL : IDC_LISTAVAIL,
                    LB_ADDSTRING, 0, (LPARAM) pComp->szDisplayName );
            }

        }
    }

    for (pComp = g_aCustComponents, iComp = 0; iComp < g_nCustComp ; pComp++, iComp++ )
    {
        if ((pComp->iCompType == COMP_OPTIONAL) && (pComp->iPlatform <= PLAT_W98))
        {
            SendDlgItemMessage( hDlg, pComp->afInstall[iOpt] ? IDC_LISTINSTALL : IDC_LISTAVAIL,
                LB_ADDSTRING, 0, (LPARAM) pComp->szDisplayName );

        }
    }

    if (!g_fOCW)
    {
        // if not silent or stealth and we are under the max number of install options then
        // enable new button

        if (!(g_fIntranet && (g_fSilent || g_fStealth)) && (g_nModes < 10))
            EnableDlgItem(hDlg, IDC_NEWOPT);
        else
        {
            EnsureDialogFocus(hDlg, IDC_NEWOPT, IDC_DELOPT);
            DisableDlgItem(hDlg, IDC_NEWOPT);
        }

        if (g_nModes > 1)
            EnableDlgItem(hDlg, IDC_DELOPT);
        else
        {
            EnsureDialogFocus(hDlg, IDC_DELOPT,
                (g_fIntranet && (g_fSilent || g_fStealth)) ? IDC_OPTLIST : IDC_NEWOPT);
            DisableDlgItem(hDlg, IDC_DELOPT);
        }
    }
    EnableWindow(GetDlgItem(hDlg, IDC_ADDCOMP), 0 < SendMessage( GetDlgItem(hDlg, IDC_LISTAVAIL), LB_GETCOUNT, 0, 0 ));
    EnableWindow(GetDlgItem(hDlg, IDC_ADDALLCOMP), 0 < SendMessage( GetDlgItem(hDlg, IDC_LISTAVAIL), LB_GETCOUNT, 0, 0 ));
    EnableWindow(GetDlgItem(hDlg, IDC_REMCOMP), 1 < SendMessage( GetDlgItem(hDlg, IDC_LISTINSTALL), LB_GETCOUNT, 0, 0 ));
    EnableWindow(GetDlgItem(hDlg, IDC_REMALLCOMP), 1 < SendMessage( GetDlgItem(hDlg, IDC_LISTINSTALL), LB_GETCOUNT, 0, 0 ));

    SetLBWidth(GetDlgItem(hDlg, IDC_LISTAVAIL));
    SetLBWidth(GetDlgItem(hDlg, IDC_LISTINSTALL));
}

void InitSelection32(HWND hDlg)
{
    int i, j, iComp;
    PCOMPONENT pComp;
    IEnumCifModes * pEnumCifModes;

    if (g_fBatch) return;
    SendDlgItemMessage(hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST, CB_RESETCONTENT, 0, 0 );

    // currently not getting alpha modes

    if (SUCCEEDED(g_lpCifRWFile->EnumModes(&pEnumCifModes,
        PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_MILLEN, NULL)))
    {
        ICifMode * pCifMode;
        TCHAR szModeID[64];
        TCHAR szOptName[96];

        i = 0;
        while (SUCCEEDED(pEnumCifModes->Next(&pCifMode)))
        {
            CCifMode_t * pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);

            pCifMode_t->GetID(szModeID, countof(szModeID));
            g_szAllModes[i] = szModeID[0];
            pCifMode_t->GetDescription(szOptName, countof(szOptName));
            SendDlgItemMessage( hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST, CB_ADDSTRING, 0, (LPARAM) szOptName );
            i++;
            delete pCifMode_t;
        }
        pEnumCifModes->Release();
        g_szAllModes[i] = TEXT('\0');
    }

    g_nModes = lstrlen(g_szAllModes);

    for (pComp = g_paComp; ; pComp++ )
    {
        if (ISNULL(pComp->szSection)) break;
        ZeroMemory(pComp->afInstall, sizeof(pComp->afInstall));
        if (pComp->iCompType == COMP_CORE)
        {
            for (i = 0; i < g_nModes ; i++ )
            {
                pComp->afInstall[i] = TRUE;
            }
        }
        else
        {
            for (i = 0; i < g_nModes; i++)
            {
                for (j=0; j < lstrlen(pComp->szModes); j++)
                {
                    if (pComp->szModes[j] == g_szAllModes[i])
                        pComp->afInstall[i] = TRUE;
                }
            }

            // for invisible comps, set them to the same modes as the visible components
            // that depend on them

            if (!pComp->fVisible)
            {
                for (i = 0; pComp->paCompRevDeps[i] && (i < 10); i++)
                {
                    for (j=0; j < MAX_INSTALL_OPTS; j++)
                    {
                        if (pComp->paCompRevDeps[i]->afInstall[j])
                            pComp->afInstall[j] = TRUE;
                    }
                }
            }
        }
    }

    for (pComp = g_aCustComponents, iComp = 0; iComp < g_nCustComp ; pComp++, iComp++ )
    {
        TCHAR szModesParam[80] = TEXT("Cust0Modes");
        TCHAR szModes[16] = TEXT("\"");
        if (ISNULL(pComp->szSection)) break;

        szModesParam[4] = (TCHAR)(iComp + TEXT('0'));
        ZeroMemory(pComp->afInstall, sizeof(pComp->afInstall));
        GetPrivateProfileString(IS_STRINGS, szModesParam, TEXT(""), szModes, countof(szModes), g_szCustInf);
        if (StrCmpI(szModes, UNUSED) != 0)
        {
            for (i = 0; i < lstrlen(szModes) ; i++ )
            {
                int j = szModes[i] - TEXT('0');
                pComp->afInstall[j] = TRUE;
            }
        }

    }

    if (g_iSelOpt > g_nModes - 1) g_iSelOpt = g_nModes ? g_nModes - 1 : 0;
    SetInstallOption(hDlg, g_iSelOpt);
}

void SaveSelection()
{
    int i, iComp;
    PCOMPONENT pComp;
    TCHAR szQuotedModes[16] = TEXT("\"");
    ICifRWComponent * pCifRWComponent;
    CCifRWComponent_t * pCifRWComponent_t;

    StrCat(szQuotedModes, g_szAllModes);
    StrCat(szQuotedModes, TEXT("\""));

    for (pComp = g_aCustComponents, iComp = 0; iComp < MAXCUST ; pComp++, iComp++ )
    {
        TCHAR szModesParam[80] = TEXT("Cust0Modes");
        TCHAR szModesNameParam[80] = TEXT("Cust0Name");
        TCHAR szModes[16] = TEXT("");
        TCHAR szQuotedSection[32] = TEXT("\"");

        StrCat(szQuotedSection, pComp->szSection);
        StrCat(szQuotedSection, TEXT("\""));
        szModesParam[4] = szModesNameParam[4] = (TCHAR)(iComp + TEXT('0'));
        if (ISNULL(pComp->szSection))
        {
            InsWriteQuotedString(IS_STRINGS, szModesNameParam, UNUSED, g_szCustInf);
            InsWriteQuotedString(IS_STRINGS, szModesParam, TEXT("\"\""), g_szCustInf);
            continue;
        }
        for (i = 0; i < g_nModes ; i++ )
        {
            TCHAR szAddMode[2] = TEXT("0");
            szAddMode[0] = (TCHAR)(i + TEXT('0'));
            if (pComp->afInstall[i]) StrCat(szModes, szAddMode);
        }

        StrCpy(pComp->szModes, szModes);
        InsWriteQuotedString(IS_STRINGS, szModesNameParam, szQuotedSection, g_szCustInf);
        InsWriteQuotedString(IS_STRINGS, szModesParam, szModes, g_szCustInf);
    }

    for (pComp = g_paComp; ; pComp++ )
    {
        TCHAR szModesParam[80];
        TCHAR szModes[16] = TEXT("");

        if (ISNULL(pComp->szSection)) break;
    //BUGBUG fix for alpha release
        if (pComp->iPlatform == PLAT_ALPHA) continue;
        for (i = 0; i < g_nModes ; i++ )
        {
            TCHAR szAddMode[2] = TEXT("0");
            szAddMode[0] = (TCHAR)(i + TEXT('0'));
            if (pComp->afInstall[i]) StrCat(szModes, szAddMode);
        }
        
        StrCpy(szModesParam, pComp->szModes);

        g_lpCifRWFile->CreateComponent(pComp->szSection, &pCifRWComponent);
        pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);

        if (pComp->iCompType == COMP_CORE)
        {
            int j;

            if ((StrCmpNI(pComp->szSection, TEXT("IE4SHELL"), 8) == 0) ||
                (StrCmpNI(pComp->szSection, TEXT("MFC"), 3) == 0))
                continue;

            WriteModesToCif(pCifRWComponent_t, g_szAllModes);
            StrCpy(pComp->szModes, g_szAllModes);
            for (j = 0; g_szAllModes[j]; j++)
                pComp->afInstall[j] = TRUE;
        }
        else
        {
            if (pComp->fVisible)
                WriteModesToCif(pCifRWComponent_t, szModes);

            // BUGBUG: <oliverl> take out this assert for now because we'd have to totally
            //         change the way we handle adding and removing comps from modes to
            //         prevent this from asserting
    /*        else
                ASSERT(ISNULL(pComp->szModes));  */

            StrCpy(pComp->szModes, szModes);
        }

        delete pCifRWComponent_t;
        pCifRWComponent_t = NULL;
    }

    WritePrivateProfileString(NULL, NULL, NULL, g_szCustInf);
    g_lpCifRWFile->Flush();
}

BOOL AddDependencies32(HWND hDlg, LPCTSTR pcszSectName, INT &nComp)
{
    HWND hSource = GetDlgItem(hDlg, IDC_LISTAVAIL);
    HWND hDest = GetDlgItem(hDlg, IDC_LISTINSTALL);
    int iComp;
    PCOMPONENT pComp;
    ICifComponent * pCifComponent;
    BOOL fCust = FALSE;

    if (StrCmpNI(pcszSectName, TEXT("BASEIE40"), 8) == 0)
        return TRUE;

    pComp = FindComp(pcszSectName, FALSE);

    if (pComp == NULL)
    {
        fCust = TRUE;
        pComp = FindCustComp(pcszSectName);

        if (pComp == NULL)
            return FALSE;
    }

    InstallComp(pComp, g_iSelOpt, TRUE);

    if (pComp->fVisible)
    {
        if ((iComp = (int) SendMessage( hSource, LB_FINDSTRINGEXACT, 0, (LPARAM)pComp->szDisplayName )) == -1 )
            return FALSE;


        SendMessage( hSource, LB_DELETESTRING, iComp, 0 );
        SendMessage( hDest, LB_ADDSTRING, 0, (LPARAM) pComp->szDisplayName);
        nComp--;

        SetLBWidth(GetDlgItem(hDlg, IDC_LISTAVAIL));
        SetLBWidth(GetDlgItem(hDlg, IDC_LISTINSTALL));
    }

    if (!fCust)
    {
        if (SUCCEEDED(g_lpCifRWFile->FindComponent(pComp->szSection, &pCifComponent)))
        {
            TCHAR tchType;
            TCHAR szDepID[96];
            UINT uiIndex = 0;
            PCOMPONENT pDepComp;
            CCifComponent_t * pCifComponent_t =
                new CCifComponent_t((ICifRWComponent *)pCifComponent);

            while (SUCCEEDED(pCifComponent_t->GetDependency(uiIndex, szDepID, countof(szDepID), &tchType, NULL, NULL)))
            {
                pDepComp = FindComp(szDepID, FALSE);

                // check to see if we've already seen this dependency

                if (pDepComp && !pDepComp->afInstall[g_iSelOpt])
                {
                    if (!AddDependencies32(hDlg, szDepID, nComp))
                        return FALSE;
                }
                uiIndex++;
            }

            delete pCifComponent_t;
        }
    }

    return TRUE;
}

void RemoveSilentDeps32(PCOMPONENT pComp, INT iSelOpt)
{
    ICifComponent * pCifComponent;
    PCOMPONENT pDepComp;
    UINT uiIndex = 0;
    TCHAR szDepID[32];
    TCHAR tchType;

    if (SUCCEEDED(g_lpCifRWFile->FindComponent(pComp->szSection, &pCifComponent)))
    {
        CCifComponent_t * pCifComponent_t =
            new CCifComponent_t((ICifRWComponent *)pCifComponent);

        while (SUCCEEDED(pCifComponent_t->GetDependency(uiIndex, szDepID, countof(szDepID), &tchType, NULL, NULL)))
        {
            pDepComp = FindComp(szDepID, FALSE);

            if (pDepComp && !pDepComp->fVisible && pDepComp->afInstall[iSelOpt])
            {
                InstallComp(pDepComp, iSelOpt, FALSE);
                RemoveSilentDeps32(pDepComp, iSelOpt);
            }
            uiIndex++;
        }
        delete pCifComponent_t;
    }
}

BOOL RemoveDependencies32(HWND hDlg, PCOMPONENT pComp, INT &nComp, BOOL fCust)
{
    int i, k, j = 0;
    BOOL fAdd;
    TCHAR szCompList[MAX_BUF];
    TCHAR szHeader[MAX_PATH];
    TCHAR szMsgBoxText[MAX_BUF];
    HWND hSource = GetDlgItem(hDlg, IDC_LISTINSTALL);
    HWND hDest = GetDlgItem(hDlg, IDC_LISTAVAIL);

    if (!fCust)
    {
        ZeroMemory(szCompList, sizeof(szCompList));

        StrCat(szCompList, TEXT("\r\n"));
        for (i = 0, j = 0; pComp->paCompRevDeps[i] && (i < 10); i++)
        {
            if (((pComp->paCompRevDeps[i])->fVisible) &&
                ((pComp->paCompRevDeps[i])->afInstall[g_iSelOpt]))
            {
                fAdd = TRUE;
                for (k = 0;  pComp->paCompRevDeps[k] && (k < i); k++)
                {
                    if (0 == (strcmp((const char*)(pComp->paCompRevDeps[k])->szDisplayName,
                                     (const char*)(pComp->paCompRevDeps[i])->szDisplayName)))
                        fAdd = FALSE;
                }
                if (fAdd)
                {
                    StrCat(szCompList, (pComp->paCompRevDeps[i])->szDisplayName);
                    StrCat(szCompList, TEXT("\r\n"));
                }
                j++;
            }
        }

        if (j != 0)
        {
            LoadString(g_rvInfo.hInst, IDS_DEPEND_WARNING , szHeader, countof(szHeader));
            wnsprintf(szMsgBoxText, countof(szMsgBoxText), szHeader, pComp->szDisplayName, szCompList);
        }
    }

    if (fCust || (j == 0) || (MessageBox(hDlg, szMsgBoxText, TEXT(""), MB_OKCANCEL) == IDOK))
    {

        InstallComp(pComp, g_iSelOpt, FALSE);
        if (!fCust)
        {
            for (i = 0; pComp->paCompRevDeps[i] && (i < 10); i++)
            {
                InstallComp(pComp->paCompRevDeps[i], g_iSelOpt, FALSE);

                if ((pComp->paCompRevDeps[i])->fVisible)
                {
                    if ((j = (int) SendMessage( hSource, LB_FINDSTRINGEXACT, 1, (LPARAM)(pComp->paCompRevDeps[i])->szDisplayName )) != -1 )
                    {
                        SendMessage( hSource, LB_DELETESTRING, j, 0 );
                        SendMessage( hDest, LB_ADDSTRING, 0, (LPARAM) (pComp->paCompRevDeps[i])->szDisplayName );
                        nComp--;

                        SetLBWidth(GetDlgItem(hDlg, IDC_LISTAVAIL));
                        SetLBWidth(GetDlgItem(hDlg, IDC_LISTINSTALL));
                    }
                }
            }
            RemoveSilentDeps32(pComp, g_iSelOpt);
        }

        if ((i = (int) SendMessage( hSource, LB_FINDSTRINGEXACT, 1, (LPARAM)pComp->szDisplayName )) != -1 )
        {
            SendMessage( hSource, LB_DELETESTRING, i, 0 );
            SendMessage( hDest, LB_ADDSTRING, 0, (LPARAM) pComp->szDisplayName );
            nComp--;

            SetLBWidth(GetDlgItem(hDlg, IDC_LISTAVAIL));
            SetLBWidth(GetDlgItem(hDlg, IDC_LISTINSTALL));
        }

    }
    else
        return FALSE;

    return TRUE;
}



void AddRemoveComponents(HWND hDlg, BOOL fAll, BOOL fAdd)
{
    HWND hSource = GetDlgItem(hDlg, fAdd ? IDC_LISTAVAIL : IDC_LISTINSTALL);
    HWND hDest = GetDlgItem(hDlg, fAdd ? IDC_LISTINSTALL : IDC_LISTAVAIL);
    TCHAR szCompName[MAX_PATH];
    PCOMPONENT pComp;
    int iComp,iStart;
    int nComp = (int) SendMessage(hSource, LB_GETCOUNT, 0, 0);
    BOOL fCust;
    BOOL fSomeSel = FALSE;

    if(!fAdd)
    {
        iStart=1; //We don't want to remove the browser itself;
    }
    else
    {
        iStart=0;
    }

    if (fAll)
    {
        for (pComp = g_paComp; *pComp->szSection; pComp++)
        {
            pComp->afInstall[g_iSelOpt] = fAdd && (!pComp->fAddOnOnly);
        }

        for (pComp = g_aCustComponents; *pComp->szSection; pComp++ )
        {
            pComp->afInstall[g_iSelOpt] = fAdd;
        }
    }

    for (iComp = iStart; iComp < nComp; iComp++ )
    {
        BOOL fSel = (SendMessage( hSource, LB_GETSEL, iComp, 0 ) > 0) ? TRUE : FALSE;
        if (!fSel && !fAll) continue;

        fSomeSel = TRUE;
        SendMessage( hSource, LB_GETTEXT, iComp, (LPARAM) szCompName );

        if (!fAll)
        {
            pComp = FindVisibleComponentName(szCompName);
            if (!pComp)
            {
                pComp = FindCustComponentName(szCompName);
                fCust = TRUE;
            }
            else
                fCust = FALSE;

            if (pComp)
            {
                if (fAdd)
                {
                    AddDependencies32(hDlg, pComp->szSection, nComp);
                    iComp = iStart-1;
                }
                else
                {
                    if (RemoveDependencies32(hDlg, pComp, nComp, fCust))
                        iComp = iStart-1;
                }
            }
            continue;
        }
        SendMessage( hSource, LB_DELETESTRING, iComp, 0 );
        SendMessage( hDest, LB_ADDSTRING, 0, (LPARAM) szCompName );
        iComp--;
        nComp--;
    }
    if (fSomeSel)
    {
        BOOL fEnableAdd = (0 < SendMessage( fAdd ? hSource : hDest, LB_GETCOUNT, 0, 0 ));
        BOOL fEnableRem = (iStart < SendMessage( fAdd ? hDest : hSource, LB_GETCOUNT, 0, 0 ));
                           
        EnableWindow(GetDlgItem(hDlg, IDC_ADDCOMP), fEnableAdd);
        EnableWindow(GetDlgItem(hDlg, IDC_ADDALLCOMP), fEnableAdd);
        EnableWindow(GetDlgItem(hDlg, IDC_REMCOMP), fEnableRem);
        EnableWindow(GetDlgItem(hDlg, IDC_REMALLCOMP), fEnableRem);

        if (fEnableAdd)
            SetFocus(GetDlgItem(hDlg,IDC_LISTINSTALL));
        else
            SetFocus(GetDlgItem(hDlg,IDC_LISTAVAIL));
    }

    SetLBWidth(GetDlgItem(hDlg, IDC_LISTAVAIL));
    SetLBWidth(GetDlgItem(hDlg, IDC_LISTINSTALL));

}


DWORD GotRoom(HWND hDlg)
{
    PCOMPONENT pComp;
    TCHAR szDestRoot[MAX_PATH];
    TCHAR szTempRoot[MAX_PATH];
    int iComp;
    DWORD dwDestMul = 1, dwTempMul = 0;
    DWORD dwDestFree, dwTempFree, dwDestNeed, dwTempNeed;

    if (g_fCD) dwDestMul++;
    if (g_fLAN) dwDestMul++;
    if (g_fBrandingOnly) dwDestMul++;
    StrCpy(szDestRoot, g_szBuildRoot);
    StrCpy(szTempRoot, g_szBuildTemp);
    CharUpper(szDestRoot);
    CharUpper(szTempRoot);
    dwDestFree = GetRootFree(szDestRoot);
    dwTempFree = GetRootFree(szTempRoot);
    dwDestNeed = dwTempNeed = 4096;

    for (pComp = g_paComp;  ; pComp++ )
    {
        if (ISNULL(pComp->szSection)) break;
        dwDestNeed += pComp->dwSize * dwDestMul;
        dwTempNeed += pComp->dwSize * dwTempMul;
    }

    for (pComp = g_aCustComponents, iComp = 0; iComp < g_nCustComp ; pComp++, iComp++ )
    {
        DWORD dwSize = FolderSize(pComp->szPath) >> 10;
        dwDestNeed += dwSize * dwDestMul;
        dwTempNeed += dwSize * dwTempMul;
    }

    if (*szDestRoot == *szTempRoot)
    {
        dwDestNeed += dwTempNeed;
    }
    else if (dwTempFree < dwTempNeed)
    {
        TCHAR szTitle[MAX_PATH];
        TCHAR szTemplate[MAX_PATH];
        TCHAR szMsg[MAX_PATH];
        LoadString( g_rvInfo.hInst, IDS_DISKERROR, szTitle, MAX_PATH );
        LoadString( g_rvInfo.hInst, IDS_TEMPDISKMSG2, szTemplate, MAX_PATH );
        wnsprintf(szMsg, countof(szMsg), szTemplate, dwTempFree, dwTempNeed);
        if (MessageBox(hDlg, szMsg, szTitle, MB_OKCANCEL | MB_SETFOREGROUND) == IDCANCEL)
        {
            LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
            MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
            DoCancel();
            return (DWORD)-1;
        }
        else
        {
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
            return (DWORD)-1;
        }
    }
    if (dwDestFree < dwDestNeed)
    {
        TCHAR szTitle[MAX_PATH];
        TCHAR szTemplate[MAX_PATH];
        TCHAR szMsg[MAX_PATH];
        LoadString( g_rvInfo.hInst, IDS_DISKERROR, szTitle, MAX_PATH );
        LoadString( g_rvInfo.hInst, IDS_DESTDISKMSG2, szTemplate, MAX_PATH );
        wnsprintf(szMsg, countof(szMsg), szTemplate, dwDestFree, dwDestNeed);
        if (MessageBox(hDlg, szMsg, szTitle, MB_OKCANCEL | MB_SETFOREGROUND) == IDCANCEL)
        {
            LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
            MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
            DoCancel();
            return (DWORD)-1;
        }
        else
        {
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
            return (DWORD)-1;
        }
    }
    return(0);

}

BOOL SaveOption(HWND hDlg, HWND hOptlist)
{
    TCHAR szOptName[80] = TEXT("");
    TCHAR szOptNameParam[8] = TEXT("0_Name");
    TCHAR szOptDesc[MAX_PATH] = TEXT("");
    TCHAR szOptDescParam[8] = TEXT("0_DESC");
    TCHAR szOptNum[2] = TEXT("0");
    ICifRWMode * pCifRWMode;
    CCifRWMode_t * pCifRWMode_t;

    GetWindowText( hOptlist, szOptName, 80 );
    GetDlgItemText( hDlg, IDC_OPTDESC, szOptDesc, countof(szOptDesc));

    if (ISNULL(szOptName) || ISNULL(szOptDesc))
    {
        ErrorMessageBox(hDlg, IDS_BLANKOPTION);
        return FALSE;
    }
    SendMessage( hOptlist, CB_DELETESTRING, g_iSelOpt, 0L );
    SendMessage( hOptlist, CB_INSERTSTRING, g_iSelOpt, (LPARAM) szOptName);
    SendMessage( hOptlist, CB_SETCURSEL, g_iSelOpt, 0L );

    szOptNum[0] = (TCHAR)(g_iSelOpt + TEXT('0'));
    g_lpCifRWFile->CreateMode(szOptNum, &pCifRWMode);
    pCifRWMode_t = new CCifRWMode_t(pCifRWMode);
    pCifRWMode_t->SetDescription(szOptName);
    pCifRWMode_t->SetDetails(szOptDesc);
    delete pCifRWMode_t;

    return TRUE;
}

void ReinitModes(HWND hDlg)
{
    PCOMPONENT pComp;
    IEnumCifModes * pEnumCifModes;
    INT iComp;

    // delete the cif structure before copying over the versioning cif to the target dir

    if (g_lpCifRWFile)
    {
        delete g_lpCifRWFile;
        g_lpCifRWFile = NULL;
    }
    CopyFile(g_szCifVer, g_szCif, FALSE);
    GetICifRWFileFromFile_t(&g_lpCifRWFile, g_szCif);

    if (g_fOCW)
    {
        g_lpCifRWFile->DeleteMode(TEXT("2"));
        g_lpCifRWFile->Flush();
    }

    // reread the modes for the components from the cif

    for (pComp = g_paComp; *pComp->szSection; pComp++)
    {
        ICifComponent * pCifComponent;

        ZeroMemory(pComp->szModes, sizeof(pComp->szModes));
        ZeroMemory(pComp->afInstall, sizeof(pComp->afInstall));

        if (SUCCEEDED(g_lpCifRWFile->FindComponent(pComp->szSection, &pCifComponent)))
        {
            UINT uiIndex = 0;
            TCHAR szMode[MAX_PATH];
            CCifComponent_t * pCifComponent_t =
                new CCifComponent_t((ICifRWComponent *)pCifComponent);

            while (SUCCEEDED(pCifComponent_t->GetMode(uiIndex, szMode, countof(szMode))))
            {
                pComp->szModes[uiIndex] = szMode[0];
                pComp->afInstall[szMode[0] - TEXT('0')] = TRUE;
                uiIndex++;
            }
            delete pCifComponent_t;
        }
    }

    if (SUCCEEDED(g_lpCifRWFile->EnumModes(&pEnumCifModes,
        PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_MILLEN, NULL)))
    {
        ICifMode * pCifMode;
        TCHAR szModeID[64];
        int i = 0;

        while (SUCCEEDED(pEnumCifModes->Next(&pCifMode)))
        {
            CCifMode_t * pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);

            pCifMode_t->GetID(szModeID, countof(szModeID));
            g_szAllModes[i] = szModeID[0];
            i++;
            delete pCifMode_t;
        }
        pEnumCifModes->Release();
        g_szAllModes[i] = TEXT('\0');
    }

    g_nModes = lstrlen(g_szAllModes);
    // reset custom components to be in all modes

    for (iComp = 0, pComp = g_aCustComponents; iComp < g_nCustComp; iComp++, pComp++ )
    {
        if (ISNULL(pComp->szSection)) break;
        StrCpy(pComp->szModes, g_szAllModes);
    }

    InitSelection32(hDlg);
}

//
//  FUNCTION: ComponentSelect(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "ComponentSelect" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
//
BOOL APIENTRY ComponentSelect(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szOptName[80];
    TCHAR szOptTpl[80];
    TCHAR szOptNameParam[8] = TEXT("0_Name");
    TCHAR szOptDesc[160];    // weird limit imposed by size of window control in ie6setup
    TCHAR szOptDescParam[8] = TEXT("0_DESC");
    TCHAR szOptNum[2] = TEXT("0");
    TCHAR szNextNameParam[8] = TEXT("0_Name");
    TCHAR szNextDescParam[8] = TEXT("0_Desc");
    TCHAR szModeNameParm[10] = TEXT("%0_Name%");
    TCHAR szModeDescParm[10] = TEXT("%0_Desc%");
    TCHAR szModeSect[8] = TEXT("0.Win");
    int iComp, iOpt, iNewSel;
    PCOMPONENT pComp;
    TCHAR szModeChar[4] = TEXT("0");
    BOOL s_fFirst = TRUE;
    HWND hOptlist;
    static BOOL s_fEditChange = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            EnableDBCSChars( hDlg, IDC_LISTAVAIL);
            EnableDBCSChars( hDlg, IDC_LISTINSTALL);
            EnableDBCSChars( hDlg, IDC_OPTLIST);
            EnableDBCSChars( hDlg, IDC_OPTLISTOCW);
            EnableDBCSChars( hDlg, IDC_OPTDESC);
            Edit_LimitText(GetDlgItem(hDlg, IDC_OPTDESC), countof(szOptDesc)-1);
            Edit_LimitText(GetDlgItem(hDlg, IDC_OPTLIST), countof(szOptName)-1);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_OPTLIST:
                case IDC_OPTLISTOCW:
                    switch (HIWORD(wParam))
                    {
                        case CBN_EDITCHANGE:
                            s_fEditChange = TRUE;
                            break;

                        case CBN_SELENDOK:
                            hOptlist = GetDlgItem(hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST);
                            iNewSel = ComboBox_GetCurSel(hOptlist);
                            if (s_fEditChange)
                            {
                                GetWindowText(hOptlist, szOptName, countof(szOptName));
                                ComboBox_DeleteString(hOptlist, g_iSelOpt);
                                ComboBox_InsertString(hOptlist, g_iSelOpt, szOptName);
                                
                                if (!SaveOption(hDlg, hOptlist))
                                {
                                    ComboBox_SetCurSel(hOptlist, g_iSelOpt);
                                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                    break;
                                }
                                s_fEditChange = FALSE;
                            }
                            if ((iNewSel != CB_ERR) && (iNewSel != g_iSelOpt))
                            {
                                g_iSelOpt = iNewSel;
                                SetInstallOption(hDlg, g_iSelOpt);
                            }
                            if (iNewSel < 0) iNewSel = 0;
                            ComboBox_SetCurSel(hOptlist, iNewSel);
                            break;

                        case CBN_DROPDOWN:
                            hOptlist = GetDlgItem(hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST);
                            GetWindowText(hOptlist, szOptName, countof(szOptName));
                            ComboBox_DeleteString(hOptlist, g_iSelOpt);
                            ComboBox_InsertString(hOptlist, g_iSelOpt, szOptName);
                            ComboBox_SetCurSel(hOptlist, g_iSelOpt);
                            break;
                        default:
                            return FALSE;
                    }
                    break;
                case IDC_OPTDESC:
                    s_fEditChange = TRUE;
                    break;
                case IDC_NEWOPT:
                    if (s_fEditChange)
                    {
                        if (!SaveOption(hDlg, GetDlgItem(hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST)))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }
                    }
                    g_iSelOpt = g_nModes++;
                    LoadString( g_rvInfo.hInst, IDS_NEWINSTALLOPT, szOptTpl, countof(szOptTpl) );
                    *szOptNum = *szOptNameParam = *szModeChar = *szModeSect =
                        szModeNameParm[1] = szModeDescParm[1] = (TCHAR)(g_iSelOpt + TEXT('0'));
                    wnsprintf(szOptName, countof(szOptName), TEXT("%s %s"), szOptTpl, szOptNum);

                    {
                        ICifRWMode * pCifRWMode;
                        CCifRWMode_t * pCifRWMode_t;

                        szOptNum[0] = (TCHAR)(g_iSelOpt + TEXT('0'));
                        g_lpCifRWFile->CreateMode(szOptNum, &pCifRWMode);
                        pCifRWMode_t = new CCifRWMode_t(pCifRWMode);
                        pCifRWMode_t->SetDescription(szOptName);
                        delete pCifRWMode_t;
                    }
                    
                    SendDlgItemMessage( hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST, CB_ADDSTRING, 0, (LPARAM) szOptName );
                    StrCat(g_szAllModes, szModeChar);

                    // add custom components to mode by default
                    for (iComp = 0, pComp = g_aCustComponents; iComp < g_nCustComp  ; iComp++, pComp++ )
                    {
                        if (ISNULL(pComp->szSection)) break;
                        pComp->afInstall[g_nModes-1] = TRUE;
                        StrCat(pComp->szModes, szOptNum);
                    }

                    SetInstallOption(hDlg, g_iSelOpt);
                    s_fEditChange = TRUE;
                    break;
                case IDC_DELOPT:
                    SendDlgItemMessage( hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST, CB_DELETESTRING, g_iSelOpt, 0 );
                    if (g_iSelOpt != (g_nModes - 1))
                    {
                        ICifRWMode * pCifRWMode;
                        CCifRWMode_t * pCifRWMode_t;
                        ICifMode * pCifMode;
                        CCifMode_t * pCifMode_t;
                        TCHAR szOptCurrent[2];
                        TCHAR szOptNext[2];
                        
                        for (iOpt = g_iSelOpt; iOpt < (g_nModes-1) ; iOpt++ )
                        {
                            *szNextNameParam = *szNextDescParam = (TCHAR)(iOpt + TEXT('1'));
                            *szOptDescParam = *szOptNameParam = (TCHAR)(iOpt + TEXT('0'));

                            StrCpy(szOptCurrent, TEXT("0"));
                            StrCpy(szOptNext, TEXT("0"));

                            szOptCurrent[0] = (TCHAR)(iOpt + TEXT('0'));
                            szOptNext[0] = (TCHAR)(iOpt + TEXT('1'));
                            g_lpCifRWFile->DeleteMode(szOptCurrent);
                            g_lpCifRWFile->CreateMode(szOptCurrent, &pCifRWMode);
                            pCifRWMode_t = new CCifRWMode_t(pCifRWMode);
                            g_lpCifRWFile->FindMode(szOptNext, &pCifMode);
                            pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);
                            pCifMode_t->GetDescription(szOptName, countof(szOptName));
                            pCifRWMode_t->SetDescription(szOptName);
                            pCifMode_t->GetDetails(szOptDesc, countof(szOptDesc));
                            pCifRWMode_t->SetDetails(szOptDesc);
                            delete pCifRWMode_t;
                            delete pCifMode_t;
                            pCifRWMode_t = NULL;
                            pCifMode_t = NULL;
                             
                            for (pComp = g_paComp; ; pComp++ )
                            {
                                if (ISNULL(pComp->szSection)) break;
                                pComp->afInstall[iOpt] = pComp->afInstall[iOpt + 1];
                            }
                            for (iComp = 0, pComp = g_aCustComponents; iComp < g_nCustComp  ; iComp++, pComp++ )
                            {
                                if (ISNULL(pComp->szSection)) break;
                                pComp->afInstall[iOpt] =  pComp->afInstall[iOpt + 1];
                            }
                        }
                    }

                    *szOptDescParam = *szOptNameParam = szOptNum[0] = (TCHAR)((g_nModes-1) + TEXT('0'));
                    szOptNum[1] = TEXT('\0');

                    g_lpCifRWFile->DeleteMode(szOptNum);

                    for (pComp = g_paComp; ; pComp++ )
                    {
                        if (ISNULL(pComp->szSection)) break;
                        pComp->afInstall[g_nModes-1] = FALSE;
                    }
                    for (iComp = 0, pComp = g_aCustComponents; iComp < g_nCustComp  ; iComp++, pComp++ )
                    {
                        if (ISNULL(pComp->szSection)) break;
                        pComp->afInstall[g_nModes-1] = FALSE;
                    }
                    g_nModes--;
                    g_szAllModes[g_nModes] = TEXT('\0');
                    
                    if (g_iSelOpt >= g_nModes) g_iSelOpt--;
                    SetInstallOption(hDlg, g_iSelOpt);
                    break;
                case IDC_ADDCOMP:
                    AddRemoveComponents(hDlg, FALSE, TRUE);
                    break;
                case IDC_REMCOMP:
                    AddRemoveComponents(hDlg, FALSE, FALSE);
                    break;
                case IDC_ADDALLCOMP:
                    AddRemoveComponents(hDlg, TRUE, TRUE);
                    break;
                case IDC_REMALLCOMP:
                    AddRemoveComponents(hDlg, TRUE, FALSE);
                    break;
                case IDC_RESETCOMPS:
                    ReinitModes(hDlg);
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    g_iSelOpt = GetPrivateProfileInt( STRINGS, INSTALLMODE, 0, g_szCustInf );

                    if (g_fOCW)
                    {
                        PCOMPONENT pComp;

                        DisableDlgItem(hDlg, IDC_NEWOPT);
                        DisableDlgItem(hDlg, IDC_DELOPT);
                        ShowWindow(GetDlgItem(hDlg, IDC_OPTLIST), SW_HIDE);
                        LoadString(g_rvInfo.hInst, IDS_OCWOPTDESC, szOptDesc, countof(szOptDesc));
                        SetWindowText(GetDlgItem(hDlg, IDC_OPTIONTEXT3), szOptDesc);

                        // do not offer full mode for OCW
                        g_lpCifRWFile->DeleteMode(TEXT("2"));
                        g_lpCifRWFile->Flush();

                        for (pComp = g_paComp; ; pComp++ )
                        {
                            if (ISNULL(pComp->szSection)) break;
                            pComp->afInstall[2] = FALSE;
                        }
                    }
                    else
                        ShowWindow(GetDlgItem(hDlg, IDC_OPTLISTOCW), SW_HIDE);

                    if (s_fFirst)
                    {
                        InitSelection32(hDlg);
                        s_fFirst = FALSE;
                    }
                    
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                    if (GotRoom(hDlg) != 0) return(TRUE);
                case PSN_WIZBACK:
                    if (!g_fBatch)
                    {
                        CNewCursor cur(IDC_WAIT);

                        if (s_fEditChange)
                        {
                            if (!SaveOption(hDlg, GetDlgItem(hDlg, g_fOCW ? IDC_OPTLISTOCW : IDC_OPTLIST)))
                            {
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                break;
                            }
                            s_fEditChange = FALSE;
                        }
                        SaveSelection();
                        for (iOpt = 0; iOpt < g_nModes ; iOpt++ )
                        {
                            *szModeChar = *szModeSect = szModeNameParm[1] = szModeDescParm[1] =
                                *szOptNameParam = *szOptDescParam = *szOptNum = (TCHAR)(iOpt + TEXT('0'));

                            {
                                ICifMode * pCifMode;
                                CCifMode_t * pCifMode_t;

                                g_lpCifRWFile->FindMode(szOptNum, &pCifMode);
                                pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);
                                if (FAILED(pCifMode_t->GetDescription(szOptName, countof(szOptName))) ||
                                    FAILED(pCifMode_t->GetDetails(szOptDesc, countof(szOptDesc))))
                                {
                                    delete pCifMode_t;
                                    ErrorMessageBox(hDlg, IDS_BLANKOPTION);
                                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                    break;
                                }
                                delete pCifMode_t;
                            }
                        }

                        InsFlushChanges(g_szCustInf);
                    }
                    else
                    {
                        g_fMailNews95 = FALSE;
                    }

                    g_iCurPage = PPAGE_COMPSEL;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

BOOL InitList(HWND hwnd, UINT id)
{
    HIMAGELIST  himl;     // handle of image list
    HBITMAP     hbmp;     // handle of bitmap
    HWND        hwndList;
    LVCOLUMN    lvCol;

    hwndList = GetDlgItem(hwnd, id);
    // Create the image list.
    if ((himl = ImageList_Create(CX_BITMAP, CY_BITMAP, 0, NUM_BITMAPS, 0)) == NULL)
        return FALSE;

    hbmp = LoadBitmap(g_rvInfo.hInst, MAKEINTRESOURCE(IDB_UNSELECT));
    ImageList_Add(himl, hbmp, (HBITMAP) NULL);
    DeleteObject(hbmp);

    hbmp = LoadBitmap(g_rvInfo.hInst, MAKEINTRESOURCE(IDB_SELECT));
    ImageList_Add(himl, hbmp, (HBITMAP) NULL);
    DeleteObject(hbmp);

    if (ImageList_GetImageCount(himl) < NUM_BITMAPS)
        return FALSE;

    // Associate the image list with the  control.
    ListView_SetImageList(hwndList, himl, LVSIL_SMALL);

    ZeroMemory(&lvCol, sizeof(lvCol));
    lvCol.mask = LVCF_FMT;
    lvCol.fmt = LVCFMT_LEFT;
    lvCol.cx = 280;
    ListView_InsertColumn(hwndList, 0, &lvCol);

    return TRUE;
}

void InitHiddenItems(UINT uListId)
{
    TCHAR szBuf[8];
    PCOMPONENT pComp;

    if (uListId == IDC_COPYCOMP)
    {
        for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
        {
            if (GetPrivateProfileString(IS_NOCOPYCUST, pComp->szGUID, TEXT(""), szBuf, countof(szBuf), g_szCustIns))
                pComp->fNoCopy = TRUE;
        }

        for (pComp = g_paComp; *pComp->szSection; pComp++)
        {
            if (GetPrivateProfileString(IS_NOCOPYCUST, pComp->szGUID, TEXT(""), szBuf, countof(szBuf), g_szCustIns))
                pComp->fNoCopy = TRUE;
        }
    }
    else
    {
        for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
        {
            if ((GetPrivateProfileString(IS_HIDECUST, pComp->szGUID, TEXT(""), szBuf, countof(szBuf), g_szCustIns)
                && (*szBuf == TEXT('1'))) || (ISNULL(szBuf) && !AnySelection(pComp)))
                pComp->fCustomHide = TRUE;
        }

        for (pComp = g_paComp; *pComp->szSection; pComp++)
        {
            if (pComp->fAddOnOnly ||
                (GetPrivateProfileString(IS_HIDECUST, pComp->szGUID, TEXT(""), szBuf, countof(szBuf), g_szCustIns)
                && (*szBuf == TEXT('1'))) || (ISNULL(szBuf) && !AnySelection(pComp)))
                pComp->fCustomHide = TRUE;
        }
    }
}

// BUGBUG: <oliverl> should probably persist this server side only info in a server side file for IEAK6

void SaveHiddenItems(UINT uListId)
{
    PCOMPONENT pComp;

    if (uListId == IDC_COPYCOMP)
    {
        for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
            WritePrivateProfileString(IS_NOCOPYCUST, pComp->szGUID, pComp->fNoCopy ? TEXT("1") : NULL, g_szCustIns);

        for (pComp = g_paComp; *pComp->szSection; pComp++)
            WritePrivateProfileString(IS_NOCOPYCUST, pComp->szGUID, pComp->fNoCopy ? TEXT("1") : NULL, g_szCustIns);
    }
    else
    {
        for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
            WritePrivateProfileString(IS_HIDECUST, pComp->szGUID, pComp->fCustomHide ? TEXT("1") : TEXT("0"), g_szCustIns);

        for (pComp = g_paComp; *pComp->szSection; pComp++)
            WritePrivateProfileString(IS_HIDECUST, pComp->szGUID, (pComp->fCustomHide && !pComp->fAddOnOnly) ? TEXT("1") : TEXT("0"), g_szCustIns);
    }
}

BOOL AddItemToList(PCOMPONENT pComp, HWND hDlg, UINT uListID, int& iItem)
{
    LVITEM lvItem;
    LVFINDINFO lvFind;
    TCHAR szStatus[64];
    HWND hwndList = GetDlgItem(hDlg, uListID);

    if ((uListID == IDC_COPYCOMP) &&
        (AnySelection(pComp) || (!pComp->fCustomHide)))
        return FALSE;

    ZeroMemory(&lvItem, sizeof(lvItem));
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvItem.iItem = iItem;
    lvItem.pszText = pComp->szDisplayName;
    if (uListID == IDC_COPYCOMP)
        lvItem.iImage = pComp->fNoCopy ? 0 : 1;
    else
        lvItem.iImage = pComp->fCustomHide ? 0 : 1;
    ZeroMemory(&lvFind, sizeof(lvFind));
    lvFind.flags = LVFI_STRING;
    lvFind.psz = pComp->szDisplayName;

    if (ListView_FindItem(hwndList, -1, &lvFind) == -1)
    {
        ListView_InsertItem(hwndList, &lvItem);
        if (uListID == IDC_HIDECOMP)
        {
            if (pComp->fCustomHide)
            {
                if (AnySelection(pComp))
                    LoadString(g_rvInfo.hInst, IDS_STATUSFORCE, szStatus, countof(szStatus));
                else
                    LoadString(g_rvInfo.hInst, IDS_STATUSNOSHOW, szStatus, countof(szStatus));
            }
            else
                LoadString(g_rvInfo.hInst, IDS_STATUSSHOW, szStatus, countof(szStatus));

            ListView_SetItemText(hwndList, iItem, 1, szStatus);
        }
        iItem++;
    }

    return TRUE;
}

BOOL InitListControl(HWND hDlg, UINT uListID, BOOL fInit)
{
    HWND hwndList = GetDlgItem(hDlg, uListID);
    PCOMPONENT  pComp;
    LV_COLUMN lvCol;
    TCHAR szHeader[MAX_PATH];
    int iItem = 0;
    BOOL bRet = FALSE;

    ListView_DeleteAllItems(hwndList);
    if (uListID == IDC_HIDECOMP)
    {
        ListView_DeleteColumn(hwndList, 1);
        ListView_DeleteColumn(hwndList, 0);
    }

    if (!fInit)
        return TRUE;

    if (uListID == IDC_HIDECOMP)
    {
        ZeroMemory(&lvCol, sizeof(lvCol));
        lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
        lvCol.fmt = LVCFMT_LEFT;
        lvCol.cx = 280;
        LoadString(g_rvInfo.hInst, IDS_COMPNAME, szHeader, countof(szHeader));
        lvCol.pszText = szHeader;
        ListView_InsertColumn(hwndList, 0, &lvCol);

        ZeroMemory(&lvCol, sizeof(lvCol));
        lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
        lvCol.fmt = LVCFMT_LEFT;
        lvCol.cx = 140;
        LoadString(g_rvInfo.hInst, IDS_STATUS, szHeader, countof(szHeader));
        lvCol.pszText = szHeader;
        ListView_InsertColumn(hwndList, 1, &lvCol);
    }

    for (pComp = g_paComp; *pComp->szSection; pComp++)
    {
        if ((pComp->iImage != RED) && pComp->fVisible && !pComp->fAddOnOnly &&
            ((pComp->iCompType != COMP_OPTIONAL) ||
            ((pComp->iCompType == COMP_OPTIONAL) && (pComp->iPlatform <= PLAT_W98))) &&
            (StrCmpI(pComp->szSection, TEXT("DCOM95")) != 0))    // dcom should always be hidden in custom mode
            bRet |= AddItemToList(pComp, hDlg, uListID, iItem);

    }

    for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
        bRet |= AddItemToList(pComp, hDlg, uListID, iItem);

    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);

    return bRet;
}

void CheckItem(HWND hDlg, UINT uListID, LVITEM * plvItem, int iCheck)
{
    HWND hwndList = GetDlgItem(hDlg, uListID);
    PCOMPONENT pComp;
    BOOL fFound = FALSE;
    BOOL fCustomHide = FALSE;
    BOOL fForce = FALSE;

    for (pComp = g_aCustComponents; *pComp->szSection; pComp++)
    {
        if (StrCmpI(plvItem->pszText, pComp->szDisplayName) == 0)
        {
            fForce = AnySelection(pComp);
            if (uListID == IDC_COPYCOMP)
                fCustomHide = (pComp->fNoCopy = ((iCheck == -1) ? !pComp->fNoCopy : (iCheck == 0)));
            else
                fCustomHide = (pComp->fCustomHide = ((iCheck == -1) ? !pComp->fCustomHide : (iCheck == 0)));
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        for (pComp = g_paComp; *pComp->szSection; pComp++)
        {
            if (StrCmpI(plvItem->pszText, pComp->szDisplayName) == 0)
            {
                fForce = AnySelection(pComp);
                if (uListID == IDC_COPYCOMP)
                    fCustomHide = (pComp->fNoCopy = ((iCheck == -1) ? !pComp->fNoCopy : (iCheck == 0)));
                else
                    fCustomHide = (pComp->fCustomHide = ((iCheck == -1) ? !pComp->fCustomHide : (iCheck == 0)));
            }
        }
    }

    plvItem->mask = LVIF_IMAGE;
    plvItem->iImage = fCustomHide ? 0 : 1;

    ListView_SetItem(hwndList, plvItem);
    if (uListID == IDC_HIDECOMP)
    {
        TCHAR szStatus[64];

        if (fCustomHide)
        {
            if (fForce)
                LoadString(g_rvInfo.hInst, IDS_STATUSFORCE, szStatus, countof(szStatus));
            else
                LoadString(g_rvInfo.hInst, IDS_STATUSNOSHOW, szStatus, countof(szStatus));
        }
        else
            LoadString(g_rvInfo.hInst, IDS_STATUSSHOW, szStatus, countof(szStatus));

        ListView_SetItemText(hwndList, plvItem->iItem, 1, szStatus);
    }
}

void MaintToggleCheckItem(HWND hDlg, UINT uListID, int iItem)
{
    LVITEM lvItem;
    TCHAR szDisplayName[MAX_PATH];

    ZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.iItem = iItem;
    lvItem.pszText = szDisplayName;
    lvItem.cchTextMax = countof(szDisplayName);
    lvItem.mask = LVIF_TEXT;

    if (ListView_GetItem(GetDlgItem(hDlg, uListID), &lvItem))
    {
        CheckItem(hDlg, uListID, &lvItem, -1);
    }
}

void ListViewSelectAll(HWND hDlg, UINT uListID, BOOL fSet)
{
    HWND hwndList = GetDlgItem(hDlg, uListID);
    LVITEM lvItem;
    TCHAR szDisplayName[MAX_PATH];
    DWORD dwNumItems, dwIndex;

    dwNumItems = ListView_GetItemCount(hwndList);

    for (dwIndex=0; dwIndex < dwNumItems; dwIndex++)
    {
        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = (int) dwIndex;
        lvItem.iSubItem = 0;
        ZeroMemory(szDisplayName, sizeof(szDisplayName));
        lvItem.pszText = szDisplayName;
        lvItem.cchTextMax = countof(szDisplayName);
        ListView_GetItem(hwndList, &lvItem);

        CheckItem(hDlg, uListID, &lvItem, fSet ? 1 : 0);
    }
}
//
//  FUNCTION: CustomizeCustom(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "Customize Custom" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
BOOL APIENTRY CustomizeCustom(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndList = GetDlgItem(hDlg, IDC_HIDECOMP);
    int iItem;

    switch (message)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDC_HIDECOMP);
            InitList(hDlg, IDC_HIDECOMP);
            break;


        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                case IDC_HIDECHECKALL:
                    ListViewSelectAll(hDlg, IDC_HIDECOMP, TRUE);
                    break;
                case IDC_HIDEUNCHECKALL:
                    ListViewSelectAll(hDlg, IDC_HIDECOMP, FALSE);
                    break;
                }
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case LVN_KEYDOWN:
                    {
                        NMLVKEYDOWN *pnm = (NMLVKEYDOWN*) lParam;
                        if ( pnm->wVKey == VK_SPACE )
                        {
                            iItem = ListView_GetSelectionMark(hwndList);
                            MaintToggleCheckItem(hDlg, IDC_HIDECOMP, iItem);
                        }
                        break;
                    }

                case NM_CLICK:
                    {
                        POINT pointScreen, pointLVClient;
                        DWORD dwPos;
                        LVHITTESTINFO HitTest;

                        dwPos = GetMessagePos();

                        pointScreen.x = LOWORD (dwPos);
                        pointScreen.y = HIWORD (dwPos);

                        pointLVClient = pointScreen;

                        // Convert the point from screen to client coordinates,
                        // relative to the Listview
                        ScreenToClient (hwndList, &pointLVClient);

                        HitTest.pt = pointLVClient;
                        ListView_HitTest(hwndList, &HitTest);

                        // Only if the user clicked on the checkbox icon/bitmap, change
                        if (HitTest.flags == LVHT_ONITEMICON)
                            MaintToggleCheckItem(hDlg, IDC_HIDECOMP, HitTest.iItem);
                    }
                    break;

                case NM_DBLCLK:
                    if ( ((LPNMHDR)lParam)->idFrom == IDC_HIDECOMP)
                    {
                        iItem = ListView_GetSelectionMark(hwndList);
                        MaintToggleCheckItem(hDlg, IDC_HIDECOMP, iItem);
                    }
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    if (!g_fBatch)
                    {
                        BOOL fEnable = (!g_fSilent && !g_fStealth && !GetPrivateProfileInt(IS_BRANDING, TEXT("HideCustom"), 0, g_szCustIns));

                        EnableDlgItem2(hDlg, IDC_HIDECOMP, fEnable);
                        EnableDlgItem2(hDlg, IDC_HIDECHECKALL, fEnable);
                        EnableDlgItem2(hDlg, IDC_HIDEUNCHECKALL, fEnable);

                        InitHiddenItems(IDC_HIDECOMP);
                        InitListControl(hDlg, IDC_HIDECOMP, fEnable);

                        EnableDlgItem2(hDlg, IDC_WEBDLOPT, g_fDownload);
                        if (g_fDownload)
                        {
                            CheckDlgButton(hDlg, IDC_WEBDLOPT,
                                GetPrivateProfileInt(BRANDING, TEXT("NoIELite"), 1, g_szCustIns) ? BST_UNCHECKED : BST_CHECKED);
                        }
                    }
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                    if (!g_fBatch)
                    {
                        BOOL fNoIELite;

                        SaveHiddenItems(IDC_HIDECOMP);
                        if (g_fDownload)
                        {
                            fNoIELite = (IsDlgButtonChecked(hDlg, IDC_WEBDLOPT) == BST_CHECKED) ? FALSE : TRUE;
                            WritePrivateProfileString(BRANDING, TEXT("NoIELite"),
                                fNoIELite ? TEXT("1") : TEXT("0"), g_szCustIns);
                        }
                    }
                    g_iCurPage = PPAGE_CUSTOMCUSTOM;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;


                default:
                    return FALSE;

        }
        break;

        case WM_LV_GETITEMS:
            LVGetItems(GetDlgItem(hDlg, IDC_HIDECOMP));
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

//
//  FUNCTION: CopyComp(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE:  Processes messages for "Copy Custom" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
BOOL APIENTRY CopyComp(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndList = GetDlgItem(hDlg, IDC_COPYCOMP);
    static BOOL s_fNext = TRUE;
    int iItem;

    switch (message)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDC_COPYCOMP);
            InitList(hDlg, IDC_COPYCOMP);
            break;


        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                case IDC_COPYCHECKALL:
                    ListViewSelectAll(hDlg, IDC_COPYCOMP, TRUE);
                    break;
                case IDC_COPYUNCHECKALL:
                    ListViewSelectAll(hDlg, IDC_COPYCOMP, FALSE);
                    break;
                }
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case LVN_KEYDOWN:
                    {
                        NMLVKEYDOWN *pnm = (NMLVKEYDOWN*) lParam;
                        if ( pnm->wVKey == VK_SPACE )
                        {
                            iItem = ListView_GetSelectionMark(hwndList);
                            MaintToggleCheckItem(hDlg, IDC_COPYCOMP, iItem);
                        }
                        break;
                    }

                case NM_CLICK:
                    {
                        POINT pointScreen, pointLVClient;
                        DWORD dwPos;
                        LVHITTESTINFO HitTest;

                        dwPos = GetMessagePos();

                        pointScreen.x = LOWORD (dwPos);
                        pointScreen.y = HIWORD (dwPos);

                        pointLVClient = pointScreen;

                        // Convert the point from screen to client coordinates,
                        // relative to the Listview
                        ScreenToClient (hwndList, &pointLVClient);

                        HitTest.pt = pointLVClient;
                        ListView_HitTest(hwndList, &HitTest);

                        // Only if the user clicked on the checkbox icon/bitmap, change
                        if (HitTest.flags == LVHT_ONITEMICON)
                            MaintToggleCheckItem(hDlg, IDC_COPYCOMP, HitTest.iItem);
                    }
                    break;

                case NM_DBLCLK:
                    if ( ((LPNMHDR)lParam)->idFrom == IDC_COPYCOMP)
                    {
                        iItem = ListView_GetSelectionMark(hwndList);
                        MaintToggleCheckItem(hDlg, IDC_COPYCOMP, iItem);
                    }
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    if (!g_fBatch)
                    {
                        InitHiddenItems(IDC_COPYCOMP);
                        if (!g_fDownload && (g_fSilent || g_fStealth || InsGetBool(IS_BRANDING, TEXT("HideCustom"), FALSE, g_szCustIns)))
                            InitHiddenItems(IDC_HIDECOMP);

                        if (!InitListControl(hDlg, IDC_COPYCOMP, TRUE))
                        {
                            if (s_fNext)
                                PostMessage(GetParent(hDlg), PSM_PRESSBUTTON, PSBTN_NEXT, 0);
                            else
                                PostMessage(GetParent(hDlg), PSM_PRESSBUTTON, PSBTN_BACK, 0);
                        }
                    }
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                    if (!g_fBatch)
                        SaveHiddenItems(IDC_COPYCOMP);

                    g_iCurPage = PPAGE_COPYCOMP;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                    {
                        s_fNext = FALSE;
                        PageNext(hDlg);
                    }
                    else
                    {
                        s_fNext = TRUE;
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;


                default:
                    return FALSE;

        }
        break;

        case WM_LV_GETITEMS:
            LVGetItems(GetDlgItem(hDlg, IDC_COPYCOMP));
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

BOOL g_fUrlsInit = FALSE;

static IDownloadSiteMgr * s_pSiteMgr = NULL;

static int s_aiSites[NUMSITES];

static BOOL s_fInChange = FALSE;

void SetCustSite(HWND hDlg, int iSite)
{
    PSITEDATA psd = &g_aCustSites[iSite];
    HWND hBaseUList = GetDlgItem(hDlg, IDC_BASEURLLIST);
    LV_ITEM lvItem;

    s_fInChange = TRUE;
    ZeroMemory(&lvItem, sizeof(lvItem));
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iSite;
    lvItem.pszText = psd->szName;
    ListView_SetItem(hBaseUList, &lvItem);
    lvItem.iSubItem = 1;
    lvItem.pszText = psd->szUrl;
    ListView_SetItem(hBaseUList, &lvItem);
    lvItem.pszText = psd->szRegion;
    lvItem.iSubItem = 2;
    ListView_SetItem(hBaseUList, &lvItem);
    s_fInChange = FALSE;
}

void CopyAdmFiles()
{
    TCHAR szAdmSrcPath[MAX_PATH];
    TCHAR szAdmSrcFile[MAX_PATH];
    TCHAR szAdmDestFile[MAX_PATH];
    HANDLE hFind = NULL;
    WIN32_FIND_DATA wfdFind;
    BOOL bDirCreated = FALSE;

    PathCombine(szAdmSrcPath, g_szWizRoot, TEXT("iebin"));
    PathAppend(szAdmSrcPath, g_szLanguage);
    PathAppend(szAdmSrcPath, TEXT("optional"));
    PathAppend(szAdmSrcPath, TEXT("*.adm"));

    hFind = FindFirstFile( szAdmSrcPath, &wfdFind );
    if( hFind == INVALID_HANDLE_VALUE )
        return;

    do
    {
        StrCpy(szAdmSrcFile, szAdmSrcPath);
        PathRemoveFileSpec(szAdmSrcFile);
        PathAppend(szAdmSrcFile, wfdFind.cFileName);
        PathCombine(szAdmDestFile, g_szWizRoot, TEXT("policies"));
        PathAppend(szAdmDestFile, g_szLanguage);
        if(!bDirCreated)
        {
            PathCreatePath(szAdmDestFile);
            bDirCreated = TRUE;
        }
        PathAppend(szAdmDestFile, wfdFind.cFileName);
        CopyFile(szAdmSrcFile, szAdmDestFile, FALSE);
        DeleteFile(szAdmSrcFile);
    }while( FindNextFile( hFind, &wfdFind ));

    FindClose(hFind);
}

void SaveDownloadUrls()
{
    int iBase = s_aiSites[0];
    TCHAR szIEAKCabUrl[MAX_URL];
    TCHAR szCabPath[MAX_PATH];
    BOOL fDownloadOpt = TRUE;
    BOOL fIgnore = FALSE;
    static BOOL s_fFirst = TRUE;
    TCHAR szVersionNew[32];
    TCHAR szOptIniFile[MAX_PATH];
    s_fNoNet = FALSE;
    ICifComponent * pCifComponent;

    ResetEvent(g_hProcessInfEvent);

    if (!g_fBatch2)
    {
        if (s_pSiteMgr)
        {
            DOWNLOADSITE *pSite;
            IDownloadSite *pISite;
            TCHAR   szLang[8];

            for (int i=0; i<NUMSITES; i++) 
            {
                s_pSiteMgr->EnumSites(i, &pISite);
                if (!pISite) break;
                pISite->GetData(&pSite);
                A2Tbux(pSite->pszLang, szLang);
                if (0 == StrCmpI(szLang, g_szActLang)) {
                    A2Tbux(pSite->pszUrl, g_szBaseURL);
                    break;
                }
                pISite->Release();
            }
        }
        PathCombine(g_szMastInf, g_szWizRoot, TEXT("iebin"));
        PathAppend(g_szMastInf, g_szLanguage);
        PathAppend(g_szMastInf, TEXT("Optional"));
        PathCreatePath(g_szMastInf);
        PathRemoveBackslash(g_szMastInf);
    }

    // wait for cif to be downloaded so we can check version

    while (MsgWaitForMultipleObjects(1, &g_hCifEvent, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
    {
        MSG msg;

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    if (g_lpCifFileNew != NULL)
    {
        if (!g_fLocalMode)
        {
            // check version before downloading opt cab

            if (SUCCEEDED(g_lpCifFileNew->FindComponent(TEXT("IEAK6OPT"), &pCifComponent)))
            {
                DWORD dwVer, dwBuild;
                TCHAR szVersion[32];

                PathCombine(szOptIniFile, g_szMastInf, TEXT("ieak6opt.ini"));
                pCifComponent->GetVersion(&dwVer, &dwBuild);
                ConvertDwordsToVersionStr(szVersionNew, dwVer, dwBuild);
                GetPrivateProfileString(TEXT("ieak6OPT"), VERSION, TEXT("-1"), szVersion, countof(szVersion), szOptIniFile);

                if ((StrCmp(szVersion, TEXT("-1")) != 0) &&
                    (StrCmpI(szVersion, szVersionNew) == 0))  // is opt cab up to date ?
                    fDownloadOpt = FALSE;
            }
        }
    }

    if (!g_fLocalMode && s_fFirst)
    {
        s_fFirst = FALSE;
        wnsprintf(szIEAKCabUrl, countof(szIEAKCabUrl), TEXT("%s/ieak6opt.cab"), g_szBaseURL);
        PathCombine(szCabPath, g_szBuildTemp, TEXT("ieak6opt.cab"));
        if (fDownloadOpt)
        {
            // if we are attempting to download the opt cab, delete iesetup.inf in the opt dir
            // first and we'll use this as a flag to determine whether or not download &
            // extraction succeeded
            // Also delete ieak6opt.ini. In case the download fails, this will force a download 
            // next time ieak runs. Otherwise iesetup.inf never get created.
            // See bug 13467-IEv60  
            DeleteFileInDir(TEXT("iesetup.inf"), g_szMastInf);
            DeleteFileInDir(TEXT("ieak6opt.ini"), g_szMastInf);
            if (DownloadCab(g_hWizard, szIEAKCabUrl, szCabPath, NULL, 0, fIgnore) == NOERROR)
            {
                if (ExtractFilesWrap(szCabPath, g_szMastInf, 0, NULL, NULL, 0) != NOERROR)
                    DeleteFileInDir(TEXT("iesetup.inf"), g_szMastInf);
                else
                {
                    SetCurrentDirectory( g_szMastInf);
                    SetAttribAllEx(g_szMastInf, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, TRUE);
                    CopyAdmFiles();
                    WritePrivateProfileString(TEXT("ieak6OPT"), VERSION, szVersionNew, szOptIniFile);
                }

                // delete the downloaded ieak6opt.cab from the temp dir so we don't copy
                // it to the target folder during the build process later

                DeleteFile(szCabPath);
            }
        }
    }
    PathCombine(g_szDefInf, g_szMastInf, TEXT("DefFav.inf"));
    PathAppend(g_szMastInf, TEXT("IeSetup.Inf"));
    PathCombine(g_szCustInf, g_szBuildRoot, TEXT("INS"));
    PathAppend(g_szCustInf, GetOutputPlatformDir());
    PathAppend(g_szCustInf, g_szLanguage);
    PathAppend(g_szCustInf, TEXT("IESetup.inf"));

    if (GetFileAttributes(g_szCustInf) == 0xFFFFFFFF)
    {
        CopyFile(g_szMastInf, g_szCustInf, FALSE);
    }
    else
    {
        UpdateInf(g_szMastInf, g_szCustInf);
    }
    SetEvent(g_hProcessInfEvent);
}

void GetSiteDataPath(void)
{
    TCHAR szIEAKIni[MAX_PATH];

    PathCombine(szIEAKIni, g_szWizRoot, TEXT("ieak.ini"));

    switch (g_dwPlatformId)
    {
    case PLATFORM_WIN32:
    default:
        GetPrivateProfileString(TEXT("IEAK"), TEXT("Win32"), TEXT(""), s_szSiteData, countof(s_szSiteData), szIEAKIni);
        break;
    }
}


void IE4BatchSetup()
{
    TCHAR szSectBuf[1024];
    TCHAR szSrcCustInf[MAX_PATH];
    DWORD sWrk, sCif;
    PCOMPONENT pComp;
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    LPTSTR pBack;
    int nComp;

    PathCombine(g_szCustInf, g_szBuildRoot, TEXT("INS"));
    PathAppend(g_szCustInf, GetOutputPlatformDir());
    PathAppend(g_szCustInf, g_szLanguage);
    PathCreatePath(g_szCustInf);

    PathCombine(szSrcCustInf, g_szSrcRoot, TEXT("INS"));
    PathAppend(szSrcCustInf, GetOutputPlatformDir());
    PathAppend(szSrcCustInf, g_szLanguage);

    if (g_fBatch2)
    {
        StrCpy(g_szBaseURL,g_szSrcRoot);
        StrCpy(g_szMastInf,g_szCustInf);

        s_fNoNet = FALSE;
    }

    if (g_fBatch2 && PathFileExists(szSrcCustInf) && PathFileExists(g_szCustInf))
    {
        CopyFilesSrcToDest(szSrcCustInf, TEXT("*.inf"), g_szCustInf);
        CopyFilesSrcToDest(szSrcCustInf, TEXT("*.ins"), g_szCustInf);
        CopyFilesSrcToDest(szSrcCustInf, TEXT("*.cif"), g_szCustInf);
        CopyFilesSrcToDest(szSrcCustInf, TEXT("*.in_"), g_szCustInf);
    }

    PathAppend(g_szCustInf, TEXT("IESetup.inf"));

    // initialize deffav.inf path
    PathCombine(g_szDefInf, g_szWizRoot, TEXT("IEBIN"));
    PathAppend(g_szDefInf, g_szLanguage);
    PathAppend(g_szDefInf, TEXT("OPTIONAL\\DEFFAV.INF"));
    PathCombine(g_szMastInf, g_szWizRoot, TEXT("IESetup.inf"));
    if ((hFind = FindFirstFile( g_szCustInf, &fd )) == INVALID_HANDLE_VALUE)
    {
        CopyFile(g_szMastInf, g_szCustInf, FALSE);
    }
    else
        FindClose(hFind);
    GetSiteDataPath();

    InitCustComponents(NULL);
    sWrk = MAX_PATH;

    GetModuleFileName( NULL, g_szIEAKProg, MAX_PATH );
    pBack = StrRChr(g_szIEAKProg, NULL, TEXT('\\'));
    if (pBack)
        *pBack = TEXT('\0');
    PathAppend(g_szIEAKProg, TEXT("Download"));
    PathAppend(g_szIEAKProg, g_szLanguage);
    PathCreatePath(g_szIEAKProg);
    PathCombine(g_szCif, g_szBuildRoot, TEXT("INS"));
    PathAppend(g_szCif, GetOutputPlatformDir());
    PathAppend(g_szCif, g_szLanguage);
    PathAppend(g_szCif, TEXT("IESetup.cif"));
    if (!PathFileExists(g_szCif))
    {
        TCHAR szCifFile[MAX_PATH];

        PathCombine(szCifFile, g_szIEAKProg, TEXT("IESetup.cif"));
        CopyFile(szCifFile, g_szCif, FALSE);
    }

    StrCpy(s_szCifCabURL, g_szBaseURL);
    StrCat(s_szCifCabURL, TEXT("/IECIF.CAB"));
    StrCpy(s_szCifNew, g_szIEAKProg);
    PathAppend(s_szCifNew, TEXT("new"));
    PathCreatePath(s_szCifNew);
    PathAppend(s_szCifNew, TEXT("IEsetup.cif"));

    {
        IEnumCifModes * pEnumCifModes;
        ICifComponent * pCifComponent;

        GetICifFileFromFile_t(&g_lpCifFileNew, s_szCifNew);
        GetICifRWFileFromFile_t(&g_lpCifRWFile, g_szCif);

        if (!g_lpCifRWFile)
        {
            if (g_hLogFile)
            {
                TCHAR szError[MAX_PATH];
                DWORD dwNumWritten;
                LoadString(g_rvInfo.hInst,IDS_ERROR_CIFRWFILE,szError,MAX_PATH);
                WriteFile(g_hLogFile,szError,StrLen(szError),&dwNumWritten,NULL);
            }    
            return;
        }


        // initialie set of modes

        if (SUCCEEDED(g_lpCifRWFile->EnumModes(&pEnumCifModes,
            PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_MILLEN, NULL)))
        {
            TCHAR szModeID[64];
            ICifMode * pCifMode;
            int i=0;

            while (SUCCEEDED(pEnumCifModes->Next(&pCifMode)))
            {
                CCifMode_t * pCifMode_t = new CCifMode_t((ICifRWMode *)pCifMode);

                pCifMode_t->GetID(szModeID, countof(szModeID));
                g_szAllModes[i] = szModeID[0];
                i++;
                delete pCifMode_t;
            }
            pEnumCifModes->Release();
        }

        // initialize version number
        if (SUCCEEDED(g_lpCifRWFile->FindComponent(BASEWIN32, &pCifComponent)) ||
            SUCCEEDED(g_lpCifRWFile->FindComponent(TEXT("BASEIE40_NTAlpha"), &pCifComponent)))
        {
            DWORD dwVer, dwBuild;

            pCifComponent->GetVersion(&dwVer, &dwBuild);
            ConvertDwordsToVersionStr(g_szJobVersion, dwVer, dwBuild);
        }
    }
    
    sCif = GetPrivateProfileString( NULL, NULL, NULL, szSectBuf, countof(szSectBuf), s_szCifNew );
    nComp = 20 + sCif/4;
    pComp = g_paComp = (PCOMPONENT) LocalAlloc(LPTR, nComp * sizeof(COMPONENT) );
    ZeroMemory(g_paComp, nComp * sizeof(COMPONENT));
}


void UpdateInf(LPTSTR szMasterInf, LPTSTR szUserInf)
{
    TCHAR szInfBack[MAX_PATH];
    LPTSTR pDot, pBuf, pParm;
    SetFileAttributes(szUserInf, FILE_ATTRIBUTE_NORMAL);
    StrCpy(szInfBack, szUserInf);
    pDot = StrRChr(szInfBack, NULL, TEXT('.'));
    if (!pDot) return;
    StrCpy(pDot, TEXT(".bak"));
    DeleteFile( szInfBack );
    MoveFile( szUserInf, szInfBack );
    CopyFile(szMasterInf, szUserInf, FALSE);
    SetFileAttributes(szUserInf, FILE_ATTRIBUTE_NORMAL);
    pBuf = (LPTSTR) LocalAlloc(LPTR, INF_BUF_SIZE);
    if (pBuf)
    {
        GetPrivateProfileString( STRINGS, NULL, TEXT(""), pBuf, ARRAYSIZE(pBuf), szInfBack );
        pParm = pBuf;
        while (*pParm)
        {
            TCHAR szValBuf[MAX_PATH];
            GetPrivateProfileString( STRINGS, pParm, TEXT(""), szValBuf, countof(szValBuf), szInfBack );
            InsWriteQuotedString( STRINGS, pParm, szValBuf, szUserInf );
            pParm += lstrlen(pParm) + 1;
        }
        LocalFree(pBuf);
    }
}

BOOL GotLang(LPTSTR szLang)
{
    int i;

    for (i = 0; i < g_nLangs ; i++ )
    {
        if (StrCmpI(szLang, g_aszLang[i]) == 0) return(TRUE);

    }
    return(FALSE);

}

extern DWORD g_aLangId[];
extern DWORD g_wCurLang;

DWORD DownloadSiteThreadProc(LPVOID)
{
    int i;
    TCHAR szBuf[8];
    TCHAR szLang[8];
    TCHAR szLocaleIni[MAX_PATH];
    DWORD dwErr;
    HWND hBaseUList;
    WIN32_FIND_DATA fd;
    DWORD dwRet = WAIT_OBJECT_0;
    MSG msg;
    LPMULTILANGUAGE pMLang = NULL;
    int iEnglish = 0, iCurLang = 0;

    USES_CONVERSION;

    CoInitialize(NULL);
    g_fCancelled = FALSE;
    dwErr = CoCreateInstance(CLSID_DownloadSiteMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_IDownloadSiteMgr, (void **) &s_pSiteMgr);
    if(!s_pSiteMgr)
    {
        dwErr = GetLastError();
        g_fLangInit = TRUE;
        SendMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
        PropSheet_SetWizButtons(GetParent(g_hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        CoUninitialize();
        return(dwErr);
    }
    g_hDownloadEvent = CreateEvent( NULL, FALSE, FALSE, TEXT("SiteMgrEvent") );
    g_hProcessInfEvent = CreateEvent( NULL, TRUE, FALSE, TEXT("ProcessInfEvent") );
    g_hCifEvent = CreateEvent( NULL, TRUE, FALSE, TEXT("CifEvent") );

    GetSiteDataPath();

    while (!(g_fDone || g_fCancelled))
    {
        if (dwRet == WAIT_OBJECT_0) switch (g_iDownloadState)
        {
            case DOWN_STATE_IDLE:
                break;
            case DOWN_STATE_ENUM_LANG:
                wnsprintf(szBuf, countof(szBuf), TEXT("%04lx"), g_wCurLang);
                PathCombine(szLocaleIni, g_szWizRoot, TEXT("Locale.INI"));
                if (GetPrivateProfileString( IS_ACTIVESETUP, szBuf, TEXT(""), g_szActLang,
                    countof(g_szActLang), szLocaleIni ) == 0)
                {
                    // check for sublocale defaults
                    GetPrivateProfileString( TEXT("SubLocales"), szBuf, TEXT("EN"), g_szActLang,
                    countof(g_szActLang), szLocaleIni );
                }

                iCurLang = -1;
                dwErr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER,
                    IID_IMultiLanguage, (void **) &pMLang);
                if (!g_fLocalMode)
                {
                    TCHAR szMsg[MAX_PATH];

                    LoadString(g_rvInfo.hInst, IDS_AVSINITFAIL, szMsg, countof(szMsg));
                    do
                    {
                        CHAR szSiteDataA[MAX_PATH];

                        dwErr = s_pSiteMgr->Initialize(T2Abux(s_szSiteData, szSiteDataA),  NULL);
                    }
                    while ((dwErr != NOERROR) && (MessageBox(g_hDlg, szMsg, g_szTitle, MB_RETRYCANCEL) == IDRETRY));
                }
                if (dwErr != NOERROR)
                {
                    s_pSiteMgr->Release();
                    s_pSiteMgr = NULL;
                    g_fLocalMode = TRUE;
                }
                if (!g_fLocalMode)
                {
                    for (i = 0, g_nLangs = 0;  ; i++ )
                    {
                        DOWNLOADSITE *pSite;
                        IDownloadSite *pISite;
                        if (!s_pSiteMgr) break;
                        s_pSiteMgr->EnumSites(i, &pISite);
                        if (!pISite) break;
                        pISite->GetData(&pSite);
                        A2Tbux(pSite->pszLang, szLang);
                        if (StrCmpI(szLang, TEXT("US")) == 0)
                            StrCpy(szLang, TEXT("EN"));

                        if (!GotLang(szLang))
                        {
                            if (StrCmpI(szLang, g_szActLang) == 0) iCurLang = g_nLangs;
                            if (StrCmpI(szLang, TEXT("EN")) == 0) iEnglish = g_nLangs;
                            StrCpy(g_aszLang[g_nLangs], szLang);
                            GetPrivateProfileString(IS_STRINGS, szLang, TEXT(""), s_aszLangDesc[g_nLangs], 64, szLocaleIni);
                            if (pMLang)
                            {
                                RFC1766INFO rInfo;
                                LCID lcid;

                                CharLower(szLang);
                                if ((dwErr = GetLcid(&lcid, szLang, szLocaleIni)) == NOERROR)
                                {
                                    g_aLangId[g_nLangs] = lcid;
                                    if (ISNULL(s_aszLangDesc[g_nLangs]))
                                    {
                                        dwErr = pMLang->GetRfc1766Info(lcid, &rInfo);
                                        W2Tbux(rInfo.wszLocaleName, s_aszLangDesc[g_nLangs]);
                                    }
                                }
                            }
                            if (dwErr == NOERROR)
                                SendDlgItemMessage(g_hDlg, IDC_LANGUAGE, CB_ADDSTRING, 0, (LPARAM)s_aszLangDesc[g_nLangs++] );
                            if (g_nLangs >= NUMLANG) break;
                        }
                    }
                    if (iCurLang == -1) iCurLang = iEnglish;
                    if (pMLang) pMLang->Release();
                }
                else
                {
                    TCHAR szDownloadDir[MAX_PATH];
                    BOOL fNoMore = FALSE;
                    HANDLE hFind = NULL;

                    for (i = 0, g_nLangs = 0;  ; i++ )
                    {
                        if (hFind == NULL)
                        {
                            PathCombine(szDownloadDir, g_szIEAKProg, TEXT("*.*"));
                            hFind = FindFirstFile(szDownloadDir, &fd);
                        }
                        else
                            fNoMore = FindNextFile(hFind, &fd) ? FALSE : TRUE;

                        while (!fNoMore && (hFind != INVALID_HANDLE_VALUE) && (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                            || (StrCmp(fd.cFileName, TEXT(".")) == 0) || (StrCmp(fd.cFileName, TEXT("..")) == 0)))
                        {
                            if (!FindNextFile(hFind, &fd))
                            {
                                fNoMore = TRUE;
                                break;
                            }
                        }

                        if (fNoMore)
                        {
                            FindClose(hFind);
                            break;
                        }

                        if (hFind == INVALID_HANDLE_VALUE)
                            break;

                        if (StrCmpI(fd.cFileName, g_szActLang) == 0) iCurLang = g_nLangs;
                        if (StrCmpI(fd.cFileName, TEXT("EN")) == 0) iEnglish = g_nLangs;
                        StrCpy(g_aszLang[g_nLangs], fd.cFileName);
                        GetPrivateProfileString(IS_STRINGS, fd.cFileName, TEXT(""), s_aszLangDesc[g_nLangs], 64, szLocaleIni);
                        if (pMLang)
                        {
                            RFC1766INFO rInfo;
                            LCID lcid;

                            CharLower(fd.cFileName);
                            if ((dwErr = GetLcid(&lcid, fd.cFileName, szLocaleIni)) == NOERROR)
                            {
                                g_aLangId[g_nLangs] = lcid;
                                if (ISNULL(s_aszLangDesc[g_nLangs]))
                                {
                                    dwErr = pMLang->GetRfc1766Info(lcid, &rInfo);
                                    W2Tbux(rInfo.wszLocaleName, s_aszLangDesc[g_nLangs]);
                                }
                            }
                        }
                        if (dwErr == NOERROR)
                            SendDlgItemMessage(g_hDlg, IDC_LANGUAGE, CB_ADDSTRING, 0, (LPARAM)s_aszLangDesc[g_nLangs++] );
                        if (g_nLangs >= NUMLANG) break;
                    }
                    if (iCurLang == -1) iCurLang = iEnglish;
                }
                SendDlgItemMessage( g_hDlg, IDC_LANGUAGE, CB_SETCURSEL, iCurLang, 0 );
                g_fLangInit = TRUE;
                SendMessage( g_hDlg, IDM_INITIALIZE, 0, 0 );
                PropSheet_SetWizButtons(GetParent(g_hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                g_iDownloadState = DOWN_STATE_IDLE;
                break;
            case DOWN_STATE_ENUM_URL:
                hBaseUList = GetDlgItem(g_hDlg, IDC_BASEURLLIST);
                if (*g_szLanguage == TEXT('\\'))
                    StrCpy(szBuf, g_szLanguage + 1);
                else
                    StrCpy(szBuf, g_szLanguage);
                szBuf[2] = TEXT('\0');
                if (s_pSiteMgr)
                {
                    int iSite = 0;
                    SendDlgItemMessage(g_hDlg, IDC_DOWNLOADLIST, CB_RESETCONTENT, 0, 0);
                    for (i = 0; ; i++)
                    {
                        DOWNLOADSITE *pSite;
                        IDownloadSite *pISite;
                        if (!s_pSiteMgr)
                            break;
                        s_pSiteMgr->EnumSites(i, &pISite);
                        if (!pISite)
                            break;
                        pISite->GetData(&pSite);
                        A2Tbux(pSite->pszLang, szLang);

                        if (StrCmpI(szLang, szBuf) == 0)
                        {
                            TCHAR szFriendlyName[MAX_PATH];

                            s_aiSites[iSite++] = i;
                            A2Tbux(pSite->pszFriendlyName, szFriendlyName);
                            SendDlgItemMessage(g_hDlg, IDC_DOWNLOADLIST, CB_ADDSTRING,
                                0, (LPARAM) szFriendlyName );
                        }
                        pISite->Release();
                        if (iSite >= NUMSITES)
                            break;
                    }
                }
                g_fUrlsInit = TRUE;
                SendDlgItemMessage( g_hDlg, IDC_DOWNLOADLIST, CB_SETCURSEL, 0, 0L );
                SetFocus( hBaseUList );
                SendMessage(g_hDlg, IDM_INITIALIZE, 0, 0 );
                PropSheet_SetWizButtons(GetParent(g_hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                g_iDownloadState = DOWN_STATE_IDLE;
                break;
            case DOWN_STATE_SAVE_URL:
                SaveDownloadUrls();
                g_iDownloadState = DOWN_STATE_IDLE;
                break;
        }
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        dwRet = MsgWaitForMultipleObjects(1, &g_hDownloadEvent, FALSE, INFINITE, QS_ALLINPUT);
    }
    if (s_pSiteMgr) s_pSiteMgr->Release();
    s_pSiteMgr = 0;
    if (s_hInet)
    {
        InternetCloseHandle(s_hInet);
        s_hInet = NULL;
    }
    CloseHandle(g_hDownloadEvent);
    CloseHandle(g_hProcessInfEvent);
    CloseHandle(g_hCifEvent);
    g_hDownloadEvent = 0;
    g_hProcessInfEvent = 0;
    g_hCifEvent = 0;
    CoUninitialize();
    return(0);

}

void InitializeUserDownloadSites(HWND hDlg)
{
    int i;
    HWND hBaseUList = GetDlgItem(hDlg, IDC_BASEURLLIST);
    LV_COLUMN lvCol;
    TCHAR szColHead[80];
    PSITEDATA psd;

    if (hDlg != NULL)
    {
        ZeroMemory(&lvCol, sizeof(lvCol));
        lvCol.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
        lvCol.fmt = LVCFMT_LEFT;
        lvCol.cx = 80;
        lvCol.pszText = szColHead;
        LoadString( g_rvInfo.hInst, IDS_DOWNSITEREGION, szColHead, countof(szColHead) );
        lvCol.iSubItem = 3;
        ListView_InsertColumn(hBaseUList, 0, &lvCol);
        lvCol.cx = 125;
        lvCol.iSubItem = 2;
        LoadString( g_rvInfo.hInst, IDS_DOWNSITEURL, szColHead, countof(szColHead) );
        ListView_InsertColumn(hBaseUList, 0, &lvCol);
        lvCol.cx = 125;
        lvCol.iSubItem = 1;
        LoadString( g_rvInfo.hInst, IDS_DOWNSITENAME, szColHead, countof(szColHead) );
        ListView_InsertColumn(hBaseUList, 0, &lvCol);
    }
    for (i = 0, psd = g_aCustSites; ; i++, psd++ )
    {
        TCHAR szBaseUrlParm[32];
        LV_ITEM lvItem;
        LPTSTR pSlash;

        ZeroMemory(psd, sizeof(SITEDATA));
        wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteName%i"), i);
        GetPrivateProfileString(IS_ACTIVESETUP_SITES, szBaseUrlParm, TEXT(""), psd->szName, 80, g_szCustIns );
        if (ISNULL(psd->szName)) break;
        wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteUrl%i"), i);
        GetPrivateProfileString(IS_ACTIVESETUP_SITES, szBaseUrlParm, TEXT(""), psd->szUrl, MAX_URL, g_szCustIns );
        pSlash = StrRChr(psd->szUrl, NULL, TEXT('/'));
        if (pSlash != NULL)
        {
            if (StrCmpI(pSlash, TEXT("/WIN32")) == 0)
            {
                LPTSTR pOld = pSlash;

                *pSlash = TEXT('\0');
                pSlash = StrRChr(psd->szUrl, NULL, TEXT('/'));
                if (pSlash != NULL)
                {
                    if (StrCmpI(pSlash, TEXT("/DOWNLOAD")) == 0)
                    {
                        *pSlash = TEXT('\0');
                    }
                    else
                        *pOld = TEXT('/');
                }
            }
        }
        wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteRegion%i"), i);
        GetPrivateProfileString(IS_ACTIVESETUP_SITES, szBaseUrlParm, TEXT(""), psd->szRegion, 80, g_szCustIns );
        g_nDownloadUrls++;

        if (hDlg != NULL)
        {
            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = i;
            lvItem.pszText = psd->szName;
            ListView_InsertItem(hBaseUList, &lvItem);
            lvItem.iSubItem = 1;
            lvItem.pszText = psd->szUrl;
            ListView_SetItem(hBaseUList, &lvItem);
            lvItem.pszText = psd->szRegion;
            lvItem.iSubItem = 2;
            ListView_SetItem(hBaseUList, &lvItem);
        }
    }

    if (hDlg != NULL)
    {
        if (g_nDownloadUrls)
        {
            SetDlgItemText( hDlg, IDE_DOWNSITENAME, g_aCustSites->szName );
            SetDlgItemText( hDlg, IDE_DOWNSITEURL, g_aCustSites->szUrl );
            SetDlgItemText( hDlg, IDE_DOWNSITEREGION, g_aCustSites->szRegion );
        }
        else
        {
            DisableDlgItem(hDlg, IDE_DOWNSITENAME);
            DisableDlgItem(hDlg, IDE_DOWNSITEURL);
            DisableDlgItem(hDlg, IDE_DOWNSITEREGION);
            DisableDlgItem(hDlg, IDC_DOWNSITENAME_TXT);
            DisableDlgItem(hDlg, IDC_DOWNSITEURL_TXT);
            DisableDlgItem(hDlg, IDC_DOWNSITEREGION_TXT);
        }
        ListView_SetItemState(hBaseUList, 0, LVIS_SELECTED | LVIS_FOCUSED,
            LVIS_SELECTED | LVIS_FOCUSED);
    }
}

void SetDownloadSiteEditControls(HWND hDlg, int nSite)
{
    if (nSite >= 0)
    {
        PSITEDATA psd = &g_aCustSites[nSite];

        SetDlgItemText( hDlg, IDE_DOWNSITENAME, psd->szName );
        SetDlgItemText( hDlg, IDE_DOWNSITEURL, psd->szUrl );
        SetDlgItemText( hDlg, IDE_DOWNSITEREGION, psd->szRegion );
    }
    else
    {
        SetDlgItemText( hDlg, IDE_DOWNSITENAME, TEXT("") );
        SetDlgItemText( hDlg, IDE_DOWNSITEURL, TEXT("") );
        SetDlgItemText( hDlg, IDE_DOWNSITEREGION, TEXT("") );
    }
}

//
//  FUNCTION: ComponentSelect(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "ComponentSelect" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
//
BOOL APIENTRY ComponentUrls(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szDownTpl[MAX_PATH];
    LV_ITEM lvItem;
    HWND hUrlList = GetDlgItem( hDlg, IDC_BASEURLLIST);
    PSITEDATA psd = &g_aCustSites[g_iSelSite];
    static BOOL s_fNext = TRUE;
    static BOOL s_fUserSitesInit = FALSE;
    static BOOL s_fErrMessageShown = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            EnableDBCSChars( hDlg, IDC_BASEURLLIST);
            EnableDBCSChars( hDlg, IDE_DOWNSITENAME);
            EnableDBCSChars( hDlg, IDE_DOWNSITEREGION);
            EnableDBCSChars( hDlg, IDE_DOWNSITEURL );
            break;

        case IDM_INITIALIZE:
            if ((g_hWait != NULL) && g_fUrlsInit)
            {
                SendMessage(g_hWait, WM_CLOSE, 0, 0);
                g_hWait = NULL;
            }
            break;

        case WM_DESTROY:
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                int i;
                switch (LOWORD(wParam))
                {
                    case IDC_ADDBASEURL:
                        if (g_nDownloadUrls && 
                            IsWindowEnabled(GetDlgItem(hDlg, IDE_DOWNSITENAME)) &&
                            (!CheckField(hDlg, IDE_DOWNSITENAME, FC_NONNULL) ||
                            !CheckField(hDlg, IDE_DOWNSITEURL, FC_NONNULL | FC_URL) ||
                            !CheckField(hDlg, IDE_DOWNSITEREGION, FC_NONNULL)))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }

                        ZeroMemory(&lvItem, sizeof(lvItem));
                        lvItem.mask = LVIF_TEXT;
                        ListView_SetItemState(hUrlList, g_iSelSite, LVIS_SELECTED | LVIS_FOCUSED, 0);
                        lvItem.iItem = g_iSelSite = g_nDownloadUrls;
                        psd = &g_aCustSites[g_nDownloadUrls];
                        lvItem.pszText = psd->szName;
                        LoadString( g_rvInfo.hInst, IDS_DOWNLOADURL, szDownTpl, 80 );
                        wnsprintf(psd->szUrl, countof(psd->szUrl), TEXT("http://%s%i"), szDownTpl, g_nDownloadUrls);
                        LoadString( g_rvInfo.hInst, IDS_DOWNLOADSITE, szDownTpl, 80 );
                        wnsprintf(psd->szName, countof(psd->szName), TEXT("%s%i"), szDownTpl, g_nDownloadUrls++);
                        LoadString( g_rvInfo.hInst, IDS_NORTHAMERICA, psd->szRegion, 80 );
                        ListView_InsertItem(hUrlList, &lvItem);
                        SetCustSite(hDlg, g_iSelSite);
                        ListView_SetItemState(hUrlList, g_iSelSite,
                            LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                        if (!IsWindowEnabled(GetDlgItem(GetParent(hDlg), IDC_NEXT)))
                            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                        EnableDlgItem(hDlg, IDE_DOWNSITENAME);
                        EnableDlgItem(hDlg, IDE_DOWNSITEURL);
                        EnableDlgItem(hDlg, IDE_DOWNSITEREGION);
                        EnableDlgItem(hDlg, IDC_REMOVEBASEURL);
                        EnableDlgItem(hDlg, IDC_DOWNSITENAME_TXT);
                        EnableDlgItem(hDlg, IDC_DOWNSITEURL_TXT);
                        EnableDlgItem(hDlg, IDC_DOWNSITEREGION_TXT);

                        SetFocus(GetDlgItem( hDlg, IDE_DOWNSITENAME));
                        EnableDlgItem2(hDlg, IDC_ADDBASEURL, (g_nDownloadUrls < ((g_fIntranet && (g_fSilent || g_fStealth)) ? 1 : 10)));
                        SendMessage(GetDlgItem( hDlg, IDE_DOWNSITENAME), EM_SETSEL, 0, -1);
                        break;

                    case IDC_REMOVEBASEURL:
                        s_fInChange = TRUE;
                        if(ListView_DeleteItem(hUrlList, g_iSelSite))
                        {
                            for (i = g_iSelSite; i <= g_nDownloadUrls ; i++)
                            {
                                g_aCustSites[i] = g_aCustSites[i + 1];
                            }
                            g_nDownloadUrls--;
                        }
                        s_fInChange = FALSE;

                        EnableDlgItem2(hDlg, IDC_ADDBASEURL, (g_nDownloadUrls < ((g_fIntranet && (g_fSilent || g_fStealth)) ? 1 : 10)));
                        if (g_nDownloadUrls == 0) {
                            int rgids[] = { IDE_DOWNSITENAME, IDE_DOWNSITEURL, IDE_DOWNSITEREGION, IDC_REMOVEBASEURL };
                            int rgtxtids[] = { IDC_DOWNSITENAME_TXT, IDC_DOWNSITEURL_TXT, IDC_DOWNSITEREGION_TXT };

                            ZeroMemory(g_aCustSites, sizeof(COMPONENT));

                            EnsureDialogFocus(hDlg, rgids, countof(rgids), IDC_ADDBASEURL);
                            DisableDlgItems  (hDlg, rgids, countof(rgids));
                            DisableDlgItems  (hDlg, rgtxtids, countof(rgtxtids));

                            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                        }
                        if (g_iSelSite >= g_nDownloadUrls) g_iSelSite--;
                        SetDownloadSiteEditControls(hDlg, g_iSelSite);
                        ListView_SetItemState(hUrlList, g_iSelSite,
                            LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                        break;
                }
            }
            else if (HIWORD(wParam) == EN_CHANGE)
            {
                switch (LOWORD(wParam))
                {
                    case IDE_DOWNSITENAME:
                        GetDlgItemText( hDlg, IDE_DOWNSITENAME, psd->szName, countof(psd->szName) );
                        break;
                    case IDE_DOWNSITEURL:
                        GetDlgItemText( hDlg, IDE_DOWNSITEURL, psd->szUrl, countof(psd->szUrl) );
                        break;
                    case IDE_DOWNSITEREGION:
                        GetDlgItemText( hDlg, IDE_DOWNSITEREGION, psd->szRegion, countof(psd->szRegion) );
                        break;
                }
                SetCustSite(hDlg, g_iSelSite);

            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                int i;

                case LVN_ITEMCHANGED:
                case LVN_ITEMCHANGING:
                    if (s_fInChange) break;

                    // BUGBUG: <oliverl> crazy hack to eat up the second LVN_ITEMCHANGING
                    //          msg we get in the error case.  I can't figure out any way
                    //          to distinguish the two.

                    if ((g_nDownloadUrls > 1) && s_fErrMessageShown && 
                        (!GetDlgItemText(hDlg, IDE_DOWNSITENAME, szDownTpl, countof(szDownTpl)) ||
                        !GetDlgItemText(hDlg, IDE_DOWNSITEURL, szDownTpl, countof(szDownTpl)) ||
                        !PathIsURL(szDownTpl) || 
                        !GetDlgItemText(hDlg, IDE_DOWNSITEREGION, szDownTpl, countof(szDownTpl))))
                    {
                        s_fErrMessageShown = FALSE;
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    if ((g_nDownloadUrls > 1) &&
                        (!CheckField(hDlg, IDE_DOWNSITENAME, FC_NONNULL) ||
                         !CheckField(hDlg, IDE_DOWNSITENAME, FC_NONNULL) ||
                         !CheckField(hDlg, IDE_DOWNSITENAME, FC_NONNULL)))
                    {
                        s_fErrMessageShown = TRUE;
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    for (i = 0; i < g_nDownloadUrls ; i++ )
                    {
                        DWORD dwState = ListView_GetItemState(hUrlList, i, LVIS_SELECTED | LVIS_FOCUSED);
                        if (dwState == (LVIS_FOCUSED | LVIS_SELECTED))
                        {
                            g_iSelSite = i;
                            SetDownloadSiteEditControls(hDlg, g_iSelSite);
                        }

                    }
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    if (!s_fUserSitesInit)
                    {
                        InitializeUserDownloadSites(hDlg);
                        s_fUserSitesInit = TRUE;
                    }

                    if (!PageEnabled(PPAGE_COMPURLS))
                        PostMessage(GetParent(hDlg), PSM_PRESSBUTTON, s_fNext ? PSBTN_NEXT : PSBTN_BACK, 0);
                    else
                    {
                        SetBannerText(hDlg);
                        EnableDlgItem2(hDlg, IDC_ADDBASEURL, (g_nDownloadUrls < ((g_fIntranet && (g_fSilent || g_fStealth)) ? 1 : 10)));
                        EnableDlgItem2(hDlg, IDC_REMOVEBASEURL, (g_nDownloadUrls != 0));
                        PropSheet_SetWizButtons(GetParent(hDlg), (g_nDownloadUrls == 0) ? PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
                        CheckBatchAdvance(hDlg);
                    }
                    break;


                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                    WritePrivateProfileString( IS_ACTIVESETUP_SITES, NULL, NULL, g_szCustIns );
                    for (i = 0, psd = g_aCustSites; i < 10 ; i++, psd++ )
                    {
                        TCHAR szBaseUrlParm[32];
                        LPTSTR pSlash;

                        if (ISNONNULL(psd->szUrl) && !PathIsURL(psd->szUrl))
                        {
                            ErrorMessageBox(hDlg, IDS_INVALID_URL);
                            SetCustSite(hDlg, i);
                            SetFocus(hUrlList);
                            ListView_SetItemState(hUrlList, i, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }

                        pSlash = StrRChr(psd->szUrl, NULL, TEXT('/'));
                        if (pSlash != NULL)
                        {
                            if (StrCmpI(pSlash, TEXT("/WIN32")) == 0)
                            {
                                LPTSTR pOld = pSlash;

                                *pSlash = TEXT('\0');
                                pSlash = StrRChr(psd->szUrl, NULL, TEXT('/'));
                                if (pSlash != NULL)
                                {
                                    if (StrCmpI(pSlash, TEXT("/DOWNLOAD")) == 0)
                                    {
                                        *pSlash = TEXT('\0');
                                    }
                                    else
                                        *pOld = TEXT('/');
                                }
                            }
                        }

                        if (!g_fBatch && (i < g_nDownloadUrls) && (ISNULL(psd->szUrl)
                             || ISNULL(psd->szName) || ISNULL(psd->szRegion)))
                        {
                            ErrorMessageBox(hDlg, IDS_BLANKSITE);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                        if ((StrChr(psd->szName, TEXT(',')) != NULL) ||
                            (StrChr(psd->szRegion, TEXT(',')) != NULL))
                        {
                            ErrorMessageBox(hDlg, IDS_ERROR_COMMA);
                            SetCustSite(hDlg, i);
                            SetFocus(hUrlList);
                            ListView_SetItemState(hUrlList, i, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                        if (psd->szUrl[lstrlen(psd->szUrl)-1] == TEXT('/'))
                            psd->szUrl[lstrlen(psd->szUrl)-1] = TEXT('\0');
                        if(!g_fOCW && ISNONNULL(psd->szUrl))
                        {
                            StrCat(psd->szUrl, TEXT("/DOWNLOAD/"));
                            StrCat(psd->szUrl, GetOutputPlatformDir());
                            psd->szUrl[lstrlen(psd->szUrl)-1] = TEXT('\0');
                        }
                        wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteUrl%i"), i);
                        WritePrivateProfileString( IS_ACTIVESETUP_SITES, szBaseUrlParm, psd->szUrl, g_szCustIns );
                        wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteName%i"), i);
                        WritePrivateProfileString( IS_ACTIVESETUP_SITES, szBaseUrlParm, psd->szName, g_szCustIns );
                        wnsprintf(szBaseUrlParm, countof(szBaseUrlParm), TEXT("SiteRegion%i"), i);
                        WritePrivateProfileString( IS_ACTIVESETUP_SITES, szBaseUrlParm, psd->szRegion, g_szCustIns );
                    }

                    g_iCurPage = PPAGE_COMPURLS;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                    {
                        s_fNext = FALSE;
                        PageNext(hDlg);
                    }
                    else
                    {
                        s_fNext = TRUE;
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}


BOOL CALLBACK AddOnDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fNoAddon,
         fDefAddon,
         fCustAddon,
         fUseMSSite;
    TCHAR szAddOnUrl[INTERNET_MAX_URL_LENGTH],
          szMenuText[128];
    INT id;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDE_ADDONURL);
            Edit_LimitText(GetDlgItem(hDlg, IDE_ADDONURL), countof(szAddOnUrl) - 1);

            EnableDBCSChars(hDlg, IDE_MENUTEXT);
            Edit_LimitText(GetDlgItem(hDlg, IDE_MENUTEXT), countof(szMenuText) - 1);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    // no addon menu is available only in the corp mode
                    if (g_fIntranet)
                    {
                        fNoAddon = InsGetBool(IS_BRANDING, IK_NO_ADDON, FALSE, g_szCustIns);
                        ShowWindow(GetDlgItem(hDlg, IDC_NO_ADDON), SW_SHOW);
                    }
                    else
                    {
                        fNoAddon = FALSE;
                        ShowWindow(GetDlgItem(hDlg, IDC_NO_ADDON), SW_HIDE);
                    }
                    fDefAddon  = InsGetBool(IS_BRANDING, IK_DEF_ADDON,  FALSE, g_szCustIns);
                    fCustAddon = InsGetBool(IS_BRANDING, IK_CUST_ADDON, FALSE, g_szCustIns);

                    if (fNoAddon)
                        id = IDC_NO_ADDON;
                    else if (fDefAddon)
                        id = IDC_DEF_ADDON;
                    else if (fCustAddon)
                        id = IDC_CUST_ADDON;
                    else
                        id = IDC_DEF_ADDON;                                     // default radio button
                    CheckRadioButton(hDlg, IDC_NO_ADDON, IDC_CUST_ADDON, id);

                    GetPrivateProfileString(IS_BRANDING, IK_HELP_MENU_TEXT, TEXT(""), szMenuText, countof(szMenuText), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_MENUTEXT, szMenuText);

                    GetPrivateProfileString(IS_BRANDING, IK_ADDONURL, TEXT(""), szAddOnUrl, countof(szAddOnUrl), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_ADDONURL, szAddOnUrl);

                    EnableDlgItem2(hDlg, IDC_MENUTEXT, fCustAddon);
                    EnableDlgItem2(hDlg, IDE_MENUTEXT, fCustAddon);

                    EnableDlgItem2(hDlg, IDC_ADDONURL, fCustAddon);
                    EnableDlgItem2(hDlg, IDE_ADDONURL, fCustAddon);

                    fUseMSSite = InsGetBool(IS_BRANDING, IK_ALT_SITES_URL, FALSE, g_szCustIns);
                    CheckDlgButton(hDlg, IDC_MSDL, fUseMSSite ? BST_CHECKED : BST_UNCHECKED);

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    if (IsDlgButtonChecked(hDlg, IDC_CUST_ADDON) == BST_CHECKED)
                        if (!CheckField(hDlg, IDE_MENUTEXT, FC_NONNULL)  ||
                            !CheckField(hDlg, IDE_ADDONURL, FC_NONNULL | FC_URL))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                    if (g_fIntranet)
                        fNoAddon = (IsDlgButtonChecked(hDlg, IDC_NO_ADDON) == BST_CHECKED);
                    else
                        fNoAddon = FALSE;
                    fDefAddon  = (IsDlgButtonChecked(hDlg, IDC_DEF_ADDON)  == BST_CHECKED);
                    fCustAddon = (IsDlgButtonChecked(hDlg, IDC_CUST_ADDON) == BST_CHECKED);

                    if ((!g_fBatch) && (!g_fBatch2))
                    {
                        InsWriteBool(IS_BRANDING, IK_NO_ADDON,   fNoAddon,   g_szCustIns);
                        InsWriteBool(IS_BRANDING, IK_DEF_ADDON,  fDefAddon,  g_szCustIns);
                        InsWriteBool(IS_BRANDING, IK_CUST_ADDON, fCustAddon, g_szCustIns);
                    }

                    GetDlgItemText(hDlg, IDE_MENUTEXT, szMenuText, countof(szMenuText));
                    InsWriteString(IS_BRANDING, IK_HELP_MENU_TEXT, szMenuText, g_szCustIns);

                    GetDlgItemText(hDlg, IDE_ADDONURL, szAddOnUrl, countof(szAddOnUrl));
                    InsWriteString(IS_BRANDING, IK_ADDONURL, szAddOnUrl, g_szCustIns);

                    fUseMSSite = (IsDlgButtonChecked(hDlg, IDC_MSDL) == BST_CHECKED);
                    InsWriteBool(IS_BRANDING, IK_ALT_SITES_URL, fUseMSSite, g_szCustIns);

                    g_iCurPage = PPAGE_ADDON;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        case IDC_NO_ADDON:
                        case IDC_DEF_ADDON:
                        case IDC_CUST_ADDON:
                            fCustAddon = (IsDlgButtonChecked(hDlg, IDC_CUST_ADDON) == BST_CHECKED);

                            EnableDlgItem2(hDlg, IDC_MENUTEXT, fCustAddon);
                            EnableDlgItem2(hDlg, IDE_MENUTEXT, fCustAddon);

                            EnableDlgItem2(hDlg, IDC_ADDONURL, fCustAddon);
                            EnableDlgItem2(hDlg, IDE_ADDONURL, fCustAddon);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
//  FUNCTION: UserAgentString(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "UserAgentString" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
//
BOOL APIENTRY UserAgentString( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    BOOL fChecked = FALSE;

    switch( msg )
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDC_UASTRING);
        Edit_LimitText(GetDlgItem(hDlg, IDC_UASTRING), MAX_PATH - 1);
        g_hWizard = hDlg;
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_UASTRINGCHECK:
                fChecked = (IsDlgButtonChecked(hDlg, IDC_UASTRINGCHECK) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDC_UASTRING, fChecked);
                EnableDlgItem2(hDlg, IDC_UASTRING_TXT, fChecked);
                break;

            default:
                return FALSE;
        }
        break;
    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {

            case PSN_HELP:
                IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                break;

            case PSN_SETACTIVE:
                SetBannerText(hDlg);
                SetDlgItemTextFromIns(hDlg, IDC_UASTRING, IDC_UASTRINGCHECK, IS_BRANDING,
                    USER_AGENT, g_szCustIns, NULL, INSIO_TRISTATE);
                EnableDlgItem2(hDlg, IDC_UASTRING_TXT, (IsDlgButtonChecked(hDlg, IDC_UASTRINGCHECK) == BST_CHECKED));
                CheckBatchAdvance(hDlg);
                break;

            case PSN_WIZBACK:
            case PSN_WIZNEXT:
                g_iCurPage = PPAGE_UASTRDLG;
                WriteDlgItemTextToIns(hDlg, IDC_UASTRING, IDC_UASTRINGCHECK, IS_BRANDING,
                    USER_AGENT, g_szCustIns, NULL, INSIO_TRISTATE);
                EnablePages();
                (((LPNMHDR)lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                break;

            case PSN_QUERYCANCEL:
                QueryCancel(hDlg);
                break;

            default:
                return FALSE;
    }
    break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL CALLBACK ActiveSetupDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szActSetupTitle[50];

    switch (uMsg)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDE_TITLE);
            EnableDBCSChars(hDlg, IDE_WIZBITMAPPATH);
            EnableDBCSChars(hDlg, IDE_WIZBITMAPPATH2);
            EnableDBCSChars(hDlg, IDC_CCTITLE);

            Edit_LimitText(GetDlgItem(hDlg, IDE_TITLE),          countof(szActSetupTitle) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_WIZBITMAPPATH),  MAX_PATH - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_WIZBITMAPPATH2), MAX_PATH - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDC_CCTITLE),        countof(g_szCustItems) - 1);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    TCHAR szActSetupBitmap[MAX_PATH];

                    SetBannerText(hDlg);

                    // IEAKLite mode clean-up: delete the bmp files from the temp dir
                    DeleteFileInDir(TEXT("actsetup.bmp"), g_szBuildTemp);
                    DeleteFileInDir(TEXT("topsetup.bmp"), g_szBuildTemp);

                    // read title
                    GetPrivateProfileString(IS_ACTIVESETUP, IK_WIZTITLE, TEXT(""), szActSetupTitle, countof(szActSetupTitle), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_TITLE, szActSetupTitle);

                    // read left bitmap path
                    GetPrivateProfileString(IS_ACTIVESETUP, IK_WIZBMP, TEXT(""), szActSetupBitmap, countof(szActSetupBitmap), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_WIZBITMAPPATH, szActSetupBitmap);

                    // read top banner bitmap path
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDE_WIZBITMAPPATH2)))
                    {
                        GetPrivateProfileString(IS_ACTIVESETUP, IK_WIZBMP2, TEXT(""), szActSetupBitmap, countof(szActSetupBitmap), g_szCustIns);
                        SetDlgItemText(hDlg, IDE_WIZBITMAPPATH2, szActSetupBitmap);
                    }

                    // read cutom components title
                    if (g_nCustComp)
                    {
                        GetPrivateProfileString(STRINGS, CUSTITEMS, TEXT(""), g_szCustItems, countof(g_szCustItems), g_szCustInf);
                        if (*g_szCustItems == TEXT('\0'))
                            LoadString(g_rvInfo.hInst, IDS_CUSTOMCOMPTITLE, g_szCustItems, countof(g_szCustItems));
                    }
                    else
                        *g_szCustItems = TEXT('\0');
                    SetDlgItemText(hDlg, IDC_CCTITLE, g_szCustItems);
                    EnableDlgItem2(hDlg, IDC_CCTITLE, *g_szCustItems ? TRUE : FALSE);
                    EnableDlgItem2(hDlg, IDC_CCTITLE_TXT, *g_szCustItems ? TRUE : FALSE);

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
                    CheckBatchAdvance(hDlg);
                    break;
                }

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                {
                    TCHAR szActSetupBitmap[MAX_PATH] = TEXT(""),
                          szActSetupBitmap2[MAX_PATH] = TEXT("");
                    LPCTSTR pszTmp;

                    if (!IsBitmapFileValid(hDlg, IDE_WIZBITMAPPATH, szActSetupBitmap, NULL, 164, 312, IDS_TOOBIG164x312, IDS_TOOSMALL164x312))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }

                    // error checking for top bitmap
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDE_WIZBITMAPPATH2)))
                    {
                        if (!IsBitmapFileValid(hDlg, IDE_WIZBITMAPPATH2, szActSetupBitmap2, NULL, 496, 56, IDS_TOOBIG496x56, IDS_TOOSMALL496x56))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                    }
                    else
                        *szActSetupBitmap2 = TEXT('\0');

                    // error checking for custom components title
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CCTITLE)))
                    {
                        GetDlgItemText(hDlg, IDC_CCTITLE, g_szCustItems, countof(g_szCustItems));

                        if (*g_szCustItems == TEXT('\0'))
                        {
                            ErrorMessageBox(hDlg, IDS_CUSTOMCOMPTITLE_ERROR);
                            SetFocus(GetDlgItem(hDlg, IDC_CCTITLE));

                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                    }
                    else
                        *g_szCustItems = TEXT('\0');

                    // write title
                    GetDlgItemText(hDlg, IDE_TITLE, szActSetupTitle, countof(szActSetupTitle));

                    pszTmp = (*szActSetupTitle ? szActSetupTitle : NULL);

                    WritePrivateProfileString(IS_ACTIVESETUP, IK_WIZTITLE, pszTmp, g_szCustIns);
                    InsWriteQuotedString(BRANDING, IK_WIZTITLE, pszTmp, g_szCustInf);

                    // write left bitmap path
                    if (*szActSetupBitmap)
                    {
                        TCHAR szDest[MAX_PATH];

                        pszTmp = szActSetupBitmap;

                        PathCombine(szDest, g_szBuildTemp, TEXT("actsetup.bmp"));
                        CopyFile(szActSetupBitmap, szDest, FALSE);
                    }
                    else
                        pszTmp = NULL;

                    InsWriteQuotedString(IS_ACTIVESETUP, IK_WIZBMP, pszTmp, g_szCustIns);
                    InsWriteQuotedString(BRANDING, IK_WIZBMP, pszTmp != NULL ? TEXT("actsetup.bmp") : NULL, g_szCustInf);

                    // write top bitmap path
                    if (*szActSetupBitmap2)
                    {
                        TCHAR szDest[MAX_PATH];

                        pszTmp = szActSetupBitmap2;

                        PathCombine(szDest, g_szBuildTemp, TEXT("topsetup.bmp"));
                        CopyFile(szActSetupBitmap2, szDest, FALSE);
                    }
                    else
                        pszTmp = NULL;

                    InsWriteQuotedString(IS_ACTIVESETUP, IK_WIZBMP2, pszTmp, g_szCustIns);
                    InsWriteQuotedString(BRANDING, IK_WIZBMP2, pszTmp != NULL ? TEXT("topsetup.bmp") : NULL, g_szCustInf);

                    // write custom components title
                    pszTmp = (*g_szCustItems ? g_szCustItems : NULL);
                    InsWriteQuotedString(STRINGS, CUSTITEMS, pszTmp, g_szCustInf);

                    g_iCurPage = PPAGE_SETUPWIZARD;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;
                }

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        TCHAR szActSetupBitmap[MAX_PATH];

                        case IDC_BROWSEWIZPATH:
                            GetDlgItemText(hDlg, IDE_WIZBITMAPPATH, szActSetupBitmap, countof(szActSetupBitmap));
                            if (BrowseForFile(hDlg, szActSetupBitmap, countof(szActSetupBitmap), GFN_BMP))
                                SetDlgItemText(hDlg, IDE_WIZBITMAPPATH, szActSetupBitmap);
                            break;

                        case IDC_BROWSEWIZPATH2:
                            GetDlgItemText(hDlg, IDE_WIZBITMAPPATH2, szActSetupBitmap, countof(szActSetupBitmap));
                            if (BrowseForFile(hDlg, szActSetupBitmap, countof(szActSetupBitmap), GFN_BMP))
                                SetDlgItemText(hDlg, IDE_WIZBITMAPPATH2, szActSetupBitmap);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

#define MINCMAKVER  TEXT("4.71.0819.0")

BOOL g_fCustomICMPro = FALSE;

BOOL APIENTRY InternetConnMgr(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szCmd[MAX_PATH+8];
    LPTSTR pName;
    DWORD dwSize;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            InitSysFont( hDlg, IDE_ICMPRO);

            //BUGBUG: (a-saship) for now disable CMAK and once its confirmed remove all references to CMAK
            DisableDlgItem(hDlg, IDC_STARTCMAK);
            HideDlgItem(hDlg, IDC_STARTCMAK);
            HideDlgItem(hDlg, IDC_CMAKICON);

            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
                switch(LOWORD(wParam))
                {
                    case IDC_BROWSEICMPRO:
                        GetDlgItemText(hDlg, IDE_ICMPRO, g_szCustIcmPro, countof(g_szCustIcmPro));
                        if (BrowseForFile(hDlg, g_szCustIcmPro, countof(g_szCustIcmPro), GFN_EXE))
                            SetDlgItemText(hDlg, IDE_ICMPRO, g_szCustIcmPro);
                        break;

                    case IDC_ICMPROCHECK:
                        g_fCustomICMPro = (IsDlgButtonChecked( hDlg, IDC_ICMPROCHECK ) == BST_CHECKED);
                        EnableDlgItem2(hDlg, IDE_ICMPRO, g_fCustomICMPro);
                        EnableDlgItem2(hDlg, IDC_BROWSEICMPRO, g_fCustomICMPro);
                        EnableDlgItem2(hDlg, IDC_ICMPRO_TXT, g_fCustomICMPro);

                        break;
                    case IDC_STARTCMAK:
                        dwSize = sizeof(szCmd);
                        if (SHGetValue(HKEY_LOCAL_MACHINE, CURRENTVERSIONKEY TEXT("\\App Paths\\cmak.exe"), NULL,  NULL,
                            (LPVOID)szCmd, &dwSize) == ERROR_SUCCESS)
                        {
                            DWORD dwExitCode;
                            StrCat(szCmd, TEXT(" /i"));
                            if (RunAndWait(szCmd, g_szWizRoot, SW_SHOW, &dwExitCode) && (dwExitCode == IDOK))
                            {
                                dwSize = sizeof(g_szCustIcmPro);

                                if (SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Connection Manager Administration Kit"),
                                    TEXT("Output"), NULL, (LPVOID)g_szCustIcmPro, &dwSize) == ERROR_SUCCESS)
                                {
                                    g_fCustomICMPro = TRUE;
                                    EnableDlgItem2(hDlg, IDE_ICMPRO, g_fCustomICMPro);
                                    EnableDlgItem2(hDlg, IDC_BROWSEICMPRO, g_fCustomICMPro);
                                    EnableDlgItem2(hDlg, IDC_ICMPRO_TXT, g_fCustomICMPro);
                                    SetDlgItemText(hDlg, IDE_ICMPRO, g_szCustIcmPro);
                                    CheckDlgButton(hDlg, IDC_ICMPROCHECK, BST_CHECKED);
                                }
                            }
                        }
                        else
                            ErrorMessageBox(hDlg, IDS_NOCMAK);
                        break;
                }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    g_fCustomICMPro = GetPrivateProfileInt( BRANDING, CMUSECUSTOM, 0, g_szCustIns );
                    CheckDlgButton( hDlg, IDC_ICMPROCHECK, g_fCustomICMPro );
                    GetPrivateProfileString( BRANDING, CMPROFILEPATH, TEXT(""),
                        g_szCustIcmPro, countof(g_szCustIcmPro), g_szCustIns );
                    SetDlgItemText( hDlg, IDE_ICMPRO, g_szCustIcmPro );
                    EnableDlgItem2(hDlg, IDE_ICMPRO, g_fCustomICMPro);
                    EnableDlgItem2(hDlg, IDC_BROWSEICMPRO, g_fCustomICMPro);
                    EnableDlgItem2(hDlg, IDC_ICMPRO_TXT, g_fCustomICMPro);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    GetDlgItemText( hDlg, IDE_ICMPRO, g_szCustIcmPro, countof(g_szCustIcmPro) );
                    if(IsDlgButtonChecked(hDlg, IDC_ICMPROCHECK) == BST_CHECKED && !CheckField(hDlg, IDE_ICMPRO, FC_NONNULL | FC_FILE | FC_EXISTS))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }
                    WritePrivateProfileString( BRANDING, CMPROFILEPATH, g_szCustIcmPro, g_szCustIns );
                    pName = StrRChr(g_szCustIcmPro, NULL, TEXT('\\'));
                    if (pName) pName++;
                    else pName = g_szCustIcmPro;
                    WritePrivateProfileString( BRANDING, CMPROFILENAME, pName, g_szCustIns );
                    WritePrivateProfileString( BRANDING, CMUSECUSTOM, (g_fCustomICMPro ? TEXT("1") : TEXT("0")), g_szCustIns);
                    if (g_fCustomICMPro)
                    {
                        TCHAR szDisplayName[MAX_PATH];
                        TCHAR szGUID[MAX_PATH];
                        TCHAR szUrl[80];
                        TCHAR szVersion[64];
                        LPTSTR pFile, pDot;
                        DWORD dwVer, dwBuild;
                        GUID guid;

                        GetVersionFromFileWrap(g_szCustIcmPro, &dwVer, &dwBuild, TRUE);
                        ConvertDwordsToVersionStr(szVersion, dwVer, dwBuild);

                        if (CheckVer(szVersion, MINCMAKVER) <= 0)
                        {
                            ErrorMessageBox(hDlg, IDS_ERROR_CMAKVER);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                        GetPrivateProfileString( CUSTCMSECT, TEXT("GUID"), TEXT(""), szGUID, countof(szGUID), g_szCustCif );
                        if (ISNULL(szGUID))
                        {
                            if (CoCreateGuid(&guid) == NOERROR)
                                CoStringFromGUID(guid, szGUID, countof(szGUID));
                        }
                        LoadString( g_rvInfo.hInst, IDS_CUSTICMPRO, szDisplayName, countof(szDisplayName) );
                        InsWriteQuotedString( CUSTCMSECT, TEXT("DisplayName"), szDisplayName, g_szCustCif );
                        InsWriteQuotedString( CUSTCMSECT, TEXT("GUID"),  szGUID,  g_szCustCif );
                        InsWriteQuotedString( CUSTCMSECT, TEXT("Command1"), pName,  g_szCustCif );

                        wnsprintf(szUrl, countof(szUrl), TEXT("%s"), pName);
                        WritePrivateProfileString( CUSTCMSECT, TEXT("URL1"), szUrl, g_szCustCif );
                        pFile = PathFindFileName(g_szCustIcmPro);
                        pDot = StrChr(pFile, TEXT('.'));
                        if (pDot)
                            *pDot = TEXT('\0');
                        wnsprintf(szDisplayName, countof(szDisplayName), TEXT("/q:a /r:n /c:\"cmstp.exe /i %s.inf\""), pFile);
                        if (pDot)
                            *pDot = TEXT('.');
                        InsWriteQuotedString( CUSTCMSECT, TEXT("Switches1"), szDisplayName, g_szCustCif );
                        WritePrivateProfileString( CUSTCMSECT, TEXT("Type1"), TEXT("2"), g_szCustCif );
                        // bump up the version number if it already exists, otherwise use the defined version in
                        // iedkbrnd.h

                        if (GetPrivateProfileString( CUSTCMSECT, VERSION, g_szJobVersion, szVersion, countof(szVersion), g_szCustCif ))
                        {
                            LPTSTR pComma;
                            INT iVer;

                            pComma = StrRChr(szVersion, NULL, TEXT(','));
                            if (pComma == NULL)
                                pComma = szVersion;
                            iVer = StrToInt( pComma + 1 );
                            iVer++;

                            wnsprintf(pComma, MAX_PATH, TEXT(",%i"), iVer);
                            WritePrivateProfileString(CUSTCMSECT, VERSION, szVersion, g_szCustCif);
                        }
                    }
                    else
                    {
                        WritePrivateProfileString( CUSTCMSECT, NULL, NULL, g_szCustCif );
                    }
                    g_iCurPage = PPAGE_ICM;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;


                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\ie4comp.h ===
// shared defines between ie4comp.cpp and buildie.cpp

// AVS states and base components
#define COMP_OPTIONAL 0
#define COMP_CORE 1
#define COMP_SERVER 2

#define BROWN  0
#define BROWN2 1
#define BLUE   2
#define BLUE2  3
#define RED    4
#define YELLOW 5
#define GREEN  6

// custom components

#define INST_CAB 0
#define INST_EXE 2
#define MAXCUST 16

//Indicates the last predefined sourcefiles section in ie4cust.sed + 1
#define SED_START_INDEX 5

#define PLAT_I386 0
#define PLAT_W98 1
#define PLAT_NTx86 2
#define PLAT_ALPHA 3

// download sites

#define NUMSITES 50

typedef struct tag_sitedata
{
    TCHAR szName[80];
    TCHAR szUrl[MAX_URL];       // BUBUG: should dynamically allocate
    TCHAR szRegion[80];
} SITEDATA, *PSITEDATA;

typedef struct component_version
{
    TCHAR szID[MAX_PATH];
    TCHAR szVersion[MAX_PATH];
} COMP_VERSION, *PCOMP_VERSION;

void GetUpdateSite();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\ieaklite.h ===
#include "precomp.h"

typedef enum tagIEAKLITEGROUP
{
    IL_ACTIVESETUP = 0,
    IL_CORPINSTALL,
    IL_CABSIGN,
    IL_ICM,
    IL_BROWSER,
    IL_URL,
    IL_FAV,
    IL_UASTR,
    IL_CONNECT,
    IL_SIGNUP,
    IL_CERT,
    IL_ZONES,
    IL_PROGRAMS,
    IL_MAILNEWS,
    IL_ADM,
    IL_END
};

typedef struct tagIEAKLITEINFO
{
    WORD idGroupName;
    WORD idCorpDesc;
    WORD idICPDesc;
    WORD idISPDesc;
    int  iListBox;
    BOOL fICP;
    BOOL fISP;
    BOOL fCorp;
    BOOL fEnabled;
} IEAKLITEINFO;

#define NUM_GROUPS IL_END

extern IEAKLITEINFO g_IEAKLiteArray[NUM_GROUPS];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\insengt.cpp ===
#include "precomp.h"

// CCifComponent_t

CCifComponent_t::CCifComponent_t(ICifRWComponent * pCifRWComponentIn)
{
    pCifRWComponent = pCifRWComponentIn;
}

STDMETHODIMP CCifComponent_t::GetID(LPTSTR pszID, DWORD cchSize)
{
    CHAR szID[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetID(szID, countof(szID));
    A2Tbuf(szID, pszID, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetGUID(LPTSTR pszGUID, DWORD cchSize)
{
    CHAR szGUID[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetGUID(szGUID, countof(szGUID));
    A2Tbuf(szGUID, pszGUID, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetDescription(LPTSTR pszDesc, DWORD cchSize)
{
    CHAR szDesc[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetDescription(szDesc, countof(szDesc));
    A2Tbuf(szDesc, pszDesc, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetDetails(LPTSTR pszDetails, DWORD cchSize)
{
    CHAR szDetails[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetDetails(szDetails, countof(szDetails));
    A2Tbuf(szDetails, pszDetails, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetUrl(UINT uUrlNum, LPTSTR pszUrl, DWORD cchSize, LPDWORD pdwUrlFlags)
{
    CHAR szUrl[INTERNET_MAX_URL_LENGTH];
    HRESULT hr;

    hr = pCifRWComponent->GetUrl(uUrlNum, szUrl, countof(szUrl), pdwUrlFlags);
    A2Tbuf(szUrl, pszUrl, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetCommand(UINT uCmdNum, LPTSTR pszCmd, DWORD cchCmdSize, LPTSTR pszSwitches,
                                              DWORD cchSwitchSize, LPDWORD pdwType)
{
    CHAR szCmd[MAX_PATH];
    CHAR szSwitches[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetCommand(uCmdNum, szCmd, countof(szCmd),
        szSwitches, countof(szSwitches), pdwType);
    A2Tbuf(szCmd, pszCmd, cchCmdSize);
    A2Tbuf(szSwitches, pszSwitches, cchSwitchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetVersion(LPDWORD pdwVersion, LPDWORD pdwBuild)
{
    return pCifRWComponent->GetVersion(pdwVersion, pdwBuild);
}

STDMETHODIMP_(DWORD) CCifComponent_t::GetDownloadSize()
{
    return pCifRWComponent->GetDownloadSize();
}

STDMETHODIMP CCifComponent_t::GetDependency(UINT uDepNum, LPTSTR pszID, DWORD cchSize, TCHAR *pchType,
                                            LPDWORD pdwVer, LPDWORD pdwBuild)
{
    CHAR szID[MAX_PATH];
    CHAR chType;
    HRESULT hr;

    hr = pCifRWComponent->GetDependency(uDepNum, szID, countof(szID), &chType, pdwVer, pdwBuild);
    A2Tbuf(szID, pszID, cchSize);
    *pchType = (TCHAR)chType;

    return hr;
}

STDMETHODIMP_(DWORD) CCifComponent_t::GetPlatform()
{
    return pCifRWComponent->GetPlatform();
}

STDMETHODIMP CCifComponent_t::GetMode(UINT uModeNum, LPTSTR pszModes, DWORD cchSize)
{
    CHAR szModes[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetMode(uModeNum, szModes, countof(szModes));
    A2Tbuf(szModes, pszModes, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::GetGroup(LPTSTR pszID, DWORD cchSize)
{
    CHAR szID[MAX_PATH];
    HRESULT hr;

    hr = pCifRWComponent->GetGroup(szID, countof(szID));
    A2Tbuf(szID, pszID, cchSize);

    return hr;
}

STDMETHODIMP CCifComponent_t::IsUIVisible()
{
    return pCifRWComponent->IsUIVisible();
}

STDMETHODIMP CCifComponent_t::GetCustomData(LPTSTR pszKey, LPTSTR pszData, DWORD cchSize)
{
    CHAR szData[MAX_PATH];
    HRESULT hr;

    USES_CONVERSION;

    hr = pCifRWComponent->GetCustomData(T2A(pszKey), szData, countof(szData));
    A2Tbuf(szData, pszData, cchSize);

    return hr;
}

// CCifRWComponent_t

CCifRWComponent_t::CCifRWComponent_t(ICifRWComponent * pCifRWComponentIn) : CCifComponent_t(pCifRWComponentIn)
{
    pCifRWComponent = pCifRWComponentIn;
}

STDMETHODIMP CCifRWComponent_t::SetGUID(LPCTSTR pszGUID)
{
    USES_CONVERSION;

    return pCifRWComponent->SetGUID(T2CA(pszGUID));
}

STDMETHODIMP CCifRWComponent_t::SetDescription(LPCTSTR pszDesc)
{
    USES_CONVERSION;

    return pCifRWComponent->SetDescription(T2CA(pszDesc));
}

STDMETHODIMP CCifRWComponent_t::SetCommand(UINT uCmdNum, LPCTSTR pszCmd, LPCTSTR pszSwitches, DWORD dwType)
{
    USES_CONVERSION;

    return pCifRWComponent->SetCommand(uCmdNum, T2CA(pszCmd), T2CA(pszSwitches), dwType);
}

STDMETHODIMP CCifRWComponent_t::SetVersion(LPCTSTR pszVersion)
{
    USES_CONVERSION;

    return pCifRWComponent->SetVersion(T2CA(pszVersion));
}

STDMETHODIMP CCifRWComponent_t::SetUninstallKey(LPCTSTR pszKey)
{
    USES_CONVERSION;

    return pCifRWComponent->SetUninstallKey(T2CA(pszKey));
}

STDMETHODIMP CCifRWComponent_t::SetInstalledSize(DWORD dwWin, DWORD dwApp)
{
    return pCifRWComponent->SetInstalledSize(dwWin, dwApp);
}

STDMETHODIMP CCifRWComponent_t::SetDownloadSize(DWORD dwSize)
{
    return pCifRWComponent->SetDownloadSize(dwSize);
}

STDMETHODIMP CCifRWComponent_t::SetExtractSize(DWORD dwSize)
{
    return pCifRWComponent->SetExtractSize(dwSize);
}

STDMETHODIMP CCifRWComponent_t::DeleteDependency(LPCTSTR pszID, TCHAR tchType)
{
    USES_CONVERSION;

    return pCifRWComponent->DeleteDependency(T2CA(pszID), (CHAR)tchType);
}

STDMETHODIMP CCifRWComponent_t::AddDependency(LPCTSTR pszID, TCHAR tchType)
{
    USES_CONVERSION;

    return pCifRWComponent->AddDependency(T2CA(pszID), (CHAR)tchType);
}

STDMETHODIMP CCifRWComponent_t::SetUIVisible(BOOL fVisible)
{
    return pCifRWComponent->SetUIVisible(fVisible);
}

STDMETHODIMP CCifRWComponent_t::SetGroup(LPCTSTR pszID)
{
    USES_CONVERSION;

    return pCifRWComponent->SetGroup(T2CA(pszID));
}

STDMETHODIMP CCifRWComponent_t::SetPlatform(DWORD dwPlatform)
{
    return pCifRWComponent->SetPlatform(dwPlatform);
}

STDMETHODIMP CCifRWComponent_t::SetPriority(DWORD dwPriority)
{
    return pCifRWComponent->SetPriority(dwPriority);
}

STDMETHODIMP CCifRWComponent_t::SetReboot(BOOL fReboot)
{
    return pCifRWComponent->SetReboot(fReboot);
}

STDMETHODIMP CCifRWComponent_t::SetUrl(UINT uUrlNum, LPCTSTR pszUrl, DWORD dwUrlFlags)
{
    USES_CONVERSION;

    return pCifRWComponent->SetUrl(uUrlNum, T2CA(pszUrl), dwUrlFlags);
}

STDMETHODIMP CCifRWComponent_t::DeleteFromModes(LPCTSTR pszMode)
{
    USES_CONVERSION;

    return pCifRWComponent->DeleteFromModes(T2CA(pszMode));
}

STDMETHODIMP CCifRWComponent_t::AddToMode(LPCTSTR pszMode)
{
    USES_CONVERSION;

    return pCifRWComponent->AddToMode(T2CA(pszMode));
}

STDMETHODIMP CCifRWComponent_t::SetModes(LPCTSTR pszMode)
{
    USES_CONVERSION;

    return pCifRWComponent->SetModes(T2CA(pszMode));
}

STDMETHODIMP CCifRWComponent_t::CopyComponent(LPCTSTR pszCifFile)
{
    USES_CONVERSION;

    return pCifRWComponent->CopyComponent(T2CA(pszCifFile));
}

STDMETHODIMP CCifRWComponent_t::AddToTreatAsOne(LPCTSTR pszCompID)
{
    USES_CONVERSION;

    return pCifRWComponent->AddToTreatAsOne(T2CA(pszCompID));
}

STDMETHODIMP CCifRWComponent_t::SetDetails(LPCTSTR pszDesc)
{
    USES_CONVERSION;

    return pCifRWComponent->SetDetails(T2CA(pszDesc));
}

// CCifRWGroup_t

CCifRWGroup_t::CCifRWGroup_t(ICifRWGroup * pCifRWGroupIn)
{
    pCifRWGroup = pCifRWGroupIn;
}

STDMETHODIMP CCifRWGroup_t::GetDescription(LPTSTR pszDesc, DWORD cchSize)
{
    CHAR szDesc[MAX_PATH];
    HRESULT hr;

    USES_CONVERSION;

    hr = pCifRWGroup->GetDescription(szDesc, countof(szDesc));
    A2Tbuf(szDesc, pszDesc, cchSize);

    return hr;
}

STDMETHODIMP_(DWORD) CCifRWGroup_t::GetPriority()
{
    return pCifRWGroup->GetPriority();
}

STDMETHODIMP CCifRWGroup_t::SetDescription(LPCTSTR pszDesc)
{
    USES_CONVERSION;

    return pCifRWGroup->SetDescription(T2CA(pszDesc));
}

STDMETHODIMP CCifRWGroup_t::SetPriority(DWORD dwPriority)
{
    return pCifRWGroup->SetPriority(dwPriority);
}

// CCifMode_t

CCifMode_t::CCifMode_t(ICifRWMode * pCifRWModeIn)
{
    pCifRWMode = pCifRWModeIn;
}

STDMETHODIMP CCifMode_t::GetID(LPTSTR pszID, DWORD cchSize)
{
    CHAR szID[MAX_PATH];
    HRESULT hr;

    hr = pCifRWMode->GetID(szID, countof(szID));
    A2Tbuf(szID, pszID, cchSize);

    return hr;
}

STDMETHODIMP CCifMode_t::GetDescription(LPTSTR pszDesc, DWORD cchSize)
{
    CHAR szDesc[MAX_PATH];
    HRESULT hr;

    hr = pCifRWMode->GetDescription(szDesc, countof(szDesc));
    A2Tbuf(szDesc, pszDesc, cchSize);

    return hr;
}

STDMETHODIMP CCifMode_t::GetDetails(LPTSTR pszDetails, DWORD cchSize)
{
    CHAR szDetails[MAX_PATH];
    HRESULT hr;

    hr = pCifRWMode->GetDetails(szDetails, countof(szDetails));
    A2Tbuf(szDetails, pszDetails, cchSize);

    return hr;
}

// CCifRWMode_t

CCifRWMode_t::CCifRWMode_t(ICifRWMode * pCifRWModeIn) : CCifMode_t(pCifRWModeIn)
{
    pCifRWMode = pCifRWModeIn;
}

STDMETHODIMP CCifRWMode_t::SetDescription(LPCTSTR pszDesc)
{
    USES_CONVERSION;

    return pCifRWMode->SetDescription(T2CA(pszDesc));
}

STDMETHODIMP CCifRWMode_t::SetDetails(LPCTSTR pszDetails)
{
    USES_CONVERSION;

    return pCifRWMode->SetDetails(T2CA(pszDetails));
}

// CCifFile_t

CCifFile_t::CCifFile_t(ICifRWFile * pCifRWFileIn)
{
    pCifRWFile = pCifRWFileIn;
}

CCifFile_t::~CCifFile_t()
{
    if (pCifRWFile != NULL)
    {
        pCifRWFile->Release();
        pCifRWFile = NULL;
    }
}

STDMETHODIMP CCifFile_t::EnumComponents(IEnumCifComponents ** ppEnumCifComponents,
                                            DWORD dwFilter, LPVOID pv)
{
    return pCifRWFile->EnumComponents(ppEnumCifComponents, dwFilter, pv);
}

STDMETHODIMP CCifFile_t::FindComponent(LPCTSTR pszID, ICifComponent **p)
{
    USES_CONVERSION;

    return pCifRWFile->FindComponent(T2CA(pszID), p);
}

STDMETHODIMP CCifFile_t::EnumModes(IEnumCifModes ** ppEnumCifModes, DWORD dwFilter, LPVOID pv)
{
    return pCifRWFile->EnumModes(ppEnumCifModes, dwFilter, pv);
}

STDMETHODIMP CCifFile_t::FindMode(LPCTSTR pszID, ICifMode **p)
{
    USES_CONVERSION;

    return pCifRWFile->FindMode(T2CA(pszID), p);
}

STDMETHODIMP CCifFile_t::GetDescription(LPTSTR pszDesc, DWORD cchSize)
{
    CHAR szDesc[MAX_PATH];
    HRESULT hr;

    hr = pCifRWFile->GetDescription(szDesc, countof(szDesc));
    A2Tbuf(szDesc, pszDesc, cchSize);

    return hr;
}

// CCifRWFile_t

CCifRWFile_t::CCifRWFile_t(ICifRWFile * pCifRWFileIn) : CCifFile_t(pCifRWFileIn)
{
    pCifRWFile = pCifRWFileIn;
}

STDMETHODIMP CCifRWFile_t::SetDescription(LPCTSTR pszDesc)
{
    USES_CONVERSION;

    return pCifRWFile->SetDescription(T2CA(pszDesc));
}

STDMETHODIMP CCifRWFile_t::CreateComponent(LPCTSTR pszID, ICifRWComponent **p)
{
    USES_CONVERSION;

    return pCifRWFile->CreateComponent(T2CA(pszID), p);
}

STDMETHODIMP CCifRWFile_t::CreateGroup(LPCTSTR pszID, ICifRWGroup **p)
{
    USES_CONVERSION;

    return pCifRWFile->CreateGroup(T2CA(pszID), p);
}

STDMETHODIMP CCifRWFile_t::CreateMode(LPCTSTR pszID, ICifRWMode **p)
{
    USES_CONVERSION;

    return pCifRWFile->CreateMode(T2CA(pszID), p);
}

STDMETHODIMP CCifRWFile_t::DeleteComponent(LPCTSTR pszID)
{
    USES_CONVERSION;

    return pCifRWFile->DeleteComponent(T2CA(pszID));
}

STDMETHODIMP CCifRWFile_t::DeleteGroup(LPCTSTR pszID)
{
    USES_CONVERSION;

    return pCifRWFile->DeleteGroup(T2CA(pszID));
}

STDMETHODIMP CCifRWFile_t::DeleteMode(LPCTSTR pszID)
{
    USES_CONVERSION;

    return pCifRWFile->DeleteMode(T2CA(pszID));
}

STDMETHODIMP CCifRWFile_t::Flush()
{
    return pCifRWFile->Flush();
}


// cif functions

HRESULT GetICifFileFromFile_t(CCifFile_t ** ppCifFile_t, LPCTSTR pszCifFile)
{
    ICifFile * lpCifFile;
    HRESULT hr;

    USES_CONVERSION;

    if (SUCCEEDED(hr = GetICifFileFromFile(&lpCifFile, T2CA(pszCifFile))))
        *ppCifFile_t = new CCifFile_t((ICifRWFile *)lpCifFile);

    return hr;
}

HRESULT GetICifRWFileFromFile_t(CCifRWFile_t ** ppCifFile_t, LPCTSTR pszCifFile)
{
    ICifRWFile * lpCifRWFile;
    HRESULT hr;

    USES_CONVERSION;

    if (SUCCEEDED(hr = GetICifRWFileFromFile(&lpCifRWFile, T2CA(pszCifFile))))
        *ppCifFile_t = new CCifRWFile_t(lpCifRWFile);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\ie4desk.cpp ===
#include "precomp.h"

extern TCHAR g_szCustIns[];
extern TCHAR g_szBuildTemp[];
extern TCHAR g_szTempSign[];
extern TCHAR g_szWizRoot[];
extern TCHAR g_szDestCif[];
extern TCHAR g_szDefInf[];
extern TCHAR g_szCustInf[];
extern TCHAR g_szAllModes[];
extern TCHAR g_szLanguage[];

extern BOOL g_fIntranet;
extern BOOL g_fServerICW, g_fServerKiosk, g_fServerless;

extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;

extern void SetCompSize(LPTSTR szCab, LPTSTR szSect, DWORD dwInstallSize);
extern void WriteModesToCif(CCifRWComponent_t * pCifRWComponent_t, LPCTSTR pcszModes);

// global variables
TCHAR g_szJobVersion[32];
TCHAR g_szDeskTemp[MAX_PATH] = TEXT("");
TCHAR g_szUnsignedFiles[MAX_BUF] = TEXT("");

// static variables
static DWORD s_dwDDF = 0;
static TCHAR s_szInfAdd1[] = TEXT("\r\n[ProgramFilesDir]\r\nHKLM,Software\\Microsoft\\Windows\\CurrentVersion,ProgramFilesDir,,%24%\r\n");
static TCHAR s_szInfAdd2[] = TEXT("\r\n[IeFilesDir]\r\nHKLM,\"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE\"")
                    TEXT(",\"Path\",,\"%24%\\Program Files\\%IEDIR%\"\r\n");
static TCHAR s_szDDFTpl[] = TEXT(".Set SourceDir=%s\r\nsetup.inf /INF=NO\r\ninstall.inf /INF=NO");

void CreatePostCmdSection(LPCTSTR szDestDir, LPCTSTR szInf)
{
    TCHAR   szLDID[MAX_PATH],
            szDir[MAX_PATH],
            szBuildDir[MAX_PATH];
    LPTSTR  pPtr,
            pPostCmdSect;
    int     nSizeSectBuffer = 0;

    if (szDestDir == NULL || *szDestDir == TEXT('\0') || szInf == NULL || *szInf == TEXT('\0'))
        return;

    *szLDID = TEXT('\0');
    *szDir  = TEXT('\0');
    pPtr = StrChr(szDestDir, TEXT(','));
    if (pPtr != NULL)
    {
        StrCpyN(szLDID, szDestDir, (int) ((pPtr - szDestDir) + 1));
        StrCpy(szDir, pPtr + 1);
    }

    if (*szLDID == TEXT('\0') || *szDir == TEXT('\0'))
        return;

    wnsprintf(szBuildDir, countof(szBuildDir), TEXT("%%%s%%\\%s"), szLDID, szDir);
    nSizeSectBuffer = MAX_PATH * 5;
    pPostCmdSect = (LPTSTR)LocalAlloc(LPTR, nSizeSectBuffer * sizeof(TCHAR));
    if (pPostCmdSect)
    {
        TCHAR szFile[MAX_PATH],
              szSectLine[MAX_PATH];
        int   nCopyIndex = 0;
        WIN32_FIND_DATA findFileData;

        // add .adm inf line (if any) to the section string
        PathCombine(szFile, g_szTempSign, TEXT("*.inf"));

        HANDLE hFind = FindFirstFile(szFile, &findFileData);
        if(hFind != INVALID_HANDLE_VALUE)
        {
            TCHAR  szADMFile[MAX_PATH],
                   szADMPath[MAX_PATH];
            LPTSTR pTemp;

            PathCombine(szADMPath, g_szWizRoot, TEXT("Policies"));
            PathAppend(szADMPath, g_szLanguage);

            do
            {
                StrCpy(szFile, findFileData.cFileName);
                PathRenameExtension(szFile, TEXT(".adm"));
                PathCombine(szADMFile, szADMPath, szFile);
                if (PathFileExists(szADMFile))
                {
                    wnsprintf(szSectLine, countof(szSectLine), TEXT("rundll32.exe advpack.dll,LaunchINFSection %s\\%s,DefaultInstall.HKLM, 1"), szBuildDir, findFileData.cFileName);
                    if (nCopyIndex + StrLen(szSectLine) + 1 > (nSizeSectBuffer - 1))
                    {
                        nSizeSectBuffer += MAX_PATH;
                        pTemp = (LPTSTR)LocalReAlloc(pPostCmdSect, nSizeSectBuffer, LMEM_ZEROINIT);
                        if (pTemp != NULL)
                            pPostCmdSect = pTemp;
                        else
                            break;
                    }

                    StrCpy(pPostCmdSect + nCopyIndex, szSectLine);
                    nCopyIndex += StrLen(szSectLine);
                    nCopyIndex++; // section lines must be spaced with a NULL character
                }
            }while(FindNextFile(hFind, &findFileData));
            FindClose(hFind);
        }
    }
    if (pPostCmdSect != NULL)
    {
        if (*pPostCmdSect != TEXT('\0'))
        {
            WritePrivateProfileSection(TEXT("PostCmdSect"), pPostCmdSect, szInf);
            WritePrivateProfileString(NULL, NULL, NULL, szInf);
        }
        LocalFree(pPostCmdSect);
    }
}

HRESULT CabUpFolder(HWND hWnd, LPTSTR szFolderPath, LPTSTR szDestDir, LPTSTR szCabname,
                    LPTSTR szDisplayName, LPTSTR szGuid, LPTSTR szAddReg)
{
    WIN32_FIND_DATA fd;
    HANDLE hFind;
    TCHAR szFrom[MAX_PATH];
    TCHAR szCabPath[MAX_PATH];
    TCHAR szDDF[MAX_PATH];
    TCHAR szDiamondParams[MAX_PATH];
    TCHAR szInf[MAX_PATH];
    TCHAR szSetInf[MAX_PATH];
    TCHAR szTempDir[MAX_PATH];
    TCHAR szIEDir[MAX_PATH];
    TCHAR szMakeCabLoc[MAX_PATH];
    TCHAR szDefaultInstallSect[64];
    DWORD dwsHi, nWritten;
    HANDLE hDDF, hInf, hRegInf, hMakeCab;
    SHELLEXECUTEINFO shInfo;
    TCHAR szDDFAdd[3 * MAX_PATH];
    DWORD dwInstallSize;
    TCHAR szSourceDisk[80];

    PathCombine(szFrom, szFolderPath, TEXT("*.*"));
    PathCombine(szCabPath, g_szBuildTemp, szCabname);
    PathCombine(szDDF, g_szBuildTemp, TEXT("Folder.ddf"));
    wnsprintf(szDiamondParams, countof(szDiamondParams), TEXT("/D CabinetName1=..\\%s /D SourceDir=\"%s\" /F %s"),
            szCabname, szFolderPath, szDDF);
    StrCpy(szInf, szCabPath);
    PathRemoveFileSpec(szInf);
    PathAppend(szInf, TEXT("install.inf"));
    if (ISNULL(szGuid))
    {
        GUID guid;
        if (CoCreateGuid(&guid) == NOERROR)
            CoStringFromGUID(guid, szGuid, 64);
    }
    DeleteFile(szInf);
    WritePrivateProfileString(VERSION, TEXT("Signature"), TEXT("$Chicago$"), szInf);
    WritePrivateProfileString(VERSION, TEXT("AdvancedInf"), TEXT("2.5"), szInf);
    WritePrivateProfileString(VERSION, TEXT("LayoutFile"), TEXT("Setup.inf"), szInf);
    WritePrivateProfileString( TEXT("CustInstDestSection"), TEXT("49000,49001,49002,49003"),
        TEXT("ProgramFilesDir,5"), szInf );
    WritePrivateProfileString( TEXT("CustInstDestSection"), TEXT("49100,49101,49102,49103"),
        TEXT("IEFilesDir,5"), szInf );
    LoadString( g_rvInfo.hInst, IDS_IE, szIEDir, MAX_PATH );
    WritePrivateProfileString( IS_STRINGS, TEXT("IEDIR"), szIEDir, szInf);
    
    StrCpy(szDefaultInstallSect, DEFAULT_INSTALL);

    WritePrivateProfileString(szDefaultInstallSect,  TEXT("CopyFiles"), TEXT("CopyFileSect"), szInf);
    WritePrivateProfileString(szDefaultInstallSect,  TEXT("CustomDestination"),
        TEXT("CustInstDestSection"), szInf);
    WritePrivateProfileString(szDefaultInstallSect, REQUIRED_ENGINE, SETUPAPI_FATAL, szInf);
    WritePrivateProfileString(TEXT("DestinationDirs"), TEXT("CopyFileSect"), szDestDir, szInf);
    WritePrivateProfileString(NULL, NULL, NULL, szInf);
    hInf = CreateFile(szInf, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
         FILE_ATTRIBUTE_NORMAL, NULL);
    SetFilePointer(hInf, 0, NULL, FILE_END);
    WriteStringToFile( hInf, s_szInfAdd1, StrLen(s_szInfAdd1));
    WriteStringToFile( hInf, s_szInfAdd2, StrLen(s_szInfAdd2) );
    WriteStringToFile( hInf, TEXT("\r\n[CopyFileSect]\r\n"), 18);

    hDDF = CreateFile(szDDF, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
         FILE_ATTRIBUTE_NORMAL, NULL);

    if (hDDF == INVALID_HANDLE_VALUE)
    {
        CloseHandle(hInf);
        return E_FAIL;
    }
    if (s_dwDDF == 0) s_dwDDF = GetFileSize( hDDF, &dwsHi );
    SetFilePointer(hDDF, s_dwDDF, NULL, FILE_BEGIN);
    SetEndOfFile( hDDF );
    if ((hFind = FindFirstFile( szFrom, &fd)) != INVALID_HANDLE_VALUE)
        while (1)
        {
            LPTSTR pFn = fd.cFileName;
            if ((ISNONNULL(pFn)) && StrCmp(pFn, TEXT(".")) && StrCmp(pFn, TEXT(".."))
                && ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
            {
                WriteStringToFile( hDDF, TEXT("\""), 1);
                WriteStringToFile( hDDF, pFn, StrLen(pFn) );
                WriteStringToFile( hDDF, TEXT("\"\r\n"), 3 );
                WriteStringToFile( hInf, TEXT("\""), 1 );
                WriteStringToFile( hInf, pFn, StrLen(pFn) );
                WriteStringToFile( hInf, TEXT("\"\r\n"), 3 );
            }
            if (!FindNextFile( hFind, &fd ))
                if (GetLastError() == ERROR_NO_MORE_FILES)
                {
                    FindClose( hFind );
                    break;
                }
        }

    if (szAddReg)
    {
        if (ISNONNULL(szAddReg))
        {
            TCHAR szRegInf[MAX_PATH];
            CHAR szRegInfBuf[2048];
            TCHAR szQuotedVer[80];
            TCHAR szClearStubCmd[MAX_PATH];
            DWORD nRead;
            PathCombine(szRegInf, g_szBuildTemp, TEXT("ADDREG.INF"));
            ZeroMemory(szRegInfBuf, sizeof(szRegInfBuf));
            hRegInf = CreateFile(szRegInf, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, NULL);
            ReadFile( hRegInf, szRegInfBuf, sizeof(szRegInfBuf), &nRead, NULL );
            WriteFile( hInf, szRegInfBuf, nRead, &nWritten, NULL );
            CloseHandle(hInf);
            CloseHandle(hRegInf);
            if ((szGuid[0] == TEXT('>')) || (szGuid[0] == TEXT('<')))
            {
                WritePrivateProfileString(szDefaultInstallSect, TEXT("DelReg"),
                    TEXT("DelRegSect"), szInf);
                WritePrivateProfileString( IS_STRINGS, TEXT("OLDGUID"), &szGuid[1], szInf);
            }
            else
                WritePrivateProfileString(TEXT("DelRegSect"), NULL, NULL, szInf);
            wnsprintf(szQuotedVer, countof(szQuotedVer), TEXT("\"%s\""), g_szJobVersion);
            wnsprintf(szClearStubCmd, countof(szClearStubCmd), TEXT("\"RUNDLL32 IEDKCS32.DLL,BrandCleanInstallStubs %s\""), szGuid);
            WritePrivateProfileString( IS_STRINGS, TEXT("Description"), szDisplayName, szInf);
            WritePrivateProfileString( IS_STRINGS, TEXT("StubPath"), szAddReg, szInf);
            WritePrivateProfileString( IS_STRINGS, TEXT("Revision"), szQuotedVer, szInf);
            WritePrivateProfileString( IS_STRINGS, TEXT("GUID"), szGuid, szInf);
            WritePrivateProfileString( IS_STRINGS, TEXT("ClearStubsCmd"), szClearStubCmd, szInf);
            WritePrivateProfileString( szDefaultInstallSect, TEXT("AddReg"), TEXT("AddRegSect"), szInf);

            // create a postcmdsect to dump the HKLM data of the rating.inf and the
            // .adm inf's.
            WritePrivateProfileString(szDefaultInstallSect, TEXT("RunPostSetupCommands"), TEXT("PostCmdSect"), szInf);
            CreatePostCmdSection(szDestDir, szInf);
        }
        else CloseHandle(hInf);
    }
    else CloseHandle(hInf);

    wnsprintf(szDDFAdd, countof(szDDFAdd), s_szDDFTpl, g_szBuildTemp);
    WriteStringToFile( hDDF, szDDFAdd, StrLen(szDDFAdd));
    CloseHandle(hDDF);

    WritePrivateProfileString(NULL, NULL, NULL, szInf);

    wnsprintf(szSourceDisk, countof(szSourceDisk), TEXT("\"Custom Folder\",%s,0"), szCabname);
    PathCombine(szSetInf, g_szBuildTemp, TEXT("SETUP.INF") );
    DeleteFile(szSetInf);
    WritePrivateProfileString( TEXT("SourceDisksNames"), TEXT("1"), szSourceDisk, szSetInf );
    WritePrivateProfileString(NULL, NULL, NULL, szSetInf);

    dwInstallSize = FolderSize(szFolderPath) >> 10;
    memset(&shInfo, 0, sizeof(shInfo));
    shInfo.cbSize = sizeof(shInfo);
    shInfo.hwnd = hWnd;
    shInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    shInfo.lpVerb = TEXT("open");
    
    // If MAKECAB.EXE is in the current directory, use the full path.
    // otherwise when we build in the scratch dir we won't find it.
    PathCombine(szMakeCabLoc, g_szBuildTemp, TEXT("MAKECAB.EXE"));
    hMakeCab = CreateFile(szMakeCabLoc, GENERIC_READ, 0, NULL, OPEN_EXISTING,
         FILE_ATTRIBUTE_NORMAL, NULL);
    if(hMakeCab == INVALID_HANDLE_VALUE)
        shInfo.lpFile = TEXT("MAKECAB.EXE");
    else 
    {
        CloseHandle(hMakeCab);
        shInfo.lpFile = szMakeCabLoc;
    }
    shInfo.lpParameters = szDiamondParams;
    PathCombine(szTempDir, g_szBuildTemp, TEXT("SCRATCH") );  // SETUP.INF is destroyed by ShellExecAndWait!! Use scratch dir
    CreateDirectory(szTempDir, NULL);
    shInfo.lpDirectory = szTempDir;
    shInfo.nShow = SW_MINIMIZE;
    SetCurrentDirectory(szTempDir);
    ShellExecAndWait(shInfo);
    SetCurrentDirectory(g_szBuildTemp);

    {
        ICifRWComponent * pCifRWComponent;
        CCifRWComponent_t * pCifRWComponent_t;
        ICifComponent * pCifBaseComp;

        g_lpCifRWFileDest->DeleteComponent(szCabname);
        g_lpCifRWFileDest->CreateComponent(szCabname, &pCifRWComponent);
        pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
        pCifRWComponent_t->SetGUID(szGuid);
        pCifRWComponent_t->SetDescription(szDisplayName);
        pCifRWComponent_t->SetUrl(0, szCabname, 3);
        pCifRWComponent_t->SetVersion(g_szJobVersion);
        pCifRWComponent_t->SetCommand(0, TEXT("INSTALL.INF"), TEXT(""), 0);
        pCifRWComponent_t->SetReboot(TRUE);
        WriteModesToCif(pCifRWComponent_t, g_szAllModes);
        pCifRWComponent_t->SetGroup(TEXT("BASEIE4"));
        pCifRWComponent_t->SetPriority(835);
        pCifRWComponent_t->SetUIVisible(FALSE);

        if (SUCCEEDED(g_lpCifRWFileDest->FindComponent(TEXT("BASEIE40_Win"), &pCifBaseComp)))
        {
            // passing in the slash because we can't change inseng interface signature
            // this translates to writing a line of BASEIE40:N:5.0.0.0"
            pCifRWComponent_t->AddDependency(TEXT("BASEIE40_Win"), TEXT('\\'));
            delete pCifRWComponent_t;
            g_lpCifRWFileDest->CreateComponent(TEXT("BASEIE40_Win"), &pCifRWComponent);
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            pCifRWComponent_t->AddToTreatAsOne(szCabname);
            delete pCifRWComponent_t;
            g_lpCifRWFileDest->CreateComponent(TEXT("BASEIE40_NTx86"), &pCifRWComponent);
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            pCifRWComponent_t->AddToTreatAsOne(szCabname);
            delete pCifRWComponent_t;
        }
        else
        {
            // passing in the slash because we can't change inseng interface signature
            // this translates to writing a line of BASEIE40:N:5.0.0.0"
            pCifRWComponent_t->AddDependency(TEXT("BASEIE40_NTAlpha"), TEXT('\\'));
            delete pCifRWComponent_t;
            g_lpCifRWFileDest->CreateComponent(TEXT("BASEIE40_NTAlpha"), &pCifRWComponent);
            pCifRWComponent_t = new CCifRWComponent_t(pCifRWComponent);
            pCifRWComponent_t->AddToTreatAsOne(szCabname);
            delete pCifRWComponent_t;
        }
    }
    SetCompSize(szCabPath, szCabname, dwInstallSize);
    return(S_OK);
}

void BuildIE4Folders(HWND hWnd)
{
    // build desktop.cab if g_szDeskTemp exists and is non-empty
    if (PathIsDirectory(g_szDeskTemp)  &&  !RemoveDirectory(g_szDeskTemp))
    {
        TCHAR szGuid[128];
        TCHAR szCustDesk[128];

        GetPrivateProfileString(IS_STRINGS, TEXT("DesktopName"), TEXT(""), szCustDesk, countof(szCustDesk), g_szDefInf);
        if (ISNULL(szCustDesk))
            LoadString(g_rvInfo.hInst, IDS_CUSTDESK, szCustDesk, countof(szCustDesk));
        GetPrivateProfileString(IS_BRANDING, TEXT("DesktopGuid"), TEXT(""), szGuid, countof(szGuid), g_szCustIns);
        CabUpFolder(hWnd, g_szDeskTemp, TEXT("25,WEB"), TEXT("DESKTOP.CAB"), szCustDesk, szGuid, NULL);
        SignFile(TEXT("DESKTOP.CAB"), g_szBuildTemp, g_szCustIns, g_szUnsignedFiles, g_szCustInf);
        PathRemovePath(g_szDeskTemp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\insengt.h ===
#ifndef _CIFTCHAR_H_
#define _CIFTCHAR_H_

// inseng tchar wrappers

// wrapper for ICifComponent

class CCifComponent_t
{
private:
    ICifRWComponent * pCifRWComponent;

public:
    CCifComponent_t(ICifRWComponent *);
    ~CCifComponent_t()   {};

    STDMETHOD(GetID)(LPTSTR pszID, DWORD cchSize);
    STDMETHOD(GetGUID)(LPTSTR pszGUID, DWORD cchSize);
    STDMETHOD(GetDescription)(LPTSTR pszDesc, DWORD cchSize);
    STDMETHOD(GetDetails)(LPTSTR pszDetails, DWORD cchSize);
    STDMETHOD(GetUrl)(UINT uUrlNum, LPTSTR pszUrl, DWORD cchSize, LPDWORD pdwUrlFlags);
    STDMETHOD(GetCommand)(UINT uCmdNum, LPTSTR pszCmd, DWORD cchCmdSize, LPTSTR pszSwitches,
        DWORD cchSwitchSize, LPDWORD pdwType);
    STDMETHOD(GetVersion)(LPDWORD pdwVersion, LPDWORD pdwBuild);
    STDMETHOD_(DWORD, GetDownloadSize)();
    STDMETHOD(GetDependency)(UINT uDepNum, LPTSTR pszID, DWORD cchSize, TCHAR *pchType, LPDWORD pdwVer, LPDWORD pdwBuild);
    STDMETHOD_(DWORD, GetPlatform)();
    STDMETHOD(GetMode)(UINT uModeNum, LPTSTR pszModes, DWORD cchSize);
    STDMETHOD(GetGroup)(LPTSTR pszID, DWORD cchSize);
    STDMETHOD(IsUIVisible)();
    STDMETHOD(GetCustomData)(LPTSTR pszKey, LPTSTR pszData, DWORD cchSize);
};

// wrapper for ICifRWComponent
class CCifRWComponent_t : public CCifComponent_t
{
private:
    ICifRWComponent * pCifRWComponent;

public:
    CCifRWComponent_t(ICifRWComponent *);
    ~CCifRWComponent_t()  {};

    STDMETHOD(SetGUID)(LPCTSTR pszGUID);
    STDMETHOD(SetDescription)(LPCTSTR pszDesc);
    STDMETHOD(SetCommand)(UINT uCmdNum, LPCTSTR pszCmd, LPCTSTR pszSwitches, DWORD dwType);
    STDMETHOD(SetVersion)(LPCTSTR pszVersion);
    STDMETHOD(SetUninstallKey)(LPCTSTR pszKey);
    STDMETHOD(SetInstalledSize)(DWORD dwWin, DWORD dwApp);
    STDMETHOD(SetDownloadSize)(DWORD);
    STDMETHOD(SetExtractSize)(DWORD);
    STDMETHOD(DeleteDependency)(LPCTSTR pszID, TCHAR chType);
    STDMETHOD(AddDependency)(LPCTSTR pszID, TCHAR chType);
    STDMETHOD(SetUIVisible)(BOOL);
    STDMETHOD(SetGroup)(LPCTSTR pszID);
    STDMETHOD(SetPlatform)(DWORD);
    STDMETHOD(SetPriority)(DWORD);
    STDMETHOD(SetReboot)(BOOL);
    STDMETHOD(SetUrl)(UINT uUrlNum, LPCTSTR pszUrl, DWORD dwUrlFlags);

    STDMETHOD(DeleteFromModes)(LPCTSTR pszMode);
    STDMETHOD(AddToMode)(LPCTSTR pszMode);
    STDMETHOD(SetModes)(LPCTSTR pszMode);
    STDMETHOD(CopyComponent)(LPCTSTR pszCifFile);
    STDMETHOD(AddToTreatAsOne)(LPCTSTR pszCompID);
    STDMETHOD(SetDetails)(LPCTSTR pszDesc);
};

// wrapper for ICifRWGroup

class CCifRWGroup_t
{
private:
    ICifRWGroup * pCifRWGroup;

public:
    CCifRWGroup_t(ICifRWGroup *);
    ~CCifRWGroup_t()  {};

    STDMETHOD(GetDescription)(LPTSTR pszDesc, DWORD cchSize);
    STDMETHOD_(DWORD, GetPriority)();

    STDMETHOD(SetDescription)(LPCTSTR pszDesc);
    STDMETHOD(SetPriority)(DWORD);
};

// wrapper for ICifMode

class CCifMode_t
{
private:
    ICifRWMode * pCifRWMode;

public:
    CCifMode_t(ICifRWMode *);
    ~CCifMode_t() {};

    STDMETHOD(GetID)(LPTSTR pszID, DWORD cchSize);
    STDMETHOD(GetDescription)(LPTSTR pszDesc, DWORD cchSize);
    STDMETHOD(GetDetails)(LPTSTR pszDetails, DWORD cchSize);
};

// wrapper for ICifRWMode
class CCifRWMode_t : public CCifMode_t
{
private:
    ICifRWMode * pCifRWMode;

public:
    CCifRWMode_t(ICifRWMode *);
    ~CCifRWMode_t()  {};

    STDMETHOD(SetDescription)(LPCTSTR pszDesc);
    STDMETHOD(SetDetails)(LPCTSTR pszDetails);
};

// wrapper for ICifFile
class CCifFile_t
{
private:
    ICifRWFile * pCifRWFile;

public:
    CCifFile_t(ICifRWFile *);
    ~CCifFile_t();

    STDMETHOD(EnumComponents)(IEnumCifComponents **, DWORD dwFilter, LPVOID pv);
    STDMETHOD(FindComponent)(LPCTSTR pszID, ICifComponent **p);

    STDMETHOD(EnumModes)(IEnumCifModes **, DWORD dwFilter, LPVOID pv);
    STDMETHOD(FindMode)(LPCTSTR pszID, ICifMode **p);

    STDMETHOD(GetDescription)(LPTSTR pszDesc, DWORD cchSize);
};

// wrapper for ICifRWFile

class CCifRWFile_t : public CCifFile_t
{
private:
    ICifRWFile * pCifRWFile;

public:
    CCifRWFile_t(ICifRWFile *);
    ~CCifRWFile_t() {};     // release will be taken care of by CCifFile_t destructor

    // ICifRWFile methods
    STDMETHOD(SetDescription)(LPCTSTR pszDesc);
    STDMETHOD(CreateComponent)(LPCTSTR pszID, ICifRWComponent **p);
    STDMETHOD(CreateGroup)(LPCTSTR pszID, ICifRWGroup **p);
    STDMETHOD(CreateMode)(LPCTSTR pszID, ICifRWMode **p);
    STDMETHOD(DeleteComponent)(LPCTSTR pszID);
    STDMETHOD(DeleteGroup)(LPCTSTR pszID);
    STDMETHOD(DeleteMode)(LPCTSTR pszID);
    STDMETHOD(Flush)();
};

HRESULT GetICifFileFromFile_t(CCifFile_t **, LPCTSTR pszCifFile);
HRESULT GetICifRWFileFromFile_t(CCifRWFile_t **, LPCTSTR pszCifFile);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\intrawiz.cpp ===
#include "precomp.h"

extern TCHAR g_szCustIns[];
extern TCHAR g_szTempSign[];
extern TCHAR g_szMastInf[];

extern BOOL g_fOCW;
extern BOOL g_fIntranet;
extern BOOL g_fInteg;
extern BOOL g_fCD, g_fLAN, g_fDownload, g_fBrandingOnly;

extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;

// global variables
TCHAR g_szInstallFolder[MAX_PATH] = TEXT("");
BOOL g_fSilent = FALSE;
BOOL g_fStealth = FALSE;
BOOL g_fImportConnect = FALSE;
int g_iInstallOpt;

// static variables
static TCHAR s_szInstallDir[MAX_PATH] = TEXT("");

BOOL CALLBACK QueryAutoConfigDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szAutoConfigURL[MAX_URL],
          szAutoProxyURL[MAX_URL],
          szAutoConfigTime[7];
    BOOL  fDetectConfig,
          fUseAutoConfig;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            DisableDBCSChars(hDlg, IDE_AUTOCONFIGTIME);

            EnableDBCSChars(hDlg, IDE_AUTOCONFIGURL);
            EnableDBCSChars(hDlg, IDE_AUTOPROXYURL);

            Edit_LimitText(GetDlgItem(hDlg, IDE_AUTOCONFIGTIME), countof(szAutoConfigTime) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_AUTOCONFIGURL),  countof(szAutoConfigURL) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_AUTOPROXYURL),   countof(szAutoProxyURL) - 1);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    fDetectConfig = FALSE;
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_AUTODETECT))) {
                        fDetectConfig = InsGetBool(IS_URL, IK_DETECTCONFIG, TRUE, g_szCustIns);
                        CheckDlgButton(hDlg, IDC_AUTODETECT, fDetectConfig  ? BST_CHECKED : BST_UNCHECKED);
                    }

                    fUseAutoConfig = InsGetBool(IS_URL, IK_USEAUTOCONF,  FALSE, g_szCustIns);
                    CheckDlgButton(hDlg, IDC_YESAUTOCON, fUseAutoConfig ? BST_CHECKED : BST_UNCHECKED);
                    
                    GetPrivateProfileString(IS_URL, IK_AUTOCONFTIME, TEXT(""), szAutoConfigTime, countof(szAutoConfigTime), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_AUTOCONFIGTIME, szAutoConfigTime);
                    EnableDlgItem2(hDlg, IDE_AUTOCONFIGTIME, fUseAutoConfig);
                    EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT2, fUseAutoConfig);
                    EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT3, fUseAutoConfig);

                    GetPrivateProfileString(IS_URL, IK_AUTOCONFURL, TEXT(""), szAutoConfigURL, countof(szAutoConfigURL), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_AUTOCONFIGURL, szAutoConfigURL);
                    EnableDlgItem2(hDlg, IDE_AUTOCONFIGURL, fUseAutoConfig);
                    EnableDlgItem2(hDlg, IDC_AUTOCONFIGURL_TXT, fUseAutoConfig);

                    GetPrivateProfileString(IS_URL, IK_AUTOCONFURLJS, TEXT(""), szAutoProxyURL, countof(szAutoProxyURL), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_AUTOPROXYURL, szAutoProxyURL);
                    EnableDlgItem2(hDlg, IDE_AUTOPROXYURL, fUseAutoConfig);
                    EnableDlgItem2(hDlg, IDC_AUTOPROXYURL_TXT, fUseAutoConfig);

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    fDetectConfig  = (IsDlgButtonChecked(hDlg, IDC_AUTODETECT) == BST_CHECKED);
                    fUseAutoConfig = (IsDlgButtonChecked(hDlg, IDC_YESAUTOCON) == BST_CHECKED);

                    GetDlgItemText(hDlg, IDE_AUTOCONFIGTIME, szAutoConfigTime, countof(szAutoConfigTime));
                    GetDlgItemText(hDlg, IDE_AUTOCONFIGURL,  szAutoConfigURL,  countof(szAutoConfigURL));
                    GetDlgItemText(hDlg, IDE_AUTOPROXYURL,   szAutoProxyURL,   countof(szAutoProxyURL));

                    // do error checking
                    if (fUseAutoConfig) {
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDE_AUTOCONFIGTIME)) &&
                            !CheckField(hDlg, IDE_AUTOCONFIGTIME, FC_NUMBER)) {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                        if (*szAutoConfigURL == TEXT('\0') && *szAutoProxyURL == TEXT('\0')) {
                            ErrorMessageBox(hDlg, IDS_AUTOCONFIG_NULL);

                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                        if (!CheckField(hDlg, IDE_AUTOCONFIGURL, FC_URL) ||
                            !CheckField(hDlg, IDE_AUTOPROXYURL,  FC_URL)) {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                    }

                    // write the values to the INS file
                    InsWriteBoolEx(IS_URL, IK_DETECTCONFIG,  fDetectConfig,    g_szCustIns);
                    InsWriteBoolEx(IS_URL, IK_USEAUTOCONF,   fUseAutoConfig,   g_szCustIns);
                    InsWriteString(IS_URL, IK_AUTOCONFTIME,  szAutoConfigTime, g_szCustIns);
                    InsWriteString(IS_URL, IK_AUTOCONFURL,   szAutoConfigURL,  g_szCustIns);
                    InsWriteString(IS_URL, IK_AUTOCONFURLJS, szAutoProxyURL,   g_szCustIns);

                    g_iCurPage = PPAGE_QUERYAUTOCONFIG;
                    EnablePages();
                    (((NMHDR FAR *)lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        case IDC_YESAUTOCON:
                            fUseAutoConfig = (IsDlgButtonChecked(hDlg, IDC_YESAUTOCON) == BST_CHECKED);
                            
                            EnableDlgItem2(hDlg, IDE_AUTOCONFIGTIME, fUseAutoConfig);
                            EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT2, fUseAutoConfig);
                            EnableDlgItem2(hDlg, IDC_AUTOCONFIGTEXT3, fUseAutoConfig);    
                            EnableDlgItem2(hDlg, IDE_AUTOCONFIGURL, fUseAutoConfig);
                            EnableDlgItem2(hDlg, IDC_AUTOCONFIGURL_TXT, fUseAutoConfig);
                            EnableDlgItem2(hDlg, IDE_AUTOPROXYURL,  fUseAutoConfig);
                            EnableDlgItem2(hDlg, IDC_AUTOPROXYURL_TXT, fUseAutoConfig);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

void EnableProxyControls(HWND hDlg, BOOL fSame, BOOL fUseProxy)
{
    EnableDlgItem2(hDlg, IDE_FTPPROXY, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_FTPPORT, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDC_FTPPROXY1, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SECPROXY, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SECPORT, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDC_SECPROXY1, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_GOPHERPROXY, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_GOPHERPORT, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDC_GOPHERPROXY1, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SOCKSPROXY, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_SOCKSPORT, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDC_SOCKSPROXY1, (!fSame) && fUseProxy);
    EnableDlgItem2(hDlg, IDE_HTTPPROXY, fUseProxy);
    EnableDlgItem2(hDlg, IDE_HTTPPORT, fUseProxy);
    EnableDlgItem2(hDlg, IDC_HTTPPROXY1, fUseProxy);
    EnableDlgItem2(hDlg, IDC_SAMEFORALL, fUseProxy);
    EnableDlgItem2(hDlg, IDE_DISPROXYADR, fUseProxy);
    EnableDlgItem2(hDlg, IDC_DISPROXYADR1, fUseProxy);
    EnableDlgItem2(hDlg, IDC_DISPROXYLOCAL, fUseProxy);
}

void InitializeProxy(HWND hDlg, LPCTSTR szInsFile)
{
    BOOL fUseProxy;
    BOOL fSameProxy;
    BOOL fLocal;
    LPTSTR pLocal;
    TCHAR szProxy[MAX_PATH];
    TCHAR szProxyOverride[MAX_STRING];

    fUseProxy = InsGetBool(IS_PROXY, IK_PROXYENABLE, FALSE, szInsFile);
    CheckDlgButton( hDlg, IDC_YESPROXY, fUseProxy );

    fSameProxy = InsGetBool(IS_PROXY, IK_SAMEPROXY, TRUE, szInsFile);
    CheckDlgButton( hDlg, IDC_SAMEFORALL, fSameProxy );

    GetPrivateProfileString( IS_PROXY, IK_HTTPPROXY, TEXT(""), szProxy,
        countof(szProxy), szInsFile );
    if( fSameProxy )
    {
        SetProxyDlg( hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT, TRUE );
        SetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE );
        SetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE );
        SetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE );
        SetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE );
    }
    else
    {
        SetProxyDlg( hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT, TRUE );
        GetPrivateProfileString( IS_PROXY, IK_FTPPROXY, TEXT(""), szProxy, countof(szProxy), szInsFile );
        SetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE );
        GetPrivateProfileString( IS_PROXY, IK_GOPHERPROXY, TEXT(""), szProxy, countof(szProxy), szInsFile );
        SetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE );
        GetPrivateProfileString( IS_PROXY, IK_SECPROXY, TEXT(""), szProxy, countof(szProxy), szInsFile );
        SetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE );
        GetPrivateProfileString( IS_PROXY, IK_SOCKSPROXY, TEXT(""), szProxy, countof(szProxy), szInsFile );
        if( lstrlen( szProxy ))
            SetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE );
    }

    GetPrivateProfileString( IS_PROXY, IK_PROXYOVERRIDE, LOCALPROXY, szProxyOverride,
        countof( szProxyOverride ), szInsFile );

    pLocal = StrStr(szProxyOverride, LOCALPROXY);

    if(pLocal != NULL)
    {
        if (pLocal == (LPTSTR) szProxyOverride)         // at the beginning
        {
            LPTSTR pSemi = pLocal + 7;
            if( *pSemi == TEXT(';') ) pSemi++;
            MoveMemory( pLocal, pSemi, (StrLen(pSemi) + 1) * sizeof(TCHAR));
        }
        else if (*(pLocal + 7) == TEXT('\0'))   // at the end
            *(pLocal - 1) = TEXT('\0');
        fLocal = TRUE;
    }
    else
        fLocal = FALSE;
    CheckDlgButton( hDlg, IDC_DISPROXYLOCAL, fLocal );
    SetDlgItemText( hDlg, IDE_DISPROXYADR, szProxyOverride );
    EnableProxyControls( hDlg, fSameProxy, fUseProxy );
}

BOOL SaveProxy(HWND hDlg, LPCTSTR szInsFile)
{
    BOOL fUseProxy;
    BOOL fSameProxy;
    BOOL fLocal;
    TCHAR szProxy[MAX_PATH];
    TCHAR szProxyOverride[MAX_STRING];

    if (!CheckField(hDlg, IDE_HTTPPORT, FC_NUMBER)   ||
        !CheckField(hDlg, IDE_FTPPORT, FC_NUMBER)    ||
        !CheckField(hDlg, IDE_GOPHERPORT, FC_NUMBER) ||
        !CheckField(hDlg, IDE_SECPORT, FC_NUMBER)    ||
        !CheckField(hDlg, IDE_SOCKSPORT, FC_NUMBER))
        return FALSE;

    fSameProxy = IsDlgButtonChecked( hDlg, IDC_SAMEFORALL );
    fUseProxy = IsDlgButtonChecked( hDlg, IDC_YESPROXY );
    fLocal = IsDlgButtonChecked( hDlg, IDC_DISPROXYLOCAL );
    GetProxyDlg( hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT );
    WritePrivateProfileString( IS_PROXY, IK_HTTPPROXY, szProxy, szInsFile );
    GetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT );
    WritePrivateProfileString( IS_PROXY, IK_FTPPROXY, szProxy, szInsFile );
    GetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT );
    WritePrivateProfileString( IS_PROXY, IK_GOPHERPROXY, szProxy, szInsFile );
    GetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT );
    WritePrivateProfileString( IS_PROXY, IK_SECPROXY, szProxy, szInsFile );
    GetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT );
    WritePrivateProfileString( IS_PROXY, IK_SOCKSPROXY, szProxy, szInsFile );
    WritePrivateProfileString( IS_PROXY, IK_SAMEPROXY, fSameProxy ? TEXT("1") : TEXT("0"), szInsFile );
    WritePrivateProfileString( IS_PROXY, IK_PROXYENABLE, fUseProxy ? TEXT("1") : TEXT("0"), szInsFile );
    GetDlgItemText( hDlg, IDE_DISPROXYADR, szProxyOverride, countof(szProxyOverride) - 10 ); // 8 for ;<local> + 2 for ""
    if( fLocal )
    {
        if( *szProxyOverride )
        {
            TCHAR szPort[MAX_STRING];

            StrRemoveAllWhiteSpace(szProxyOverride);
            wnsprintf(szPort, countof(szPort), TEXT("%s;%s"), szProxyOverride, LOCALPROXY );
            InsWriteQuotedString( IS_PROXY, IK_PROXYOVERRIDE, szPort, szInsFile );
        }
        else
            WritePrivateProfileString( IS_PROXY, IK_PROXYOVERRIDE, LOCALPROXY, szInsFile );
    }
    else
        WritePrivateProfileString( IS_PROXY, IK_PROXYOVERRIDE, szProxyOverride, szInsFile );

    return TRUE;
}

BOOL APIENTRY ProxySettings( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    BOOL fSameProxy;
    BOOL fUseProxy;
    BOOL fLocal;
    TCHAR szProxy[MAX_PATH];

    switch( msg )
    {
    case WM_INITDIALOG:
        InitSysFont(hDlg, IDE_HTTPPROXY);
        InitSysFont(hDlg, IDE_SECPROXY);
        InitSysFont(hDlg, IDE_FTPPROXY);
        InitSysFont(hDlg, IDE_GOPHERPROXY);
        InitSysFont(hDlg, IDE_SOCKSPROXY);
        InitSysFont(hDlg, IDE_DISPROXYADR);

        Edit_LimitText(GetDlgItem(hDlg, IDE_HTTPPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_FTPPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_GOPHERPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SECPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SOCKSPORT), 5);
        Edit_LimitText(GetDlgItem(hDlg, IDE_DISPROXYADR), MAX_STRING - 11); // 8 for ;<local> + 2 for the double quotes

        g_hWizard = hDlg;
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_COMMAND:
        fSameProxy = IsDlgButtonChecked( hDlg, IDC_SAMEFORALL );
        fUseProxy = IsDlgButtonChecked( hDlg, IDC_YESPROXY );
        fLocal = IsDlgButtonChecked( hDlg, IDC_DISPROXYLOCAL );

        if( HIWORD(wParam) == BN_CLICKED )
        {
            switch( LOWORD(wParam))
            {
            case IDC_SAMEFORALL:
                GetProxyDlg(hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT);
                if( fSameProxy )
                {
                    SetProxyDlg( hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT, TRUE );
                    SetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE );
                    SetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE );
                    SetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE );
                    SetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE );
                }
                // fallthrough

            case IDC_YESPROXY:
                EnableProxyControls( hDlg, fSameProxy, fUseProxy );
                break;
            }
        }
        else if( (HIWORD(wParam) == EN_UPDATE) && fSameProxy && ((LOWORD(wParam) == IDE_HTTPPROXY) || (LOWORD(wParam) == IDE_HTTPPORT)))
        {
            GetProxyDlg(hDlg, szProxy, IDE_HTTPPROXY, IDE_HTTPPORT);
            SetProxyDlg( hDlg, szProxy, IDE_FTPPROXY, IDE_FTPPORT, TRUE );
            SetProxyDlg( hDlg, szProxy, IDE_GOPHERPROXY, IDE_GOPHERPORT, TRUE );
            SetProxyDlg( hDlg, szProxy, IDE_SECPROXY, IDE_SECPORT, TRUE );
            SetProxyDlg( hDlg, szProxy, IDE_SOCKSPROXY, IDE_SOCKSPORT, FALSE );
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
            case PSN_HELP:
                IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                break;

            case PSN_SETACTIVE:
                SetBannerText(hDlg);
                InitializeProxy(hDlg, g_szCustIns);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                CheckBatchAdvance(hDlg);
                break;

            case PSN_WIZNEXT:
            case PSN_WIZBACK:
                if (!SaveProxy(hDlg, g_szCustIns))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE;
                }
                g_iCurPage = PPAGE_PROXY;
                EnablePages();
                if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                    PageNext(hDlg);
                else
                    PagePrev(hDlg);
                break;

            case PSN_WIZFINISH:
                break;

            case PSN_QUERYCANCEL:
                QueryCancel(hDlg);
                break;

            default:
                return FALSE;
    }
    break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL CALLBACK ConnectSetDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_CSNOIMPORT:
                            DisableDlgItem(hDlg, IDC_MODIFYCONNECT);
                            break;

                        case IDC_CSIMPORT:
                            EnableDlgItem(hDlg, IDC_MODIFYCONNECT);
                            break;

                        case IDC_MODIFYCONNECT:
                            ShowInetcpl(hDlg, INET_PAGE_CONNECTION, g_fIntranet ? IEM_CORP : IEM_NEUTRAL);
                            break;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                {
                    BOOL fImport;

                    SetBannerText(hDlg);
                    fImport = GetPrivateProfileInt(IS_CONNECTSET, OPTION, 0, g_szCustIns);
                    EnableDlgItem2(hDlg, IDC_MODIFYCONNECT, fImport);
                    CheckRadioButton(hDlg, IDC_CSNOIMPORT, IDC_CSIMPORT, fImport ? IDC_CSIMPORT : IDC_CSNOIMPORT);
                    CheckDlgButton(hDlg, IDC_DELCONNECT,
                        GetPrivateProfileInt(IS_CONNECTSET, IK_DELETECONN, 0, g_szCustIns) ? BST_CHECKED : BST_UNCHECKED);

                    ShowWindow(GetDlgItem(hDlg, IDC_DELCONNECT), g_fIntranet ? SW_SHOWNORMAL : SW_HIDE);
                    ShowWindow(GetDlgItem(hDlg, IDC_DELCONNECT_TXT), g_fIntranet ? SW_SHOWNORMAL : SW_HIDE);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                    CheckBatchAdvance(hDlg);
                    break;
                }

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                {
                    CNewCursor cur(IDC_WAIT);
                    TCHAR szWorkDir[MAX_PATH];

                    g_cmCabMappings.GetFeatureDir(FEATURE_CONNECT, szWorkDir);
                    g_fImportConnect = (IsDlgButtonChecked(hDlg, IDC_CSIMPORT) == BST_CHECKED);

                    ImportConnectSet(g_szCustIns, szWorkDir, g_szTempSign, g_fImportConnect, g_fIntranet ? IEM_CORP : IEM_NEUTRAL);
                    InsWriteBool(IS_CONNECTSET, IK_DELETECONN,
                        g_fIntranet && (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_DELCONNECT)), g_szCustIns);

                    g_iCurPage = PPAGE_CONNECTSET;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;
                }

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

BOOL APIENTRY InstallDirectory(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szWrk[MAX_PATH];
    BOOL fAllow;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            InitSysFont( hDlg, IDE_INSTALLDIR);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
                switch (LOWORD(wParam))
                {
                    case IDC_BROWSEDIR:
                        {
                            TCHAR szInstructions[MAX_PATH];
                            LoadString(g_rvInfo.hInst,IDS_INSTALLDIR,szInstructions,countof(szInstructions));

                            if (BrowseForFolder(hDlg, s_szInstallDir, szInstructions))
                                SetDlgItemText( hDlg, IDE_INSTALLDIR, s_szInstallDir );
                            break;
                        }

                    case IDC_PROGFILES32:
                    case IDC_FULLPATH32:
                        CheckRadioButton( hDlg, IDC_PROGFILES32, IDC_FULLPATH32, LOWORD(wParam) );
                        GetDlgItemText( hDlg, IDE_INSTALLDIR, s_szInstallDir, MAX_PATH );
                        if (LOWORD(wParam) != IDC_FULLPATH32)
                        {
                            DisableDlgItem(hDlg, IDC_BROWSEDIR);
                            if (StrChr(s_szInstallDir, TEXT('\\')) || lstrlen(s_szInstallDir) == 0)
                            {
                                LoadString( g_rvInfo.hInst, IDS_IE, s_szInstallDir, MAX_PATH );
                                SetDlgItemText( hDlg, IDE_INSTALLDIR, s_szInstallDir );
                            }
                        }
                        else
                        {
                            if (s_szInstallDir[1] != TEXT(':'))
                                SetDlgItemText( hDlg, IDE_INSTALLDIR, TEXT("") );
                            EnableDlgItem(hDlg, IDC_BROWSEDIR);
                        }
                        break;
                }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    GetPrivateProfileString( IS_BRANDING, TEXT("InstallDir"), TEXT(""), szWrk, MAX_PATH, g_szCustIns );
                    if (*szWrk != TEXT('%'))
                    {
                        g_iInstallOpt = INSTALL_OPT_FULL;
                        if (ISNONNULL(szWrk))
                        {
                            StrCpy(s_szInstallDir, szWrk);
                            CheckRadioButton( hDlg, IDC_PROGFILES32, IDC_FULLPATH32, IDC_FULLPATH32 );
                        }
                        else
                        {
                            LoadString( g_rvInfo.hInst, IDS_IE, s_szInstallDir, MAX_PATH );
                            g_iInstallOpt = INSTALL_OPT_PROG;
                            CheckRadioButton( hDlg, IDC_PROGFILES32, IDC_FULLPATH32, IDC_PROGFILES32 );
                            DisableDlgItem(hDlg, IDC_BROWSEDIR);
                        }
                    }
                    else
                    {
                        switch (szWrk[1])
                        {
                            case TEXT('p'):
                            case TEXT('P'):
                            default:
                                g_iInstallOpt = INSTALL_OPT_PROG;
                                CheckRadioButton( hDlg, IDC_PROGFILES32, IDC_FULLPATH32, IDC_PROGFILES32 );
                                break;
                        }
                        DisableDlgItem(hDlg, IDC_BROWSEDIR);
                        StrCpy(s_szInstallDir, &szWrk[3]);
                    }

                    SetDlgItemText( hDlg, IDE_INSTALLDIR, s_szInstallDir );
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    if (g_fSilent || g_fStealth)
                        DisableDlgItem(hDlg, IDC_ALLOWINSTALLDIR);
                    else
                    {
                        EnableDlgItem(hDlg, IDC_ALLOWINSTALLDIR);
                        fAllow =  GetPrivateProfileInt(IS_BRANDING, TEXT("AllowInstallDir"), 1, g_szCustIns);

                        CheckDlgButton(hDlg, IDC_ALLOWINSTALLDIR,
                            fAllow ? BST_CHECKED : BST_UNCHECKED);

                    }
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    GetDlgItemText( hDlg, IDE_INSTALLDIR, g_szInstallFolder, MAX_PATH );
                    if ((IsDlgButtonChecked( hDlg, IDC_FULLPATH32 ) == BST_CHECKED))
                    {
                        if (PathIsRelative(g_szInstallFolder))
                        {
                            ErrorMessageBox(hDlg, IDS_BADDEST);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                        StrCpy(s_szInstallDir, g_szInstallFolder);
                        g_iInstallOpt = INSTALL_OPT_FULL;
                    }
                    else
                    {
                        if (!PathIsRelative(g_szInstallFolder))
                        {
                            ErrorMessageBox(hDlg, IDS_RELATIVE_ONLY);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }
                        if ((IsDlgButtonChecked( hDlg, IDC_PROGFILES32 )  == BST_CHECKED))
                        {
                            g_iInstallOpt = INSTALL_OPT_PROG;
                            wnsprintf(s_szInstallDir, countof(s_szInstallDir), TEXT("%%p\\%s"), g_szInstallFolder);
                        }
                    }

                    //----- Validate input -----
                    if (!PathIsValidPath(g_szInstallFolder)) {
                        HWND hEdit;
                        UINT nID;

                        ErrorMessageBox(hDlg, IDS_BADDEST);

                        switch (g_iInstallOpt) {
                        case INSTALL_OPT_FULL: nID = IDC_FULLPATH32;
                        case INSTALL_OPT_PROG: nID = IDC_PROGFILES32;
                        default:               nID = (UINT)-1; ASSERT(FALSE);
                        };

                        hEdit = GetDlgItem(hDlg, nID);
                        Edit_SetSel(hEdit, 0, -1);
                        SetFocus(hEdit);

                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    }

                    WritePrivateProfileString( IS_BRANDING, TEXT("InstallDir"), s_szInstallDir, g_szCustIns );

                    fAllow = (IsDlgButtonChecked(hDlg, IDC_ALLOWINSTALLDIR) == BST_CHECKED) && !g_fSilent && !g_fStealth;
                    WritePrivateProfileString(IS_BRANDING, TEXT("AllowInstallDir"),
                        fAllow ? TEXT("1") : TEXT("0"), g_szCustIns);
                    
                    g_iCurPage = PPAGE_INSTALLDIR;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_WIZFINISH:
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

//
//  FUNCTION: CorpCustomizeCustom(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "Corp Customize Custom" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
BOOL APIENTRY CorpCustomizeCustom(
    HWND hDlg,
    UINT message,
    WPARAM,
    LPARAM lParam)
{
    BOOL fCompatDisabled;
    BOOL fCustDisabled;
    BOOL fBackupDisabled;
    int iDefaultBrowserCheck;

    switch (message)
    {
        case WM_INITDIALOG:
            break;


        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    //from the former shellinteg dlg

                    g_fInteg = GetPrivateProfileInt( BRANDING, WEB_INTEGRATED, 0, g_szCustIns );

                    CheckDlgButton(hDlg, IDC_DESKTOPUPDATE, g_fInteg ? BST_CHECKED : BST_UNCHECKED);
                    
                    // BUGBUG: <oliverl> should probably move this stuff into server side file for IEAK6

                    EnableDlgItem2(hDlg, IDC_IECOMPAT, !(g_fSilent || g_fStealth));
                    EnableDlgItem2(hDlg, IDC_CUSTCUST, !(g_fSilent || g_fStealth));
                    EnableDlgItem2(hDlg, IDC_NOXFLAG, !(g_fSilent || g_fStealth));

                    iDefaultBrowserCheck = GetPrivateProfileInt(IS_BRANDING, TEXT("BrowserDefault"), 2, g_szCustIns);
                    if (!(g_fSilent || g_fStealth))
                    {
                        fCompatDisabled = GetPrivateProfileInt(IS_BRANDING, TEXT("HideCompat"), 0, g_szCustIns);
                        CheckDlgButton(hDlg, IDC_IECOMPAT, fCompatDisabled ? BST_CHECKED : BST_UNCHECKED);
                        fCustDisabled = GetPrivateProfileInt(IS_BRANDING, TEXT("HideCustom"), 0, g_szCustIns);
                        CheckDlgButton(hDlg, IDC_CUSTCUST, fCustDisabled ? BST_CHECKED : BST_UNCHECKED);
                    }
                    else
                    {
                        if (iDefaultBrowserCheck == 2)
                            iDefaultBrowserCheck = 0;
                    }

                    CheckRadioButton(hDlg, IDC_XFLAGFALSE, IDC_NOXFLAG, IDC_XFLAGFALSE + iDefaultBrowserCheck);

                    fBackupDisabled = GetPrivateProfileInt(IS_BRANDING, TEXT("NoBackup"), 0, g_szCustIns);
                    CheckDlgButton(hDlg, IDC_NOBACKUPDATA, fBackupDisabled ? BST_CHECKED : BST_UNCHECKED);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                    //from the former shellinteg dlg
                    TCHAR szBrandingDir[MAX_PATH];

                    g_fInteg = IsDlgButtonChecked(hDlg, IDC_DESKTOPUPDATE);

                    if (g_fOCW)
                    {
                        HKEY hkIEAK;

                        if(RegOpenKeyEx(HKEY_CURRENT_USER, RK_IEAK_SERVER, 0, KEY_READ, &hkIEAK) == ERROR_SUCCESS)
                        {
                            DWORD dwData;

                            dwData = g_fInteg ? 1 : 0;
                            RegSetValueEx(hkIEAK, TEXT("InstallShell"), 0, REG_DWORD, (LPBYTE) &dwData, sizeof(dwData));
                            RegCloseKey(hkIEAK);
                        }
                    }

                    WritePrivateProfileString( BRANDING, WEB_INTEGRATED,
                        g_fInteg ? TEXT("1") : TEXT("0"), g_szCustIns );

                    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szBrandingDir);

                    if (g_fInteg)
                    {
                        TCHAR szFixIEIcoInf[MAX_PATH];

                        WritePrivateProfileString(EXTREGINF, TEXT("FixIEIco"), TEXT("*,fixieico.inf,DefaultInstall"), g_szCustIns);

                        // fixieico.inf is under iebin\<lang>\optional
                        StrCpy(szFixIEIcoInf, g_szMastInf);
                        PathRemoveFileSpec(szFixIEIcoInf);
                        PathAppend(szFixIEIcoInf, TEXT("fixieico.inf"));

                        // copy fixieico.inf from iebin\<lang>\optional to the branding dir
                        PathAppend(szBrandingDir, TEXT("fixieico.inf"));
                        CopyFile(szFixIEIcoInf, szBrandingDir, FALSE);
                    }
                    else
                    {
                        // delete the FixIEIco line
                        WritePrivateProfileString(EXTREGINF, TEXT("FixIEIco"), NULL, g_szCustIns);

                        // delete fixieico.inf from the branding dir
                        PathAppend(szBrandingDir, TEXT("fixieico.inf"));
                        DeleteFile(szBrandingDir);
                    }


                    //

                    if (!(g_fSilent || g_fStealth))
                    {
                        fCompatDisabled = (IsDlgButtonChecked(hDlg, IDC_IECOMPAT) == BST_CHECKED);
                        WritePrivateProfileString(IS_BRANDING, TEXT("HideCompat"),
                            fCompatDisabled ? TEXT("1") : TEXT("0"), g_szCustIns);
                        fCustDisabled = (IsDlgButtonChecked(hDlg, IDC_CUSTCUST) == BST_CHECKED);
                        WritePrivateProfileString(IS_BRANDING, TEXT("HideCustom"),
                            fCustDisabled ? TEXT("1") : TEXT("0"), g_szCustIns);
                    }
                    fBackupDisabled = (IsDlgButtonChecked(hDlg, IDC_NOBACKUPDATA) == BST_CHECKED);
                    WritePrivateProfileString(IS_BRANDING, TEXT("NoBackup"),
                        fBackupDisabled ? TEXT("1") : TEXT("0"), g_szCustIns);

                    if (IsDlgButtonChecked(hDlg, IDC_XFLAGFALSE) == BST_CHECKED)
                        WritePrivateProfileString(IS_BRANDING, TEXT("BrowserDefault"), TEXT("0"), g_szCustIns);
                    else
                    {
                        if (IsDlgButtonChecked(hDlg, IDC_XFLAGTRUE) == BST_CHECKED)
                            WritePrivateProfileString(IS_BRANDING, TEXT("BrowserDefault"), TEXT("1"), g_szCustIns);
                        else
                            WritePrivateProfileString(IS_BRANDING, TEXT("BrowserDefault"), TEXT("2"), g_szCustIns);
                    }
                    g_iCurPage = PPAGE_CORPCUSTOM;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;


                default:
                    return FALSE;

        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

BOOL APIENTRY SilentInstall(HWND hDlg, UINT message, WPARAM, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            break;


        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;


        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    if (!g_fDownload && !g_fLAN && !g_fCD)
                    {
                        g_fStealth = FALSE;
                        DisableDlgItem(hDlg, IDC_SILENTALL);
                    }

                    g_fSilent = GetPrivateProfileInt( BRANDING, SILENT_INSTALL, 0, g_szCustIns );
                    g_fStealth = GetPrivateProfileInt( BRANDING, TEXT("StealthInstall"), 0, g_szCustIns );

                    CheckRadioButton(hDlg, IDC_SILENTNOT, IDC_SILENTSOME,
                        g_fStealth ? IDC_SILENTALL : (g_fSilent ? IDC_SILENTSOME : IDC_SILENTNOT));

                    if (g_fLAN && !g_fDownload && !g_fCD && !g_fBrandingOnly)
                    {
                        ShowDlgItem(hDlg, IDC_URD);
                        ShowDlgItem(hDlg, IDC_URD_GROUP);
                        ShowDlgItem(hDlg, IDC_URD_TEXT1);
                        ShowDlgItem(hDlg, IDC_URD_TEXT2);
                        ShowDlgItem(hDlg, IDC_URD_TEXT3);
                        ReadBoolAndCheckButton(IS_HIDECUST, IK_URD_STR, FALSE, g_szCustIns, hDlg, IDC_URD);
                    }
                    else
                    {
                        CheckDlgButton(hDlg, IDC_URD, BST_UNCHECKED);
                        HideDlgItem(hDlg, IDC_URD);
                        HideDlgItem(hDlg, IDC_URD_GROUP);
                        HideDlgItem(hDlg, IDC_URD_TEXT1);
                        HideDlgItem(hDlg, IDC_URD_TEXT2);
                        HideDlgItem(hDlg, IDC_URD_TEXT3);
                    }

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    g_fSilent = IsDlgButtonChecked(hDlg, IDC_SILENTSOME);
                    WritePrivateProfileString( BRANDING, SILENT_INSTALL, g_fSilent ? TEXT("1") : TEXT("0"), g_szCustIns );

                    g_fStealth = IsDlgButtonChecked(hDlg, IDC_SILENTALL);
                    WritePrivateProfileString( BRANDING, TEXT("StealthInstall"), g_fStealth ? TEXT("1") : TEXT("0"), g_szCustIns );

                    CheckButtonAndWriteBool(hDlg, IDC_URD, IS_HIDECUST, IK_URD_STR, g_szCustIns);

                    g_iCurPage = PPAGE_SILENTINSTALL;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_WIZFINISH:
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

BOOL CALLBACK SecurityZonesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // ieaklite clean-up
            DeleteFileInDir(TEXT("seczones.inf"), g_szTempSign);
            DeleteFileInDir(TEXT("ratings.inf"),  g_szTempSign);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    BOOL fImport;

                    SetBannerText(hDlg);

                    fImport = InsGetBool(SECURITY_IMPORTS, TEXT("ImportSecZones"), FALSE, g_szCustIns);
                    CheckRadioButton(hDlg, IDC_NOZONES, IDC_IMPORTZONES, fImport ? IDC_IMPORTZONES : IDC_NOZONES);
                    EnableDlgItem2(hDlg, IDC_MODIFYZONES, fImport);

                    fImport = InsGetBool(SECURITY_IMPORTS, TEXT("ImportRatings"), FALSE, g_szCustIns);
                    CheckRadioButton(hDlg, IDC_NORAT, IDC_IMPORTRAT, fImport ? IDC_IMPORTRAT : IDC_NORAT);
                    EnableDlgItem2(hDlg, IDC_MODIFYRAT, fImport);

                    CheckBatchAdvance(hDlg);
                    break;
                }

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                {
                    TCHAR szBrandingDir[MAX_PATH];
                    TCHAR szSecZonesInf[MAX_PATH];
                    TCHAR szRatingsInf[MAX_PATH];
                    HCURSOR hOldCur;

                    hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

                    // seczones.inf goes into the branding.cab
                    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szBrandingDir);
                    PathCombine(szSecZonesInf, szBrandingDir, TEXT("seczones.inf"));

                    ImportZones(g_szCustIns, NULL, szSecZonesInf, IsDlgButtonChecked(hDlg, IDC_IMPORTZONES) == BST_CHECKED);
                    
                    // ratings.inf goes into the branding.cab
                    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szBrandingDir);
                    PathCombine(szRatingsInf, szBrandingDir, TEXT("ratings.inf"));

                    ImportRatings(g_szCustIns, NULL, szRatingsInf, IsDlgButtonChecked(hDlg, IDC_IMPORTRAT) == BST_CHECKED);

                    SetCursor(hOldCur);

                    g_iCurPage = PPAGE_SECURITY;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;
                }

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_NOZONES:
                            DisableDlgItem(hDlg, IDC_MODIFYZONES);
                            break;

                        case IDC_IMPORTZONES:
                            EnableDlgItem(hDlg, IDC_MODIFYZONES);
                            break;

                        case IDC_MODIFYZONES:
                            ModifyZones(hDlg);
                            break;

                        case IDC_NORAT:
                            DisableDlgItem(hDlg, IDC_MODIFYRAT);
                            break;

                        case IDC_IMPORTRAT:
                            EnableDlgItem(hDlg, IDC_MODIFYRAT);
                            break;

                        case IDC_MODIFYRAT:
                            ModifyRatings(hDlg);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


BOOL CALLBACK SecurityCertsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // ieaklite clean-up
            DeleteFileInDir(TEXT("sitecert.inf"), g_szTempSign);
            DeleteFileInDir(TEXT("root.str"),     g_szTempSign);
            DeleteFileInDir(TEXT("ca.str"),       g_szTempSign);
            DeleteFileInDir(TEXT("authcode.inf"), g_szTempSign);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    BOOL fImport;

                    SetBannerText(hDlg);

                    fImport = InsGetBool(SECURITY_IMPORTS, TEXT("ImportSiteCert"), FALSE, g_szCustIns);
                        
                    CheckRadioButton(hDlg, IDC_NOSC, IDC_IMPORTSC, fImport ? IDC_IMPORTSC : IDC_NOSC);
                    EnableDlgItem2(hDlg, IDC_MODIFYSC, fImport);

                    fImport = InsGetBool(SECURITY_IMPORTS, TEXT("ImportAuthCode"), FALSE, g_szCustIns);
                    CheckRadioButton(hDlg, IDC_NOAUTH, IDC_IMPORTAUTH, fImport ? IDC_IMPORTAUTH : IDC_NOAUTH);
                    EnableDlgItem2(hDlg, IDC_MODIFYAUTH, fImport);

                    CheckBatchAdvance(hDlg);
                    break;
                }

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                {
                    TCHAR szBrandingDir[MAX_PATH];
                    TCHAR szSiteCertInf[MAX_PATH];
                    TCHAR szRootStr[MAX_PATH];
                    TCHAR szCaStr[MAX_PATH];
                    TCHAR szAuthCodeInf[MAX_PATH];
                    HCURSOR hOldCur;

                    hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

                    // sitecert.inf, root.str and ca.str goes into the branding.cab
                    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szBrandingDir);
                    PathCombine(szSiteCertInf, szBrandingDir, TEXT("sitecert.inf"));
                    PathCombine(szRootStr, szBrandingDir, TEXT("root.str"));
                    PathCombine(szCaStr, szBrandingDir, TEXT("ca.str"));

                    ImportSiteCert(g_szCustIns, NULL, szSiteCertInf, IsDlgButtonChecked(hDlg, IDC_IMPORTSC) == BST_CHECKED);

                    // authcode.inf goes into the branding.cab
                    g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szBrandingDir);
                    PathCombine(szAuthCodeInf, szBrandingDir, TEXT("authcode.inf"));

                    ImportAuthCode(g_szCustIns, NULL, szAuthCodeInf, IsDlgButtonChecked(hDlg, IDC_IMPORTAUTH) == BST_CHECKED);

                    SetCursor(hOldCur);

                    g_iCurPage = PPAGE_SECURITYCERT;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;
                }

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_NOSC:
                            DisableDlgItem(hDlg, IDC_MODIFYSC);
                            break;

                        case IDC_IMPORTSC:
                            EnableDlgItem(hDlg, IDC_MODIFYSC);
                            break;

                        case IDC_MODIFYSC:
                            ModifySiteCert(hDlg);
                            break;

                        case IDC_NOAUTH:
                            DisableDlgItem(hDlg, IDC_MODIFYAUTH);
                            break;

                        case IDC_IMPORTAUTH:
                            EnableDlgItem(hDlg, IDC_MODIFYAUTH);
                            break;

                        case IDC_MODIFYAUTH:
                            ModifyAuthCode(hDlg);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wizard.rc
//
#define IDI_WIZARD                      101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        1001
#define _APS_NEXT_COMMAND_VALUE         20001
#define _APS_NEXT_CONTROL_VALUE         10001
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

/////////////////////////////////////////////////////////////////////////
//
//  ATL / OLE HACKHACK
//
//  Include <w95wraps.h> before anything else that messes with names.
//  Although everybody gets the wrong name, at least it's *consistently*
//  the wrong name, so everything links.
//
//  NOTE:  This means that while debugging you will see functions like
//  ShellExecuteExWrapW when you expected to see
//  ShellExecuteExW.
//
#include <w95wraps.h>

#include <windows.h>
#include <windowsx.h>

#include <commctrl.h>
#include <commdlg.h>
#include <prsht.h>

#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <wininet.h>
#include <inseng.h>
#include <advpub.h>
#include <ras.h>
#include <inetcpl.h>

#include <iedkbrnd.h>
#include "..\ieakutil\ieakutil.h"
#include "..\ieakeng\exports.h"

#include "..\ieakui\common.h"
#include "..\ieakui\resource.h"
#include "..\ieakui\wizard.h"
#include "..\ieakui\legacy.h"

#include "insengt.h"
#include "wizard.h"
#include "cabclass.h"
#include "utils.h"
#include "resource.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\status.cpp ===
#include "precomp.h"

extern BOOL g_fBatch;
extern BOOL g_fBatch2;
extern RECT g_dtRect;

HWND g_hProgress;
HWND g_hStatusDlg;

static void setBoldFace(HWND hDlg, int idControl, BOOL fBold);

void UpdateProgress(int iProgress)
{
    static s_iProgress = 0;

    if (iProgress == -1)
        s_iProgress = 100;
    else
        s_iProgress += iProgress;

    if (s_iProgress > 100)
    {
        s_iProgress = 100;
        ASSERT(FALSE);
    }

    SendMessage(g_hProgress, PBM_SETPOS, s_iProgress, 0L);
}

void StatusDialog (UINT nStep)
{
    if (g_fBatch || g_fBatch2)
        return;

    switch (nStep)
    {
    case SD_STEP1:
        setBoldFace(g_hStatusDlg, IDC_STEP1, TRUE);
        break;

    case SD_STEP2:
        setBoldFace(g_hStatusDlg, IDC_STEP1, FALSE);
        setBoldFace(g_hStatusDlg, IDC_STEP3, TRUE);
        break;
    }
}

static void setBoldFace(HWND hDlg, int idControl, BOOL fBold)
{
    HFONT hFont;
    LOGFONT lfFont;

    hFont = (HFONT) SendDlgItemMessage(hDlg, idControl, WM_GETFONT, 0, 0);

    GetObject(hFont, sizeof(lfFont), &lfFont);
    lfFont.lfWeight = fBold ? FW_BOLD : FW_NORMAL;

    hFont = CreateFontIndirect(&lfFont);

    SendDlgItemMessage(hDlg, idControl, WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\programs.cpp ===
#include "precomp.h"

extern TCHAR g_szCustIns[];
extern TCHAR g_szTempSign[];
extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;

BOOL CALLBACK ProgramsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fImport;

    switch (uMsg)
    {
    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
        case PSN_SETACTIVE:
            // import INS clean-up -- delete old content
            DeleteFileInDir(TEXT("programs.inf"), g_szTempSign);

            SetBannerText(hDlg);

            fImport = !InsIsKeyEmpty(IS_EXTREGINF, IK_PROGRAMS, g_szCustIns);

            CheckRadioButton(hDlg, IDC_PROGNOIMPORT, IDC_PROGIMPORT, fImport ? IDC_PROGIMPORT : IDC_PROGNOIMPORT);
            EnableDlgItem2(hDlg, IDC_MODIFYPROG, fImport);

            CheckBatchAdvance(hDlg);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            fImport = (IsDlgButtonChecked(hDlg, IDC_PROGIMPORT) == BST_CHECKED);

            {
                TCHAR szBrandingDir[MAX_PATH];

                CNewCursor cur(IDC_WAIT);

                g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szBrandingDir);
                ImportPrograms(g_szCustIns, szBrandingDir, fImport);
            }

            g_iCurPage = PPAGE_PROGRAMS;
            EnablePages();
            (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            QueryCancel(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_PROGNOIMPORT:
            DisableDlgItem(hDlg, IDC_MODIFYPROG);
            break;

        case IDC_PROGIMPORT:
            EnableDlgItem(hDlg, IDC_MODIFYPROG);
            break;

        case IDC_MODIFYPROG:
            ShowInetcpl(hDlg, INET_PAGE_PROGRAMS);
            break;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\signup.cpp ===
#include "precomp.h"


// external variable declarations
extern TCHAR g_szCustIns[];
extern TCHAR g_szBuildRoot[];
extern TCHAR g_szLanguage[];
extern TCHAR g_szTempSign[];
extern BOOL g_fBrandingOnly;
extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;


// macro definitions
#define MAX_SIGNUP_FILES 50


// type definitions
typedef struct tagSIGNUPFILE
{
    TCHAR szEntryName[RAS_MaxEntryName + 1];

    TCHAR szEntryPath[MAX_PATH];

    TCHAR szAreaCode[RAS_MaxAreaCode + 1];
    TCHAR szPhoneNumber[RAS_MaxPhoneNumber + 1];
    TCHAR szCountryCode[8];
    TCHAR szCountryId[8];

    TCHAR szName[64];
    TCHAR szPassword[64];

    TCHAR szSupportNum[RAS_MaxPhoneNumber + 1];

    TCHAR szSignupURL[MAX_URL];

    struct
    {
        BOOL  fStaticDNS;
        TCHAR szDNSAddress[32];
        TCHAR szAltDNSAddress[32];

        BOOL  fRequiresLogon:1;
        BOOL  fNegTCPIP:1;
        BOOL  fDisableLCP:1;
        BOOL  fDialAsIs:1;

        BOOL  fPWEncrypt:1;
        BOOL  fSWCompress:1;
        BOOL  fIPHdrComp:1;
        BOOL  fDefGate:1;

        BOOL  fDontApplyIns:1;
        BOOL  fDontModify:1;
        BOOL  fApplyIns:1;
        TCHAR szBrandingCabName[64];
        TCHAR szBrandingCabURL[MAX_URL];
    } Advanced;
} SIGNUPFILE,*PSIGNUPFILE;


// prototype declaration of functions defined in this file
static BOOL CALLBACK SignupDlgProcHelper(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam,
                                         HWND hwndCombo, PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems,
                                         DWORD &nSignupFiles, INT &iSelIndex, BOOL fIsp);

static BOOL CALLBACK IspPopupDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static BOOL CALLBACK InsPopupDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static BOOL CALLBACK SignupPopupDlgProcHelper(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM,
                                              PSIGNUPFILE pSignupFile, BOOL fIsp);

static VOID UpdateSignupFilesStatus(HWND hDlg, LPCTSTR pcszSignupPath);

static DWORD InitSignupFileArray(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems,
                                 HWND hwndCombo, BOOL fIsp);
static VOID SaveSignupFileArray(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems, BOOL fIsp);

static VOID ReadSignupFile(PSIGNUPFILE pSignupFile, LPCTSTR pcszSignupFile, BOOL fIsp);
static VOID WriteSignupFile(PSIGNUPFILE pSignupFile, LPCTSTR pcszSignupFile, BOOL fIsp);

static INT NewSignupFileEntry(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems, HWND hwndCombo,
                              BOOL fIsp);
static VOID SetSignupFileEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp);
static BOOL SaveSignupFileEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp);

static VOID SetSignupFileAdvancedEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp);
static BOOL SaveSignupFileAdvancedEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp);

static VOID SetDlgIPAddress(HWND hDlg, LPCTSTR pcszIPAddress, INT iCtlA, INT iCtlB, INT iCtlC, INT iCtlD);
static VOID GetDlgIPAddress(HWND hDlg, LPTSTR  pszIPAddress,  INT iCtlA, INT iCtlB, INT iCtlC, INT iCtlD);
static BOOL VerifyDlgIPAddress(HWND hDlg, INT iCtlA, INT iCtlB, INT iCtlC, INT iCtlD);

static PSIGNUPFILE IsEntryPathInSignupArray(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems, LPCTSTR pcszEntryPath);

static VOID CleanupSignupFiles(LPCTSTR pcszTempDir, LPCTSTR pcszIns);


// global variables
BOOL g_fServerICW = FALSE;
BOOL g_fServerKiosk = FALSE;
BOOL g_fServerless = FALSE;
BOOL g_fNoSignup = FALSE;

BOOL g_fSkipServerIsps = FALSE;
BOOL g_fSkipIspIns = FALSE;

TCHAR g_szSignup[MAX_PATH];

static TCHAR s_szIsp[MAX_PATH];
static SIGNUPFILE s_SignupFileArray[MAX_SIGNUP_FILES];


BOOL CALLBACK QuerySignupDlgProc(HWND hDlg, UINT uMsg, WPARAM, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    INT id;

                    SetBannerText(hDlg);

                    // do IEAKLite mode clean-up here
                    CleanupSignupFiles(g_szTempSign, g_szCustIns);

                    // initialize signup mode
                    g_fServerICW = InsGetBool(IS_BRANDING, IK_USEICW, 0, g_szCustIns);
                    g_fServerKiosk = InsGetBool(IS_BRANDING, IK_SERVERKIOSK, 0, g_szCustIns);
                    g_fServerless = InsGetBool(IS_BRANDING, IK_SERVERLESS, 0, g_szCustIns);
                    g_fNoSignup = InsGetBool(IS_BRANDING, IK_NODIAL, 0, g_szCustIns);

                    if (!IsWindowEnabled(GetDlgItem(hDlg, IDC_ISS2)))
                        g_fServerICW = FALSE;

                    if (g_fServerICW)
                        id = IDC_ISS2;
                    else if (g_fServerKiosk)
                        id = IDC_ISS;
                    else if (g_fServerless)
                        id = IDC_SERVLESS;
                    else if (g_fNoSignup)
                        id = IDC_NOSIGNUP;
                    else 
                        id = IDC_ISS2;

                    CheckRadioButton(hDlg, IDC_ISS2, IDC_NOSIGNUP, id);

                    CheckBatchAdvance(hDlg);
                    break;
                }

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_ISS2)))
                        g_fServerICW = (IsDlgButtonChecked(hDlg, IDC_ISS2) == BST_CHECKED);
                    else
                        g_fServerICW = FALSE;
                    g_fServerKiosk = (IsDlgButtonChecked(hDlg, IDC_ISS) == BST_CHECKED);
                    g_fServerless = (IsDlgButtonChecked(hDlg, IDC_SERVLESS) == BST_CHECKED);
                    g_fNoSignup = (IsDlgButtonChecked(hDlg, IDC_NOSIGNUP) == BST_CHECKED);

                    InsWriteBool(IS_BRANDING, IK_USEICW, g_fServerICW, g_szCustIns);
                    InsWriteBool(IS_BRANDING, IK_SERVERKIOSK, g_fServerKiosk, g_szCustIns);
                    InsWriteBool(IS_BRANDING, IK_SERVERLESS, g_fServerless, g_szCustIns);
                    InsWriteBool(IS_BRANDING, IK_NODIAL, g_fNoSignup, g_szCustIns);

                    // CopyIE4Files() relies on g_szSignup to be non-empty to copy files from the signup folder
                    // to the temp location so that they will be cabbed up in the branding cab.
                    // We should clear the path here so that if the user chooses a signup mode and then
                    // selects NoSignup, CopyIE4Files() won't copy any files around unnecessarily.
                    *g_szSignup = TEXT('\0');

                    g_iCurPage = PPAGE_QUERYSIGNUP;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


BOOL CALLBACK SignupFilesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDC_SFLOC);
            EnableDBCSChars(hDlg, IDE_SFCOPY);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    // clear the status bitmaps
                    SendMessage(GetDlgItem(hDlg, IDC_SFBMP1), STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, NULL);
                    SendMessage(GetDlgItem(hDlg, IDC_SFBMP2), STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, NULL);
                    SendMessage(GetDlgItem(hDlg, IDC_SFBMP3), STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, NULL);
                    SendMessage(GetDlgItem(hDlg, IDC_SFBMP4), STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, NULL);

                    // disable the copy files button; it will be enabled with the user enters a path or file(s) to copy
                    EnableDlgItem2(hDlg, IDC_COPYSF, GetDlgItemTextLength(hDlg, IDE_SFCOPY) ? TRUE : FALSE);

                    // if the new ICW method is not chosen, disable the status
                    // line that requires icwsign.htm; otherwise, enable it
                    EnableDlgItem2(hDlg, IDC_SFSTATUS1, g_fServerICW);

                    // for the new ICW method, if single disk branding media is chosen,
                    // we require that signup.htm is also supplied to work on downlevel clients
                    if (g_fServerICW)
                        EnableDlgItem2(hDlg, IDC_SFSTATUS2, g_fBrandingOnly);
                    else
                        EnableDlgItem(hDlg, IDC_SFSTATUS2);

                    // for serverless signup, no .ISP files are required
                    // so disable the status line and the check box for .ISP
                    EnableDlgItem2(hDlg, IDC_SFSTATUS3, !g_fServerless);
                    EnableDlgItem2(hDlg, IDC_CHECK3, !g_fServerless);

                    // construct the signup folder path; the signup folder is under the output dir
                    // for e.g.: <output dir>\ins\win32\en\signup\kiosk
                    PathCombine(g_szSignup, g_szBuildRoot, TEXT("ins"));
                    PathAppend(g_szSignup, GetOutputPlatformDir());
                    PathAppend(g_szSignup, g_szLanguage);
                    PathAppend(g_szSignup, TEXT("signup"));

                    // create a different subdir depending on the signup mode chosen
                    PathAppend(g_szSignup, g_fServerICW ? TEXT("icw") : (g_fServerKiosk ? TEXT("kiosk") : TEXT("servless")));

                    SetDlgItemText(hDlg, IDC_SFLOC, g_szSignup);

                    // set the attribs of all the files in the signup folder to NORMAL;
                    // good thing to do because if some of the ISP/INS files have READONLY attrib set,
                    // GetPrivateProfile calls would fail on Win9x
                    SetAttribAllEx(g_szSignup, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, FALSE);

                    // initialize the path to signup.isp (used in subsequent dlg procs)
                    PathCombine(s_szIsp, g_szSignup, TEXT("signup.isp"));

                    UpdateSignupFilesStatus(hDlg, g_szSignup);

                    // initialize modify .ISP files checkbox
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECK3)))
                        ReadBoolAndCheckButton(IS_ICW, IK_MODIFY_ISP, 1, g_szCustIns, hDlg, IDC_CHECK3);

                    // initialize modify .INS files checkbox
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECK4)))
                        ReadBoolAndCheckButton(IS_ICW, IK_MODIFY_INS, 1, g_szCustIns, hDlg, IDC_CHECK4);

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    // do error checking only if the user clicked the Next button
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                    {
                        // for ICW mode, make sure that icwsign.htm is present in the signup folder
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_SFSTATUS1)))
                        {
                            if (!PathFileExistsInDir(TEXT("icwsign.htm"), g_szSignup))
                            {
                                ErrorMessageBox(hDlg, IDS_ICWHTM_MISSING);

                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                return TRUE;
                            }
                        }

                        // for all other modes including ICW mode with single-disk branding,
                        // make sure that signup.htm is present in the signup folder
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_SFSTATUS2)))
                        {
                            if (!PathFileExistsInDir(TEXT("signup.htm"), g_szSignup))
                            {
                                ErrorMessageBox(hDlg, IDS_SIGNUPHTM_MISSING);

                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                return TRUE;
                            }
                        }

                        // if the modify .ISP files button is unchecked, make sure
                        // that signup.isp is present in the signup folder
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECK3)))
                            if (IsDlgButtonChecked(hDlg, IDC_CHECK3) == BST_UNCHECKED)
                            {
                                if (!PathFileExistsInDir(TEXT("signup.isp"), g_szSignup))
                                {
                                    ErrorMessageBox(hDlg, IDS_SIGNUPISP_MISSING);

                                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                    return TRUE;
                                }

                                // write the magic number to signup.isp so that ICW doesn't complain
                                WritePrivateProfileString(IS_BRANDING, FLAGS, TEXT("16319"), s_szIsp);
                                InsFlushChanges(s_szIsp);
                            }

                        // if the modify .INS files button is unchecked, make sure
                        // that a file called install.ins is not present in the signup folder
                        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECK4)))
                            if (IsDlgButtonChecked(hDlg, IDC_CHECK4) == BST_UNCHECKED)
                            {
                                if (PathFileExistsInDir(TEXT("install.ins"), g_szSignup))
                                {
                                    ErrorMessageBox(hDlg, IDS_INSTALLINS_FOUND);

                                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                    return TRUE;
                                }
                            }
                    }

                    // persist the modify .ISP files checkbox state
                    g_fSkipServerIsps = FALSE;
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECK3)))
                    {
                        g_fSkipServerIsps = (IsDlgButtonChecked(hDlg,IDC_CHECK3) == BST_UNCHECKED);
                        InsWriteBoolEx(IS_ICW, IK_MODIFY_ISP, !g_fSkipServerIsps, g_szCustIns);
                    }
                    else
                        WritePrivateProfileString(IS_ICW, IK_MODIFY_ISP, NULL, g_szCustIns);

                    // persist the modify .INS files checkbox state
                    g_fSkipIspIns = FALSE;
                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECK4)))
                    {
                        g_fSkipIspIns = (IsDlgButtonChecked(hDlg,IDC_CHECK4) == BST_UNCHECKED);
                        InsWriteBoolEx(IS_ICW, IK_MODIFY_INS, !g_fSkipIspIns, g_szCustIns);
                    }
                    else
                        WritePrivateProfileString(IS_ICW, IK_MODIFY_INS, NULL, g_szCustIns);

                    g_iCurPage = PPAGE_SIGNUPFILES;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                TCHAR szCopySignupFiles[MAX_PATH];

                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_SFBROWSE:
                            {
                                TCHAR szInstructions[MAX_PATH];
                                LoadString(g_rvInfo.hInst,IDS_SFDIR,szInstructions,countof(szInstructions));

                                if (BrowseForFolder(hDlg, szCopySignupFiles,szInstructions))
                                    SetDlgItemText(hDlg, IDE_SFCOPY, szCopySignupFiles);
                                break;
                            }

                        case IDC_COPYSF:
                        {
                            HANDLE hFind;
                            WIN32_FIND_DATA fd;

                            GetDlgItemText(hDlg, IDE_SFCOPY, szCopySignupFiles, countof(szCopySignupFiles));

                            // NOTE: szCopySignupFiles can be either a dir or a file.
                            //       if a file, it can contain wildcard chars

                            // FindFirstFile would fail if you specify "\" or "c:\" (root paths); so append *.*
                            if (PathIsRoot(szCopySignupFiles))
                                PathAppend(szCopySignupFiles, TEXT("*.*"));

                            // verify if the path exists
                            if ((hFind = FindFirstFile(szCopySignupFiles, &fd)) != INVALID_HANDLE_VALUE)
                                FindClose(hFind);
                            else
                            {
                                HWND hCtrl = GetDlgItem(hDlg, IDE_SFCOPY);

                                ErrorMessageBox(hDlg, IDS_PATH_DOESNT_EXIST);
                                Edit_SetSel(hCtrl, 0, -1);
                                SetFocus(hCtrl);

                                break;
                            }

                            CNewCursor cur(IDC_WAIT);

                            if (PathIsDirectory(szCopySignupFiles))
                                CopyFilesSrcToDest(szCopySignupFiles, TEXT("*.*"), g_szSignup);
                            else
                            {
                                LPTSTR pszFile;

                                pszFile = PathFindFileName(szCopySignupFiles);
                                PathRemoveFileSpec(szCopySignupFiles);

                                CopyFilesSrcToDest(szCopySignupFiles, pszFile, g_szSignup);
                            }

                            // set the attribs of all the files in the signup folder to NORMAL;
                            // good thing to do because if some of the ISP/INS files have READONLY attrib set,
                            // GetPrivateProfile calls would fail on Win9x
                            SetAttribAllEx(g_szSignup, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, FALSE);

                            // clear out the path in the edit control
                            SetDlgItemText(hDlg, IDE_SFCOPY, TEXT(""));

                            UpdateSignupFilesStatus(hDlg, g_szSignup);
                            break;
                        }
                    }
                    break;

                case EN_CHANGE:
                    switch (LOWORD(wParam))
                    {
                        case IDE_SFCOPY:
                            GetDlgItemText(hDlg, IDE_SFCOPY, szCopySignupFiles, countof(szCopySignupFiles));

                            // enable the copy files button if the path is non-empty
                            if (*szCopySignupFiles == TEXT('\0'))
                                EnsureDialogFocus(hDlg, IDC_COPYSF, IDE_SFCOPY);
                            EnableDlgItem2(hDlg, IDC_COPYSF, *szCopySignupFiles ? TRUE : FALSE);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


BOOL CALLBACK ServerIspsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND s_hwndCombo = NULL;
    static DWORD s_nISPFiles = 0;
    static INT s_iSelIndex = 0;

    if (uMsg == WM_INITDIALOG)
        s_hwndCombo = GetDlgItem(hDlg, IDC_CONNECTION);         // used in lots of places in the dlg proc

    // NOTE: s_nISPFiles and s_iSelIndex are passed by reference.
    return SignupDlgProcHelper(hDlg, uMsg, wParam, lParam,
                    s_hwndCombo, s_SignupFileArray, countof(s_SignupFileArray),
                    s_nISPFiles, s_iSelIndex, TRUE);
}


BOOL CALLBACK SignupInsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND s_hwndCombo = NULL;
    static DWORD s_nINSFiles = 0;
    static INT s_iSelIndex = 0;

    if (uMsg == WM_INITDIALOG)
        s_hwndCombo = GetDlgItem(hDlg, IDC_CONNECTION);         // used in lots of places in the dlg proc

    // NOTE: s_nINSFiles and s_iSelIndex are passed by reference.
    return SignupDlgProcHelper(hDlg, uMsg, wParam, lParam,
                    s_hwndCombo, s_SignupFileArray, countof(s_SignupFileArray), s_nINSFiles,
                    s_iSelIndex, FALSE);
}

static BOOL CALLBACK SignupDlgProcHelper(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam,
                                         HWND hwndCombo, PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems,
                                         DWORD &nSignupFiles, INT &iSelIndex, BOOL fIsp)
{
    PSIGNUPFILE pSignupFileCurrent;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDC_CONNECTION);
            ComboBox_LimitText(hwndCombo, countof(pSignupArray[0].szEntryName) - 1);

            EnableDBCSChars(hDlg, IDE_CONNECTION);
            Edit_LimitText(GetDlgItem(hDlg, IDE_CONNECTION), countof(pSignupArray[0].szEntryPath) - 1);

            DisableDBCSChars(hDlg, IDE_AREACODE);
            DisableDBCSChars(hDlg, IDE_PHONENUMBER);
            DisableDBCSChars(hDlg, IDE_COUNTRYCODE);
            DisableDBCSChars(hDlg, IDE_COUNTRYID);
            Edit_LimitText(GetDlgItem(hDlg, IDE_AREACODE), countof(pSignupArray[0].szAreaCode) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_PHONENUMBER), countof(pSignupArray[0].szPhoneNumber) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_COUNTRYCODE), countof(pSignupArray[0].szCountryCode) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_COUNTRYID), countof(pSignupArray[0].szCountryId) - 1);

            EnableDBCSChars(hDlg, IDE_USERNAME);
            DisableDBCSChars(hDlg, IDE_PASSWORD);
            Edit_LimitText(GetDlgItem(hDlg, IDE_USERNAME), countof(pSignupArray[0].szName) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDE_PASSWORD), countof(pSignupArray[0].szPassword) - 1);

            if (fIsp)
            {
                DisableDBCSChars(hDlg, IDE_SUPPORTNUM);
                Edit_LimitText(GetDlgItem(hDlg, IDE_SUPPORTNUM), countof(pSignupArray[0].szSupportNum) - 1);
            }
            else
            {
                // support number is not applicable on the INS page
                ShowWindow(GetDlgItem(hDlg, IDC_SUPPORTNUM), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDE_SUPPORTNUM), SW_HIDE);
            }

            if (fIsp)
            {
                EnableDBCSChars(hDlg, IDE_SIGNUPURL);
                Edit_LimitText(GetDlgItem(hDlg, IDE_SIGNUPURL), countof(pSignupArray[0].szSignupURL) - 1);
            }
            else
            {
                ShowWindow(GetDlgItem(hDlg, IDC_SIGNUPURLTXT), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDE_SIGNUPURL), SW_HIDE);
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                    // set the window caption
                    {
                        TCHAR szTemp[MAX_PATH];

                        LoadString(g_rvInfo.hInst, fIsp ? IDS_ISPINS1_TITLE : IDS_ISPINS2_TITLE, szTemp, countof(szTemp));
                        SetWindowText(hDlg, szTemp);

                        LoadString(g_rvInfo.hInst, fIsp ? IDS_ISPINS1_TEXT : IDS_ISPINS2_TEXT, szTemp, countof(szTemp));
                        SetWindowText(GetDlgItem(hDlg, IDC_ENTER), szTemp);
                    }

                    // NOTE: SetBannerText should be called *after* the window caption is set because
                    //       it uses the current window caption string to create the banner text.
                    SetBannerText(hDlg);

                    if (fIsp)
                    {
                        // support number should be shown only for the ICW signup mode
                        ShowWindow(GetDlgItem(hDlg, IDC_SUPPORTNUM), g_fServerICW ? SW_SHOW : SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDE_SUPPORTNUM), g_fServerICW ? SW_SHOW : SW_HIDE);
                    }

                    ZeroMemory(pSignupArray, nSignupArrayElems * sizeof(pSignupArray[0]));

                    nSignupFiles = InitSignupFileArray(pSignupArray, nSignupArrayElems, hwndCombo, fIsp);
                    if (nSignupFiles == 0)
                    {
                        NewSignupFileEntry(pSignupArray, nSignupArrayElems, hwndCombo, fIsp);
                        nSignupFiles++;
                    }

                    iSelIndex = 0;

                    pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                    SetSignupFileEntry(hDlg, pSignupFileCurrent, fIsp);

                    ComboBox_SetCurSel(hwndCombo, iSelIndex);

                    EnableDlgItem2(hDlg, IDC_ADDCONNECTION, nSignupFiles < nSignupArrayElems);
                    EnableDlgItem2(hDlg, IDC_RMCONNECTION,  nSignupFiles > 1);

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                    if (!SaveSignupFileEntry(hDlg, pSignupFileCurrent, fIsp))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }

                    // for ISP case, make sure that signup.isp is specified (fIsp && pSignupFileCurrent == NULL).
                    // for INS case, make sure that install.ins is NOT specified (!fIsp && pSignupFileCurrent != NULL).
                    pSignupFileCurrent = IsEntryPathInSignupArray(pSignupArray, nSignupArrayElems, fIsp ? TEXT("signup.isp") : TEXT("install.ins"));
                    if (( fIsp && pSignupFileCurrent == NULL)  ||
                        (!fIsp && pSignupFileCurrent != NULL))
                    {
                        ErrorMessageBox(hDlg, fIsp ? IDS_NEEDSIGNUPISP : IDS_INSTALLINS_SPECIFIED);

                        // BUGBUG: for install.ins case, try sending a CBN_SELENDOK message to display the install.ins entry

                        Edit_SetSel(GetDlgItem(hDlg, IDE_CONNECTION), 0, -1);
                        SetFocus(GetDlgItem(hDlg, IDE_CONNECTION));

                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }

                    SaveSignupFileArray(pSignupArray, nSignupArrayElems, fIsp);

                    if (fIsp)
                    {
                        // write the magic number to signup.isp so that ICW doesn't complain
                        WritePrivateProfileString(IS_BRANDING, FLAGS, TEXT("16319"), s_szIsp);
                        InsFlushChanges(s_szIsp);
                    }

                    g_iCurPage = (fIsp ? PPAGE_SERVERISPS : PPAGE_ISPINS);
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_ADDCONNECTION:
                            pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                            if (!SaveSignupFileEntry(hDlg, pSignupFileCurrent, fIsp))
                                break;

                            iSelIndex = NewSignupFileEntry(pSignupArray, nSignupArrayElems, hwndCombo, fIsp);
                            nSignupFiles++;

                            pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                            SetSignupFileEntry(hDlg, pSignupFileCurrent, fIsp);

                            if (nSignupFiles >= nSignupArrayElems)
                                EnsureDialogFocus(hDlg, IDC_ADDCONNECTION, IDC_RMCONNECTION);
                            EnableDlgItem2(hDlg, IDC_ADDCONNECTION, nSignupFiles < nSignupArrayElems);
                            EnableDlgItem(hDlg, IDC_RMCONNECTION);
                            break;

                        case IDC_RMCONNECTION:
                            pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);

                            DeleteFile(pSignupFileCurrent->szEntryPath);
                            if (!fIsp  &&  !g_fServerless)
                                DeleteFileInDir(pSignupFileCurrent->Advanced.szBrandingCabName, g_szSignup);
                            nSignupFiles--;

                            // clear the entry
                            ZeroMemory(pSignupFileCurrent, sizeof(*pSignupFileCurrent));

                            ComboBox_DeleteString(hwndCombo, iSelIndex);

                            if ((DWORD) iSelIndex >= nSignupFiles)
                                iSelIndex = nSignupFiles - 1;

                            pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                            SetSignupFileEntry(hDlg, pSignupFileCurrent, fIsp);

                            EnableDlgItem(hDlg, IDC_ADDCONNECTION);
                            if (nSignupFiles <= 1)
                                EnsureDialogFocus(hDlg, IDC_RMCONNECTION, IDC_ADDCONNECTION);
                            EnableDlgItem2(hDlg, IDC_RMCONNECTION,  nSignupFiles > 1);
                            break;

                        case IDC_SFADVANCED:
                            pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                            DialogBoxParam(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_SIGNUPPOPUP), hDlg,
                                (DLGPROC) (fIsp ? IspPopupDlgProc : InsPopupDlgProc),
                                (LPARAM) pSignupFileCurrent);
                            break;
                    }
                    break;

                case CBN_SELENDOK:
                {
                    INT iCurSelIndex;

                    if ((iCurSelIndex = ComboBox_GetCurSel(hwndCombo)) != CB_ERR  &&  iCurSelIndex != iSelIndex)
                    {
                        pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                        if (SaveSignupFileEntry(hDlg, pSignupFileCurrent, fIsp))
                        {
                            iSelIndex = iCurSelIndex;

                            pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex);
                            SetSignupFileEntry(hDlg, pSignupFileCurrent, fIsp);
                        }
                    }
                    ComboBox_SetCurSel(hwndCombo, iSelIndex);
                    break;
                }

                case CBN_CLOSEUP:
                case CBN_SELENDCANCEL:
                case CBN_DROPDOWN:
                case CBN_KILLFOCUS:
                    if ((pSignupFileCurrent = (PSIGNUPFILE) ComboBox_GetItemData(hwndCombo, iSelIndex)) != (PSIGNUPFILE) CB_ERR)
                    {
                        TCHAR szEntryName[RAS_MaxEntryName + 1];

                        GetDlgItemText(hDlg, IDC_CONNECTION, szEntryName, countof(szEntryName));

                        if (StrCmpI(pSignupFileCurrent->szEntryName, szEntryName))
                        {
                            ComboBox_DeleteString(hwndCombo, iSelIndex);

                            StrCpy(pSignupFileCurrent->szEntryName, szEntryName);
                            ComboBox_InsertString(hwndCombo, iSelIndex, (LPARAM) pSignupFileCurrent->szEntryName);
                            ComboBox_SetItemData(hwndCombo, iSelIndex, (LPARAM) pSignupFileCurrent);
                        }
                        ComboBox_SetCurSel(hwndCombo, iSelIndex);
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


BOOL CALLBACK NewICWDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL  fCustICWTitle;
    TCHAR szICWTitle[MAX_PATH],
          szTopBmpFile[MAX_PATH] = TEXT(""),
          szLeftBmpFile[MAX_PATH] = TEXT(""),
          szPrevBmpFile[MAX_PATH];

    switch (uMsg)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDE_ICWTITLE);
            EnableDBCSChars(hDlg, IDE_ICWHEADERBMP);
            EnableDBCSChars(hDlg, IDE_ICWWATERBMP);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    // read the checkbox state for customizing the title bar
                    fCustICWTitle = InsGetBool(IS_ICW, IK_CUSTICWTITLE, 0, g_szCustIns);
                    CheckDlgButton(hDlg, IDC_ICWTITLE, fCustICWTitle ? BST_CHECKED : BST_UNCHECKED);

                    // read the custom title
                    GetPrivateProfileString(IS_ICW, IK_ICWDISPNAME, TEXT(""), szICWTitle, countof(szICWTitle), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_ICWTITLE, szICWTitle);

                    // read top bitmap file
                    GetPrivateProfileString(IS_ICW, IK_HEADERBMP, TEXT(""), szTopBmpFile, countof(szTopBmpFile), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_ICWHEADERBMP, szTopBmpFile);

                    // read left bitmap file
                    GetPrivateProfileString(IS_ICW, IK_WATERBMP, TEXT(""), szLeftBmpFile, countof(szLeftBmpFile), g_szCustIns);
                    SetDlgItemText(hDlg, IDE_ICWWATERBMP, szLeftBmpFile);

                    EnableDlgItem2(hDlg, IDE_ICWTITLE, fCustICWTitle);
                    EnableDlgItem2(hDlg, IDC_ICWTITLE_TXT, fCustICWTitle);

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    // make sure that if customize title bar is checked, the title bar text is non-empty
                    fCustICWTitle = (IsDlgButtonChecked(hDlg, IDC_ICWTITLE) == BST_CHECKED);
                    if (fCustICWTitle)
                        if (!CheckField(hDlg, IDE_ICWTITLE, FC_NONNULL))
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                    // check if the bitmaps have the correct sizes
                    if (!IsBitmapFileValid(hDlg, IDE_ICWHEADERBMP, szTopBmpFile, NULL, 49, 49, IDS_TOOBIG49x49, IDS_TOOSMALL49x49)  ||
                        !IsBitmapFileValid(hDlg, IDE_ICWWATERBMP, szLeftBmpFile, NULL, 164, 458, IDS_TOOBIG164x458, IDS_TOOSMALL164x458))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        return TRUE;
                    }

                    // persist the checkbox state
                    InsWriteBool(IS_ICW, IK_CUSTICWTITLE, fCustICWTitle, g_szCustIns);

                    // write the custom title
                    GetDlgItemText(hDlg, IDE_ICWTITLE, szICWTitle, countof(szICWTitle));
                    WritePrivateProfileString(IS_ICW, IK_ICWDISPNAME, fCustICWTitle ? szICWTitle : NULL, s_szIsp);

                    // write the custom title to the INS also so that if you import this INS file, all the values
                    // on this page are persisted
                    InsWriteString(IS_ICW, IK_ICWDISPNAME, szICWTitle, g_szCustIns);

                    // delete the old top bitmap file from the signup folder
                    GetPrivateProfileString(IS_ICW, IK_HEADERBMP, TEXT(""), szPrevBmpFile, countof(szPrevBmpFile), s_szIsp);
                    if (ISNONNULL(szPrevBmpFile))
                        DeleteFileInDir(szPrevBmpFile, g_szSignup);

                    // write top bitmap file path and copy the file to the signup folder
                    InsWriteString(IS_ICW, IK_HEADERBMP, PathFindFileName(szTopBmpFile), s_szIsp);
                    InsWriteString(IS_ICW, IK_HEADERBMP, szTopBmpFile, g_szCustIns);
                    if (ISNONNULL(szTopBmpFile))
                        CopyFileToDir(szTopBmpFile, g_szSignup);

                    // delete the old left bitmap file from the signup folder
                    GetPrivateProfileString(IS_ICW, IK_WATERBMP, TEXT(""), szPrevBmpFile, countof(szPrevBmpFile), s_szIsp);
                    if (ISNONNULL(szPrevBmpFile))
                        DeleteFileInDir(szPrevBmpFile, g_szSignup);

                    // write left bitmap file path and copy the file to the signup folder
                    InsWriteString(IS_ICW, IK_WATERBMP, PathFindFileName(szLeftBmpFile), s_szIsp);
                    InsWriteString(IS_ICW, IK_WATERBMP, szLeftBmpFile, g_szCustIns);
                    if (ISNONNULL(szLeftBmpFile))
                        CopyFileToDir(szLeftBmpFile, g_szSignup);

                    // write flags to let ICW know that ICW-based signup process should be used
                    WritePrivateProfileString(IS_ICW, IK_USEICW, TEXT("1"), s_szIsp);
                    WritePrivateProfileString(IS_ICW, IK_ICWHTM, TEXT("icwsign.htm"), s_szIsp);

                    g_iCurPage = PPAGE_ICW;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch (LOWORD(wParam))
                    {
                        case IDC_ICWTITLE:
                            fCustICWTitle = (IsDlgButtonChecked(hDlg, IDC_ICWTITLE) == BST_CHECKED);
                            EnableDlgItem2(hDlg, IDE_ICWTITLE, fCustICWTitle);
                            EnableDlgItem2(hDlg, IDC_ICWTITLE_TXT, fCustICWTitle);
                            break;

                        case IDC_BROWSEICWHEADERBMP:
                            GetDlgItemText(hDlg, IDE_ICWHEADERBMP, szTopBmpFile, countof(szTopBmpFile));
                            if (BrowseForFile(hDlg, szTopBmpFile, countof(szTopBmpFile), GFN_PICTURE | GFN_BMP))
                                SetDlgItemText(hDlg, IDE_ICWHEADERBMP, szTopBmpFile);
                            break;

                        case IDC_BROWSEICWWATERBMP:
                            GetDlgItemText(hDlg, IDE_ICWWATERBMP, szLeftBmpFile, countof(szLeftBmpFile));
                            if (BrowseForFile(hDlg, szLeftBmpFile, countof(szLeftBmpFile), GFN_PICTURE | GFN_BMP))
                                SetDlgItemText(hDlg, IDE_ICWWATERBMP, szLeftBmpFile);
                            break;
                    }
                    break;
            }
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


static BOOL CALLBACK IspPopupDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static PSIGNUPFILE s_pISPFileCurrent = NULL;

    if (uMsg == WM_INITDIALOG)
        s_pISPFileCurrent = (PSIGNUPFILE) lParam;

    return SignupPopupDlgProcHelper(hDlg, uMsg, wParam, lParam, s_pISPFileCurrent, TRUE);
}


static BOOL CALLBACK InsPopupDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static PSIGNUPFILE s_pINSFileCurrent = NULL;

    if (uMsg == WM_INITDIALOG)
        s_pINSFileCurrent = (PSIGNUPFILE) lParam;

    return SignupPopupDlgProcHelper(hDlg, uMsg, wParam, lParam, s_pINSFileCurrent, FALSE);
}


static BOOL CALLBACK SignupPopupDlgProcHelper(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM,
                                              PSIGNUPFILE pSignupFile, BOOL fIsp)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            DisableDBCSChars(hDlg, IDE_DNSA);
            DisableDBCSChars(hDlg, IDE_DNSB);
            DisableDBCSChars(hDlg, IDE_DNSC);
            DisableDBCSChars(hDlg, IDE_DNSD);
            Edit_LimitText(GetDlgItem(hDlg, IDE_DNSA), 3);
            Edit_LimitText(GetDlgItem(hDlg, IDE_DNSB), 3);
            Edit_LimitText(GetDlgItem(hDlg, IDE_DNSC), 3);
            Edit_LimitText(GetDlgItem(hDlg, IDE_DNSD), 3);

            DisableDBCSChars(hDlg, IDE_ALTDNSA);
            DisableDBCSChars(hDlg, IDE_ALTDNSB);
            DisableDBCSChars(hDlg, IDE_ALTDNSC);
            DisableDBCSChars(hDlg, IDE_ALTDNSD);
            Edit_LimitText(GetDlgItem(hDlg, IDE_ALTDNSA), 3);
            Edit_LimitText(GetDlgItem(hDlg, IDE_ALTDNSB), 3);
            Edit_LimitText(GetDlgItem(hDlg, IDE_ALTDNSC), 3);
            Edit_LimitText(GetDlgItem(hDlg, IDE_ALTDNSD), 3);

            // for serverless, only Applyins is applicable
            if (fIsp  ||  g_fServerless)
            {
                if (fIsp)
                {
                    ShowWindow(GetDlgItem(hDlg, IDC_DONTAPPLYINS), SW_HIDE);
                    ShowWindow(GetDlgItem(hDlg, IDC_DONTMODIFY), SW_HIDE);
                    ShowWindow(GetDlgItem(hDlg, IDC_APPLYINS), SW_HIDE);
                }

                ShowWindow(GetDlgItem(hDlg, IDC_BRANDNAME), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDE_BRANDINGCABNAME), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_BRANDURL), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDE_BRANDINGCABURL), SW_HIDE);
            }

            SetSignupFileAdvancedEntry(hDlg, pSignupFile, fIsp);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_CHECKSTATICDNS:
                {
                    BOOL fStaticDNS;

                    fStaticDNS = (IsDlgButtonChecked(hDlg, IDC_CHECKSTATICDNS) == BST_CHECKED);

                    EnableDlgItem2(hDlg, IDC_PRIMARY, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_DNSA, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_DNSB, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_DNSC, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_DNSD, fStaticDNS);

                    EnableDlgItem2(hDlg, IDC_ALT, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_ALTDNSA, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_ALTDNSB, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_ALTDNSC, fStaticDNS);
                    EnableDlgItem2(hDlg, IDE_ALTDNSD, fStaticDNS);

                    return TRUE;
                }

                case IDC_DONTAPPLYINS:
                case IDC_DONTMODIFY:
                case IDC_APPLYINS:
                    if (!g_fServerless)
                    {
                        BOOL fApplyIns;

                        fApplyIns = (IsDlgButtonChecked(hDlg, IDC_APPLYINS) == BST_CHECKED);

                        EnableDlgItem2(hDlg, IDC_BRANDNAME, fApplyIns);
                        EnableDlgItem2(hDlg, IDE_BRANDINGCABNAME, fApplyIns);

                        EnableDlgItem2(hDlg, IDC_BRANDURL, fApplyIns);
                        EnableDlgItem2(hDlg, IDE_BRANDINGCABURL, fApplyIns);
                    }
                    return TRUE;

                case IDOK:
                    if (!SaveSignupFileAdvancedEntry(hDlg, pSignupFile, fIsp))
                        break;
                    EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
            }
            break;
    }

    return FALSE;
}


static VOID UpdateSignupFilesStatus(HWND hDlg, LPCTSTR pcszSignupPath)
{
    static HBITMAP s_hCheckBmp = NULL;
    static HBITMAP s_hXBmp = NULL;

    HWND hwndBitmap;
    TCHAR szBuf[MAX_PATH];
    DWORD nFiles;

    // NOTE: s_hCheckBmp and s_hXBmp don't get freed up until the wizard is closed.

    if (s_hCheckBmp == NULL)
        s_hCheckBmp = (HBITMAP) LoadImage(g_rvInfo.hInst, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);

    if (s_hXBmp == NULL)
        s_hXBmp = (HBITMAP) LoadImage(g_rvInfo.hInst, MAKEINTRESOURCE(IDB_X), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);

    // check if icwsign.htm exists in the signup folder
    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_SFSTATUS1)))
    {
        hwndBitmap = GetDlgItem(hDlg, IDC_SFBMP1);

        if (PathFileExistsInDir(TEXT("icwsign.htm"), pcszSignupPath))
        {
            LoadString(g_rvInfo.hInst, IDS_SF_ICWHTM_FOUND, szBuf, countof(szBuf));

            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hCheckBmp);
        }
        else
        {
            LoadString(g_rvInfo.hInst, IDS_SF_ICWHTM_NOTFOUND, szBuf, countof(szBuf));

            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hXBmp);
        }

        SetDlgItemText(hDlg, IDC_SFSTATUS1, szBuf);
    }

    // check if signup.htm exists in the signup folder
    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_SFSTATUS2)))
    {
        hwndBitmap = GetDlgItem(hDlg, IDC_SFBMP2);

        if (PathFileExistsInDir(TEXT("signup.htm"), pcszSignupPath))
        {
            LoadString(g_rvInfo.hInst, IDS_SF_SIGNUPHTM_FOUND, szBuf, countof(szBuf));

            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hCheckBmp);
        }
        else
        {
            LoadString(g_rvInfo.hInst, IDS_SF_SIGNUPHTM_NOTFOUND, szBuf, countof(szBuf));

            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hXBmp);
        }

        SetDlgItemText(hDlg, IDC_SFSTATUS2, szBuf);
    }

    // check how many .ISP files are there in the signup folder
    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_SFSTATUS3)))
    {
        TCHAR szBuf2[64];

        hwndBitmap = GetDlgItem(hDlg, IDC_SFBMP3);

        nFiles = GetNumberOfFiles(TEXT("*.isp"), pcszSignupPath);

        if (nFiles > 0)
        {
            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hCheckBmp);

            EnableDlgItem(hDlg, IDC_CHECK3);
        }
        else
        {
            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hXBmp);

            // if no files found, user shouldn't be able to unselect the Verify/modify checkbox;
            // so select it and disable it
            CheckDlgButton(hDlg, IDC_CHECK3, BST_CHECKED);
            DisableDlgItem(hDlg, IDC_CHECK3);
        }

        LoadString(g_rvInfo.hInst, IDS_SF_ISPFILES, szBuf2, countof(szBuf2));
        wnsprintf(szBuf, countof(szBuf), szBuf2, nFiles);
        SetDlgItemText(hDlg, IDC_SFSTATUS3, szBuf);
    }

    // check how many .INS files are there in the signup folder
    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_SFSTATUS4)))
    {
        TCHAR szBuf2[64];

        hwndBitmap = GetDlgItem(hDlg, IDC_SFBMP4);

        nFiles = GetNumberOfINSFiles(pcszSignupPath);
        if (nFiles > 0)
        {
            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hCheckBmp);

            EnableDlgItem(hDlg, IDC_CHECK4);
        }
        else
        {
            SendMessage(hwndBitmap, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) s_hXBmp);

            if (g_fServerless)
            {
                // if no files found, user shouldn't be able to unselect the Verify/modify checkbox;
                // so select it and disable it
                CheckDlgButton(hDlg, IDC_CHECK4, BST_CHECKED);
                DisableDlgItem(hDlg, IDC_CHECK4);
            }
            else
            {
                // for server-based, creating INS files is optional;
                // so don't force the Verify/modify checkbox to be selected
                CheckDlgButton(hDlg, IDC_CHECK4, BST_UNCHECKED);        // unchecked by default
                EnableDlgItem(hDlg, IDC_CHECK4);

                // have to change this here because in PSN_SETACTIVE, the default is to turn it on;
                // should probably move that logic in this function.
                if (!InsGetBool(IS_ICW, IK_MODIFY_INS, 0, g_szCustIns))
                    WritePrivateProfileString(IS_ICW, IK_MODIFY_INS, TEXT("0"), g_szCustIns);
            }
        }

        LoadString(g_rvInfo.hInst, IDS_SF_INSFILES, szBuf2, countof(szBuf2));
        wnsprintf(szBuf, countof(szBuf), szBuf2, nFiles);
        SetDlgItemText(hDlg, IDC_SFSTATUS4, szBuf);
    }
}


static DWORD InitSignupFileArray(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems,
                                 HWND hwndCombo, BOOL fIsp)
{
    DWORD nSignupFiles = 0;
    TCHAR szFile[MAX_PATH];
    HANDLE hFind;
    WIN32_FIND_DATA fd;

    ComboBox_ResetContent(hwndCombo);

    PathCombine(szFile, g_szSignup, fIsp ? TEXT("*.isp") : TEXT("*.ins"));

    if ((hFind = FindFirstFile(szFile, &fd)) != INVALID_HANDLE_VALUE)
    {
        BOOL fSignupIspFound = FALSE;

        do
        {
            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                continue;

            // don't enumerate .ins files that have Cancel=Yes in the [Entry] section
            if (!fIsp)
            {
                PathCombine(szFile, g_szSignup, fd.cFileName);
                if (InsGetYesNo(TEXT("Entry"), TEXT("Cancel"), 0, szFile))
                    continue;
            }

            PathCombine(pSignupArray[nSignupFiles].szEntryPath, g_szSignup, fd.cFileName);
            ReadSignupFile(&pSignupArray[nSignupFiles], pSignupArray[nSignupFiles].szEntryPath, fIsp);

            INT iIndex = ComboBox_AddString(hwndCombo, pSignupArray[nSignupFiles].szEntryName);
            ComboBox_SetItemData(hwndCombo, iIndex, (LPARAM) &pSignupArray[nSignupFiles]);

            nSignupFiles++;
        } while (nSignupFiles < nSignupArrayElems  &&  FindNextFile(hFind, &fd));

        FindClose(hFind);
    }

    return nSignupFiles;
}


static VOID SaveSignupFileArray(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems, BOOL fIsp)
{
    for ( ;  nSignupArrayElems-- > 0;  pSignupArray++)
        if (*pSignupArray->szEntryPath)
            WriteSignupFile(pSignupArray, pSignupArray->szEntryPath, fIsp);
}


static VOID ReadSignupFile(PSIGNUPFILE pSignupFile, LPCTSTR pcszSignupFile, BOOL fIsp)
{
    GetPrivateProfileString(TEXT("Entry"), TEXT("Entry_Name"), TEXT(""),
                            pSignupFile->szEntryName, countof(pSignupFile->szEntryName), pcszSignupFile);

    GetPrivateProfileString(TEXT("Phone"), TEXT("Area_Code"), TEXT(""),
                            pSignupFile->szAreaCode, countof(pSignupFile->szAreaCode), pcszSignupFile);
    GetPrivateProfileString(TEXT("Phone"), TEXT("Phone_Number"), TEXT(""),
                            pSignupFile->szPhoneNumber, countof(pSignupFile->szPhoneNumber), pcszSignupFile);
    GetPrivateProfileString(TEXT("Phone"), TEXT("Country_Code"), TEXT(""),
                            pSignupFile->szCountryCode, countof(pSignupFile->szCountryCode), pcszSignupFile);
    GetPrivateProfileString(TEXT("Phone"), TEXT("Country_ID"), TEXT(""),
                            pSignupFile->szCountryId, countof(pSignupFile->szCountryId), pcszSignupFile);

    GetPrivateProfileString(TEXT("User"), TEXT("Name"), TEXT(""),
                            pSignupFile->szName, countof(pSignupFile->szName), pcszSignupFile);
    GetPrivateProfileString(TEXT("User"), TEXT("Password"), TEXT(""),
                            pSignupFile->szPassword, countof(pSignupFile->szPassword), pcszSignupFile);

    // support number is applicable only for an ISP file and if ICW mode is chosen
    if (fIsp  &&  g_fServerICW)
        GetPrivateProfileString(TEXT("Support"), TEXT("SupportPhoneNumber"), TEXT(""),
                            pSignupFile->szSupportNum, countof(pSignupFile->szSupportNum), pcszSignupFile);

    pSignupFile->Advanced.fStaticDNS = InsGetYesNo(TEXT("TCP/IP"), TEXT("Specify_Server_Address"), 0, pcszSignupFile);
    GetPrivateProfileString(TEXT("TCP/IP"), TEXT("DNS_Address"), TEXT(""),
                            pSignupFile->Advanced.szDNSAddress, countof(pSignupFile->Advanced.szDNSAddress), pcszSignupFile);
    GetPrivateProfileString(TEXT("TCP/IP"), TEXT("DNS_Alt_Address"), TEXT(""),
                            pSignupFile->Advanced.szAltDNSAddress, countof(pSignupFile->Advanced.szAltDNSAddress), pcszSignupFile);

    // signup url is not applicable for .ins files
    if (fIsp)
    {
        GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""),
                            pSignupFile->szSignupURL, countof(pSignupFile->szSignupURL), pcszSignupFile);

        if (*pSignupFile->szSignupURL == TEXT('\0'))
        {
            // for backward compatibility, check if SignupURL is defined in signup.isp or install.ins
            if (GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""), pSignupFile->szSignupURL, countof(pSignupFile->szSignupURL), s_szIsp) == 0)
                GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""), pSignupFile->szSignupURL, countof(pSignupFile->szSignupURL), g_szCustIns);
        }
    }

    pSignupFile->Advanced.fRequiresLogon = InsGetYesNo(TEXT("User"), TEXT("Requires_Logon"), 0, pcszSignupFile);
    pSignupFile->Advanced.fNegTCPIP = InsGetYesNo(TEXT("Server"), TEXT("Negotiate_TCP/IP"), 1, pcszSignupFile);
    pSignupFile->Advanced.fDisableLCP = InsGetYesNo(TEXT("Server"), TEXT("Disable_LCP"), 0, pcszSignupFile);
    pSignupFile->Advanced.fDialAsIs = InsGetYesNo(TEXT("Phone"), TEXT("Dial_As_Is"), 0, pcszSignupFile);

    pSignupFile->Advanced.fPWEncrypt = InsGetYesNo(TEXT("Server"), TEXT("PW_Encrypt"), 0, pcszSignupFile);
    pSignupFile->Advanced.fSWCompress = InsGetYesNo(TEXT("Server"), TEXT("SW_Compress"), 0, pcszSignupFile);
    pSignupFile->Advanced.fIPHdrComp = InsGetYesNo(TEXT("TCP/IP"), TEXT("IP_Header_Compress"), 1, pcszSignupFile);
    pSignupFile->Advanced.fDefGate = InsGetYesNo(TEXT("TCP/IP"), TEXT("Gateway_On_Remote"), 1, pcszSignupFile);

    if (!fIsp)
    {
        pSignupFile->Advanced.fDontApplyIns =
        pSignupFile->Advanced.fDontModify =
        pSignupFile->Advanced.fApplyIns = FALSE;

        // make sure that only one of the above BOOLs is set to TRUE
        pSignupFile->Advanced.fApplyIns = InsGetBool(IS_APPLYINS, IK_APPLYINS, 0, pcszSignupFile);
        if (!pSignupFile->Advanced.fApplyIns)
        {
            pSignupFile->Advanced.fDontModify = InsGetBool(IS_APPLYINS, IK_DONTMODIFY, 0, pcszSignupFile);
            if (!pSignupFile->Advanced.fDontModify)
            {
                // default to TRUE for DontApplyIns
                pSignupFile->Advanced.fDontApplyIns = InsGetBool(IS_APPLYINS, IK_DONTAPPLYINS, 1, pcszSignupFile);
            }
        }

        if (!g_fServerless)
        {
            GetPrivateProfileString(IS_APPLYINS, IK_BRAND_NAME, TEXT(""),
                                pSignupFile->Advanced.szBrandingCabName, countof(pSignupFile->Advanced.szBrandingCabName), pcszSignupFile);
            GetPrivateProfileString(IS_APPLYINS, IK_BRAND_URL, TEXT(""),
                                pSignupFile->Advanced.szBrandingCabURL, countof(pSignupFile->Advanced.szBrandingCabURL), pcszSignupFile);
        }
    }
}


static VOID WriteSignupFile(PSIGNUPFILE pSignupFile, LPCTSTR pcszSignupFile, BOOL fIsp)
{
    // IMPORTANT: (pritobla): On Win9x, if we don't flush the content before DeleteFile and WritePrivateProfile
    // calls, the file would get deleted but for some weird reason, the WritePrivateProfile calls would fail to
    // create a new one.
    WritePrivateProfileString(NULL, NULL, NULL, pcszSignupFile);

    // for .INS, delete the file if DontApplyIns or ApplyIns is TRUE;
    // we want to primarily do this to clean-up the ApplyIns customizations
    if (!fIsp  &&  !pSignupFile->Advanced.fDontModify)
    {
        SetFileAttributes(pcszSignupFile, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(pcszSignupFile);
    }

    InsWriteString(TEXT("Entry"), TEXT("Entry_Name"), pSignupFile->szEntryName, pcszSignupFile);

    InsWriteString(TEXT("Phone"), TEXT("Area_Code"), pSignupFile->szAreaCode, pcszSignupFile);
    InsWriteString(TEXT("Phone"), TEXT("Phone_Number"), pSignupFile->szPhoneNumber, pcszSignupFile);
    InsWriteString(TEXT("Phone"), TEXT("Country_Code"), pSignupFile->szCountryCode, pcszSignupFile);
    InsWriteString(TEXT("Phone"), TEXT("Country_ID"), pSignupFile->szCountryId, pcszSignupFile);

    InsWriteString(TEXT("User"), TEXT("Name"), pSignupFile->szName, pcszSignupFile);
    InsWriteString(TEXT("User"), TEXT("Password"), pSignupFile->szPassword, pcszSignupFile);

    // support number is applicable only for an ISP file and if ICW mode is chosen
    if (fIsp  &&  g_fServerICW)
        InsWriteString(TEXT("Support"), TEXT("SupportPhoneNumber"), pSignupFile->szSupportNum, pcszSignupFile);

    if (fIsp)
        InsWriteString(IS_URL, TEXT("Signup"), pSignupFile->szSignupURL, pcszSignupFile);

    InsWriteYesNo(TEXT("TCP/IP"), TEXT("Specify_Server_Address"), pSignupFile->Advanced.fStaticDNS, pcszSignupFile);
    InsWriteString(TEXT("TCP/IP"), TEXT("DNS_Address"), pSignupFile->Advanced.szDNSAddress, pcszSignupFile);
    InsWriteString(TEXT("TCP/IP"), TEXT("DNS_Alt_Address"), pSignupFile->Advanced.szAltDNSAddress, pcszSignupFile);

    InsWriteYesNo(TEXT("User"), TEXT("Requires_Logon"), pSignupFile->Advanced.fRequiresLogon, pcszSignupFile);
    InsWriteYesNo(TEXT("Server"), TEXT("Negotiate_TCP/IP"), pSignupFile->Advanced.fNegTCPIP, pcszSignupFile);
    InsWriteYesNo(TEXT("Server"), TEXT("Disable_LCP"), pSignupFile->Advanced.fDisableLCP, pcszSignupFile);
    InsWriteYesNo(TEXT("Phone"), TEXT("Dial_As_Is"), pSignupFile->Advanced.fDialAsIs, pcszSignupFile);

    InsWriteYesNo(TEXT("Server"), TEXT("PW_Encrypt"), pSignupFile->Advanced.fPWEncrypt, pcszSignupFile);
    InsWriteYesNo(TEXT("Server"), TEXT("SW_Compress"), pSignupFile->Advanced.fSWCompress, pcszSignupFile);
    InsWriteYesNo(TEXT("TCP/IP"), TEXT("IP_Header_Compress"), pSignupFile->Advanced.fIPHdrComp, pcszSignupFile);
    InsWriteYesNo(TEXT("TCP/IP"), TEXT("Gateway_On_Remote"), pSignupFile->Advanced.fDefGate, pcszSignupFile);

    if (!fIsp)
    {
        InsWriteBool(IS_APPLYINS, IK_APPLYINS, pSignupFile->Advanced.fApplyIns, pcszSignupFile);
        InsWriteBool(IS_APPLYINS, IK_DONTMODIFY, pSignupFile->Advanced.fDontModify, pcszSignupFile);
        InsWriteBool(IS_APPLYINS, IK_DONTAPPLYINS, pSignupFile->Advanced.fDontApplyIns, pcszSignupFile);

        if (!g_fServerless)
        {
            InsWriteString(IS_APPLYINS, IK_BRAND_NAME, pSignupFile->Advanced.szBrandingCabName, pcszSignupFile);
            InsWriteString(IS_APPLYINS, IK_BRAND_URL, pSignupFile->Advanced.szBrandingCabURL, pcszSignupFile);
        }
    }

    // NOTE: we need to write the default server type
    WritePrivateProfileString(TEXT("Server"), TEXT("Type"), TEXT("PPP"), pcszSignupFile);

    // flush the buffer
    WritePrivateProfileString(NULL, NULL, NULL, pcszSignupFile);
}


static INT NewSignupFileEntry(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems, HWND hwndCombo,
                              BOOL fIsp)
{
    DWORD nIndex;
    PSIGNUPFILE pSignupFileNew;
    TCHAR szNameBuf[64];
    INT iSelIndex;

    for (nIndex = 0, pSignupFileNew = pSignupArray;  nIndex < nSignupArrayElems;  nIndex++, pSignupFileNew++)
        if (*pSignupFileNew->szEntryName == TEXT('\0'))
            break;

    ASSERT(nIndex < nSignupArrayElems);

    ZeroMemory(pSignupFileNew, sizeof(*pSignupFileNew));

    // give a default name for the connection
    LoadString(g_rvInfo.hInst, IDS_CONNECTNAME, szNameBuf, countof(szNameBuf));

    // start with an index of 1 and find a name that's not in the combo box list
    for (nIndex = 1;  nIndex <= nSignupArrayElems;  nIndex++)
    {
        wnsprintf(pSignupFileNew->szEntryName, countof(pSignupFileNew->szEntryName), szNameBuf, nIndex);
        if (ComboBox_FindStringExact(hwndCombo, -1, (LPARAM) pSignupFileNew->szEntryName) == CB_ERR)
            break;
    }

    ASSERT(nIndex <= nSignupArrayElems);

    // give a default name for the file name
    LoadString(g_rvInfo.hInst, fIsp ? IDS_CONNECTFILE_ISP : IDS_CONNECTFILE_INS, szNameBuf, countof(szNameBuf));
    wnsprintf(pSignupFileNew->szEntryPath, countof(pSignupFileNew->szEntryPath), szNameBuf, nIndex);

    // read in SignupURL if defined in signup.isp or install.ins as the default for Signup URL
    if (fIsp)
        if (GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""), pSignupFileNew->szSignupURL, countof(pSignupFileNew->szSignupURL), s_szIsp) == 0)
            GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""), pSignupFileNew->szSignupURL, countof(pSignupFileNew->szSignupURL), g_szCustIns);

    // the following settings are on by default
    pSignupFileNew->Advanced.fNegTCPIP = TRUE;
    pSignupFileNew->Advanced.fIPHdrComp = TRUE;
    pSignupFileNew->Advanced.fDefGate = TRUE;

    if (!fIsp)
        pSignupFileNew->Advanced.fDontApplyIns = TRUE;

    iSelIndex = ComboBox_AddString(hwndCombo, pSignupFileNew->szEntryName);
    ComboBox_SetItemData(hwndCombo, iSelIndex, (LPARAM) pSignupFileNew);

    return iSelIndex;
}


static VOID SetSignupFileEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp)
{
    SetDlgItemText(hDlg, IDC_CONNECTION, pSignupFile->szEntryName);

    SetDlgItemText(hDlg, IDE_CONNECTION, PathFindFileName(pSignupFile->szEntryPath));

    SetDlgItemText(hDlg, IDE_AREACODE, pSignupFile->szAreaCode);
    SetDlgItemText(hDlg, IDE_PHONENUMBER, pSignupFile->szPhoneNumber);
    SetDlgItemText(hDlg, IDE_COUNTRYCODE, pSignupFile->szCountryCode);
    SetDlgItemText(hDlg, IDE_COUNTRYID, pSignupFile->szCountryId);

    SetDlgItemText(hDlg, IDE_USERNAME, pSignupFile->szName);
    SetDlgItemText(hDlg, IDE_PASSWORD, pSignupFile->szPassword);

    // support number is applicable only for an ISP file and if ICW mode is chosen
    if (fIsp  &&  g_fServerICW)
        SetDlgItemText(hDlg, IDE_SUPPORTNUM, pSignupFile->szSupportNum);

    if (fIsp)
        SetDlgItemText(hDlg, IDE_SIGNUPURL, pSignupFile->szSignupURL);
}


static BOOL SaveSignupFileEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp)
{
    // NOTE: passing PIVP_FILENAME_ONLY for IDE_CONNECTION makes sure that only
    //       filenames are specified (no path components should be there)
    if (!CheckField(hDlg, IDC_CONNECTION,  FC_NONNULL)  ||
        !CheckField(hDlg, IDE_CONNECTION,  FC_NONNULL | FC_FILE, PIVP_FILENAME_ONLY)  ||
        !CheckField(hDlg, IDE_PHONENUMBER, FC_NONNULL)  ||
        !CheckField(hDlg, IDE_COUNTRYCODE, FC_NONNULL)  ||
        !CheckField(hDlg, IDE_COUNTRYID,   FC_NONNULL))
        return FALSE;

    if (fIsp)
        if (!CheckField(hDlg, IDE_SIGNUPURL, FC_NONNULL | FC_URL))
            return FALSE;

    // check if file extension is .isp or .ins if the field is enabled
    if (IsWindowEnabled(GetDlgItem(hDlg, IDE_CONNECTION)))
    {
        TCHAR szFile[MAX_PATH];
        LPTSTR pszExt;

        GetDlgItemText(hDlg, IDE_CONNECTION, szFile, countof(szFile));
        pszExt = PathFindExtension(szFile);
        if (StrCmpI(pszExt, fIsp ? TEXT(".isp") : TEXT(".ins")))
        {
            ErrorMessageBox(hDlg, fIsp ? IDS_NON_ISP_EXTN : IDS_NON_INS_EXTN);

            Edit_SetSel(GetDlgItem(hDlg, IDE_CONNECTION), pszExt - szFile, -1);
            SetFocus(GetDlgItem(hDlg, IDE_CONNECTION));

            return FALSE;
        }

        // if the current file name is different from the previous one, delete the previous file
        if (StrCmpI(szFile, PathFindFileName(pSignupFile->szEntryPath)))
            DeleteFile(pSignupFile->szEntryPath);

        PathCombine(pSignupFile->szEntryPath, g_szSignup, szFile);
    }

    GetDlgItemText(hDlg, IDC_CONNECTION, pSignupFile->szEntryName, countof(pSignupFile->szEntryName));

    GetDlgItemText(hDlg, IDE_AREACODE, pSignupFile->szAreaCode, countof(pSignupFile->szAreaCode));
    GetDlgItemText(hDlg, IDE_PHONENUMBER, pSignupFile->szPhoneNumber, countof(pSignupFile->szPhoneNumber));
    GetDlgItemText(hDlg, IDE_COUNTRYCODE, pSignupFile->szCountryCode, countof(pSignupFile->szCountryCode));
    GetDlgItemText(hDlg, IDE_COUNTRYID, pSignupFile->szCountryId, countof(pSignupFile->szCountryId));

    GetDlgItemText(hDlg, IDE_USERNAME, pSignupFile->szName, countof(pSignupFile->szName));
    GetDlgItemText(hDlg, IDE_PASSWORD, pSignupFile->szPassword, countof(pSignupFile->szPassword));

    // support number is applicable only for an ISP file and if ICW mode is chosen
    if (fIsp  && g_fServerICW)
        GetDlgItemText(hDlg, IDE_SUPPORTNUM, pSignupFile->szSupportNum, countof(pSignupFile->szSupportNum));

    if (fIsp)
        GetDlgItemText(hDlg, IDE_SIGNUPURL, pSignupFile->szSignupURL, countof(pSignupFile->szSignupURL));

    return TRUE;
}


static VOID SetSignupFileAdvancedEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp)
{
    CheckDlgButton(hDlg, IDC_CHECKSTATICDNS, pSignupFile->Advanced.fStaticDNS ? BST_CHECKED : BST_UNCHECKED);
    SetDlgIPAddress(hDlg, pSignupFile->Advanced.szDNSAddress, IDE_DNSA, IDE_DNSB, IDE_DNSC, IDE_DNSD);
    SetDlgIPAddress(hDlg, pSignupFile->Advanced.szAltDNSAddress, IDE_ALTDNSA, IDE_ALTDNSB, IDE_ALTDNSC, IDE_ALTDNSD);

    CheckDlgButton(hDlg, IDC_REQLOGON, pSignupFile->Advanced.fRequiresLogon ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_NEGOTIATETCP, pSignupFile->Advanced.fNegTCPIP ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_DISABLELCP, pSignupFile->Advanced.fDisableLCP ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_DIALASIS, pSignupFile->Advanced.fDialAsIs ? BST_CHECKED : BST_UNCHECKED);

    CheckDlgButton(hDlg, IDC_CHECKPWENCRYPT, pSignupFile->Advanced.fPWEncrypt ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_CHECKSWCOMP, pSignupFile->Advanced.fSWCompress ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_CHECKIPHDRCOMP, pSignupFile->Advanced.fIPHdrComp ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hDlg, IDC_CHECKDEFGW, pSignupFile->Advanced.fDefGate ? BST_CHECKED : BST_UNCHECKED);

    if (!fIsp)
    {
        INT id;

        if (pSignupFile->Advanced.fApplyIns)
            id = IDC_APPLYINS;
        else if (pSignupFile->Advanced.fDontModify)
            id = IDC_DONTMODIFY;
        else
            id = IDC_DONTAPPLYINS;

        CheckRadioButton(hDlg, IDC_DONTAPPLYINS, IDC_APPLYINS, id);

        if (!g_fServerless)
        {
            if (ISNULL(pSignupFile->Advanced.szBrandingCabName))
            {
                // pre-populate the name for the branding cab with <name of the ins file>.cab
                StrCpy(pSignupFile->Advanced.szBrandingCabName, PathFindFileName(pSignupFile->szEntryPath));
                PathRenameExtension(pSignupFile->Advanced.szBrandingCabName, TEXT(".cab"));
            }

            if (ISNULL(pSignupFile->Advanced.szBrandingCabURL))
            {
                // pre-populate the URL for the branding cab with the signup URL from signup.isp or install.ins
                if (GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""),
                            pSignupFile->Advanced.szBrandingCabURL, countof(pSignupFile->Advanced.szBrandingCabURL), s_szIsp) == 0)
                    GetPrivateProfileString(IS_URL, TEXT("Signup"), TEXT(""),
                            pSignupFile->Advanced.szBrandingCabURL, countof(pSignupFile->Advanced.szBrandingCabURL), g_szCustIns);
            }

            SetDlgItemText(hDlg, IDE_BRANDINGCABNAME, pSignupFile->Advanced.szBrandingCabName);
            SetDlgItemText(hDlg, IDE_BRANDINGCABURL, pSignupFile->Advanced.szBrandingCabURL);
        }
    }

    EnableDlgItem2(hDlg, IDC_PRIMARY, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_DNSA, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_DNSB, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_DNSC, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_DNSD, pSignupFile->Advanced.fStaticDNS);

    EnableDlgItem2(hDlg, IDC_ALT, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_ALTDNSA, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_ALTDNSB, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_ALTDNSC, pSignupFile->Advanced.fStaticDNS);
    EnableDlgItem2(hDlg, IDE_ALTDNSD, pSignupFile->Advanced.fStaticDNS);

    if (!fIsp  &&  !g_fServerless)
    {
        EnableDlgItem2(hDlg, IDC_BRANDNAME, pSignupFile->Advanced.fApplyIns);
        EnableDlgItem2(hDlg, IDE_BRANDINGCABNAME, pSignupFile->Advanced.fApplyIns);

        EnableDlgItem2(hDlg, IDC_BRANDURL, pSignupFile->Advanced.fApplyIns);
        EnableDlgItem2(hDlg, IDE_BRANDINGCABURL, pSignupFile->Advanced.fApplyIns);
    }
}


static BOOL SaveSignupFileAdvancedEntry(HWND hDlg, PSIGNUPFILE pSignupFile, BOOL fIsp)
{
    if (IsDlgButtonChecked(hDlg, IDC_CHECKSTATICDNS) == BST_CHECKED)
        if (!VerifyDlgIPAddress(hDlg, IDE_DNSA, IDE_DNSB, IDE_DNSC, IDE_DNSD)  ||
            !VerifyDlgIPAddress(hDlg, IDE_ALTDNSA, IDE_ALTDNSB, IDE_ALTDNSC, IDE_ALTDNSD))
            return FALSE;

    // NOTE: passing PIVP_FILENAME_ONLY for IDE_BRANDINGCABNAME makes sure that only
    //       filenames are specified (no path components should be there)
    if (!fIsp  &&  !g_fServerless)
        if (IsDlgButtonChecked(hDlg, IDC_APPLYINS) == BST_CHECKED)
            if (!CheckField(hDlg, IDE_BRANDINGCABNAME, FC_NONNULL | FC_FILE, PIVP_FILENAME_ONLY)  ||
                !CheckField(hDlg, IDE_BRANDINGCABURL,  FC_NONNULL | FC_URL))
                return FALSE;

    pSignupFile->Advanced.fStaticDNS = (IsDlgButtonChecked(hDlg, IDC_CHECKSTATICDNS) == BST_CHECKED);
    GetDlgIPAddress(hDlg, pSignupFile->Advanced.szDNSAddress, IDE_DNSA, IDE_DNSB, IDE_DNSC, IDE_DNSD);
    GetDlgIPAddress(hDlg, pSignupFile->Advanced.szAltDNSAddress, IDE_ALTDNSA, IDE_ALTDNSB, IDE_ALTDNSC, IDE_ALTDNSD);

    pSignupFile->Advanced.fRequiresLogon = (IsDlgButtonChecked(hDlg, IDC_REQLOGON) == BST_CHECKED);
    pSignupFile->Advanced.fNegTCPIP = (IsDlgButtonChecked(hDlg, IDC_NEGOTIATETCP) == BST_CHECKED);
    pSignupFile->Advanced.fDisableLCP = (IsDlgButtonChecked(hDlg, IDC_DISABLELCP) == BST_CHECKED);
    pSignupFile->Advanced.fDialAsIs = (IsDlgButtonChecked(hDlg, IDC_DIALASIS) == BST_CHECKED);

    pSignupFile->Advanced.fPWEncrypt = (IsDlgButtonChecked(hDlg, IDC_CHECKPWENCRYPT) == BST_CHECKED);
    pSignupFile->Advanced.fSWCompress = (IsDlgButtonChecked(hDlg, IDC_CHECKSWCOMP) == BST_CHECKED);
    pSignupFile->Advanced.fIPHdrComp = (IsDlgButtonChecked(hDlg, IDC_CHECKIPHDRCOMP) == BST_CHECKED);
    pSignupFile->Advanced.fDefGate = (IsDlgButtonChecked(hDlg, IDC_CHECKDEFGW) == BST_CHECKED);

    if (!fIsp)
    {
        pSignupFile->Advanced.fApplyIns     = (IsDlgButtonChecked(hDlg, IDC_APPLYINS)     == BST_CHECKED);
        pSignupFile->Advanced.fDontModify   = (IsDlgButtonChecked(hDlg, IDC_DONTMODIFY)   == BST_CHECKED);
        pSignupFile->Advanced.fDontApplyIns = (IsDlgButtonChecked(hDlg, IDC_DONTAPPLYINS) == BST_CHECKED);

        if (!g_fServerless)
        {
            TCHAR szCabName[MAX_PATH];

            GetDlgItemText(hDlg, IDE_BRANDINGCABNAME, szCabName, countof(szCabName));

            // if DontApplyIns is TRUE  OR
            // if ApplyIns is TRUE and the current cabname is different from the previous one,
            // delete the previous branding cab
            if ( pSignupFile->Advanced.fDontApplyIns  ||
                (pSignupFile->Advanced.fApplyIns && StrCmpI(szCabName, pSignupFile->Advanced.szBrandingCabName)))
                DeleteFileInDir(pSignupFile->Advanced.szBrandingCabName, g_szSignup);

            StrCpy(pSignupFile->Advanced.szBrandingCabName, szCabName);
            GetDlgItemText(hDlg, IDE_BRANDINGCABURL, pSignupFile->Advanced.szBrandingCabURL,
                                countof(pSignupFile->Advanced.szBrandingCabURL));
        }
    }

    return TRUE;
}


static VOID SetDlgIPAddress(HWND hDlg, LPCTSTR pcszIPAddress, INT iCtlA, INT iCtlB, INT iCtlC, INT iCtlD)
{
    INT aIDs[4];
    TCHAR szWrkIPAddress[32];
    LPTSTR pszWrkIPAddress;

    aIDs[0] = iCtlA;
    aIDs[1] = iCtlB;
    aIDs[2] = iCtlC;
    aIDs[3] = iCtlD;

    if (pcszIPAddress != NULL)
    {
        StrCpy(szWrkIPAddress, pcszIPAddress);
        pszWrkIPAddress = szWrkIPAddress;
    }
    else
        pszWrkIPAddress = NULL;

    for (INT i = 0;  i < countof(aIDs);  i++)
    {
        LPTSTR pszIPAdr = TEXT("0");                    // display "0" by default

        if (pszWrkIPAddress != NULL)
        {
            LPTSTR pszDot;
            INT iLen;

            if ((pszDot = StrChr(pszWrkIPAddress, TEXT('.'))) != NULL)
                *pszDot++ = TEXT('\0');

            iLen = lstrlen(pszWrkIPAddress);
            if (iLen > 0)                               // if iLen == 0, display "0"
            {
                if (iLen > 3)                           // max 3 characters are allowed
                    pszWrkIPAddress[3] = TEXT('\0');
                pszIPAdr = pszWrkIPAddress;
            }

            pszWrkIPAddress = pszDot;
        }

        SetDlgItemText(hDlg, aIDs[i], pszIPAdr);
    }
}


static VOID GetDlgIPAddress(HWND hDlg, LPTSTR pszIPAddress, INT iCtlA, INT iCtlB, INT iCtlC, INT iCtlD)
{
    INT aIDs[4];

    if (pszIPAddress == NULL)
        return;

    aIDs[0] = iCtlA;
    aIDs[1] = iCtlB;
    aIDs[2] = iCtlC;
    aIDs[3] = iCtlD;

    for (INT i = 0;  i < countof(aIDs);  i++)
    {
        // max 3 characters are allowed
        GetDlgItemText(hDlg, aIDs[i], pszIPAddress, 4);
        if (*pszIPAddress == TEXT('\0'))
            StrCpy(pszIPAddress, TEXT("0"));            // copy "0" as default

        pszIPAddress += lstrlen(pszIPAddress);
        *pszIPAddress++ = TEXT('.');                    // place a dot between two addresses
    }

    *--pszIPAddress = TEXT('\0');                       // replace the final dot with a nul character
}


static BOOL VerifyDlgIPAddress(HWND hDlg, INT iCtlA, INT iCtlB, INT iCtlC, INT iCtlD)
{
    INT aIDs[4];

    aIDs[0] = iCtlA;
    aIDs[1] = iCtlB;
    aIDs[2] = iCtlC;
    aIDs[3] = iCtlD;

    for (INT i = 0;  i < countof(aIDs);  i++)
    {
        TCHAR szIPAddress[4];                           // max 3 characters are allowed

        if (!CheckField(hDlg, aIDs[i], FC_NUMBER))
            return FALSE;

        // verify that the value is in the range 0-255
        GetDlgItemText(hDlg, aIDs[i], szIPAddress, countof(szIPAddress));
        if (StrToInt(szIPAddress) > 255)
        {
            ErrorMessageBox(hDlg, IDS_BADIPADDR);

            Edit_SetSel(GetDlgItem(hDlg, aIDs[i]), 0, -1);
            SetFocus(GetDlgItem(hDlg, aIDs[i]));

            return FALSE;
        }
    }

    return TRUE;
}


static PSIGNUPFILE IsEntryPathInSignupArray(PSIGNUPFILE pSignupArray, DWORD nSignupArrayElems, LPCTSTR pcszEntryPath)
{
    for ( ;  nSignupArrayElems-- > 0;  pSignupArray++)
        if (ISNONNULL(pSignupArray->szEntryPath)  &&  StrCmpI(PathFindFileName(pSignupArray->szEntryPath), pcszEntryPath) == 0)
            return pSignupArray;

    return NULL;
}


static VOID CleanupSignupFiles(LPCTSTR pcszTempDir, LPCTSTR pcszIns)
{
    for (INT i = 0;  TRUE;  i++)
    {
        TCHAR szKey[8],
              szFile[MAX_PATH];

        wnsprintf(szKey, countof(szKey), FILE_TEXT, i);
        if (GetPrivateProfileString(IS_SIGNUP, szKey, TEXT(""), szFile, countof(szFile), pcszIns) == 0)
            break;

        DeleteFileInDir(szFile, pcszTempDir);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\security.cpp ===
#include "precomp.h"
#include <wincrypt.h>

extern TCHAR g_szCustIns[];
extern TCHAR g_szTempSign[];
extern TCHAR g_szWizRoot[];
extern PROPSHEETPAGE g_psp[];
extern int g_iCurPage;

static void initCerts(HWND hwndCtl);
static void addCompanyCertToReg(HWND hDlg);

BOOL CALLBACK ISPAddRootCertDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szCertFile[MAX_PATH];
    TCHAR szWorkDir[MAX_PATH];
    TCHAR szTemp[MAX_PATH];

    switch (uMsg)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_ISPROOTCERT);
        Edit_LimitText(GetDlgItem(hDlg, IDE_ISPROOTCERT), countof(szCertFile) - 1);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
        case PSN_SETACTIVE:
            // import INS clean-up -- delete cert file from the temp location
            if (InsGetString(IS_ISPSECURITY, IK_ROOTCERT, szCertFile, countof(szCertFile), g_szCustIns))
                DeleteFileInDir(szCertFile, g_szTempSign);

            SetBannerText(hDlg);

            SetDlgItemText(hDlg, IDE_ISPROOTCERT, szCertFile);

            CheckBatchAdvance(hDlg);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            if (!CheckField(hDlg, IDE_ISPROOTCERT, FC_FILE | FC_EXISTS))
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                return TRUE;
            }

            g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szWorkDir);

            // delete the old cert file
            if (InsGetString(IS_ISPSECURITY, IK_ROOTCERT, szTemp, countof(szTemp), g_szCustIns))
                DeleteFileInDir(szTemp, szWorkDir);

            // copy the new cert file
            GetDlgItemText(hDlg, IDE_ISPROOTCERT, szCertFile, countof(szCertFile));
            if (*szCertFile)
                CopyFileToDir(szCertFile, szWorkDir);

            InsWriteString(IS_ISPSECURITY, IK_ROOTCERT, szCertFile, g_szCustIns);

            g_iCurPage = PPAGE_ADDROOT;
            EnablePages();
            (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            QueryCancel(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_BROWSEROOTCERT:
            GetDlgItemText(hDlg, IDE_ISPROOTCERT, szCertFile, countof(szCertFile));
            if (BrowseForFile(hDlg, szCertFile, countof(szCertFile), GFN_CERTIFICATE))
                SetDlgItemText(hDlg, IDE_ISPROOTCERT, szCertFile);
            break;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL CALLBACK CabSignDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szSPCPath[MAX_PATH];
    TCHAR szPVKPath[MAX_PATH];
    TCHAR szDesc[MAX_PATH];
    TCHAR szInfoUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szTimeUrl[INTERNET_MAX_URL_LENGTH];

    switch (uMsg)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDC_CSCOMP);
        initCerts(GetDlgItem(hDlg, IDC_CSCOMP));

        EnableDBCSChars(hDlg, IDE_CSSPC);
        EnableDBCSChars(hDlg, IDE_CSPVK);
        EnableDBCSChars(hDlg, IDE_CSDESC);
        EnableDBCSChars(hDlg, IDE_CSURL);
        EnableDBCSChars(hDlg, IDE_CSTIME);
 
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSSPC),  countof(szSPCPath) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSPVK),  countof(szPVKPath) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSDESC), countof(szDesc)    - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSURL),  countof(szInfoUrl) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CSTIME),  countof(szTimeUrl) - 1);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
        case PSN_SETACTIVE:
            SetBannerText(hDlg);

            InsGetString(IS_CABSIGN, IK_SPC,   szSPCPath, countof(szSPCPath), g_szCustIns);
            InsGetString(IS_CABSIGN, IK_PVK,   szPVKPath, countof(szPVKPath), g_szCustIns);
            InsGetString(IS_CABSIGN, IK_NAME,  szDesc,    countof(szDesc),    g_szCustIns);
            InsGetString(IS_CABSIGN, IK_CSURL, szInfoUrl, countof(szInfoUrl), g_szCustIns);
            InsGetString(IS_CABSIGN, IK_CSTIME, szTimeUrl, countof(szTimeUrl), g_szCustIns);

            SetDlgItemText(hDlg, IDE_CSSPC,  szSPCPath);
            SetDlgItemText(hDlg, IDE_CSPVK,  szPVKPath);
            SetDlgItemText(hDlg, IDE_CSDESC, szDesc);
            SetDlgItemText(hDlg, IDE_CSURL,  szInfoUrl);
            SetDlgItemText(hDlg, IDE_CSTIME,  szTimeUrl);

            CheckBatchAdvance(hDlg);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            GetDlgItemText(hDlg, IDE_CSSPC,  szSPCPath, countof(szSPCPath));
            GetDlgItemText(hDlg, IDE_CSPVK,  szPVKPath, countof(szPVKPath));
            GetDlgItemText(hDlg, IDE_CSDESC, szDesc,    countof(szDesc));
            GetDlgItemText(hDlg, IDE_CSURL,  szInfoUrl, countof(szInfoUrl));
            GetDlgItemText(hDlg, IDE_CSTIME,  szTimeUrl, countof(szTimeUrl));

            if (*szSPCPath  ||  *szPVKPath  ||  *szDesc  ||  *szInfoUrl ||  *szTimeUrl)
            {
                TCHAR szCompanyName[MAX_PATH];
                HWND hwndCtl;
                int iSel;

                if (!CheckField(hDlg, IDE_CSSPC,  FC_NONNULL | FC_FILE | FC_EXISTS)  ||
                    !CheckField(hDlg, IDE_CSPVK,  FC_NONNULL | FC_FILE | FC_EXISTS)  ||
                    !CheckField(hDlg, IDE_CSDESC, FC_NONNULL)                        ||
                    !CheckField(hDlg, IDE_CSURL,  FC_URL)                            ||
                    !CheckField(hDlg, IDE_CSTIME, FC_URL))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE;
                }

                *szCompanyName = TEXT('\0');
                hwndCtl = GetDlgItem(hDlg, IDC_CSCOMP);

                iSel = ComboBox_GetCurSel(hwndCtl);
                if (iSel != CB_ERR)
                    ComboBox_GetLBText(hwndCtl, iSel, szCompanyName);

                InsWriteString(IS_CABSIGN, IK_COMPANYNAME, szCompanyName, g_szCustIns);
            }

            InsWriteString(IS_CABSIGN, IK_SPC,   szSPCPath, g_szCustIns);
            InsWriteString(IS_CABSIGN, IK_PVK,   szPVKPath, g_szCustIns);
            InsWriteString(IS_CABSIGN, IK_NAME,  szDesc,    g_szCustIns);
            InsWriteString(IS_CABSIGN, IK_CSURL, szInfoUrl, g_szCustIns);
            InsWriteString(IS_CABSIGN, IK_CSTIME, szTimeUrl, g_szCustIns);

            g_iCurPage = PPAGE_CABSIGN;
            EnablePages();
            (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            QueryCancel(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_CSADD:
            addCompanyCertToReg(hDlg);       
            break;
        case IDC_BROWSECSSPC:
            GetDlgItemText(hDlg, IDE_CSSPC, szSPCPath, countof(szSPCPath));
            if (BrowseForFile(hDlg, szSPCPath, countof(szSPCPath), GFN_SPC))
                SetDlgItemText(hDlg, IDE_CSSPC, szSPCPath);
            break;

        case IDC_BROWSECSPVK:
            GetDlgItemText(hDlg, IDE_CSPVK, szPVKPath, countof(szPVKPath));
            if (BrowseForFile(hDlg, szPVKPath, countof(szPVKPath), GFN_PVK))
                SetDlgItemText(hDlg, IDE_CSPVK, szPVKPath);
            break;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

static void initCerts(HWND hwndCtl)
{
    HKEY hKey;
    TCHAR szCompanyName[MAX_PATH];

    if (SHOpenKeyHKCU(RK_TRUSTKEY, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        TCHAR szKey[MAX_PATH];
        TCHAR szValue[MAX_PATH];
        DWORD dwEntry;
        DWORD cchKey;
        DWORD cbValue;

        dwEntry = 0;
        cchKey  = countof(szKey);
        cbValue = sizeof(szValue);

        while (RegEnumValue(hKey, dwEntry, szKey, &cchKey, NULL, NULL, (LPBYTE) szValue, &cbValue) == ERROR_SUCCESS)
        {
            if (ComboBox_FindStringExact(hwndCtl, -1, szValue) == CB_ERR)   // string not present
                ComboBox_AddString(hwndCtl, szValue);                       // so, add it

            dwEntry++;
            cchKey  = countof(szKey);
            cbValue = sizeof(szValue);
        }

        RegCloseKey(hKey);
    }

    InsGetString(IS_CABSIGN, IK_COMPANYNAME, szCompanyName, countof(szCompanyName), g_szCustIns);
    if (*szCompanyName == TEXT('\0'))
        StrCpy(szCompanyName, TEXT("MICROSOFT"));

    ComboBox_SelectString(hwndCtl, -1, szCompanyName);
}

static void addCompanyCertToReg(HWND hDlg)
{
    if (CheckField(hDlg, IDE_CSSPC,  FC_NONNULL | FC_FILE | FC_EXISTS)  &&
        CheckField(hDlg, IDE_CSPVK,  FC_NONNULL | FC_FILE | FC_EXISTS))
    {
        TCHAR szTempDir[MAX_PATH];
        TCHAR szTempFile[MAX_PATH];
        TCHAR szCabFile[MAX_PATH];
        TCHAR szResult[MAX_PATH + 16] = TEXT("");
        BOOL fSuccess = FALSE;
    
        
        PathCombine(szTempDir, g_szTempSign, TEXT("SIGN"));
        PathCreatePath(szTempDir);
        
        // copy signing files to temp dir
        
        PathCombine(szTempFile, g_szWizRoot, TEXT("tools\\signcode.exe"));
        CopyFileToDir(szTempFile, szTempDir);
        PathRemoveFileSpec(szTempFile);
        PathAppend(szTempFile, TEXT("signer.dll"));
        CopyFileToDir(szTempFile, szTempDir);
        
        GetDlgItemText(hDlg, IDE_CSSPC, szTempFile, countof(szTempFile));
        InsWriteString(IS_CABSIGN, IK_SPC, szTempFile, g_szCustIns);
        GetDlgItemText(hDlg, IDE_CSPVK, szTempFile, countof(szTempFile));
        InsWriteString(IS_CABSIGN, IK_PVK, szTempFile, g_szCustIns);
        
        InsFlushChanges(g_szCustIns);
        
        PathCombine(szTempFile, szTempDir, TEXT("temp.exe"));

        // copy cabarc.exe from tools dir to  sign

        PathCombine(szCabFile, g_szWizRoot, TEXT("tools\\cabarc.exe"));

        CopyFile(szCabFile, szTempFile, FALSE);
        
        SignFile(szTempFile, NULL, g_szCustIns, szResult, NULL, TRUE);
        
        if (ISNULL(szResult) &&
            (CheckTrustExWrap(NULL, szTempFile, hDlg, FALSE, NULL) == NOERROR))
            fSuccess = TRUE;
            
        if (fSuccess)
        {
            initCerts(GetDlgItem(hDlg, IDC_CSCOMP));
            ErrorMessageBox(hDlg, IDS_SUCCESS_CSADDCERT);
        }
        else
            ErrorMessageBox(hDlg, IDS_ERROR_CSADDCERT);
        
        PathRemovePath(szTempDir);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\keymake.cpp ===
#include "precomp.h"

extern BOOL g_fDemo, g_fKeyGood;
extern BOOL g_fBranded, g_fIntranet;
extern BOOL g_fSilent;
extern int g_iKeyType;

// Note: this function is also in ..\keymaker\keymake.c so make changes in both places

void MakeKey(LPTSTR pszSeed, BOOL fCorp)
{
    int i;
    DWORD dwKey;
    CHAR szKeyA[5];
    CHAR szSeedA[16];

    // always do the keycode create in ANSI

    T2Abux(pszSeed, szSeedA);
    i = lstrlenA(szSeedA);

    if (i < 6)
    {
        // extend the input seed to 6 characters
        for (; i < 6; i++)
            szSeedA[i] = (char)('0' + i);
    }

    // let's calculate the DWORD key used for the last 4 chars of keycode

    // multiply by my first name

    dwKey = szSeedA[0] * 'O' + szSeedA[1] * 'L' + szSeedA[2] * 'I' +
        szSeedA[3] * 'V' + szSeedA[4] * 'E' + szSeedA[5] * 'R';

    // multiply the result by JONCE

    dwKey *= ('J' + 'O' + 'N' + 'C' + 'E');

    dwKey %= 10000;

    if (fCorp)
    {
        // give a separate keycode based on corp flag or not
        // 9 is chosen because is is a multiplier such that for any x,
        // (x+214) * 9 != x + 10000y
        // we have 8x = 10000y - 1926 which when y=1 gives us 8x = 8074
        // since 8074 is not divisible by 8 where guaranteed to be OK since
        // the number on the right can only increase by 10000 increments which
        // are always divisible by 8

        dwKey += ('L' + 'E' + 'E');
        dwKey *= 9;
        dwKey %= 10000;
    }

    wsprintfA(szKeyA, "%04lu", dwKey);
    StrCpyA(&szSeedA[6], szKeyA);
    A2Tbux(szSeedA, pszSeed);
}

BOOL CheckKey(LPTSTR pszKey)
{
    TCHAR szBaseKey[16];

    CharUpper(pszKey);
    StrCpy(szBaseKey, pszKey);
    g_fDemo = g_fKeyGood = FALSE;
    g_iKeyType = KEY_TYPE_STANDARD;

    // check for MS key code

    if (StrCmpI(pszKey, TEXT("MICROSO800")) == 0)
    {
        g_fKeyGood = TRUE;
        return TRUE;
    }

    // check for ISP key code

    MakeKey(szBaseKey, FALSE);

    if (StrCmpI(szBaseKey, pszKey) == 0)
    {
        g_iKeyType = KEY_TYPE_SUPER;
        g_fKeyGood = TRUE;
        g_fBranded = TRUE;
        g_fIntranet = g_fSilent = FALSE;
        return TRUE;
    }

    // check for a corp key code

    MakeKey(szBaseKey, TRUE);

    if (StrCmpI(szBaseKey, pszKey) == 0)
    {
        g_iKeyType = KEY_TYPE_SUPERCORP;
        g_fKeyGood = TRUE;
        g_fBranded = TRUE;
        g_fIntranet = TRUE;
        return TRUE;
    }

    // check for demo key code

    if (StrCmpNI(pszKey, TEXT("DEMO"), 4) == 0  &&  lstrlen(pszKey) > 9)
    {
        g_fDemo = TRUE;
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\update.cpp ===
#include "precomp.h"

extern TCHAR g_szTitle[];
extern TCHAR g_szBuildTemp[];
extern TCHAR g_szBaseURL[];
extern TCHAR g_szWizRoot[];
extern HWND g_hWait;
extern BOOL g_fLocalMode, g_fOCW;
extern int s_iType;

extern DWORD GetRootFree(LPCTSTR pcszPath);
extern HRESULT DownloadCab(HWND hDlg, LPTSTR szUrl, LPTSTR szFilename,
                           LPCTSTR pcszDisplayname, int sComponent, BOOL &fIgnore);

void UpdateIni(LPCTSTR pcszCurrentIni, CCifComponent_t * pCifComponent_t)
{
    TCHAR szNew[INTERNET_MAX_URL_LENGTH];

    if (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("Win32"), szNew, countof(szNew))))
        WritePrivateProfileString(TEXT("IEAK"), TEXT("Win32"), szNew, pcszCurrentIni);
    if (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("Ini"), szNew, countof(szNew))))
        WritePrivateProfileString(VERSION, IK_INI, szNew, pcszCurrentIni);

}

BOOL CheckIniVersion(LPTSTR pszId, LPCTSTR pcszCurrentIni, CCifComponent_t * pCifComponent_t)
{
    TCHAR szCurrentVer[64];
    TCHAR szNewVer[64];
    BOOL fRet = TRUE;

    GetPrivateProfileString(VERSION, pszId, TEXT(""), szCurrentVer, countof(szCurrentVer), pcszCurrentIni);

    fRet = SUCCEEDED(pCifComponent_t->GetCustomData(pszId, szNewVer, countof(szNewVer)));

    return (fRet && (CheckVer(szCurrentVer, szNewVer) < 0));
}

DWORD DownloadUpdateThreadProc(LPVOID lpvUrl)
{
    TCHAR szDest[MAX_PATH];
    TCHAR szMsg[MAX_PATH];
    LPTSTR pFile;
    DWORD dwRet = 0;

    GetTempPath(countof(szDest), szDest);

    pFile = StrRChr((LPTSTR)lpvUrl, NULL, TEXT('/'));

    if (pFile != NULL)
        pFile++;

    if (StrCmpI(StrRChr((LPTSTR)lpvUrl, NULL, TEXT('.')), TEXT(".EXE")) == 0)
    {
        BOOL fIgnore = FALSE;

        PathAppend(szDest, pFile);

        if (DownloadCab(g_hWait, (LPTSTR)lpvUrl, szDest, NULL, 0, fIgnore) != NOERROR)
        {
            LoadString(g_rvInfo.hInst, IDS_UPDATEERROR, szMsg, countof(szMsg));
            MessageBox(g_hWizard, szMsg, g_szTitle, MB_OK);
            return (DWORD)-1;
        }
    }
    else
    {
        BOOL fSuccess = TRUE;
        BOOL fIgnore = FALSE;

        PathCombine(szDest, g_szBuildTemp, pFile);

        if (DownloadCab(g_hWait, (LPTSTR)lpvUrl, szDest, NULL, 0, fIgnore) == NOERROR)
        {
            TCHAR szTempDir[MAX_PATH];

            PathCombine(szTempDir, g_szBuildTemp, TEXT("update"));
            PathCreatePath(szTempDir);

            if (ExtractFilesWrap(szDest, szTempDir, 0, NULL, NULL, 0) == ERROR_SUCCESS)
            {
                TCHAR szInf[MAX_PATH];

                PathCombine(szInf, szTempDir, TEXT("ieak6.inf"));
                dwRet = RunSetupCommandWrap(g_hWizard, szInf, NULL, szTempDir, NULL,
                    NULL, RSC_FLAG_INF | RSC_FLAG_QUIET, NULL);

                PathRemovePath(szTempDir);
                DeleteFile(szDest);
            }
            else
                fSuccess = FALSE;
        }
        else
            fSuccess = FALSE;

        SendMessage(g_hWait, WM_CLOSE, 0, 0);

        if (!fSuccess)
        {
            LoadString(g_rvInfo.hInst, IDS_UPDATEERROR, szMsg, countof(szMsg));
            MessageBox(g_hWizard, szMsg, g_szTitle, MB_OK);
            return (DWORD)-1;
        }
    }

    return dwRet;
}

void UpdateIEAK(HWND hDlg)
{
    TCHAR szCurrentIni[MAX_PATH];
    TCHAR szMsg[MAX_PATH];
    TCHAR szUpdateUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szCifLang[8];
    TCHAR szWizLang[8];
    ICifComponent * pCifComponent;
    CCifComponent_t * pCifComponent_t;
    DWORD dwTid;
    DWORD dwRet = ERROR_SUCCESS;
    BOOL fNo = FALSE;
    HWND hWait;

    if (!g_lpCifFileNew || !(SUCCEEDED(g_lpCifFileNew->FindComponent(TEXT("ieak6OPT"), &pCifComponent))))
        return;

    pCifComponent_t = new CCifComponent_t((ICifRWComponent *)pCifComponent);

    pCifComponent_t->GetCustomData(TEXT("Lang"), szCifLang, countof(szCifLang));

    StrCpy(szUpdateUrl, g_szBaseURL);
    if (*(CharPrev(szUpdateUrl, szUpdateUrl + StrLen(szUpdateUrl))) != TEXT('/'))
        StrCat(szUpdateUrl, TEXT("/"));

    PathCombine(szCurrentIni, g_szWizRoot, TEXT("ieak.ini"));

    GetPrivateProfileString(VERSION, TEXT("Lang"), TEXT(""), szWizLang, countof(szWizLang), szCurrentIni);

    // only allow self-update for same language as the current wizard

    if (StrCmpI(szCifLang, szWizLang) != 0)
        goto exit;

    if (CheckIniVersion(IK_FULL, szCurrentIni, pCifComponent_t))
    {
        pCifComponent_t->GetCustomData(TEXT("FullText"), szMsg, countof(szMsg));

        if (MessageBox(g_hWizard, szMsg, g_szTitle, MB_YESNO | MB_DEFBUTTON2) == IDYES)
        {
            HANDLE hThread;
            TCHAR szExeName[MAX_PATH];
            DWORD dwFlags;
            ICifComponent * pCifExeComponent;
            CCifComponent_t * pCifExeComponent_t;

            if (SUCCEEDED(g_lpCifFileNew->FindComponent(TEXT("ieak6EXE"), &pCifExeComponent)))
            {
                pCifExeComponent_t = new CCifComponent_t((ICifRWComponent *)pCifExeComponent);

                if (SUCCEEDED(pCifExeComponent_t->GetUrl(0, szExeName, countof(szExeName), &dwFlags)))
                {
                    // do not allow self-update to continue if not enough size (size of Exe +
                    // extract size approximated by twice the size of the exe)

                    if (((dwFlags = pCifExeComponent_t->GetDownloadSize() * 3) > GetRootFree(g_szBuildTemp)) &&
                        dwFlags)
                    {
                        TCHAR szMsg[MAX_PATH];
                        TCHAR szMsgTemplate[MAX_PATH];

                        LoadString(g_rvInfo.hInst, IDS_ERROR_UPDATESPACE, szMsgTemplate, countof(szMsgTemplate));
                        wnsprintf(szMsg, countof(szMsg), szMsgTemplate, pCifExeComponent_t->GetDownloadSize() * 3);
                        dwRet = (DWORD)-1;
                        MessageBox(hDlg, szMsg, g_szTitle, MB_OK | MB_ICONEXCLAMATION);
                    }
                    else
                    {
                        StrCat(szUpdateUrl, szExeName);

                        hWait = CreateDialog(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_UPDATE), hDlg,
                            (DLGPROC)DownloadStatusDlgProc);
                        ShowWindow( hWait, SW_SHOWNORMAL );

                        hThread = CreateThread(NULL, 4096, DownloadUpdateThreadProc, (LPVOID)szUpdateUrl, 0, &dwTid);

                        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
                        {
                            MSG msg;

                            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                        GetExitCodeThread(hThread, &dwRet);
                        CloseHandle(hThread);
                        SendMessage(hWait, WM_CLOSE, 0, 0);
                    }
                }
                else
                    dwRet = (DWORD)-1;

                delete pCifExeComponent_t;
            }
            else
                dwRet = (DWORD)-1;

            if (dwRet == -1)
            {
                g_fLocalMode = TRUE;
                goto exit;
            }
            else
            {
                SHELLEXECUTEINFO shInfo;
                DWORD dwPID;
                TCHAR szTempBuf[MAX_PATH + 32];
                TCHAR szTempPath[MAX_PATH];

                PathCombine(szTempBuf, g_szWizRoot, TEXT("update.exe"));
                GetTempPath(countof(szTempPath), szTempPath);
                CopyFileToDir(szTempBuf, szTempPath);

                ZeroMemory(&shInfo, sizeof(shInfo));
                shInfo.cbSize = sizeof(shInfo);
                shInfo.hwnd = GetDesktopWindow();
                shInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
                shInfo.lpVerb = TEXT("open");
                shInfo.lpFile = TEXT("update.exe");
                dwPID = GetCurrentProcessId();
                WCHAR wcType;
                switch (s_iType)
                {
                    case BRANDED:
                        wcType = TEXT('B');
                    break;
                    
                    case REDIST:
                        wcType = TEXT('R');
                    break;

                    case INTRANET:
                    default:
                        wcType = TEXT('I');
                    break;
                }
                if (g_fOCW)
                    wnsprintf(szTempBuf, countof(szTempBuf), TEXT("/o /p:%lu /m:%c"), dwPID,wcType);
                else
                    wnsprintf(szTempBuf, countof(szTempBuf), TEXT("/p:%lu /m:%c"), dwPID,wcType);

                shInfo.lpParameters = szTempBuf;
                shInfo.lpDirectory = szTempPath;
                shInfo.nShow = SW_SHOWNORMAL;

                ShellExecuteEx(&shInfo);
                CloseHandle(shInfo.hProcess);
                DoCancel();
                goto exit;
            }
        }
        else
            fNo = TRUE;
    }

    if (!fNo && (CheckIniVersion(IK_CAB, szCurrentIni, pCifComponent_t)))
    {
        pCifComponent_t->GetCustomData(TEXT("CabText"), szMsg, countof(szMsg));

        if (MessageBox(g_hWizard, szMsg, g_szTitle, MB_YESNO | MB_DEFBUTTON2) == IDYES)
        {
            TCHAR szNewVer[MAX_PATH];
            TCHAR  szCabName[32];
            DWORD dwFlags;
            HANDLE hThread;
            ICifComponent * pCifCabComponent;
            CCifComponent_t * pCifCabComponent_t;

            if (SUCCEEDED(g_lpCifFileNew->FindComponent(TEXT("ieak6CAB"), &pCifCabComponent)))
            {
                pCifCabComponent_t = new CCifComponent_t((ICifRWComponent *)pCifCabComponent);

                if (SUCCEEDED(pCifCabComponent_t->GetUrl(0, szCabName, countof(szCabName), &dwFlags)))
                {
                    // do not allow self-update to continue if not enough size (size of Cab +
                    // extract size approximated by twice the size of the cab)

                    if (((dwFlags = pCifCabComponent_t->GetDownloadSize() * 3) > GetRootFree(g_szBuildTemp)) &&
                        dwFlags)
                    {
                        TCHAR szMsg[MAX_PATH];
                        TCHAR szMsgTemplate[MAX_PATH];

                        LoadString(g_rvInfo.hInst, IDS_ERROR_UPDATESPACE, szMsgTemplate, countof(szMsgTemplate));
                        wnsprintf(szMsg, countof(szMsg), szMsgTemplate, pCifCabComponent_t->GetDownloadSize() * 3);
                        dwRet = (DWORD)-1;
                        MessageBox(hDlg, szMsg, g_szTitle, MB_OK | MB_ICONEXCLAMATION);
                    }
                    else
                    {
                        StrCat(szUpdateUrl, szCabName);

                        hWait = CreateDialog(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_UPDATE), hDlg,
                            (DLGPROC)DownloadStatusDlgProc);
                        ShowWindow( hWait, SW_SHOWNORMAL );

                        hThread = CreateThread(NULL, 4096, DownloadUpdateThreadProc, (LPVOID)szUpdateUrl, 0, &dwTid);

                        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
                        {
                            MSG msg;

                            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                        GetExitCodeThread(hThread, &dwRet);
                        CloseHandle(hThread);
                        SendMessage(hWait, WM_CLOSE, 0, 0);
                    }
                }
                else
                    dwRet = (DWORD)-1;

                delete pCifCabComponent_t;
            }
            else
                dwRet = (DWORD)-1;

            if (dwRet == (DWORD)-1)
            {
                g_fLocalMode = TRUE;
                goto exit;
            }

            if (CheckIniVersion(IK_INI, szCurrentIni, pCifComponent_t))
                UpdateIni(szCurrentIni, pCifComponent_t);

            if (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("Cab"), szNewVer, countof(szNewVer))))
                WritePrivateProfileString(VERSION, IK_CAB, szNewVer, szCurrentIni);
        }
        else
            fNo = TRUE;
    }

    if (!fNo && (CheckIniVersion(IK_INI, szCurrentIni, pCifComponent_t)))
    {
        pCifComponent_t->GetCustomData(TEXT("IniText"), szMsg, countof(szMsg));

        if (MessageBox(g_hWizard, szMsg, g_szTitle, MB_YESNO | MB_DEFBUTTON2) == IDYES)
        {
            UpdateIni(szCurrentIni, pCifComponent_t);
        }
        else
            fNo = TRUE;
    }

    if (dwRet == ERROR_SUCCESS_REBOOT_REQUIRED)
        DoReboot(g_hWizard);

    if (fNo)
        g_fLocalMode = TRUE;

exit:
    delete pCifComponent_t;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\updates.h ===
#define DONT_SHOW_UPDATES       0xdeadbeef 
#define SHOW_UPDATES            0xabaddeed

typedef HRESULT (* FCLV_PREADDLISTITEM)(HWND hListView, int * count, CCifComponent_t *);

extern PCOMPONENT g_paComp;
extern PCOMPONENT g_pMNComp;
extern TCHAR g_szIEAKProg[MAX_PATH];
extern TCHAR g_szCifVer[MAX_PATH];
extern TCHAR g_szCif[MAX_PATH];
extern TCHAR g_szUpdateURL[MAX_URL];
extern TCHAR g_szUpdateData[MAX_URL];
extern UINT g_uiNumCabs;
extern BOOL g_fOCW;

extern HIMAGELIST s_hImgList;
extern HWND s_hStat;
extern int s_aiIcon[7];
extern DWORD GetRootFree(LPCTSTR pcszPath);
extern void updateCifVersions32(PCOMPONENT pComp, BOOL fIgnore, BOOL fUpdate);
extern PCOMPONENT FindComp(LPCTSTR szID, BOOL fCore);
extern BOOL CALLBACK ErrDlgProc (HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
extern int DownloadErrMsg(HWND hWnd, LPTSTR szFilename, LPCTSTR lpTemplateName);
extern HRESULT DownloadCab(HWND hDlg, LPTSTR szUrl, LPTSTR szFilename, LPCTSTR pcszDisplayname, int sComponent, BOOL &fIgnore);

void InsertCommas(LPTSTR szIn);

ATOM CreateIEAKUrl();

void UpdateBlueIcon(HWND hCompList, PCOMPONENT pComp);

void UpdateBrownIcon(HWND hCompList, PCOMPONENT pNewComp);

HRESULT ProcessUpdateIcons(HWND hDlg);

HRESULT CifComponentToPComponent(PCOMPONENT pComp, CCifComponent_t * pCifComponent_t);

HRESULT DownloadUpdate(PCOMPONENT pComp);

void InitAVSListView(HWND hCompList);

HRESULT AssignComponentIcon(LPTSTR szInID, int pageNumber);

HRESULT PreAddListItem(HWND hCompList, int * count, CCifComponent_t * pCifComp);

int FillComponentsListView(HWND hCompList, LPCTSTR szCifPath, FCLV_PREADDLISTITEM pfnPreAddListItem);

DWORD InitUpdateThreadProc(LPVOID lParam);

DWORD UpdateDlg_InitDialog(HWND hDlg, LPTSTR ps_szFreeSpace, LPTSTR ps_szTotalSize);

PCOMPONENT* UpdateDlg_GetDownloadList(HWND hDlg);

void UpdateDlg_GetDownloadSize(HWND hCompList, HWND hStatusField, BOOL fAll);

LRESULT CALLBACK HyperLinkWndProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

BOOL CALLBACK UpdateDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

#ifndef ISNULL
#define ISNULL(psz)    (*(psz) == TEXT('\0'))
#endif

#ifndef ISNONNULL
#define ISNONNULL(psz) (*(psz) != TEXT('\0'))
#endif

DWORD   FolderSize(LPCTSTR pszFolderName);
HRESULT CopyFilesSrcToDest(LPCTSTR pszSrcPath, LPCTSTR pszSrcFilter, LPCTSTR pszDestPath,
                           DWORD dwTicks = 0);

void  TooBig(HWND hWnd, WORD id);
void SetWindowTextSmart(HWND hwnd, LPCTSTR pcszText);

DWORD ShellExecAndWait(SHELLEXECUTEINFO shInfo);

LPTSTR StrTok(LPTSTR pcszToken, LPCTSTR pcszDelimit);

void LVGetItems(HWND hwndLV);

LPTSTR GetOutputPlatformDir();

int GetRole(BOOL g_fBranded, BOOL g_fIntranet);

BOOL IsIconsInFavs(LPCTSTR pcszSection, LPCTSTR pcszCustIns);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\updates.cpp ===
#include "precomp.h"
#include "ie4comp.h"
#include "updates.h"

extern PCOMP_VERSION g_rgCompVer;

void InsertCommas(LPTSTR pszIn)
{                                     //---- Puts commas into numbered strings ending in " KB" ----
    TCHAR szTemp[30], szTemp2[30];
    int   i, j, z;

    for (j=0; pszIn[j+3]; j++);
    for (i=j-1; i>=0; i--)
        szTemp[j-i-1]=pszIn[i];
    szTemp[j]='\0';
    z=0;
    for (i=0; szTemp[i]; i++, z++) {
        szTemp2[z] = szTemp[i];
        if (i % 3 == 2) {
            z++;
            szTemp2[z] = ',';
        }
    }
    if (',' == szTemp2[z-1])
        z--;
    szTemp2[z]='\0';
    for (i=z-1; i>=0; i--)
        pszIn[z-i-1] = szTemp2[i];
    pszIn[z]='\0';
    StrCat(pszIn, TEXT(" KB"));
}

ATOM CreateIEAKUrl()
{
    WNDCLASS wc;
    wc.style         = 0;
    wc.lpfnWndProc   = HyperLinkWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = g_rvInfo.hInst;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(g_rvInfo.hInst, MAKEINTRESOURCE(IDC_LINK));
    wc.hbrBackground = (HBRUSH) GetStockObject(GetSysColor(COLOR_MENU));
    wc.lpszMenuName  = TEXT("Link Window");
    wc.lpszClassName = TEXT("Link Window");
    return RegisterClass(&wc);
}

HRESULT CifComponentToPComponent(PCOMPONENT pComp, CCifComponent_t * pCifComponent_t)
{
    TCHAR          szCustData[MAX_PATH], szID[128], szMode[MAX_PATH];
    DWORD          dwPlatform, dwType, dwVer, dwBuild;
    UINT           uiIndex = 0;
    ICifComponent* pCifComponentTemp;
    
    pComp->fVisible = (pCifComponent_t->IsUIVisible() == S_FALSE) ? FALSE : TRUE;

    dwPlatform = pCifComponent_t->GetPlatform();

    if (dwPlatform & PLATFORM_WIN98)
    {
        if (dwPlatform & PLATFORM_NT4)
            pComp->iPlatform = PLAT_I386;
        else
            pComp->iPlatform = PLAT_W98;
    }
    else
        pComp->iPlatform = PLAT_NTx86;

    pCifComponent_t->GetID(szID, countof(szID));

    if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("AddOnOnly"), szCustData, countof(szCustData))))
        && (szCustData[0] == TEXT('1')))
    {
        pComp->fAddOnOnly = TRUE;
        pComp->fVisible = TRUE;
    }

    if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKVisible"), szCustData, countof(szCustData))))
        && (szCustData[0] == TEXT('1')))
        pComp->fVisible = TRUE;

    szMode[0] = TEXT('\0');
    if (SUCCEEDED(g_lpCifRWFile->FindComponent(szID, &pCifComponentTemp)))
    {
        CCifComponent_t * pCifComponentTemp_t =
            new CCifComponent_t((ICifRWComponent *)pCifComponentTemp);
        while (SUCCEEDED(pCifComponentTemp_t->GetMode(uiIndex, szMode, countof(szMode))))
        {
            pComp->szModes[uiIndex] = szMode[0];
            pComp->afInstall[szMode[0] - TEXT('0')] = TRUE;
            uiIndex++;
        }
        delete pCifComponentTemp_t;
    }
    else
    {
        while (SUCCEEDED(pCifComponent_t->GetMode(uiIndex, szMode, countof(szMode))))
        {
            pComp->szModes[uiIndex] = szMode[0];
            pComp->afInstall[szMode[0] - TEXT('0')] = TRUE;
            uiIndex++;
        }
    } 

    pComp->szModes[uiIndex] = TEXT('\0');

    ZeroMemory(pComp->szVersion, sizeof(pComp->szVersion));
    pCifComponent_t->GetVersion(&dwVer, &dwBuild);
    ConvertDwordsToVersionStr(pComp->szVersion, dwVer, dwBuild);
    
    if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKCore"), szCustData, countof(szCustData))))
        && (szCustData[0] == TEXT('1')))
    {
        pComp->iCompType = COMP_CORE;
        pComp->fVisible = FALSE;
    }

    // pick up special core comps for OCW

    if (g_fOCW && (SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKOCWCore"), szCustData, countof(szCustData))))
        && (szCustData[0] == TEXT('1')))
    {
        pComp->iCompType = COMP_CORE;
        pComp->fVisible = FALSE;
    }

    if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKServer"), szCustData, countof(szCustData))))
        && (szCustData[0] == TEXT('1')))
        pComp->iCompType = COMP_SERVER;

    // IEAK should ignore these components since they point to the same cabs as
    // another section

    if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKAVSIgnore"), szCustData, countof(szCustData))))
        && (szCustData[0] == TEXT('1')))
    {
        pComp->fAVSDupe = TRUE;
        pComp->fVisible = FALSE;
    }

    // pick up components which point to the same cabs as this section

    if ((SUCCEEDED(pCifComponent_t->GetCustomData(TEXT("IEAKAVSLinks"), szCustData, countof(szCustData))))
        && ISNONNULL(szCustData))
    {
        StrRemoveWhitespace(szCustData);
        if ((pComp->pszAVSDupeSections =
            (LPTSTR)CoTaskMemAlloc((StrLen(szCustData)+1) * sizeof(TCHAR))) != NULL)
            StrCpy(pComp->pszAVSDupeSections, szCustData);
    }
    else
        pComp->pszAVSDupeSections = NULL;

    StrCpy(pComp->szSection, szID);

    /*bug 14679 - don't change these pointers in updates.cpp or this will get clobbered when updates.cpp frees
    all this memory!!

    if (StrCmpI(szID, TEXT("MAILNEWS")) == 0)
        g_pMNComp = pComp;

*/

    pCifComponent_t->GetGUID(pComp->szGUID, countof(pComp->szGUID));
    pCifComponent_t->GetDescription(pComp->szDisplayName, countof(pComp->szDisplayName));
    pCifComponent_t->GetUrl(0, pComp->szUrl, countof(pComp->szUrl), &dwType);
    if (!(dwType & URLF_RELATIVEURL))
    {
        LPTSTR pUrl;
        TCHAR szTempUrl[MAX_PATH];

        pUrl = StrRChr(pComp->szUrl, NULL, TEXT('/'));
        if (pUrl)
            pUrl++;
        else
            pUrl = pComp->szUrl;

        StrCpy(szTempUrl, pUrl);
        StrCpy(pComp->szUrl, szTempUrl);
    }

    pComp->dwSize = pCifComponent_t->GetDownloadSize();
    return TRUE;
}

void UpdateBlueIcon(HWND hCompList, PCOMPONENT pComp)
{
    PCOMPONENT pCompTemp = FindComp(pComp->szSection, FALSE);
    LVITEM     lvi;
                                
    StrCpy(pCompTemp->szVersion, pComp->szVersion);
    pCompTemp->dwSize = pComp->dwSize;
    pCompTemp->iImage = BLUE2;

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask  = LVIF_IMAGE;
    lvi.iItem = pCompTemp->iList;
    ListView_GetItem(hCompList, &lvi);

    lvi.iImage = BLUE2;
    lvi.mask   = LVIF_IMAGE;
    lvi.iItem  = pCompTemp->iList;

    ListView_SetItem(hCompList, &lvi);
    ListView_SetItemText(hCompList, lvi.iItem, 1, pComp->szVersion);
}

void UpdateBrownIcon(HWND hCompList, PCOMPONENT pNewComp)
{
    PCOMPONENT pComp = NULL;
    PCOMP_VERSION pCompVer = NULL;
    LVITEM     lvi;
    int        nList = ListView_GetItemCount(hCompList);
    UINT        uiSize;
    
    ZeroMemory(&lvi, sizeof(lvi));

    uiSize = (UINT)LocalSize(g_paComp);
    
    if (uiSize < (g_uiNumCabs * sizeof(COMPONENT)))
    {
        ASSERT(TRUE);  //not enough memory for all these components
        return;
    }

    pComp = g_paComp + g_uiNumCabs;
    *pComp = *pNewComp;

    //we also need to set g_rgCompVer
    pCompVer = g_rgCompVer + g_uiNumCabs;
    StrCpy(pCompVer->szID,pComp->szCommand);
    StrCpy(pCompVer->szVersion,pComp->szVersion);
  
    pComp->iList  = nList;
    pComp->iImage = BROWN2;
    
    lvi.mask       = LVIF_TEXT | LVIF_IMAGE;
    lvi.iItem      = nList;
    lvi.iSubItem   = 0;
    lvi.iImage     = BROWN2;
    lvi.pszText    = pComp->szDisplayName;
    lvi.cchTextMax = countof(pComp->szDisplayName);
    ListView_InsertItem(hCompList, &lvi);

    //handle our special case globals--per bug 14679, we have to be very careful what these point
    //to, that it's something that won't be freed until we are really done.  g_paComp will hold
    //onto this memory until the end, though having these global pointers is still risky design

    if (StrCmpI(pComp->szDisplayName, TEXT("MAILNEWS")) == 0)
        g_pMNComp = pComp;

    ListView_SetItemText(hCompList, nList, 1, pComp->szVersion);
    g_uiNumCabs++;
}

HRESULT ProcessUpdateIcons(HWND hDlg)
{                                  //---- fixes  updated component for the main page list view
    HWND                hCompList          = GetDlgItem(hDlg, IDC_COMPLIST);
    HRESULT             hr                 = NULL;
    TCHAR               szUpdateCif[MAX_PATH];
    PCOMP_VERSION       pCompVer           = NULL;
    CCifFile_t*         pCifFile           = NULL;
    IEnumCifComponents* pEnumCifComponents = NULL;

    PathCombine(szUpdateCif, g_szIEAKProg, TEXT("update\\ieupdate.cif"));

    if (!PathFileExists(szUpdateCif))
        return DONT_SHOW_UPDATES;

    if ((0 == StrCmp(TEXT(""), g_szUpdateData)) || (0 == StrCmp(TEXT(""), g_szUpdateURL)))
        GetUpdateSite();
    
    GetICifFileFromFile_t(&pCifFile, szUpdateCif);
    hr = pCifFile->EnumComponents(&pEnumCifComponents, PLATFORM_WIN98 | PLATFORM_NT4 | 
                                                       PLATFORM_NT5 | PLATFORM_MILLEN, NULL);
    if (FAILED(hr)) {
        delete pCifFile;
        return hr;
    }
    
    ICifComponent* pCifComponent = NULL;
    PCOMPONENT     pComp         = NULL;
    
    pComp = (PCOMPONENT) LocalAlloc(LPTR, sizeof(COMPONENT) );
          
    while (S_OK == pEnumCifComponents->Next(&pCifComponent))
    {
        CCifComponent_t* pCifComp;

        pCifComp = new CCifComponent_t((ICifRWComponent*)pCifComponent);
        if (NULL == pCifComp) {
            delete pCifComp;
            continue;
        }
        
        ZeroMemory(pComp, sizeof(COMPONENT));
        CifComponentToPComponent(pComp, pCifComp);
        if ((FALSE == pComp->fVisible) || (TRUE == pComp->fAVSDupe)) {
            delete pCifComp;
            continue;
        }

        pComp->iImage = AssignComponentIcon(pComp->szSection, 3);

        if (DONT_SHOW_UPDATES != pComp->iImage) {
            if (BLUE2 == pComp->iImage) 
                UpdateBlueIcon(hCompList, pComp);

            if (BROWN2 == pComp->iImage)
                UpdateBrownIcon(hCompList, pComp);
        }

        delete pCifComp;
    }

    pEnumCifComponents->Release();
    delete pCifFile;
    LocalFree(pComp);
    return TRUE;
}

HRESULT DownloadUpdate(PCOMPONENT pComp)
{
    TCHAR        szLocalPath[MAX_PATH], szUrl[INTERNET_MAX_URL_LENGTH];
    LPTSTR       pCab = NULL;
    DWORD        dwFreeSpace;
    HRESULT      hr;
    BOOL         fIgnore = FALSE;
    
    if (pComp->szDisplayName)
        SetDlgItemText( s_hStat, IDC_DOWNCOMPNAMD, pComp->szDisplayName );
    
    PathCombine(szLocalPath, g_szIEAKProg, pComp->szUrl);

    StrCpy(szUrl, g_szUpdateURL);
    StrCat(szUrl, TEXT("/"));
    StrCat(szUrl, pComp->szUrl);

    dwFreeSpace = GetRootFree(g_szIEAKProg);
    if (dwFreeSpace < pComp->dwSize)
    {
        TCHAR szTitle[MAX_PATH];
        TCHAR szTemplate[MAX_PATH];
        TCHAR szMsg[MAX_PATH];
        LoadString( g_rvInfo.hInst, IDS_DISKERROR, szTitle, MAX_PATH );
        LoadString( g_rvInfo.hInst, IDS_TEMPDISKMSG, szTemplate, MAX_PATH );
        wnsprintf(szMsg, countof(szMsg), szTemplate, dwFreeSpace, (pComp->dwSize));
        MessageBox(NULL, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
        return FALSE;
    }

    hr = DownloadCab(s_hStat, szUrl, szLocalPath, pComp->szDisplayName, pComp->dwSize, fIgnore);
    if (!PathFileExists(szLocalPath) || (DONT_SHOW_UPDATES == hr))
        return DONT_SHOW_UPDATES;

    updateCifVersions32(pComp, fIgnore, TRUE);
 
    return S_OK;
}

void InitAVSListView(HWND hCompList)
{
    LVCOLUMN lvc;
    TCHAR    szAux[MAX_PATH];
    HICON    hBrown, hBrown2, hBlue, hBlue2, hRed, hYellow, hGreen;
        
    //----- Create the image list if it has not already been created -----
    if (s_hImgList == 0) 
    {
        s_hImgList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
        GetSystemMetrics(SM_CYSMICON), 1, 7, 1);

        hBrown  = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_BROWN));
        hBrown2 = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_BROWN2));
        hBlue   = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_BLUE));
        hBlue2  = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_BLUE2));
        hRed    = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_RED));
        hYellow = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_YELLOW));
        hGreen  = LoadIcon(g_rvInfo.hInst, MAKEINTRESOURCE(IDI_GREEN));

        s_aiIcon[0] = ImageList_AddIcon(s_hImgList, hBrown);
        s_aiIcon[1] = ImageList_AddIcon(s_hImgList, hBrown2);
        s_aiIcon[2] = ImageList_AddIcon(s_hImgList, hBlue);
        s_aiIcon[3] = ImageList_AddIcon(s_hImgList, hBlue2);
        s_aiIcon[4] = ImageList_AddIcon(s_hImgList, hRed);
        s_aiIcon[5] = ImageList_AddIcon(s_hImgList, hYellow);
        s_aiIcon[6] = ImageList_AddIcon(s_hImgList, hGreen);
    
        DestroyIcon(hBrown);
        DestroyIcon(hBrown2);
        DestroyIcon(hBlue);
        DestroyIcon(hBlue2);
        DestroyIcon(hRed);
        DestroyIcon(hYellow);
        DestroyIcon(hGreen);
    }

    // Assign the image lists to the list view control.
    ListView_SetImageList(hCompList, s_hImgList, LVSIL_SMALL);

    //----- Initialize columns in a list view -----
    LoadString(g_rvInfo.hInst, IDS_COMPNAME, szAux, countof(szAux));

    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvc.fmt     = LVCFMT_LEFT;
    lvc.cx      = 273;
    lvc.pszText = szAux;
    ListView_InsertColumn(hCompList, 0, &lvc);

    LoadString(g_rvInfo.hInst, IDS_VERSION, szAux, countof(szAux));

    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvc.fmt     = LVCFMT_LEFT;
    lvc.cx      = 105;
    lvc.pszText = szAux;
    ListView_InsertColumn(hCompList, 1, &lvc);   
}

HRESULT AssignComponentIcon(LPTSTR szInID, int ipageNumber)
{
    //---- returns the icon color, Unless the component update is not shown => returns DONT_SHOW_UPDATE
    TCHAR             szDiskVer[MAX_PATH], szSetupVer[MAX_PATH], szUpdateVer[MAX_PATH], 
                      szIECifPath[MAX_PATH], szUpdatePath[MAX_PATH];
    HRESULT           hr = NULL;
    DWORD             dwVer, dwBuild;
    UINT              i;
    BOOL              fOnDisk = TRUE, fInSetupFile = TRUE, fInUpdateFile = TRUE, fInDownload = TRUE;
    PCOMP_VERSION     pCompVer = NULL;
    CCifFile_t      * lpDiskFile     = NULL, * lpSetupFile     = NULL, * lpUpdateFile     = NULL;
    ICifComponent   * pDiskComponent = NULL, * pSetupComponent = NULL, * pUpdateComponent = NULL;
    CCifComponent_t * pDiskComp      = NULL, * pSetupComp      = NULL, * pUpdateComp      = NULL;
    int               iDiskSetup;
    
    PathCombine(szIECifPath, g_szIEAKProg, TEXT("new\\iesetup.cif"));
    PathCombine(szUpdatePath, g_szIEAKProg, TEXT("update\\ieupdate.cif"));
    
    if (PathFileExists(g_szCif))
        hr = GetICifFileFromFile_t(&lpDiskFile, g_szCif);
    else
        fOnDisk = FALSE;

    pCompVer = g_rgCompVer;
    for (i=0; i < g_uiNumCabs; i++, pCompVer++) 
        if ((NULL != pCompVer->szID) && (0 == StrCmp(pCompVer->szID, szInID))) {
            StrCpy(szSetupVer, pCompVer->szVersion);
            fInSetupFile = TRUE;
            break;
        }
    if (((NULL == pCompVer->szID) || (i == g_uiNumCabs)) && (0 != StrCmp(pCompVer->szID, szInID)))
        fInSetupFile = FALSE;

    if (PathFileExists(szUpdatePath))                                          
        hr = GetICifFileFromFile_t(&lpUpdateFile, szUpdatePath);
    else
        fInUpdateFile = FALSE;

    if (fOnDisk)
        fOnDisk = SUCCEEDED(lpDiskFile->FindComponent(szInID, &pDiskComponent));
        if (fOnDisk)                                                                //--- Search ID in Builds\...\IEsetup.cif
        {
            TCHAR szPath[MAX_PATH], szUrl[MAX_PATH];
            DWORD dwType;

            pDiskComp = new CCifComponent_t((ICifRWComponent *) pDiskComponent);   
            StrCpy(szPath, g_szIEAKProg);

            pDiskComp->GetUrl(0, szUrl, countof(szUrl), &dwType);       //--- Check to see if it the cab is downloaded
            if (!(dwType & URLF_RELATIVEURL))
            {
                LPTSTR pUrl;
                TCHAR szTempUrl[MAX_PATH];

                pUrl = StrRChr(szUrl, NULL, TEXT('/'));
                if (pUrl)
                    pUrl++;
                else
                    pUrl = szUrl;

                StrCpy(szTempUrl, pUrl);
                StrCpy(szUrl, szTempUrl);
            }

            PathAppend(szPath, szUrl);

            if (!PathFileExists(szPath))
                fInDownload = FALSE;
            pDiskComp->GetVersion(&dwVer, &dwBuild);
            ConvertDwordsToVersionStr(szDiskVer, dwVer, dwBuild);
        }
        else
            fInDownload = FALSE;
    if (fInUpdateFile)
        fInUpdateFile = SUCCEEDED(lpUpdateFile->FindComponent(szInID, &pUpdateComponent));
        if (fInUpdateFile)                                                          //--- Search ID in update\IEsetup.cif
        {
            pUpdateComp = new CCifComponent_t((ICifRWComponent *) pUpdateComponent);   
            pUpdateComp->GetVersion(&dwVer, &dwBuild);
            ConvertDwordsToVersionStr(szUpdateVer, dwVer, dwBuild);
        }

    delete pSetupComp;
    delete pDiskComp;
    delete pUpdateComp;
    delete lpDiskFile;
    delete lpSetupFile;
    delete lpUpdateFile;

    if ((ipageNumber == 1) || (ipageNumber == 3))
        if ((!fOnDisk) || (!fInDownload))
            return RED;
        else 
        {
            iDiskSetup = CheckVer(szDiskVer, szSetupVer);
            if ((fInSetupFile) && (0 > iDiskSetup))
                return YELLOW;
            else
                if ((fInSetupFile) && (0 == iDiskSetup))
                    return GREEN;
        }

    if (fOnDisk)
    {
        if ((2 == ipageNumber) && (((CheckVer(szDiskVer, szUpdateVer) == 0) && (fInDownload)) ||
                                   (0 == CheckVer(szUpdateVer, szSetupVer))))
            return DONT_SHOW_UPDATES;
        if (2 == ipageNumber)
            if (fInSetupFile)
                return BLUE;
            else
                return BROWN;
        if (fInSetupFile)
            return BLUE2;
        else
            return BROWN2;
    }
    else
        if (!fInSetupFile)
            return BROWN;
        else
            return BLUE;
}

HRESULT PreAddListItem(HWND hCompList, int * count, CCifComponent_t * pCifComp)
{
    LVITEM       lvi;
    PCOMPONENT   pComp = NULL;
    
    ZeroMemory(&lvi, sizeof(lvi));

    pComp = (PCOMPONENT) LocalAlloc(LPTR, sizeof(COMPONENT) );
    if (!pComp) 
        return FALSE;
    ZeroMemory(pComp, sizeof(COMPONENT));
    
    CifComponentToPComponent(pComp, pCifComp);

    if ((TRUE == pComp->fAVSDupe) || (FALSE == pComp->fVisible))
        return FALSE;
    else
        pComp->iImage = lvi.iImage = AssignComponentIcon(pComp->szSection, 2);
    if (DONT_SHOW_UPDATES == lvi.iImage)
        return FALSE;

    lvi.lParam     = (LPARAM) pComp;

    lvi.mask       = LVIF_STATE | LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvi.iItem      = *count;
    lvi.pszText    = pComp->szDisplayName;
    lvi.cchTextMax = countof(pComp->szDisplayName);

    ListView_InsertItem(hCompList, &lvi);
    ListView_SetItemText(hCompList, *count, 1, pComp->szVersion);
    return TRUE;
}

int FillComponentsListView(HWND hCompList, LPCTSTR szCifPath, FCLV_PREADDLISTITEM pfnPreAddListItem)
{
    HRESULT  hr;
    LPLVITEM plvi   = NULL;
    int      icount = 0;
    CCifFile_t* pCifFile = NULL;

    InitAVSListView(hCompList);                 //---- assigns image list and creates columns

    if (NULL == pfnPreAddListItem)
        return S_FALSE;

    hr = GetICifFileFromFile_t(&pCifFile, szCifPath);
    if (FAILED(hr))
        return hr;

    IEnumCifComponents* pEnumCifComponents = NULL;
    ICifComponent*      pCifComponent      = NULL;

    hr = pCifFile->EnumComponents(&pEnumCifComponents,
                                  PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_MILLEN, NULL);
    if (FAILED(hr))
        return hr;

    while (S_OK == pEnumCifComponents->Next(&pCifComponent))
    {
        CCifComponent_t* pCifComponent_t;

        pCifComponent_t = new CCifComponent_t((ICifRWComponent*)pCifComponent);
        if (NULL == pCifComponent_t)
            continue;

        if (!(*pfnPreAddListItem)(hCompList, &icount, pCifComponent_t))
            delete pCifComponent_t;
        else
            icount++;                            //----- Don't delete the component if it's in the list view
    }
    pEnumCifComponents->Release();

    delete pCifFile;
    return icount;
}

DWORD InitUpdateThreadProc(LPVOID lParam)    //----- Downloads cab file, extracts new cif, and sends status -----
{
    TCHAR   szLocalCab[MAX_PATH], szCabURL[MAX_PATH], szLocalDir[MAX_PATH];
    HWND    hDlg      = (HWND) lParam,
            hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
    HRESULT hrCom;
    int     count     = 0;
    BOOL    fIgnore   = FALSE;

    CCifFile_t * lpUpdateFile = NULL;

    hrCom = CoInitialize(NULL);

    PathCombine(szLocalDir, g_szIEAKProg, TEXT("update\\"));
  
    TCHAR szMsg[MAX_PATH], szTitle[MAX_PATH];
    LoadString(g_rvInfo.hInst, IDS_NOUPDATETITLE, szTitle, countof(szTitle));
    LoadString(g_rvInfo.hInst, IDS_ERROR_UPDATEFOLDER, szMsg, countof(szMsg));

    if (!PathIsDirectory(szLocalDir))
        while ((!CreateDirectory(szLocalDir, NULL)) && (IDRETRY == MessageBox(hDlg, szMsg, szTitle, MB_ICONERROR | MB_RETRYCANCEL)));

    if ((0 == StrCmp(TEXT(""), g_szUpdateData)) || (0 == StrCmp(TEXT(""), g_szUpdateURL)))
        GetUpdateSite();
    
    ZeroMemory(szCabURL, sizeof(szCabURL));
    StrCpy(szCabURL, g_szUpdateURL);
    StrCat(szCabURL, TEXT("/IEUPDATE.CAB"));
    PathCombine(szLocalCab, szLocalDir, TEXT("IEUPDATE.CAB"));

    if (SUCCEEDED(DownloadCab(hDlg, szCabURL, szLocalCab, TEXT("IEUPDATE.CAB"), 0, fIgnore))) 
    {
        if (SUCCEEDED(ExtractFilesWrap(szLocalCab, szLocalDir, 0, NULL, NULL, 0)))
        {
            TCHAR szLocalCif[MAX_PATH];
            FCLV_PREADDLISTITEM pfnPreAddListItem = PreAddListItem;
    
            PathCombine(szLocalCif, szLocalDir, TEXT("ieupdate.cif"));

            count = FillComponentsListView(hCompList, szLocalCif, pfnPreAddListItem);
            if ((0 < count) && (9 > count))
                ListView_SetColumnWidth(hCompList, 1, 128);
            else
                ListView_SetColumnWidth(hCompList, 1, 113);
        }
        else
        {
            LoadString(g_rvInfo.hInst, IDS_ERROR_IEUPDATECIF, szMsg, countof(szMsg));
            MessageBox(hDlg, szMsg, szTitle, MB_ICONERROR);
        }
    }
    else
        DownloadErrMsg(hDlg, TEXT("IEUPDATE.CAB"), MAKEINTRESOURCE(IDD_DOWNLOADERR));
    
    if (SUCCEEDED(hrCom))
        CoUninitialize();
    return (0 < count) ? SHOW_UPDATES : DONT_SHOW_UPDATES;
}

BOOL CALLBACK FindUpdateDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(wParam);

    HWND* phDlg;

    switch (iMsg)
    {
        case WM_INITDIALOG:
            phDlg = (HWND*)lParam;
            if (NULL != phDlg) {
                ASSERT(NULL == *phDlg);
                *phDlg = hDlg;
            }
            break;

        default:
            return FALSE; 
    }

    return TRUE;
}

DWORD UpdateDlg_InitDialog(HWND hDlg, LPTSTR ps_szFreeSpace, LPTSTR ps_szTotalSize)
{
    HWND   hFindUpdateDlg;
    HANDLE hAVSThread;
    DWORD  dwResult, dwThread;
  
    hAVSThread = CreateThread(NULL, 4096, InitUpdateThreadProc, hDlg, 0, &dwThread);
    if (NULL == hAVSThread) {
        return 0;
    } 

    hFindUpdateDlg = CreateDialog(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_FINDUPDATE), hDlg, (DLGPROC)FindUpdateDlgProc);
    ShowWindow(hFindUpdateDlg, SW_SHOWNORMAL);

    while (WAIT_OBJECT_0 != MsgWaitForMultipleObjects(1, &hAVSThread, FALSE, INFINITE, QS_ALLINPUT))
    {
        MSG msg;

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    DestroyWindow(hFindUpdateDlg);

    GetExitCodeThread(hAVSThread, &dwResult);
    if (DONT_SHOW_UPDATES == dwResult) {
        TCHAR szMsg[MAX_PATH], szTitle[MAX_PATH];

        LoadString(g_rvInfo.hInst, IDS_AVSNOUPDATES, szMsg, countof(szMsg));
        LoadString(g_rvInfo.hInst, IDS_NOUPDATETITLE, szTitle, countof(szTitle));
        MessageBox(hDlg, szMsg, szTitle, MB_OK);

        EndDialog(hDlg, IDCANCEL);
    }
                           //--- Set initial Disk space displays -----
    InsertCommas(ps_szFreeSpace);
    SetDlgItemText(hDlg, IDC_DISKSPACE, ps_szFreeSpace);
    ShowDlgItem(hDlg, IDC_DISKSPACE);
    UpdateDlg_GetDownloadSize(GetDlgItem(hDlg, IDC_COMPLIST), GetDlgItem(hDlg, IDC_DISKSPACENEEDED), TRUE);
    GetDlgItemText(hDlg, IDC_DISKSPACENEEDED, ps_szTotalSize, MAX_PATH);
    ShowDlgItem(hDlg, IDC_DISKSPACENEEDED);
    ShowDlgItem(hDlg, IDC_DISKSPACETEXT);
    
    DisableDlgItem(hDlg, IDOK);            //---- Can't synchronize with nothing selected.

    return 0;
}

PCOMPONENT* UpdateDlg_GetDownloadList(HWND hDlg)
{
    HWND        hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
    PCOMPONENT* rgpComp,
                pComp;
    UINT        cSelected,
                i, j;

    cSelected = ListView_GetSelectedCount(hCompList);
    if (0 == cSelected)
        return NULL;

    rgpComp = (PCOMPONENT*)LocalAlloc(LPTR, (1 + cSelected) * sizeof(PCOMPONENT));
    if (NULL == rgpComp)
        return NULL;
    ZeroMemory(rgpComp, (1 + cSelected) * sizeof(PCOMPONENT));

    for (i = j = 0; i < (UINT) ListView_GetItemCount(hCompList); i++)
    {
        LVITEM lvi;

        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask      = LVIF_STATE | LVIF_PARAM;
        lvi.stateMask = LVIS_SELECTED;
        lvi.iItem     = i;
        ListView_GetItem(hCompList, &lvi);

        pComp = (PCOMPONENT)lvi.lParam;
        if (0 != (LVIS_SELECTED & lvi.state))
            rgpComp[j++] = pComp;

        else
            LocalFree(pComp);
    }
    ASSERT(j == cSelected);
    rgpComp[j] = NULL;

    return rgpComp;
}

void UpdateDlg_GetDownloadSize(HWND hCompList, HWND hStatusField, BOOL fAll)
{
    int        i;
    DWORD      dwSize = 0;
    TCHAR      szSize[32];
    PCOMPONENT pComp;

    for (i=0; i < ListView_GetItemCount(hCompList); i++)
    {
        LVITEM lvi;

        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask      = LVIF_STATE | LVIF_PARAM;
        lvi.stateMask = LVIS_SELECTED;
        lvi.iItem     = i;
        ListView_GetItem(hCompList, &lvi);
        
        if ((!fAll) && ((lvi.state & LVIS_SELECTED) == 0))
            continue;

        pComp = (PCOMPONENT) lvi.lParam;
        dwSize += pComp->dwSize;
    }
    wnsprintf(szSize, countof(szSize), TEXT("%lu KB"), dwSize);
    InsertCommas(szSize);
    SetWindowText(hStatusField, szSize);
}

LRESULT CALLBACK HyperLinkWndProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR       szText[30];
    PAINTSTRUCT ps;
    HDC         hdc;
    LOGFONT     lfNew, lf;
    HFONT       hfCurrent, hfLink;
    int         len;

    switch (iMsg)
    {
        case WM_PAINT:
            ZeroMemory(szText, sizeof(szText));
            GetWindowText(hDlg, szText, sizeof(szText));
            hdc = BeginPaint(hDlg, &ps);
 
            hfCurrent = (HFONT) GetCurrentObject(hdc, OBJ_FONT);    
            ASSERT(hfCurrent != NULL);    
    
            len = GetObject(hfCurrent, sizeof(lf), &lf);    
            ASSERT(len == sizeof(lf));        
        
            ZeroMemory(&lfNew, sizeof(lfNew));        
            lfNew.lfHeight    = (LONG) 13;
            lfNew.lfUnderline = TRUE;    
            lfNew.lfWeight    = FW_NORMAL;
            StrCpy(lfNew.lfFaceName, TEXT("Tahoma"));
            hfLink = CreateFontIndirect(&lfNew);

            SelectObject(hdc, hfLink);
            SetBkColor(hdc, GetSysColor(COLOR_MENU));
            SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHT));

            TextOut(hdc, 0, 0, szText, StrLen(szText));
            
            DeleteObject(SelectObject(hdc, GetStockObject(OBJ_FONT)));
            DeleteDC(hdc);
            EndPaint(hDlg, &ps); 
            return 0;
        case WM_KEYUP:
            if (wParam != VK_SPACE)
                break;
        case WM_LBUTTONUP:
            SendMessage(GetParent(hDlg), WM_COMMAND, GetWindowLong(hDlg, GWL_ID), (LPARAM) hDlg);
            return 0;
    }
    return DefWindowProc(hDlg, iMsg, wParam, lParam);
}

BOOL CALLBACK UpdateDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    static   PCOMPONENT** s_ppCompList; /*= NULL*/
    HWND     hCompList;
    static   TCHAR s_szFreeSpace[MAX_PATH];
    static   TCHAR s_szTotalSize[MAX_PATH];
    static   HFONT hfLink;
    
    switch (iMsg)
    {
        case WM_INITDIALOG:
            wnsprintf(s_szFreeSpace, countof(s_szFreeSpace), TEXT("%lu KB"), GetRootFree(g_szIEAKProg));
            UpdateDlg_InitDialog(hDlg, s_szFreeSpace, s_szTotalSize);
            s_ppCompList = (PCOMPONENT**)lParam;                    //--- Keep pointer to download list
            ASSERT(NULL != s_ppCompList);
            break;

        case IDM_INITIALIZE:
            break;

        case WM_COMMAND:
            if (BN_CLICKED != GET_WM_COMMAND_CMD(wParam, lParam))
                return FALSE;

            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    *s_ppCompList = UpdateDlg_GetDownloadList(hDlg); //--- Set download list
                case IDCANCEL:
                    EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                    break;
                case IDHELP:
                    ListView_SetItemState(GetDlgItem(hDlg, IDC_COMPLIST), -1, 0, LVIS_SELECTED);
                    IeakPageHelp(hDlg, MAKEINTRESOURCE(IDD_OPTUPDATE));
                    break;
                case IDC_DOWNLOADALL:
                    hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
                    SetFocus(hCompList);
                    ListView_SetItemState(hCompList, -1, LVIS_SELECTED, LVIS_SELECTED);
                    break;
 //-----------------     IEAK Site here Take out link for now since it doesn't work with build lab------------
 //-----------------     also need to uncomment CreateIEAKUrl in ie4comp.cpp and the comments     ------------
 //-----------------     for the control in ieakui\wizard.rc (IDD_OPTUPDATE) to activate          ------------
 //               case IDC_DIALOGLINK:
 //                   ShellExecute(hDlg, TEXT("open"), TEXT("http://www.microsoft.com/isapi/Redir.dll?prd=ieak&ar=ieak"), 
 //                       NULL, NULL, SW_SHOWNORMAL); 
                    break;
                default:
                    return FALSE;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
            {
              case LVN_ITEMCHANGED:
                hCompList = GetDlgItem(hDlg, IDC_COMPLIST);
                if (0 < ListView_GetSelectedCount(hCompList))
                {
                    HideDlgItem(hDlg, IDC_DISKSPACETEXT);
                    UpdateDlg_GetDownloadSize(hCompList, GetDlgItem(hDlg, IDC_DISKSPACENEEDED), FALSE);
                    ShowDlgItem(hDlg, IDC_DISKSPACETEXT2);
                    EnableDlgItem(hDlg, IDOK);
                }
                else
                {
                    ShowDlgItem(hDlg, IDC_DISKSPACETEXT);
                    HideDlgItem(hDlg, IDC_DISKSPACETEXT2);
                    SetDlgItemText(hDlg, IDC_DISKSPACENEEDED, s_szTotalSize);
                    DisableDlgItem(hDlg, IDOK);
                }
                break;
           
            default:
                return FALSE;
            }
            break; 

        case WM_HELP:
            ListView_SetItemState(GetDlgItem(hDlg, IDC_COMPLIST), -1, 0, LVIS_SELECTED);
            IeakPageHelp(hDlg, MAKEINTRESOURCE(IDD_OPTUPDATE));
            break;

        default:
            return FALSE; 
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\utils.cpp ===
#include "precomp.h"
#include "utils.h"

#define MAX_FILES 700

extern void UpdateProgress(int);

DWORD FolderSize(LPCTSTR pszFolderName)
{
    DWORD dwSize = 0;
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;
    TCHAR szFile[MAX_PATH];

    if (pszFolderName == NULL  ||  ISNULL(pszFolderName))
        return dwSize;

    PathCombine(szFile, pszFolderName, TEXT("*"));

    if ((hFindFile = FindFirstFile(szFile, &fileData)) != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                dwSize += fileData.nFileSizeLow;
        } while (FindNextFile(hFindFile, &fileData));

        FindClose(hFindFile);
    }

    return dwSize;
}

HRESULT MySHFileOperation(SHFILEOPSTRUCT &shfStruc, LPDWORD lpdwSizeArray,
                          DWORD dwTotalSize, DWORD dwTicks)
{
    LPCTSTR pFrom;
    LPTSTR pTo;
    TCHAR szTo[MAX_PATH];
    DWORD dwBytesCopied = 0;
    DWORD dwTickInterval = 0;
    DWORD dwIndex = 0;
    int i;

    // create the directory(we assume all files are being copied to the same dir here)

    PathCreatePath(shfStruc.pTo);

    if (dwTicks)
    {
        dwIndex = 1;

        // round up on the update interval

        dwTickInterval = dwTotalSize / dwTicks +
            ((dwTotalSize % dwTicks == 0) ? 0 : 1);
    }

    StrCpy(szTo, shfStruc.pTo);
    PathAddBackslash(szTo);
    pTo = szTo + StrLen(szTo);
    for (pFrom = shfStruc.pFrom, i = 0; *pFrom; pFrom += StrLen(pFrom) + 1, i++)
    {
        StrCpy(pTo, PathFindFileName(pFrom));
        // set the file_normal attribute so we can overwrite existing files
        SetFileAttributes(szTo, FILE_ATTRIBUTE_NORMAL);

        if (!CopyFile(pFrom, szTo, FALSE))
            return E_FAIL;
        if (dwTicks)
        {
            dwBytesCopied += lpdwSizeArray[i];
            if (dwBytesCopied > (dwTickInterval * dwIndex))
            {
                dwIndex++;
                UpdateProgress(1);
            }
        }
    }

    if (dwTicks)
        UpdateProgress(1);
    return S_OK;
}

HRESULT CopyFilesSrcToDest(LPCTSTR pszSrcPath, LPCTSTR pszSrcFilter, LPCTSTR pszDestPath,
                           DWORD dwTicks /* = 0 */)
{
    HANDLE hFind;
    WIN32_FIND_DATA wfdFind;
    TCHAR szSrcFile[MAX_PATH];
    DWORD dwTotalSize = 0;
    LPTSTR lpszFrom;
    LPDWORD lpdwSize = NULL;
    int nFrom = 0;
    int nFiles = 0;
    HRESULT res = S_OK;
    SHFILEOPSTRUCT shfStruc;

    if(ISNULL(pszSrcPath))
        return S_OK;

    lpszFrom = (LPTSTR) LocalAlloc(LPTR, MAX_BUFFER_SIZE*sizeof(TCHAR));
    if (!lpszFrom)
        return E_FAIL;

    if (dwTicks)
    {
        lpdwSize = (LPDWORD) LocalAlloc(LPTR, MAX_FILES * sizeof(DWORD));
        if (!lpdwSize)
        {
            LocalFree(lpszFrom);
            return E_FAIL;
        }
    }

    ZeroMemory(&shfStruc, sizeof(shfStruc));
    shfStruc.hwnd = g_hWizard;
    shfStruc.wFunc = FO_COPY;

    // remove the trailing backslash character
    TCHAR szBuffer[MAX_PATH];

    StrCpy(szBuffer, pszSrcPath);
    PathRemoveBackslash(szBuffer);
    pszSrcPath = szBuffer;

    PathCombine(szSrcFile, pszSrcPath, pszSrcFilter);
    hFind = FindFirstFile(szSrcFile, &wfdFind);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(wfdFind.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                && StrCmp(wfdFind.cFileName, TEXT("."))
                && StrCmp(wfdFind.cFileName, TEXT("..")))
            {
                PathCombine(szSrcFile, pszSrcPath, wfdFind.cFileName);
                if (((nFrom + lstrlen(szSrcFile) + 1) < MAX_BUFFER_SIZE) &&
                    ((!dwTicks) || (nFiles < MAX_FILES)))
                {
                    StrCpy(lpszFrom + nFrom, szSrcFile);
                    nFrom += lstrlen(szSrcFile) + 1;
                    if (dwTicks)
                    {
                        dwTotalSize += (lpdwSize[nFiles] = wfdFind.nFileSizeLow);
                        nFiles++;
                    }
                }
                else
                {
                    shfStruc.pFrom = lpszFrom;
                    shfStruc.pTo = pszDestPath;
                    shfStruc.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

                    res |= MySHFileOperation(shfStruc, lpdwSize, dwTotalSize, dwTicks);

                    ZeroMemory(lpszFrom, MAX_BUFFER_SIZE);
                    nFrom = 0;
                    dwTicks = 0;

                    StrCpy(lpszFrom + nFrom, szSrcFile);
                    nFrom += lstrlen(szSrcFile) + 1;
                }
            }
        }while (FindNextFile( hFind, &wfdFind));
        FindClose(hFind);

        if(ISNONNULL(lpszFrom))
        {
            shfStruc.pFrom = lpszFrom;
            shfStruc.pTo = pszDestPath;
            shfStruc.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

            res |= MySHFileOperation(shfStruc, lpdwSize, dwTotalSize, dwTicks);
        }
    }
    LocalFree(lpszFrom);
    if (dwTicks) LocalFree(lpdwSize);
    return res;
}

void TooBig(HWND hWnd, WORD id)
{
    TCHAR szTitle[MAX_PATH], szMsg[MAX_PATH];

    LoadString(g_rvInfo.hInst, IDS_TITLE, szTitle, countof(szTitle));
    LoadString(g_rvInfo.hInst, id, szMsg, countof(szMsg));

    MessageBox(hWnd, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
    SetWindowLongPtr(hWnd, DWLP_MSGRESULT, -1);
}

void SetWindowTextSmart(HWND hwnd, LPCTSTR pcszText)
{
    TCHAR szCurrentText[INTERNET_MAX_URL_LENGTH];

    if (GetWindowText(hwnd, szCurrentText, countof(szCurrentText)))
    {
        if (StrCmpI(pcszText, szCurrentText) == 0)
            return;
    }

    SetWindowText(hwnd, pcszText);
}

DWORD ShellExecAndWait(SHELLEXECUTEINFO shInfo)
{
    MSG msg;
    DWORD dwRet;

    if (!ShellExecuteEx(&shInfo))
        return (DWORD)E_FAIL;

    while (MsgWaitForMultipleObjects(1, &shInfo.hProcess, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    GetExitCodeProcess(shInfo.hProcess, &dwRet);
    CloseHandle(shInfo.hProcess);
    return dwRet;
}

// equivalent of c run time strtok

LPTSTR StrTok(LPTSTR pcszToken, LPCTSTR pcszDelimit)
{
    LPTSTR pszRet, pszCur;
    int i;

    pszCur = pcszToken;

    while (*pszCur)
    {
        i = 0;
        while(pcszDelimit[i])
        {
            if (*pszCur == pcszDelimit[i])
                break;
            i++;
        }
        if (!pcszDelimit[i])
            break;
        pszCur++;
    }

    pszRet = ((*pszCur) ? pszCur : NULL);

    if (pszRet != NULL)
    {
        while (*pszCur)
        {
            i = 0;
            while(pcszDelimit[i])
            {
                if (*pszCur == pcszDelimit[i])
                    break;
                i++;
            }
            if (pcszDelimit[i])
                break;
            pszCur++;
        }

        if(*pszCur)
            *pszCur = TEXT('\0');
    }

    return pszRet;
}

//**********************************************************************
// Automation HookIn : This function copies displayed item names from the
// LV into the Registry key "HKEY_LOCAL_MACHINE\Soft\MS\AutoTemp".
// Taken from setupwbv.cpp
//
//**********************************************************************

void LVGetItems(HWND hwndLV)
{
    LV_ITEM     lvi;
    DWORD       dwNumItems, dwIndex;
    HKEY        hKey;
    DWORD       dwDisp;
    TCHAR       szValueName[5];
    TCHAR       szDisplayName[MAX_PATH];
    BOOL        bOK = TRUE;
    LONG        lRet;

    dwNumItems = ListView_GetItemCount(hwndLV);

    // Create the new key. NOTE: Its volatile.
    lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\AutoTemp"), 0,
                          NULL, REG_OPTION_VOLATILE, KEY_READ|KEY_WRITE,
                          NULL, &hKey, &dwDisp);
    bOK = (lRet == ERROR_SUCCESS);
    if (bOK)
    {
        // If the key already existed, delete it so that old
        // data does not carry-over by mistake.
        if ( dwDisp == REG_OPENED_EXISTING_KEY )
        {
            RegCloseKey(hKey);
            RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\AutoTemp"));
            lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\AutoTemp"), 0,
                                  NULL, REG_OPTION_VOLATILE, KEY_READ|KEY_WRITE,
                                  NULL, &hKey, &dwDisp);
            bOK = (lRet == ERROR_SUCCESS);
        }

        if (bOK)
        {
            for (dwIndex=0; dwIndex < dwNumItems && bOK; dwIndex++)
            {
                lvi.mask = LVIF_TEXT;
                lvi.iItem = (int) dwIndex;
                lvi.iSubItem = 0;
                ZeroMemory(szDisplayName, sizeof(szDisplayName));
                lvi.pszText = szDisplayName;
                lvi.cchTextMax = countof(szDisplayName);
                ListView_GetItem(hwndLV, &lvi);

                // Write the Display name to the Registry.
                wnsprintf(szValueName, countof(szValueName), TEXT("%03d"), dwIndex);
                lRet = RegSetValueEx(hKey, szValueName, 0, REG_SZ,
                              (const BYTE *)szDisplayName, (lstrlen(szDisplayName)+1)*sizeof(TCHAR));

                bOK = (lRet == ERROR_SUCCESS);
            }

            // Write the number of values for the automation people to readout.
            RegSetValueEx(hKey, TEXT("Number"), 0, REG_DWORD,
                          (const BYTE *)&dwIndex, sizeof(dwIndex));

            // Close the Reg key.
            RegCloseKey(hKey);
        }
    }
}

LPTSTR GetOutputPlatformDir()
{
    static TCHAR s_szOutPlatform[MAX_PATH];

    if (ISNULL(s_szOutPlatform))
    {
        switch (g_dwPlatformId)
        {
        case PLATFORM_WIN32:
        default:
            StrCpy(s_szOutPlatform, TEXT("WIN32\\"));
            break;
        }
    }

    ASSERT(ISNONNULL(s_szOutPlatform));
    return s_szOutPlatform;
}

int GetRole(BOOL g_fBranded, BOOL g_fIntranet)
{
    int nRetVal = -1;

    if (g_fBranded == FALSE && g_fIntranet == FALSE)
        nRetVal = ROLE_ICP;
    else if (g_fBranded == TRUE && g_fIntranet == FALSE)
        nRetVal = ROLE_ISP;
    else if (g_fBranded == TRUE && g_fIntranet == TRUE)
        nRetVal = ROLE_CORP;
    else
        ASSERT(FALSE);

    return nRetVal;
}

// Loop thru Favorites/Links under the section FavoritesEx/URL and check if it has any associated icon file.
BOOL IsIconsInFavs(LPCTSTR pcszSection, LPCTSTR pcszCustIns)
{
    TCHAR szTemp[MAX_PATH];
    TCHAR szNameKey[MAX_PATH];
    TCHAR szIconKey[MAX_PATH];
    TCHAR szNameFormat[MAX_PATH];
    TCHAR szIconFormat[MAX_PATH];

    if (StrCmpI(pcszSection, IS_FAVORITESEX) == 0)
    {
        StrCpy(szNameFormat, IK_TITLE_FMT);
        StrCpy(szIconFormat, IK_ICON_FMT);
    }
    else // IS_URL
    {
        StrCpy(szNameFormat, IK_QUICKLINK_NAME);
        StrCpy(szIconFormat, IK_QUICKLINK_ICON);
    }

    for(int nCount = 1; ; nCount++)
    {
        wnsprintf(szNameKey, countof(szNameKey), szNameFormat, nCount);
        wnsprintf(szIconKey, countof(szIconKey), szIconFormat, nCount);
        
        if (GetPrivateProfileString(pcszSection, szNameKey, TEXT(""), szTemp, countof(szTemp), pcszCustIns) != 0)
        {
            if (GetPrivateProfileString(pcszSection, szIconKey, TEXT(""), szTemp, countof(szTemp), pcszCustIns) != 0)
                return TRUE;
        }
        else
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\filefind.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifdef _MAC
#error CFindFile is not supported on the Macintosh
#endif

#include "stdafx.h"
#include "filefind.h"

////////////////////////////////////////////////////////////////////////////
// CFindFile implementation

CFindFile::CFindFile()
{
	m_pFoundInfo = NULL;
	m_pNextInfo = NULL;
	m_hContext = NULL;
	m_chDirSeparator = '\\';
}

CFindFile::~CFindFile()
{
	Close();
}

void CFindFile::Close()
{
	if (m_pFoundInfo != NULL)
	{
		delete m_pFoundInfo;
		m_pFoundInfo = NULL;
	}

	if (m_pNextInfo != NULL)
	{
		delete m_pNextInfo;
		m_pNextInfo = NULL;
	}

	if (m_hContext != NULL && m_hContext != INVALID_HANDLE_VALUE)
	{
		CloseContext();
		m_hContext = NULL;
	}
}

void CFindFile::CloseContext()
{
	::FindClose(m_hContext);
	return;
}

BOOL CFindFile::FindFile(LPCTSTR pstrName /* = NULL */,
	DWORD dwUnused /* = 0 */)
{
	UNUSED_ALWAYS(dwUnused);
	Close();
	m_pNextInfo = new WIN32_FIND_DATA;
	m_bGotLast = FALSE;

	if (pstrName == NULL)
		pstrName = _T("*.*");
	_tcscpy(((WIN32_FIND_DATA*) m_pNextInfo)->cFileName, pstrName);

	m_hContext = ::FindFirstFile(pstrName, (WIN32_FIND_DATA*) m_pNextInfo);

	if (m_hContext == INVALID_HANDLE_VALUE)
	{
		DWORD dwTemp = ::GetLastError();
		Close();
		::SetLastError(dwTemp);
		return FALSE;
	}

	LPTSTR pstrRoot = m_strRoot.GetBufferSetLength(_MAX_PATH);
	LPCTSTR pstr = _tfullpath(pstrRoot, pstrName, _MAX_PATH);

	// passed name isn't a valid path but was found by the API
	ASSERT(pstr != NULL);
	if (pstr == NULL)
	{
		m_strRoot.ReleaseBuffer(-1);
		Close();
		::SetLastError(ERROR_INVALID_NAME);
		return FALSE;
	}
	else
	{
		// find the last forward or backward whack
		LPTSTR pstrBack  = _tcsrchr(pstrRoot, '\\');
		LPTSTR pstrFront = _tcsrchr(pstrRoot, '/');

		if (pstrFront != NULL || pstrBack != NULL)
		{
			if (pstrFront == NULL)
				pstrFront = pstrRoot;
			if (pstrBack == NULL)
				pstrBack = pstrRoot;

			// from the start to the last whack is the root

			if (pstrFront >= pstrBack)
				*pstrFront = '\0';
			else
				*pstrBack = '\0';
		}
		m_strRoot.ReleaseBuffer(-1);
	}

	return TRUE;
}

BOOL CFindFile::MatchesMask(DWORD dwMask) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
		return (!!(((LPWIN32_FIND_DATA) m_pFoundInfo)->dwFileAttributes & dwMask));
	else
		return FALSE;
}

BOOL CFindFile::GetLastAccessTime(FILETIME* pTimeStamp) const
{
	ASSERT(m_hContext != NULL);
	ASSERT(pTimeStamp != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL && pTimeStamp != NULL)
	{
		*pTimeStamp = ((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastAccessTime;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFindFile::GetLastWriteTime(FILETIME* pTimeStamp) const
{
	ASSERT(m_hContext != NULL);
	ASSERT(pTimeStamp != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL && pTimeStamp != NULL)
	{
		*pTimeStamp = ((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastWriteTime;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFindFile::GetCreationTime(FILETIME* pTimeStamp) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL && pTimeStamp != NULL)
	{
		*pTimeStamp = ((LPWIN32_FIND_DATA) m_pFoundInfo)->ftCreationTime;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFindFile::GetLastAccessTime(CTime& refTime) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
	{
		refTime = CTime(((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastAccessTime);
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFindFile::GetLastWriteTime(CTime& refTime) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
	{
		refTime = CTime(((LPWIN32_FIND_DATA) m_pFoundInfo)->ftLastWriteTime);
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFindFile::GetCreationTime(CTime& refTime) const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
	{
		refTime = CTime(((LPWIN32_FIND_DATA) m_pFoundInfo)->ftCreationTime);
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CFindFile::IsDots() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	// return TRUE if the file name is "." or ".." and
	// the file is a directory

	BOOL bResult = FALSE;
	if (m_pFoundInfo != NULL && IsDirectory())
	{
		LPWIN32_FIND_DATA pFindData = (LPWIN32_FIND_DATA) m_pFoundInfo;
		if (pFindData->cFileName[0] == '.')
		{
			if (pFindData->cFileName[1] == '\0' ||
				(pFindData->cFileName[1] == '.' &&
				 pFindData->cFileName[2] == '\0'))
			{
				bResult = TRUE;
			}
		}
	}

	return bResult;
}

BOOL CFindFile::FindNextFile()
{
	ASSERT(m_hContext != NULL);

	if (m_hContext == NULL)
		return FALSE;
	if (m_pFoundInfo == NULL)
		m_pFoundInfo = new WIN32_FIND_DATA;

	ASSERT_VALID(this);

	void* pTemp = m_pFoundInfo;
	m_pFoundInfo = m_pNextInfo;
	m_pNextInfo = pTemp;

	return ::FindNextFile(m_hContext, (LPWIN32_FIND_DATA) m_pNextInfo);
}

CString CFindFile::GetFileURL() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	CString strResult("file://");
	strResult += GetFilePath();
	return strResult;
}

CString CFindFile::GetRoot() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	return m_strRoot;
}

CString CFindFile::GetFilePath() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	CString strResult = m_strRoot;
	if (strResult[strResult.GetLength()-1] != '\\' &&
		strResult[strResult.GetLength()-1] != '/')
		strResult += m_chDirSeparator;
	strResult += GetFileName();
	return strResult;
}

CString CFindFile::GetFileTitle() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	CString strFullName = GetFileName();
	CString strResult;

	_tsplitpath(strFullName, NULL, NULL, strResult.GetBuffer(_MAX_PATH), NULL);
	strResult.ReleaseBuffer();
	return strResult;
}

CString CFindFile::GetFileName() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	CString ret;

	if (m_pFoundInfo != NULL)
		ret = ((LPWIN32_FIND_DATA) m_pFoundInfo)->cFileName;
	return ret;
}

DWORD CFindFile::GetLength() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
		return ((LPWIN32_FIND_DATA) m_pFoundInfo)->nFileSizeLow;
	else
		return 0;
}

#if defined(_X86_) || defined(_ALPHA_)
__int64 CFindFile::GetLength64() const
{
	ASSERT(m_hContext != NULL);
	ASSERT_VALID(this);

	if (m_pFoundInfo != NULL)
		return ((LPWIN32_FIND_DATA) m_pFoundInfo)->nFileSizeLow +
				(((LPWIN32_FIND_DATA) m_pFoundInfo)->nFileSizeHigh << 32);
	else
		return 0;
}
#endif

#ifdef _DEBUG
void CFindFile::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);
	dc << "\nm_hContext = " << (UINT) m_hContext;
}

void CFindFile::AssertValid() const
{
	// if you trip the ASSERT in the else side, you've called
	// a Get() function without having done at least one
	// FindNext() call

	if (m_hContext == NULL)
		ASSERT(m_pFoundInfo == NULL && m_pNextInfo == NULL);
	else
		ASSERT(m_pFoundInfo != NULL && m_pNextInfo != NULL);

}
#endif

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_DYNAMIC(CFindFile, CObject)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\wizard.h ===
#ifndef _WIZARD_H_
#define _WIZARD_H_

#pragma warning (disable:4189) // disable local var init'd but not ref'd warning since all
                               // occurences in the wizard have been removed.  Should be
                               // moved to warning.h in ..\inc when other modules have been
                               // fixed

// constants
#define MAX_BUF          5000
#define MAX_LINE          512
#define MAX_URL          2048
#define MAX_BUFFER_SIZE 32767
#define MAX_COPY_SIZE   32767

typedef enum tagPPAGE {
    PPAGE_WELCOME    = 0,
    PPAGE_OCWWELCOME = 0,

    PPAGE_STAGE1,
    PPAGE_TARGET,
    PPAGE_LANGUAGE,
    PPAGE_MEDIA,
    PPAGE_IEAKLITE,

    PPAGE_STAGE2,
    PPAGE_OPTDOWNLOAD,
    PPAGE_CUSTCOMP,

    PPAGE_STAGE3,
    PPAGE_ISKBACK,
    PPAGE_CDINFO,
    PPAGE_SETUPWIZARD,
    PPAGE_SILENTINSTALL,
    PPAGE_COMPSEL,
    PPAGE_COMPURLS,
    PPAGE_ADDON,
    PPAGE_INSTALLDIR,
    PPAGE_CORPCUSTOM,
    PPAGE_CUSTOMCUSTOM,
    PPAGE_COPYCOMP,
    PPAGE_ICM,
    PPAGE_CABSIGN,

    PPAGE_STAGE4,
    PPAGE_OCWSTAGE2,
    PPAGE_TITLE,
    PPAGE_BTOOLBARS,
    PPAGE_CUSTICON,
    PPAGE_STARTSEARCH,
    PPAGE_FAVORITES,
    PPAGE_WELCOMEMSGS,
    PPAGE_DESKTOP,
    PPAGE_DTOOLBARS,
    PPAGE_FOLDERMCCP,
    PPAGE_UASTRDLG,
    PPAGE_CONNECTSET,
    PPAGE_QUERYAUTOCONFIG,
    PPAGE_PROXY,
    PPAGE_ADDROOT,
    PPAGE_SECURITYCERT,
    PPAGE_SECURITY,

    PPAGE_QUERYSIGNUP,
    PPAGE_SIGNUPFILES,
    PPAGE_SERVERISPS,
    PPAGE_ISPINS,
    PPAGE_ICW,

    PPAGE_STAGE5,
    PPAGE_PROGRAMS,
    PPAGE_MAIL,
    PPAGE_IMAP,
    PPAGE_OE,
    PPAGE_PRECONFIG,
    PPAGE_OEVIEW,
    PPAGE_SIG,
    PPAGE_LDAP,
    PPAGE_ADMDESC,
    PPAGE_ADM,
    PPAGE_STATUS,
    PPAGE_FINISH
};

#define NUM_PAGES   PPAGE_FINISH + 1

// typedefs
typedef struct tagREVIEWINFO
{
    HINSTANCE hInst;                            // instance handel of the resource dll
    HINSTANCE hinstExe;                         // instance handle of this executable

    TCHAR pszName[MAX_PATH];
} REVIEWINFO;

// Function prototypes

// procs
LRESULT APIENTRY MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY About(HWND, UINT, WPARAM, LPARAM);

// Pages for Wizard
BOOL APIENTRY OptionalDownload(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK DownloadStatusDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY CustomComponents(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY CertificatePick(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY ComponentSelect(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY CorpCustomizeCustom(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY CustomizeCustom(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY CopyComp(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY ComponentUrls(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK CabSignDlgProc(HWND, UINT, WPARAM, LPARAM );
BOOL APIENTRY CustIcon(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY Favorites(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK QueryAutoConfigDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY ProxySettings(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ConnectSetDlgProc(HWND, UINT, WPARAM, LPARAM);

BOOL CALLBACK QuerySignupDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK SignupFilesDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ServerIspsDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK SignupInsDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK NewICWDlgProc(HWND, UINT, WPARAM, LPARAM);

BOOL CALLBACK ProgramsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

BOOL CALLBACK MailServer(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK IMAPSettings(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK LDAPServer(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK CustomizeOE(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK Signature(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK ViewSettings(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK PreConfigSettings(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

BOOL CALLBACK WelcomeMessageDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY InstallDirectory(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY CustUserSettings(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK SecurityZonesDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK SecurityCertsDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ISPAddRootCertDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ActiveSetupDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK BToolbarProc(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY DesktopAddOneComp(HWND,UINT, WPARAM, LPARAM);
BOOL APIENTRY UserAgentString(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY ADMDesc(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY ADMParse(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY InternetConnMgr(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY CustomCompName(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK AddOnDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY SilentInstall(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY AddEditChannel(HWND, UINT, WPARAM, LPARAM);
DWORD DownloadSiteThreadProc(LPVOID);
BOOL CALLBACK MediaDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY TargetProc(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY IEAKLiteProc(HWND, UINT, WPARAM, LPARAM);


//functions
BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE);
int  CreateWizard(HWND);
void FillInPropertyPage( int , int, LPTSTR, DLGPROC);
void GenerateReview(HWND);
void StatusDialog(UINT);

void DoBatchAdvance(HWND hDlg);
BOOL IeakPageHelp(HWND, LPCTSTR pszData);
void EnablePages();
BOOL PageEnabled(int iPage);
void PagePrev(HWND hDlg);
void PageNext(HWND hDlg);
void DoCancel();
BOOL QueryCancel(HWND hDlg);
void CheckBatchAdvance(HWND hDlg);

BOOL ADMEnablePage(); // admwizpg.cpp
void SetBannerText(HWND hDlg);
void ChangeBannerText(HWND hDlg);

// definitions for StatusDialog( )
#define SD_STEP1    1
#define SD_STEP2    2

typedef struct tagISKINFO
{
    TCHAR szISKBackBitmap[MAX_PATH];
    TCHAR szISKTitleBar[128];
    TCHAR szISKBtnBitmap[MAX_PATH];
    DWORD dwNormalColor;
    DWORD dwHighlightColor;
    DWORD dwNIndex;
    DWORD dwHIndex;
    BOOL fCoolButtons;
} ISKINFO;

BOOL APIENTRY ISKBackBitmap(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY CDInfoProc(HWND, UINT, WPARAM, LPARAM);


#define SIGTYPE_TEXT 1
#define SIGTYPE_FILE 2


#define SIGFLAG_OUTGOING 0x10000
#define SIGFLAG_REPLY 0x20000


// Automation HookIn
#define WM_LV_GETITEMS  WM_USER+21

#define IDM_WIZARD         WM_USER + 3000
#define IDM_LAST           WM_USER + 3001
#define IDM_EXIT           WM_USER + 3002
#define IDM_INITIALIZE     WM_USER + 3003
#define IDM_BATCHADVANCE   WM_USER + 3004
#define IDM_SETDEFBUTTON   WM_USER + 3005
#define IDM_ERROR          WM_USER + 3006

#define NUMLANG 100

#define DOWN_STATE_IDLE 0
#define DOWN_STATE_ENUM_LANG 1
#define DOWN_STATE_ENUM_URL 2
#define DOWN_STATE_SAVE_URL 3

#define KEY_TYPE_STANDARD 0                // old MS mode still used for current MS builds
#define KEY_TYPE_ENHANCED 1                // old code now unused
#define KEY_TYPE_SUPER    2                // isp
#define KEY_TYPE_CORP     3                // old code now unused
#define KEY_TYPE_SUPERCORP 4               // corp

#define MAX_INSTALL_OPTS 10

typedef struct patch_info
{
    DWORD dwSize;
    TCHAR szVersion[32];
    TCHAR szSection[32];
} PATCHINFO, *PPATCHINFO;

typedef struct tag_component
{
    int iList;
    DWORD dwSize;
    int iType;
    int iImage;
    int iPlatform;
    int iCompType;
    int iInstallType;         // 0=after IE, 1=before IE, 2=after reboot
    BOOL fVisible;
    BOOL fAddOnOnly;
    BOOL fCustomHide;
    BOOL fNoCopy;
    BOOL fAVSDupe;
    BOOL fIEDependency;
    PATCHINFO piPatchInfo;
    BOOL afInstall[MAX_INSTALL_OPTS];
    TCHAR szDisplayName[80];
    TCHAR szSection[32];
    LPTSTR pszAVSDupeSections;
    TCHAR szCommand[32];
    TCHAR szUrl[80];
    TCHAR szGUID[64];
    TCHAR szSwitches[80];
    TCHAR szUninstall[80];
    TCHAR szVersion[32];
    TCHAR szModes[80];
    TCHAR szPath[MAX_PATH];
    TCHAR szDesc[512];
    tag_component * paCompRevDeps[10];
} COMPONENT, *PCOMPONENT;

extern REVIEWINFO g_rvInfo;
extern DWORD      g_dwPlatformId;
extern BOOL       g_fUseShortFileName;
extern HWND       g_hWizard;

extern CCifRWFile_t *g_lpCifRWFile;
extern CCifFile_t   *g_lpCifFileNew;
extern CCifRWFile_t *g_lpCifRWFileDest;
extern CCifRWFile_t *g_lpCifRWFileVer;

// ProcessINSFiles flags
#define PINSF_DEFAULT   0x00
#define PINSF_DELETE    0x01
#define PINSF_COPY      0x02
#define PINSF_APPLY     0x04
#define PINSF_COPYCAB   0x08
#define PINSF_FIXINS    0x10
#define PINSF_NOCLEAR   0x20

DWORD ProcessINSFiles(LPCTSTR pcszDir, DWORD dwFlags, LPCTSTR pcszOutDir);
#define GetNumberOfINSFiles(d)          (ProcessINSFiles((d), PINSF_DEFAULT, NULL))
#define DeleteINSFiles(d)               (ProcessINSFiles((d), PINSF_DELETE,  NULL))
#define CopyINSFiles(d, o)              (ProcessINSFiles((d), PINSF_COPY,    (o)))
#define ApplyINSFiles(d, i)             (ProcessINSFiles((d), PINSF_APPLY,   (i)))
#define CopyCabFiles(d, c)              (ProcessINSFiles((d), PINSF_COPYCAB, (c)))
#define FixINSFiles(d)                  (ProcessINSFiles((d), PINSF_FIXINS,  NULL))
#define WriteNoClearToINSFiles(d)       (ProcessINSFiles((d), PINSF_NOCLEAR, NULL))


// ADM constants
#define IS_ADM      TEXT("ADM")
#define IK_ADMIN    TEXT("Admin")

#define POSTCUSTITEMS   TEXT("PostCustItems")
#define URDCOMP         TEXT("URD")
#define IE55URD_EXE     TEXT("ie55urd.exe")
#define URD_GUID_STR    TEXT("{71F159B0-139A-4555-BE78-D728734BB5D4}")
#define IK_URD_STR      URD_GUID_STR

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\msie.h ===
#if !defined(AFX_MSIE_H__25959BF4_E700_11D2_A7AF_00C04F806200__INCLUDED_)
#define AFX_MSIE_H__25959BF4_E700_11D2_A7AF_00C04F806200__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Msie.h : main header file for MSIE.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#include "msiedata.h"
#include <ras.h>
#include <wincrypt.h>

/////////////////////////////////////////////////////////////////////////////
// CMsieApp : See Msie.cpp for implementation.

class CMsieApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();

	DWORD AppGetTemplate(void ** ppBuffer);
	void AppGetIEData(IEDataType enType, long *lCount, void ***pppIEData, long *pCancel = NULL);
	void AppDeleteIEData(IEDataType enType, long lCount, void **ppIEData);

private:
	void LoadTemplate();
	CString GetBooleanString(BOOL bValue, int nType = 0);
	CString ConvertIPAddressToString(RASIPADDR ipaddr);
	void GetRegValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszName, COleVariant &vtData);
	long GetRegValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszName, DWORD &dwData);
	long GetRegValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszName, CString &strData);
	CString GetLongPathName(LPCTSTR pszShortPath);
	DWORD GetDirSize(LPCTSTR pszFolder);
	CString GetFileVersion(LPCTSTR pszFileName);
	CString GetFileCompany(LPCTSTR pszFileName);
	DWORD GetCipherStrength();
	void GetCertificateInfo(PCCERT_CONTEXT pContext, int idsType, CPtrArray& ptrs);
	void GetPersonalCertificates(CPtrArray& ptrs);
	void GetOtherPeopleCertificates(CPtrArray& ptrs);

	bool m_bRunningOnNT;
	bool m_bRunningOnNT5OrHigher;

	BOOL m_fTemplateLoaded;
	unsigned char *m_pTemplateInfo;
	DWORD m_dwTemplateInfoLen;
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
extern CMsieApp theApp;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSIE_H__25959BF4_E700_11D2_A7AF_00C04F806200__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieak5\wizard\wizard.cpp ===
#include "precomp.h"
#include <htmlhelp.h>                           // for html help calls
#include <regstr.h>
#include "wizard.rcv"                           // for VER_PRODUCTVERSION_STR only
#include "adjustui.h"
#include "ieaklite.h"
#include "ie4comp.h"

CCabMappings g_cmCabMappings;
REVIEWINFO g_rvInfo;      // a structure containing the review information
HWND g_hWizard;
TCHAR g_szCustIns[MAX_PATH] = TEXT("");
TCHAR g_szSrcRoot[MAX_PATH] = TEXT(""); //Batch mode only: use settings in g_szSrcRoot to build package in g_szBuildRoot.
TCHAR g_szBuildRoot[MAX_PATH] = TEXT("");
TCHAR g_szBuildTemp[MAX_PATH] = TEXT("");
TCHAR g_szWizPath[MAX_PATH];
TCHAR g_szWizRoot[MAX_PATH];
TCHAR g_szTitle[MAX_PATH];
TCHAR g_szLogFile[MAX_PATH] = TEXT("");
HANDLE g_hLogFile = NULL;   //Logfile handle;

extern TCHAR g_szDefInf[];
extern TCHAR g_szTempSign[];
BOOL g_fDownload = TRUE;
BOOL g_fCD = FALSE;
BOOL g_fLAN = FALSE;
BOOL g_fBrandingOnly = FALSE;
BOOL g_fBranded = FALSE;
BOOL g_fIntranet = FALSE;
BOOL g_fMailNews95 = FALSE;
BOOL g_fLangInit = FALSE;
BOOL g_fSrcDirChanged = TRUE;
static BOOL s_fDestDirChanged = TRUE;
BOOL g_fDisableIMAPPage = FALSE;
extern TCHAR g_szDeskTemp[];
extern int g_iInstallOpt;
extern TCHAR g_szInstallFolder[];
extern TCHAR   s_szBannerText[MAX_PATH];

HANDLE g_hThread = NULL;   // handle to DownloadSiteThreadProc
extern HANDLE g_hAVSThread;
extern BOOL g_fOptCompInit;
BOOL g_fCancelled = FALSE;
BOOL g_fDone = FALSE;
BOOL g_fKeyGood = FALSE;

static BOOL s_fNT5;

int g_iKeyType = KEY_TYPE_STANDARD;
TCHAR g_szKey[16] ;

extern int MakeKey(TCHAR *, int);
PROPSHEETPAGE g_psp[NUM_PAGES];
static HPROPSHEETPAGE s_ahPsp[NUM_PAGES];
static BOOL s_fPageEnabled[NUM_PAGES] =
{
    TRUE, TRUE, TRUE, TRUE
};
int g_iCurPage;

RECT g_dtRect;

TCHAR g_szLanguage[16];
extern TCHAR g_szActLang[];

TCHAR g_aszLang[NUMLANG][16];
DWORD g_aLangId[NUMLANG];

BOOL g_fDemo = FALSE;

#define MAX_STDOPT 5
#define MIN_CUSTOPT 6
#define MAX_CUSTOPT 7
#define OPT_CUST1 6
#define OPT_CUST2 7

extern BOOL  CheckKey(LPTSTR szKey);
static HKEY s_hkIEAKUser;

BOOL g_fUseIEWelcomePage = FALSE;
static TCHAR s_szSourceDir[MAX_PATH] = TEXT("");
TCHAR g_szLoadedIns[MAX_PATH] = TEXT("");
static BOOL s_fLoadIns;

static BOOL s_fAppendLang;
BOOL g_fBatch = FALSE;
BOOL g_fBatch2 = FALSE; //The second batch mode
static TCHAR s_szType[16];
int s_iType;

extern BOOL g_fServerICW;
extern BOOL g_fServerKiosk;
extern BOOL g_fServerless;
extern BOOL g_fNoSignup;
extern BOOL g_fSkipServerIsps;
extern BOOL g_fSkipIspIns;

extern HANDLE g_hDownloadEvent;
int g_iDownloadState = 0, g_nLangs = 0;
HWND g_hDlg = 0;

extern void IE4BatchSetup(void);
extern BOOL InitList(HWND hwnd, UINT id);

extern BOOL g_fSilent, g_fStealth;
extern BOOL g_fUrlsInit;
extern BOOL g_fLocalMode;
extern BOOL g_fInteg, g_fImportConnect;
extern PCOMPONENT g_paComp;
extern UINT g_uiNumCabs;
extern PCOMP_VERSION g_rgCompVer;
extern HFONT g_hFont;

DWORD g_dwPlatformId = PLATFORM_WIN32;

// new cif format stuff

CCifFile_t   *g_lpCifFileNew = NULL;
CCifRWFile_t *g_lpCifRWFile = NULL;
CCifRWFile_t *g_lpCifRWFileDest = NULL;
CCifRWFile_t *g_lpCifRWFileVer = NULL;

// g_hBaseDllHandle is used by DelayLoadFailureHook() -- defined in ieakutil.lib
// for more info, read the Notes section in ieak5\ieakutil\dload.cpp
HANDLE  g_hBaseDllHandle;

//OCW specific
BOOL g_fOCW = FALSE;
BOOL g_fOCWCancel = FALSE;
TCHAR g_szParentWindowName[MAX_PATH];

BOOL ParseCmdLine(LPSTR lpCmdLine);
void PositionWindow(HWND hWnd);
//
extern TCHAR g_szIEAKProg[MAX_PATH];
void GetIEAKDir(LPTSTR szDir);

extern HBITMAP g_hBannerBmp;
extern HWND g_hWait;
extern LPTSTR GetOutputPlatformDir();
void GenerateCustomIns();

extern void WriteMSTrustKey(BOOL bSet);
DWORD g_wCurLang;

static HWND s_hWndHelp = NULL;

void CleanUp()
{
    if (g_hAVSThread != NULL)
    {
        while ((MsgWaitForMultipleObjects(1, &g_hAVSThread, FALSE, INFINITE, QS_ALLINPUT)) != WAIT_OBJECT_0)
        {
            MSG msg;

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        CloseHandle(g_hAVSThread);
    }

    if (g_hThread != NULL)
    {
        while ((MsgWaitForMultipleObjects(1, &g_hThread, FALSE, INFINITE, QS_ALLINPUT)) != WAIT_OBJECT_0)
        {
            MSG msg;

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        CloseHandle(g_hThread);
    }

    if (g_paComp != NULL)
    {
        for (PCOMPONENT pComp = g_paComp; ISNONNULL(pComp->szSection); pComp++)
        {
            if (pComp->pszAVSDupeSections != NULL)
                CoTaskMemFree(pComp->pszAVSDupeSections);
        }
        LocalFree(g_paComp);
    }

    if (g_rgCompVer)
    {
        LocalFree(g_rgCompVer);
    } 

    if (g_hFont != NULL) DeleteObject(g_hFont);

    if (g_lpCifRWFile != NULL)
    {
        delete g_lpCifRWFile;
        g_lpCifRWFile = NULL;
    }

    if (g_lpCifFileNew != NULL)
    {
        delete g_lpCifFileNew;
        g_lpCifFileNew = NULL;
    }

    if (g_lpCifRWFileDest != NULL)
    {
        delete g_lpCifRWFileDest;
        g_lpCifRWFileDest = NULL;
    }

    if (g_lpCifRWFileVer != NULL)
    {
        delete g_lpCifRWFileVer;
        g_lpCifRWFileVer = NULL;
    }

    if (g_hBannerBmp != NULL)
        DeleteObject(g_hBannerBmp);

    if (ISNONNULL(g_szDeskTemp))
        PathRemovePath(g_szDeskTemp);
}

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPSTR pszCmdLine = GetCommandLineA();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR lpCmdLine, int)
{
    MSG     msg;
    HANDLE  hMutex;
    HRESULT hrOle;
    int     iRetVal;
    
    // initialize g_hBaseDllHandle which is used by DelayLoadFailureHook()
    // in ieak5\ieakutil\dload.cpp
    g_hBaseDllHandle = hInstance;

    hMutex = NULL;
    // allow only one instance running at a time, except for build lab batch mode
    // also if ie6 is not installed, bail out

    if (lpCmdLine  == NULL                  ||
        *lpCmdLine == '\0'                  ||
        StrCmpNIA(lpCmdLine, "/o", 2) == 0  ||
        StrCmpNIA(lpCmdLine, "/p", 2) == 0)
    {
        DWORD dwIEVer;

        hMutex = CreateMutex(NULL, TRUE, TEXT("IEAK6Wizard.Mutex"));
        if (hMutex != NULL  &&  GetLastError() == ERROR_ALREADY_EXISTS)
        {
            CloseHandle(hMutex);
            ErrorMessageBox(NULL, IDS_ERROR_MULTWIZ);
            return ERROR_CANCELLED;
        }

        dwIEVer = GetIEVersion();
        if (HIWORD(dwIEVer) < 6)
        {
            ErrorMessageBox(NULL, IDS_NOIE);
            return ERROR_CANCELLED;
        }
    }

    ZeroMemory(&g_rvInfo, sizeof(g_rvInfo));
    g_rvInfo.hinstExe = hInstance;
    g_rvInfo.hInst    = LoadLibrary(TEXT("ieakui.dll"));

    if (g_rvInfo.hInst == NULL)
        return ERROR_CANCELLED;

    // if the class registration fails, return.
    if (!InitApplication(hInstance))
    {
        FreeLibrary(g_rvInfo.hInst);
        return ERROR_CANCELLED;
    }

    SHCreateKeyHKCU(RK_IEAK_SERVER_MAIN, KEY_ALL_ACCESS, &s_hkIEAKUser);

    g_wCurLang = GetUserDefaultLCID() & 0xFFFF;
    s_fNT5   = IsOS(OS_NT5);

    hrOle = CoInitialize(NULL);

    GetIEAKDir(g_szWizPath);

    StrCpy(g_szWizRoot, g_szWizPath);
    CharUpper(g_szWizRoot);

    LoadString(g_rvInfo.hInst, IDS_TITLE, g_szTitle, countof(g_szTitle));

    //get the mode  -- NOTE: THIS MUST COME BEFORE PARSECMDLINE SO THAT COMMANDLINE OPTIONS OVERRIDE THE REG ENTRY!!!
    DWORD dwSize = sizeof(DWORD);
    if (SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\IEAK"), TEXT("Mode"), NULL, &s_iType, &dwSize) != ERROR_SUCCESS)
        s_iType = INTRANET; //if there is no reg entry, default to corp mode
    switch (s_iType)
    {
        case REDIST://icp
            StrCpy(s_szType, TEXT("REDIST"));
            g_fBranded = FALSE;
            g_iKeyType = KEY_TYPE_SUPER;
            g_fIntranet = g_fSilent = FALSE;
            break;

        case BRANDED://isp
            StrCpy(s_szType, TEXT("BRANDED"));
            g_fBranded = TRUE;
            g_iKeyType = KEY_TYPE_SUPER;
            g_fIntranet = g_fSilent = FALSE;
            break;

        case INTRANET:
        default:
            StrCpy(s_szType, TEXT("INTRANET"));
            g_iKeyType = KEY_TYPE_SUPERCORP;
            g_fBranded = TRUE;
            g_fIntranet = TRUE;
            break;
    }

    *g_szKey = TEXT('\0');
    if (lpCmdLine != NULL  &&  *lpCmdLine)
        if (!ParseCmdLine(lpCmdLine))
        {
            FreeLibrary(g_rvInfo.hInst);
            return ERROR_CANCELLED;
        }

    if (*g_szLogFile != 0 && (g_hLogFile = CreateFile(g_szLogFile, GENERIC_WRITE, 
                                                    FILE_SHARE_READ, NULL, OPEN_ALWAYS, 
                                                    FILE_ATTRIBUTE_NORMAL, NULL)) == NULL)
    {
        MessageBox(NULL, TEXT("Cannot open log file"), NULL, MB_OK);
        return ERROR_CANCELLED;
    }

    // Perform initializations that apply to a specific instance
    if (!InitInstance(hInstance))
    {
        FreeLibrary(g_rvInfo.hInst);
        return ERROR_CANCELLED;
    }

    // Acquire and dispatch messages until a WM_QUIT message is received.
    iRetVal = GetMessage(&msg, NULL, 0, 0);
    while (iRetVal != -1  &&  iRetVal != 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);

        iRetVal = GetMessage(&msg, NULL, 0, 0);
    }

    CleanUp();
    if (S_OK == hrOle)
        CoUninitialize();

    if (g_hLogFile)
        CloseHandle(g_hLogFile);


#ifdef DBG
    if (g_fBatch || g_fBatch2 || MessageBox(NULL, TEXT("OK to Delete Temp Files"), TEXT("Wizard Complete"), MB_YESNO) == IDYES)
#endif
        if (lstrlen(g_szBuildTemp))
            PathRemovePath(g_szBuildTemp);

    RegCloseKey(s_hkIEAKUser);
    WriteMSTrustKey(FALSE);      // Mark MS as a trusted provider

    if (s_hWndHelp != NULL)
        SendMessage(s_hWndHelp, WM_CLOSE, 0, 0L);

    FreeLibrary(g_rvInfo.hInst);

    if (hMutex != NULL)
        CloseHandle(hMutex);

    if (g_fOCWCancel)
        return ERROR_CANCELLED;

    return (int) msg.wParam;
}

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS wcSample;

    wcSample.style         = 0;
    wcSample.lpfnWndProc   = (WNDPROC) MainWndProc;
    wcSample.cbClsExtra    = 0;
    wcSample.cbWndExtra    = 0;
    wcSample.hInstance     = hInstance;
    wcSample.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WIZARD));
    wcSample.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcSample.hbrBackground = (HBRUSH) GetStockObject(GRAY_BRUSH);
    wcSample.lpszMenuName  = NULL;
    wcSample.lpszClassName = TEXT("SampleWClass");

    return RegisterClass(&wcSample);
}

BOOL ParseCmdLine(LPSTR lpCmdLine)
{
    TCHAR szCmdLine[MAX_PATH];
    LPTSTR pParam;
    TCHAR szWrkLang[8] = TEXT("en");
    HKEY hKey;
    DWORD dwSize;
    TCHAR szType[16]; //Mode: CORP(INTRANET), ICP(RETAIL) or ISP(BRANDED)

    *szType = TEXT('\0');     

    A2Tbux(lpCmdLine, szCmdLine);
    CharUpper(szCmdLine);

    pParam = szCmdLine;
    while (pParam != NULL)
    {
        pParam = StrChr(pParam, TEXT('/'));
        if (pParam == NULL)
            break;

        switch (*++pParam)
        {
            case TEXT('S'): // srcpath
                if ( *(pParam+2) == '\"' ) 
                {
                    pParam++; //skip the first quote, we don't want the quotes
                    StrCpyN(g_szSrcRoot, pParam + 2, countof(g_szSrcRoot));
                    StrTok(g_szSrcRoot, TEXT("\"\n\r\t"));  //instead of stopping w/ a space, stop w/ "
                }
                else
                {
                    StrCpyN(g_szSrcRoot, pParam + 2, countof(g_szSrcRoot));
                    StrTok(g_szSrcRoot, TEXT(" \n\r\t"));
                }
                pParam += StrLen(g_szSrcRoot);
                break;
                
            case TEXT('I'):
            case TEXT('D'):
                if ( *(pParam+2) == '\"' ) 
                {
                    pParam++; //skip the first quote, we don't want the quotes
                    StrCpyN(g_szBuildRoot, pParam + 2, countof(g_szBuildRoot));
                    StrTok(g_szBuildRoot, TEXT("\"\n\r\t"));  //instead of stopping w/ a space, stop w/ "
                }
                else
                {
                    StrCpyN(g_szBuildRoot, pParam + 2, countof(g_szBuildRoot));
                    StrTok(g_szBuildRoot, TEXT(" \n\r\t"));
                }
                pParam += StrLen(g_szBuildRoot);
                break;

            case TEXT('K'):
                StrCpyN(g_szKey, pParam + 2, countof(g_szKey));
                StrTok(g_szKey, TEXT(" \n\r\t"));
                pParam += StrLen(g_szKey);
                break;

            case TEXT('M'): // Mode: corp, isp or icp
                StrCpyN(szType, pParam + 2, countof(szType));
                StrTok(szType, TEXT(" \n\r\t"));
                pParam += StrLen(szType);
                break;

            case TEXT('Q'): // logfile
                if ( *(pParam+2) == '\"' ) 
                {
                    pParam++; //skip the first quote, we don't want the quotes
                    StrCpyN(g_szLogFile, pParam + 2, countof(g_szLogFile));
                    StrTok(g_szLogFile, TEXT("\"\n\r\t"));  //instead of stopping w/ a space, stop w/ "
                }
                else
                {
                    StrCpyN(g_szLogFile, pParam + 2, countof(g_szLogFile));
                    StrTok(g_szLogFile, TEXT(" \n\r\t"));
                }
                pParam += StrLen(g_szLogFile);
                break;

            case TEXT('L'):
                StrCpyN(szWrkLang, pParam + 2, 3);
                pParam += 3;
                break;

            case TEXT('O'):
                g_fOCW = TRUE;
                g_dwPlatformId = PLATFORM_WIN32;

                // (a-saship) read all the data from the registry from HKCU\Software\Microsoft\IEAK since
                // office reads/writes data from/to this location. This is due to the fact that IEAK5_5
                // changed the registry location to HKCU\Software\Microsoft\IEAK5_5 and office is not aware
                // of it. These values is only used by Office and hence we are safe here.
                if (RegOpenKeyEx(HKEY_CURRENT_USER, RK_IEAK, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
                {
                    dwSize = sizeof(g_szKey);
                    SHQueryValueEx(hKey, TEXT("KeyCode"), NULL, NULL, (LPVOID) g_szKey, &dwSize);

                    dwSize = sizeof(g_szIEAKProg);
                    SHQueryValueEx(hKey, TEXT("SourceDir"), NULL, NULL, (LPVOID) g_szIEAKProg, &dwSize);
                    if (*g_szIEAKProg)
                    {
                        PathAddBackslash(g_szIEAKProg);
                        StrCpy(s_szSourceDir, g_szIEAKProg);
                    }

                    dwSize = sizeof(g_szBuildRoot);
                    SHQueryValueEx(hKey, TEXT("TargetDir"), NULL, NULL, (LPVOID) g_szBuildRoot, &dwSize);
                    if (*g_szBuildRoot == TEXT('\0'))
                        StrCpy(g_szBuildRoot, g_szIEAKProg);
                    if (*g_szBuildRoot)
                        PathRemoveBackslash(g_szBuildRoot);

                    s_fAppendLang = TRUE;

                    dwSize = sizeof(g_szParentWindowName);
                    SHQueryValueEx(hKey, TEXT("ParentWindowName"), NULL, NULL, (LPVOID) g_szParentWindowName, &dwSize);

                    RegCloseKey(hKey);
                }
                break;
        }
    }

    *g_szLanguage = TEXT('\\');
    StrCpy(&g_szLanguage[1], szWrkLang);
    g_szLanguage[3] = TEXT('\\');
    g_szLanguage[4] = TEXT('\0');

    StrCpy(g_szActLang, szWrkLang);

    if ((*g_szKey != TEXT('\0')) && (!szType[0]))  //if they set a key, we should override the mode
    {
        CheckKey(g_szKey); 
        if (g_iKeyType == KEY_TYPE_SUPERCORP)
        {
            StrCpy(s_szType, TEXT("INTRANET"));
            StrCpy(szType, TEXT("CORP"));
        }
        else StrCpy(szType, TEXT("ICP"));
    }


/*  removed--this is really crappy validation code and also makes it impossible to have spaces in paths

    if (StrCmpN(g_szBuildRoot, TEXT("\\\\"), 2)  &&
        StrCmpN(&g_szBuildRoot[1], TEXT(":\\"), 2))
    {
        ErrorMessageBox(NULL, IDS_NEEDPATH);
        return FALSE;
    }
*/

    if (StrLen(g_szBuildRoot) <= 3)
    {
        ErrorMessageBox(NULL, IDS_ROOTILLEGAL);
        return FALSE;
    }

    if ((!PathIsDirectory(g_szBuildRoot)) && (!CreateDirectory(g_szBuildRoot,NULL)))
    {
        TCHAR szMsg[MAX_PATH];
        TCHAR szTemp[2 * MAX_PATH];

        LoadString(g_rvInfo.hInst, IDS_BADDIR, szMsg, countof(szMsg));
        wnsprintf(szTemp, countof(szTemp), szMsg, g_szBuildRoot);
        MessageBox(NULL, szTemp, g_szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
        return FALSE;
    }
    
    GetTempPath(MAX_PATH, g_szBuildTemp);
    PathAppend(g_szBuildTemp, TEXT("iedktemp"));

    PathRemovePath(g_szBuildTemp);
    PathCreatePath(g_szBuildTemp);

    GenerateCustomIns();

    if (g_szSrcRoot[0])
        g_fBatch2 = TRUE;
    else
        g_fBatch = TRUE;

    if (szType[0])
    {
        if ( 0 == StrCmpI(szType, TEXT("CORP")))
        {
            // if type CORP, set CorpMode=1; this allows the Profile Manager to run
            DWORD dwVal = 1;
            RegSetValueEx(s_hkIEAKUser, TEXT("CorpMode"), 0, REG_DWORD, (CONST BYTE *) &dwVal, sizeof(dwVal));
            s_iType = INTRANET;
        }
        else if ( 0 == StrCmpI(szType, TEXT("ISP")))
        {
            RegDeleteValue(s_hkIEAKUser, TEXT("CorpMode"));
            s_iType = BRANDED;
        }
        else if ( 0 == StrCmpI(szType, TEXT("ICP")))
        {
            RegDeleteValue(s_hkIEAKUser, TEXT("CorpMode"));
            s_iType = REDIST;
        }
        else
        {
            if(g_hLogFile)
            {
                TCHAR szError[MAX_PATH];
                DWORD dwNumWritten;
                LoadString(g_rvInfo.hInst,IDS_ERROR_INVALIDMODE,szError,MAX_PATH);
                FormatString(szError,szType);
                WriteFile(g_hLogFile,szError,StrLen(szError),&dwNumWritten,NULL);
            }
            return FALSE;
        }
    }
    else
        s_iType = GetPrivateProfileInt( IS_BRANDING, TEXT("Type"), REDIST, g_szCustIns );

    switch (s_iType)
    {
        case REDIST:
            g_fBranded = g_fIntranet = g_fSilent = FALSE;
            break;
        case BRANDED:
        case BRANDEDPROXY:
            g_fBranded = TRUE;
            g_fIntranet = g_fSilent = FALSE;
            break;
        case INTRANET:
            g_fIntranet = g_fBranded = TRUE;
            break;
    }
    
    if (g_fOCW)
    {
        // set to corp mode
        g_fIntranet = g_fBranded = TRUE;
        s_iType = INTRANET;

        // set to flat install
        g_fDownload = g_fCD = g_fBrandingOnly = FALSE;
        g_fLAN = TRUE;

        return TRUE;
    }

    IE4BatchSetup();

    return TRUE;
}


//
//
//   FUNCTION: InitInstance(HANDLE)
//
//   PURPOSE: Creates the main window.
//
//   COMMENTS: N/A
//
//
HWND g_hWndCent;

BOOL InitInstance(HINSTANCE hInstance)
{
    InitCommonControls();
    GetWindowRect(GetDesktopWindow(), &g_dtRect);
    g_hWndCent = CreateWindow(
                TEXT("SampleWClass"),
                TEXT("IEAK"),
        WS_POPUPWINDOW | WS_CAPTION,
        g_dtRect.right/2, g_dtRect.bottom/2, 0, 0,
        HWND_DESKTOP,
        NULL,
        hInstance,
        (HINSTANCE) NULL);

    ShowWindow(g_hWndCent, SW_SHOWNORMAL);
    UpdateWindow(g_hWndCent);
    PostMessage(g_hWndCent, WM_COMMAND, IDM_WIZARD, (LPARAM) 0);

    return (TRUE);

}

IEAKLITEINFO g_IEAKLiteArray[NUM_GROUPS] =  {
{IDS_IL_ACTIVESETUP, IDS_IL_ACTIVESETUPDESC, IDS_IL_ACTIVESETUPDESC, IDS_IL_ACTIVESETUPDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_CORPINSTALL, IDS_IL_CORPINSTALLDESC, IDS_IL_CORPINSTALLDESC, IDS_IL_CORPINSTALLDESC, -2, FALSE, FALSE, TRUE, TRUE},
{IDS_IL_CABSIGN, IDS_IL_CABSIGNDESC, IDS_IL_CABSIGNDESC, IDS_IL_CABSIGNDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_ICM, IDS_IL_ICMDESC, IDS_IL_ICMDESC, IDS_IL_ICMDESC, -2, FALSE, TRUE, TRUE, TRUE},
{IDS_IL_BROWSER, IDS_IL_BROWSERDESC, IDS_IL_BROWSERDESC, IDS_IL_BROWSERDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_URL, IDS_IL_URLDESC, IDS_IL_URLDESC, IDS_IL_URLDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_FAV, IDS_IL_FAVDESC, IDS_IL_FAVDESC, IDS_IL_FAVDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_UASTR, IDS_IL_UASTRDESC, IDS_IL_UASTRDESC, IDS_IL_UASTRDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_CONNECT, IDS_IL_CONNECTDESC, IDS_IL_CONNECTDESC, IDS_IL_CONNECTDESC, -2, FALSE, TRUE, TRUE, TRUE},
{IDS_IL_SIGNUP, IDS_IL_SIGNUPDESC, IDS_IL_SIGNUPDESC, IDS_IL_SIGNUPDESC, -2, FALSE, TRUE, FALSE, TRUE},
{IDS_IL_CERT, IDS_IL_CERTDESC, IDS_IL_CERTDESC, IDS_IL_CERTDESC, -2, FALSE, TRUE, TRUE, TRUE},
{IDS_IL_ZONES, IDS_IL_ZONESDESC, IDS_IL_ZONESDESC, IDS_IL_ZONESDESC, -2, FALSE, FALSE, TRUE, TRUE},
{IDS_IL_PROGRAMS, IDS_IL_PROGRAMSDESC, IDS_IL_PROGRAMSDESC, IDS_IL_PROGRAMSDESC, -2, TRUE, TRUE, TRUE, TRUE},
{IDS_IL_MAILNEWS, IDS_IL_MAILNEWSDESC, IDS_IL_MAILNEWSDESC, IDS_IL_MAILNEWSDESC, -2, FALSE, TRUE, TRUE, TRUE},
{IDS_IL_ADM, IDS_IL_ADMDESC, IDS_IL_ADMDESC, IDS_IL_ADMDESC, -2, TRUE, TRUE, TRUE, TRUE}
};

void DisableIEAKLiteGroups()
{
    TCHAR szIspFile[MAX_PATH];

    if (!g_IEAKLiteArray[IL_ACTIVESETUP].fEnabled)
    {
        s_fPageEnabled[PPAGE_SETUPWIZARD] = s_fPageEnabled[PPAGE_COMPSEL] = s_fPageEnabled[PPAGE_ISKBACK] = s_fPageEnabled[PPAGE_CDINFO] =
        s_fPageEnabled[PPAGE_CUSTOMCUSTOM] = s_fPageEnabled[PPAGE_COPYCOMP] = s_fPageEnabled[PPAGE_COMPURLS] =
        s_fPageEnabled[PPAGE_CUSTCOMP] =  FALSE;
    }

    if (!g_IEAKLiteArray[IL_CORPINSTALL].fEnabled)
    {
        s_fPageEnabled[PPAGE_CORPCUSTOM] = s_fPageEnabled[PPAGE_INSTALLDIR] = s_fPageEnabled[PPAGE_SILENTINSTALL] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_CABSIGN].fEnabled)
    {
        s_fPageEnabled[PPAGE_CABSIGN] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_ICM].fEnabled)
    {
        s_fPageEnabled[PPAGE_ICM] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_BROWSER].fEnabled)
    {
        s_fPageEnabled[PPAGE_TITLE] = s_fPageEnabled[PPAGE_CUSTICON] =
        s_fPageEnabled[PPAGE_BTOOLBARS] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_URL].fEnabled)
    {
        s_fPageEnabled[PPAGE_STARTSEARCH] = s_fPageEnabled[PPAGE_WELCOMEMSGS] =
            s_fPageEnabled[PPAGE_ADDON] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_FAV].fEnabled)
    {
        s_fPageEnabled[PPAGE_FAVORITES] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_UASTR].fEnabled)
    {
        s_fPageEnabled[PPAGE_UASTRDLG] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_CONNECT].fEnabled)
    {
        s_fPageEnabled[PPAGE_PROXY] = s_fPageEnabled[PPAGE_CONNECTSET] = s_fPageEnabled[PPAGE_QUERYAUTOCONFIG] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_SIGNUP].fEnabled)
    {
        s_fPageEnabled[PPAGE_QUERYSIGNUP] =
        s_fPageEnabled[PPAGE_SIGNUPFILES] =
        s_fPageEnabled[PPAGE_SERVERISPS] =
        s_fPageEnabled[PPAGE_ICW] = s_fPageEnabled[PPAGE_ISPINS] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_CERT].fEnabled)
    {
        s_fPageEnabled[PPAGE_ADDROOT] = s_fPageEnabled[PPAGE_SECURITYCERT] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_ZONES].fEnabled)
    {
        s_fPageEnabled[PPAGE_SECURITY] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_PROGRAMS].fEnabled)
    {
        s_fPageEnabled[PPAGE_PROGRAMS] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_MAILNEWS].fEnabled)
    {
        s_fPageEnabled[PPAGE_MAIL] = s_fPageEnabled[PPAGE_IMAP] = s_fPageEnabled[PPAGE_LDAP] =
        s_fPageEnabled[PPAGE_OE]   = s_fPageEnabled[PPAGE_SIG]  = s_fPageEnabled[PPAGE_PRECONFIG] =
        s_fPageEnabled[PPAGE_OEVIEW] = FALSE;
    }

    if (!g_IEAKLiteArray[IL_ADM].fEnabled)
    {
        s_fPageEnabled[PPAGE_ADMDESC] = FALSE;
        s_fPageEnabled[PPAGE_ADM] = FALSE;
    }

    // do not show stage 4 page if nothing has been left on in the stage

    if (!(g_IEAKLiteArray[IL_BROWSER].fEnabled || g_IEAKLiteArray[IL_URL].fEnabled 
        || g_IEAKLiteArray[IL_FAV].fEnabled || g_IEAKLiteArray[IL_UASTR].fEnabled ||
        (g_IEAKLiteArray[IL_CONNECT].fEnabled && g_fBranded) || (g_IEAKLiteArray[IL_SIGNUP].fEnabled && !g_fIntranet && g_fBranded) ||
        ((g_IEAKLiteArray[IL_CERT].fEnabled || g_IEAKLiteArray[IL_ZONES].fEnabled) && g_fIntranet)))
        s_fPageEnabled[PPAGE_STAGE4] = FALSE;

    if (!(g_IEAKLiteArray[IL_PROGRAMS].fEnabled || (g_IEAKLiteArray[IL_MAILNEWS].fEnabled && g_fBranded) || 
          g_IEAKLiteArray[IL_ADM].fEnabled))
        s_fPageEnabled[PPAGE_STAGE5] = FALSE;

    // szIspFile used as temp buf

    if (g_fDownload && !g_fOCW && ISNONNULL(g_szCustIns) && !GetPrivateProfileString(IS_ACTIVESETUP_SITES, TEXT("SiteUrl0"), TEXT(""), szIspFile, countof(szIspFile), g_szCustIns))
        s_fPageEnabled[PPAGE_COMPURLS] = TRUE;

    // do not show stage 3 page if nothing has been left on in the stage

    if (!(s_fPageEnabled[PPAGE_COMPURLS] || g_IEAKLiteArray[IL_ACTIVESETUP].fEnabled ||
          (g_IEAKLiteArray[IL_CORPINSTALL].fEnabled && g_fIntranet) || g_IEAKLiteArray[IL_CABSIGN].fEnabled || 
          (g_IEAKLiteArray[IL_ICM].fEnabled) && g_fBranded && !g_fBrandingOnly))
        s_fPageEnabled[PPAGE_STAGE3] = FALSE;

    // always enable download urls page for download packages
    // the page itself has logic to skip

    if (g_fDownload)
        s_fPageEnabled[PPAGE_COMPURLS] = TRUE;
}

void EnablePages()
{
    int i;
    static BOOL s_fRunningOnIntegShell = WhichPlatform() & PLATFORM_INTEGRATED;

    for (i = 0;  i < NUM_PAGES;  i++)
    {
        s_fPageEnabled[i] = TRUE;
    }

    // NOTE: pages should not explicitly be set to TRUE after this point

    // g_fIntranet and g_fBranded are set to the following values depending on the role
    // ICP:  (g_fIntranet == FALSE  &&  g_fBranded == FALSE)
    // ISP:  (g_fIntranet == FALSE  &&  g_fBranded == TRUE )
    // CORP: (g_fIntranet == TRUE   &&  g_fBranded == TRUE )
    //
    // So, check for
    // ICP  is (!g_fBranded)
    // ISP  is (!g_fIntranet  &&  g_fBranded)
    // CORP is (g_fIntranet)

    if (!g_fBranded)
    {   // ICP mode
        s_fPageEnabled[PPAGE_PROXY] =
        s_fPageEnabled[PPAGE_INSTALLDIR] =
        s_fPageEnabled[PPAGE_ICM] =
        s_fPageEnabled[PPAGE_ICW] =
        s_fPageEnabled[PPAGE_QUERYAUTOCONFIG] =
        s_fPageEnabled[PPAGE_MAIL] =
        s_fPageEnabled[PPAGE_IMAP] =
        s_fPageEnabled[PPAGE_LDAP] =
        s_fPageEnabled[PPAGE_PRECONFIG] =
        s_fPageEnabled[PPAGE_OEVIEW] =
        s_fPageEnabled[PPAGE_OE]   = s_fPageEnabled[PPAGE_CORPCUSTOM] = s_fPageEnabled[PPAGE_ADMDESC] =
        s_fPageEnabled[PPAGE_SIG]  = s_fPageEnabled[PPAGE_FOLDERMCCP] = s_fPageEnabled[PPAGE_ADDROOT] =
        s_fPageEnabled[PPAGE_SECURITY] = s_fPageEnabled[PPAGE_SECURITYCERT] = s_fPageEnabled[PPAGE_QUERYSIGNUP] =
        s_fPageEnabled[PPAGE_SILENTINSTALL] =
        s_fPageEnabled[PPAGE_DESKTOP] = s_fPageEnabled[PPAGE_DTOOLBARS] = s_fPageEnabled[PPAGE_CONNECTSET] =
        s_fPageEnabled[PPAGE_SIGNUPFILES] = s_fPageEnabled[PPAGE_SERVERISPS] = s_fPageEnabled[PPAGE_ISPINS] = FALSE;
    }
    else if (!g_fIntranet)
    {   // Either ISP or Super ISP
        s_fPageEnabled[PPAGE_QUERYAUTOCONFIG] =
        s_fPageEnabled[PPAGE_SIG] =
        s_fPageEnabled[PPAGE_INSTALLDIR] =
        s_fPageEnabled[PPAGE_SILENTINSTALL] =
        s_fPageEnabled[PPAGE_DESKTOP] = s_fPageEnabled[PPAGE_DTOOLBARS] = s_fPageEnabled[PPAGE_ADMDESC] =
        s_fPageEnabled[PPAGE_SECURITY] = s_fPageEnabled[PPAGE_SECURITYCERT] =
        s_fPageEnabled[PPAGE_FOLDERMCCP] = s_fPageEnabled[PPAGE_CORPCUSTOM] = FALSE;

        s_fPageEnabled[PPAGE_SERVERISPS] = (g_fServerICW || g_fServerKiosk)  &&  !g_fSkipServerIsps;
        s_fPageEnabled[PPAGE_ISPINS] = !g_fNoSignup  &&  !g_fSkipIspIns;

        s_fPageEnabled[PPAGE_ICW] = g_fServerICW;
        s_fPageEnabled[PPAGE_SIGNUPFILES] = !g_fNoSignup;
    }
    else
    {   // CorpAdmin mode
        s_fPageEnabled[PPAGE_ADDROOT] = s_fPageEnabled[PPAGE_ICW] =
        s_fPageEnabled[PPAGE_SERVERISPS] = s_fPageEnabled[PPAGE_ISPINS] =
        s_fPageEnabled[PPAGE_QUERYSIGNUP] = s_fPageEnabled[PPAGE_SIGNUPFILES] = FALSE;
        s_fPageEnabled[PPAGE_DTOOLBARS] = s_fPageEnabled[PPAGE_DESKTOP] = g_fInteg && s_fRunningOnIntegShell && !s_fNT5;
        s_fPageEnabled[PPAGE_FOLDERMCCP] = g_fInteg && !s_fNT5;

        s_fPageEnabled[PPAGE_ADMDESC] = ADMEnablePage();
    }

    if (!g_fCD)
        s_fPageEnabled[PPAGE_ISKBACK] = s_fPageEnabled[PPAGE_CDINFO] = FALSE;

    if (!g_fDownload)
        s_fPageEnabled[PPAGE_COMPURLS] = FALSE;

    if (!g_fMailNews95 && !g_fOCW)
    {
        s_fPageEnabled[PPAGE_MAIL] = s_fPageEnabled[PPAGE_IMAP] = s_fPageEnabled[PPAGE_PRECONFIG] =
        s_fPageEnabled[PPAGE_OEVIEW] = s_fPageEnabled[PPAGE_LDAP] = s_fPageEnabled[PPAGE_OE] =
        s_fPageEnabled[PPAGE_SIG]  = FALSE;
    }

    if (!g_fDownload && (g_fSilent || g_fStealth))
        s_fPageEnabled[PPAGE_CUSTOMCUSTOM] = FALSE;

    // pages to disable for single disk branding only builds

    if (g_fBrandingOnly && !(g_fDownload || g_fLAN || g_fCD))
    {
        s_fPageEnabled[PPAGE_CUSTCOMP] = s_fPageEnabled[PPAGE_COMPSEL] = s_fPageEnabled[PPAGE_COMPURLS] =
        s_fPageEnabled[PPAGE_INSTALLDIR] = s_fPageEnabled[PPAGE_CORPCUSTOM] = s_fPageEnabled[PPAGE_CUSTOMCUSTOM] =
        s_fPageEnabled[PPAGE_COPYCOMP] = s_fPageEnabled[PPAGE_ICM] =
        s_fPageEnabled[PPAGE_ADDON] = FALSE;

        g_fInteg = TRUE;  // set this flag to true so admins can still make desktop customizations
    }

    // disable advanced installation options page if no download media and custom mode
    // disabled

    if (!g_fDownload && InsGetBool(IS_BRANDING, TEXT("HideCustom"), FALSE, g_szCustIns))
        s_fPageEnabled[PPAGE_CUSTOMCUSTOM] = FALSE;

    if (g_fImportConnect)
        s_fPageEnabled[PPAGE_PROXY] = s_fPageEnabled[PPAGE_QUERYAUTOCONFIG] = FALSE;

    s_fPageEnabled[PPAGE_ADM] = ADMEnablePage();

    if(g_fOCW)
    {
        s_fPageEnabled[PPAGE_FINISH]       = 
        s_fPageEnabled[PPAGE_MEDIA]        = s_fPageEnabled[PPAGE_ISPINS] =
        s_fPageEnabled[PPAGE_ICM]          = s_fPageEnabled[PPAGE_QUERYSIGNUP]  = s_fPageEnabled[PPAGE_ICW] =
        s_fPageEnabled[PPAGE_SIGNUPFILES]  = s_fPageEnabled[PPAGE_SERVERISPS]   = s_fPageEnabled[PPAGE_SETUPWIZARD]  =
        s_fPageEnabled[PPAGE_STAGE1]       = s_fPageEnabled[PPAGE_STAGE2]       = s_fPageEnabled[PPAGE_STAGE3]        =
        s_fPageEnabled[PPAGE_STAGE4]       = s_fPageEnabled[PPAGE_STAGE5]       = s_fPageEnabled[PPAGE_SILENTINSTALL] =
        s_fPageEnabled[PPAGE_COMPURLS]     = s_fPageEnabled[PPAGE_INSTALLDIR]   = FALSE;
    }
    else
    {
        s_fPageEnabled[PPAGE_OCWSTAGE2]    = FALSE;
    }

    // Special case IMAP page
    if (g_fDisableIMAPPage)
        s_fPageEnabled[PPAGE_IMAP] = FALSE;

    DisableIEAKLiteGroups();
}

BOOL PageEnabled(int iPage)
{
    TCHAR szTemp[4];

    // this should eventually just index into s_fPageEnabled, but for now we need to do this
    // manually since we must still use the page array for PageNext and PageBack

    if (iPage == PPAGE_COMPURLS)
        return (g_IEAKLiteArray[IL_ACTIVESETUP].fEnabled
                || !GetPrivateProfileString(IS_ACTIVESETUP_SITES, TEXT("SiteUrl0"),
                TEXT(""), szTemp, countof(szTemp), g_szCustIns));

    return TRUE;    // default to show page
}

static TCHAR s_aSzTitle[NUM_PAGES][MAX_PATH];

void PageNext(HWND hDlg)
{
    if (s_fPageEnabled[++g_iCurPage]) return;
    while (1)
    {
        if (s_fPageEnabled[++g_iCurPage])
        {
            DWORD id = (DWORD) PtrToUlong(g_psp[g_iCurPage].pszTemplate);
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, id);
            return;
        }
    }
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_FINISH);
}

void PagePrev(HWND hDlg)
{
    if (s_fPageEnabled[--g_iCurPage]) return;
    while (1)
    {
        if (s_fPageEnabled[--g_iCurPage])
        {
            DWORD id = (DWORD) PtrToUlong(g_psp[g_iCurPage].pszTemplate);
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, id);
            return;
        }
    }
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_KEYINS);
}

SHFILEOPSTRUCT g_shfStruc;

void DoCancel()
{
    g_fCancelled = TRUE;
    g_fOCWCancel = TRUE;
    if (g_hDownloadEvent) SetEvent(g_hDownloadEvent);
    PostQuitMessage(0);

}

BOOL QueryCancel(HWND hDlg)
{
    TCHAR szMsg[MAX_PATH];
    LoadString( g_rvInfo.hInst, IDS_CANCELOK, szMsg, countof(szMsg) );
    if (MessageBox(hDlg, szMsg, g_szTitle, MB_YESNO | MB_SETFOREGROUND) == IDNO)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        g_fCancelled = FALSE;
        return(FALSE);
    }
    DoCancel();
    return(TRUE);
}

BOOL IeakPageHelp(HWND hWnd, LPCTSTR pszData)
{
    static TCHAR szHelpPath[MAX_PATH] = TEXT("");

    UNREFERENCED_PARAMETER(hWnd);

    if (ISNULL(szHelpPath))
        PathCombine(szHelpPath, g_szWizRoot, TEXT("ieakhelp.chm"));

    // (pritobla): If we pass hWnd to HtmlHelp, the HTML help window
    // would stay on top of our window (parent->child relationship).
    // This is bad because the user can't switch between these windows
    // for cross referencing.  This is especially bad on a 640x480
    // resolution monitor.
    s_hWndHelp = HtmlHelp(NULL, szHelpPath, HH_HELP_CONTEXT, (ULONG_PTR) pszData);

    // (pritobla): On OSR2 machines, the HTML help window comes up behind
    // our window.  On a 640x480 resolution monitor, we pretty much occupy
    // the entire screen, so the user won't know that the HTML help window
    // is up.  Setting it to the foreground solves the problem.

    SetForegroundWindow(s_hWndHelp);
    return TRUE;
}

extern DWORD BuildIE4(LPVOID );

//
//   FUNCTION: MainWndProc(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for the main window procedure
//
//    MESSAGES:
//
//  WM_CREATE - creates the main MLE for the window
//  WM_COMMAND - processes the menu commands for the application
//  WM_SIZE - sizes the MLE to fill the client area of the window
//  WM_DESTROY - posts a quit message and returns
//
LRESULT APIENTRY MainWndProc(
    HWND hWnd,                // window handle
    UINT message,             // type of message
    WPARAM wParam,              // additional information
    LPARAM lParam)              // additional information
{
    int i;

    switch (message)
    {
        case WM_CREATE:
            return FALSE;

        case WM_INITDIALOG:
            return FALSE;

        case WM_SIZE:
            if (!IsIconic(hWnd) && (hWnd != g_hWndCent))
                ShowWindow(hWnd, SW_MINIMIZE);
            if (g_hWizard != NULL)
                SetFocus(g_hWizard);
            return (DefWindowProc(hWnd, message, wParam, lParam));

        case WM_HELP:
            IeakPageHelp(hWnd, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            switch( LOWORD( wParam ))
            {
                case IDM_WIZARD:
                    if (g_fCancelled)
                        break;

                    i = CreateWizard(g_hWndCent);
                    if (i < 0) {
                        PostQuitMessage(0);
                        break;
                    }
                    PostMessage(hWnd, WM_COMMAND, IDM_LAST, (LPARAM) 0);
                    break;

                case IDM_LAST:
                    PostQuitMessage(0);
                    break;

                case IDM_EXIT:
                    PostQuitMessage(0);
                    break;

                default:
                    return (DefWindowProc(hWnd, message, wParam, lParam));

        }
        break;

        case WM_CLOSE:
            QueryCancel(hWnd);
            break;

        case WM_DESTROY:                  /* message: window being destroyed */
            PostQuitMessage(0);
            DestroyWindow(g_hWndCent);
            break;

        default:
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (0);
}


DWORD GetRootFree(LPCTSTR pcszPath)
{
    DWORD dwSecPerClus, dwBytesPerSec, dwTotClusters, dwFreeClusters, dwClustK;
    CHAR szPathA[MAX_PATH];

    // thunk to ANSI since shlwapi doesn't have a wrapper fot GetDiskFreeSpace and
    // the W version is stubbed out on Win95

    T2Abux(pcszPath, szPathA);

    if (szPathA[1] == ':')
    {
        szPathA[3] = '\0';
    }
    else
    {
        if ((szPathA[0] == '\\') && (szPathA[1] == '\\'))
        {
            NETRESOURCEA netRes;
            DWORD erc = ERROR_ALREADY_ASSIGNED;
            CHAR szLocalPathA[4] = "D:";
            LPSTR pBack = StrChrA(&szPathA[2], '\\');
            if (!pBack) return(0);
            pBack = StrChrA(CharNextA(pBack), '\\');
            if (pBack) *pBack = '\0';
            ZeroMemory(&netRes, sizeof(netRes));
            netRes.dwType = RESOURCETYPE_DISK;
            netRes.lpRemoteName = szPathA;
            for (*szLocalPathA = 'D'; *szLocalPathA <= 'Z' ; (*szLocalPathA)++ )
            {
                netRes.lpLocalName = szLocalPathA;
                erc = WNetAddConnection2A(&netRes, NULL, NULL, 0);
                if (erc == ERROR_ALREADY_ASSIGNED) continue;
                if (erc == NO_ERROR) break;
            }
            if (erc == NO_ERROR)
            {
                if (!GetDiskFreeSpaceA( szLocalPathA, &dwSecPerClus, &dwBytesPerSec, &dwFreeClusters, &dwTotClusters ))
                    dwSecPerClus = dwBytesPerSec = 0;
                WNetCancelConnection2A(szLocalPathA, 0, FALSE);
                if (dwSecPerClus == 1) return(dwFreeClusters/2);
                dwClustK = dwSecPerClus * dwBytesPerSec / 1024;
                return(dwClustK * dwFreeClusters);
            }
        }
        else return(0);
    }
    if (!GetDiskFreeSpaceA( szPathA, &dwSecPerClus, &dwBytesPerSec, &dwFreeClusters, &dwTotClusters ))
        return(0);
    if (dwSecPerClus == 1) return(dwFreeClusters/2);
    dwClustK = dwSecPerClus * dwBytesPerSec / 1024;
    return(dwClustK * dwFreeClusters);
}

void CheckBatchAdvance(HWND hDlg)
{
    if (g_fBatch || g_fBatch2) PostMessage(hDlg, IDM_BATCHADVANCE, 0, 0);
}

void DoBatchAdvance(HWND hDlg)
{
    if (g_fBatch || g_fBatch2) PostMessage(GetParent(hDlg), PSM_PRESSBUTTON, PSBTN_NEXT, 0);
}

BOOL CALLBACK MediaDlgProc(HWND hDlg, UINT uMsg, WPARAM, LPARAM lParam)
{
    static BOOL s_fNext = TRUE;

    switch (uMsg)
    {
        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    g_fDownload     = GetPrivateProfileInt(TEXT("Media"), TEXT("Build_Download"),     1, g_szCustIns);
                    g_fCD           = GetPrivateProfileInt(TEXT("Media"), TEXT("Build_CD"),           0, g_szCustIns);
                    g_fLAN          = GetPrivateProfileInt(TEXT("Media"), TEXT("Build_LAN"),          0, g_szCustIns);
                    g_fBrandingOnly = GetPrivateProfileInt(TEXT("Media"), TEXT("Build_BrandingOnly"), 0, g_szCustIns);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKDL)))
                        CheckDlgButton(hDlg, IDC_CHECKDL, g_fDownload ? BST_CHECKED : BST_UNCHECKED);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKCD)))
                        CheckDlgButton(hDlg, IDC_CHECKCD, g_fCD ? BST_CHECKED : BST_UNCHECKED);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKLAN)))
                        CheckDlgButton(hDlg, IDC_CHECKLAN, g_fLAN ? BST_CHECKED : BST_UNCHECKED);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKSDB)))
                        CheckDlgButton(hDlg, IDC_CHECKSDB, g_fBrandingOnly ? BST_CHECKED : BST_UNCHECKED);

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    g_fDownload = g_fCD = g_fLAN = g_fBrandingOnly = FALSE;

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKDL)))
                        g_fDownload = (IsDlgButtonChecked(hDlg, IDC_CHECKDL) == BST_CHECKED);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKCD)))
                        g_fCD = (IsDlgButtonChecked(hDlg, IDC_CHECKCD) == BST_CHECKED);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKLAN)))
                        g_fLAN = (IsDlgButtonChecked(hDlg, IDC_CHECKLAN) == BST_CHECKED);

                    if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHECKSDB)))
                        g_fBrandingOnly = (IsDlgButtonChecked(hDlg, IDC_CHECKSDB) == BST_CHECKED);

                    // if none of the media boxes are selected, display an error msg
                    if (!g_fDownload  &&  !g_fCD  &&  !g_fLAN  &&  !g_fBrandingOnly)
                    {
                        ErrorMessageBox(hDlg, IDS_NOMEDIA);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    WritePrivateProfileString(TEXT("Media"), TEXT("Build_Download"),     g_fDownload     ? TEXT("1") : TEXT("0"), g_szCustIns );
                    WritePrivateProfileString(TEXT("Media"), TEXT("Build_CD"),           g_fCD           ? TEXT("1") : TEXT("0"), g_szCustIns );
                    WritePrivateProfileString(TEXT("Media"), TEXT("Build_LAN"),          g_fLAN          ? TEXT("1") : TEXT("0"), g_szCustIns );
                    WritePrivateProfileString(TEXT("Media"), TEXT("Build_BrandingOnly"), g_fBrandingOnly ? TEXT("1") : TEXT("0"), g_szCustIns );

                    s_fNext = (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? FALSE : TRUE;

                    g_iCurPage = PPAGE_MEDIA;
                    EnablePages();
                    (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

void DisplayBitmap(HWND hControl, LPCTSTR pcszFileName, int nBitmapId)
{
    HANDLE hBmp = (HANDLE) GetWindowLongPtr(hControl, GWLP_USERDATA);

    if(ISNONNULL(pcszFileName) && PathFileExists(pcszFileName))
        ShowBitmap(hControl, pcszFileName, 0, &hBmp);
    else
        ShowBitmap(hControl, TEXT(""), nBitmapId, &hBmp);

    SetWindowLongPtr(hControl, GWLP_USERDATA, (LONG_PTR)hBmp);
}

void ReleaseBitmap(HWND hControl)
{
    HANDLE hBmp = (HANDLE) GetWindowLongPtr(hControl, GWLP_USERDATA);

    if (hBmp)
        DeleteObject(hBmp);
}

void InitializeAnimBmps(HWND hDlg, LPCTSTR szInsFile)
{
    TCHAR szBig[MAX_PATH];
    TCHAR szSmall[MAX_PATH];
    BOOL fBrandBmps;

    // load information from ins file
    fBrandBmps = InsGetString(IS_ANIMATION, TEXT("Big_Path"),
        szBig, countof(szBig), szInsFile);
    SetDlgItemTextTriState(hDlg, IDE_BIGANIMBITMAP, IDC_ANIMBITMAP, szBig, fBrandBmps);

    InsGetString(IS_ANIMATION, TEXT("Small_Path"),
        szSmall, countof(szSmall), szInsFile, NULL, &fBrandBmps);
    SetDlgItemTextTriState(hDlg, IDE_SMALLANIMBITMAP, IDC_ANIMBITMAP, szSmall, fBrandBmps);

    EnableDlgItem2(hDlg, IDE_BIGANIMBITMAP, fBrandBmps);
    EnableDlgItem2(hDlg, IDC_BROWSEBIG, fBrandBmps);
    EnableDlgItem2(hDlg, IDC_BIGANIMBITMAP_TXT, fBrandBmps);
    EnableDlgItem2(hDlg, IDE_SMALLANIMBITMAP, fBrandBmps);
    EnableDlgItem2(hDlg, IDC_BROWSESMALL, fBrandBmps);
    EnableDlgItem2(hDlg, IDC_SMALLANIMBITMAP_TXT, fBrandBmps);
}


//
//  FUNCTION: CustIcon(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "Work Habits" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
BOOL APIENTRY CustIcon( HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    TCHAR szBig[MAX_PATH];
    TCHAR szSmall[MAX_PATH];
    TCHAR szLargeBmp[MAX_PATH];
    TCHAR szSmallBmp[MAX_PATH];

    LPDRAWITEMSTRUCT lpDrawItem = NULL;
    TCHAR szWorkDir[MAX_PATH];
    BOOL fBrandBmps,fBrandAnim;

    switch( msg )
    {
    case WM_INITDIALOG:
        //from anim
        EnableDBCSChars(hDlg, IDE_SMALLANIMBITMAP);
        EnableDBCSChars(hDlg, IDE_BIGANIMBITMAP);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SMALLANIMBITMAP), countof(szSmallBmp) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_BIGANIMBITMAP), countof(szLargeBmp) - 1);
        
        //custicon
        EnableDBCSChars(hDlg, IDC_BITMAP);
        EnableDBCSChars(hDlg, IDC_BITMAP2);
        Edit_LimitText(GetDlgItem(hDlg, IDC_BITMAP), countof(szBig) - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDC_BITMAP2), countof(szSmall) - 1);
        g_hWizard = hDlg;
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_BROWSEBIG:
                GetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szLargeBmp, countof(szLargeBmp));
                if(BrowseForFile(hDlg, szLargeBmp, countof(szLargeBmp), GFN_BMP))
                    SetDlgItemText(hDlg, IDE_BIGANIMBITMAP, szLargeBmp);
                break;

            case IDC_BROWSESMALL:
                GetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmallBmp, countof(szSmallBmp));
                if(BrowseForFile(hDlg, szSmallBmp, countof(szSmallBmp), GFN_BMP))
                    SetDlgItemText(hDlg, IDE_SMALLANIMBITMAP, szSmallBmp);
                break;

            case IDC_ANIMBITMAP:
                fBrandAnim = (IsDlgButtonChecked(hDlg, IDC_ANIMBITMAP) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_BIGANIMBITMAP, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_BROWSEBIG, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_BIGANIMBITMAP_TXT, fBrandAnim);
                EnableDlgItem2(hDlg, IDE_SMALLANIMBITMAP, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_BROWSESMALL, fBrandAnim);
                EnableDlgItem2(hDlg, IDC_SMALLANIMBITMAP_TXT, fBrandAnim);
                break;

            case IDC_BROWSEICON:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    GetDlgItemText(hDlg, IDC_BITMAP, szBig, countof(szBig));
                    if(BrowseForFile(hDlg, szBig, countof(szBig), GFN_BMP))
                        SetDlgItemText(hDlg, IDC_BITMAP, szBig);
                    break;
                }
                return FALSE;

            case IDC_BROWSEICON2:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    GetDlgItemText(hDlg, IDC_BITMAP2, szSmall, countof(szSmall));
                    if(BrowseForFile(hDlg, szSmall, countof(szSmall), GFN_BMP))
                        SetDlgItemText(hDlg, IDC_BITMAP2, szSmall);
                    break;
                }
                return FALSE;

            case IDC_BITMAPCHECK:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    fBrandBmps = (IsDlgButtonChecked(hDlg, IDC_BITMAPCHECK) == BST_CHECKED);
                    EnableDlgItem2(hDlg, IDC_BITMAP, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_BROWSEICON, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_LARGEBITMAP_TXT, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_BROWSEICON2, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_BITMAP2, fBrandBmps);
                    EnableDlgItem2(hDlg, IDC_SMALLBITMAP_TXT, fBrandBmps);
                    break;
                }
                return FALSE;

            default:
                return FALSE;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {

            case PSN_HELP:
                IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                break;

            case PSN_SETACTIVE:
                SetBannerText(hDlg);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);

                // load information from ins file
                InitializeAnimBmps(hDlg, g_szCustIns);

                InsGetString(IS_SMALLLOGO, TEXT("Path"),
                    szSmall, countof(szSmall), g_szCustIns);
                InsGetString(IS_LARGELOGO, TEXT("Path"),
                    szBig, countof(szBig), g_szCustIns, NULL, &fBrandBmps);

                SetDlgItemTextTriState(hDlg, IDC_BITMAP2, IDC_BITMAPCHECK, szSmall, fBrandBmps);
                SetDlgItemTextTriState(hDlg, IDC_BITMAP, IDC_BITMAPCHECK, szBig, fBrandBmps);
                EnableDlgItem2(hDlg, IDC_BROWSEICON, fBrandBmps);
                EnableDlgItem2(hDlg, IDC_BROWSEICON2, fBrandBmps);
                EnableDlgItem2(hDlg, IDC_LARGEBITMAP_TXT, fBrandBmps);
                EnableDlgItem2(hDlg, IDC_SMALLBITMAP_TXT, fBrandBmps);
                {
                    TCHAR szTmp[MAX_PATH];

                    if (ISNONNULL(szSmall))
                    {
                        PathCombine(szTmp, g_szTempSign, PathFindFileName(szSmall));
                        DeleteFile(szTmp);
                    }
                    if (ISNONNULL(szBig))
                    {
                        PathCombine(szTmp, g_szTempSign, PathFindFileName(szBig));
                        DeleteFile(szTmp);
                    }
                }

                CheckBatchAdvance(hDlg);
                break;

            case PSN_WIZNEXT:
            case PSN_WIZBACK:
                //from animbmp
                g_cmCabMappings.GetFeatureDir(FEATURE_BRAND, szWorkDir);

                GetDlgItemTextTriState(hDlg, IDE_SMALLANIMBITMAP, IDC_ANIMBITMAP, szSmallBmp,
                    countof(szSmallBmp));

                fBrandAnim = GetDlgItemTextTriState(hDlg, IDE_BIGANIMBITMAP, IDC_ANIMBITMAP,
                    szLargeBmp, countof(szLargeBmp));

                if ((fBrandAnim && !IsAnimBitmapFileValid(hDlg, IDE_BIGANIMBITMAP, szLargeBmp, NULL, IDS_TOOBIG38, IDS_TOOSMALL38, 38, 38)) ||
                    !CopyAnimBmp(hDlg, szLargeBmp, szWorkDir, IK_LARGEBITMAP, TEXT("Big_Path"), g_szCustIns))
                {
                    SetFocus(GetDlgItem(hDlg, IDE_BIGANIMBITMAP));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                if ((fBrandAnim && !IsAnimBitmapFileValid(hDlg, IDE_SMALLANIMBITMAP, szSmallBmp, NULL, IDS_TOOBIG22, IDS_TOOSMALL22, 22, 22)) ||
                    !CopyAnimBmp(hDlg, szSmallBmp, szWorkDir, IK_SMALLBITMAP, TEXT("Small_Path"), g_szCustIns))
                {
                    SetFocus(GetDlgItem(hDlg, IDE_SMALLANIMBITMAP));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                if ((fBrandAnim && ISNULL(szSmallBmp) && ISNONNULL(szLargeBmp)) || (fBrandAnim && ISNONNULL(szSmallBmp) && ISNULL(szLargeBmp)))
                {
                    ErrorMessageBox(hDlg, IDS_BOTHBMP_ERROR);
                    if (ISNULL(szSmallBmp))
                        SetFocus(GetDlgItem(hDlg, IDE_SMALLANIMBITMAP));
                    else
                        SetFocus(GetDlgItem(hDlg, IDE_BIGANIMBITMAP));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                InsWriteBool(IS_ANIMATION, IK_DOANIMATION, fBrandAnim, g_szCustIns);

                //custicon
                fBrandBmps = (IsDlgButtonChecked(hDlg, IDC_BITMAPCHECK) == BST_CHECKED);
                //----- Validate the bitmap -----
                GetDlgItemText(hDlg, IDC_BITMAP2, szSmall, countof(szSmall));
                if (fBrandBmps && !IsBitmapFileValid(hDlg, IDC_BITMAP2, szSmall, NULL, 22, 22, IDS_TOOBIG22, IDS_TOOSMALL22))
                {
                    SetFocus(GetDlgItem(hDlg, IDC_BITMAP2));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                CopyLogoBmp(hDlg, szSmall, IS_SMALLLOGO, szWorkDir, g_szCustIns);

                GetDlgItemText(hDlg, IDC_BITMAP, szBig, countof(szBig));
                if (fBrandBmps && !IsBitmapFileValid(hDlg, IDC_BITMAP, szBig, NULL, 38, 38, IDS_TOOBIG38, IDS_TOOSMALL38))
                {
                    SetFocus(GetDlgItem(hDlg, IDC_BITMAP));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                CopyLogoBmp(hDlg, szBig, IS_LARGELOGO, szWorkDir, g_szCustIns);

                if ((fBrandBmps && ISNULL(szSmall) && ISNONNULL(szBig)) || (fBrandBmps && ISNONNULL(szSmall) && ISNULL(szBig)))
                {
                    ErrorMessageBox(hDlg, IDS_BOTHBMP_ERROR);
                    if (ISNULL(szSmall))
                        SetFocus(GetDlgItem(hDlg, IDC_BITMAP2));
                    else
                        SetFocus(GetDlgItem(hDlg, IDC_BITMAP));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                g_iCurPage = PPAGE_CUSTICON;
                EnablePages();
                if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                    PageNext(hDlg);
                else
                    PagePrev(hDlg);
                break;

            case PSN_QUERYCANCEL:
                QueryCancel(hDlg);
                break;

            default:
                return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL APIENTRY Favorites(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR      szWorkDir[MAX_PATH],
               szValue[16],
               szUrl[INTERNET_MAX_URL_LENGTH];
    HWND       hTv = GetDlgItem(hDlg, IDC_TREE1);
    LPCTSTR    pszValue;
    BOOL       fQL,
               fFavoritesOnTop, fFavoritesDelete, fIEAKFavoritesDelete;
    DWORD      dwFavoritesDeleteFlags;

    switch(msg) {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDC_TREE1);

        MigrateFavorites(g_szCustIns);
#ifdef UNICODE
        TreeView_SetUnicodeFormat(hTv, TRUE);
#else
        TreeView_SetUnicodeFormat(hTv, FALSE);
#endif
        g_hWizard = hDlg;
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case WM_COMMAND:
        switch(HIWORD(wParam)) {
        case BN_CLICKED:
            switch(LOWORD(wParam)) {
            case IDC_FAVONTOP:
                if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_FAVONTOP)) {
                    HTREEITEM hti;
                    TV_ITEM   tvi;

                    EnableDlgItem(hDlg, IDC_FAVONTOP);

                    hti = TreeView_GetSelection(hTv);
                    if (hti != NULL) {
                        ZeroMemory(&tvi, sizeof(tvi));
                        tvi.mask  = TVIF_STATE;
                        tvi.hItem = hti;
                        TreeView_GetItem(hTv, &tvi);

                        if (!HasFlag(tvi.state, TVIS_BOLD)) {
                            EnableDlgItem2(hDlg, IDC_FAVUP,   (NULL != TreeView_GetPrevSibling(hTv, hti)));
                            EnableDlgItem2(hDlg, IDC_FAVDOWN, (NULL != TreeView_GetNextSibling(hTv, hti)));
                        }
                    }
                }
                else {
                    DisableDlgItem(hDlg, IDC_FAVUP);
                    DisableDlgItem(hDlg, IDC_FAVDOWN);
                }
                break;

            case IDC_DELFAVORITES:
                fFavoritesDelete = (IsDlgButtonChecked(hDlg, IDC_DELFAVORITES) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDC_DELIEAKFAVORITES, fFavoritesDelete);
                break;

            case IDC_FAVUP:
                MoveUpFavorite(hTv, TreeView_GetSelection(hTv));
                break;

            case IDC_FAVDOWN:
                MoveDownFavorite(hTv, TreeView_GetSelection(hTv));
                break;

            case IDC_ADDURL:
                fQL = !IsFavoriteItem(hTv, TreeView_GetSelection(hTv));
                if (GetFavoritesNumber(hTv, fQL) >= GetFavoritesMaxNumber(fQL)) {
                    UINT nID;

                    nID = (!fQL ? IDS_ERROR_MAXFAVS : IDS_ERROR_MAXQLS);
                    ErrorMessageBox(hDlg, nID);
                    break;
                }

                g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szWorkDir);
                NewUrl(hTv, szWorkDir, g_dwPlatformId, g_fIntranet ? IEM_CORP : IEM_NEUTRAL);
                break;

            case IDC_ADDFOLDER:
                ASSERT(IsFavoriteItem(hTv, TreeView_GetSelection(hTv)));
                if (GetFavoritesNumber(hTv) >= GetFavoritesMaxNumber()) {
                    ErrorMessageBox(hDlg, IDS_ERROR_MAXFAVS);
                    break;
                }

                NewFolder(hTv);
                break;

            case IDC_MODIFY:
                g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szWorkDir);
                ModifyFavorite(hTv, TreeView_GetSelection(hTv), szWorkDir, g_szTempSign, g_dwPlatformId, g_fIntranet ? IEM_CORP : IEM_NEUTRAL);
                break;

            case IDC_REMOVE:
                g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szWorkDir);
                DeleteFavorite(hTv, TreeView_GetSelection(hTv), szWorkDir);
                break;

            case IDC_TESTFAVURL:
                if (GetFavoriteUrl(hTv, TreeView_GetSelection(hTv), szUrl, countof(szUrl)))
                    TestURL(szUrl);
                break;

            case IDC_IMPORT: {
                CNewCursor cursor(IDC_WAIT);

                g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szWorkDir);
                ImportFavoritesCmd(hTv, szWorkDir);
                break;
                }
            }
        }
        break;

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE:
            SetBannerText(hDlg);

            g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szWorkDir);
            PathCreatePath(szWorkDir);

            ASSERT(GetFavoritesNumber(hTv, FALSE) == 0 && GetFavoritesNumber(hTv, TRUE) == 0);
            ImportFavorites (hTv, g_szDefInf, g_szCustIns, szWorkDir, g_szTempSign, !g_fIntranet);
            ImportQuickLinks(hTv, g_szDefInf, g_szCustIns, szWorkDir, g_szTempSign, !g_fIntranet);

            TreeView_SelectItem(hTv, TreeView_GetRoot(hTv));

            fFavoritesOnTop = GetPrivateProfileInt(IS_BRANDING, IK_FAVORITES_ONTOP, (int)FALSE, g_szCustIns);
            CheckDlgButton(hDlg, IDC_FAVONTOP, fFavoritesOnTop ? BST_CHECKED : BST_UNCHECKED);

            //delete channels checkbox
            if (g_fIntranet)
            {
                EnableDlgItem(hDlg, IDC_DELETECHANNELS);
                ShowDlgItem  (hDlg, IDC_DELETECHANNELS);
                ReadBoolAndCheckButton(IS_DESKTOPOBJS, IK_DELETECHANNELS, FALSE, g_szCustIns, hDlg, IDC_DELETECHANNELS);
            }
            else
            {
                DisableDlgItem(hDlg, IDC_DELETECHANNELS);
                HideDlgItem   (hDlg, IDC_DELETECHANNELS);
            }

            if (!fFavoritesOnTop) {
                DisableDlgItem(hDlg, IDC_FAVUP);
                DisableDlgItem(hDlg, IDC_FAVDOWN);
            }

            if (g_fIntranet) {
                ShowWindow(GetDlgItem(hDlg, IDC_DELFAVORITES),     SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_DELIEAKFAVORITES), SW_SHOW);

                dwFavoritesDeleteFlags = (DWORD) GetPrivateProfileInt(IS_BRANDING, IK_FAVORITES_DELETE, (int)FD_DEFAULT, g_szCustIns);

                fFavoritesDelete = HasFlag(dwFavoritesDeleteFlags, ~FD_REMOVE_IEAK_CREATED);
                CheckDlgButton(hDlg, IDC_DELFAVORITES, fFavoritesDelete ? BST_CHECKED : BST_UNCHECKED);

                fIEAKFavoritesDelete = HasFlag(dwFavoritesDeleteFlags, FD_REMOVE_IEAK_CREATED);
                CheckDlgButton(hDlg, IDC_DELIEAKFAVORITES, fIEAKFavoritesDelete ? BST_CHECKED : BST_UNCHECKED);

                // only if delete Favorites is TRUE should the delete IEAK Favorites checkbox be enabled
                EnableDlgItem2(hDlg, IDC_DELIEAKFAVORITES, fFavoritesDelete);
            }
            else {
                ShowWindow(GetDlgItem(hDlg, IDC_DELFAVORITES),     SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_DELIEAKFAVORITES), SW_HIDE);
            }
            
            CheckBatchAdvance(hDlg);
            break;

        case TVN_GETINFOTIP:
            ASSERT(wParam == IDC_TREE1);
            GetFavoritesInfoTip((LPNMTVGETINFOTIP)lParam);
            break;

        case NM_DBLCLK:
            ASSERT(wParam == IDC_TREE1);
            if (IsWindowEnabled(GetDlgItem(hDlg, IDC_MODIFY)))
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_MODIFY, BN_CLICKED), (LPARAM)GetDlgItem(hDlg, IDC_MODIFY));
            break;

        case TVN_KEYDOWN:
            ASSERT(wParam == IDC_TREE1);
            if (((LPNMTVKEYDOWN)lParam)->wVKey == VK_DELETE && IsWindowEnabled(GetDlgItem(hDlg, IDC_REMOVE)))
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_REMOVE, BN_CLICKED), (LPARAM)GetDlgItem(hDlg, IDC_REMOVE));
            break;

        case TVN_SELCHANGED:
            ASSERT(wParam == IDC_TREE1);
            ProcessFavSelChange(hDlg, hTv, (LPNMTREEVIEW)lParam);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            fFavoritesOnTop = (IsDlgButtonChecked(hDlg, IDC_FAVONTOP) == BST_CHECKED);

            dwFavoritesDeleteFlags = 0;
            szValue[0]             = TEXT('\0');
            pszValue               = NULL;
            fFavoritesDelete       = (IsDlgButtonChecked(hDlg, IDC_DELFAVORITES)     == BST_CHECKED);
            fIEAKFavoritesDelete   = (IsDlgButtonChecked(hDlg, IDC_DELIEAKFAVORITES) == BST_CHECKED);

            if (fFavoritesDelete) {
                // NOTE. (andrewgu) flags explanation:
                // 1. FD_FAVORITES        means "empty favorites";
                // 2. FD_CHANNELS         means "don't delete channels folder";
                // 3. FD_SOFTWAREUPDATES  means "don't delete sofware updates folder";
                // 4. FD_QUICKLINKS       means "don't delete quick links folder";
                // 5. FD_EMPTY_QUICKLINKS means "but make it empty";
                // 6. FD_REMOVE_HIDDEN    means "don't hesitate to party on HIDDEN folders and favorites";
                // 7. FD_REMOVE_SYSTEM    means "don't hesitate to party on SYSTEM folders and favorites";
                dwFavoritesDeleteFlags |= FD_FAVORITES      |
                    FD_CHANNELS        | FD_SOFTWAREUPDATES | FD_QUICKLINKS | FD_EMPTY_QUICKLINKS |
                    FD_REMOVE_HIDDEN   | FD_REMOVE_SYSTEM;
            }

            //delete channels
            if (g_fIntranet)
                CheckButtonAndWriteBool(hDlg, IDC_DELETECHANNELS, IS_DESKTOPOBJS, IK_DELETECHANNELS, g_szCustIns);
            
            if (fIEAKFavoritesDelete)
                // FD_REMOVE_IEAK_CREATED means "delete those items created by the IEAK";
                dwFavoritesDeleteFlags |= FD_REMOVE_IEAK_CREATED;

            if (dwFavoritesDeleteFlags) {
                wnsprintf(szValue, countof(szValue), TEXT("0x%X"), dwFavoritesDeleteFlags);
                pszValue = szValue;
            }

            WritePrivateProfileString(IS_BRANDING, IK_FAVORITES_DELETE, pszValue, g_szCustIns);
            WritePrivateProfileString(IS_BRANDING, IK_FAVORITES_ONTOP, fFavoritesOnTop ? TEXT("1") : TEXT("0"), g_szCustIns);

            g_cmCabMappings.GetFeatureDir(FEATURE_FAVORITES, szWorkDir);
            ExportFavorites (hTv, g_szCustIns, szWorkDir, TRUE);
            ExportQuickLinks(hTv, g_szCustIns, szWorkDir, TRUE);

            if (!g_fBatch)
            {
                // (pritobla) if in batch mode, no need to export to the old IE4 format
                // because there is no scenario that the ms install.ins will be installed
                // without the IE6 branding dll.
                MigrateToOldFavorites(g_szCustIns);
            }

            DeleteFavorite(hTv, TreeView_GetRoot(hTv), NULL);
            DeleteFavorite(hTv, TreeView_GetRoot(hTv), NULL);

            g_iCurPage = PPAGE_FAVORITES;
            EnablePages();
            if (((LPNMHDR)lParam)->code != PSN_WIZBACK)
                PageNext(hDlg);
            else
                PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            if (QueryCancel(hDlg)) {
                DeleteFavorite(hTv, TreeView_GetRoot(hTv), NULL);
                DeleteFavorite(hTv, TreeView_GetRoot(hTv), NULL);
            }
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//
//  FUNCTION: Welcome(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for welcome page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
BOOL APIENTRY Welcome(
    HWND hDlg,
    UINT message,
    WPARAM,
    LPARAM lParam)
{
    static fInitWindowPos = FALSE;

    switch (message)
    {
        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_INITDIALOG:
            LoadString(g_rvInfo.hInst, IDS_TITLE, g_szTitle, countof(g_szTitle));
            SetWindowText(g_hWndCent, g_szTitle);
            g_hWizard = hDlg;
            return(TRUE);

            case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    TCHAR szWizardVer[MAX_PATH];
                    TCHAR szType[MAX_PATH];
                    TCHAR  szTemp1[MAX_PATH], szTemp2[MAX_PATH];

                    SetBannerText(hDlg);

                    LoadString(g_rvInfo.hInst,IDS_WIZARDTYPETEXT,szWizardVer,countof(szWizardVer));
                    switch (s_iType)
                    {
                        case BRANDED:
                            LoadString(g_rvInfo.hInst,IDS_ISPTYPE,szType,countof(szType));
                            break;
                        case REDIST:
                            LoadString(g_rvInfo.hInst,IDS_ICPTYPE,szType,countof(szType));
                            break;
                        case INTRANET:
                        default:
                            LoadString(g_rvInfo.hInst,IDS_CORPTYPE,szType,countof(szType));
                            break;
                    }   

                    wnsprintf(szTemp1,countof(szTemp1),szWizardVer,szType);
                    wnsprintf(szTemp2,countof(szTemp2),s_szBannerText,szTemp1);

                    StrCpy(s_szBannerText,szTemp2);
                    
                    ChangeBannerText(hDlg);
                    PropSheet_SetTitle(hDlg, 0, s_aSzTitle[g_iCurPage]);
                    if (g_fDone)
                    {
                        EndDialog(hDlg, 0);
                        return FALSE;
                    }
                    if(!fInitWindowPos)
                    {
                        PositionWindow(GetParent(hDlg));
                        ShowWindow(GetParent(hDlg), SW_SHOWNORMAL);
                        fInitWindowPos = TRUE;
                    }
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;
            }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

//
//  FUNCTION: Stage(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for welcome page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
BOOL APIENTRY Stage(
    HWND hDlg,
    UINT message,
    WPARAM,
    LPARAM lParam)
{
    switch (message)
    {
        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_INITDIALOG:
            return(FALSE);

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    PropSheet_SetTitle(hDlg, 0, s_aSzTitle[g_iCurPage]);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                        PageNext(hDlg);
                    else
                        PagePrev(hDlg);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;
            }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

static UINT_PTR s_idTim;

BOOL CALLBACK BrandTitle(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szFullTitle[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    DWORD dwTitlePrefixLen;
    BOOL  fTitle;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_TITLE);

        LoadString(g_rvInfo.hInst, IDS_TITLE_PREFIX, szTitle, countof(szTitle));
        dwTitlePrefixLen = StrLen(szTitle);
        // browser will only display 74 chars before cutting off title
        Edit_LimitText(GetDlgItem(hDlg, IDE_TITLE), 74 - dwTitlePrefixLen);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
        case PSN_SETACTIVE:
            SetBannerText(hDlg);

            // title
            InsGetString(IS_BRANDING, TEXT("Window_Title_CN"), szTitle, countof(szTitle), 
                g_szCustIns, NULL, &fTitle);
            if (!fTitle  &&  *szTitle == '\0')
                InsGetString(IS_BRANDING, TEXT("CompanyName"), szTitle, countof(szTitle), g_szCustIns);

            SetDlgItemTextTriState(hDlg, IDE_TITLE, IDC_TITLE, szTitle, fTitle);
            EnableDlgItem2(hDlg, IDC_TITLE_TXT, fTitle);

            CheckBatchAdvance(hDlg);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            // title
            if (g_fBatch)
            {
                InsGetString(TEXT("BatchMode"), IK_WINDOWTITLE, szFullTitle, countof(szFullTitle), g_szCustIns);
                InsWriteString(IS_BRANDING, IK_WINDOWTITLE, szFullTitle, g_szCustIns, TRUE, NULL, INSIO_TRISTATE);

                InsGetString(TEXT("BatchMode"), TEXT("Window_Title_OE"), szFullTitle, countof(szFullTitle), g_szCustIns);
                InsWriteString(IS_INTERNETMAIL, IK_WINDOWTITLE, szFullTitle, g_szCustIns, TRUE, NULL, INSIO_TRISTATE);
            }
            else
            {
                fTitle = GetDlgItemTextTriState(hDlg, IDE_TITLE, IDC_TITLE, szTitle, countof(szTitle));
                InsWriteString(IS_BRANDING, TEXT("Window_Title_CN"), szTitle, g_szCustIns, fTitle, NULL, INSIO_SERVERONLY | INSIO_TRISTATE);

                // browser title
                *szFullTitle = TEXT('\0');
                if (*szTitle)
                {
                    *szTemp = TEXT('\0');

                    InsGetString(IS_STRINGS, TEXT("IE_TITLE"), szTemp, countof(szTemp), g_szDefInf);

                    if (*szTemp)
                        wnsprintf(szFullTitle, countof(szFullTitle), szTemp, szTitle);
                }
                InsWriteString(IS_BRANDING, IK_WINDOWTITLE, szFullTitle, g_szCustIns, fTitle, NULL, INSIO_TRISTATE);

                // OE title
                *szFullTitle = TEXT('\0');
                if (*szTitle)
                {
                    *szTemp = TEXT('\0');

                    InsGetString(IS_STRINGS, TEXT("OE_TITLE"), szTemp, countof(szTemp), g_szDefInf);

                    if (*szTemp)
                        wnsprintf(szFullTitle, countof(szFullTitle), szTemp, szTitle);
                }
                InsWriteString(IS_INTERNETMAIL, IK_WINDOWTITLE, szFullTitle, g_szCustIns, fTitle, NULL, INSIO_TRISTATE);
            }

            g_iCurPage = PPAGE_TITLE;
            EnablePages();
            (((LPNMHDR) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            QueryCancel(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_TITLE:
            fTitle = (IsDlgButtonChecked(hDlg, IDC_TITLE) == BST_CHECKED);
            EnableDlgItem2(hDlg, IDC_TITLE_TXT, fTitle);
            EnableDlgItem2(hDlg, IDE_TITLE,     fTitle);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL CALLBACK WelcomeMessageDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szInitHomePage[INTERNET_MAX_URL_LENGTH];
    INT   id;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_WELCOMEURL);
        Edit_LimitText(GetDlgItem(hDlg, IDE_WELCOMEURL), countof(szInitHomePage) - 1);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
        case PSN_SETACTIVE:
            SetBannerText(hDlg);

            g_fUseIEWelcomePage = !InsGetBool(IS_URL, IK_NO_WELCOME_URL, FALSE, g_szCustIns);
            InsGetString(IS_URL, IK_FIRSTHOMEPAGE, szInitHomePage, countof(szInitHomePage), g_szCustIns);

            if (g_fUseIEWelcomePage)
                id = IDC_WELCOMEDEF;
            else
                id = (*szInitHomePage ? IDC_WELCOMECUST : IDC_WELCOMENO);

            CheckRadioButton(hDlg, IDC_WELCOMEDEF, IDC_WELCOMECUST, id);

            if (id == IDC_WELCOMECUST)
            {
                SetDlgItemText(hDlg, IDE_WELCOMEURL, szInitHomePage);
                EnableDlgItem (hDlg, IDE_WELCOMEURL);
            }
            else
                DisableDlgItem(hDlg, IDE_WELCOMEURL);

            CheckBatchAdvance(hDlg);
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            // if custom home page radio button is checked, verify that a URL is specified
            if (IsDlgButtonChecked(hDlg, IDC_WELCOMECUST) == BST_CHECKED)
                if (!CheckField(hDlg, IDE_WELCOMEURL, FC_NONNULL | FC_URL))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE;
                }

            g_fUseIEWelcomePage = (IsDlgButtonChecked(hDlg, IDC_WELCOMEDEF) == BST_CHECKED);
            InsWriteBool(IS_URL, IK_NO_WELCOME_URL, !g_fUseIEWelcomePage, g_szCustIns);

            GetDlgItemText(hDlg, IDE_WELCOMEURL, szInitHomePage, countof(szInitHomePage));
            InsWriteString(IS_URL, IK_FIRSTHOMEPAGE, szInitHomePage, g_szCustIns);

            g_iCurPage = PPAGE_WELCOMEMSGS;
            EnablePages();
            (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
            break;

        case PSN_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case PSN_QUERYCANCEL:
            QueryCancel(hDlg);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_WELCOMENO:
        case IDC_WELCOMEDEF:
            SetDlgItemText(hDlg, IDE_WELCOMEURL, TEXT(""));
            DisableDlgItem(hDlg, IDE_WELCOMEURL);
            break;

        case IDC_WELCOMECUST:
            EnableDlgItem(hDlg, IDE_WELCOMEURL);
            break;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void LoadInsFile(LPCTSTR pcszNewInsFile)
{
    TCHAR szSrcPath[MAX_PATH];
    TCHAR szDestDir[MAX_PATH];
    TCHAR szPlatform[8];
    TCHAR szFilePath[MAX_PATH];
    TCHAR szData[8];

    CopyFile(pcszNewInsFile, g_szCustIns, FALSE);

    SetFileAttributes(g_szCustIns, FILE_ATTRIBUTE_NORMAL);
    StrCpy(szSrcPath, pcszNewInsFile);
    PathRemoveFileSpec(szSrcPath);
    StrCpy(szDestDir, g_szCustIns);
    PathRemoveFileSpec(szDestDir);

    // make sure platform info is correct

    wnsprintf(szPlatform, countof(szPlatform), TEXT("%lu"), g_dwPlatformId);
    WritePrivateProfileString(BRANDING, TEXT("Platform"), szPlatform, g_szCustIns);

    // the delete adms flag will be cleared out when we hit next on the adm page

    WritePrivateProfileString(IS_BRANDING, TEXT("DeleteAdms"), TEXT("1"), g_szCustIns);
    WritePrivateProfileString(IS_BRANDING, TEXT("ImportIns"), pcszNewInsFile, g_szCustIns);

    // branding.cab file is cross platform

    CopyFilesSrcToDest(szSrcPath, TEXT("BRANDING.CAB"), szDestDir);

    PathCombine(szFilePath, szSrcPath, TEXT("iesetup.inf"));

    // only copy over iesetup.inf if it's also a win32 inf
    if (GetPrivateProfileString(OPTIONS, TEXT("CifName"), TEXT(""), szData, countof(szData), szFilePath))
        CopyFilesSrcToDest(szSrcPath, TEXT("iesetup.inf"), szDestDir);


    CopyFilesSrcToDest(szSrcPath, TEXT("iak.ini"), szDestDir);
    CopyFilesSrcToDest(szSrcPath, TEXT("iesetup.cif"), szDestDir);
    CopyFilesSrcToDest(szSrcPath, TEXT("custom.cif"), szDestDir);
    CopyFilesSrcToDest(szSrcPath, TEXT("DESKTOP.CAB"), szDestDir);
    CopyFilesSrcToDest(szSrcPath, TEXT("CHNLS.CAB"), szDestDir);
    SetAttribAllEx(szDestDir, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, FALSE);

    // clear out CMAK guid when importing so we'll generate a new one for this package

    PathCombine(szFilePath, szDestDir, TEXT("custom.cif"));
    WritePrivateProfileString( CUSTCMSECT, TEXT("GUID"), NULL, szFilePath );
    WritePrivateProfileString( CUSTCMSECT, VERSION, NULL, szFilePath );

    // copy singup files
    // BUGBUG: pritobla- should implement a function in ieakutil to xcopy a folder (including its subdirs)
    //                   to another location and use that function here.
    PathAppend(szSrcPath, TEXT("signup"));
    PathAppend(szDestDir, TEXT("signup"));

    PathAppend(szSrcPath, TEXT("icw"));
    PathAppend(szDestDir, TEXT("icw"));
    CopyFilesSrcToDest(szSrcPath, TEXT("*.*"), szDestDir);

    PathRemoveFileSpec(szSrcPath);
    PathRemoveFileSpec(szDestDir);

    PathAppend(szSrcPath, TEXT("kiosk"));
    PathAppend(szDestDir, TEXT("kiosk"));
    CopyFilesSrcToDest(szSrcPath, TEXT("*.*"), szDestDir);

    PathRemoveFileSpec(szSrcPath);
    PathRemoveFileSpec(szDestDir);

    PathAppend(szSrcPath, TEXT("servless"));
    PathAppend(szDestDir, TEXT("servless"));
    CopyFilesSrcToDest(szSrcPath, TEXT("*.*"), szDestDir);
}

//
//  FUNCTION: Language(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "Language" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//  WM_COMMAND - saves the id of the choice selected
//
BOOL APIENTRY Language(
    HWND hDlg,
    UINT message,
    WPARAM,
    LPARAM lParam)
{
    TCHAR szBuf[1024];
    int i;
    static BOOL s_fNext = TRUE;
    TCHAR szTemp[MAX_PATH];
    DWORD dwSelLangId;

    USES_CONVERSION;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            InitSysFont( hDlg, IDC_LANGUAGE);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            //from the download pg
            if (!g_fUrlsInit && !g_fBatch && !g_fBatch2 && !g_hWait && g_hDownloadEvent && !g_fLocalMode)
            {
                g_hWizard = hDlg;
                g_hWait = CreateDialog( g_rvInfo.hInst, MAKEINTRESOURCE(IDD_WAITSITES), hDlg,
                    (DLGPROC) DownloadStatusDlgProc );
                ShowWindow( g_hWait, SW_SHOWNORMAL );
                PropSheet_SetWizButtons(GetParent(hDlg), 0 );
                g_iDownloadState = DOWN_STATE_ENUM_URL;
                g_hDlg = hDlg;
                SetEvent(g_hDownloadEvent);
            }

            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case IDM_INITIALIZE:
            if (g_hWait && g_fLangInit)
            {
                SendMessage(g_hWait, WM_CLOSE, 0, 0);
                g_hWait = NULL;
            }
            break;

        // this resets the focus away from cancel when we disable back/next

        case IDM_SETDEFBUTTON:
            SetFocus( GetDlgItem( GetParent(hDlg), IDC_STATIC ) );
            SendMessage(GetParent(hDlg), DM_SETDEFID, (WPARAM)IDC_STATIC, (LPARAM)0);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    if (!g_fLangInit && !g_fBatch && !g_fBatch2)
                    {
                        DWORD dwTid;
                        g_iDownloadState = DOWN_STATE_ENUM_LANG;
                        g_hDlg = hDlg;
                        PropSheet_SetWizButtons(GetParent(hDlg), 0);
                        if (!g_fLocalMode)
                        {
                            g_hWait = CreateDialog(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_WAITSITES), hDlg,
                                (DLGPROC)DownloadStatusDlgProc);
                            ShowWindow( g_hWait, SW_SHOWNORMAL );
                        }
                        g_hThread = CreateThread(NULL, 4096, DownloadSiteThreadProc, &g_hWizard, 0, &dwTid);
                        PostMessage(hDlg, IDM_SETDEFBUTTON, 0, 0);
                        break;
                    }

                    if (g_fOptCompInit)
                        DisableDlgItem(hDlg, IDC_LANGUAGE);

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                    if (!g_nLangs && !g_fBatch && !g_fBatch2)
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        g_fCancelled = FALSE;
                        return(TRUE);
                    }
                    
                    //original processing

                    dwSelLangId = 1033;
                    if (!g_fBatch && !g_fBatch2)
                    {
                        i = (int) SendDlgItemMessage( hDlg, IDC_LANGUAGE, CB_GETCURSEL, 0, 0 );

                        StrCpy(g_szLanguage + 1, g_aszLang[i]);
                        *g_szLanguage = g_szLanguage[3] = TEXT('\\');
                        g_szLanguage[4] = TEXT('\0');
                        dwSelLangId = g_aLangId[i];

                        if (StrCmpI(g_szActLang, g_aszLang[i]) != 0)
                        {
                            s_fAppendLang = TRUE;
                            g_fSrcDirChanged = TRUE;
                            StrCpy(g_szActLang, g_aszLang[i]);
                        }
                        if (s_fAppendLang)
                        {
                            PathCombine(g_szIEAKProg, s_szSourceDir, &g_szLanguage[1]);
                            if (!PathFileExists(g_szIEAKProg))
                                PathCreatePath(g_szIEAKProg);
                            s_fAppendLang = FALSE;
                        }
                    }
                    CharUpper(g_szLanguage);
                    CharUpper(g_szActLang);

                    StrCpy(szBuf, g_szLanguage + 1);
                    szBuf[lstrlen(szBuf) - 1] = TEXT('\0');

                    GenerateCustomIns();

                    if (ISNONNULL(g_szLoadedIns) && s_fLoadIns)
                    {
                        TCHAR szLoadLang[8];

                        s_fLoadIns = FALSE;
                        if (GetPrivateProfileString(IS_BRANDING, LANG_LOCALE, TEXT(""),
                            szLoadLang, countof(szLoadLang), g_szLoadedIns) && (StrCmpI(szLoadLang, g_szActLang) != 0))
                        {
                            TCHAR szMsgParam[MAX_PATH];
                            TCHAR szMsg[MAX_PATH*2];

                            LoadString(g_rvInfo.hInst, IDS_LANGDIFFERS, szMsgParam, countof(szMsgParam));
                            wnsprintf(szMsg, countof(szMsg), szMsgParam, g_szLoadedIns);

                            if (MessageBox(hDlg, szMsg, g_szTitle, MB_YESNO) == IDNO)
                            {
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                                return TRUE;
                            }
                        }

                        LoadInsFile(g_szLoadedIns);
                    }

                    wnsprintf(s_szType, countof(s_szType), TEXT("%i"), s_iType);
                    WritePrivateProfileString(BRANDING, TEXT("Type"), s_szType, g_szCustIns);
                    WritePrivateProfileString( BRANDING, IK_WIZVERSION, A2CT(VER_PRODUCTVERSION_STR), g_szCustIns );
                    //clear others so we know this is wizard
                    WritePrivateProfileString(BRANDING, PMVERKEY, NULL, g_szCustIns);
                    WritePrivateProfileString(BRANDING, GPVERKEY, NULL, g_szCustIns);
                    StrCpy(szTemp, g_szKey);
                    szTemp[7] = TEXT('\0');
                    WritePrivateProfileString( BRANDING, TEXT("Custom_Key"), szTemp, g_szCustIns );
                    if (*(g_rvInfo.pszName) == 0)
                        GetPrivateProfileString(BRANDING, TEXT("CompanyName"), TEXT(""), g_rvInfo.pszName, countof(g_rvInfo.pszName), g_szCustIns);
                    WritePrivateProfileString(BRANDING, TEXT("CompanyName"), g_rvInfo.pszName, g_szCustIns);

                    if (g_iKeyType < KEY_TYPE_ENHANCED)
                    {
                        WritePrivateProfileString( TEXT("Animation"), NULL, NULL, g_szCustIns );
                        WritePrivateProfileString( TEXT("Big_Logo"), NULL, NULL, g_szCustIns );
                        WritePrivateProfileString( TEXT("Small_Logo"), NULL, NULL, g_szCustIns );
                    }
                    if (!g_fBatch)
                    {
                        TCHAR szLngID[16];

                        wnsprintf(szLngID, countof(szLngID), TEXT("%lu"), dwSelLangId);
                        WritePrivateProfileString(BRANDING, LANG_LOCALE, g_szActLang, g_szCustIns);
                        WritePrivateProfileString(BRANDING, LANG_ID, szLngID, g_szCustIns);
                    }

                    g_iCurPage = PPAGE_LANGUAGE;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT)
                    {
                        s_fNext = FALSE;
                        PageNext(hDlg);
                    }
                    else
                    {
                        s_fNext = TRUE;
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;

        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

BOOL CALLBACK StartSearch(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fStartPage, fSearchPage, fSupportPage;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_STARTPAGE);
        EnableDBCSChars(hDlg, IDE_SEARCHPAGE);
        EnableDBCSChars(hDlg, IDE_CUSTOMSUPPORT);

        Edit_LimitText(GetDlgItem(hDlg, IDE_STARTPAGE),     INTERNET_MAX_URL_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_SEARCHPAGE),    INTERNET_MAX_URL_LENGTH - 1);
        Edit_LimitText(GetDlgItem(hDlg, IDE_CUSTOMSUPPORT), INTERNET_MAX_URL_LENGTH - 1);
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code)
        {
            case PSN_SETACTIVE:
                SetBannerText(hDlg);

                InitializeStartSearch(hDlg, g_szCustIns, NULL);

                CheckBatchAdvance(hDlg);
                break;

            case PSN_WIZBACK:
            case PSN_WIZNEXT:
                fStartPage   = (IsDlgButtonChecked(hDlg, IDC_STARTPAGE)     == BST_CHECKED);
                fSearchPage  = (IsDlgButtonChecked(hDlg, IDC_SEARCHPAGE)    == BST_CHECKED);
                fSupportPage = (IsDlgButtonChecked(hDlg, IDC_CUSTOMSUPPORT) == BST_CHECKED);

                if ((fStartPage    &&  !CheckField(hDlg, IDE_STARTPAGE,     FC_URL))  ||
                    (fSearchPage   &&  !CheckField(hDlg, IDE_SEARCHPAGE,    FC_URL))  ||
                    (fSupportPage  &&  !CheckField(hDlg, IDE_CUSTOMSUPPORT, FC_URL)))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE;
                }

                SaveStartSearch(hDlg, g_szCustIns, NULL);

                g_iCurPage = PPAGE_STARTSEARCH;
                EnablePages();
                (((LPNMHDR) lParam)->code == PSN_WIZNEXT) ? PageNext(hDlg) : PagePrev(hDlg);
                break;

            case PSN_HELP:
                IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                break;

            case PSN_QUERYCANCEL:
                QueryCancel(hDlg);
                break;

            default:
                return FALSE;
        }
        break;

    case WM_COMMAND:
        if (GET_WM_COMMAND_CMD(wParam, lParam) != BN_CLICKED)
            return FALSE;

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_STARTPAGE:
                fStartPage = (IsDlgButtonChecked(hDlg, IDC_STARTPAGE) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_STARTPAGE, fStartPage);
                EnableDlgItem2(hDlg, IDC_STARTPAGE_TXT, fStartPage);
                break;

            case IDC_SEARCHPAGE:
                fSearchPage = (IsDlgButtonChecked(hDlg, IDC_SEARCHPAGE) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_SEARCHPAGE, fSearchPage);
                EnableDlgItem2(hDlg, IDC_SEARCHPAGE_TXT, fSearchPage);
                break;

            case IDC_CUSTOMSUPPORT:
                fSupportPage = (IsDlgButtonChecked(hDlg, IDC_CUSTOMSUPPORT) == BST_CHECKED);
                EnableDlgItem2(hDlg, IDE_CUSTOMSUPPORT, fSupportPage);
                EnableDlgItem2(hDlg, IDC_CUSTOMSUPPORT_TXT, fSupportPage);
                break;

            default:
                return FALSE;
        }
        break;

    case WM_HELP:
        IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
        break;

    case IDM_BATCHADVANCE:
        DoBatchAdvance(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL APIENTRY Finish(HWND hDlg, UINT message, WPARAM, LPARAM lParam)
{
    TCHAR szPlatform[8];
    TCHAR szWinDir[MAX_PATH];
    static s_fFinished = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            if (s_fFinished)
                EnableDBCSChars(hDlg, IDC_FINISHTXT3);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case WM_COMMAND:
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);
                    if (!s_fFinished)
                    {
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                        ShowWindow(GetDlgItem(hDlg, IDC_FINISHTXT1), SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDC_STEP1), SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDC_STEP3), SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS), SW_HIDE);
                        CheckBatchAdvance(hDlg);
                    }
                    else
                    {
                        SetWindowText(GetDlgItem(hDlg, IDC_FINISHTXT3), g_szBuildRoot);
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);

                        if (g_fBatch || g_fBatch2)
                            PostMessage(GetParent(hDlg), PSM_PRESSBUTTON, PSBTN_FINISH, 0);
                    }
                    break;

                case PSN_WIZBACK:
                    PagePrev(hDlg);
                    break;

                case PSN_WIZNEXT:
                    if (!g_fCancelled && !g_fDemo)
                    {
                        CNewCursor cur(IDC_WAIT);
                        HANDLE hThread;
                        DWORD dwTid;

                        wnsprintf(szPlatform, countof(szPlatform), TEXT("%lu"), g_dwPlatformId);
                        WritePrivateProfileString(BRANDING, TEXT("Platform"), szPlatform, g_szCustIns);

                        ShowWindow(GetDlgItem(hDlg, IDC_FINISHTXT1), SW_SHOW);
                        ShowWindow(GetDlgItem(hDlg, IDC_STEP1), SW_SHOW);
                        ShowWindow(GetDlgItem(hDlg, IDC_STEP3), SW_SHOW);
                        ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS), SW_SHOW);
                        PropSheet_SetWizButtons(GetParent(hDlg), 0);
                        DisableDlgItem(GetParent(hDlg), IDHELP);
                        DisableDlgItem(GetParent(hDlg), IDCANCEL);

                        Animate_Open( GetDlgItem( hDlg, IDC_ANIM ), IDA_GEARS );
                        Animate_Play( GetDlgItem( hDlg, IDC_ANIM ), 0, -1, -1 );

                        SetAttribAllEx(g_szBuildRoot, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, TRUE);
                        g_fCancelled = TRUE;
                        GetWindowsDirectory(szWinDir, MAX_PATH);
                        memset(&g_shfStruc, 0, sizeof(g_shfStruc));
                        g_shfStruc.hwnd = hDlg;
                        g_shfStruc.wFunc = FO_COPY;
                        SetAttribAllEx(g_szBuildTemp, TEXT("*.*"), FILE_ATTRIBUTE_NORMAL, TRUE);

                        hThread = CreateThread(NULL, 4096, BuildIE4, hDlg, 0, &dwTid);

                        while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
                        {
                            MSG msg;
                            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }

                        CloseHandle(hThread);

                        // this sets the last 'platform/language' package built in this build directory.
                        // its used to get the settings used in the last .ins file.
                        {
                            TCHAR szPlatformLang[MAX_PATH];
                            TCHAR szRegKey[MAX_PATH];

                            wnsprintf(szRegKey, countof(szRegKey), TEXT("%s\\INS"), RK_IEAK_SERVER);
                            wnsprintf(szPlatformLang, countof(szPlatformLang), TEXT("%s%s"), GetOutputPlatformDir(), g_szActLang);
                            SHSetValue(HKEY_CURRENT_USER, szRegKey, g_szBuildRoot, REG_SZ, (LPBYTE)szPlatformLang,
                                (StrLen(szPlatformLang)+1)*sizeof(TCHAR));
                        }
                    }

                    if (g_fDemo)
                    {
                        TCHAR szMsg[MAX_PATH];
                        SetCurrentDirectory(g_szBuildRoot);
                        PathRemovePath(g_szBuildTemp);
                        LoadString( g_rvInfo.hInst, IDS_ENDEMO, szMsg, countof(szMsg) );
                        MessageBox(hDlg, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
                        g_fDone = TRUE;
                        SetEvent(g_hDownloadEvent);
                    }
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);
                    g_fCancelled = TRUE;
                    s_fFinished = TRUE;
                    break;

                case PSN_WIZFINISH:
                    break;

                case PSN_QUERYCANCEL:
                    if (IsWindowEnabled(GetDlgItem(GetParent(hDlg), IDCANCEL)))
                        QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

#define OLDPRSHTSIZE 0x28
#define OLDPPAGESIZE 0x28

#define SSF_ALL SSF_SHOWALLOBJECTS | SSF_SHOWEXTENSIONS | SSF_SHOWCOMPCOLOR | SSF_SHOWSYSFILES | SSF_DESKTOPHTML | SSF_WIN95CLASSIC

void FillInPropertyPage(int iPsp, WORD idDlg, DLGPROC pfnDlgProc)
{
    LPPROPSHEETPAGE pPsp;
    TCHAR           szPage[MAX_PATH];
    LPDLGTEMPLATE   pDlg;

    if (iPsp < 0 || iPsp > NUM_PAGES)
        return;

    if (idDlg == 0)
        return;

    if (pfnDlgProc == NULL)
        return;

    pDlg = NULL;

    LoadString(g_rvInfo.hInst, IDS_TITLE, szPage, countof(szPage));

    if (iPsp != PPAGE_WELCOME && iPsp != PPAGE_OCWWELCOME && iPsp != PPAGE_FINISH)
    {
        TCHAR szStage[MAX_PATH];

        if (iPsp < PPAGE_STAGE2)
            LoadString(g_rvInfo.hInst, IDS_STAGE1, szStage, countof(szStage));
        else
        {
            if (iPsp < PPAGE_STAGE3)
                LoadString(g_rvInfo.hInst, IDS_STAGE2, szStage, countof(szStage));
            else
            {
                if (iPsp < PPAGE_STAGE4)
                    LoadString(g_rvInfo.hInst, IDS_STAGE3, szStage, countof(szStage));
                else
                {
                    if (iPsp < PPAGE_STAGE5)
                        LoadString(g_rvInfo.hInst, IDS_STAGE4, szStage, countof(szStage));
                    else
                        LoadString(g_rvInfo.hInst, IDS_STAGE5, szStage, countof(szStage));
                }
            }
        }

        StrCpy(s_aSzTitle[iPsp], szStage);
    }
    else
        StrCpy(s_aSzTitle[iPsp], szPage);

    pPsp = &g_psp[iPsp];
    ZeroMemory(pPsp, sizeof(PROPSHEETPAGE));

    pPsp->dwSize      = sizeof(PROPSHEETPAGE);
    pPsp->dwFlags     = PSP_USETITLE | PSP_HASHELP;
    pPsp->hInstance   = g_rvInfo.hInst;
    pPsp->pfnDlgProc  = pfnDlgProc;
    pPsp->pszTitle    = s_aSzTitle[iPsp];
    pPsp->pszTemplate = MAKEINTRESOURCE(idDlg);

/*    if (!IsTahomaFontExist(g_hWndCent))
    {
        pPsp->dwFlags   |= PSP_DLGINDIRECT;
        pPsp->pResource  = pDlg;
    }*/

    s_ahPsp[iPsp] = CreatePropertySheetPage(pPsp);
}

int CreateWizard(HWND hwndOwner)
{
    PROPSHEETHEADER psh;
    LPTSTR pLastSlash;

    GetModuleFileName(GetModuleHandle(NULL), g_szWizPath, MAX_PATH);
    pLastSlash = StrRChr(g_szWizPath, NULL, TEXT('\\'));
    if (pLastSlash)
    {
        pLastSlash[1] = TEXT('\0');
    }
    StrCpy(g_szWizRoot, g_szWizPath);
    CharUpper(g_szWizRoot);
    pLastSlash = StrStr(g_szWizRoot, TEXT("IEBIN"));
    if (pLastSlash) *pLastSlash = TEXT('\0');

    LoadString( g_rvInfo.hInst, IDS_TITLE, g_szTitle, countof(g_szTitle) );

    ZeroMemory(&psh, sizeof(psh));
    if(!g_fOCW)
        FillInPropertyPage( PPAGE_WELCOME, IDD_WELCOME, (DLGPROC) Welcome);
    else
        FillInPropertyPage( PPAGE_OCWWELCOME, IDD_OCWWELCOME, (DLGPROC) Welcome);

    FillInPropertyPage( PPAGE_STAGE1, IDD_STAGE1, (DLGPROC) Stage);
    FillInPropertyPage( PPAGE_TARGET, IDD_TARGET, (DLGPROC) TargetProc);
    FillInPropertyPage( PPAGE_LANGUAGE, IDD_LANGUAGE, (DLGPROC)Language);
    FillInPropertyPage( PPAGE_MEDIA, IDD_MEDIA, (DLGPROC)MediaDlgProc);
    FillInPropertyPage( PPAGE_IEAKLITE, IDD_IEAKLITE, (DLGPROC) IEAKLiteProc);

    FillInPropertyPage( PPAGE_STAGE2, IDD_STAGE2, (DLGPROC) Stage);
    FillInPropertyPage( PPAGE_OPTDOWNLOAD, IDD_OPTDOWNLOAD, (DLGPROC) OptionalDownload);
    FillInPropertyPage( PPAGE_CUSTCOMP, IDD_CUSTCOMP4, (DLGPROC) CustomComponents);

    FillInPropertyPage( PPAGE_STAGE3, IDD_STAGE3, (DLGPROC) Stage);
    FillInPropertyPage( PPAGE_ISKBACK, IDD_ISKBACKBITMAP, (DLGPROC) ISKBackBitmap);
    FillInPropertyPage( PPAGE_CDINFO, IDD_CD, (DLGPROC) CDInfoProc);
    FillInPropertyPage( PPAGE_SETUPWIZARD, IDD_SETUPWIZARD, (DLGPROC) ActiveSetupDlgProc);
    FillInPropertyPage( PPAGE_ICM, IDD_ICM, (DLGPROC) InternetConnMgr);
    FillInPropertyPage( PPAGE_COMPSEL, IDD_COMPSEL4, (DLGPROC) ComponentSelect);
    FillInPropertyPage( PPAGE_COMPURLS, IDD_COMPURLS, (DLGPROC)ComponentUrls);
    FillInPropertyPage( PPAGE_ADDON, IDD_ADDON, (DLGPROC) AddOnDlgProc);
    FillInPropertyPage( PPAGE_CORPCUSTOM, IDD_CORPCUSTOM, (DLGPROC) CorpCustomizeCustom);
    FillInPropertyPage( PPAGE_CUSTOMCUSTOM, IDD_CUSTOMCUSTOM, (DLGPROC) CustomizeCustom);
    FillInPropertyPage( PPAGE_COPYCOMP, IDD_COPYCOMP, (DLGPROC) CopyComp);
    FillInPropertyPage( PPAGE_CABSIGN, IDD_CABSIGN, (DLGPROC) CabSignDlgProc);

    FillInPropertyPage( PPAGE_STAGE4, IDD_STAGE4, (DLGPROC) Stage);
    FillInPropertyPage( PPAGE_OCWSTAGE2, IDD_OCWSTAGE2, (DLGPROC) Stage);
    FillInPropertyPage( PPAGE_INSTALLDIR, IDD_INSTALLDIR, (DLGPROC)InstallDirectory);
    FillInPropertyPage( PPAGE_SILENTINSTALL, IDD_SILENTINSTALL, (DLGPROC) SilentInstall);
    FillInPropertyPage( PPAGE_TITLE, IDD_BTITLE, (DLGPROC) BrandTitle);
    FillInPropertyPage( PPAGE_BTOOLBARS, IDD_BTOOLBARS, (DLGPROC) BToolbarProc);
    FillInPropertyPage( PPAGE_CUSTICON, IDD_CUSTICON, (DLGPROC)CustIcon);
    FillInPropertyPage( PPAGE_STARTSEARCH, IDD_STARTSEARCH, (DLGPROC) StartSearch);
    FillInPropertyPage( PPAGE_FAVORITES, IDD_FAVORITES, (DLGPROC) Favorites);
    FillInPropertyPage( PPAGE_WELCOMEMSGS, IDD_WELCOMEMSGS, (DLGPROC) WelcomeMessageDlgProc);
    FillInPropertyPage( PPAGE_UASTRDLG, IDD_UASTRDLG, (DLGPROC) UserAgentString);
    FillInPropertyPage( PPAGE_QUERYAUTOCONFIG, IDD_QUERYAUTOCONFIG, (DLGPROC)QueryAutoConfigDlgProc);
    FillInPropertyPage( PPAGE_PROXY, IDD_PROXY, (DLGPROC)ProxySettings);
    FillInPropertyPage( PPAGE_CONNECTSET, IDD_CONNECTSET, (DLGPROC) ConnectSetDlgProc);

    FillInPropertyPage( PPAGE_QUERYSIGNUP, IDD_QUERYSIGNUP, (DLGPROC)QuerySignupDlgProc);
    FillInPropertyPage( PPAGE_SIGNUPFILES, IDD_SIGNUPFILES, (DLGPROC)SignupFilesDlgProc);
    FillInPropertyPage( PPAGE_SERVERISPS, IDD_SERVERISPS, (DLGPROC)ServerIspsDlgProc);
    FillInPropertyPage( PPAGE_ISPINS, IDD_SIGNUPINS, (DLGPROC)SignupInsDlgProc);
    FillInPropertyPage( PPAGE_ICW, IDD_ICW, (DLGPROC)NewICWDlgProc);

    FillInPropertyPage( PPAGE_ADDROOT, IDD_ADDROOT, (DLGPROC)ISPAddRootCertDlgProc);
    FillInPropertyPage( PPAGE_SECURITYCERT, IDD_SECURITYCERT, (DLGPROC)SecurityCertsDlgProc);
    FillInPropertyPage( PPAGE_SECURITY, IDD_SECURITY1, (DLGPROC) SecurityZonesDlgProc);

    FillInPropertyPage( PPAGE_STAGE5, IDD_STAGE5, (DLGPROC) Stage);
    FillInPropertyPage( PPAGE_PROGRAMS, IDD_PROGRAMS, (DLGPROC)ProgramsDlgProc);
    FillInPropertyPage( PPAGE_MAIL, IDD_MAIL, (DLGPROC)MailServer);
    FillInPropertyPage( PPAGE_IMAP, IDD_IMAP, (DLGPROC)IMAPSettings);
    FillInPropertyPage( PPAGE_PRECONFIG,IDD_PRECONFIG,(DLGPROC)PreConfigSettings);
    FillInPropertyPage( PPAGE_OEVIEW,IDD_OEVIEW,(DLGPROC)ViewSettings);
    FillInPropertyPage( PPAGE_LDAP, IDD_LDAP, (DLGPROC)LDAPServer);
    FillInPropertyPage( PPAGE_OE, IDD_OE, (DLGPROC)CustomizeOE);
    FillInPropertyPage( PPAGE_SIG, IDD_SIG, (DLGPROC)Signature);
    FillInPropertyPage( PPAGE_ADMDESC, IDD_ADMDESC, (DLGPROC) ADMDesc);
    FillInPropertyPage( PPAGE_ADM, IDD_ADM, (DLGPROC) ADMParse);
    FillInPropertyPage( PPAGE_STATUS, IDD_STATUS, (DLGPROC) Finish);
    FillInPropertyPage( PPAGE_FINISH, IDD_FINISH, (DLGPROC)Finish);

    psh.dwSize     = sizeof(PROPSHEETHEADER);
    psh.dwFlags    = PSH_WIZARD | PSH_NOAPPLYNOW | PSH_USEPAGELANG | PSH_USECALLBACK;
    psh.hInstance  = g_rvInfo.hInst;
    psh.hwndParent = hwndOwner;
    psh.pszCaption = TEXT("Review Wizard");
    psh.nPages     = NUM_PAGES;
    psh.nStartPage = 0;
    psh.phpage     = s_ahPsp;
    psh.pfnCallback= &PropSheetProc;

    INT_PTR iResult = PropertySheet(&psh);

/*    if (!IsTahomaFontExist(g_hWndCent))
    {
        for (int i = 0; i < NUM_PAGES; i++) {
            CoTaskMemFree((PVOID)g_psp[i].pResource);
            g_psp[i].pResource = NULL;
        }
    }*/

    return (iResult < 0) ? -1 : 1;
}


BOOL CheckAVS(LPCTSTR pcszDownloadDir)
{
    TCHAR szDownloadDir[MAX_PATH];
    TCHAR szCabFile[MAX_PATH];
    HANDLE hFind = NULL;
    WIN32_FIND_DATA fd;
    static TCHAR s_szLocaleIni[MAX_PATH];

    if (ISNULL(s_szLocaleIni))
        PathCombine(s_szLocaleIni, g_szWizRoot, TEXT("locale.ini"));

    PathCombine(szDownloadDir, pcszDownloadDir, TEXT("*.*"));
    hFind = FindFirstFile(szDownloadDir, &fd);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                || (StrCmp(fd.cFileName, TEXT(".")) == 0)
                || (StrCmp(fd.cFileName, TEXT("..")) == 0))
                continue;

            if (!InsIsKeyEmpty(IS_STRINGS, fd.cFileName, s_szLocaleIni))
            {
                PathCombine(szCabFile, pcszDownloadDir, fd.cFileName);
                PathAppend(szCabFile, TEXT("setupw95.cab"));
                if (PathFileExists(szCabFile))
                {
                    FindClose(hFind);
                    return TRUE;
                }
            }
        }
        while (FindNextFile(hFind, &fd));

        FindClose(hFind);
    }
    return FALSE;
}

BOOL APIENTRY AdvancedDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM)
{
    TCHAR  szTemp[MAX_PATH];
    TCHAR  szTempFile[MAX_PATH];
    DWORD  dwVal;
    BOOL   fLocalMode = TRUE;
    HANDLE hTemp;
    DWORD  dwFlags;

    switch (message)
    {
    case WM_INITDIALOG:
        EnableDBCSChars(hDlg, IDE_LOADINS);
        EnableDBCSChars(hDlg, IDE_SOURCEDIR);
        SetDlgItemText(hDlg, IDE_SOURCEDIR, g_szIEAKProg);
        CheckDlgButton( hDlg, IDC_OFFLINE, g_fLocalMode ? BST_UNCHECKED : BST_CHECKED );

        if (g_fLangInit)
            DisableDlgItem(hDlg, IDC_OFFLINE);

        SetDlgItemText(hDlg, IDE_LOADINS, g_szLoadedIns);
        break;

    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDC_BROWSE:
                {
                    TCHAR szInstructions[MAX_PATH];
                    LoadString(g_rvInfo.hInst,IDS_COMPDLDIR,szInstructions,countof(szInstructions));

                    if (BrowseForFolder(hDlg, szTemp, szInstructions))
                        SetDlgItemText(hDlg, IDE_SOURCEDIR, szTemp);
                }
                break;
            case IDC_BROWSEINS:
                GetDlgItemText( hDlg, IDE_LOADINS, szTemp, countof(szTemp));
                if( BrowseForFile( hDlg, szTemp, countof(szTemp), GFN_INS ))
                    SetDlgItemText( hDlg, IDE_LOADINS, szTemp );
                break;
            case IDCANCEL:
                EndDialog( hDlg, IDCANCEL );
                break;
            case IDOK:
                dwFlags = FC_FILE | FC_EXISTS;
                if (!CheckField(hDlg, IDE_LOADINS, dwFlags))
                    break;
                GetDlgItemText(hDlg, IDE_SOURCEDIR, szTemp, countof(szTemp));

                if (!CheckField(hDlg, IDE_SOURCEDIR, FC_PATH | FC_DIR))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }

                if (!PathIsUNC(szTemp))
                {
                    if ((PathIsRoot(szTemp)) || (PathIsRelative(szTemp)))
                    {
                        ErrorMessageBox(hDlg, IDS_SRCNEEDPATH);
                        break;
                    }
                }

                if ((StrLen(szTemp) <= 3) || PathIsUNCServer(szTemp))
                {
                    ErrorMessageBox(hDlg, IDS_SRCROOTILLEGAL);
                    break;;
                }

                fLocalMode = !IsDlgButtonChecked( hDlg, IDC_OFFLINE );

                if (!g_fBatch && fLocalMode && !CheckAVS(szTemp))
                {
                    ErrorMessageBox(hDlg, IDS_NEEDAVS);
                    break;
                }

                PathCombine(szTempFile, szTemp, TEXT("~~!!foo.txt"));

                if (!PathCreatePath(szTemp) ||
                    ((hTemp = CreateFile(szTempFile, GENERIC_WRITE, 0, NULL,
                    CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE))
                {
                    TCHAR szMsg[128];
                    TCHAR szMsgTemp[MAX_PATH+128];

                    LoadString(g_rvInfo.hInst, IDS_BADDIR, szMsg, countof(szMsg));
                    wnsprintf(szMsgTemp, countof(szMsgTemp), szMsg, szTemp);
                    MessageBox(hDlg, szMsgTemp, g_szTitle, MB_OK | MB_SETFOREGROUND);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;
                }
                CloseHandle(hTemp);
                DeleteFile(szTempFile);
                PathAddBackslash(szTemp);

                StrCpy(g_szIEAKProg, szTemp);

                GetDlgItemText(hDlg, IDE_LOADINS, g_szLoadedIns, countof(g_szLoadedIns));

                if (ISNONNULL(g_szLoadedIns))
                {
                    int nPlatformId = 0;

                    InsGetString(IS_BRANDING, TEXT("Platform"), szTemp, countof(szTemp), g_szLoadedIns);
                    nPlatformId = StrToInt(szTemp);
                    if (nPlatformId != 0 && nPlatformId != PLATFORM_WIN32 && nPlatformId != PLATFORM_W2K)
                    {
                        TCHAR szMsgParam[128];
                        TCHAR szMsg[MAX_PATH+128];

                        LoadString(g_rvInfo.hInst, IDS_UNSUPPORTED_PLATFORM, szMsgParam, countof(szMsgParam));
                        wnsprintf(szMsg, countof(szMsg), szMsgParam, g_szLoadedIns);

                        MessageBox(hDlg, szMsg, g_szTitle, MB_ICONINFORMATION | MB_OK);
                        
                        *g_szLoadedIns = TEXT('\0');
                        SetFocus(GetDlgItem(hDlg, IDE_LOADINS));

                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }
                    else if (nPlatformId == 0)
                        nPlatformId = PLATFORM_WIN32;
                }

                s_fLoadIns = TRUE;
                g_fLocalMode = fLocalMode;
                dwVal = g_fLocalMode ? 0 : 1;
                switch (g_dwPlatformId)
                {
                case PLATFORM_WIN32:
                default:
                     SHSetValue(HKEY_CURRENT_USER, RK_IEAK_SERVER, TEXT("WIN32_AVS"), REG_DWORD, (LPBYTE)&dwVal, sizeof(dwVal));
                     break;
                }

                EndDialog( hDlg, IDOK );
                break;
            }
            break;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

//
//  FUNCTION: TargetProc(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "OCW Source Target" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//
BOOL APIENTRY TargetProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR  szMsg[MAX_PATH];
    TCHAR  szTemp[MAX_PATH+128];
    TCHAR  szTempFile[MAX_PATH];
    TCHAR  szDeskDir[MAX_PATH];
    TCHAR  szRealRoot[MAX_PATH];
    TCHAR  szDestRoot[MAX_PATH];
    TCHAR  szTempRoot[MAX_PATH];
    DWORD  dwDestFree, dwDestNeed;
    DWORD  dwSRet, dwAttrib = 0xFFFFFFFF;
    BOOL   fNext = FALSE;
    HANDLE hTemp;
    static BOOL s_fFirst = TRUE;

    switch (message)
    {
        case WM_INITDIALOG:
            g_hWizard = hDlg;
            EnableDBCSChars(hDlg, IDE_TARGETDIR);

            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_COMMAND:
            if( HIWORD(wParam) == BN_CLICKED )
            {
                switch (LOWORD(wParam))
                {
                case IDC_BROWSE2:
                    {
                        TCHAR szInstructions[MAX_PATH];
                        LoadString(g_rvInfo.hInst,IDS_TARGETDIR,szInstructions,countof(szInstructions));

                        if (BrowseForFolder(hDlg, szTemp,szInstructions))
                            SetDlgItemText(hDlg, IDE_TARGETDIR, szTemp);
                    }
                    break;
                case IDC_ADVANCED:
                    DialogBox( g_rvInfo.hInst, (LPTSTR) IDD_ADVANCEDPOPUP, hDlg, (DLGPROC)AdvancedDlgProc);
                    break;
                }
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    //file locs
                    dwSRet = countof(g_szBuildRoot);
                    if(!g_fBatch && !g_fBatch2)
                    {
                        if (ISNULL(s_szSourceDir))
                        {
                            DWORD dwSize = sizeof(g_szIEAKProg);

                            SHGetValue(HKEY_CURRENT_USER, RK_IEAK_SERVER, TEXT("SourceDir"), NULL, (LPBYTE)s_szSourceDir, &dwSize);

                            if (ISNULL(s_szSourceDir))
                            {
                                GetIEAKDir(s_szSourceDir);
                                PathAppend(s_szSourceDir, TEXT("Download"));
                            }
                        }
                        StrCpy(g_szIEAKProg, s_szSourceDir);
                        PathAddBackslash(s_szSourceDir);
                        s_fAppendLang = TRUE;
                    }

                    if (s_fFirst)
                    {
                        DWORD dwSize, dwVal;

                        s_fFirst = FALSE;
                        dwSize = sizeof(dwVal);
                        switch (g_dwPlatformId)
                        {
                        case PLATFORM_WIN32:
                        default:
                            if ((SHGetValue(HKEY_CURRENT_USER, RK_IEAK_SERVER, TEXT("WIN32_AVS"), NULL, (LPBYTE)&dwVal, &dwSize) == ERROR_SUCCESS)
                                && !dwVal)
                                g_fLocalMode = TRUE;
                            break;
                        }
                    }

                    if (ISNONNULL(g_szIEAKProg))
                        PathRemoveBackslash(g_szIEAKProg);

                    if (!g_fOCW)
                    {
                        if (!g_fBatch && !g_fBatch2)
                        {
                            DWORD dwSize = sizeof(g_szBuildRoot);
                            SHGetValue(HKEY_CURRENT_USER, RK_IEAK_SERVER, TEXT("DestPath"), NULL, (LPVOID)g_szBuildRoot, &dwSize);
                        }
                    }

                    if (ISNONNULL(g_szBuildRoot))
                        PathRemoveBackslash(g_szBuildRoot);

                    else
                    {
                        SYSTEMTIME SystemTime;
                        TCHAR szDate[MAX_PATH];
                        TCHAR szDefaultTarget[MAX_PATH];

                        GetLocalTime(&SystemTime);
                        wnsprintf(szDate, countof(szDate), TEXT("%02d%02d%d"), SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear);
                        LoadString(g_rvInfo.hInst, IDS_DEFAULT_TARGETDIR, szDefaultTarget, countof(szDefaultTarget));
                        wnsprintf(g_szBuildRoot, countof(g_szBuildRoot), szDefaultTarget, szDate);
                    }

                    SetDlgItemText(hDlg, IDE_TARGETDIR, g_szBuildRoot);

                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                    fNext = TRUE;
                case PSN_WIZBACK:
                    //file locs
                    if (!g_fBatch && g_fLocalMode && !CheckAVS(g_szIEAKProg))
                    {
                        ErrorMessageBox(hDlg, IDS_NEEDAVS2);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }
                    StrCpy(szTemp, g_szBuildRoot);
                    GetDlgItemText(hDlg, IDE_TARGETDIR, g_szBuildRoot, countof(g_szBuildRoot));
                    StrTrim(g_szBuildRoot, TEXT(" \t"));
                    if (!PathIsUNC(g_szBuildRoot))
                    {
                        if ((PathIsRoot(g_szBuildRoot)) || (PathIsRelative(g_szBuildRoot)))
                        {
                            ErrorMessageBox(hDlg, IDS_NEEDPATH);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;

                        }
                    }

                    if ((StrLen(g_szBuildRoot) <= 3) || PathIsUNCServer(g_szBuildRoot))
                    {
                        ErrorMessageBox(hDlg, IDS_ROOTILLEGAL);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    if (!CheckField(hDlg, IDE_TARGETDIR, FC_PATH | FC_DIR))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    if (ISNONNULL(g_szBuildRoot))
                        PathRemoveBackslash(g_szBuildRoot);

                    PathRemoveBackslash(g_szIEAKProg);

                    if (StrCmpI(g_szBuildRoot, g_szIEAKProg) == 0)
                    {
                        LoadString(g_rvInfo.hInst, IDS_SAMEDIR, szMsg, countof(szMsg));
                        MessageBox(hDlg, szMsg, g_szTitle, MB_OK | MB_SETFOREGROUND);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }

                    StrCpy(szRealRoot, g_szBuildRoot);

                    hTemp = NULL;
                    PathCombine(szTempFile, g_szIEAKProg, TEXT("~~!!foo.txt"));
                    if (!PathCreatePath(g_szIEAKProg) ||
                        ((hTemp = CreateFile(szTempFile, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE))
                    {
                        LoadString(g_rvInfo.hInst, IDS_BADDIR2, szMsg, countof(szMsg));
                        wnsprintf(szTemp, countof(szTemp), szMsg, g_szIEAKProg);
                        MessageBox(hDlg, szTemp, g_szTitle, MB_OK | MB_SETFOREGROUND);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }
                    if (hTemp != INVALID_HANDLE_VALUE)
                        CloseHandle(hTemp);
                    DeleteFile(szTempFile);
                    PathAddBackslash(g_szIEAKProg);

                    hTemp = NULL;
                    PathCombine(szTempFile, g_szBuildRoot, TEXT("~~!!foo.txt"));
                    if (!PathCreatePath(g_szBuildRoot) || (hTemp = CreateFile(szTempFile, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
                    {
                        LoadString(g_rvInfo.hInst, IDS_BADDIR, szMsg, countof(szMsg));
                        wnsprintf(szTemp, countof(szTemp), szMsg, g_szBuildRoot);
                        MessageBox(hDlg, szTemp, g_szTitle, MB_OK | MB_SETFOREGROUND);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                    }
                    if (hTemp != INVALID_HANDLE_VALUE)
                        CloseHandle(hTemp);
                    DeleteFile(szTempFile);

                    PathCombine(szDeskDir, g_szBuildRoot, TEXT("Desktop"));
                    if ((dwAttrib = GetFileAttributes(szDeskDir)) != 0xFFFFFFFF)
                        SetFileAttributes(szDeskDir, dwAttrib & ~FILE_ATTRIBUTE_HIDDEN);
                    if (!g_fBatch)
                        SHSetValue(HKEY_CURRENT_USER, RK_IEAK_SERVER, TEXT("DestPath"), REG_SZ, (LPBYTE)szRealRoot,
                                    (StrLen(szRealRoot)+1)*sizeof(TCHAR));

                    GetTempPath(MAX_PATH, g_szBuildTemp);
                    PathAppend(g_szBuildTemp, TEXT("IEDKTEMP"));
                    PathRemovePath(g_szBuildTemp);
                    PathCreatePath(g_szBuildTemp);
                    PathCombine(g_szTempSign, g_szBuildTemp, TEXT("CUSTSIGN"));
                    PathCreatePath(g_szTempSign);

                    // BUGBUG: (andrewgu) no man's land starts...
                    StrCpy(szDestRoot, g_szBuildRoot);
                    StrCpy(szTempRoot, g_szBuildTemp);
                    CharUpper(szDestRoot);
                    CharUpper(szTempRoot);
                    dwDestFree = GetRootFree(szDestRoot);
                    dwDestNeed = MIN_PACKAGE_SIZE;
                    if (fNext)
                    {
                        if (dwDestFree < dwDestNeed)
                        {
                            TCHAR szTitle[MAX_PATH];
                            TCHAR szTemplate[MAX_PATH];
                            TCHAR szMsg[MAX_PATH];
                            LoadString( g_rvInfo.hInst, IDS_DISKERROR, szTitle, MAX_PATH );
                            LoadString( g_rvInfo.hInst, IDS_DESTDISKMSG, szTemplate, MAX_PATH );
                            wnsprintf(szMsg, countof(szMsg), szTemplate, dwDestFree, dwDestNeed);
                            if (MessageBox(hDlg, szMsg, szTitle, MB_OKCANCEL | MB_SETFOREGROUND) == IDCANCEL)
                            {
                                LoadString( g_rvInfo.hInst, IDS_ERROREXIT, szMsg, countof(szMsg) );
                                MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_SETFOREGROUND);
                                DoCancel();
                            }

                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return TRUE;
                        }

                    }

                    if(!g_fBatch && !g_fBatch2)
                    {
                        if (StrCmpI(s_szSourceDir, g_szIEAKProg) != 0)
                        {
                            SHSetValue(HKEY_CURRENT_USER, RK_IEAK_SERVER, TEXT("SourceDir"), REG_SZ,
                                (LPBYTE)g_szIEAKProg, (lstrlen(g_szIEAKProg)+1)*sizeof(TCHAR));
                            g_fSrcDirChanged = TRUE;
                            s_fAppendLang = TRUE;
                            StrCpy(s_szSourceDir, g_szIEAKProg);
                        }

                        if (StrCmpI(szTemp, g_szBuildRoot))
                            s_fDestDirChanged = TRUE;
                    }

                    g_iCurPage = PPAGE_TARGET;
                    EnablePages();
                    if (fNext)
                        PageNext(hDlg);
                    else
                        PagePrev(hDlg);
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}

void InitIEAKLite(HWND hwndList)
{
    ListView_DeleteAllItems(hwndList);

    for (int i = 0, iItem = 0;  i < IL_END;  i++)
    {
        TCHAR  szGroupName[MAX_PATH];
        LVITEM lvItem;

        // do not show groups that are not relevant for the current role (ICP, ISP, or Corp)
        // recap:
        //  ICP  is (!g_fBranded)
        //  ISP  is (g_fBranded && !g_fIntranet)
        //  CORP is (g_fIntranet)
        if ((!g_fBranded                  &&  g_IEAKLiteArray[i].fICP  == FALSE)  ||
            ( g_fBranded && !g_fIntranet  &&  g_IEAKLiteArray[i].fISP  == FALSE)  ||
            (                g_fIntranet  &&  g_IEAKLiteArray[i].fCorp == FALSE))
        {
            g_IEAKLiteArray[i].iListBox = -2;
            g_IEAKLiteArray[i].fEnabled = TRUE;
            continue;
        }

        // do not show ICM group in IEAKLite if only doing single disk branding since it's
        // not available anyway
        if (i == IL_ICM)
        {
            if (g_fBrandingOnly  &&  !g_fDownload  &&  !g_fCD  &&  !g_fLAN)
            {
                g_IEAKLiteArray[i].iListBox = -2;
                g_IEAKLiteArray[i].fEnabled = TRUE;
                continue;
            }
        }

        // if adms haven't been deleted yet, show adm page
        // by not creating an entry in the IEAKLite box
        if (i == IL_ADM)
        {
            if (InsGetBool(IS_BRANDING, TEXT("DeleteAdms"), FALSE, g_szCustIns))
            {
                g_IEAKLiteArray[i].iListBox = -2;
                g_IEAKLiteArray[i].fEnabled = TRUE;
                continue;
            }
        }

        // BUGBUG: pritobla: should have separate flags similar to DeleteAdms for activesetup
        // and icm so that even if the user cancels out of wizard before reaching these
        // pages, we can force them again.
        // Should consider this while reworking ieaklite.

        // force active setup, CMAK and adms to show up if imported an ins
        // by not creating an entry in the IEAKLite box
        if (*g_szLoadedIns)
        {
            if (i == IL_ACTIVESETUP  ||  i == IL_ICM  ||  i == IL_ADM)
            {
                g_IEAKLiteArray[i].iListBox = -2;
                g_IEAKLiteArray[i].fEnabled = TRUE;
                continue;
            }
        }

        LoadString(g_rvInfo.hInst, g_IEAKLiteArray[i].idGroupName, szGroupName, countof(szGroupName));
        
        g_IEAKLiteArray[i].fEnabled = !InsGetBool(IS_IEAKLITE, szGroupName, FALSE, g_szCustIns);

        ZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
        lvItem.iItem = iItem++;
        lvItem.pszText = szGroupName;
        lvItem.iImage = g_IEAKLiteArray[i].fEnabled ? 1 : 0;

#ifdef _DEBUG
        {
            LVFINDINFO lvFind;

            ZeroMemory(&lvFind, sizeof(lvFind));
            lvFind.flags = LVFI_STRING;
            lvFind.psz = szGroupName;

            ASSERT(ListView_FindItem(hwndList, -1, &lvFind) == -1);
        }
#endif

        g_IEAKLiteArray[i].iListBox = ListView_InsertItem(hwndList, &lvItem);
    }

    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);
}

void IEAKLiteMaintToggleCheckItem(HWND hwndList, int iItem)
{
    int i;
    LVITEM lvItem;

    for (i = 0; i < IL_END; i++)
    {
        if (g_IEAKLiteArray[i].iListBox == iItem)
            break;
    }
    ZeroMemory(&lvItem, sizeof(lvItem));
    g_IEAKLiteArray[i].fEnabled = !(g_IEAKLiteArray[i].fEnabled);
    lvItem.iItem = iItem;
    lvItem.mask = LVIF_IMAGE;
    lvItem.iImage = g_IEAKLiteArray[i].fEnabled ? 1 : 0;

    ListView_SetItem(hwndList, &lvItem);
}

BOOL ExtractOldInfo(LPCTSTR pcszCabname, LPTSTR pcszDestDir, BOOL fExe)
{
    TCHAR szCabPath[MAX_PATH];
    TCHAR szCmd[MAX_PATH*3];

    StrCpy(szCabPath, g_szCustIns);
    PathRemoveFileSpec(szCabPath);
    PathAppend(szCabPath, pcszCabname);

    if (!PathFileExists(szCabPath))
        return TRUE;

    if (!fExe)
        return (ExtractFilesWrap(szCabPath, pcszDestDir, 0, NULL, NULL, 0) == ERROR_SUCCESS);

    wnsprintf(szCmd, countof(szCmd), TEXT("\"%s\" /c /t:\"%s\""), szCabPath, pcszDestDir);

    return (RunAndWait(szCmd, g_szBuildTemp, SW_HIDE) == S_OK);
}

// BUGBUG: <oliverl> should probably persist this server side only info in a server side file for IEAK6

DWORD SaveIEAKLiteThreadProc(LPVOID)
{
    static BOOL s_fDesk;
    static BOOL s_fBrand;
    static BOOL s_fExe;
    TCHAR szGroupName[128];
    TCHAR szTmp[MAX_PATH];

    if (s_fDestDirChanged)
        s_fDestDirChanged = s_fDesk = s_fBrand = s_fExe = FALSE;

    for (int i=0; i < IL_END; i++)
    {
        LoadString(g_rvInfo.hInst, g_IEAKLiteArray[i].idGroupName, szGroupName, countof(szGroupName));
        WritePrivateProfileString(IS_IEAKLITE, szGroupName, g_IEAKLiteArray[i].fEnabled ? NULL : TEXT("1"), g_szCustIns);
    }

    if (!s_fExe && !g_IEAKLiteArray[IL_ACTIVESETUP].fEnabled)
    {
        ExtractOldInfo(TEXT("IE6SETUP.EXE"), g_szBuildTemp, TRUE);
        s_fExe = TRUE;
    }

    if (!s_fBrand &&
        (!g_IEAKLiteArray[IL_BROWSER].fEnabled || !g_IEAKLiteArray[IL_SIGNUP].fEnabled || !g_IEAKLiteArray[IL_CONNECT].fEnabled ||
        !g_IEAKLiteArray[IL_ZONES].fEnabled || !g_IEAKLiteArray[IL_CERT].fEnabled || !g_IEAKLiteArray[IL_MAILNEWS].fEnabled ||
        !g_IEAKLiteArray[IL_ADM].fEnabled || IsIconsInFavs(IS_FAVORITESEX, g_szCustIns) ||
        IsIconsInFavs(IS_URL, g_szCustIns)))
    {
        ExtractOldInfo(TEXT("BRANDING.CAB"), g_szTempSign, FALSE);
        PathCombine(szTmp, g_szTempSign, TEXT("install.inf"));
        DeleteFile(szTmp);
        PathCombine(szTmp, g_szTempSign, TEXT("setup.inf"));
        DeleteFile(szTmp);

        s_fBrand = TRUE;
    }

    if (ISNULL(g_szDeskTemp) && g_fIntranet)
    {
        PathCombine(g_szDeskTemp, g_szBuildRoot, TEXT("DESKTOP"));
        PathCreatePath(g_szDeskTemp);
    }

    if (!s_fDesk)
    {
        ExtractOldInfo(TEXT("DESKTOP.CAB"), g_szDeskTemp, FALSE);
        PathCombine(szTmp, g_szDeskTemp, TEXT("install.inf"));
        DeleteFile(szTmp);
        PathCombine(szTmp, g_szDeskTemp, TEXT("setup.inf"));
        DeleteFile(szTmp);
        s_fDesk = TRUE;
    }

    if (!g_fIntranet && g_fBranded)
    {
        // ISP

        g_fServerICW = g_fServerKiosk = g_fServerless = g_fNoSignup = FALSE;

        // make sure that only one of the variables is set to TRUE
        g_fServerICW = InsGetBool(IS_BRANDING, IK_USEICW, 0, g_szCustIns);
        if (!g_fServerICW)
        {
            g_fServerKiosk = InsGetBool(IS_BRANDING, IK_SERVERKIOSK, 0, g_szCustIns);
            if (!g_fServerKiosk)
            {
                g_fServerless = InsGetBool(IS_BRANDING, IK_SERVERLESS, 0, g_szCustIns);
                if (!g_fServerless)
                {
                    // in lots of other functions like BuildIE4, BuildBrandingOnly, BuildCDandMflop, etc.,
                    // !g_fNoSignup is used to mean that some signup mode was chosen;
                    // therefore, default to TRUE for g_fNoSignup
                    g_fNoSignup = InsGetBool(IS_BRANDING, IK_NODIAL, 1, g_szCustIns);
                }
            }
        }
    }
    else
    {
        if (g_fIntranet)
        {
            // Corp
            g_fSilent = GetPrivateProfileInt( BRANDING, SILENT_INSTALL, 0, g_szCustIns );
            g_fStealth = GetPrivateProfileInt( BRANDING, TEXT("StealthInstall"), 0, g_szCustIns );
            g_fInteg = GetPrivateProfileInt( BRANDING, WEB_INTEGRATED, 0, g_szCustIns );
        }
    }

    g_fUseIEWelcomePage = !InsGetBool(IS_URL, IK_NO_WELCOME_URL, FALSE, g_szCustIns);

    // take care of install dir for corp case
    if (g_fIntranet)
    {
        TCHAR szWrk[MAX_PATH];

        GetPrivateProfileString( IS_BRANDING, TEXT("InstallDir"), TEXT(""), szWrk, countof(szWrk), g_szCustIns );
        if (*szWrk != TEXT('%'))
        {
            g_iInstallOpt = INSTALL_OPT_FULL;
            if (ISNONNULL(szWrk))
                StrCpy(g_szInstallFolder, szWrk);
            else
            {
                LoadString( g_rvInfo.hInst, IDS_IE, g_szInstallFolder, MAX_PATH );
                g_iInstallOpt = INSTALL_OPT_PROG;
            }
        }
        else
        {
            switch (szWrk[1])
            {
            case 'p':
            case 'P':
            default:
                g_iInstallOpt = INSTALL_OPT_PROG;
                break;
            }
            StrCpy(g_szInstallFolder, &szWrk[3]);
        }
    }
    return 0;
}

void SetIEAKLiteDesc(HWND hDlg, int iItem)
{
    WORD wId;
    int i;
    TCHAR szDesc[512];

    for (i = 0; i < IL_END; i++)
    {
        if (g_IEAKLiteArray[i].iListBox == iItem)
            break;
    }

    if (!g_fBranded)
        wId = g_IEAKLiteArray[i].idICPDesc;
    else
    {
        if (!g_fIntranet)
            wId = g_IEAKLiteArray[i].idISPDesc;
        else
            wId = g_IEAKLiteArray[i].idCorpDesc;
    }
    LoadString(g_rvInfo.hInst, wId, szDesc, countof(szDesc));
    SetDlgItemText(hDlg, IDC_IEAKLITEDESC, szDesc);
}

void IEAKLiteSelectAll(HWND hCompList, BOOL fSet)
{
    for (int i=0; i < IL_END; i++)
    {
        if (g_IEAKLiteArray[i].iListBox != -2)
        {
            LV_ITEM lvItem;

            g_IEAKLiteArray[i].fEnabled = fSet;
            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.iImage = fSet ? 1 : 0;
            lvItem.mask = LVIF_IMAGE;
            lvItem.iItem = g_IEAKLiteArray[i].iListBox;
            ListView_SetItem(hCompList, &lvItem);
        }
    }
}
//
//  FUNCTION: IEAKLiteProc(HWND, UINT, UINT, LONG)
//
//  PURPOSE:  Processes messages for "IEAKLite" page
//
//  MESSAGES:
//
//  WM_INITDIALOG - intializes the page
//  WM_NOTIFY - processes the notifications sent to the page
//
BOOL APIENTRY IEAKLiteProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndList = GetDlgItem(hDlg, IDC_IEAKLITE);
    HWND hWait;
    HANDLE hThread;
    int iItem;
    DWORD dwTid;

    switch (message)
    {
        case WM_INITDIALOG:
            EnableDBCSChars(hDlg, IDC_IEAKLITE);
            InitList(hDlg, IDC_IEAKLITE);
            g_hWizard = hDlg;
            break;

        case WM_HELP:
            IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
            break;

        case IDM_BATCHADVANCE:
            DoBatchAdvance(hDlg);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_LITECHECKALL:
                        IEAKLiteSelectAll(hwndList, TRUE);
                        break;
                    case IDC_LITEUNCHECKALL:
                        IEAKLiteSelectAll(hwndList, FALSE);
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case LVN_KEYDOWN:
                    {
                        NMLVKEYDOWN *pnm = (NMLVKEYDOWN*) lParam;
                        if ( pnm->wVKey == VK_SPACE )
                        {
                            iItem = ListView_GetSelectionMark(hwndList);
                            IEAKLiteMaintToggleCheckItem(hwndList, iItem);
                        }
                        break;
                    }

                case NM_CLICK:
                    {
                        POINT pointScreen, pointLVClient;
                        DWORD dwPos;
                        LVHITTESTINFO HitTest;

                        dwPos = GetMessagePos();

                        pointScreen.x = LOWORD (dwPos);
                        pointScreen.y = HIWORD (dwPos);

                        pointLVClient = pointScreen;

                        // Convert the point from screen to client coordinates,
                        // relative to the Listview
                        ScreenToClient (hwndList, &pointLVClient);

                        HitTest.pt = pointLVClient;
                        ListView_HitTest(hwndList, &HitTest);

                        // Only if the user clicked on the checkbox icon/bitmap, change
                        if (HitTest.flags == LVHT_ONITEMICON)
                            IEAKLiteMaintToggleCheckItem(hwndList, HitTest.iItem);
                        SetIEAKLiteDesc(hDlg, HitTest.iItem);
                    }
                    break;

                case NM_DBLCLK:
                    if ( ((LPNMHDR)lParam)->idFrom == IDC_IEAKLITE)
                    {
                        iItem = ListView_GetSelectionMark(hwndList);
                        IEAKLiteMaintToggleCheckItem(hwndList, iItem);
                        SetIEAKLiteDesc(hDlg, iItem);
                    }
                    break;

                case LVN_ITEMCHANGED:
                    iItem = ListView_GetSelectionMark(hwndList);
                    SetIEAKLiteDesc(hDlg, iItem);
                    break;
                case PSN_HELP:
                    IeakPageHelp(hDlg, g_psp[g_iCurPage].pszTemplate);
                    break;

                case PSN_SETACTIVE:
                    SetBannerText(hDlg);

                    InitIEAKLite(GetDlgItem(hDlg, IDC_IEAKLITE));
                    ListView_SetItemState(hwndList, 0, LVIS_SELECTED, LVIS_SELECTED);
                    SetIEAKLiteDesc(hDlg, 0);
                    CheckBatchAdvance(hDlg);
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                    PropSheet_SetWizButtons(GetParent(hDlg), 0);
                    hWait = CreateDialog(g_rvInfo.hInst, MAKEINTRESOURCE(IDD_WAITIEAKLITE), hDlg,
                        (DLGPROC)DownloadStatusDlgProc);
                    ShowWindow( hWait, SW_SHOWNORMAL );

                    hThread = CreateThread(NULL, 4096, SaveIEAKLiteThreadProc, NULL, 0, &dwTid);

                    while (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0)
                    {
                        MSG msg;

                        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                        {
                            TranslateMessage(&msg);
                            DispatchMessage(&msg);
                        }
                    }

                    if (hThread) CloseHandle(hThread);

                    DestroyWindow(hWait);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                    g_iCurPage = PPAGE_IEAKLITE;
                    EnablePages();
                    if (((NMHDR FAR *) lParam)->code == PSN_WIZNEXT) PageNext(hDlg);
                    else
                    {
                        PagePrev(hDlg);
                    }
                    break;

                case PSN_QUERYCANCEL:
                    QueryCancel(hDlg);
                    break;

                default:
                    return FALSE;
        }
        break;

        case WM_LV_GETITEMS:
            LVGetItems(GetDlgItem(hDlg, IDC_IEAKLITE));
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

void PositionWindow(HWND hWnd)
{
    int nXPos, nYPos, nWidth, nHeight;
    RECT rectWnd, rectDesktop;

    if (hWnd == NULL && !IsWindow(hWnd))
        return;

    GetWindowRect(GetDesktopWindow(), &rectDesktop);
    GetWindowRect(hWnd, &rectWnd);

    nXPos = nYPos = -1;
    nWidth = rectWnd.right - rectWnd.left;
    nHeight = rectWnd.bottom - rectWnd.top;

    if (g_fOCW  &&  *g_szParentWindowName)
    {
        HWND hOCWWnd;
        RECT rect;

        hOCWWnd = FindWindow(NULL, g_szParentWindowName);
        if (hOCWWnd != NULL  &&  IsWindow(hOCWWnd)  &&  !IsIconic(hOCWWnd))
        {
            GetWindowRect(hOCWWnd, &rect);
            nXPos = rect.left;
            nYPos = rect.top;
        }
    }

    if (nXPos == -1 && nYPos == -1)
    {
        nXPos = (rectDesktop.right  - nWidth)  / 2;
        nYPos = (rectDesktop.bottom - nHeight) / 2;
    }

    MoveWindow(hWnd, nXPos, nYPos, nWidth, nHeight, TRUE);
}

void GetIEAKDir(LPTSTR szDir)
{
    TCHAR szIEAKDir[MAX_PATH];

    *szIEAKDir = TEXT('\0');
    if (GetModuleFileName(NULL, szIEAKDir, countof(szIEAKDir)))
        PathRemoveFileSpec(szIEAKDir);
    else
    {
        DWORD dwSize;

        dwSize = sizeof(szIEAKDir);
        if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS TEXT("\\ieak6WIZ.EXE"),
                            TEXT("Path"), NULL, (LPVOID) szIEAKDir, &dwSize) != ERROR_SUCCESS)
        {
            dwSize = sizeof(szIEAKDir);
            if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, TEXT("ProgramFilesDir"),
                                NULL, (LPVOID) szIEAKDir, &dwSize) == ERROR_SUCCESS)
                PathAppend(szIEAKDir, TEXT("IEAK"));
        }
    }

    StrCpy(szDir, szIEAKDir);
}

// get the ins file from the selected "platform/language" directory if exists
// else copy the last ins file used for this build directory if one exists
// else start with a new ins file
void GenerateCustomIns()
{
    TCHAR szSrcCustIns[MAX_PATH];

    PathCombine(g_szCustIns, g_szBuildRoot, TEXT("INS"));
    PathAppend(g_szCustIns, GetOutputPlatformDir());
    PathAppend(g_szCustIns, g_szLanguage);
    PathCreatePath(g_szCustIns);
    PathAppend(g_szCustIns, TEXT("INSTALL.INS"));

    if (g_szSrcRoot[0])
    {
        PathCombine(szSrcCustIns, g_szSrcRoot, TEXT("INS"));
        PathAppend(szSrcCustIns, GetOutputPlatformDir());
        PathAppend(szSrcCustIns, g_szLanguage);
        PathCreatePath(szSrcCustIns);
        PathAppend(szSrcCustIns, TEXT("INSTALL.INS"));
    }

    if (PathFileExists(szSrcCustIns))
        CopyFile(szSrcCustIns, g_szCustIns, FALSE); //Overwrite if already exists

    if (!PathFileExists(g_szCustIns))
    {
        TCHAR szInsFile[MAX_PATH];
        TCHAR szPlatformLang[MAX_PATH];
        DWORD dwSize = sizeof(szPlatformLang);
        TCHAR szRegKey[MAX_PATH];

        wnsprintf(szRegKey, countof(szRegKey), TEXT("%s\\INS"), RK_IEAK_SERVER);
        if (SHGetValue(HKEY_CURRENT_USER, szRegKey, g_szBuildRoot, NULL, (LPBYTE)szPlatformLang, &dwSize) == ERROR_SUCCESS)
        {
            TCHAR szTemp[MAX_PATH];

            StrCpy(szTemp, szPlatformLang);
            PathRemoveFileSpec(szTemp);
            if (StrCmpI(szTemp, TEXT("WIN32")) == 0)
            {
                PathCombine(szInsFile, g_szBuildRoot, TEXT("INS"));
                PathAppend(szInsFile, szPlatformLang);
                PathAppend(szInsFile, TEXT("INSTALL.INS"));
                CopyFile(szInsFile, g_szCustIns, TRUE);
                if (ISNULL(g_szLoadedIns) && (StrCmpI(g_szLoadedIns, szInsFile) != 0))
                {
                    StrCpy(g_szLoadedIns, szInsFile);
                    s_fLoadIns = TRUE;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\filefind.h ===
#ifndef _FILEFIND_H_
#define _FILEFIND_H_

////////////////////////////////////////////////////////////////////////////
// Local file searches

class CFindFile : public CObject
{
public:
	CFindFile();
	virtual ~CFindFile();

// Attributes
public:
	DWORD GetLength() const;
#if defined(_X86_) || defined(_ALPHA_)
	__int64 GetLength64() const;
#endif
	virtual CString GetFileName() const;
	virtual CString GetFilePath() const;
	virtual CString GetFileTitle() const;
	virtual CString GetFileURL() const;
	virtual CString GetRoot() const;

	virtual BOOL GetLastWriteTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastAccessTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetCreationTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastWriteTime(CTime& refTime) const;
	virtual BOOL GetLastAccessTime(CTime& refTime) const;
	virtual BOOL GetCreationTime(CTime& refTime) const;

	virtual BOOL MatchesMask(DWORD dwMask) const;

	virtual BOOL IsDots() const;
	// these aren't virtual because they all use MatchesMask(), which is
	BOOL IsReadOnly() const;
	BOOL IsDirectory() const { return MatchesMask(FILE_ATTRIBUTE_DIRECTORY); };
	BOOL IsCompressed() const;
	BOOL IsSystem() const;
	BOOL IsHidden() const;
	BOOL IsTemporary() const;
	BOOL IsNormal() const;
	BOOL IsArchived() const;

// Operations
	void Close();
	virtual BOOL FindFile(LPCTSTR pstrName = NULL, DWORD dwUnused = 0);
	virtual BOOL FindNextFile();

protected:
	virtual void CloseContext();

// Implementation
protected:
	void* m_pFoundInfo;
	void* m_pNextInfo;
	HANDLE m_hContext;
	BOOL m_bGotLast;
	CString m_strRoot;
	TCHAR m_chDirSeparator;     // not '\\' for Internet classes

#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
	void AssertValid() const;
#endif

	DECLARE_DYNAMIC(CFindFile)
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\msie.cpp ===
// Msie.cpp : Implementation of CMsieApp and DLL registration.

#include "stdafx.h"
#include "Msie.h"
#include "regkeys.h"
#include "resdefs.h"
#include <wbemprov.h>
#include <AFXPRIV.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CMsieApp theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x25959bec, 0xe700, 0x11d2, { 0xa7, 0xaf, 0, 0xc0, 0x4f, 0x80, 0x62, 0 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const LPCSTR CLSID_MSIE = "{25959BEF-E700-11D2-A7AF-00C04F806200}";
const LPCSTR IE_REPAIR_CMD = "rundll32 setupwbv.dll,IE6Maintenance \"%s\\Setup\\SETUP.EXE\" /g \"%s\\%s\"";

const LPCSTR OCX_FILE_IN_COMMON = "Microsoft Shared\\MSInfo\\ieinfo5.ocx";
const LPCSTR MOF_FILE_PATH = "%SystemRoot%\\System32\\WBEM\\MOF";
const LPCSTR MOF_FILE = "ieinfo5.mof";

const MAX_KEY_LENGTH = 256;



////////////////////////////////////////////////////////////////////////////
// CMsieApp::InitInstance - DLL initialization

BOOL CMsieApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		m_fTemplateLoaded		= FALSE;
		m_pTemplateInfo		= NULL;
		m_dwTemplateInfoLen	= 0;
	}

	return bInit;
}

////////////////////////////////////////////////////////////////////////////
// CMsieApp::ExitInstance - DLL termination

int CMsieApp::ExitInstance()
{
	if (m_pTemplateInfo != NULL)
	{
		delete m_pTemplateInfo;
		m_pTemplateInfo = NULL;
	}
	return COleControlModule::ExitInstance();
}

//-----------------------------------------------------------------------------
// AppGetTemplate is the entry point for the app object from outside the DLL.
// It's called by the exported function GetTemplate. The reconstructed template
// file should be returned to the caller as a pointer in the pBuffer parameter.
//
// If a NULL pointer is passed for pBuffer, we are free to delete the internal
// buffer storing the template file.
//-----------------------------------------------------------------------------

DWORD CMsieApp::AppGetTemplate(void ** ppBuffer)
{
	if (!m_fTemplateLoaded)
	{
		LoadTemplate();
		m_fTemplateLoaded = TRUE;
	}

	if (ppBuffer == NULL)
	{
		if (m_pTemplateInfo)
			delete m_pTemplateInfo;

		m_pTemplateInfo = NULL;
		m_dwTemplateInfoLen = 0;
		m_fTemplateLoaded = FALSE;
		return 0;
	}

	*ppBuffer = (void *)m_pTemplateInfo;
	return m_dwTemplateInfoLen;
}

//-----------------------------------------------------------------------------
// This table of keywords is used during the reconstruction process. It matches
// exactly the table used during the conversion from NFT to resources, and it
// MUST NOT be modified, or the reconstructed information will be bogus.
//-----------------------------------------------------------------------------

#define KEYWORD_COUNT 19
char * KEYWORD_STRING[KEYWORD_COUNT] = 
{
	"node", "columns", "line", "field", "enumlines", "(", ")", "{", "}", ",",
	"\"basic\"", "\"advanced\"", "\"BASIC\"", "\"ADVANCED\"", "\"static\"",
	"\"LEXICAL\"", "\"VALUE\"", "\"NONE\"", "\"\""
};

//-----------------------------------------------------------------------------
// The LoadTemplate function needs to load the template information out of
// our resources, and create a buffer which contains the restored template
// file to return to our caller (through AppGetTemplate).
//-----------------------------------------------------------------------------

void CMsieApp::LoadTemplate()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CMapWordToPtr	mapNonLocalized;
	HRSRC				hrsrcNFN;
	HGLOBAL			hglbNFN;
	unsigned char	*pData;
	WORD				wID;
	CString			strToken, *pstrToken;

	// In debug mode, we'll reconstruct the original template file for comparison.

/*#ifdef DBG
	CFile fileRestore(_T("ie-restore.nft"), CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite);
#endif*/

	// Load the non-localized strings from the custom resource type and create
	// a map of ID to strings. Because these are non-localized strings, they
	// will not be stored as Unicode. Each item in the stream is a 2 byte word
	// ID followed by a null-terminated string. A zero ID indicates the end of
	// the stream.

	hrsrcNFN		= FindResource(AfxGetResourceHandle(), _T("#1"), _T("MSINonLocalizedTokens"));
	hglbNFN		= LoadResource(AfxGetResourceHandle(), hrsrcNFN);
	pData			= (unsigned char *)LockResource(hglbNFN);

	while (pData && *((WORD UNALIGNED *)pData))
	{
		wID  = (WORD)(((WORD)*pData++) << 8);	// deal with the byte order explicitly to avoid
		wID |= (WORD)*pData++;						// endian problems.

		pstrToken = new CString((char *)pData);
		pData += strlen((char *)pData) + 1;

		if (pstrToken)
			mapNonLocalized.SetAt(wID, (void *)pstrToken);
	}

	// Load the binary stream of token identifiers into memory.

	HRSRC				hrsrcNFB = FindResource(AfxGetResourceHandle(), _T("#1"), _T("MSITemplateStream"));
	HGLOBAL			hglbNFB = LoadResource(AfxGetResourceHandle(), hrsrcNFB);
	unsigned char *pStream = (unsigned char *) LockResource(hglbNFB);

	if (pStream)
	{
		// The first DWORD in the stream is the size of the original text file. We'll
		// use this to allocate our buffer to store the reconstituted file.

		DWORD dwSize;
		dwSize  = ((DWORD)*pStream++) << 24;
		dwSize |= ((DWORD)*pStream++) << 16;
		dwSize |= ((DWORD)*pStream++) << 8;
		dwSize |= ((DWORD)*pStream++);

		// The size stored is for an Ansi text file. We need to adjust for the
		// fact that our reconstituted file will be Unicode. We also want to add
		// a word to the front of the stream to hold the Unicode file marker (so
		// MSInfo can use the same functions to read a file or this stream).

		dwSize *= sizeof(WCHAR);	// adjust for Unicode
		dwSize += sizeof(WORD);		// add room for Unicode file marker
		m_pTemplateInfo = new unsigned char[dwSize];
		m_dwTemplateInfoLen = 0;
		if (m_pTemplateInfo == NULL)
			return;

		// Write the Unicode file marker.

		wID = 0xFEFF;
		memcpy(&m_pTemplateInfo[m_dwTemplateInfoLen], (void *)&wID, sizeof(WORD));
		m_dwTemplateInfoLen += sizeof(WORD);

		// Process the stream a token at a time. For each new item in the stream, we
		// process it as follows:
		//
		// 1. If ((byte & 0x80) == 0x00), use the byte to lookup a KEYWORD_STRING.
		// 2. If ((byte & 0xC0) == 0x80), use the byte and the next byte as a word
		//    ID to lookup a non-localized token from mapNonLocalized.
		// 3. Else ((byte & 0xC0) == 0xC0), use the byte and the next byte as a word
		//    ID to lookup a localized token from the resources of this DLL.

		while (pStream && *pStream)
		{
			if ((*pStream & 0x80) == 0x00)
			{
				// A byte with the high bit clear refers to a keyword. Look up the keyword
				// from the table, and add it to the restored file.

				wID = (WORD)(((WORD)*pStream++) - 1); ASSERT(wID <= KEYWORD_COUNT);
				if (wID <= KEYWORD_COUNT)
					strToken = KEYWORD_STRING[wID];
			}
			else
			{
				wID  = (WORD)(((WORD)*pStream++) << 8);	// deal with the byte order explicitly to avoid
				wID |= (WORD)*pStream++;						// endian problems.

				if ((wID & 0xC000) == 0x8000)
				{
					// A byte with the high bit set, but the next to high bit clear indicates
					// the ID is actually a word, and should be used to get a non-localized
					// string. Get the string out of the map we created and add it to the file.

					if (mapNonLocalized.Lookup(((WORD)(wID & 0x7FFF)), (void *&)pstrToken))
						strToken = *pstrToken;
					else
						ASSERT(FALSE);
				}
				else
				{
					// A byte with the two MSB set indicates that the ID is a word, and should
					// be used to reference a localized string out of the string table in this
					// module's resources. This string will be UNICODE.

					VERIFY(strToken.LoadString((wID & 0x3FFF) + IDS_MSITEMPLATEBASE));
					strToken = _T("\"") + strToken + _T("\"");
				}
			}

			// Store the token on the end of our buffer. The data in this buffer must
			// be Unicode, so we'll need to convert the string if necessary.

			//v-stlowe  if (m_dwTemplateInfoLen + strToken.GetLength() * sizeof(WCHAR) < dwSize)
			if (m_dwTemplateInfoLen + strToken.GetLength() < dwSize)
			{
				// Converting to strToken to Unicode

				
				WCHAR *pwchToken;
				pwchToken = new WCHAR[strToken.GetLength() + 1];
				//v-stlowe ::MultiByteToWideChar(CP_ACP, 0, strToken, -1, pwchToken, (strToken.GetLength() + 1) * sizeof(WCHAR));
				
				
				USES_CONVERSION;
				wcscpy(pwchToken,T2W((LPTSTR)(LPCTSTR)strToken));

				// Copying Unicode string to buffer

				memcpy(&m_pTemplateInfo[m_dwTemplateInfoLen], (void *)pwchToken, wcslen(pwchToken) * sizeof(WCHAR));
				m_dwTemplateInfoLen += wcslen(pwchToken) * sizeof(WCHAR);
				
				delete pwchToken;
				
				/*memcpy(&m_pTemplateInfo[m_dwTemplateInfoLen],(void *) strToken.GetBuffer(strToken.GetLength()),strToken.GetLength());
				strToken.ReleaseBuffer();*/
			}
			else
				ASSERT(FALSE);

/*#ifdef DBG
			if (strToken == CString(_T("}")) || strToken == CString(_T("{")) || strToken == CString(_T(")")))
				strToken += CString(_T("\r\n"));
			fileRestore.Write((void *)(LPCTSTR)strToken, strToken.GetLength() * sizeof(TCHAR));
#endif*/

		}
	}

	// Delete the contents of the lookup table.

	#ifdef DBG
		CFile fileRestore(_T("test.nft"), CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite);
		fileRestore.Write(m_pTemplateInfo,m_dwTemplateInfoLen);
	#endif

	for (POSITION pos = mapNonLocalized.GetStartPosition(); pos != NULL;)
	{
		mapNonLocalized.GetNextAssoc(pos, wID, (void *&)pstrToken);
		if (pstrToken)
			delete pstrToken;
	}
}

////////////////////////////////////////////////////////////////////////////
// WriteNode - Helper function for writing an MSInfo node to the registry

void WriteNode(HKEY hKey, LPCTSTR pszSubKey, int idsDefault, DWORD dwView, DWORD dwRank)
{
	HKEY hNewKey;
	DWORD dwDisposition;
	CString strDefault;

	if (ERROR_SUCCESS == RegCreateKeyEx(hKey, pszSubKey, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hNewKey, &dwDisposition))
	{
		strDefault.LoadString(idsDefault);
		RegSetValueEx(hNewKey, NULL, 0, REG_SZ, (const LPBYTE)(LPCTSTR)strDefault, strDefault.GetLength() + sizeof(TCHAR));
		RegSetValueEx(hNewKey, REG_CLSID, 0, REG_SZ, (const LPBYTE)CLSID_MSIE, strlen(CLSID_MSIE) + 1);
		RegSetValueEx(hNewKey, REG_MSINFO_VIEW, 0, REG_BINARY, (const LPBYTE)&dwView, sizeof(DWORD));
		RegSetValueEx(hNewKey, REG_RANK, 0, REG_BINARY, (const LPBYTE)&dwRank, sizeof(DWORD));

		RegCloseKey(hNewKey);
	}
}

////////////////////////////////////////////////////////////////////////////
// RegDeleteKeyRecusive - Helper function for deleting reg keys

DWORD RegDeleteKeyRecusive(HKEY hStartKey, LPCTSTR pKeyName)
{
   DWORD   dwRtn, dwSubKeyLength;
   LPTSTR  pSubKey = NULL;
   TCHAR   szSubKey[MAX_KEY_LENGTH]; // (256) this should be dynamic.
   HKEY    hKey;

   // Do not allow NULL or empty key name
   if ( pKeyName &&  lstrlen(pKeyName))
   {
      if( (dwRtn = RegOpenKeyEx(hStartKey, pKeyName, 0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
      {
         while (dwRtn == ERROR_SUCCESS)
         {
            dwSubKeyLength = MAX_KEY_LENGTH;
            dwRtn=RegEnumKeyEx(
                           hKey,
                           0,       // always index zero
                           szSubKey,
                           &dwSubKeyLength,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                         );

            if(dwRtn == ERROR_NO_MORE_ITEMS)
            {
               dwRtn = RegDeleteKey(hStartKey, pKeyName);
               break;
            }
            else if(dwRtn == ERROR_SUCCESS)
               dwRtn = RegDeleteKeyRecusive(hKey, szSubKey);
         }
         RegCloseKey(hKey);
         // Do not save return code because error
         // has already occurred
      }
   }
   else
      dwRtn = ERROR_BADKEY;

   return dwRtn;
}

////////////////////////////////////////////////////////////////////////////
// GetIERepairToolCmdLine - Helper function for creating command line for
//									 launching IE Repair Tool.

CString GetIERepairToolCmdLine()
{
	CString strRet, strIEPath, strIEPathExpanded, strWindowsPath, strRepairLog;
	HKEY hKey;
	DWORD cbData;

	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_IE_SETUP_KEY, 0, KEY_QUERY_VALUE, &hKey))
	{
		cbData = MAX_PATH;
		RegQueryValueEx(hKey, REG_PATH, NULL, NULL, (LPBYTE)strIEPath.GetBuffer(MAX_PATH), &cbData);
		strIEPath.ReleaseBuffer();

		ExpandEnvironmentStrings(strIEPath, strIEPathExpanded.GetBuffer(MAX_PATH), MAX_PATH);
		strIEPathExpanded.ReleaseBuffer();

		RegCloseKey(hKey);
	}
	GetWindowsDirectory(strWindowsPath.GetBuffer(MAX_PATH), MAX_PATH);
	strWindowsPath.ReleaseBuffer();
	strRepairLog.LoadString(IDS_REPAIR_LOG);
	strRet.Format((LPCTSTR) IE_REPAIR_CMD, strIEPathExpanded, strWindowsPath, strRepairLog);

	return strRet;
}
			
/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	OSVERSIONINFO osver;
	HKEY hCatKey, hIE6Key, hCacheKey, hContentKey, hRepairKey, hMsinfoKey, hTemplatesKey, hIeinfo5Key;
	HKEY hMicrosoftKey, hSharedToolsKey, hCurrentVersionKey;
	CString strCatKey, strKey, strValue, strFullPath, strMofPathSrc, strMofPathDest;
	BYTE szBuffer[MAX_PATH];
	DWORD dwDisposition, dwType, dwSize;
	int nIndex;
    HRESULT hr = S_OK;

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	// check OS ver

	osver.dwOSVersionInfoSize = sizeof(osver);
	VERIFY(GetVersionEx(&osver));
	if ((osver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osver.dwMajorVersion >= 5))
	{
		//***** Windows 2000 *****

		// add template reg entry

		if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_MICROSOFT_KEY, 0, KEY_CREATE_SUB_KEY, &hMicrosoftKey))
		{
			if (ERROR_SUCCESS == RegCreateKeyEx(hMicrosoftKey, REG_SHARED_TOOLS, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_CREATE_SUB_KEY, NULL, &hSharedToolsKey, &dwDisposition))
			{
				if (ERROR_SUCCESS == RegCreateKeyEx(hSharedToolsKey, REG_MSINFO, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_CREATE_SUB_KEY, NULL, &hMsinfoKey, &dwDisposition))
				{
					if (ERROR_SUCCESS == RegCreateKeyEx(hMsinfoKey, REG_TEMPLATES, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_CREATE_SUB_KEY, NULL, &hTemplatesKey, &dwDisposition))
					{
						if (ERROR_SUCCESS == RegCreateKeyEx(hTemplatesKey, REG_IEINFO5, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hIeinfo5Key, &dwDisposition))
						{
							if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_CURRENT_VERSION_KEY, 0, KEY_QUERY_VALUE, &hCurrentVersionKey))
							{
								dwType = REG_SZ;
								dwSize = MAX_PATH;
								if (ERROR_SUCCESS == RegQueryValueEx(hCurrentVersionKey, REG_COMMON_FILES_DIR, NULL, &dwType, (LPBYTE)strFullPath.GetBuffer(MAX_PATH), &dwSize))
								{
									strFullPath.ReleaseBuffer();

									strFullPath += _T('\\');
									strFullPath += OCX_FILE_IN_COMMON;
									if (strFullPath[0] == _T('"'))
										strFullPath = strFullPath.Right(strFullPath.GetLength() - 1);

									RegSetValueEx(hIeinfo5Key, NULL, 0, REG_SZ, (const LPBYTE)(LPCTSTR)strFullPath, strFullPath.GetLength() * sizeof(TCHAR));
								}
								RegCloseKey(hCurrentVersionKey);
							}
							RegCloseKey(hIeinfo5Key);
						}
						RegCloseKey(hTemplatesKey);
					}
					RegCloseKey(hMsinfoKey);
				}
				RegCloseKey(hSharedToolsKey);
			}
			RegCloseKey(hMicrosoftKey);
		}

        // copy ieinfo5.mof to mof dir

        if (!strFullPath.IsEmpty() && false) //12/13/2000. a-sanka. do not compile mof. 
        {
            WCHAR strPathMof[MAX_PATH];

            strMofPathSrc = strFullPath;
            nIndex = strMofPathSrc.ReverseFind(_T('\\'));

            strMofPathSrc = strMofPathSrc.Left(nIndex + 1);
            strMofPathSrc += MOF_FILE;
            
            if (strMofPathSrc[0] == _T('"'))
                strMofPathSrc = strMofPathSrc.Right(strMofPathSrc.GetLength() - 1);

#ifdef UNICODE
            wsprintfW(strPathMof, L"%ls", strMofPathSrc);
#else
            wsprintfW(strPathMof, L"%hs", strMofPathSrc);
#endif
            HRESULT hrInit = CoInitialize(NULL);
            IMofCompiler * pMofComp;

            hr = CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (void**)&pMofComp);
            if (SUCCEEDED(hr))
            {
                WBEM_COMPILE_STATUS_INFO Info;
                hr = pMofComp->CompileFile(strPathMof,NULL,NULL,NULL,NULL,WBEM_FLAG_AUTORECOVER,0,0,&Info);

                pMofComp->Release();
            }

            if (SUCCEEDED(hrInit))
                CoUninitialize();
        }
    }
    else
    {
		//***** NT4, Win 9x *****

		// Set all MSInfo category reg values for this extension

		strCatKey = REG_MSINFO_KEY;
		strCatKey += '\\'; 
		strCatKey += REG_CATEGORIES;
		if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, strCatKey, 0, KEY_WRITE, &hCatKey))
		{
			WriteNode(hCatKey, REG_INTERNET_EXPLORER_6, IDS_INTERNET_EXPLORER_6, 1, 0x35);

			if (ERROR_SUCCESS == RegOpenKeyEx(hCatKey, REG_INTERNET_EXPLORER_6, 0, KEY_WRITE, &hIE6Key))
			{
				WriteNode(hIE6Key, REG_FILE_VERSIONS, IDS_FILE_VERSIONS, 2, 0x10);
				WriteNode(hIE6Key, REG_CONNECTIVITY, IDS_CONNECTIVITY, 3, 0x20);
				WriteNode(hIE6Key, REG_CACHE, IDS_CACHE, 4, 0x30);
				if (ERROR_SUCCESS == RegOpenKeyEx(hIE6Key, REG_CACHE, 0, KEY_WRITE, &hCacheKey))
				{
					WriteNode(hCacheKey, REG_OBJECT_LIST, IDS_OBJECT_LIST, 5, 0x10);
					RegCloseKey(hCacheKey);
				}
				WriteNode(hIE6Key, REG_CONTENT, IDS_CONTENT, 6, 0x40);
				if (ERROR_SUCCESS == RegOpenKeyEx(hIE6Key, REG_CONTENT, 0, KEY_WRITE, &hContentKey))
				{
					WriteNode(hContentKey, REG_PERSONAL_CERTIFICATES, IDS_PERSONAL_CERTIFICATES, 7, 0x10);
					WriteNode(hContentKey, REG_OTHER_PEOPLE_CERTIFICATES, IDS_OTHER_PEOPLE_CERTIFICATES, 8, 0x20);
					WriteNode(hContentKey, REG_PUBLISHERS, IDS_PUBLISHERS, 9, 0x30);
					RegCloseKey(hContentKey);
				}
				WriteNode(hIE6Key, REG_SECURITY, IDS_SECURITY, 10, 0x50);

				RegCloseKey(hIE6Key);
			}
			RegCloseKey(hCatKey);
		}

		// Add MSInfo tool reg values for IE Repair Tool

		strKey = REG_MSINFO_KEY;
		strKey += '\\'; 
		strKey += REG_TOOLS;
		strKey += '\\'; 
		strKey += REG_IE_REPAIR;
		if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, strKey, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRepairKey, &dwDisposition))
		{
			strValue.LoadString(IDS_IE_REPAIR_TOOL);
			RegSetValueEx(hRepairKey, NULL, 0, REG_SZ, (const LPBYTE)(LPCTSTR)strValue, strValue.GetLength() + sizeof(TCHAR));

			strValue = GetIERepairToolCmdLine();
			RegSetValueEx(hRepairKey, REG_COMMAND, 0, REG_SZ, (const LPBYTE)(LPCTSTR)strValue, strValue.GetLength() + sizeof(TCHAR));

			strValue.LoadString(IDS_RUNS_IE_REPAIR_TOOL);
			RegSetValueEx(hRepairKey, REG_DESCRIPTION, 0, REG_SZ, (const LPBYTE)(LPCTSTR)strValue, strValue.GetLength() + sizeof(TCHAR));

			RegCloseKey(hRepairKey);
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	OSVERSIONINFO osver;
	CString strKey;

	if (!AfxOleUnregisterTypeLib(_tlid /*, _wVerMajor, _wVerMinor*/))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	osver.dwOSVersionInfoSize = sizeof(osver);
	VERIFY(GetVersionEx(&osver));
	if ((osver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osver.dwMajorVersion >= 5))
	{
		// Windows 2000

	}
	else
	{
		// NT4, Win 9x

		// Remove all MSInfo category reg values for this extension

		strKey = REG_MSINFO_KEY;
		strKey += '\\'; 
		strKey += REG_CATEGORIES;
		strKey += '\\'; 
		strKey += REG_INTERNET_EXPLORER_6;
		RegDeleteKeyRecusive(HKEY_LOCAL_MACHINE, strKey);

		// Remove MSInfo tool reg values for IE Repair Tool

		strKey = REG_MSINFO_KEY;
		strKey += '\\'; 
		strKey += REG_TOOLS;
		strKey += '\\'; 
		strKey += REG_IE_REPAIR;
		RegDeleteKey(HKEY_LOCAL_MACHINE, strKey);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// GetTemplate - exported function for NT5 template dll

DWORD __cdecl GetTemplate(void ** ppBuffer)
{
	DWORD dwReturn = 0;

	TRY
	{
		dwReturn = theApp.AppGetTemplate(ppBuffer);	
	}
	CATCH_ALL(e)
	{
#ifdef DBG
		e->ReportError();
#endif
		dwReturn = 0;
	}
	END_CATCH_ALL

	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\msiectl.cpp ===
// MsieCtl.cpp : Implementation of the CMsieCtrl ActiveX Control class.

#include "stdafx.h"
#include "Msie.h"
#include "MsieCtl.h"
#include "MsiePpg.h"
#include "MsieData.h"
#include "resdefs.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// WMI Interfaces used (defining here instead of linking to wbemuuid.lib)

const IID IID_IWbemProviderInit =
		{ 0x1be41572, 0x91dd, 0x11d1, { 0xae, 0xb2, 0x00, 0xc0, 0x4f, 0xb6, 0x88, 0x20 } };

//const IID IID_IWbemServices = 
//		{ 0x9556dc99, 0x828c, 0x11cf, { 0xa3, 0x7e, 0x00, 0xaa, 0x00, 0x32, 0x40, 0xc7 } };


// Macro for setting a WBEM property

#define SETPROPERTY(prop) \
	if (pData->prop.vt == VT_DATE) \
		ConvertDateToWbemString(pData->prop); \
	pInstance->Put(L#prop, 0, &pData->prop, 0);


IMPLEMENT_DYNCREATE(CMsieCtrl, COleControl)

/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMsieCtrl, COleControl)
	//{{AFX_MSG_MAP(CMsieCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_CTLCOLOR()
	ON_BN_CLICKED(IDC_BTN_BASIC, OnBasicBtnClicked) 
	ON_BN_CLICKED(IDC_BTN_ADVANCED, OnAdvancedBtnClicked) 
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CMsieCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CMsieCtrl)
	DISP_PROPERTY_NOTIFY(CMsieCtrl, "MSInfoView", m_MSInfoView, OnMSInfoViewChanged, VT_I4)
	DISP_FUNCTION(CMsieCtrl, "MSInfoRefresh", MSInfoRefresh, VT_EMPTY, VTS_BOOL VTS_PI4)
	DISP_FUNCTION(CMsieCtrl, "MSInfoLoadFile", MSInfoLoadFile, VT_BOOL, VTS_BSTR)
	DISP_FUNCTION(CMsieCtrl, "MSInfoSelectAll", MSInfoSelectAll, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CMsieCtrl, "MSInfoCopy", MSInfoCopy, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CMsieCtrl, "MSInfoUpdateView", MSInfoUpdateView, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CMsieCtrl, "MSInfoGetData", MSInfoGetData, VT_I4, VTS_I4 VTS_PI4 VTS_I4)
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Interface map

BEGIN_INTERFACE_MAP(CMsieCtrl, COleControl)
	INTERFACE_PART(CMsieCtrl, IID_IWbemProviderInit, WbemProviderInit)
	INTERFACE_PART(CMsieCtrl, IID_IWbemServices, WbemServices)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CMsieCtrl, COleControl)
	//{{AFX_EVENT_MAP(CMsieCtrl)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

BEGIN_PROPPAGEIDS(CMsieCtrl, 1)
	PROPPAGEID(CMsiePropPage::guid)
END_PROPPAGEIDS(CMsieCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMsieCtrl, "MSIE.MsieCtrl.1",
	0x25959bef, 0xe700, 0x11d2, 0xa7, 0xaf, 0, 0xc0, 0x4f, 0x80, 0x62, 0)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CMsieCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DMsie =
		{ 0x25959bed, 0xe700, 0x11d2, { 0xa7, 0xaf, 0, 0xc0, 0x4f, 0x80, 0x62, 0 } };
const IID BASED_CODE IID_DMsieEvents =
		{ 0x25959bee, 0xe700, 0x11d2, { 0xa7, 0xaf, 0, 0xc0, 0x4f, 0x80, 0x62, 0 } };

/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwMsieOleMisc =
	OLEMISC_SIMPLEFRAME |
	OLEMISC_INVISIBLEATRUNTIME |
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CMsieCtrl, IDS_MSIE, _dwMsieOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::CMsieCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CMsieCtrl

BOOL CMsieCtrl::CMsieCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_MSIE,
			IDB_MSIE,
			afxRegApartmentThreading,
			_dwMsieOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::CMsieCtrl - Constructor

CMsieCtrl::CMsieCtrl()
{
	TRACE0("-- CMsieCtrl::CMsieCtrl()\n");

	InitializeIIDs(&IID_DMsie, &IID_DMsieEvents);

	EnableSimpleFrame();

	// set background brush to white (used with static and radio button controls)

	m_pCtlBkBrush = new CBrush(RGB(255,255,255));

	// You don't need to initialize your data members here. In fact, you
	// shouldn't do any time consuming updates here. MSInfoRefresh will
	// be called before you need to render or save information.
	//
	// You will want to initialize the member variable which indicates
	// that the control is showing current system info (not any loaded
	// information) as this is the default.

	m_bCurrent = true;
	m_cColumns = 0;
	m_MSInfoView = 0;
	m_pNamespace = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::~CMsieCtrl - Destructor

CMsieCtrl::~CMsieCtrl()
{
	TRACE0("-- CMsieCtrl::~CMsieCtrl()\n");

	// Delete all of the items in the pointer array.

	for (int i = 0; i < m_ptrarray.GetSize(); i++)
		DeleteArrayObject(m_ptrarray.GetAt(i));
	m_ptrarray.RemoveAll();

	delete m_pCtlBkBrush;

	if (m_pNamespace)
		m_pNamespace->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::OnDraw - Drawing function

void CMsieCtrl::OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	TRACE0("-- CMsieCtrl::OnDraw()\n");

	if (m_MSInfoView)
	{
		if (m_MSInfoView == MSIVIEW_CONNECTIVITY)
		{
			DrawLine();
			m_edit.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
		}
		else
			m_list.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME); 
	}
}


/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::DoPropExchange - Persistence support

void CMsieCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// Not using properties, so I'll just leave this one alone.
}


/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::OnResetState - Reset control to default state

void CMsieCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange
}

//-----------------------------------------------------------------------------
// The OnCreate method is used to create the list control. Also, if we've
// already loaded information using Serialize, we can add the lines to
// the list control.
//-----------------------------------------------------------------------------

int CMsieCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	TRACE0("-- CMsieCtrl::OnCreate()\n");

	CRect rect;
	DWORD dwExStyles;
	CString strText;
	CHARFORMAT cf;
	NONCLIENTMETRICS ncm;

	// setup fonts for static and radio button controls

	memset(&ncm, 0, sizeof(ncm));
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	ncm.lfMessageFont.lfWeight = FW_BOLD;
	m_fontStatic.CreateFontIndirect(&ncm.lfMessageFont);

	ncm.lfMessageFont.lfWeight = FW_NORMAL;
	m_fontBtn.CreateFontIndirect(&ncm.lfMessageFont);

	if (COleControl::OnCreate(lpCreateStruct) == -1) return -1;
	
	// In this control, we want to process the WM_CREATE message so we
	// can create the list control which is used to display the print
	// information. Make the list control the same size as the 
	// client area.

	GetClientRect(&rect);

	if (!m_list.Create(WS_CHILD | WS_VSCROLL | WS_HSCROLL | LVS_REPORT, rect, this, IDC_LISTCTRL))
		return -1;

	// set to FullRowSelect (via extended style)

	dwExStyles = (DWORD) ::SendMessage(m_list.m_hWnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);
	::SendMessage(m_list.m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, dwExStyles | LVS_EX_FULLROWSELECT);

	// create static text for Connectivity node

	strText.LoadString(IDS_CONNECTIVITY);
	if (!m_static.Create(strText, WS_CHILD | WS_GROUP | WS_EX_TRANSPARENT | SS_LEFT, CRect(rect.left + 5, rect.top, rect.left + 100, rect.top + 20), this, IDC_STATIC))
		return -1;
	m_static.SetFont(&m_fontStatic);

	// create basic and advanced radio buttons for Connectivity node

	strText.LoadString(IDS_BASIC_INFO);
	if (!m_btnBasic.Create(strText, WS_CHILD | WS_TABSTOP | WS_GROUP | BS_AUTORADIOBUTTON, CRect(rect.left + 5, rect.top + 25, rect.left + 200, rect.top + 45), this, IDC_BTN_BASIC))
		return -1;
	m_btnBasic.SetFont(&m_fontBtn);
	m_btnBasic.SetCheck(1);

	strText.LoadString(IDS_ADVANCED_INFO);
	if (!m_btnAdvanced.Create(strText, WS_CHILD | BS_AUTORADIOBUTTON, CRect(rect.left + 200, rect.top + 25, rect.left + 400, rect.top + 45), this, IDC_BTN_ADVANCED))
		return -1;
	m_btnAdvanced.SetFont(&m_fontBtn);

	// create a rich edit control for display Connectivity node

	if (!m_edit.Create(WS_CHILD | WS_CLIPCHILDREN | WS_TABSTOP | WS_GROUP | WS_VSCROLL | WS_HSCROLL | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | ES_SAVESEL | ES_READONLY, CRect(rect.left, rect.top + 63, rect.right, rect.bottom), this, IDC_EDITCTRL))
		return -1;

	// set default character formatting for rich edit control

	cf.cbSize = sizeof(cf);
	cf.dwMask = CFM_BOLD | CFM_COLOR | CFM_FACE | CFM_SIZE;
	cf.dwEffects = CFE_AUTOCOLOR; 
	cf.yHeight = 180;
	strcpy(cf.szFaceName, "MS Sans Serif");
	m_edit.SetDefaultCharFormat(cf);

	return 0;
}

void CMsieCtrl::DrawLine()
{
	CRect rect;
	CDC *dc = GetDC();
	CBrush brush;

	GetClientRect(&rect);
	brush.CreateSolidBrush(GetBkColor(*dc));
	dc->FillRect(rect, &brush);	
	dc->MoveTo(0, 61);
	dc->LineTo(rect.Width(), 61);
	dc->MoveTo(0, 62);
	dc->LineTo(rect.Width(), 62);

	ReleaseDC(dc);
}

//-----------------------------------------------------------------------------
// The FormatColumns method makes calls to the AddColumn method to create
// all of the necessary columns for this control.
//-----------------------------------------------------------------------------

BOOL CMsieCtrl::FormatColumns()
{
	TRACE1("-- CMsieCtrl::FormatColumns: %i\n", m_MSInfoView);

	int idsCol1, idsCol2;

	// remove current columns

	for (int iCol = m_cColumns - 1; iCol >= 0; iCol--)
		m_list.DeleteColumn(iCol);
	m_cColumns = 0;
	
	if (m_MSInfoView == MSIVIEW_FILE_VERSIONS)
	{
		// File, Version, Size, Date, Path, Company

		AddColumn(IDS_FILE, 0, 17);
		AddColumn(IDS_VERSION, 1, 17);
		AddColumn(IDS_SIZE, 2, 17, 0, LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM, LVCFMT_RIGHT);
		AddColumn(IDS_DATE, 3, 17);
		AddColumn(IDS_PATH, 4, 17);
		AddColumn(IDS_COMPANY, 5, -1);
	}
	else if (m_MSInfoView == MSIVIEW_OBJECT_LIST)
	{
		AddColumn(IDS_PROGRAM_FILE, 0, 40);
		AddColumn(IDS_STATUS, 1, 20);
		AddColumn(IDS_CODE_BASE, 5, -1);
	}
	else if ((m_MSInfoView == MSIVIEW_PERSONAL_CERTIFICATES) || (m_MSInfoView == MSIVIEW_OTHER_PEOPLE_CERTIFICATES))
	{
		AddColumn(IDS_ISSUED_TO, 0, 30);
		AddColumn(IDS_ISSUED_BY, 1, 30);
		AddColumn(IDS_VALIDITY, 5, 20);
		AddColumn(IDS_SIGNATURE_ALGORITHM, 5, -1);
	}
	else if (m_MSInfoView == MSIVIEW_PUBLISHERS)
	{
		AddColumn(IDS_NAME, 0, -1);
	}
	else
	{
		if (m_MSInfoView == MSIVIEW_SECURITY)
		{
			idsCol1 = IDS_ZONE;
			idsCol2 = IDS_SECURITY_LEVEL;
		}
		else
		{
			idsCol1 = IDS_ITEM;
			idsCol2 = IDS_VALUE;
		}

		// Item, Value
		// The item lable gets 40% of the control width, the value label the rest.

		AddColumn(idsCol1, 0, 40);
		AddColumn(idsCol2, 1, -1);
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// The AddColumn method adds (you guessed it) a column to the list control. If
// size is zero, the column is sized large enough to hold the text. If size is
// positive, it is treated as a percentage of the window width. If size is -1,
// the column is sized to fill the remaining space in the window.
//-----------------------------------------------------------------------------

BOOL CMsieCtrl::AddColumn(int idsLabel, int nItem, int size, int nSubItem, int nMask, int nFmt)
{
	LV_COLUMN lvc, getlvc;
	CString strLabel;
	CRect rect;
	int nIndex, spaceUsed = 0, nCol = 0;

	strLabel.LoadString(idsLabel);

	// strip off W2K "[]" stuff

	if (-1 != (nIndex = strLabel.Find(_T('['))))
		strLabel = strLabel.Left(nIndex - 1);

	lvc.mask = nMask;
	lvc.fmt = nFmt;
	lvc.pszText = (LPTSTR)(LPCTSTR)strLabel;
	
	// Save the ratio for this column.

	ASSERT(nItem < 20);
	m_aiRequestedWidths[nItem] = size;
	if (m_cColumns < nItem + 1)
		m_cColumns = nItem + 1;

	// Determine the size of this new column.

	switch (size)
	{
	case 0:	// shouldn't use this, though.
		lvc.cx = m_list.GetStringWidth(lvc.pszText) + 15;
		break;
	case -1:
		getlvc.mask = LVCF_WIDTH;
		for (nCol = 0; m_list.GetColumn(nCol, &getlvc); nCol++)
			spaceUsed += getlvc.cx;
	
		m_list.GetClientRect(&rect);
		lvc.cx = rect.Width() - spaceUsed;
		break;
	default:
		m_list.GetClientRect(&rect);
		lvc.cx = (rect.Width() * size) / 100;
	}

	if (nMask & LVCF_SUBITEM)
	{
		if (nSubItem != -1)
			lvc.iSubItem = nSubItem;
		else
			lvc.iSubItem = nItem;
	}

	m_aiColumnWidths[nItem] = lvc.cx;
	m_aiMaxWidths[nItem] = lvc.cx;
	m_aiMinWidths[nItem] = lvc.cx;

	return m_list.InsertColumn(nItem, &lvc);
}

//-----------------------------------------------------------------------------
// The RefigureColumns method is called when the control is resized. It should
// use the information saved about the columns to change their widths. We
// assume that the last column should be sized to fit the remaining space, if
// possible. Here are our resizing rules:
//
//		1.	If the user has resized something, LEAVE THAT WIDTH ALONE.
//		2.	Otherwise, use the ratios originally set.
//		3.	If a column's wider than its widest item, use the widest item.
//		4.	If a column's smaller than its minimum width, use the min.
//		5.	Always size the last column to fit, unless it would be smaller
//			than its minimum.
//-----------------------------------------------------------------------------

void CMsieCtrl::RefigureColumns(CRect& rect)
{
	int iCol, iPercentageLeft, cxAvailable, cxTotal, cxWidth;
	BOOL bIgnoreColumn[20];

	if (rect == CRect(0,0,0,0))
		m_list.GetClientRect(&rect);

	// Initialize the running totals.

	iPercentageLeft = 100;
	cxAvailable = rect.Width();

	// The first pass will be used to find out what columns to leave alone.
	// Doing this allows us to use make a better estimate of the other
	// column's size using the ratios.

	for (iCol = 0; iCol < m_cColumns; iCol++)
	{
		if (m_list.GetColumnWidth(iCol) != m_aiColumnWidths[iCol])
		{
			cxAvailable -= m_list.GetColumnWidth(iCol);
			iPercentageLeft -= m_aiRequestedWidths[iCol];
			bIgnoreColumn[iCol] = TRUE;
		}
		else
			bIgnoreColumn[iCol] = FALSE;
	}
	cxTotal = cxAvailable;

	// Now, resize the rest of the columns.

	for (iCol = 0; iCol < m_cColumns; iCol++)
	{
		if (bIgnoreColumn[iCol])
			continue;

		// Compute how big this column should be, based on the space
		// remaining. Remember, cxTotal is the total remaining space
		// left after the fixed size columns have been accounted for.

		if (iCol + 1 < m_cColumns)
		{
			cxWidth = m_aiRequestedWidths[iCol] * cxAvailable / iPercentageLeft;
			iPercentageLeft -= m_aiRequestedWidths[iCol];

			if (cxWidth > m_aiMaxWidths[iCol]) cxWidth = m_aiMaxWidths[iCol];
			if (cxWidth < m_aiMinWidths[iCol]) cxWidth = m_aiMinWidths[iCol];
		}
		else
		{
			// This is the last column. Try out using the space available.

			cxWidth = cxAvailable;
			if (cxWidth < m_aiMinWidths[iCol]) cxWidth = m_aiMinWidths[iCol];
		}

		// if first column, add space for icon

		if (!iCol)
			cxWidth += 20;

		cxAvailable -= cxWidth;
		m_list.SetColumnWidth(iCol, cxWidth);
		m_aiColumnWidths[iCol] = m_list.GetColumnWidth(iCol);
	}
}

//-----------------------------------------------------------------------------
// The AddItem method is used to add a line to the list control.
//-----------------------------------------------------------------------------

BOOL CMsieCtrl::AddItem(int nItem, int nSubItem, LPCTSTR strItem, int nImageIndex)
{
	LV_ITEM lvItem;
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = nItem;
	lvItem.iSubItem = nSubItem;
	lvItem.pszText = (LPTSTR)strItem;
	if (nSubItem == 0)
	{
		if (nImageIndex != -1)
		{
			lvItem.mask |= LVIF_IMAGE;
			lvItem.iImage = nImageIndex;
		}
		return m_list.InsertItem(&lvItem);
	}
	return m_list.SetItem(&lvItem);
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// When the view property is changed, we should update whatever
// variables used to display the information so the new view will
// be reflected when the control is redrawn, or when data is returned
// by the MSInfoGetText method. This method should NOT refresh the
// information from the system (that's what MSInfoRefresh is for) or
// cause the control to redraw itself.
//-----------------------------------------------------------------------------

void CMsieCtrl::OnMSInfoViewChanged() 
{
	TRACE1("-- CMsieCtrl::OnMSInfoViewChanged() [changed to %ld]\n", m_MSInfoView);
}


void CMsieCtrl::DeleteArrayObject(void *ptrArray)
{
	LIST_ITEM *pListItem;
	LIST_FILE_VERSION *pFileVersion;
	LIST_OBJECT *pObject;
	LIST_CERT *pCert;
	LIST_NAME *pName;
	EDIT_ITEM *pEditItem;

	if (ptrArray)
	{
		switch (m_MSInfoView)
		{
		case MSIVIEW_FILE_VERSIONS:
			pFileVersion = (LIST_FILE_VERSION *)ptrArray;
			delete pFileVersion;
			break;
		case MSIVIEW_OBJECT_LIST:
			pObject = (LIST_OBJECT *)ptrArray;
			delete pObject;
			break;
		case MSIVIEW_CONNECTIVITY:
			pEditItem = (EDIT_ITEM *)ptrArray;
			delete pEditItem;
			break;
		case MSIVIEW_PERSONAL_CERTIFICATES:
		case MSIVIEW_OTHER_PEOPLE_CERTIFICATES:
			pCert = (LIST_CERT *)ptrArray;
			delete pCert;
			break;
		case MSIVIEW_PUBLISHERS:
			pName = (LIST_NAME *)ptrArray;
			delete pName;
			break;
		default:
			pListItem = (LIST_ITEM *)ptrArray;
			delete pListItem;
		}
	}
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// The MSInfoRefresh method is where the bulk of the work will be
// done for your control. You should requery the system for all of the
// information you display. If this query has the potential to be
// at all time consuming, monitor the long pointed to by pCancel.
// If it is ever non-zero, cancel the update. If the update is
// cancelled, the control is responsible for restoring itself to the
// original, pre-refresh state. 
//
// This method should never be called if the control is displaying 
// previously saved information.
// 
// If the fForSave parameter is TRUE, then the control is being
// updated prior to saving to a stream. In this case, ALL information
// should be gathered (not just info relevant to the current
// MSInfoView) and the control should not be redrawn. Otherwise, for
// efficiency, you can update information only shown by the current
// view.
//-----------------------------------------------------------------------------

void CMsieCtrl::MSInfoRefresh(BOOL fForSave, long FAR* pCancel) 
{
	TRACE1("-- CMsieCtrl::MSInfoRefresh(%s,...)\n", (fForSave) ? "TRUE" : "FALSE");

	CPtrArray ptrarrayNew;
	int i, iListItem;

	if (!m_bCurrent) return;

	// Remember, we need to check if the update was cancelled. It's a good idea
	// to check before we start the update, in case it was cancelled while the
	// control was being loaded.

	if (*pCancel != 0L) return;

	// Call a method to update the new pointer array with current info, based
	// on what view we should be showing.

	iListItem = 0;
	if (fForSave)
	{
		for (i = MSIVIEW_BEGIN; i <= MSIVIEW_END; i++)
			RefreshArray(i, iListItem, ptrarrayNew);
	}
	else
		RefreshArray(m_MSInfoView, iListItem, ptrarrayNew);

	// If this loop has been broken out of because of a cancel, then
	// deallocate all of the structures we've allocated for the list
	// and exit. If we're still OK, copy all of the new items over
	// to the real pointer array (deallocating what's already there).

	if (*pCancel == 0L)
	{
		i = 0;
		while (i < ptrarrayNew.GetSize())
		{
			// Delete what's already in the list (if there is anything
			// in the list).

			if (i < m_ptrarray.GetSize())
				DeleteArrayObject(m_ptrarray.GetAt(i));

			// Copy the element from the new array to the real array.

			m_ptrarray.SetAtGrow(i++, ptrarrayNew.GetAt(i));
		}

		// Finish emptying out the list (if necessary).

		while (i < m_ptrarray.GetSize())
		{
			DeleteArrayObject(m_ptrarray.GetAt(i));
			m_ptrarray.SetAt(i++, NULL);
		}
	}
	else
	{
		// Delete all of the items in the pointer array.

		for (int i = 0; i < ptrarrayNew.GetSize(); i++)
			DeleteArrayObject(ptrarrayNew.GetAt(i));

		ptrarrayNew.RemoveAll();
	}
}

void CMsieCtrl::RefreshArray(int iView, int &iListItem, CPtrArray &ptrarrayNew)
{
	TRACE0("-- CMsieCtrl::RefreshArray\n");

	long lCount, lIndex;

	m_uiView = iView;

	if (iView == MSIVIEW_SUMMARY)
	{
		IE_SUMMARY **ppData;
		CString strVersion;

		theApp.AppGetIEData(SummaryType, &lCount, (void***)&ppData);
		if (lCount == 1)
		{
			AddToArray(ptrarrayNew, iListItem++, IDS_VERSION, GetStringFromVariant((*ppData)->Version));
			AddToArray(ptrarrayNew, iListItem++, IDS_BUILD, GetStringFromVariant((*ppData)->Build));
			AddToArray(ptrarrayNew, iListItem++, IDS_PRODUCT_ID, GetStringFromVariant((*ppData)->ProductID));
			AddToArray(ptrarrayNew, iListItem++, IDS_APP_PATH, GetStringFromVariant((*ppData)->Path));
			AddToArray(ptrarrayNew, iListItem++, IDS_LAST_INSTALL_DATE, GetStringFromVariant((*ppData)->LastInstallDate));
			AddToArray(ptrarrayNew, iListItem++, IDS_LANGUAGE, GetStringFromVariant((*ppData)->Language));
			AddToArray(ptrarrayNew, iListItem++, IDS_ACTIVE_PRINTER, GetStringFromVariant((*ppData)->ActivePrinter));
			AddBlankLineToArray(ptrarrayNew, iListItem++);
			AddToArray(ptrarrayNew, iListItem++, IDS_CIPHER_STRENGTH, GetStringFromVariant((*ppData)->CipherStrength, IDS_FORMAT_BIT));
			AddToArray(ptrarrayNew, iListItem++, IDS_CONTENT_ADVISOR, GetStringFromVariant((*ppData)->ContentAdvisor));
			AddToArray(ptrarrayNew, iListItem++, IDS_IEAK_INSTALL, GetStringFromVariant((*ppData)->IEAKInstall));
		}
		theApp.AppDeleteIEData(SummaryType, lCount, (void**)ppData);
	}
	else if (iView == MSIVIEW_FILE_VERSIONS)
	{
		IE_FILE_VERSION **ppData;

		theApp.AppGetIEData(FileVersionType, &lCount, (void***)&ppData);
		for (lIndex = 0; lIndex < lCount; lIndex++)
		{
			AddFileVersionToArray(ptrarrayNew, iListItem++,
				GetStringFromVariant(ppData[lIndex]->File),
				GetStringFromVariant(ppData[lIndex]->Version),
				GetStringFromVariant(ppData[lIndex]->Size, IDS_FORMAT_KB),
				GetStringFromVariant(ppData[lIndex]->Date),
				GetStringFromVariant(ppData[lIndex]->Path),
				GetStringFromVariant(ppData[lIndex]->Company),
				ppData[lIndex]->Size.lVal,
				ppData[lIndex]->Date.date);
		}
		theApp.AppDeleteIEData(FileVersionType, lCount, (void**)ppData);
	}
	else if (iView == MSIVIEW_CONNECTIVITY)
	{
		IE_CONN_SUMMARY **ppData;
		IE_LAN_SETTINGS **ppLanData;
		IE_CONN_SETTINGS **ppConnData;
		CString strTemp;
		long lLanCount, lConnCount;

		theApp.AppGetIEData(ConnSummaryType, &lCount, (void***)&ppData);
		if (lCount == 1)
		{
			AddEditBlankLineToArray(ptrarrayNew, iListItem++);
			AddEditToArray(ptrarrayNew, iListItem++, IDS_CONN_PREF, GetStringFromVariant((*ppData)->ConnectionPreference));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_ENABLE_HTTP_1_1, GetStringFromVariant((*ppData)->EnableHttp11));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY_HTTP_1_1, GetStringFromVariant((*ppData)->ProxyHttp11));
		}
		theApp.AppDeleteIEData(ConnSummaryType, lCount, (void**)ppData);

		theApp.AppGetIEData(LanSettingsType, &lLanCount, (void***)&ppLanData);
		if (lCount == 1)
		{
			AddEditBlankLineToArray(ptrarrayNew, iListItem++);
			AddEditToArray(ptrarrayNew, iListItem++, IDS_LAN_SETTINGS, _T(""), TRUE);
			AddEditBlankLineToArray(ptrarrayNew, iListItem++);
			AddEditToArray(ptrarrayNew, iListItem++, IDS_AUTO_CONFIG_PROXY, GetStringFromVariant((*ppLanData)->AutoConfigProxy));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_AUTO_PROXY_DETECT_MODE, GetStringFromVariant((*ppLanData)->AutoProxyDetectMode));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_AUTO_CONFIG_URL, GetStringFromVariant((*ppLanData)->AutoConfigURL));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY, GetStringFromVariant((*ppLanData)->Proxy));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY_SERVER, GetStringFromVariant((*ppLanData)->ProxyServer));
			AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY_OVERRIDE, GetStringFromVariant((*ppLanData)->ProxyOverride));
		}
		theApp.AppDeleteIEData(LanSettingsType, lLanCount, (void**)ppLanData);

		theApp.AppGetIEData(ConnSettingsType, &lConnCount, (void***)&ppConnData);
		if (lConnCount > 0)
		{
			for (lIndex = 0; lIndex < lConnCount; lIndex++)
			{
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, GetStringFromVariant(ppConnData[lIndex]->Name), _T(""), TRUE);
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_AUTO_PROXY_DETECT_MODE, GetStringFromVariant(ppConnData[lIndex]->AutoProxyDetectMode));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_AUTO_CONFIG_URL, GetStringFromVariant(ppConnData[lIndex]->AutoConfigURL));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY, GetStringFromVariant(ppConnData[lIndex]->Proxy));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY_SERVER, GetStringFromVariant(ppConnData[lIndex]->ProxyServer));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_PROXY_OVERRIDE, GetStringFromVariant(ppConnData[lIndex]->ProxyOverride));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_ALLOW_INTERNET_PROGRAMS, GetStringFromVariant(ppConnData[lIndex]->AllowInternetPrograms));
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_MAX_ATTEMPTS, GetStringFromVariant(ppConnData[lIndex]->RedialAttempts));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_WAIT_BETWEEN_ATTEMPTS, GetStringFromVariant(ppConnData[lIndex]->RedialWait));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_DISCONNECT_IDLE_TIME, GetStringFromVariant(ppConnData[lIndex]->DisconnectIdleTime));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_AUTO_DISCONNECT, GetStringFromVariant(ppConnData[lIndex]->AutoDisconnect));
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_MODEM, GetStringFromVariant(ppConnData[lIndex]->Modem));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_DIAL_UP_SERVER, GetStringFromVariant(ppConnData[lIndex]->DialUpServer));
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_LOG_ON_TO_NETWORK, GetStringFromVariant(ppConnData[lIndex]->NetworkLogon));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_ENABLE_SOFTWARE_COMPRESSION, GetStringFromVariant(ppConnData[lIndex]->SoftwareCompression));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_REQUIRE_ENCRYPTED_PASSWORD, GetStringFromVariant(ppConnData[lIndex]->EncryptedPassword));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_REQUIRE_DATA_ENCRYPTION, GetStringFromVariant(ppConnData[lIndex]->DataEncryption));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_RECORD_LOG_FILE, GetStringFromVariant(ppConnData[lIndex]->RecordLogFile));
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_NETWORK_PROTOCOLS, GetStringFromVariant(ppConnData[lIndex]->NetworkProtocols));
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_USE_SERVER_ASSIGNED_IP_ADDRESS, GetStringFromVariant(ppConnData[lIndex]->ServerAssignedIPAddress));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_IP_ADDRESS, GetStringFromVariant(ppConnData[lIndex]->IPAddress));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_USE_SERVER_ASSIGNED_NAME_SERVER, GetStringFromVariant(ppConnData[lIndex]->ServerAssignedNameServer));
				strTemp.Format(IDS_PRIMARY_DNS, GetStringFromVariant(ppConnData[lIndex]->PrimaryDNS));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_NAME_SERVER_ADDRESSES, strTemp);
				strTemp.Format(IDS_SECONDARY_DNS, GetStringFromVariant(ppConnData[lIndex]->SecondaryDNS));
				AddEditToArray(ptrarrayNew, iListItem++, _T(""), strTemp);
				strTemp.Format(IDS_PRIMARY_WINS, GetStringFromVariant(ppConnData[lIndex]->PrimaryWINS));
				AddEditToArray(ptrarrayNew, iListItem++, _T(""), strTemp);
				strTemp.Format(IDS_SECONDARY_WINS, GetStringFromVariant(ppConnData[lIndex]->SecondaryWINS));
				AddEditToArray(ptrarrayNew, iListItem++, _T(""), strTemp);
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_USE_IP_HEADER_COMPRESSION, GetStringFromVariant(ppConnData[lIndex]->IPHeaderCompression));
				AddEditToArray(ptrarrayNew, iListItem++, IDS_USE_DEFAULT_GATEWAY, GetStringFromVariant(ppConnData[lIndex]->DefaultGateway));
				AddEditBlankLineToArray(ptrarrayNew, iListItem++);
				AddEditToArray(ptrarrayNew, iListItem++, IDS_SCRIPT_FILE_NAME, GetStringFromVariant(ppConnData[lIndex]->ScriptFileName));
			}
			theApp.AppDeleteIEData(ConnSettingsType, lConnCount, (void**)ppConnData);
		}
		else
		{
			AddEditBlankLineToArray(ptrarrayNew, iListItem++);
			AddEditToArray(ptrarrayNew, iListItem++, IDS_NO_CONNECTIONS, _T(""));
		}
	}
	else if (iView == MSIVIEW_CACHE)
	{
		IE_CACHE **ppData;

		theApp.AppGetIEData(CacheType, &lCount, (void***)&ppData);
		if (lCount == 1)
		{
			AddToArray(ptrarrayNew, iListItem++, IDS_PAGE_REFRESH_TYPE, GetStringFromVariant((*ppData)->PageRefreshType));
			AddToArray(ptrarrayNew, iListItem++, IDS_TEMPORARY_INTERNET_FILES_FOLDER, GetStringFromVariant((*ppData)->TempInternetFilesFolder));
			AddToArray(ptrarrayNew, iListItem++, IDS_TOTAL_DISK_SPACE, GetStringFromVariant((*ppData)->TotalDiskSpace, IDS_FORMAT_MB));
			AddToArray(ptrarrayNew, iListItem++, IDS_AVAILABLE_DISK_SPACE, GetStringFromVariant((*ppData)->AvailableDiskSpace, IDS_FORMAT_MB));
			AddToArray(ptrarrayNew, iListItem++, IDS_MAX_CACHE_SIZE, GetStringFromVariant((*ppData)->MaxCacheSize, IDS_FORMAT_MB));
			AddToArray(ptrarrayNew, iListItem++, IDS_AVAILABLE_CACHE_SIZE, GetStringFromVariant((*ppData)->AvailableCacheSize, IDS_FORMAT_MB));
		}
		theApp.AppDeleteIEData(CacheType, lCount, (void**)ppData);
	}
	else if (iView == MSIVIEW_OBJECT_LIST)
	{
		IE_OBJECT **ppData;

		theApp.AppGetIEData(ObjectType, &lCount, (void***)&ppData);
		if (lCount > 0)
		{
			for (lIndex = 0; lIndex < lCount; lIndex++)
			{
				AddObjectToArray(ptrarrayNew, iListItem++,
					GetStringFromVariant(ppData[lIndex]->ProgramFile),
					GetStringFromVariant(ppData[lIndex]->Status),
					GetStringFromVariant(ppData[lIndex]->CodeBase));
			}
			theApp.AppDeleteIEData(ObjectType, lCount, (void**)ppData);
		}
	}
	else if (iView == MSIVIEW_CONTENT)
	{
		IE_CONTENT **ppData;

		theApp.AppGetIEData(ContentType, &lCount, (void***)&ppData);
		if (lCount == 1)
		{
			AddToArray(ptrarrayNew, iListItem++, IDS_CONTENT_ADVISOR, GetStringFromVariant((*ppData)->Advisor));
		}
		theApp.AppDeleteIEData(ContentType, lCount, (void**)ppData);
	}
	else if ((iView == MSIVIEW_PERSONAL_CERTIFICATES) || (iView == MSIVIEW_OTHER_PEOPLE_CERTIFICATES))
	{
		IE_CERTIFICATE **ppData;
		CString strType;
		int idsType;

		theApp.AppGetIEData(CertificateType, &lCount, (void***)&ppData);
		if (lCount > 0)
		{
			idsType = (iView == MSIVIEW_PERSONAL_CERTIFICATES)? IDS_PERSONAL_TYPE : IDS_OTHER_PEOPLE_TYPE;
			strType.LoadString(idsType);

			for (lIndex = 0; lIndex < lCount; lIndex++)
			{
				if (strType == ppData[lIndex]->Type.bstrVal)
					AddCertificateToArray(ptrarrayNew, iListItem++,
						GetStringFromVariant(ppData[lIndex]->IssuedTo),
						GetStringFromVariant(ppData[lIndex]->IssuedBy),
						GetStringFromVariant(ppData[lIndex]->Validity),
						GetStringFromVariant(ppData[lIndex]->SignatureAlgorithm));
			}
			theApp.AppDeleteIEData(CertificateType, lCount, (void**)ppData);
		}
	}
	else if (iView == MSIVIEW_PUBLISHERS)
	{
		IE_PUBLISHER **ppData;

		theApp.AppGetIEData(PublisherType, &lCount, (void***)&ppData);
		if (lCount > 0)
		{
			for (lIndex = 0; lIndex < lCount; lIndex++)
			{
				AddNameToArray(ptrarrayNew, iListItem++, GetStringFromVariant(ppData[lIndex]->Name));
			}
			theApp.AppDeleteIEData(PublisherType, lCount, (void**)ppData);
		}
	}
	else if (iView == MSIVIEW_SECURITY)
	{
		IE_SECURITY **ppData;

		theApp.AppGetIEData(SecurityType, &lCount, (void***)&ppData);
		if (lCount > 0)
		{
			for (lIndex = 0; lIndex < lCount; lIndex++)
			{
				AddToArray(ptrarrayNew, iListItem++, GetStringFromVariant(ppData[lIndex]->Zone), GetStringFromVariant(ppData[lIndex]->Level));
			}
			theApp.AppDeleteIEData(SecurityType, lCount, (void**)ppData);
		}
	}
}

CString CMsieCtrl::GetStringFromVariant(COleVariant &var, int idsFormat)
{
	COleDateTime dateTime;
	CString strRet;

	switch (var.vt)
	{
	case VT_BSTR:
		strRet = var.bstrVal;
		break;

	case VT_I4:
		if (idsFormat)
			strRet.Format(idsFormat, var.lVal);
		else
			strRet.Format(_T("%d"), var.lVal);
		break;

	case VT_R4:
		if (idsFormat)
			strRet.Format(idsFormat, var.fltVal);
		else
			strRet.Format(_T("%0.1f"), var.fltVal);
		break;

	case VT_BOOL:
		strRet.LoadString(var.boolVal ? IDS_TRUE : IDS_FALSE);
		break;

	case VT_I2:	// boolean
		strRet.LoadString(var.iVal ? IDS_TRUE : IDS_FALSE);
		break;

	case VT_DATE:
		dateTime = var.date;
		strRet = dateTime.Format();
		break;

	case VT_EMPTY:
		strRet.LoadString(IDS_NOT_AVAILABLE);
		break;

	default:
		ASSERT(false);		// should be handling this type
		strRet.LoadString(IDS_NOT_AVAILABLE);
	}
	return strRet;
}

//-----------------------------------------------------------------------------
// This helper method is called to add a list item to an array.
//-----------------------------------------------------------------------------

void CMsieCtrl::AddToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszItem, LPCTSTR pszValue)
{
	LIST_ITEM *pListItem;

	if ((pListItem = new LIST_ITEM) == NULL) 
		return;
	lstrcpyn(pListItem->szItem, pszItem, ITEM_LEN);
	lstrcpyn(pListItem->szValue, pszValue, VALUE_LEN);
	pListItem->uiView = m_uiView;
	ptrarray.SetAtGrow(itemNum, pListItem);
}

void CMsieCtrl::AddToArray(CPtrArray &ptrarray, int itemNum, int idsItem, LPCTSTR pszValue)
{
	CString strItem;

	strItem.LoadString(idsItem);
	AddToArray(ptrarray, itemNum, strItem, pszValue);
}

void CMsieCtrl::AddFileVersionToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszFile, LPCTSTR pszVersion, LPCTSTR pszSize, LPCTSTR pszDate, LPCTSTR pszPath, LPCTSTR pszCompany, DWORD dwSize, DATE date)
{
	LIST_FILE_VERSION *pFileVersion;

	if ((pFileVersion = new LIST_FILE_VERSION) == NULL) 
		return;
	lstrcpyn(pFileVersion->szFile, pszFile, _MAX_FNAME);
	lstrcpyn(pFileVersion->szVersion, pszVersion, VERSION_LEN);
	lstrcpyn(pFileVersion->szSize, pszSize, SIZE_LEN);
	lstrcpyn(pFileVersion->szDate, pszDate, DATE_LEN);
	lstrcpyn(pFileVersion->szPath, pszPath, VALUE_LEN);
	lstrcpyn(pFileVersion->szCompany, pszCompany, VALUE_LEN);
	pFileVersion->uiView = m_uiView;
	pFileVersion->dwSize = dwSize;
	pFileVersion->date = date;
	ptrarray.SetAtGrow(itemNum, pFileVersion);
}

void CMsieCtrl::AddEditToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszItem, LPCTSTR pszValue, BOOL bBold)
{
	EDIT_ITEM *pEditItem;

	if ((pEditItem = new EDIT_ITEM) == NULL) 
		return;

	lstrcpyn(pEditItem->szItem, pszItem, ITEM_LEN);
	lstrcpyn(pEditItem->szValue, pszValue, VALUE_LEN);
	pEditItem->uiView = m_uiView;
	pEditItem->bBold = bBold;
	ptrarray.SetAtGrow(itemNum, pEditItem);
}

void CMsieCtrl::AddEditToArray(CPtrArray &ptrarray, int itemNum, int idsItem, LPCTSTR pszValue, BOOL bBold)
{
	CString strItem;

	strItem.LoadString(idsItem);
	AddEditToArray(ptrarray, itemNum, strItem, pszValue, bBold);
}

void CMsieCtrl::AddObjectToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszProgramFile, LPCTSTR pszStatus, LPCTSTR pszCodeBase)
{
	LIST_OBJECT *pObject;

	if ((pObject = new LIST_OBJECT) == NULL) 
		return;
	lstrcpyn(pObject->szProgramFile, pszProgramFile, _MAX_FNAME);
	lstrcpyn(pObject->szStatus, pszStatus, STATUS_LEN);
	lstrcpyn(pObject->szCodeBase, pszCodeBase, MAX_PATH);
	pObject->uiView = m_uiView;
	ptrarray.SetAtGrow(itemNum, pObject);
}

void CMsieCtrl::AddCertificateToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszIssuedTo, LPCTSTR pszIssuedBy, LPCTSTR pszValidity, LPCTSTR pszSignatureAlgorithm)
{
	LIST_CERT *pCert;

	if ((pCert = new LIST_CERT) == NULL) 
		return;
	lstrcpyn(pCert->szIssuedTo, pszIssuedTo, _MAX_FNAME);
	lstrcpyn(pCert->szIssuedBy, pszIssuedBy, _MAX_FNAME);
	lstrcpyn(pCert->szValidity, pszValidity, _MAX_FNAME);
	lstrcpyn(pCert->szSignatureAlgorithm, pszSignatureAlgorithm, _MAX_FNAME);
	pCert->uiView = m_uiView;
	ptrarray.SetAtGrow(itemNum, pCert);
}

void CMsieCtrl::AddNameToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszName)
{
	LIST_NAME *pName;

	if ((pName = new LIST_NAME) == NULL) 
		return;
	lstrcpyn(pName->szName, pszName, _MAX_FNAME);
	pName->uiView = m_uiView;
	ptrarray.SetAtGrow(itemNum, pName);
}

//-----------------------------------------------------------------------------
// This helper method is called to add a blank line list item to an array.
//-----------------------------------------------------------------------------

void CMsieCtrl::AddBlankLineToArray(CPtrArray &ptrarray, int itemNum)
{
	AddToArray(ptrarray, itemNum, _T(""), _T(""));
}

void CMsieCtrl::AddEditBlankLineToArray(CPtrArray &ptrarray, int itemNum)
{
	AddEditToArray(ptrarray, itemNum, _T(""), _T(""));
}

//-----------------------------------------------------------------------------
// This method is called to update the display with the current data.
//-----------------------------------------------------------------------------

void CMsieCtrl::MSInfoUpdateView() 
{
	TRACE0("-- CMsieCtrl::MSInfoUpdateView()\n");

	if (m_MSInfoView == MSIVIEW_CONNECTIVITY)
	{
		if (!m_edit.IsWindowVisible())
		{
			m_list.ShowWindow(SW_HIDE);
			m_list.EnableWindow(FALSE);

			m_static.ShowWindow(SW_SHOW);
			m_btnBasic.ShowWindow(SW_SHOW);
			m_btnBasic.EnableWindow(TRUE);
			m_btnAdvanced.ShowWindow(SW_SHOW);
			m_btnAdvanced.EnableWindow(TRUE);
			m_edit.ShowWindow(SW_SHOW);
			m_edit.EnableWindow(TRUE);
		}
		RefreshEditControl(TRUE);
	}
	else
	{
		if (!m_list.IsWindowVisible())
		{
			m_static.ShowWindow(SW_HIDE);
			m_btnBasic.ShowWindow(SW_HIDE);
			m_btnBasic.EnableWindow(FALSE);
			m_btnAdvanced.ShowWindow(SW_HIDE);
			m_btnAdvanced.EnableWindow(FALSE);
			m_edit.ShowWindow(SW_HIDE);
			m_edit.EnableWindow(FALSE);

			m_list.ShowWindow(SW_SHOW);
			m_list.EnableWindow(TRUE);
		}
		RefreshListControl(TRUE);
	}
}

//-----------------------------------------------------------------------------
// This method updates the list control to contain the contents of the
// pointer array. This is also where we compute some of the values used in 
// sizing the columns (like minimum and maximum column widths). Remember, only
// put the item in the list view if the MSInfoView index and the flag for
// the item agree.
//
// For each line we add, we set the item data for that line to be the index
// to the element in the pointer array for that item. Since more than one
// line comes from each element in the array, we OR in a constant.
//-----------------------------------------------------------------------------

void CMsieCtrl::RefreshListControl(BOOL bRedraw)
{
	TRACE0("-- CMsieCtrl::RefreshListControl()\n");

	LIST_ITEM *pListItem;
	LIST_FILE_VERSION *pFileVersion;
	LIST_OBJECT *pObject;
	LIST_CERT *pCert;
	LIST_NAME *pName;
	CRect	rect;
	int listIndex = 0;

	m_list.SetRedraw(FALSE);
	m_list.DeleteAllItems();


	// Format columns adds the appropriate columns to the list control.

	FormatColumns();

	for (int itemNum = 0; itemNum < m_ptrarray.GetSize(); itemNum++)
	{
		pListItem = (LIST_ITEM *)m_ptrarray.GetAt(itemNum);
		if (pListItem)
		{
			if ((long)pListItem->uiView == m_MSInfoView)
			{
				if (pListItem->uiView == MSIVIEW_FILE_VERSIONS)
				{
					pFileVersion = (LIST_FILE_VERSION *)pListItem;

					AddItem(listIndex, 0, pFileVersion->szFile);
					AddItem(listIndex, 1, pFileVersion->szVersion);
					AddItem(listIndex, 2, pFileVersion->szSize);
					AddItem(listIndex, 3, pFileVersion->szDate);
					AddItem(listIndex, 4, pFileVersion->szPath);
					AddItem(listIndex, 5, pFileVersion->szCompany);
				}
				else if (pListItem->uiView == MSIVIEW_OBJECT_LIST)
				{
					pObject = (LIST_OBJECT *)pListItem;

					AddItem(listIndex, 0, pObject->szProgramFile);
					AddItem(listIndex, 1, pObject->szStatus);
					AddItem(listIndex, 2, pObject->szCodeBase);
				}
				else if ((pListItem->uiView == MSIVIEW_PERSONAL_CERTIFICATES) || (pListItem->uiView == MSIVIEW_OTHER_PEOPLE_CERTIFICATES))
				{
					pCert = (LIST_CERT *)pListItem;

					AddItem(listIndex, 0, pCert->szIssuedTo);
					AddItem(listIndex, 1, pCert->szIssuedBy);
					AddItem(listIndex, 2, pCert->szValidity);
					AddItem(listIndex, 3, pCert->szSignatureAlgorithm);
				}
				else if (pListItem->uiView == MSIVIEW_PUBLISHERS)
				{
					pName = (LIST_NAME *)pListItem;

					AddItem(listIndex, 0, pName->szName);
				}
				else
				{
					AddItem(listIndex, 0, pListItem->szItem);
					AddItem(listIndex, 1, pListItem->szValue);
				}
				m_list.SetItemData(listIndex, itemNum);
				listIndex++;
			}
		}
	}

	// Now, figure some values for the column widths. But only if we actually added
	// items to the list.

	if (listIndex)
	{
		int cxMax, cxWidth, cxMin, cxAverage;
		for (int iCol = 0; iCol < m_cColumns; iCol++)
		{
			cxMax = 0; cxMin = 0; cxAverage = 0;
			for (int iRow = 0; iRow < m_list.GetItemCount(); iRow++)
			{
				cxWidth = m_list.GetStringWidth(m_list.GetItemText(iRow, iCol));
				if (cxWidth > cxMax) 
					cxMax = cxWidth;
				if ((cxWidth < cxMin || cxMin == 0) && cxWidth != 0) 
					cxMin = cxWidth;

				cxAverage += cxWidth;
			}

			cxAverage /= m_list.GetItemCount();
			m_aiMaxWidths[iCol] = cxMax + 12;
			m_aiMinWidths[iCol] = cxAverage + 12;
		}
	}

	GetClientRect(&rect);
	RefigureColumns(rect);
	m_list.SetRedraw(TRUE);

	if (bRedraw)
		InvalidateControl();
}

void CMsieCtrl::RefreshEditControl(BOOL bRedraw)
{
	TRACE0("-- CMsieCtrl::RefreshEditControl()\n");

	EDIT_ITEM *pEditItem;
	CString strLine;
	CHARFORMAT cf;
	SIZE sizeSpace, sizeStr;
	int itemNum, nLen, i, cLines = 0;
	BOOL bBasicView;

	DrawLine();

	m_edit.SetRedraw(FALSE);
	m_edit.SetWindowText(_T(""));

	bBasicView = m_btnBasic.GetCheck();

	cf.cbSize = sizeof(cf);
	cf.dwMask = CFM_BOLD;
	GetTextExtentPoint(m_edit.GetDC()->m_hDC, _T(" "), 1, &sizeSpace);
	for (itemNum = 0; itemNum < m_ptrarray.GetSize(); itemNum++)
	{
		pEditItem = (EDIT_ITEM *)m_ptrarray.GetAt(itemNum);
		if (pEditItem)
		{
			if ((long)pEditItem->uiView == m_MSInfoView)
			{
				strLine = _T("   ");
				if (!pEditItem->bBold)
					strLine += _T(' ');

				strLine += pEditItem->szItem;

				if (pEditItem->szValue[0] != _T('\0'))
				{
					GetTextExtentPoint(m_edit.GetDC()->m_hDC, pEditItem->szItem, _tcslen(pEditItem->szItem), &sizeStr);

					nLen = sizeStr.cx / sizeSpace.cx;
					if (nLen < 50)
					{
						for (i = nLen; i < 50; i++)
							strLine += _T(' ');
					}
					strLine += _T('\t');
					strLine += pEditItem->szValue;
				}
				strLine += _T('\n');

				m_edit.SetSel(-1, -1);

				cf.dwEffects = pEditItem->bBold ? CFE_BOLD : 0;
				m_edit.SetSelectionCharFormat(cf);

				m_edit.ReplaceSel(strLine);

				// only show default connection info if basic info button checked

				if (bBasicView)
					if (++cLines == CONNECTIVITY_BASIC_LINES)
						break;
			}
		}
	}

	m_edit.SetRedraw(TRUE);
	if (bRedraw)
		InvalidateControl();
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// When the control is resized, we want to also resize the list
// control. We'll also call a method to resize the columns in the
// list control, based on the new control size.
//-----------------------------------------------------------------------------

void CMsieCtrl::OnSize(UINT nType, int cx, int cy) 
{
	COleControl::OnSize(nType, cx, cy);

	CRect rect;
	GetClientRect(&rect);

	m_edit.MoveWindow(CRect(rect.left, rect.top + 63, rect.right, rect.bottom));
	m_list.MoveWindow(&rect);

	if (m_MSInfoView == MSIVIEW_CONNECTIVITY)
	{
		m_edit.Invalidate();
	}
	else
	{
		RefigureColumns(rect);
		m_list.Invalidate();
	}
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// The Serialize method is used to save the state of your object to
// a stream, or to load it from a stream. This stream is part of the
// compound MSInfo file. Your control can also open a file directly
// by making an entry in the MSInfo registry key indicating what
// file types it can open. In that case, the file will be passed to
// MSInfoLoadFile.
//
// The InternetExplorer category will save the items in it's list view to the
// archive as a struct. The first item in the archive will be a DWORD
// indicating how many pairs will be saved. The view for each struct will be
// archived out just before the struct for easier loading (knowing which type
// of struct to new for loading).
//-----------------------------------------------------------------------------

void CMsieCtrl::Serialize(CArchive& ar) 
{
	TRACE1("-- CMsieCtrl::Serialize() [%s]\n", (ar.IsStoring()) ? "STORE" : "LOAD");

	LIST_ITEM *pListItem;
	LIST_FILE_VERSION *pFileVersion;
	LIST_OBJECT *pObject;
	LIST_CERT *pCert;
	LIST_NAME *pName;
	EDIT_ITEM *pEditItem;
	DWORD dwCount;
	UINT uiView;

	if (ar.IsStoring())
	{
		dwCount = (DWORD) m_ptrarray.GetSize();
		ar << dwCount;

		for (DWORD i = 0; i < dwCount; i++)
		{
			pListItem = (LIST_ITEM *)m_ptrarray.GetAt(i);
			if (pListItem)
			{
				ar << pListItem->uiView;
				switch (pListItem->uiView)
				{
				case MSIVIEW_FILE_VERSIONS:
					pFileVersion = (LIST_FILE_VERSION *)pListItem;
					ar.Write((void *)pFileVersion, sizeof(LIST_FILE_VERSION));
					break;
				case MSIVIEW_OBJECT_LIST:
					pObject = (LIST_OBJECT *)pListItem;
					ar.Write((void *)pObject, sizeof(LIST_OBJECT));
					break;
				case MSIVIEW_CONNECTIVITY:
					pEditItem = (EDIT_ITEM *)pListItem;
					ar.Write((void *)pEditItem, sizeof(EDIT_ITEM));
					break;
				case MSIVIEW_PERSONAL_CERTIFICATES:
				case MSIVIEW_OTHER_PEOPLE_CERTIFICATES:
					pCert = (LIST_CERT *)pListItem;
					ar.Write((void *)pCert, sizeof(LIST_CERT));
					break;
				case MSIVIEW_PUBLISHERS:
					pName = (LIST_NAME *)pListItem;
					ar.Write((void *)pName, sizeof(LIST_NAME));
					break;
				default:
					ar.Write((void *)pListItem, sizeof(LIST_ITEM));
				}
			}
		}
	}
	else
	{
		ar >> dwCount;
		for (DWORD i = 0; i < dwCount; i++)
		{
			ar >> uiView;
			switch (uiView)
			{
			case MSIVIEW_FILE_VERSIONS:
				pFileVersion = new LIST_FILE_VERSION;
				if (pFileVersion)
				{
					if (ar.Read((void *)pFileVersion, sizeof(LIST_FILE_VERSION)) != sizeof(LIST_FILE_VERSION))
						break;
					m_ptrarray.SetAtGrow(i, pFileVersion);
				}
				break;
			case MSIVIEW_OBJECT_LIST:
				pObject = new LIST_OBJECT;
				if (pObject)
				{
					if (ar.Read((void *)pObject, sizeof(LIST_OBJECT)) != sizeof(LIST_OBJECT))
						break;
					m_ptrarray.SetAtGrow(i, pObject);
				}
				break;
			case MSIVIEW_CONNECTIVITY:
				pEditItem = new EDIT_ITEM;
				if (pEditItem)
				{
					if (ar.Read((void *)pEditItem, sizeof(EDIT_ITEM)) != sizeof(EDIT_ITEM))
						break;
					m_ptrarray.SetAtGrow(i, pEditItem);
				}
				break;
			case MSIVIEW_PERSONAL_CERTIFICATES:
			case MSIVIEW_OTHER_PEOPLE_CERTIFICATES:
				pCert = new LIST_CERT;
				if (pCert)
				{
					if (ar.Read((void *)pCert, sizeof(LIST_CERT)) != sizeof(LIST_CERT))
						break;
					m_ptrarray.SetAtGrow(i, pCert);
				}
				break;
			case MSIVIEW_PUBLISHERS:
				pName = new LIST_NAME;
				if (pName)
				{
					if (ar.Read((void *)pName, sizeof(LIST_NAME)) != sizeof(LIST_NAME))
						break;
					m_ptrarray.SetAtGrow(i, pName);
				}
				break;
			default:
				pListItem = new LIST_ITEM;
				if (pListItem)
				{
					if (ar.Read((void *)pListItem, sizeof(LIST_ITEM)) != sizeof(LIST_ITEM))
						break;
					m_ptrarray.SetAtGrow(i, pListItem);
				}
			}
		}
		m_bCurrent = false;
	} 
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// A control used in MSInfo has the ability to register itself as
// recognizing a file type (by extension). This entry is made in the
// registry, and when MSInfo lets the user open a file, files of this
// type can be displayed. If a file is chosen, a different set of
// categories is loaded, presumably all using this control. When
// the control is created, a call will be made to MSInfoLoadFile with
// the file to load.
//
// There isn't a native file format for this control, so we do
// exactly nothing.
//-----------------------------------------------------------------------------

BOOL CMsieCtrl::MSInfoLoadFile(LPCTSTR szFileName) 
{
	TRACE1("-- CMsieCtrl::MSInfoLoadFile(%s)\n", szFileName);
	return TRUE;
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// This method should do a select all on the information the control
// shows. This only applies to controls which support selection.
// If the selection is changed, the control is responsible for
// redrawing itself
//
// For this control, we mark all of the items in the list view as selected.
//-----------------------------------------------------------------------------

void CMsieCtrl::MSInfoSelectAll() 
{
	TRACE0("-- CMsieCtrl::SelectAll()\n");

	if (m_MSInfoView == MSIVIEW_CONNECTIVITY)
	{
		m_edit.SetFocus();
		m_edit.SetSel(0, -1);
	}
	else
	{
		m_list.SetFocus();
		for (int i = 0; i < m_list.GetItemCount(); i++)
			m_list.SetItemState(i, LVIS_SELECTED, LVIS_SELECTED);
	}

	InvalidateControl();
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// Use this method to copy the currently selected information into
// the clipboard in an appropriate format. If your control does not
// support user selection, then all of the data displayed by your
// control should be put into the clipboard. If this is the case,
// only the information shown by the current MSInfoView should be
// copied (if you support multiple views).
//
// We'll scan through the list view, and generate a text string
// containing the text from each selected line.
//-----------------------------------------------------------------------------

void CMsieCtrl::MSInfoCopy() 
{
	TRACE0("-- CMsieCtrl::MSInfoCopy()\n");

	CString strReturnText;
	int i, nIndex;

	// Build a string of the text of selected items.

	if (m_MSInfoView == MSIVIEW_CONNECTIVITY)
	{
		strReturnText = m_edit.GetSelText();
	}
	else
	{
		for (i = 0; i < m_list.GetItemCount(); i++)
		{
			if (m_list.GetItemState(i, LVIS_SELECTED) != 0)
			{
				strReturnText += m_list.GetItemText(i, 0);
				for (nIndex = 1; nIndex < m_cColumns; nIndex++)
				{
					strReturnText += '\t';
					strReturnText += m_list.GetItemText(i, nIndex);
				}
				strReturnText += CString("\r\n");
			}
		}
	}

	// Put that text in the clipboard.

	if (OpenClipboard())
	{
		if (EmptyClipboard())
		{
			DWORD	dwSize = strReturnText.GetLength() + 1;	// +1 for terminating NULL
			HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dwSize);

			if (hMem)
			{
				LPVOID lpvoid = GlobalLock(hMem);
				if (lpvoid)
				{
					memcpy(lpvoid, (LPCTSTR) strReturnText, dwSize);
					GlobalUnlock(hMem);
					SetClipboardData(CF_TEXT, hMem);
				}
			}
		}
		CloseClipboard();
	}
}

//-----------------------------------------------------------------------------
// MSInfo Specific...
//
// The control should return its contents as text when this method
// is called. The parameters are a pointer to a buffer and a length
// of the buffer in bytes. Write the contents of the control to the
// buffer (including a null) up to dwLength. Return the number of
// bytes copied (not including the null). If the pointer parameter is
// null, then just return the length.
//
// For this example, we get the text from the list and concatenate
// the columns together.
//-----------------------------------------------------------------------------

static CString strGetDataReturnText;

long CMsieCtrl::MSInfoGetData(long dwMSInfoView, long FAR* pBuffer, long dwLength) 
{
	TRACE2("-- CMsieCtrl::MSInfoGetData(0x%08x, %ld)\n", (long) pBuffer, dwLength);

	LIST_ITEM *	pListItem;
	LIST_FILE_VERSION *pFileVersion;
	LIST_OBJECT *pObject;
	LIST_CERT *pCert;
	LIST_NAME *pName;
	CString strWorking, strTemp;

	if (pBuffer == NULL)
	{
		// We should get the data from the array of pointers, not the list
		// control. This is because this method might be called without
		// ever drawing the list. We need to use the current MSInfoView
		// in determining what to return.

		strGetDataReturnText.Empty();

		// write out column headers if view with columns

		switch (dwMSInfoView)
		{
		case MSIVIEW_FILE_VERSIONS:
			strTemp.LoadString(IDS_FILE);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_VERSION);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_SIZE);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_DATE);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_PATH);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_COMPANY);
			strGetDataReturnText += strTemp;
			break;

		case MSIVIEW_OBJECT_LIST:
			strTemp.LoadString(IDS_PROGRAM_FILE);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_STATUS);
			strGetDataReturnText += strTemp;
			strGetDataReturnText += '\t';
			strTemp.LoadString(IDS_CODE_BASE);
			strGetDataReturnText += strTemp;
			break;

		case MSIVIEW_PERSONAL_CERTIFICATES:
		case MSIVIEW_OTHER_PEOPLE_CERTIFICATES:
			break;

//  BUGBUG: NEED TO FILL IN!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

		case MSIVIEW_PUBLISHERS:
			break;

//  BUGBUG: NEED TO FILL IN!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

			break;
		}

		for (int i = 0; i < m_ptrarray.GetSize(); i++)
		{
			pListItem = (LIST_ITEM *) m_ptrarray.GetAt(i);
			if (pListItem != NULL)
			{
				if ((long)pListItem->uiView == dwMSInfoView)
				{
					strWorking.Empty();

					switch (dwMSInfoView)
					{
					case MSIVIEW_FILE_VERSIONS:
						pFileVersion = (LIST_FILE_VERSION *)pListItem;
						if (pFileVersion->szFile[0] != _T('\0'))
						{
							strWorking += pFileVersion->szFile;
							strWorking += '\t';
							strWorking += pFileVersion->szVersion;
							strWorking += '\t';
							strWorking += pFileVersion->szSize;
							strWorking += '\t';
							strWorking += pFileVersion->szDate;
							strWorking += '\t';
							strWorking += pFileVersion->szPath;
							strWorking += '\t';
							strWorking += pFileVersion->szCompany;
						}
						break;

					case MSIVIEW_OBJECT_LIST:
						pObject = (LIST_OBJECT *)pListItem;
						if (pObject->szProgramFile[0] != _T('\0'))
						{
							strWorking += pObject->szProgramFile;
							strWorking += '\t';
							strWorking += pObject->szStatus;
							strWorking += '\t';
							strWorking += pObject->szCodeBase;
						}
						break;

					case MSIVIEW_PERSONAL_CERTIFICATES:
					case MSIVIEW_OTHER_PEOPLE_CERTIFICATES:
						pCert = (LIST_CERT *)pListItem;
						if (pCert->szIssuedTo[0] != _T('\0'))
						{
							strWorking += pCert->szIssuedTo;
							strWorking += '\t';
							strWorking += pCert->szIssuedBy;
							strWorking += '\t';
							strWorking += pCert->szValidity;
							strWorking += '\t';
							strWorking += pCert->szSignatureAlgorithm;
						}
						break;

					case MSIVIEW_PUBLISHERS:
						pName = (LIST_NAME *)pListItem;
						if (pName->szName[0] != _T('\0'))
						{
							strWorking += pName->szName;
						}
						break;

					default:
						strWorking += pListItem->szItem;
						strWorking += '\t';
						strWorking += pListItem->szValue;
					}
					strWorking.TrimRight();
					if (!strGetDataReturnText.IsEmpty())
						strGetDataReturnText += _T("\r\n");
					strGetDataReturnText += strWorking;
				}
			}
		}

		return (long) strGetDataReturnText.GetLength();
	}
	else
	{
		DWORD	dwSize;

		// dwSize will be the number of characters to copy, and shouldn't
		// include the null terminator.

		dwSize = strGetDataReturnText.GetLength();
		if (dwLength <= (long)dwSize)
		{
			// There isn't enough room in the buffer to copy all of the
			// characters and the null, so we'll need to concatenate.

			dwSize = dwLength - 1;
		}

		memcpy(pBuffer, (LPCTSTR) strGetDataReturnText, dwSize);
		((char *)pBuffer)[dwSize] = '\0';
		return (long) dwSize;
	}
}

//-----------------------------------------------------------------------------
// We override the OnNotify member because we want to be able to take action
// when the user resizes a column (possibly by double clicking the divider)
// and when the user clicks on a column header (we want to sort by that
// column).
//-----------------------------------------------------------------------------

CPtrArray* pptrarray;
static bool bAscendingOrder = true;
static int nLastColumn = 0;
int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
BOOL CMsieCtrl::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	NMHDR *pnmhdr = (NMHDR *)lParam;
	NM_LISTVIEW *pnmlv;

	if (pnmhdr)
	{
		if (pnmhdr->code == HDN_ENDTRACK || pnmhdr->code == HDN_DIVIDERDBLCLICK)
			RefigureColumns(CRect(0,0,0,0));

		if (wParam == IDC_LISTCTRL)
		{
			switch (pnmhdr->code)
			{
			case LVN_COLUMNCLICK:

				if ((m_MSInfoView == MSIVIEW_FILE_VERSIONS) ||
					(m_MSInfoView == MSIVIEW_OBJECT_LIST) ||
					(m_MSInfoView == MSIVIEW_PERSONAL_CERTIFICATES) ||
					(m_MSInfoView == MSIVIEW_OTHER_PEOPLE_CERTIFICATES) ||
					(m_MSInfoView == MSIVIEW_PUBLISHERS))
				{
					pnmlv = (NM_LISTVIEW*)lParam;
					pptrarray = &m_ptrarray;

					if (nLastColumn == pnmlv->iSubItem)
					{
						bAscendingOrder = !bAscendingOrder;
					}
					else
					{
						bAscendingOrder = true;
						nLastColumn = pnmlv->iSubItem;
					}

					m_list.SortItems(CompareFunc, (LPARAM)pnmlv->iSubItem);
				}
				break;
			}
		}
	}
	
	return COleControl::OnNotify(wParam, lParam, pResult);
}

//-----------------------------------------------------------------------------
// This compare function is called by the list control as a callback when we
// sort the list.
//-----------------------------------------------------------------------------

int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	int nRet = 0;
	double flDateDiff;

   // lParamSort contains a pointer to the list view control.
   // The lParam of an item is just its index.

	LIST_ITEM *pItem = (LIST_ITEM *)pptrarray->GetAt(lParam1);

	if (pItem->uiView == MSIVIEW_FILE_VERSIONS)
	{
		LIST_FILE_VERSION* pItem1 = (LIST_FILE_VERSION *)pptrarray->GetAt(lParam1);
		LIST_FILE_VERSION* pItem2 = (LIST_FILE_VERSION *)pptrarray->GetAt(lParam2);

		ASSERT(pItem1 != NULL && pItem2 != NULL);
		if (pItem1 == NULL || pItem2 == NULL)
			return 0;

		switch (lParamSort)
		{
			case 0:
				nRet = _tcsicmp(pItem1->szFile, pItem2->szFile);
				break;

			case 1:
				nRet = _tcsicmp(pItem2->szVersion, pItem1->szVersion);
				break;
			
			case 2:
				nRet = pItem1->dwSize - pItem2->dwSize;
				break;
			
			case 3:
				flDateDiff = pItem1->date - pItem2->date;
				if (flDateDiff > 0)
					nRet = -1;
				else if (flDateDiff < 0)
					nRet = 1;
				break;

			case 4:
				nRet = _tcsicmp(pItem1->szPath, pItem2->szPath);
				break;

			case 5:
				nRet = _tcsicmp(pItem1->szCompany, pItem2->szCompany);
				break;
		}
	}
	else if (pItem->uiView == MSIVIEW_OBJECT_LIST)
	{
		LIST_OBJECT* pItem1 = (LIST_OBJECT *)pptrarray->GetAt(lParam1);
		LIST_OBJECT* pItem2 = (LIST_OBJECT *)pptrarray->GetAt(lParam2);

		ASSERT(pItem1 != NULL && pItem2 != NULL);
		if (pItem1 == NULL || pItem2 == NULL)
			return 0;

		switch (lParamSort)
		{
			case 0:
				nRet = _tcsicmp(pItem1->szProgramFile, pItem2->szProgramFile);
				break;

			case 1:
				nRet = _tcsicmp(pItem1->szStatus, pItem2->szStatus);
				break;
			
			case 2:
				nRet = _tcsicmp(pItem1->szCodeBase, pItem2->szCodeBase);
				break;
		}
	}
	else if ((pItem->uiView == MSIVIEW_PERSONAL_CERTIFICATES) || (pItem->uiView == MSIVIEW_OTHER_PEOPLE_CERTIFICATES))
	{
		LIST_CERT* pItem1 = (LIST_CERT *)pptrarray->GetAt(lParam1);
		LIST_CERT* pItem2 = (LIST_CERT *)pptrarray->GetAt(lParam2);

		ASSERT(pItem1 != NULL && pItem2 != NULL);
		if (pItem1 == NULL || pItem2 == NULL)
			return 0;

		switch (lParamSort)
		{
			case 0:
				nRet = _tcsicmp(pItem1->szIssuedTo, pItem2->szIssuedTo);
				break;

			case 1:
				nRet = _tcsicmp(pItem1->szIssuedBy, pItem2->szIssuedBy);
				break;
			
			case 2:
				nRet = _tcsicmp(pItem1->szValidity, pItem2->szValidity);
				break;

			case 3:
				nRet = _tcsicmp(pItem1->szSignatureAlgorithm, pItem2->szSignatureAlgorithm);
				break;
		}
	}
	else if (pItem->uiView == MSIVIEW_PUBLISHERS)
	{
		LIST_NAME* pItem1 = (LIST_NAME *)pptrarray->GetAt(lParam1);
		LIST_NAME* pItem2 = (LIST_NAME *)pptrarray->GetAt(lParam2);

		ASSERT(pItem1 != NULL && pItem2 != NULL);
		if (pItem1 == NULL || pItem2 == NULL)
			return 0;

		switch (lParamSort)
		{
			case 0:
				nRet = _tcsicmp(pItem1->szName, pItem2->szName);
				break;
		}
	}

	if (!bAscendingOrder)
		nRet = -nRet;

	return nRet;
}

HBRUSH CMsieCtrl::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	switch (nCtlColor)
	{
	case CTLCOLOR_STATIC:
	case CTLCOLOR_BTN:
		return (HBRUSH)(m_pCtlBkBrush->GetSafeHandle());

	default:
		return CWnd::OnCtlColor(pDC, pWnd, nCtlColor);
	}
}

void CMsieCtrl::OnBasicBtnClicked()
{
	MSInfoUpdateView();
}

void CMsieCtrl::OnAdvancedBtnClicked()
{
	MSInfoUpdateView();
}

/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::XWbemProviderInit

STDMETHODIMP_(ULONG) CMsieCtrl::XWbemProviderInit::AddRef()
{
	METHOD_PROLOGUE(CMsieCtrl, WbemProviderInit)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CMsieCtrl::XWbemProviderInit::Release()
{
	METHOD_PROLOGUE(CMsieCtrl, WbemProviderInit)
	return pThis->ExternalRelease();
}

STDMETHODIMP CMsieCtrl::XWbemProviderInit::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE(CMsieCtrl, WbemProviderInit)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CMsieCtrl::XWbemProviderInit::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
	METHOD_PROLOGUE(CMsieCtrl, WbemProviderInit)

	if (pNamespace)
		pNamespace->AddRef();
	pThis->m_pNamespace = pNamespace;

	//Let CIMOM know you are initialized

	pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);

	return WBEM_S_NO_ERROR;
}

/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl::XWbemServices

STDMETHODIMP_(ULONG) CMsieCtrl::XWbemServices::AddRef()
{
	METHOD_PROLOGUE(CMsieCtrl, WbemServices)
	return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CMsieCtrl::XWbemServices::Release()
{
	METHOD_PROLOGUE(CMsieCtrl, WbemServices)
	return pThis->ExternalRelease();
}

STDMETHODIMP CMsieCtrl::XWbemServices::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	METHOD_PROLOGUE(CMsieCtrl, WbemServices)
	return pThis->ExternalQueryInterface(&iid, ppvObj);
}

SCODE CMsieCtrl::XWbemServices::CreateInstanceEnumAsync(const BSTR RefStr, long lFlags, IWbemContext *pCtx, IWbemObjectSink *pHandler)
{
	METHOD_PROLOGUE(CMsieCtrl, WbemServices)

	IWbemClassObject *pClass = NULL;
	IWbemClassObject **ppInstances = NULL;
	SCODE sc;
	void **ppData;
	IEDataType enType;
	long cInstances, lIndex;

	CoImpersonateClient();

	// Do a check of arguments and make sure we have pointer to Namespace

	if (pHandler == NULL || pThis->m_pNamespace == NULL)
		return WBEM_E_INVALID_PARAMETER;

	// Get a class object from CIMOM

	sc = pThis->m_pNamespace->GetObject(RefStr, 0, pCtx, &pClass, NULL);
	if (sc != S_OK)
		return WBEM_E_FAILED;

	if (pThis->GetIEType(RefStr, enType))
	{
		theApp.AppGetIEData(enType, &cInstances, (void***)&ppData);

		ppInstances = (IWbemClassObject**)new LPVOID[cInstances];

		for (lIndex = 0; lIndex < cInstances; lIndex++)
		{
			// Create an instance object and fill it will appropriate Office data

			sc = pClass->SpawnInstance(0, &ppInstances[lIndex]);
			if (SUCCEEDED(sc))
			{
				pThis->SetIEProperties(enType, ppData[lIndex], ppInstances[lIndex]);
			}
		}
		theApp.AppDeleteIEData(enType, cInstances, ppData);
	}
	else
	{
		sc = WBEM_E_NOT_FOUND;
	}

	pClass->Release();

	if (SUCCEEDED(sc))
	{
		// Send the instances to the caller

		pHandler->Indicate(cInstances, ppInstances);

		for (lIndex = 0; lIndex < cInstances; lIndex++)
			ppInstances[lIndex]->Release();
	}

	// Clean up

	if (ppInstances)
		delete []ppInstances;

	// Set status

	pHandler->SetStatus(0, sc, NULL, NULL);

	return sc;
}

bool CMsieCtrl::GetIEType(const BSTR classStr, IEDataType &enType)
{
	bool bRet = true;
	CString strClass(classStr);

	if (strClass == _T("MicrosoftIE_Summary"))  enType = SummaryType;
	else if (strClass == _T("MicrosoftIE_FileVersion"))  enType = FileVersionType;
	else if (strClass == _T("MicrosoftIE_ConnectionSummary"))  enType = ConnSummaryType;
	else if (strClass == _T("MicrosoftIE_LanSettings"))  enType = LanSettingsType;
	else if (strClass == _T("MicrosoftIE_ConnectionSettings"))  enType = ConnSettingsType;
	else if (strClass == _T("MicrosoftIE_Cache"))  enType = CacheType;
	else if (strClass == _T("MicrosoftIE_Object"))  enType = ObjectType;
	else if (strClass == _T("MicrosoftIE_Certificate"))  enType = CertificateType;
	else if (strClass == _T("MicrosoftIE_Publisher"))  enType = PublisherType;
	else if (strClass == _T("MicrosoftIE_Security"))  enType = SecurityType;
	else
	{
		bRet = false;
	}

	return bRet;
}

void CMsieCtrl::ConvertDateToWbemString(COleVariant &var)
{
	COleDateTime dateTime;
	CString strDateTime;

	dateTime = var.date;
	strDateTime = dateTime.Format(_T("%Y%m%d%H%M%S.******+***"));
	var = strDateTime.AllocSysString();
}

void CMsieCtrl::SetIEProperties(IEDataType enType, void *pIEData, IWbemClassObject *pInstance)
{
	if (enType == SummaryType)
	{
		IE_SUMMARY *pData = (IE_SUMMARY*)pIEData;

		SETPROPERTY(Name);
		SETPROPERTY(Version);
		SETPROPERTY(Build);
		SETPROPERTY(ProductID);
		SETPROPERTY(Path);
		SETPROPERTY(Language);
		SETPROPERTY(ActivePrinter);
		SETPROPERTY(CipherStrength);
		SETPROPERTY(ContentAdvisor);
		SETPROPERTY(IEAKInstall);
	}
	else if (enType == FileVersionType)
	{
		IE_FILE_VERSION *pData = (IE_FILE_VERSION*)pIEData;
		CString strVersion, strFileMissing;

		SETPROPERTY(File);
		SETPROPERTY(Version);

		// don't set rest of properties if file is missing

		strVersion = pData->Version.bstrVal;
		strFileMissing.LoadString(IDS_FILE_MISSING);
		if (strFileMissing != strVersion)
		{
			SETPROPERTY(Size);
			SETPROPERTY(Date);
			SETPROPERTY(Path);
			SETPROPERTY(Company);
		}
	}
	else if (enType == ConnSummaryType)
	{
		IE_CONN_SUMMARY *pData = (IE_CONN_SUMMARY*)pIEData;

		SETPROPERTY(ConnectionPreference);
		SETPROPERTY(EnableHttp11);
		SETPROPERTY(ProxyHttp11);
	}
	else if (enType == LanSettingsType)
	{
		IE_LAN_SETTINGS *pData = (IE_LAN_SETTINGS*)pIEData;

		SETPROPERTY(AutoConfigProxy);
		SETPROPERTY(AutoProxyDetectMode);
		SETPROPERTY(AutoConfigURL);
		SETPROPERTY(Proxy);
		SETPROPERTY(ProxyServer);
		SETPROPERTY(ProxyOverride);
	}
	else if (enType == ConnSettingsType)
	{
		IE_CONN_SETTINGS *pData = (IE_CONN_SETTINGS*)pIEData;

		SETPROPERTY(Name);
		SETPROPERTY(Default);
		SETPROPERTY(AutoProxyDetectMode);
		SETPROPERTY(AutoConfigURL);
		SETPROPERTY(Proxy);
		SETPROPERTY(ProxyServer);
		SETPROPERTY(ProxyOverride);
		SETPROPERTY(AllowInternetPrograms);
		SETPROPERTY(RedialAttempts);
		SETPROPERTY(RedialWait);
		SETPROPERTY(DisconnectIdleTime);
		SETPROPERTY(AutoDisconnect);
		SETPROPERTY(Modem);
		SETPROPERTY(DialUpServer);
		SETPROPERTY(NetworkLogon);
		SETPROPERTY(SoftwareCompression);
		SETPROPERTY(EncryptedPassword);
		SETPROPERTY(DataEncryption);
		SETPROPERTY(NetworkProtocols);
		SETPROPERTY(ServerAssignedIPAddress);
		SETPROPERTY(IPAddress);
		SETPROPERTY(ServerAssignedNameServer);
		SETPROPERTY(PrimaryDNS);
		SETPROPERTY(SecondaryDNS);
		SETPROPERTY(PrimaryWINS);
		SETPROPERTY(SecondaryWINS);
		SETPROPERTY(IPHeaderCompression);
		SETPROPERTY(DefaultGateway);
		SETPROPERTY(ScriptFileName);
	}
	else if (enType == CacheType)
	{
		IE_CACHE *pData = (IE_CACHE*)pIEData;

		SETPROPERTY(PageRefreshType);
		SETPROPERTY(TempInternetFilesFolder);
		SETPROPERTY(TotalDiskSpace);
		SETPROPERTY(AvailableDiskSpace);
		SETPROPERTY(MaxCacheSize);
		SETPROPERTY(AvailableCacheSize);
	}
	else if (enType == ObjectType)
	{
		IE_OBJECT *pData = (IE_OBJECT*)pIEData;

		SETPROPERTY(ProgramFile);
		SETPROPERTY(Status);
		SETPROPERTY(CodeBase);
	}
	else if (enType == CertificateType)
	{
		IE_CERTIFICATE *pData = (IE_CERTIFICATE*)pIEData;

		SETPROPERTY(Type);
		SETPROPERTY(IssuedTo);
		SETPROPERTY(IssuedBy);
		SETPROPERTY(Validity);
		SETPROPERTY(SignatureAlgorithm);
	}
	else if (enType == PublisherType)
	{
		IE_PUBLISHER *pData = (IE_PUBLISHER*)pIEData;

		SETPROPERTY(Name);
	}
	else if (enType == SecurityType)
	{
		IE_SECURITY *pData = (IE_SECURITY*)pIEData;

		SETPROPERTY(Zone);
		SETPROPERTY(Level);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\msiectl.h ===
// MsieCtl.h : Declaration of the CMsieCtrl ActiveX Control class.

#if !defined(AFX_MSIECTL_H__25959BFC_E700_11D2_A7AF_00C04F806200__INCLUDED_)
#define AFX_MSIECTL_H__25959BFC_E700_11D2_A7AF_00C04F806200__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <wbemprov.h>

// MSInfo views for IE extension - must match values in Registry

#define MSIVIEW_BEGIN				1
#define MSIVIEW_SUMMARY				1
#define MSIVIEW_FILE_VERSIONS		2
#define MSIVIEW_CONNECTIVITY		3
#define MSIVIEW_CACHE				4
#define MSIVIEW_OBJECT_LIST		5
#define MSIVIEW_CONTENT				6
#define MSIVIEW_PERSONAL_CERTIFICATES	7
#define MSIVIEW_OTHER_PEOPLE_CERTIFICATES	8
#define MSIVIEW_PUBLISHERS			9
#define MSIVIEW_SECURITY			10
#define MSIVIEW_END					10

#define CONNECTIVITY_BASIC_LINES	51

#define ITEM_LEN			128
#define VALUE_LEN			MAX_PATH
#define VERSION_LEN		20
#define DATE_LEN			64
#define SIZE_LEN			16
#define STATUS_LEN		40

typedef struct
{
	UINT		uiView;
	TCHAR		szItem[ITEM_LEN];
	TCHAR		szValue[VALUE_LEN];
} LIST_ITEM;

typedef struct
{
	UINT		uiView;
	TCHAR		szItem[ITEM_LEN];
	TCHAR		szValue[VALUE_LEN];
	BOOL		bBold;
} EDIT_ITEM;

typedef struct
{
	UINT		uiView;
	TCHAR		szFile[_MAX_FNAME];
	TCHAR		szVersion[VERSION_LEN];
	TCHAR		szSize[SIZE_LEN];
	TCHAR		szDate[DATE_LEN];
	TCHAR		szPath[VALUE_LEN];
	TCHAR		szCompany[VALUE_LEN];
	DWORD		dwSize;
	DATE		date;
} LIST_FILE_VERSION;

typedef struct
{
	UINT		uiView;
	TCHAR		szProgramFile[_MAX_FNAME];
	TCHAR		szStatus[STATUS_LEN];
	TCHAR		szCodeBase[MAX_PATH];
} LIST_OBJECT;

typedef struct
{
	UINT		uiView;
	TCHAR		szIssuedTo[_MAX_FNAME];
	TCHAR		szIssuedBy[_MAX_FNAME];
	TCHAR		szValidity[_MAX_FNAME];
	TCHAR		szSignatureAlgorithm[_MAX_FNAME];
} LIST_CERT;

typedef struct
{
	UINT		uiView;
	TCHAR		szName[_MAX_FNAME];
} LIST_NAME;

/////////////////////////////////////////////////////////////////////////////
// CMsieCtrl : See MsieCtl.cpp for implementation.

class CMsieCtrl : public COleControl
{
	DECLARE_DYNCREATE(CMsieCtrl)

// Constructor
public:
	CMsieCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMsieCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void Serialize(CArchive& ar);
	protected:
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CMsieCtrl();

	DECLARE_OLECREATE_EX(CMsieCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CMsieCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CMsieCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CMsieCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CMsieCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void OnBasicBtnClicked();
	void OnAdvancedBtnClicked();

// Dispatch maps
	//{{AFX_DISPATCH(CMsieCtrl)
	long m_MSInfoView;
	afx_msg void OnMSInfoViewChanged();
	afx_msg void MSInfoRefresh(BOOL fForSave, long FAR* pCancel);
	afx_msg BOOL MSInfoLoadFile(LPCTSTR szFileName);
	afx_msg void MSInfoSelectAll();
	afx_msg void MSInfoCopy();
	afx_msg void MSInfoUpdateView();
	afx_msg long MSInfoGetData(long dwMSInfoView, long FAR* pBuffer, long dwLength);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Interface maps
	
	DECLARE_INTERFACE_MAP()

	// IWbemProviderInit
	BEGIN_INTERFACE_PART(WbemProviderInit, IWbemProviderInit)
		STDMETHOD(Initialize)(
			/* [in] */ LPWSTR pszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR pszNamespace,
			/* [in] */ LPWSTR pszLocale,
			/* [in] */ IWbemServices *pNamespace,
			/* [in] */ IWbemContext *pCtx,
			/* [in] */ IWbemProviderInitSink *pInitSink);
		STDMETHOD(GetByPath)(BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext *pCtx) {return WBEM_E_NOT_SUPPORTED;};
	END_INTERFACE_PART(WbemProviderInit)

	//IWbemServices  
	BEGIN_INTERFACE_PART(WbemServices, IWbemServices)
		STDMETHOD(OpenNamespace)( 
         /* [in] */ const BSTR Namespace,
         /* [in] */ long lFlags,
         /* [in] */ IWbemContext __RPC_FAR *pCtx,
         /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
         /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
		STDMETHOD(CancelAsyncCall)( 
			/* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(QueryObjectSink)( 
			/* [in] */ long lFlags,
			/* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(GetObject)( 
			/* [in] */ const BSTR ObjectPath,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
			/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(GetObjectAsync)( 
			/* [in] */ const BSTR ObjectPath,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(PutClass)( 
			/* [in] */ IWbemClassObject __RPC_FAR *pObject,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(PutClassAsync)( 
			/* [in] */ IWbemClassObject __RPC_FAR *pObject,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(DeleteClass)( 
			/* [in] */ const BSTR Class,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(DeleteClassAsync)( 
			/* [in] */ const BSTR Class,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(CreateClassEnum)( 
			/* [in] */ const BSTR Superclass,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(CreateClassEnumAsync)( 
			/* [in] */ const BSTR Superclass,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(PutInstance)( 
			/* [in] */ IWbemClassObject __RPC_FAR *pInst,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(PutInstanceAsync)( 
			/* [in] */ IWbemClassObject __RPC_FAR *pInst,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(DeleteInstance)( 
			/* [in] */ const BSTR ObjectPath,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(DeleteInstanceAsync)( 
			/* [in] */ const BSTR ObjectPath,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(CreateInstanceEnum)( 
			/* [in] */ const BSTR Class,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(CreateInstanceEnumAsync)( 
			/* [in] */ const BSTR Class,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

		STDMETHOD(ExecQuery)( 
			/* [in] */ const BSTR QueryLanguage,
			/* [in] */ const BSTR Query,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(ExecQueryAsync)( 
			/* [in] */ const BSTR QueryLanguage,
			/* [in] */ const BSTR Query,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(ExecNotificationQuery)( 
			/* [in] */ const BSTR QueryLanguage,
			/* [in] */ const BSTR Query,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(ExecNotificationQueryAsync)( 
			/* [in] */ const BSTR QueryLanguage,
			/* [in] */ const BSTR Query,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
			/* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

		STDMETHOD(ExecMethod)(const BSTR, const BSTR, long, IWbemContext*,
			IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

		STDMETHOD(ExecMethodAsync)(const BSTR, const BSTR, long, 
			IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}
	END_INTERFACE_PART(WbemServices)

// Event maps
	//{{AFX_EVENT(CMsieCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CMsieCtrl)
	dispidMSInfoView = 1L,
	dispidMSInfoRefresh = 2L,
	dispidMSInfoLoadFile = 3L,
	dispidMSInfoSelectAll = 4L,
	dispidMSInfoCopy = 5L,
	dispidMSInfoUpdateView = 6L,
	dispidMSInfoGetData = 7L,
	//}}AFX_DISP_ID
	};

private:
	void DrawLine();
	BOOL FormatColumns();
	BOOL AddColumn(int idsLabel, int nItem, int nSubItem = -1, int size = 0,
		int nMask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM,
		int nFmt = LVCFMT_LEFT);
	BOOL AddItem(int nItem,int nSubItem,LPCTSTR strItem,int nImageIndex = -1);
	void RefigureColumns(CRect& rect);
	void RefreshListControl(BOOL bRedraw);
	void RefreshEditControl(BOOL bRedraw);

	void DeleteArrayObject(void *ptrArray);

	void RefreshArray(int iView, int &iListItem, CPtrArray &ptrarrayNew);
	CString GetStringFromIDS(int ids);
	CString GetStringFromVariant(COleVariant &var, int idsFormat = 0);
	void AddToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszItem, LPCTSTR pszValue);
	void AddToArray(CPtrArray &ptrarray, int itemNum, int idsItem, LPCTSTR pszValue);
	void AddBlankLineToArray(CPtrArray &ptrarray, int itemNum);
	void AddEditBlankLineToArray(CPtrArray &ptrarray, int itemNum);
	void AddFileVersionToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszFile, LPCTSTR pszVersion, LPCTSTR pszSize, LPCTSTR pszDate, LPCTSTR pszPath, LPCTSTR pszCompany, DWORD dwSize, DATE date);
	void AddEditToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszItem, LPCTSTR pszValue, BOOL bBold = FALSE);
	void AddEditToArray(CPtrArray &ptrarray, int itemNum, int idsItem, LPCTSTR pszValue, BOOL bBold = FALSE);
	void AddObjectToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszProgramFile, LPCTSTR pszStatus, LPCTSTR pszCodeBase);
	void AddCertificateToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszIssuedTo, LPCTSTR pszIssuedBy, LPCTSTR pszValidity, LPCTSTR pszSignatureAlgorithm);
	void AddNameToArray(CPtrArray &ptrarray, int itemNum, LPCTSTR pszName);

	//====================================================================
	// MSInfo Specific...
	//
	// Add members to the control class to keep track of the currently
	// displayed data. In this example, we use a flag to indicate if the
	// data is current or loaded from a file.
	//====================================================================

	CBrush *m_pCtlBkBrush;
	bool m_bCurrent;
	CListCtrl m_list;
	CImageList m_imageList;
	CPtrArray m_ptrarray;
	CStatic m_static;
	CButton m_btnBasic, m_btnAdvanced;
	CRichEditCtrl m_edit;
	CFont m_fontStatic, m_fontBtn;
	UINT m_uiView;

	// The following member variables are used to keep track of the
	// column sizes on the list control.

	int m_cColumns;
	int m_aiRequestedWidths[20];
	int m_aiColumnWidths[20];
	int m_aiMinWidths[20];
	int m_aiMaxWidths[20];

	// WMI 

	bool GetIEType(const BSTR classStr, IEDataType &enType);
	void ConvertDateToWbemString(COleVariant &var);
	void SetIEProperties(IEDataType enType, void *pIEData, IWbemClassObject *pInstance);

	IWbemServices *m_pNamespace;
};

#endif // !defined(AFX_MSIECTL_H__25959BFC_E700_11D2_A7AF_00C04F806200__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\msieppg.h ===
#if !defined(AFX_MSIEPPG_H__25959BFE_E700_11D2_A7AF_00C04F806200__INCLUDED_)
#define AFX_MSIEPPG_H__25959BFE_E700_11D2_A7AF_00C04F806200__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// MsiePpg.h : Declaration of the CMsiePropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMsiePropPage : See MsiePpg.cpp.cpp for implementation.

class CMsiePropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CMsiePropPage)
	DECLARE_OLECREATE_EX(CMsiePropPage)

// Constructor
public:
	CMsiePropPage();

// Dialog Data
	//{{AFX_DATA(CMsiePropPage)
	enum { IDD = IDD_PROPPAGE_MSIE };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CMsiePropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSIEPPG_H__25959BFE_E700_11D2_A7AF_00C04F806200__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\msiedata.h ===
// Msiedata.h : Enums, structs and externs exposed by MSIE51.ocx

#ifndef _MSIEDATA_H_
#define _MSIEDATA_H_

enum IEDataType
{
	SummaryType,
	FileVersionType,
	LanSettingsType,
	ConnSummaryType,
	ConnSettingsType,
	CacheType,
	ObjectType,
	ContentType,
	CertificateType,
	PublisherType,
	SecurityType
};

typedef struct
{
	COleVariant Name;
	COleVariant Version;
	COleVariant Build;
	COleVariant ProductID;
	COleVariant Path;
	COleVariant LastInstallDate;
	COleVariant Language;
	COleVariant ActivePrinter;
	COleVariant CipherStrength;
	COleVariant ContentAdvisor;
	COleVariant IEAKInstall;
} IE_SUMMARY;

typedef struct
{
	COleVariant File;
	COleVariant Version;
	COleVariant Size;
	COleVariant Date;
	COleVariant Path;
	COleVariant Company;
} IE_FILE_VERSION;

typedef struct
{
	COleVariant ConnectionPreference;
	COleVariant EnableHttp11;
	COleVariant ProxyHttp11;
} IE_CONN_SUMMARY;

typedef struct
{
	COleVariant AutoConfigProxy;
	COleVariant AutoProxyDetectMode;
	COleVariant AutoConfigURL;
	COleVariant Proxy;
	COleVariant ProxyServer;
	COleVariant ProxyOverride;
} IE_LAN_SETTINGS;

typedef struct
{
	COleVariant Name;
	COleVariant Default;
	COleVariant AutoDial;
	COleVariant AutoProxyDetectMode;
	COleVariant AutoConfigURL;
	COleVariant Proxy;
	COleVariant ProxyServer;
	COleVariant ProxyOverride;
	COleVariant AllowInternetPrograms;
	COleVariant RedialAttempts;
	COleVariant RedialWait;
	COleVariant DisconnectIdleTime;
	COleVariant AutoDisconnect;
	COleVariant Modem;
	COleVariant DialUpServer;
	COleVariant NetworkLogon;
	COleVariant SoftwareCompression;
	COleVariant EncryptedPassword;
	COleVariant DataEncryption;
	COleVariant RecordLogFile;
	COleVariant NetworkProtocols;
	COleVariant ServerAssignedIPAddress;
	COleVariant IPAddress;
	COleVariant ServerAssignedNameServer;
	COleVariant PrimaryDNS;
	COleVariant SecondaryDNS;
	COleVariant PrimaryWINS;
	COleVariant SecondaryWINS;
	COleVariant IPHeaderCompression;
	COleVariant DefaultGateway;
	COleVariant ScriptFileName;
} IE_CONN_SETTINGS;

typedef struct
{
	COleVariant PageRefreshType;
	COleVariant TempInternetFilesFolder;
	COleVariant TotalDiskSpace;
	COleVariant AvailableDiskSpace;
	COleVariant MaxCacheSize;
	COleVariant AvailableCacheSize;
} IE_CACHE;

typedef struct
{
	COleVariant ProgramFile;
	COleVariant Status;
	COleVariant CodeBase;
} IE_OBJECT;

typedef struct
{
	COleVariant Advisor;
} IE_CONTENT;

typedef struct
{
	COleVariant Type;
	COleVariant IssuedTo;
	COleVariant IssuedBy;
	COleVariant Validity;
	COleVariant SignatureAlgorithm;
} IE_CERTIFICATE;

typedef struct
{
	COleVariant Name;
} IE_PUBLISHER;

typedef struct
{
	COleVariant Zone;
	COleVariant Level;
} IE_SECURITY;

#endif _MSIEDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Msie.rc
//
#define IDS_MSIE                        1
#define IDB_MSIE                        1
#define IDS_MSIE_PPG                    2
#define IDS_TRUE                        3
#define IDS_FALSE                       4
#define IDS_NOT_AVAILABLE               5
#define IDS_FILE_MISSING                6
#define IDS_DIAL_NO_NET                 7
#define IDS_ALWAYS_DIAL                 8
#define IDS_NEVER_DIAL                  9
#define IDS_BASIC_INFO                  10
#define IDS_ADVANCED_INFO               11
#define IDS_INF_FILE_MISSING            12
#define IDS_DEFAULT                     13
#define IDS_PROTOCOL_PPP                14
#define IDS_PROTOCOL_SLIP               15
#define IDS_PROTOCOL_RAS                16
#define IDS_TCP_IP                      17
#define IDS_IPX_SPX                     18
#define IDS_NET_BEUI                    19
#define IDS_YES                         20
#define IDS_NO                          21
#define IDS_ALWAYS                      22
#define IDS_ONCE_PER_SESSION            23
#define IDS_AUTOMATIC                   24
#define IDS_NEVER                       25
#define IDS_LOW                         26
#define IDS_MEDIUM_LOW                  27
#define IDS_MEDIUM                      28
#define IDS_HIGH                        29
#define IDS_CUSTOM                      30
#define IDS_INSTALLED                   31
#define IDS_SHARED                      32
#define IDS_DAMAGED                     33
#define IDS_UNPLUGGED                   34
#define IDS_IE_REPAIR_TOOL              35
#define IDS_RUNS_IE_REPAIR_TOOL         36
#define IDS_REPAIR_LOG                  37
#define IDS_VALIDITY_FORMAT             38
#define IDS_ENABLED                     39
#define IDS_DISABLED                    40
#define IDS_NO_CONNECTIONS              41
#define IDS_MSIE_PPG_CAPTION            500
#define IDD_PROPPAGE_MSIE               500
#define IDC_LISTCTRL                    501
#define IDC_EDITCTRL                    502
#define IDC_BTN_BASIC                   503
#define IDC_BTN_ADVANCED                504
#define IDS_MSITEMPLATEBASE             1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        506
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         505
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\regkeys.h ===
#define REG_IE_KEY				_T("SOFTWARE\\Microsoft\\Internet Explorer")
#define REG_VERSION				_T("Version")
#define REG_BUILD					_T("Build")
#define REG_REGISTRATION		_T("Registration")
#define REG_PRODUCT_ID			_T("ProductID")
#define REG_IEXPLORE_EXE_KEY	_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE")
#define REG_PATH					_T("Path")
#define REG_CUSTOMIZED_VERSION	_T("CustomizedVersion")
#define REG_IE_SETTINGS_KEY	_T("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define REG_AUTO_CONFIG_PROXY	_T("AutoConfigProxy")
#define REG_ENABLE_HTTP_1_1	_T("EnableHttp1_1")
#define REG_PROXY_HTTP_1_1		_T("ProxyHttp1.1")
#define REG_ENABLE_AUTODIAL	_T("EnableAutodial")
#define REG_NO_NET_AUTODIAL	_T("NoNetAutodial")
#define REG_MSINFO_KEY			_T("Software\\Microsoft\\Shared Tools\\MSInfo")
#define REG_REMOTE_ACCESS_PROFILE	_T("RemoteAccess\\Profile")
#define REG_REMOTE_ACCESS		_T("RemoteAccess")
#define REG_INTERNET_PROFILE	_T("InternetProfile")
#define REG_COVER_EXCLUDE		_T("CoverExclude")
#define REG_REDIAL_ATTEMPTS	_T("RedialAttempts")
#define REG_REDIAL_WAIT			_T("RedialWait")
#define REG_DISCONNECT_IDLE_TIME	_T("DisconnectIdleTime")
#define REG_ENABLE_AUTO_DISCONNECT	_T("EnableAutodisconnect")
#define REG_PPP_KEY				_T("SYSTEM\\CurrentControlSet\\Services\\RasMan\\PPP")
#define REG_LOGGING				_T("Logging")
#define REG_ZONES					_T("Zones")
#define REG_FLAGS					_T("Flags")
#define REG_DISPLAY_NAME		_T("DisplayName")
#define REG_CURRENT_LEVEL		_T("CurrentLevel")
#define REG_CATEGORIES			_T("Categories")
#define REG_INTERNET_EXPLORER_6	_T("InternetExplorer6")
#define REG_FILE_VERSIONS		_T("FileVersions")
#define REG_CONNECTIVITY		_T("Connectivity")
#define REG_CACHE					_T("Cache")
#define REG_OBJECT_LIST			_T("ObjectList")
#define REG_CONTENT				_T("Content")
#define REG_PERSONAL_CERTIFICATES	_T("PersonalCertificates")
#define REG_OTHER_PEOPLE_CERTIFICATES	_T("OtherPeopleCertificates")
#define REG_PUBLISHERS			_T("Publishers")
#define REG_SECURITY				_T("Security")
#define REG_CLSID					_T("CLSID")
#define REG_MSINFO_VIEW			_T("MSInfoView")
#define REG_RANK					_T("Rank")
#define REG_TOOLS					_T("Tools")
#define REG_IE_REPAIR			_T("IERepair")
#define REG_COMMAND				_T("command")
#define REG_DESCRIPTION			_T("description")
#define REG_IE_SETUP_KEY		_T("Software\\Microsoft\\IE Setup\\SETUP")
#define REG_TEMPLATES			_T("Templates")
#define REG_IEINFO5				_T("ieinfo5")
#define REG_WBEM_KEY				_T("Software\\Microsoft\\WBEM")
#define REG_MOF_SELF_INSTALL	_T("MOF Self-Install Directory")
#define REG_PUBLISHERS_KEY    _T("Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust\\Trust Providers\\Software Publishing\\Trust Database\\0")
#define REG_SYNC_MODE_5			_T("SyncMode5")
#define REG_SHELL_FOLDERS_KEY	_T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define REG_CACHE_LIMIT			_T("CacheLimit")
#define REG_MICROSOFT_KEY		_T("Software\\Microsoft")
#define REG_SHARED_TOOLS		_T("Shared Tools")
#define REG_CURRENT_VERSION_KEY	_T("Software\\Microsoft\\Windows\\CurrentVersion")
#define REG_COMMON_FILES_DIR	_T("CommonFilesDir")
#define REG_MSINFO				_T("MSInfo")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\msiedata.cpp ===
#include "stdafx.h"
#include "regkeys.h"
#include "filefind.h"
#include "resdefs.h"
#include <afxtempl.h>
#include <shlobj.h>
#include <comdef.h>
#include <setupapi.h>
#include <wininet.h>
#include <winineti.h>
#include <cleanoc.h>
#include <ras.h>
#include <raserror.h>
#include <wincrypt.h>

#define SECURITY_WIN32
#include <schnlsp.h> //for UNISP_NAME_A
#include <sspi.h> //for SCHANNEL.dll api -- to obtain encryption key size

#include "msie.h"
#include "msiedata.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//*** DEFINES ***

#define CONSTANT_MEGABYTE		(1024*1024)
#define CONTROLNAME_MAXSIZE	200

#define CONTENT_IE5				"Content.IE5"

#define INF_FILE					"iefiles5.inf"
#define INF_FILES_SECTION		_T("Files")

#define SETUP_LOG					"Active Setup Log.txt"
#define IEXPLORE_EXE				"iexplore.exe"

#define MY_STORE					"MY"
#define ADDRESS_BOOK_STORE		"AddressBook"
#define CA_STORE					"CA"


//*** ENUMS ***

enum BoolStringType
{
	YES_NO,
	TRUE_FALSE,
	ENABLED_DISABLED
};

enum ExportLibType
{
	WININET,
	MSRATING,
	OCCACHE,
	RASAPI32,
	CRYPT32
};


//*** STRUCTS ***

struct TRANSLATION	// for retrieving Language
{
	WORD langID;   // language ID
	WORD charset; // code page
} translation;


// WININET Function Pointers

BOOL (WINAPI* pfnInternetQueryOption)(HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufferLength);
BOOL (WINAPI* pfnGetDiskInfo)(LPTSTR pszPath, PDWORD pdwClusterSize, PDWORDLONG pdlAvail, PDWORDLONG pdlTotal);

// MSRATING Function Pointers

HRESULT (WINAPI* pfnRatingEnabledQuery)();

// OCCACHE Function Pointers

LONG (WINAPI *pfnFindFirstControl)(HANDLE& hFindHandle, HANDLE& hControlHandle, LPCTSTR lpszCachePath = NULL);
LONG (WINAPI *pfnFindNextControl)(HANDLE& hFindHandle, HANDLE& hControlHandle);
BOOL (WINAPI *pfnGetControlInfo)(HANDLE hControlHandle, UINT nFlag, LPDWORD lpdwData, LPSTR lpszBuf, int nBufLen);
void (WINAPI *pfnFindControlClose)(HANDLE hFindHandle);
void (WINAPI *pfnReleaseControlHandle)(HANDLE hControlHandle);

// RASAPI32 Function Pointers

DWORD (WINAPI* pfnRasGetEntryProperties)(LPCTSTR, LPCTSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD);
DWORD (WINAPI* pfnRasEnumEntries)(LPCTSTR, LPCTSTR, LPRASENTRYNAMEW, LPDWORD, LPDWORD);

// CRYPT32 Function Pointers

HCERTSTORE (WINAPI* pfnCertOpenSystemStore)(HCRYPTPROV, LPCSTR);
BOOL (WINAPI* pfnCertCloseStore)(HCERTSTORE, DWORD);
PCCERT_CONTEXT (WINAPI* pfnCertEnumCertificatesInStore)(HCERTSTORE, PCCERT_CONTEXT);
DWORD (WINAPI* pfnCertGetNameString)(PCCERT_CONTEXT, DWORD, DWORD, void *, LPTSTR, DWORD);
PCCRYPT_OID_INFO (WINAPI* pfnCryptFindOIDInfo)(DWORD, void *, DWORD);
BOOL (WINAPI* pfnCertGetCertificateContextProperty)(PCCERT_CONTEXT, DWORD, void *, DWORD *);
BOOL (WINAPI* pfnCryptDecodeObject)(DWORD, LPCSTR, const BYTE *, DWORD, DWORD, void *, DWORD *);

HINSTANCE GetExports(int enExportLib)
{
	HINSTANCE hInst;

	switch (enExportLib)
	{
	case WININET:
		hInst = LoadLibraryA("WININET.DLL");
		if (hInst == NULL)
			goto error;

		pfnInternetQueryOption = (BOOL(WINAPI *)(HINTERNET, DWORD, LPVOID, LPDWORD))GetProcAddress(hInst, "InternetQueryOptionW");
		pfnGetDiskInfo = (BOOL(WINAPI *)(LPTSTR, PDWORD, PDWORDLONG, PDWORDLONG))GetProcAddress(hInst, (LPSTR)102);

		if ((pfnInternetQueryOption == NULL) || (pfnGetDiskInfo == NULL))
			goto error;
		break;

	case MSRATING:
		hInst = LoadLibraryW(_T("MSRATING.DLL"));
		if (hInst == NULL)
			goto error;

		pfnRatingEnabledQuery = (HRESULT(WINAPI *)(VOID))GetProcAddress(hInst, "RatingEnabledQuery");

		if (pfnRatingEnabledQuery == NULL)
			goto error;
		break;

	case OCCACHE:
		hInst = LoadLibraryW(_T("OCCACHE.DLL"));
		if (hInst == NULL)
			goto error;

		pfnFindFirstControl = (LONG(WINAPI *)(HANDLE&, HANDLE&, LPCTSTR))GetProcAddress(hInst, "FindFirstControl");
		pfnFindNextControl = (LONG(WINAPI *)(HANDLE&, HANDLE&))GetProcAddress(hInst, "FindNextControl");
		pfnGetControlInfo = (BOOL(WINAPI *)(HANDLE, UINT, LPDWORD, LPSTR, int))GetProcAddress(hInst, "GetControlInfo");
		pfnFindControlClose = (void(WINAPI *)(HANDLE))GetProcAddress(hInst, "FindControlClose");
		pfnReleaseControlHandle = (void(WINAPI *)(HANDLE))GetProcAddress(hInst, "ReleaseControlHandle");

		if ((pfnFindFirstControl == NULL) || (pfnFindNextControl == NULL) || (pfnGetControlInfo == NULL)
				|| (pfnFindControlClose == NULL) || (pfnReleaseControlHandle == NULL))
			goto error;
		break;

	case RASAPI32:
		hInst = LoadLibraryA("RASAPI32.DLL");
		if (hInst == NULL)
			goto error;

		pfnRasGetEntryProperties = (DWORD(WINAPI *)(LPCTSTR, LPCTSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD))GetProcAddress(hInst, "RasGetEntryPropertiesW");
		pfnRasEnumEntries = (DWORD(WINAPI *)(LPCTSTR, LPCTSTR, LPRASENTRYNAMEW, LPDWORD, LPDWORD))GetProcAddress(hInst, "RasEnumEntriesW");

		if ((pfnRasGetEntryProperties == NULL) || (pfnRasEnumEntries == NULL))
			goto error;
		break;
	
	case CRYPT32:
		hInst = LoadLibraryW(_T("CRYPT32.DLL"));
		if (hInst == NULL)
			goto error;

		pfnCertOpenSystemStore = (HCERTSTORE(WINAPI *)(HCRYPTPROV, LPCSTR))GetProcAddress(hInst, "CertOpenSystemStoreW");
		pfnCertCloseStore = (BOOL(WINAPI *)(HCERTSTORE, DWORD))GetProcAddress(hInst, "CertCloseStore");
		pfnCertEnumCertificatesInStore = (PCCERT_CONTEXT(WINAPI *)(HCERTSTORE, PCCERT_CONTEXT))GetProcAddress(hInst, "CertEnumCertificatesInStore");
		pfnCertGetNameString = (DWORD(WINAPI *)(PCCERT_CONTEXT, DWORD, DWORD, void *, LPTSTR, DWORD))GetProcAddress(hInst, "CertGetNameStringW");
		pfnCryptFindOIDInfo = (PCCRYPT_OID_INFO(WINAPI *)(DWORD, void *, DWORD))GetProcAddress(hInst, "CryptFindOIDInfo");
		pfnCertGetCertificateContextProperty = (BOOL(WINAPI *)(PCCERT_CONTEXT, DWORD, void *, DWORD *))GetProcAddress(hInst, "CertGetCertificateContextProperty");
		pfnCryptDecodeObject = (BOOL(WINAPI *)(DWORD, LPCSTR, const BYTE *, DWORD, DWORD, void *, DWORD *))GetProcAddress(hInst, "CryptDecodeObject");

		if ((pfnCertOpenSystemStore == NULL) ||
				(pfnCertCloseStore == NULL) ||
				(pfnCertEnumCertificatesInStore == NULL) ||
				(pfnCertGetNameString == NULL) ||
				(pfnCryptFindOIDInfo == NULL) ||
				(pfnCertGetCertificateContextProperty == NULL) ||
				(pfnCryptDecodeObject == NULL))
			goto error;
	}
	return hInst;

error:
	if (hInst)
		FreeLibrary(hInst);

	return NULL;
}

//-----------------------------------------------------------------------------
// GetBooleanString - Converts a boolean to a string, returns as a CString.
//-----------------------------------------------------------------------------

CString CMsieApp::GetBooleanString(BOOL bValue, int nType)
{
	CString strTemp;
	int idsTemp;

	switch (nType)
	{
	case TRUE_FALSE:
		idsTemp = bValue ? IDS_TRUE : IDS_FALSE;
		break;
	case ENABLED_DISABLED:
		idsTemp = bValue ? IDS_ENABLED : IDS_DISABLED;
		break;
	case YES_NO:
	default:
		idsTemp = bValue ? IDS_YES : IDS_NO;
		break;
	}

	strTemp.LoadString(idsTemp);
	return strTemp;
}

//-----------------------------------------------------------------------------
// ConvertIPAddressToString - Converts an IP address, returns as a CString.
//-----------------------------------------------------------------------------

CString CMsieApp::ConvertIPAddressToString(RASIPADDR ipaddr)
{
	CString strTemp;

	strTemp.Format(_T("%d.%d.%d.%d"), ipaddr.a, ipaddr.b, ipaddr.c, ipaddr.d);

	return strTemp;
}

//-----------------------------------------------------------------------------
// GetRegValue - Gets a Registry value, returns as variant.
//-----------------------------------------------------------------------------

void CMsieApp::GetRegValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszName, COleVariant &vtData)
{
	CoImpersonateClient();
	HKEY hOpenKey;
	BYTE byData[MAX_PATH];
	DWORD dwType, cbData;
	long lResult;

	if (ERROR_SUCCESS == RegOpenKeyEx(hKey, pszSubKey, 0, KEY_QUERY_VALUE, &hOpenKey))
	{
		cbData = sizeof(byData);
		dwType = REG_DWORD;
		lResult = RegQueryValueEx(hOpenKey, pszName, NULL, &dwType, byData, &cbData);
		if (lResult == ERROR_SUCCESS)
		{
			if ((dwType == REG_BINARY) || (dwType == REG_DWORD))
				vtData = (long)*byData;
			else
				vtData = (TCHAR*) byData;
		}
		RegCloseKey(hOpenKey);
	}
}

//-----------------------------------------------------------------------------
// GetRegValue - Gets a Registry value, returns as long.
//-----------------------------------------------------------------------------

long CMsieApp::GetRegValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszName, DWORD &dwData)
{
	HKEY hOpenKey;
	DWORD cbData;
	long lResult;

	lResult = RegOpenKeyEx(hKey, pszSubKey, 0, KEY_QUERY_VALUE, &hOpenKey);
	if (lResult == ERROR_SUCCESS)
	{
		cbData = sizeof(dwData);
		lResult = RegQueryValueEx(hOpenKey, pszName, NULL, NULL, (LPBYTE)&dwData, &cbData);

		RegCloseKey(hOpenKey);
	}
	return lResult;
}

//-----------------------------------------------------------------------------
// GetRegValue - Gets a Registry value, returns as string.
//-----------------------------------------------------------------------------

long CMsieApp::GetRegValue(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszName, CString &strData)
{
	HKEY hOpenKey;
	DWORD cbData;
	long lResult;

	lResult = RegOpenKeyEx(hKey, pszSubKey, 0, KEY_QUERY_VALUE, &hOpenKey);
	if (lResult == ERROR_SUCCESS)
	{
		cbData = MAX_PATH;
		lResult = RegQueryValueEx(hOpenKey, pszName, NULL, NULL, (LPBYTE)strData.GetBuffer(MAX_PATH), &cbData);
		strData.ReleaseBuffer();

		RegCloseKey(hOpenKey);
	}
	return lResult;
}

//-----------------------------------------------------------------------------
// GetLongPathName - Returns long path name of passed in short path name.
//-----------------------------------------------------------------------------

CString CMsieApp::GetLongPathName(LPCTSTR pszShortPath)
{
   LPSHELLFOLDER psfDesktop = NULL;
   ULONG chEaten = 0;
   LPITEMIDLIST pidlShellItem = NULL;
	CString strLongPath = pszShortPath;		// initializing return str in case of failure
	WCHAR wstrShortPath[MAX_PATH];

   // Get the Desktop's shell folder interface

   HRESULT hr = SHGetDesktopFolder(&psfDesktop);

#ifdef _UNICODE
	wcscpy(wstrShortPath, pszShortPath);
#else
	MultiByteToWideChar(CP_ACP, 0, pszShortPath, -1, wstrShortPath, MAX_PATH);
#endif

   // Request an ID list (relative to the desktop) for the short pathname

   hr = psfDesktop->ParseDisplayName(NULL, NULL, wstrShortPath, &chEaten, &pidlShellItem, NULL);
   psfDesktop->Release();  // Release the desktop's IShellFolder   
   if (SUCCEEDED(hr))
	{
      // We did get an ID list, convert it to a long pathname

      SHGetPathFromIDList(pidlShellItem, strLongPath.GetBuffer(MAX_PATH));
		strLongPath.ReleaseBuffer();

      // Free the ID list allocated by ParseDisplayName

      LPMALLOC pMalloc = NULL;
      SHGetMalloc(&pMalloc);
      pMalloc->Free(pidlShellItem);
      pMalloc->Release();
	}
	return strLongPath;
}

//-----------------------------------------------------------------------------
// GetDirSize - Returns size of a directory, including all files in subdirs.
//-----------------------------------------------------------------------------

DWORD CMsieApp::GetDirSize(LPCTSTR pszDir)
{
	CFindFile finder;
	CString strDir(pszDir);
	DWORD dwSize = 0;
	BOOL bWorking;

	if (strDir[strDir.GetLength() - 1] != _T('\\'))
		strDir += '\\';
	strDir += "*.*";
	bWorking = finder.FindFile(strDir);
	while (bWorking)
	{
		bWorking = finder.FindNextFile();
		if (!finder.IsDots())
		{
			if (finder.IsDirectory())
			{
				// recursively add subdir size

				dwSize += GetDirSize(finder.GetFilePath());
			}
			else
			{
				//TRACE(finder.GetFileName() + "\n");
				dwSize += finder.GetLength();
			}
		}
	}
	return dwSize;
}

//-----------------------------------------------------------------------------
// GetFileVersion - Retrieves FileVersion of passed in filename.
//-----------------------------------------------------------------------------

CString CMsieApp::GetFileVersion(LPCTSTR pszFileName)
{
	CString strVersion;
	HANDLE hMem;
	LPVOID lpvMem;
	VS_FIXEDFILEINFO *pVerInfo;
	UINT cchVerInfo;
	DWORD dwVerInfoSize, dwTemp;

	dwVerInfoSize = GetFileVersionInfoSize((LPTSTR)pszFileName, &dwTemp); 
	if (dwVerInfoSize)
	{ 
		hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize); 
		lpvMem = GlobalLock(hMem); 
		if (GetFileVersionInfo((LPTSTR)pszFileName, dwTemp, dwVerInfoSize, lpvMem))
		{
			if (VerQueryValue(lpvMem, _T("\\"), (LPVOID*)&pVerInfo, &cchVerInfo))
			{
				strVersion.Format(_T("%u.%u.%u.%u"), HIWORD(pVerInfo->dwFileVersionMS), LOWORD(pVerInfo->dwFileVersionMS),
										HIWORD(pVerInfo->dwFileVersionLS), LOWORD(pVerInfo->dwFileVersionLS));
			}
		}
		GlobalUnlock(hMem);
		GlobalFree(hMem);
	}

	if (strVersion.IsEmpty())
		strVersion.LoadString(IDS_NOT_AVAILABLE);

	return strVersion;
}

//-----------------------------------------------------------------------------
// GetFileCompany - Retrieves CompanyName declared in passed in file.
//-----------------------------------------------------------------------------

CString CMsieApp::GetFileCompany(LPCTSTR pszFileName)
{
	CString strCompany, strSubBlock, strLangID, strCharset;
	HANDLE hMem;
	LPVOID lpvMem, pBuffer;
	VS_FIXEDFILEINFO *pVerInfo;
	UINT cchVerInfo, cchBuffer;
	DWORD dwVerInfoSize, dwTemp;

	dwVerInfoSize = GetFileVersionInfoSize((LPTSTR)pszFileName, &dwTemp); 
	if (dwVerInfoSize)
	{ 
		hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize); 
		lpvMem = GlobalLock(hMem); 
		if (GetFileVersionInfo((LPTSTR)pszFileName, dwTemp, dwVerInfoSize, lpvMem))
		{
			if (VerQueryValue(lpvMem, _T("\\VarFileInfo\\Translation"), (LPVOID*)&pVerInfo, &cchVerInfo))
			{
				translation = *(TRANSLATION*)pVerInfo;

				strSubBlock.Format(_T("\\StringFileInfo\\%04X%04X\\CompanyName"), translation.langID, translation.charset);
				VerQueryValue(lpvMem, (LPTSTR)(LPCTSTR)strSubBlock, &pBuffer, &cchBuffer);
				strCompany = (LPCTSTR)pBuffer;
			}
		}
		GlobalUnlock(hMem);
		GlobalFree(hMem);
	}

	if (strCompany.IsEmpty())
		strCompany.LoadString(IDS_NOT_AVAILABLE);

	return strCompany;
}

//-----------------------------------------------------------------------------
// GetCipherStrength - Returns the maximum cipher strength (snagged from IE
//		About Box code (aboutinf.cpp).
//-----------------------------------------------------------------------------

DWORD CMsieApp::GetCipherStrength()
{
    PSecurityFunctionTable (WINAPI *pfnInitSecurityInterface)();
    PSecurityFunctionTable pSecFuncTable;
    HINSTANCE hSecurity;
    DWORD dwKeySize = 0;

	 // Can't go directly to schannel on NT5.  (Note that g_bRunningOnNT5OrHigher
    // may not be initialized when fUseSChannel is initialized!)
    //
    static BOOL fUseSChannel = TRUE;
    if (fUseSChannel && !m_bRunningOnNT5OrHigher)
    {
        //
        // This is better for performance. Rather than call through
        // SSPI, we go right to the DLL doing the work.
        //
        hSecurity = LoadLibrary(_T("SCHANNEL.DLL"));
    }
    else
    {
        //
        // Use SSPI
        //
        if (m_bRunningOnNT)
        {
            hSecurity = LoadLibrary(_T("SECURITY.DLL"));
        }
        else
        {
            hSecurity = LoadLibrary(_T("SECUR32.DLL"));
        }
    }

    if (hSecurity == NULL)
    {
        return 0;
    }

    //
    // Get the SSPI dispatch table
    //
    pfnInitSecurityInterface =
        (PSecurityFunctionTable(WINAPI *)())GetProcAddress(hSecurity, "InitSecurityInterfaceW");

    if (pfnInitSecurityInterface == NULL)
    {
        goto exit;
    }

    pSecFuncTable = (PSecurityFunctionTable)((*pfnInitSecurityInterface)());
    if (pSecFuncTable == NULL)
    {
        goto exit;
    }

    if (pSecFuncTable->AcquireCredentialsHandleW && pSecFuncTable->QueryCredentialsAttributesW)
    {
        TimeStamp  tsExpiry;
        CredHandle chCred;
        SecPkgCred_CipherStrengths cs;

        if (S_OK == (*pSecFuncTable->AcquireCredentialsHandleW)(NULL,  
                          UNISP_NAME_W, // Package
                          SECPKG_CRED_OUTBOUND,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          &chCred,      // Handle
                          &tsExpiry ))
        {
            if (S_OK == (*pSecFuncTable->QueryCredentialsAttributesW)(&chCred, SECPKG_ATTR_CIPHER_STRENGTHS, &cs))
            {
                dwKeySize = cs.dwMaximumCipherStrength;
            }

            // Free the handle if we can
            if (pSecFuncTable->FreeCredentialsHandle)
            {
                (*pSecFuncTable->FreeCredentialsHandle)(&chCred);
            }
        }
    }

exit:
    FreeLibrary(hSecurity);

    if (dwKeySize == 0 && fUseSChannel)
    {
        // Failed, so retry using SSPI
        fUseSChannel = FALSE;
        dwKeySize = GetCipherStrength();
    }
    return dwKeySize;
}

//---------------------------------------------------------------------------------
// GetCertificateInfo - Retrieves specific certificate info from passed in context.
//---------------------------------------------------------------------------------

void CMsieApp::GetCertificateInfo(PCCERT_CONTEXT pContext, int idsType, CPtrArray& ptrs)
{
	IE_CERTIFICATE *pData;
	PCCRYPT_OID_INFO pOidInfo;
	CString strType, strIssuedTo, strIssuedBy, strValidity;
	COleDateTime dateNotBefore, dateNotAfter;
	DWORD dwResult;

	pData = new IE_CERTIFICATE;
	ptrs.Add(pData);

	strType.LoadString(idsType);
	pData->Type = strType;

	// get Issued To (Subject)

	dwResult = pfnCertGetNameString(pContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, strIssuedTo.GetBuffer(256), 256);
	strIssuedTo.ReleaseBuffer();
	if (dwResult)
		pData->IssuedTo = strIssuedTo;

	// get Issued From (Issuer)

	dwResult = pfnCertGetNameString(pContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, NULL, strIssuedBy.GetBuffer(256), 256);
	strIssuedBy.ReleaseBuffer();
	if (dwResult)
		pData->IssuedBy = strIssuedBy;

	// get Validity dates

	dateNotBefore = pContext->pCertInfo->NotBefore;
	dateNotAfter = pContext->pCertInfo->NotAfter;
	strValidity.Format(IDS_VALIDITY_FORMAT, dateNotBefore.Format(VAR_DATEVALUEONLY), dateNotAfter.Format(VAR_DATEVALUEONLY));
	pData->Validity = strValidity;

	// get Signature Algorithm

	if (pOidInfo = pfnCryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, pContext->pCertInfo->SignatureAlgorithm.pszObjId, 0))
		pData->SignatureAlgorithm = pOidInfo->pwszName;
}

//-----------------------------------------------------------------------------
// GetPersonalCertificates - Retrieves certificates from MY certificate store.
//-----------------------------------------------------------------------------

void CMsieApp::GetPersonalCertificates(CPtrArray& ptrs)
{
	HCERTSTORE hStore;
	PCCERT_CONTEXT pPrevContext, pContext;
	DWORD dwPrivateKey, dwSize;

	hStore = pfnCertOpenSystemStore(NULL, MY_STORE);
	if (hStore)
	{
		pPrevContext = NULL;
		while (pContext = pfnCertEnumCertificatesInStore(hStore, pPrevContext))
		{
			// make sure private key property exists

			dwSize = sizeof(DWORD);
			if (pfnCertGetCertificateContextProperty(pContext, CERT_KEY_SPEC_PROP_ID, &dwPrivateKey, &dwSize))
			{
				GetCertificateInfo(pContext, IDS_PERSONAL_TYPE, ptrs);
			}
			pPrevContext = pContext;
		}
		pfnCertCloseStore(hStore, 0);
	}
}

//-----------------------------------------------------------------------------
// GetOtherPeopleCertificates - Retrieves from AddressBook certificate store.
//-----------------------------------------------------------------------------

void CMsieApp::GetOtherPeopleCertificates(CPtrArray& ptrs)
{
	HCERTSTORE hStore;
	PCCERT_CONTEXT pPrevContext, pContext;
	CERT_BASIC_CONSTRAINTS2_INFO constraintInfo;
	DWORD dwSize, dwIndex;
	bool bIsEndEntity;

	hStore = pfnCertOpenSystemStore(NULL, ADDRESS_BOOK_STORE);
	if (hStore)
	{
		pPrevContext = NULL;
		while (pContext = pfnCertEnumCertificatesInStore(hStore, pPrevContext))
		{
			GetCertificateInfo(pContext, IDS_OTHER_PEOPLE_TYPE, ptrs);

			pPrevContext = pContext;
		}
		pfnCertCloseStore(hStore, 0);
	}

	// also obtain end-entity certificate from CA store

	hStore = pfnCertOpenSystemStore(NULL, CA_STORE);
	if (hStore)
	{
		pPrevContext = NULL;
		while (pContext = pfnCertEnumCertificatesInStore(hStore, pPrevContext))
		{
			bIsEndEntity = false;
			for (dwIndex = 0; dwIndex < pContext->pCertInfo->cExtension; dwIndex++)
			{
				if (!strcmp(pContext->pCertInfo->rgExtension[dwIndex].pszObjId, szOID_BASIC_CONSTRAINTS2))
				{
					dwSize = sizeof(constraintInfo);
					if (pfnCryptDecodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, szOID_BASIC_CONSTRAINTS2,
													pContext->pCertInfo->rgExtension[dwIndex].Value.pbData,
													pContext->pCertInfo->rgExtension[dwIndex].Value.cbData, 0, &constraintInfo, &dwSize))
					{
						bIsEndEntity = !constraintInfo.fCA;
						break;
					}
				}
			}
			if (bIsEndEntity)
			{
				GetCertificateInfo(pContext, IDS_OTHER_PEOPLE_TYPE, ptrs);
			}
			pPrevContext = pContext;
		}
		pfnCertCloseStore(hStore, 0);
	}
}

///////////////////////////////////////////////////////////////////////////////
// AppGetIEData - Retrieves IE data.
///////////////////////////////////////////////////////////////////////////////

void CMsieApp::AppGetIEData(IEDataType enType, long *plCount, void ***pppIEData, long *pCancel)
{
	*plCount = 0;
	*pppIEData = NULL;

	if (enType == SummaryType)
	{
		IE_SUMMARY *pData;
		HINSTANCE hInstRatingDll;
		OSVERSIONINFO osver;
		HANDLE hMem;
		LPVOID lpvMem;
		VS_FIXEDFILEINFO *pVerInfo;
		CStdioFile fileSetupLog;
		COleDateTime dateTime;
		CString strAppName, strKey, strPath, strActivePrinter, strVersion, strCustomizedVersion, strSetupLog, strLine, strFullPath, strLanguage;
		DWORD dwVerInfoSize, dwTemp;
		long lStrength;
		UINT cchVerInfo;
		int nIndex, nEndIndex;
		BOOL (WINAPI *pfnRatingEnabledQuery)();

		if (pCancel)
			if (*pCancel != 0L) return;

		// Allocate one struct pointer

		*pppIEData = (void**)new LPVOID;

		// Allocate one struct

		pData = new IE_SUMMARY;
		*pppIEData[0] = pData;
		*plCount = 1;

		// get name

		strAppName.LoadString(IDS_INTERNET_EXPLORER_6);
		pData->Name = strAppName;

		// get version and build

		GetRegValue(HKEY_LOCAL_MACHINE, REG_IE_KEY, REG_VERSION, pData->Version);
		GetRegValue(HKEY_LOCAL_MACHINE, REG_IE_KEY, REG_BUILD, pData->Build);

		// get product id

		strKey = REG_IE_KEY;
		strKey += "\\";
		strKey += REG_REGISTRATION;
		GetRegValue(HKEY_LOCAL_MACHINE, strKey, REG_PRODUCT_ID, pData->ProductID);

		// get app path

		GetRegValue(HKEY_LOCAL_MACHINE, REG_IEXPLORE_EXE_KEY, _T(""), pData->Path);
		strPath = pData->Path.bstrVal;
		if (!strPath.IsEmpty())
		{
			nIndex = strPath.ReverseFind(_T('\\'));
			if (nIndex != -1)
				strPath = strPath.Left(nIndex);

			// change to long file name

			pData->Path = GetLongPathName(strPath);
		}

		// get last install date from "active setup log.txt"
		// Ex: "Date:4/7/1999 (M/D/Y) Time:10:23:20"

		if (GetWindowsDirectory(strSetupLog.GetBuffer(MAX_PATH), MAX_PATH))
		{
			strSetupLog.ReleaseBuffer();
			strSetupLog += '\\';
			strSetupLog += SETUP_LOG;

			if (fileSetupLog.Open(strSetupLog, CFile::modeRead))
			{
				try
				{
					while (fileSetupLog.ReadString(strLine))
					{
						// find date line

						if (strLine.Left(5) == "Date:")
						{
							strLine = strLine.Right(strLine.GetLength() - 5);

							// remove "(M/D/Y)"

							if ((nIndex = strLine.Find('(')) != -1)
							{
								if ((nEndIndex = strLine.Find(')')) != -1)
									strLine = strLine.Left(nIndex) + strLine.Right(strLine.GetLength() - nEndIndex - 1);
							}

							// remove "Time:"

							if ((nIndex = strLine.Find(_T("Time:"))) != -1)
								strLine = strLine.Left(nIndex) + strLine.Right(strLine.GetLength() - nIndex - 5);

							dateTime.ParseDateTime(strLine);
							pData->LastInstallDate = dateTime;

							break;
						}
					}
				}
				catch (CFileException *e)
				{
					e->Delete();
				}
				fileSetupLog.Close();
			}
		}

		// get language (from iexplore.exe)

		GetRegValue(HKEY_LOCAL_MACHINE, REG_IEXPLORE_EXE_KEY, _T(""), strFullPath);
		dwVerInfoSize = GetFileVersionInfoSize((LPTSTR)(LPCTSTR)strFullPath, &dwTemp); 
		if (dwVerInfoSize)
		{ 
			hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize); 
			lpvMem = GlobalLock(hMem); 
			if (GetFileVersionInfo((LPTSTR)(LPCTSTR)strFullPath, dwTemp, dwVerInfoSize, lpvMem))
			{
				if (VerQueryValue(lpvMem, _T("\\VarFileInfo\\Translation"), (LPVOID*)&pVerInfo, &cchVerInfo))
				{
					translation = *(TRANSLATION*)pVerInfo;
					VerLanguageName(translation.langID, strLanguage.GetBuffer(MAX_PATH), MAX_PATH);
					strLanguage.ReleaseBuffer();

					pData->Language = strLanguage;
				}
			}
			GlobalUnlock(hMem);
			GlobalFree(hMem);
		}

		// get active printer

		::GetProfileString(_T("windows"), _T("device"), _T(",,,"), strActivePrinter.GetBuffer(MAX_PATH), MAX_PATH);
		strActivePrinter.ReleaseBuffer();
		if ((!strActivePrinter.IsEmpty()) && (strActivePrinter != ",,,"))
			pData->ActivePrinter = strActivePrinter;

		// get cipher strength
  		// first check OS

		osver.dwOSVersionInfoSize = sizeof(osver);
		VERIFY(GetVersionEx(&osver));
		m_bRunningOnNT = (osver.dwPlatformId == VER_PLATFORM_WIN32_NT);
		m_bRunningOnNT5OrHigher = (m_bRunningOnNT && (osver.dwMajorVersion >= 5));
		lStrength = (long)GetCipherStrength();

		// handle weirdness of cipher strength
		/*
		if (m_bRunningOnNT5OrHigher)
			pData->CipherStrength = lStrength;
		else
			pData->CipherStrength = (lStrength >= 168) ? (long)128 : (long)40;
		
		a-sanka 02/15/2001
		QueryCredentialsAttributes returns 128 for 40-bit & 168 for 128-bit encryption.
		All other values are authentic, and can be reported unchanged.
		*/
		
		if(lStrength == 128)
			lStrength = 40;
		else if(lStrength == 168)
			lStrength = 128;
		pData->CipherStrength = lStrength;
		
		// get content advisor (via msrating.dll call)

		if (hInstRatingDll = LoadLibrary(_T("msrating.dll")))
		{
			if (pfnRatingEnabledQuery = (BOOL(WINAPI *)())GetProcAddress(hInstRatingDll, "RatingEnabledQuery"))
			{
				pData->ContentAdvisor = GetBooleanString(S_OK == pfnRatingEnabledQuery(), ENABLED_DISABLED);
			}
			FreeLibrary(hInstRatingDll);
		}

		// get ieak install

		GetRegValue(HKEY_LOCAL_MACHINE, REG_IE_KEY, REG_CUSTOMIZED_VERSION, strCustomizedVersion);
		pData->IEAKInstall = GetBooleanString(!strCustomizedVersion.IsEmpty());
		if (!strCustomizedVersion.IsEmpty())
		{
			// add IS, CO or IC to version string
			
			strVersion = pData->Version.bstrVal;
			strVersion += strCustomizedVersion;
			pData->Version = strVersion;
		}
	}

	else if (enType == FileVersionType)
	{
		IE_FILE_VERSION *pData;
		CTypedPtrArray<CPtrArray, IE_FILE_VERSION*> ptrs;
		CStringArray strSearchPaths;
		CString strInfPath, strFileName, strFileMissing, strPathEnvVar, strFullPath, strIExplorePath;
		CFileStatus status;
		COleDateTime dateTime;
		HINF hInf;
		INFCONTEXT context;
		DWORD dwFileIndex;
		long cFiles;
		int nIndex, nPathIndex;
		bool bFoundFile;

		// open msiefiles.inf file for list of files display info about

		GetRegValue(HKEY_LOCAL_MACHINE, REG_MSINFO_KEY, REG_PATH, strInfPath);
		ASSERT(!strInfPath.IsEmpty());

		// replace msinfo32.exe with inf filename

		nIndex = strInfPath.ReverseFind(_T('\\'));
		strInfPath = strInfPath.Left(nIndex + 1);
		strInfPath += INF_FILE;
		if (strInfPath[0] == _T('"'))
			strInfPath = strInfPath.Right(strInfPath.GetLength() - 1);

		hInf = SetupOpenInfFile(strInfPath, NULL, INF_STYLE_WIN4, NULL);
		ASSERT(hInf != INVALID_HANDLE_VALUE);
		if (hInf != INVALID_HANDLE_VALUE)
		{
			cFiles = SetupGetLineCount(hInf, INF_FILES_SECTION);
			if (cFiles > 0)
			{
				// get all dirs to look in from PATH environment variable

				GetEnvironmentVariable(_T("PATH"), strPathEnvVar.GetBuffer(1024), 1024);
				strPathEnvVar.ReleaseBuffer();

				while (-1 != (nIndex = strPathEnvVar.Find(_T(';'))))
				{
					strSearchPaths.Add(strPathEnvVar.Left(nIndex));
					strPathEnvVar = strPathEnvVar.Right(strPathEnvVar.GetLength() - (nIndex + 1));
				}
				if (!strPathEnvVar.IsEmpty())
					strSearchPaths.Add(strPathEnvVar);

				// also add iexplore dir to search paths

				GetRegValue(HKEY_LOCAL_MACHINE, REG_IEXPLORE_EXE_KEY, REG_PATH, strIExplorePath);
				if (!strIExplorePath.IsEmpty())
				{
					if (strIExplorePath[strIExplorePath.GetLength() - 1] == _T(';'))
						strIExplorePath = strIExplorePath.Left(strIExplorePath.GetLength() -1);
					strSearchPaths.Add(strIExplorePath);
				}

				// Look for files...

				strFileMissing.LoadString(IDS_FILE_MISSING);
				for (dwFileIndex = 0; dwFileIndex < (DWORD)cFiles; dwFileIndex++)
				{
					SetupGetLineByIndex(hInf, INF_FILES_SECTION, dwFileIndex, &context);
					SetupGetLineText(&context, hInf, NULL, NULL, strFileName.GetBuffer(_MAX_FNAME), _MAX_FNAME, NULL);
					strFileName.ReleaseBuffer();

					//...in each path (in environment)

					bFoundFile = false;
					for (nPathIndex = 0; nPathIndex < strSearchPaths.GetSize(); nPathIndex++)
					{
						strFullPath = strSearchPaths[nPathIndex];
						if (strFullPath[strFullPath.GetLength() - 1] != _T('\\'))
							strFullPath += '\\';
						strFullPath += strFileName;

						if (CFile::GetStatus(strFullPath, status))
						{
							if (!bFoundFile)
								bFoundFile = true;

							pData = new IE_FILE_VERSION;
							ptrs.Add(pData);

							// set name

							pData->File = strFileName;

							// get version

							pData->Version = GetFileVersion(strFullPath);

							// get size and modified date

							if (CFile::GetStatus(strFullPath, status))
							{
								pData->Size = (float)status.m_size / 1024;

								dateTime = status.m_mtime.GetTime();
								pData->Date = dateTime;
							}

							// get company

							pData->Company = GetFileCompany(strFullPath);

							// get path (chop off filename and make sure long filename)

							strFullPath = strFullPath.Left(strFullPath.GetLength() - (strFileName.GetLength() + 1));
							pData->Path = GetLongPathName(strFullPath);
						}
					}
					if (!bFoundFile)
					{
						pData = new IE_FILE_VERSION;
						ptrs.Add(pData);

						pData->File = strFileName;
						pData->Version = strFileMissing;
						pData->Size = _T("");
						pData->Date = _T("");
						pData->Path = _T("");
						pData->Company = _T("");
					}
				}
				SetupCloseInfFile(hInf);

				*plCount = (long) ptrs.GetSize();
				*pppIEData = (void**)new LPVOID[*plCount];

				for (int i = 0; i < *plCount; i++)
					(*pppIEData)[i] = ptrs[i];

			}
			else
			{
				*pppIEData = (void**)new LPVOID;
				pData = new IE_FILE_VERSION;
				*pppIEData[0] = pData;
				*plCount = 1;

				strFileName.LoadString(IDS_INF_FILE_MISSING);
				pData->File = strFileName;

				pData->Version = _T("");
				pData->Size = _T("");
				pData->Date = _T("");
				pData->Path = _T("");
				pData->Company = _T("");
			}
		}
	}

	else if (enType == ConnSummaryType)
	{
		IE_CONN_SUMMARY *pData;
		HKEY hOpenKey;
		BOOL bAutodial, bNoNetAutodial;
		DWORD cbData;
		long lResult;
		int ids;
		CString strTemp;

		if (pCancel)
			if (*pCancel != 0L) return;

		// Allocate one struct pointer

		*pppIEData = (void**)new LPVOID;

		// Allocate one struct

		pData = new IE_CONN_SUMMARY;
		*pppIEData[0] = pData;
		*plCount = 1;

		if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REG_IE_SETTINGS_KEY, 0, KEY_QUERY_VALUE, &hOpenKey))
		{
			cbData = sizeof(bAutodial);
			lResult = RegQueryValueEx(hOpenKey, REG_ENABLE_AUTODIAL, NULL, NULL, (BYTE*)&bAutodial, &cbData);
			if (lResult == ERROR_SUCCESS)
			{
				if (bAutodial)
				{
					cbData = sizeof(bNoNetAutodial);
					lResult = RegQueryValueEx(hOpenKey, REG_NO_NET_AUTODIAL, NULL, NULL, (BYTE*)&bNoNetAutodial, &cbData);
					if (lResult == ERROR_SUCCESS)
						ids = bNoNetAutodial ? IDS_DIAL_NO_NET : IDS_ALWAYS_DIAL;
					else
						ids = IDS_NOT_AVAILABLE;
				}
				else
					ids = IDS_NEVER_DIAL;
			}
			else
				ids = IDS_NEVER_DIAL;	// if reg entry not found, set to default

			strTemp.LoadString(ids);
			pData->ConnectionPreference = strTemp;

			RegCloseKey(hOpenKey);
		}
		GetRegValue(HKEY_CURRENT_USER, REG_IE_SETTINGS_KEY, REG_ENABLE_HTTP_1_1, pData->EnableHttp11);
		if (VT_EMPTY == pData->EnableHttp11.vt)
			pData->EnableHttp11 = (long)1;	// if reg entry not found, set to default

		GetRegValue(HKEY_CURRENT_USER, REG_IE_SETTINGS_KEY, REG_PROXY_HTTP_1_1, pData->ProxyHttp11);
		if (VT_EMPTY == pData->ProxyHttp11.vt)
			pData->ProxyHttp11 = (long)0;		// if reg entry not found, set to default
	}

	else if (enType == LanSettingsType)
	{
		IE_LAN_SETTINGS *pData;
		INTERNET_PER_CONN_OPTION_LIST list;
		HINSTANCE hInst;
		DWORD dwListSize;
		CString strTemp;

		if (pCancel)
			if (*pCancel != 0L) return;

		// Allocate one struct pointer

		*pppIEData = (void**)new LPVOID;

		// Allocate one struct

		pData = new IE_LAN_SETTINGS;
		*pppIEData[0] = pData;
		*plCount = 1;

		// get AutoConfigProxy

		GetRegValue(HKEY_CURRENT_USER, REG_IE_SETTINGS_KEY, REG_AUTO_CONFIG_PROXY, pData->AutoConfigProxy);

		// get all InternetQueryOption info

		if (hInst = GetExports(WININET))
		{
			dwListSize = sizeof(list);
			list.pszConnection = NULL;
			list.dwSize = sizeof(list);
			list.dwOptionCount = 4;
			list.pOptions = new INTERNET_PER_CONN_OPTION[4];

			list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
			list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
			list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
			list.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

			BOOL bResult = pfnInternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwListSize);
			if (bResult)
			{
				pData->AutoProxyDetectMode = GetBooleanString(list.pOptions[0].Value.dwValue & PROXY_TYPE_AUTO_DETECT, ENABLED_DISABLED);

				strTemp = list.pOptions[3].Value.pszValue;
				pData->AutoConfigURL = strTemp;

				pData->Proxy = GetBooleanString(list.pOptions[0].Value.dwValue & PROXY_TYPE_PROXY, ENABLED_DISABLED);

				strTemp = list.pOptions[1].Value.pszValue;
				pData->ProxyServer = strTemp;

				strTemp = list.pOptions[2].Value.pszValue;
				pData->ProxyOverride = strTemp;
			}
			delete []list.pOptions;

			FreeLibrary(hInst);
		}
	}

	else if (enType == ConnSettingsType)
	{
		IE_CONN_SETTINGS *pData;
		CString strName, strDefaultName, strDefault, strKey, strProxyOverride, strTemp;
		INTERNET_PER_CONN_OPTION_LIST list;
		LPRASENTRYNAME pRasEntryName;
		LPRASENTRYNAME pRasEntryNamePreFail = NULL;
		LPRASENTRY pRasEntry;
		LPRASENTRY pRasEntryPreFail = NULL;
		HINSTANCE hInstRAS, hInst;
		DWORD dwTemp, dwIndex, dwListSize, dwEntrySize, dwResult, cEntries = 0;
		int ids, nIndex, nDefaultIndex = -1;
		BOOL bResult;
		bool bFoundDefault = false;

		strDefault.LoadString(IDS_DEFAULT);

		// get number of Connections

		if (hInstRAS = GetExports(RASAPI32))
		{
			dwEntrySize = sizeof(RASENTRYNAME);
			if ((pRasEntryName = (LPRASENTRYNAME)malloc((UINT)dwEntrySize)) != NULL) 
			{
				pRasEntryName->dwSize = sizeof(RASENTRYNAME);
				dwResult = pfnRasEnumEntries(NULL, NULL, pRasEntryName, &dwEntrySize, &cEntries);
				if (dwResult == ERROR_BUFFER_TOO_SMALL)
				{
                    pRasEntryNamePreFail = pRasEntryName;
//#pragma prefast(suppress:308,"Pointer was saved")
					if ((pRasEntryName = (LPRASENTRYNAME)realloc(pRasEntryName, dwEntrySize)) != NULL)
						dwResult = pfnRasEnumEntries(NULL, NULL, pRasEntryName, &dwEntrySize, &cEntries);
                                        else
                                        {
                                            free(pRasEntryNamePreFail);
                                        }
				}
				if ((!dwResult) && (cEntries > 0) && pRasEntryName)
				{
					*plCount = cEntries;
					*pppIEData = (void**)new LPVOID[cEntries];

					// get default connection name (if one exists)

					GetRegValue(HKEY_CURRENT_USER, REG_REMOTE_ACCESS, REG_INTERNET_PROFILE, strDefaultName);

					for (dwIndex = 0; dwIndex < cEntries; dwIndex++)
					{
						pData = new IE_CONN_SETTINGS;
						(*pppIEData)[dwIndex] = pData;

						// set connection name

						strName = pRasEntryName[dwIndex].szEntryName;

						if (strName == strDefaultName)
						{
							// add " (Default)" to name

							strDefaultName += strDefault;
							pData->Name = strDefaultName;
							pData->Default = VARIANT_TRUE;
							nDefaultIndex = dwIndex;
						}
						else
						{
							pData->Name = strName;
							pData->Default = VARIANT_FALSE;
						}

						// get all InternetQueryOption info

						if (hInst = GetExports(WININET))
						{
							dwListSize = sizeof(list);
							list.pszConnection = strName.GetBuffer(strName.GetLength());
							list.dwSize = sizeof(list);
							list.dwOptionCount = 4;
							list.pOptions = new INTERNET_PER_CONN_OPTION[4];

							list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
							list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
							list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
							list.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

							bResult = pfnInternetQueryOption(NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwListSize);
							if (bResult)
							{
								pData->AutoProxyDetectMode = GetBooleanString(list.pOptions[0].Value.dwValue & PROXY_TYPE_AUTO_DETECT, ENABLED_DISABLED);

								strTemp = list.pOptions[3].Value.pszValue;
								pData->AutoConfigURL = strTemp;

								pData->Proxy = GetBooleanString(list.pOptions[0].Value.dwValue & PROXY_TYPE_PROXY, ENABLED_DISABLED);

								strTemp = list.pOptions[1].Value.pszValue;
								pData->ProxyServer = strTemp;
								
								strProxyOverride = list.pOptions[2].Value.pszValue;

								// removing all <enter>s from string

								while (-1 != (nIndex = strProxyOverride.Find(_T("\r\n"))))
									strProxyOverride = strProxyOverride.Left(nIndex) + strProxyOverride.Right(strProxyOverride.GetLength() - (nIndex + 2));

								pData->ProxyOverride = strProxyOverride;
							}
							delete []list.pOptions;
							strName.ReleaseBuffer();

							FreeLibrary(hInst);
						}

						// allow Internet programs to use connection

						strKey = REG_REMOTE_ACCESS_PROFILE;
						strKey += _T('\\');
						strKey += strName;
						if (ERROR_SUCCESS == GetRegValue(HKEY_CURRENT_USER, strKey, REG_COVER_EXCLUDE, dwTemp))
							pData->AllowInternetPrograms = GetBooleanString(!dwTemp);

						// get other reg data

						GetRegValue(HKEY_CURRENT_USER, strKey, REG_REDIAL_ATTEMPTS, pData->RedialAttempts);
						if (VT_EMPTY == pData->RedialAttempts.vt)
							pData->RedialAttempts = (long)10;		// if reg entry not found, set to default

						GetRegValue(HKEY_CURRENT_USER, strKey, REG_REDIAL_WAIT, pData->RedialWait);
						if (VT_EMPTY == pData->RedialWait.vt)
							pData->RedialWait = (long)5;		// if reg entry not found, set to default

						GetRegValue(HKEY_CURRENT_USER, strKey, REG_DISCONNECT_IDLE_TIME, pData->DisconnectIdleTime);
						if (VT_EMPTY == pData->DisconnectIdleTime.vt)
							pData->DisconnectIdleTime = (long)20;		// if reg entry not found, set to default

						dwTemp = 0;		// if reg entry not found, set to default
						GetRegValue(HKEY_CURRENT_USER, strKey, REG_ENABLE_AUTO_DISCONNECT, dwTemp);
						pData->AutoDisconnect = GetBooleanString(dwTemp, ENABLED_DISABLED);

						if (ERROR_SUCCESS == GetRegValue(HKEY_LOCAL_MACHINE, REG_PPP_KEY, REG_LOGGING, dwTemp))
							pData->RecordLogFile = GetBooleanString(dwTemp);

						// get all RasGetEntryProperties info

						dwEntrySize = sizeof(RASENTRY);
						if ((pRasEntry = (LPRASENTRY)malloc((UINT)dwEntrySize)) != NULL) 
						{
							pRasEntry->dwSize = sizeof(RASENTRY);
							dwResult = pfnRasGetEntryProperties(NULL,(LPCTSTR)strName, pRasEntry, &dwEntrySize, NULL, NULL);
							if (dwResult == ERROR_BUFFER_TOO_SMALL)
							{
                                pRasEntryPreFail = pRasEntry;
//#pragma prefast(suppress:308,"Pointer was saved")
								if ((pRasEntry = (LPRASENTRY)realloc(pRasEntry, dwEntrySize)) != NULL)
									dwResult = pfnRasGetEntryProperties(NULL, (LPCTSTR)strName, pRasEntry, &dwEntrySize, NULL, NULL);
                                else
                                {
									free(pRasEntryPreFail);
                                }
							}
							if (!dwResult && pRasEntry)
							{
								// modem name

								pData->Modem = pRasEntry->szDeviceName;

								// dial-up server (framing protocol)

								switch (pRasEntry->dwFramingProtocol)
								{
								case RASFP_Ppp:
									ids = IDS_PROTOCOL_PPP;
									break;
								case RASFP_Slip:
									ids = IDS_PROTOCOL_SLIP;
									break;
								case RASFP_Ras:
									ids = IDS_PROTOCOL_RAS;
									break;
								default:
									ids = IDS_NOT_AVAILABLE;
								}
								strTemp.LoadString(ids);
								pData->DialUpServer = strTemp;

								// bools

								pData->NetworkLogon = GetBooleanString(pRasEntry->dwfOptions & RASEO_NetworkLogon);
								pData->SoftwareCompression = GetBooleanString(pRasEntry->dwfOptions & RASEO_SwCompression);
								pData->EncryptedPassword = GetBooleanString(pRasEntry->dwfOptions & RASEO_RequireEncryptedPw);
								pData->DataEncryption = GetBooleanString(pRasEntry->dwfOptions & RASEO_RequireDataEncryption);
								pData->IPHeaderCompression = GetBooleanString(pRasEntry->dwfOptions & RASEO_IpHeaderCompression);
								pData->DefaultGateway = GetBooleanString(pRasEntry->dwfOptions & RASEO_RemoteDefaultGateway);

								// network protocols

								strName.Empty();
								if (pRasEntry->dwfNetProtocols & RASNP_Ip)
								{
									strTemp.LoadString(IDS_TCP_IP);
									strName += strTemp;
								}
								if (pRasEntry->dwfNetProtocols & RASNP_Ipx)
								{
									strTemp.LoadString(IDS_IPX_SPX);
									if (!strName.IsEmpty())
										strName += _T(", ");
									strName += strTemp;
								}
								if (pRasEntry->dwfNetProtocols & RASNP_NetBEUI)
								{
									strTemp.LoadString(IDS_NET_BEUI);
									if (!strName.IsEmpty())
										strName += _T(", ");
									strName += strTemp;
								}
								pData->NetworkProtocols = strName;

								// IP addresses

								pData->ServerAssignedIPAddress = GetBooleanString(!(pRasEntry->dwfOptions & RASEO_SpecificIpAddr));
								pData->IPAddress = ConvertIPAddressToString(pRasEntry->ipaddr);
								pData->ServerAssignedNameServer = GetBooleanString(!(pRasEntry->dwfOptions & RASEO_SpecificNameServers));
								pData->PrimaryDNS = ConvertIPAddressToString(pRasEntry->ipaddrDns);
								pData->SecondaryDNS = ConvertIPAddressToString(pRasEntry->ipaddrDnsAlt);
								pData->PrimaryWINS = ConvertIPAddressToString(pRasEntry->ipaddrWins);
								pData->SecondaryWINS = ConvertIPAddressToString(pRasEntry->ipaddrWinsAlt);

								// script filename

								pData->ScriptFileName = pRasEntry->szScript;
							}
							free(pRasEntry);
						}
    				}

					// Making sure the first item in the returned array is the default connection (if one exists)

					if (nDefaultIndex > 0)
					{
						// swapping ptrs so first item is default

						pData = (IE_CONN_SETTINGS*)(*pppIEData)[0];
						(*pppIEData)[0] = (*pppIEData)[nDefaultIndex];
						(*pppIEData)[nDefaultIndex] = pData;
					}

				}
				free(pRasEntryName);
			}
			FreeLibrary(hInstRAS);
		}
	}
	else if (enType == CacheType)
	{
		IE_CACHE *pData;
		CString strTemp, strCachePath, strKey;
		HINSTANCE hInst;
		DWORDLONG cbAvail = 0, cbTotal = 0;
		DWORD dwSyncMode, dwCacheLimit, dwCacheSize;
		int ids;

		if (pCancel)
			if (*pCancel != 0L) return;

		// Allocate one struct pointer

		*pppIEData = (void**)new LPVOID;

		// Allocate one struct

		pData = new IE_CACHE;
		*pppIEData[0] = pData;
		*plCount = 1;

		// page refresh type

		if (ERROR_SUCCESS == GetRegValue(HKEY_CURRENT_USER, REG_IE_SETTINGS_KEY, REG_SYNC_MODE_5, dwSyncMode))
		{
			switch (dwSyncMode)
			{
			case WININET_SYNC_MODE_ALWAYS:
				ids = IDS_ALWAYS;
				break;
			case WININET_SYNC_MODE_ONCE_PER_SESSION:
				ids = IDS_ONCE_PER_SESSION;
				break;
			case WININET_SYNC_MODE_AUTOMATIC:
				ids = IDS_AUTOMATIC;
				break;
			case WININET_SYNC_MODE_NEVER:
				ids = IDS_NEVER;
				break;
			default:
				ids = IDS_NOT_AVAILABLE;
			}
		}
		else
			ids = IDS_AUTOMATIC;		// if reg entry not found, set to default

		strTemp.LoadString(ids);
		pData->PageRefreshType = strTemp;

		// temp internet files folder

		GetRegValue(HKEY_CURRENT_USER, REG_SHELL_FOLDERS_KEY, REG_CACHE, pData->TempInternetFilesFolder);

		// adding hidden content.ie5 folder for size calculations
		
		strCachePath = pData->TempInternetFilesFolder.bstrVal;
		if (strCachePath.Right(strlen(CONTENT_IE5)) != CONTENT_IE5)
		{
			if (strCachePath[strCachePath.GetLength() - 1] != _T('\\'))
				strCachePath += '\\';
			strCachePath += CONTENT_IE5;
		}

		// disk space and cache size

		strKey = REG_IE_SETTINGS_KEY;
		strKey += _T('\\');
		strKey += REG_CACHE;
		strKey += _T('\\');
		strKey += REG_CONTENT;

		if (ERROR_SUCCESS == GetRegValue(HKEY_CURRENT_USER, strKey, REG_CACHE_LIMIT, dwCacheLimit))
		{
			if (hInst = GetExports(WININET))
			{
				if (pfnGetDiskInfo((LPTSTR)(LPCTSTR)strCachePath, NULL, &cbAvail, &cbTotal))
				{
					pData->TotalDiskSpace = (float)(signed __int64)(cbTotal / CONSTANT_MEGABYTE);
					pData->AvailableDiskSpace = (float)(signed __int64)(cbAvail / CONSTANT_MEGABYTE);
					pData->MaxCacheSize = (float)(dwCacheLimit / 1024);

					// get size of all files under "Temporary Internet Files" folder

					dwCacheSize = GetDirSize(strCachePath);
					TRACE(_T("Temporary Internet Files Folder Size = %lu\n"), dwCacheSize);
					pData->AvailableCacheSize = ((float)((dwCacheLimit * 1024) - dwCacheSize) / CONSTANT_MEGABYTE);
				}
				FreeLibrary(hInst);
			}
		}
	}

	else if (enType == ObjectType)
	{
		IE_OBJECT *pData;
		CTypedPtrArray<CPtrArray, IE_OBJECT*> ptrs;
		CString strTemp;
		HINSTANCE hInst;
		HANDLE hFindControl, hControl;
		DWORD dwStatus;
		int ids;

		if (hInst = GetExports(OCCACHE))
		{
			if (ERROR_SUCCESS == pfnFindFirstControl(hFindControl, hControl, NULL))
			{
				do
				{
					pData = new IE_OBJECT;
					ptrs.Add(pData);
					char strName[CONTROLNAME_MAXSIZE];
					pfnGetControlInfo(hControl, GCI_NAME, NULL, strName, CONTROLNAME_MAXSIZE);
					//strTemp.ReleaseBuffer();
					pData->ProgramFile = strName;

					pfnGetControlInfo(hControl, GCI_STATUS, &dwStatus, NULL, 0);
					switch (dwStatus)
					{
					case STATUS_CTRL_INSTALLED:
						ids = IDS_INSTALLED;
						break;
					case STATUS_CTRL_SHARED:
						ids = IDS_SHARED;
						break;
					case STATUS_CTRL_DAMAGED:
						ids = IDS_DAMAGED;
						break;
					case STATUS_CTRL_UNPLUGGED:
						ids = IDS_UNPLUGGED;
						break;
					case STATUS_CTRL_UNKNOWN:
					default:
						ids = IDS_NOT_AVAILABLE;
					}
					CString strTemp;
					strTemp.LoadString(ids);
					pData->Status = strTemp;
					char strCodeBase[INTERNET_MAX_URL_LENGTH];
					pfnGetControlInfo(hControl, GCI_CODEBASE, NULL, strCodeBase, INTERNET_MAX_URL_LENGTH);
					//strTemp.ReleaseBuffer();
					pData->CodeBase = strCodeBase;

					pfnReleaseControlHandle(hControl);

				} while (ERROR_SUCCESS == pfnFindNextControl(hFindControl, hControl));
			}
			pfnFindControlClose(hFindControl);

			*plCount = (long) ptrs.GetSize();
			*pppIEData = (void**)new LPVOID[*plCount];

			for (int i = 0; i < *plCount; i++)
				(*pppIEData)[i] = ptrs[i];

			FreeLibrary(hInst);
		}
	}

	else if (enType == ContentType)
	{
		IE_CONTENT *pData;
		HINSTANCE hInst;

		// Allocate one struct pointer

		*pppIEData = (void**)new LPVOID;

		// Allocate one struct

		pData = new IE_CONTENT;
		*pppIEData[0] = pData;
		*plCount = 1;

		if (hInst = GetExports(MSRATING))
		{
			pData->Advisor = GetBooleanString(pfnRatingEnabledQuery() == S_OK, ENABLED_DISABLED);

			FreeLibrary(hInst);
		}
	}

	else if ((enType == CertificateType))
	{
		CTypedPtrArray<CPtrArray, IE_CERTIFICATE*> ptrs;
		HINSTANCE hInst;

		if (hInst = GetExports(CRYPT32))
		{
			GetPersonalCertificates(ptrs);
			GetOtherPeopleCertificates(ptrs);

			*plCount = (long) ptrs.GetSize();
			*pppIEData = (void**)new LPVOID[*plCount];

			for (int i = 0; i < *plCount; i++)
				(*pppIEData)[i] = ptrs[i];

			FreeLibrary(hInst);
		}
	}

	else if ((enType == PublisherType))
	{
		IE_PUBLISHER *pData;
		HKEY hKey;
		CString strRegName, strRegData;
		DWORD cPublishers, dwIndex, dwNameSize, dwDataSize;

		if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REG_PUBLISHERS_KEY, 0, KEY_READ, &hKey))
		{
			if (ERROR_SUCCESS == RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &cPublishers, NULL, NULL, NULL, NULL))
			{
				*plCount = cPublishers;
				*pppIEData = (void**)new LPVOID[cPublishers];

				for (dwIndex = 0; dwIndex < cPublishers; dwIndex++)
				{
					pData = new IE_PUBLISHER;
					(*pppIEData)[dwIndex] = pData;

					dwNameSize = _MAX_FNAME;
					dwDataSize = _MAX_FNAME;
					RegEnumValue(hKey, dwIndex, strRegName.GetBuffer(_MAX_FNAME), &dwNameSize, NULL, NULL, (LPBYTE)strRegData.GetBuffer(_MAX_FNAME), &dwDataSize);
					strRegName.ReleaseBuffer();
					strRegData.ReleaseBuffer();

					pData->Name = strRegData;
				}
			}
			RegCloseKey(hKey);
		}
	}

	else if (enType == SecurityType)
	{
		IE_SECURITY *pData;
		IInternetZoneManager*  pIZoneMgr = NULL;
		DWORD dwEnum;
		DWORD dwCount;
		CTypedPtrArray<CPtrArray, IE_SECURITY*> ptrs;
		try
		{
			HRESULT hr = CoCreateInstance(CLSID_InternetZoneManager,NULL,CLSCTX_INPROC_SERVER,IID_IInternetZoneManager,(void**) &pIZoneMgr);
			if (SUCCEEDED(hr))
			{
				hr = pIZoneMgr->CreateZoneEnumerator(&dwEnum,&dwCount,0);
				if (SUCCEEDED(hr))
				{
					DWORD dwZone;
					ZONEATTRIBUTES zoneAttrib;
					for(DWORD i = 0; i < dwCount; i++)
					{
						hr = pIZoneMgr->GetZoneAt(dwEnum,i,&dwZone);
						if (FAILED(hr))
						{
							break;
						}
						hr = pIZoneMgr->GetZoneAttributes(dwZone,&zoneAttrib);
						if (FAILED(hr))
						{
							break;
						}
						pData = new IE_SECURITY;
						ptrs.Add(pData);
						pData->Zone = zoneAttrib.szDisplayName;
						CString strTemp;
						int ids;
						switch (zoneAttrib.dwTemplateCurrentLevel)
						{
							case URLTEMPLATE_LOW:
								ids = IDS_LOW;
								break;
							case 0x10500:
								ids = IDS_MEDIUM_LOW;
								break;
							case URLTEMPLATE_MEDIUM:
								ids = IDS_MEDIUM;
								break;
							case URLTEMPLATE_HIGH:
								ids = IDS_HIGH;
								break;
							case URLTEMPLATE_CUSTOM:
								ids = IDS_CUSTOM;
								break;
							default:
								ids = IDS_NOT_AVAILABLE;
						}
						strTemp.LoadString(ids);
						pData->Level = strTemp;
						
					}
				}
			


				*plCount = (long) ptrs.GetSize();
				*pppIEData = (void**)new LPVOID[*plCount];

				for (int i = 0; i < *plCount; i++)
					(*pppIEData)[i] = ptrs[i];
			}
		}
		catch(...)
		{

		}
		if (pIZoneMgr)
		{
			pIZoneMgr->Release();
		}

	}
}

///////////////////////////////////////////////////////////////////////////////
// AppDeleteIEData - Deletes previously retrieved IE data.
///////////////////////////////////////////////////////////////////////////////

void CMsieApp::AppDeleteIEData(IEDataType enType, long lCount, void **ppIEData)
{
	for (long i = 0; i < lCount; i++)
	{
		switch (enType)
		{
		case SummaryType:
			delete (IE_SUMMARY*)ppIEData[i];
			break;

		case FileVersionType:
			delete (IE_FILE_VERSION*)ppIEData[i];
			break;

		case ConnSummaryType:
			delete (IE_CONN_SUMMARY*)ppIEData[i];
			break;

		case LanSettingsType:
			delete (IE_LAN_SETTINGS*)ppIEData[i];
			break;

		case ConnSettingsType:
			delete (IE_CONN_SETTINGS*)ppIEData[i];
			break;

		case CacheType:
			delete (IE_CACHE*)ppIEData[i];
			break;

		case ObjectType:
			delete (IE_OBJECT*)ppIEData[i];
			break;

		case ContentType:
			delete (IE_CONTENT*)ppIEData[i];
			break;

		case CertificateType:
			delete (IE_CERTIFICATE*)ppIEData[i];
			break;

		case PublisherType:
			delete (IE_PUBLISHER*)ppIEData[i];
			break;

		case SecurityType:
			delete (IE_SECURITY*)ppIEData[i];
			break;
		}
	}
	delete []ppIEData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\msieppg.cpp ===
// MsiePpg.cpp : Implementation of the CMsiePropPage property page class.

#include "stdafx.h"
#include "Msie.h"
#include "MsiePpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMsiePropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMsiePropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CMsiePropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMsiePropPage, "MSIE.MsiePropPage.1",
	0x25959bf0, 0xe700, 0x11d2, 0xa7, 0xaf, 0, 0xc0, 0x4f, 0x80, 0x62, 0)


/////////////////////////////////////////////////////////////////////////////
// CMsiePropPage::CMsiePropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMsiePropPage

BOOL CMsiePropPage::CMsiePropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_MSIE_PPG, afxRegApartmentThreading);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMsiePropPage::CMsiePropPage - Constructor

CMsiePropPage::CMsiePropPage() :
	COlePropertyPage(IDD, IDS_MSIE_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CMsiePropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMsiePropPage::DoDataExchange - Moves data between page and properties

void CMsiePropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CMsiePropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMsiePropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\resdefs.h ===
// resdefs.h : Defines for friendly names of template resources

#define IDS_INTERNET_EXPLORER_6         IDS_MSITEMPLATEBASE+2
#define IDS_ITEM                        IDS_MSITEMPLATEBASE+7
#define IDS_VALUE                       IDS_MSITEMPLATEBASE+8
#define IDS_VERSION                     IDS_MSITEMPLATEBASE+9
#define IDS_BUILD                       IDS_MSITEMPLATEBASE+11
#define IDS_PRODUCT_ID                  IDS_MSITEMPLATEBASE+12
#define IDS_APP_PATH                    IDS_MSITEMPLATEBASE+13
#define IDS_LAST_INSTALL_DATE           IDS_MSITEMPLATEBASE+14
#define IDS_LANGUAGE                    IDS_MSITEMPLATEBASE+16
#define IDS_ACTIVE_PRINTER              IDS_MSITEMPLATEBASE+17
#define IDS_CIPHER_STRENGTH             IDS_MSITEMPLATEBASE+18
#define IDS_FORMAT_BIT                  IDS_MSITEMPLATEBASE+19
#define IDS_CONTENT_ADVISOR             IDS_MSITEMPLATEBASE+20
#define IDS_IEAK_INSTALL                IDS_MSITEMPLATEBASE+22
#define IDS_FILE_VERSIONS               IDS_MSITEMPLATEBASE+24
#define IDS_FILE                        IDS_MSITEMPLATEBASE+26
#define IDS_SIZE                        IDS_MSITEMPLATEBASE+28
#define IDS_DATE                        IDS_MSITEMPLATEBASE+29
#define IDS_PATH                        IDS_MSITEMPLATEBASE+30
#define IDS_COMPANY                     IDS_MSITEMPLATEBASE+31
#define IDS_FORMAT_KB                   IDS_MSITEMPLATEBASE+32
#define IDS_CONNECTIVITY                IDS_MSITEMPLATEBASE+34
#define IDS_CONN_PREF                   IDS_MSITEMPLATEBASE+38
#define IDS_PROXY_HTTP_1_1              IDS_MSITEMPLATEBASE+40
#define IDS_LAN_SETTINGS                IDS_MSITEMPLATEBASE+41
#define IDS_AUTO_CONFIG_PROXY           IDS_MSITEMPLATEBASE+42
#define IDS_AUTO_PROXY_DETECT_MODE      IDS_MSITEMPLATEBASE+43
#define IDS_AUTO_CONFIG_URL             IDS_MSITEMPLATEBASE+44
#define IDS_PROXY                       IDS_MSITEMPLATEBASE+45
#define IDS_PROXY_SERVER                IDS_MSITEMPLATEBASE+46
#define IDS_PROXY_OVERRIDE              IDS_MSITEMPLATEBASE+47
#define IDS_ALLOW_INTERNET_PROGRAMS     IDS_MSITEMPLATEBASE+49
#define IDS_MAX_ATTEMPTS                IDS_MSITEMPLATEBASE+50
#define IDS_WAIT_BETWEEN_ATTEMPTS       IDS_MSITEMPLATEBASE+51
#define IDS_DISCONNECT_IDLE_TIME        IDS_MSITEMPLATEBASE+52
#define IDS_AUTO_DISCONNECT             IDS_MSITEMPLATEBASE+53
#define IDS_MODEM                       IDS_MSITEMPLATEBASE+54
#define IDS_DIAL_UP_SERVER              IDS_MSITEMPLATEBASE+55
#define IDS_LOG_ON_TO_NETWORK           IDS_MSITEMPLATEBASE+56
#define IDS_ENABLE_SOFTWARE_COMPRESSION IDS_MSITEMPLATEBASE+57
#define IDS_REQUIRE_ENCRYPTED_PASSWORD  IDS_MSITEMPLATEBASE+58
#define IDS_REQUIRE_DATA_ENCRYPTION     IDS_MSITEMPLATEBASE+59
#define IDS_RECORD_LOG_FILE             IDS_MSITEMPLATEBASE+60
#define IDS_NETWORK_PROTOCOLS           IDS_MSITEMPLATEBASE+61
#define IDS_USE_SERVER_ASSIGNED_IP_ADDRESS IDS_MSITEMPLATEBASE+62
#define IDS_IP_ADDRESS                  IDS_MSITEMPLATEBASE+63
#define IDS_USE_SERVER_ASSIGNED_NAME_SERVER IDS_MSITEMPLATEBASE+64
#define IDS_NAME_SERVER_ADDRESSES       IDS_MSITEMPLATEBASE+65
#define IDS_USE_IP_HEADER_COMPRESSION   IDS_MSITEMPLATEBASE+66
#define IDS_USE_DEFAULT_GATEWAY         IDS_MSITEMPLATEBASE+67
#define IDS_SCRIPT_FILE_NAME            IDS_MSITEMPLATEBASE+68
#define IDS_CACHE                       IDS_MSITEMPLATEBASE+70
#define IDS_PAGE_REFRESH_TYPE           IDS_MSITEMPLATEBASE+76
#define IDS_TEMPORARY_INTERNET_FILES_FOLDER IDS_MSITEMPLATEBASE+77
#define IDS_TOTAL_DISK_SPACE            IDS_MSITEMPLATEBASE+78
#define IDS_FORMAT_MB                   IDS_MSITEMPLATEBASE+79
#define IDS_AVAILABLE_DISK_SPACE        IDS_MSITEMPLATEBASE+80
#define IDS_MAX_CACHE_SIZE              IDS_MSITEMPLATEBASE+81
#define IDS_AVAILABLE_CACHE_SIZE        IDS_MSITEMPLATEBASE+82
#define IDS_OBJECT_LIST                 IDS_MSITEMPLATEBASE+84
#define IDS_PROGRAM_FILE                IDS_MSITEMPLATEBASE+86
#define IDS_STATUS                      IDS_MSITEMPLATEBASE+87
#define IDS_CODE_BASE                   IDS_MSITEMPLATEBASE+88
#define IDS_CONTENT                     IDS_MSITEMPLATEBASE+90
#define IDS_SECURITY                    IDS_MSITEMPLATEBASE+97
#define IDS_ZONE                        IDS_MSITEMPLATEBASE+98
#define IDS_SECURITY_LEVEL              IDS_MSITEMPLATEBASE+99
#define IDS_ENABLE_HTTP_1_1             IDS_MSITEMPLATEBASE+102
#define IDS_PERSONAL_CERTIFICATES       IDS_MSITEMPLATEBASE+104
#define IDS_ISSUED_TO                   IDS_MSITEMPLATEBASE+106
#define IDS_ISSUED_BY                   IDS_MSITEMPLATEBASE+107
#define IDS_VALIDITY                    IDS_MSITEMPLATEBASE+108
#define IDS_SIGNATURE_ALGORITHM         IDS_MSITEMPLATEBASE+109
#define IDS_PRIMARY_DNS                 IDS_MSITEMPLATEBASE+110
#define IDS_SECONDARY_DNS               IDS_MSITEMPLATEBASE+111
#define IDS_PRIMARY_WINS                IDS_MSITEMPLATEBASE+112
#define IDS_SECONDARY_WINS              IDS_MSITEMPLATEBASE+113
#define IDS_PERSONAL_TYPE               IDS_MSITEMPLATEBASE+114
#define IDS_OTHER_PEOPLE_CERTIFICATES   IDS_MSITEMPLATEBASE+116
#define IDS_OTHER_PEOPLE_TYPE           IDS_MSITEMPLATEBASE+122
#define IDS_PUBLISHERS                  IDS_MSITEMPLATEBASE+124
#define IDS_NAME                        IDS_MSITEMPLATEBASE+126
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\ieproj\msinfo\stdafx.h ===
#if !defined(AFX_STDAFX_H__25959BF2_E700_11D2_A7AF_00C04F806200__INCLUDED_)
#define AFX_STDAFX_H__25959BF2_E700_11D2_A7AF_00C04F806200__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>

// Delete the two includes below if you do not wish to use the MFC
//  database classes
//#include <afxdb.h>			// MFC database classes
//#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__25959BF2_E700_11D2_A7AF_00C04F806200__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\cpldebug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME ""
#endif	// SZ_COMPNAME



static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
        if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
            break;
    }
    wsprintf(ach, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
	_AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  

    wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
	OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
	_DebugMsg(pszMsg);
	_asm {int 3};
}

#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP	_DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\advpack.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* ADVPACK.H - Self-extracting/Self-installing stub.                       *
//*                                                                         *
//***************************************************************************
// Check out different levels of quiet mode.


#ifndef _ADVPACK_H_
#define _ADVPACK_H_


//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <shlobj.h>
#include <shellapi.h>
#include "res.h"
#include "advpub.h"
#include "sdsutils.h"

//***************************************************************************
//* DEFINES                                                                 *
//***************************************************************************
#define ADVPACK_VERSION   205           // Format:  MajorVer*100+MinorVer

#define BIG_STRING        512
#define BUF_1K            1024
#define MAX_INFLINE       256

#define SHFREE_ORDINAL    195           // Required for BrowseForDir
#define _OSVER_WIN95      0
#define _OSVER_WINNT3X    1
#define _OSVER_WINNT40    2
#define _OSVER_WINNT50    3
#define _OSVER_WINNT51    4

//#define MAXERRORCHECK
// define quiet modes
#define QUIETMODE_ALL       0x0001
#define QUIETMODE_SHOWMSG   0x0002

// Flags specified in advanced INF file
#define FLAG_VALUE              0x0001              // Bit 0
#define FLAG_FAIL               0x0002              // Bit 1
#define FLAG_QUIET              0x0004              // Bit 2
#define FLAG_NOSTRIP            0x0008              // Bit 3
#define FLAG_NODIRCHECK         0x0010              // Bit 4
#define FLAG_FAIL_NOT           0x0020              // Bit 5
#define FLAG_STRIPAFTER_FIRST   0x0040              
#define DEFAULT_FLAGS   FLAG_VALUE

// Flags specifying how to set the LDID
#define LDID_SFN        0x0001              // Bit 0
#define LDID_OEM_CHARS  0x0002              // Bit 1
#define LDID_SFN_NT_ALSO   0x0004              // Bit 2

// Setup engine types
#define ENGINE_SETUPAPI 0
#define ENGINE_SETUPX   1

// CoreInstall() flags
#define COREINSTALL_PROMPT                  0x0001      // Bit 0
#define COREINSTALL_GRPCONV                 0x0002      // Bit 1
#define COREINSTALL_SMARTREBOOT             0x0004      // Bit 2
#define COREINSTALL_BKINSTALL               0x0008
#define COREINSTALL_ROLLBACK                0x0010
#define COREINSTALL_REBOOTCHECKONINSTALL    0x0020
#define COREINSTALL_ROLLBKDOALL             0x0040
#define COREINSTALL_DELAYREGISTEROCX        0x0080
#define COREINSTALL_SETUPAPI                0x0100
#define COREINSTALL_DELAYREBOOT             0x0200
#define COREINSTALL_DELAYPOSTCMD            0x0400

// Cleanup bitfield
#define CLEN_REMVINF    0x0001

// registeries for store save/restore info
//
#define   REGKEY_SAVERESTORE    "Software\\Microsoft\\Advanced INF Setup"
#define   REGSUBK_REGBK         "RegBackup"
#define   REGSUBK_CATALOGS      "Catalogs"

#define   REGVAL_BKDIR          "BackupPath"
#define   REGVAL_BKSIZE         "BackupFileSize"
#define   REGVAL_BKFILE         "BackupFileName"
#define   REGVAL_BKINSTCAB      "InstallCabFile"
#define   REGVAL_BKINSTINF      "InstallINFFile"
#define   REGVAL_BKINSTSEC      "InstallINFSection"
#define   REGVAL_BKREGDATA      "BackupRegistry"
#define   REGVAL_BKMODVER       "ComponentVersion"

#define   DEF_BACKUPPATH        "Uninstall Information"            // default fullpath: PROGRAMFILES\backup information\<module>

// registeries for system pathes
#define   REGVAL_SM_ACCESSORIES     "SM_AccessoriesName"
#define   REGVAL_PF_ACCESSORIES     "PF_AccessoriesName"
#define   REGVAL_PROGRAMFILESPATH   "ProgramFilesPath"
#define   REGVAL_PROGRAMFILES       "ProgramFilesDir"


//***************************************************************************
//* TYPE DEFINITIONS                                                        *
//***************************************************************************
// Required for BrowseForDir()
typedef WINSHELLAPI HRESULT (WINAPI *SHGETSPECIALFOLDERLOCATION)(HWND, int, LPITEMIDLIST *);
typedef WINSHELLAPI LPITEMIDLIST (WINAPI *SHBROWSEFORFOLDER)(LPBROWSEINFO);
typedef WINSHELLAPI void (WINAPI *SHFREE)(LPVOID);
typedef WINSHELLAPI BOOL (WINAPI *SHGETPATHFROMIDLIST)( LPCITEMIDLIST, LPSTR );

// Args passed to directory dialog
typedef struct _DIRDLGPARMS {
    LPSTR lpszPromptText;
    LPSTR lpszDefault;
    LPSTR lpszDestDir;
    ULONG cbDestDirSize;
    DWORD dwInstNeedSize;
} DIRDLGPARMS, *PDIRDLGPARMS;

// list of INF Install Section key names
typedef struct _INFOPT {
    PCSTR pszInfKey;
} INFOPT, *PINFOPT;

// OCX data struct
typedef struct _REGOCXData {
    PSTR pszOCX;
    PSTR pszSwitch;
    PSTR pszParam;
} REGOCXDATA, *PREGOCXDATA;

typedef UINT (WINAPI *MYFILEQUEUECALLBACK)( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 );                                      


typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;


//***************************************************************************
//* MACRO DEFINITIONS                                                       *
//***************************************************************************
#define MsgBox( hWnd, nMsgID, uIcon, uButtons ) \
    MsgBox2Param( hWnd, nMsgID, NULL, NULL, uIcon, uButtons )
#define MsgBox1Param( hWnd, nMsgID, szParam, uIcon, uButtons ) \
    MsgBox2Param( hWnd, nMsgID, szParam, NULL, uIcon, uButtons )
#define ErrorMsg( hWnd, nMsgID ) \
    MsgBox2Param( hWnd, nMsgID, NULL, NULL, MB_ICONERROR, MB_OK )
#define ErrorMsg1Param( hWnd, nMsgID, szParam ) \
    MsgBox2Param( hWnd, nMsgID, szParam, NULL, MB_ICONERROR, MB_OK )
#define ErrorMsg2Param( hWnd, nMsgID, szParam1, szParam2 ) \
    MsgBox2Param( hWnd, nMsgID, szParam1, szParam2, MB_ICONERROR, MB_OK )


#define ARRAYSIZE(a)    (sizeof(a) / sizeof((a)[0]))
#define SIZEOF(x)       (sizeof(x))

//***************************************************************************
//* string defines                                                          *
//***************************************************************************
#define szNT4XDelayUntilReboot  "System\\CurrentControlSet\\Control\\Session Manager"
#define szNT4XPendingValue      "PendingFileRenameOperations"
#define szNT3XDelayUntilReboot  "System\\CurrentControlSet\\Control\\Session Manager\\FileRenameOperations"

// install OCX
#define achREGSVREXE    " /RegServer"
#define achUNREGSVREXE  " /UnRegServer"
#define achREGSVRDLL    "DllRegisterServer"
#define achUNREGSVRDLL  "DllUnregisterServer"
#define achIEXREG       "IExpressRegOCX%d"
#define achRUNDLL       "rundll32.exe advpack.dll,RegisterOCX %s,%s,%s"
#define RUNONCEEX       "RunOnceEx"
#define RUNONCEEXDATA   "%s|%s"
#define RUNONCE_IERNONCE "rundll32.exe %s,RunOnceExProcess"

#define W95INF32DLL     "W95INF32.DLL"
#define SETUPAPIDLL     "SETUPAPI.DLL"

// INF Install section keys
#define ADVINF_DELDIRS  "DelDirs"
#define ADVINF_CLEANUP  "Cleanup"

#define ADVINF_MODNAME  "ComponentName"
#define ADVINF_ADDREG   "AddReg"
#define ADVINF_DELREG   "DelReg"
#define ADVINF_BKREG    "BackupReg"
#define ADVINF_COPYFILE "CopyFiles"
#define ADVINF_DELFILE  "DelFiles"
#define ADVINF_PREROLBK "PreRollBack"
#define ADVINF_POSTROLBK "PostRollBack"
#define ADVINF_BACKUPPATH  "BackupPath"
#define ADVINF_CHKADMIN    "CheckAdminRights"
#define ADVINF_PERUSER     "PerUserInstall"
#define ADVINF_PU_DSP      "DisplayName"
#define ADVINF_PU_GUID     "GUID"
#define ADVINF_PU_VER      "Version"
#define ADVINF_PU_LANG     "Locale"
#define ADVINF_PU_ISINST    "IsInstalled"
#define ADVINF_PU_STUB      "StubPath"
#define ADVINF_PU_CID       "ComponentID"
#define ADVINF_PU_ROLLBK    "RollbackUninstall"
#define ADVINF_FLAGS        "AdvOptions"
#define ADVINF_MODVER       "ComponentVersion"
#define ADVINF_UPDINFENG    "UpdateINFEngine"
#define ADVINF_NOBACKPLATF  "NoBackupPlatform"
#define ADVINF_CATALOG_NAME "CatalogName"


//***************************************************************************
//* FUNCTION PROTOTYPES                                                     *
//***************************************************************************

// EXPORTED FUNCTIONS


BOOL    WINAPI DllMain( HINSTANCE, DWORD, LPVOID );
HRESULT WINAPI DoInfInstall( ADVPACKARGS * );
DWORD   WINAPI GetInfInstallSectionName( LPCSTR, LPSTR, DWORD );
INT     WINAPI RegisterOCX( HWND, HINSTANCE, PSTR, INT );


// INTERNAL FUNCTIONS

HRESULT       CommonInstallInit( PCSTR, PCSTR, PSTR, DWORD, PCSTR, BOOL, DWORD );
VOID          CommonInstallCleanup( VOID );
HRESULT       CoreInstall( PCSTR, PCSTR, PCSTR, DWORD, DWORD, PCSTR );
HRESULT       RunCommands( PCSTR, PCSTR, PCSTR, DWORD, BOOL );

DWORD         GetTranslatedInt( PCSTR pszInfFilename, PCSTR pszTranslateSection, 
                                PCSTR pszTranslateKey, DWORD dwDefault );
HRESULT       GetTranslatedString( PCSTR, PCSTR, PCSTR, PSTR, DWORD, PDWORD );
HRESULT       GetTranslatedLine( PCSTR, PCSTR, DWORD, PSTR*,  PDWORD );
DWORD         GetTranslatedSection(PCSTR c_pszInfFilename, PCSTR c_pszTranslateSection,
                                   PSTR pszBuffer, DWORD dwBufSize );

BOOL          MyNTReboot( VOID );
PSTR          GetStringField( PSTR*, PCSTR, CHAR, BOOL );
BOOL          IsSeparator( CHAR, PCSTR );
PSTR          StripWhitespace( PSTR );
PSTR          StripQuotes( PSTR );
BOOL          IsGoodAdvancedInfVersion( PCSTR );
BOOL          SelectSetupEngine( PCSTR, PCSTR, DWORD );
INT           BeginPrompt( PCSTR, PCSTR, PSTR, DWORD );
VOID          EndPrompt( PCSTR, PCSTR );
BOOL          MyGetPrivateProfileString( PCSTR, PCSTR, PCSTR, PSTR, DWORD );
BOOL          LoadSetupLib( PCSTR, PCSTR, BOOL, DWORD );
VOID          UnloadSetupLib( VOID );
BOOL          CheckOSVersion( VOID );
INT           MsgBox2Param( HWND, UINT, LPCSTR, LPCSTR, UINT, UINT );
LPSTR         LoadSz( UINT, LPSTR, UINT );
BOOL          UserDirPrompt( LPSTR, LPSTR, LPSTR, ULONG, DWORD );
BOOL CALLBACK DirDlgProc( HWND, UINT, WPARAM, LPARAM );
BOOL          BrowseForDir( HWND, LPCSTR, LPSTR );
BOOL          CenterWindow( HWND, HWND );
BOOL          IsGoodDir( LPCSTR );
HRESULT       CtlSetLddPath( UINT, LPSTR, DWORD );
HRESULT       GenInstall(LPSTR, LPSTR, LPSTR);
BOOL          GetValueFromRegistry( LPSTR, UINT, LPSTR, LPSTR, LPSTR );
HRESULT       SetLDIDs( PCSTR, PCSTR, DWORD, PCSTR );
HRESULT       GetDestinationDir( PCSTR, PCSTR, DWORD, DWORD, PSTR, DWORD );
BOOL          DirExists( LPSTR );
DWORD         ParseDestinationLine( PSTR, PSTR, PSTR *, PDWORD, PDWORD, PDWORD, PDWORD );
BOOL          ParseCustomLine( PSTR, PSTR *, PSTR *, PSTR *, PSTR *, PSTR *, BOOL, BOOL );
BOOL          RegisterOCXs( LPSTR, LPSTR, BOOL, BOOL, DWORD);
BOOL          InstallOCX( PREGOCXDATA, BOOL, BOOL, int );
DWORD         FormStrWithoutPlaceHolders( LPCSTR, LPSTR, DWORD, LPCSTR );
DWORD         IsMyKeyExists( LPCSTR, LPCSTR, LPSTR, UINT, LPCSTR );

DWORD         GetWininitSize();
DWORD         GetRegValueSize(LPCSTR lpcszRegKey, LPCSTR lpcszValue);
DWORD         GetNumberOfValues(LPCSTR lpcszRegKey);
DWORD         InternalNeedRebootInit(WORD wOSVer);
BOOL          InternalNeedReboot(DWORD dwRebootCheck, WORD wOSVer);
BOOL          IsEnoughInstSpace( LPSTR szPath, DWORD cbInstNeedSize, LPDWORD pdwPadSize );
LONG          My_atol( LPSTR );
INT           My_atoi( LPSTR );
BOOL          IsFullPath( PCSTR );
//BOOL          GetUNCroot( LPSTR, LPSTR );
DWORD         MyFileSize( PCSTR );
HRESULT       CreateFullPath( PCSTR, BOOL );
HRESULT       LaunchAndWait( LPSTR, LPSTR, HANDLE *, DWORD, DWORD );
DWORD         RO_GetPrivateProfileSection( LPCSTR lpSec, LPSTR lpBuf, DWORD dwSize, LPCSTR lpFile);
HINSTANCE     MyLoadLibrary( LPSTR lpFile );

BOOL        GetThisModulePath( LPSTR lpPath, int size );
BOOL UpdateHelpDlls( LPCSTR *ppszDlls, INT numDlls, LPSTR pszPath, LPSTR pszMsg, DWORD dwFlag);
void        DoCleanup( LPCSTR szInfFilename, LPCSTR szInstallSection );
void        DelDirs( LPCSTR szInfFilename, LPCSTR szInstallSection );
void        MyRemoveDirectory( LPSTR szFolder );
PSTR        FindFileExt( PSTR pszFile );
BOOL        GetFullInfNameAndSrcDir( PCSTR pszInfFilename, PSTR pszFilename, PSTR pszSrcDir );
HRESULT     ProcessFileSections( PCSTR pszSection, PCSTR pszSrcDir, MYFILEQUEUECALLBACK pMyFileQueueCallback );
HRESULT     SaveRestoreInfo( PCSTR pszInf, PCSTR pszSection, PCSTR pszSrcDir, PCSTR pszCatalogs, DWORD dwFlags );
//HRESULT     ExtractFiles(LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags,
//                         LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved);
//BOOL        GetParentDir( LPSTR szFolder );
PSTR        GetNextToken(PSTR *ppszData, CHAR chDeLim);
HRESULT     RegRestoreAllEx( HKEY hkBckupKey );
HRESULT     ProcessAllRegSec( HWND hw, PCSTR pszTitle, PCSTR pszInf, PCSTR pszSection, HKEY hKey, HKEY hCUKey, DWORD dwFlags, BOOL *lpbOneReg );
HRESULT     ProcessAllFiles( HWND hw, PCSTR pszSection, PCSTR pszSrcDir, PCSTR pszBackupPath,
                             PCSTR pszBaseName, PCSTR pszCatalogs, PCSTR pszModule, DWORD dwFlags  );
BOOL        AddEnvInPath( PSTR pszOldPath, PSTR pszNew );
BOOL        GetProgramFilesDir( LPSTR pszPrgfDir, int iSize );
void        SetSysPathsInReg();
HRESULT     ProcessPerUserSec( PCSTR pcszInf, PCSTR pcszSec );
HRESULT     DirSafe(LPCSTR pszDir);
BOOL        GetUniHiveKeyName( HKEY hKey, LPSTR pszRegHiveKey, DWORD dwSize, LPCSTR pszBackupPath );
void        SetPathForRegHiveUse( LPSTR pszPath, DWORD * adwAttr, int iLevels, BOOL bSave );
HRESULT     RunCommandsSections( PCSTR pcszInf, PCSTR pcszSection, PCSTR c_pszKey, PCSTR c_pszSourceDir, DWORD dwFlags, BOOL bNeedReboot );
void GetNextRunOnceExSubKey( HKEY hKey, PSTR pszSubKey, int *piSubKeyNum );
void GetNextRunOnceValName( HKEY hKey, PCSTR pszFormat, PSTR pszValName, int line );
BOOL UseRunOnceEx();
BOOL RemoveBackupBaseOnVer( LPCSTR pszInf, LPCSTR pszSection );
LPSTR GetStringFieldNoQuote( PSTR *ppszString, PCSTR c_pszSeparators, BOOL bStripWhiteSpace);

BOOL GetFieldString(LPSTR lpszLine, int iField, LPSTR lpszField, int cbSize);
BOOL InitializeSetupAPI();

HRESULT     RunPatchingCommands(PCSTR c_pszInfFilename, PCSTR szInstallSection, PCSTR c_pszSourceDir);

#endif // _ADVPACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\cab_dll.h ===
/* cab_dll.h -- CABINET.DLL high-level APIs */

#ifndef _CAB_DLL_H_INCLUDED
#define _CAB_DLL_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

// File Name List
//
// used as pFilesToExtract to track files in the CAB we need extracted
//
// or a pFileList in PSESSION
//
// We keep track of all files that are in a cabinet
// keeping their names in a list and when the download
// is complete we use this list to delete temp files

struct sFNAME {
    LPSTR               pszFilename;
    struct sFNAME       *pNextName;
    DWORD               status; /* out */
};

typedef struct sFNAME FNAME;
typedef FNAME *PFNAME;


// SFNAME.status: success is 0 or non-zero error code in extraction
#define SFNAME_INIT         1
#define SFNAME_EXTRACTED    0

/***    ERRF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 *
 *  Identical to an FCI/FDI ERF, but renamed to avoid collision.
 */

typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERRF;

//
// Master State Information for File Extraction: used by extract.c
//

typedef struct {
    UINT        cbCabSize;
    ERRF        erf;
    PFNAME      pFileList;              // List of Files in CAB
    UINT        cFiles;
    DWORD       flags;                  // flags: see below for list
    char        achLocation[MAX_PATH];  // Dest Dir
    char        achFile[MAX_PATH];      // Current File
    char        achCabPath[MAX_PATH];   // Current Path to cabs
    PFNAME      pFilesToExtract;        // files to extract;null=enumerate only

} SESSION, *PSESSION;

typedef enum {
    SESSION_FLAG_NONE           = 0x0,
    SESSION_FLAG_ENUMERATE      = 0x1,
    SESSION_FLAG_EXTRACT_ALL    = 0x2,
    SESSION_FLAG_EXTRACTED_ALL  = 0x4
} SESSION_FLAGS;


typedef struct
{
    DWORD   cbStruct;
    DWORD   dwReserved1;
    DWORD   dwReserved2;
    DWORD   dwFileVersionMS;
    DWORD   dwFileVersionLS;

} CABINETDLLVERSIONINFO, *PCABINETDLLVERSIONINFO;


/* export definitions */

typedef LPCSTR WINAPI FN_GETDLLVERSION(VOID);
typedef FN_GETDLLVERSION *PFN_GETDLLVERSION;

typedef VOID WINAPI FN_DLLGETVERSION(PCABINETDLLVERSIONINFO);
typedef FN_DLLGETVERSION *PFN_DLLGETVERSION;

typedef HRESULT WINAPI FN_EXTRACT(PSESSION,LPCSTR);
typedef FN_EXTRACT *PFN_EXTRACT;

typedef VOID WINAPI FN_DELETEEXTRACTEDFILES(PSESSION);
typedef FN_DELETEEXTRACTEDFILES *PFN_DELETEEXTRACTEDFILES;

#ifdef __cplusplus
}
#endif

#endif // _CAB_DLL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\crc32.c ===
#pragma warning( disable:4001 ) /* Disable new type remark warning */

/***    crc32.c - 32-bit CRC generator
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Mike Sliger
 *
 *  History:
 *      10-Aug-1993 bens    Initial version
 */

#include <Windows.h>
// #include <types.h>
#include "crc32.h"

static long crc_32_tab[] =
{
        0x00000000L, 0x77073096L, 0xEE0E612CL, 0x990951BAL, 0x076DC419L, 0x706AF48FL, 0xE963A535L, 0x9E6495A3L,
        0x0EDB8832L, 0x79DCB8A4L, 0xE0D5E91EL, 0x97D2D988L, 0x09B64C2BL, 0x7EB17CBDL, 0xE7B82D07L, 0x90BF1D91L,
        0x1DB71064L, 0x6AB020F2L, 0xF3B97148L, 0x84BE41DEL, 0x1ADAD47DL, 0x6DDDE4EBL, 0xF4D4B551L, 0x83D385C7L,
        0x136C9856L, 0x646BA8C0L, 0xFD62F97AL, 0x8A65C9ECL, 0x14015C4FL, 0x63066CD9L, 0xFA0F3D63L, 0x8D080DF5L,
        0x3B6E20C8L, 0x4C69105EL, 0xD56041E4L, 0xA2677172L, 0x3C03E4D1L, 0x4B04D447L, 0xD20D85FDL, 0xA50AB56BL,
        0x35B5A8FAL, 0x42B2986CL, 0xDBBBC9D6L, 0xACBCF940L, 0x32D86CE3L, 0x45DF5C75L, 0xDCD60DCFL, 0xABD13D59L,
        0x26D930ACL, 0x51DE003AL, 0xC8D75180L, 0xBFD06116L, 0x21B4F4B5L, 0x56B3C423L, 0xCFBA9599L, 0xB8BDA50FL,
        0x2802B89EL, 0x5F058808L, 0xC60CD9B2L, 0xB10BE924L, 0x2F6F7C87L, 0x58684C11L, 0xC1611DABL, 0xB6662D3DL,

        0x76DC4190L, 0x01DB7106L, 0x98D220BCL, 0xEFD5102AL, 0x71B18589L, 0x06B6B51FL, 0x9FBFE4A5L, 0xE8B8D433L,
        0x7807C9A2L, 0x0F00F934L, 0x9609A88EL, 0xE10E9818L, 0x7F6A0DBBL, 0x086D3D2DL, 0x91646C97L, 0xE6635C01L,
        0x6B6B51F4L, 0x1C6C6162L, 0x856530D8L, 0xF262004EL, 0x6C0695EDL, 0x1B01A57BL, 0x8208F4C1L, 0xF50FC457L,
        0x65B0D9C6L, 0x12B7E950L, 0x8BBEB8EAL, 0xFCB9887CL, 0x62DD1DDFL, 0x15DA2D49L, 0x8CD37CF3L, 0xFBD44C65L,
        0x4DB26158L, 0x3AB551CEL, 0xA3BC0074L, 0xD4BB30E2L, 0x4ADFA541L, 0x3DD895D7L, 0xA4D1C46DL, 0xD3D6F4FBL,
        0x4369E96AL, 0x346ED9FCL, 0xAD678846L, 0xDA60B8D0L, 0x44042D73L, 0x33031DE5L, 0xAA0A4C5FL, 0xDD0D7CC9L,
        0x5005713CL, 0x270241AAL, 0xBE0B1010L, 0xC90C2086L, 0x5768B525L, 0x206F85B3L, 0xB966D409L, 0xCE61E49FL,
        0x5EDEF90EL, 0x29D9C998L, 0xB0D09822L, 0xC7D7A8B4L, 0x59B33D17L, 0x2EB40D81L, 0xB7BD5C3BL, 0xC0BA6CADL,

        0xEDB88320L, 0x9ABFB3B6L, 0x03B6E20CL, 0x74B1D29AL, 0xEAD54739L, 0x9DD277AFL, 0x04DB2615L, 0x73DC1683L,
        0xE3630B12L, 0x94643B84L, 0x0D6D6A3EL, 0x7A6A5AA8L, 0xE40ECF0BL, 0x9309FF9DL, 0x0A00AE27L, 0x7D079EB1L,
        0xF00F9344L, 0x8708A3D2L, 0x1E01F268L, 0x6906C2FEL, 0xF762575DL, 0x806567CBL, 0x196C3671L, 0x6E6B06E7L,
        0xFED41B76L, 0x89D32BE0L, 0x10DA7A5AL, 0x67DD4ACCL, 0xF9B9DF6FL, 0x8EBEEFF9L, 0x17B7BE43L, 0x60B08ED5L,
        0xD6D6A3E8L, 0xA1D1937EL, 0x38D8C2C4L, 0x4FDFF252L, 0xD1BB67F1L, 0xA6BC5767L, 0x3FB506DDL, 0x48B2364BL,
        0xD80D2BDAL, 0xAF0A1B4CL, 0x36034AF6L, 0x41047A60L, 0xDF60EFC3L, 0xA867DF55L, 0x316E8EEFL, 0x4669BE79L,
        0xCB61B38CL, 0xBC66831AL, 0x256FD2A0L, 0x5268E236L, 0xCC0C7795L, 0xBB0B4703L, 0x220216B9L, 0x5505262FL,
        0xC5BA3BBEL, 0xB2BD0B28L, 0x2BB45A92L, 0x5CB36A04L, 0xC2D7FFA7L, 0xB5D0CF31L, 0x2CD99E8BL, 0x5BDEAE1DL,

        0x9B64C2B0L, 0xEC63F226L, 0x756AA39CL, 0x026D930AL, 0x9C0906A9L, 0xEB0E363FL, 0x72076785L, 0x05005713L,
        0x95BF4A82L, 0xE2B87A14L, 0x7BB12BAEL, 0x0CB61B38L, 0x92D28E9BL, 0xE5D5BE0DL, 0x7CDCEFB7L, 0x0BDBDF21L,
        0x86D3D2D4L, 0xF1D4E242L, 0x68DDB3F8L, 0x1FDA836EL, 0x81BE16CDL, 0xF6B9265BL, 0x6FB077E1L, 0x18B74777L,
        0x88085AE6L, 0xFF0F6A70L, 0x66063BCAL, 0x11010B5CL, 0x8F659EFFL, 0xF862AE69L, 0x616BFFD3L, 0x166CCF45L,
        0xA00AE278L, 0xD70DD2EEL, 0x4E048354L, 0x3903B3C2L, 0xA7672661L, 0xD06016F7L, 0x4969474DL, 0x3E6E77DBL,
        0xAED16A4AL, 0xD9D65ADCL, 0x40DF0B66L, 0x37D83BF0L, 0xA9BCAE53L, 0xDEBB9EC5L, 0x47B2CF7FL, 0x30B5FFE9L,
        0xBDBDF21CL, 0xCABAC28AL, 0x53B39330L, 0x24B4A3A6L, 0xBAD03605L, 0xCDD70693L, 0x54DE5729L, 0x23D967BFL,
        0xB3667A2EL, 0xC4614AB8L, 0x5D681B02L, 0x2A6F2B94L, 0xB40BBE37L, 0xC30C8EA1L, 0x5A05DF1BL, 0x2D02EF8DL
};


/* update running CRC calculation with contents of a buffer */

DWORD CRC32Compute(BYTE FAR *pb,unsigned cb,DWORD crc32)
{
    // ** Put CRC in form loop want it 
    crc32 = (-1L - crc32);

    while (cb--)
    {
        crc32 = crc_32_tab[(BYTE)crc32 ^ *pb++] ^ ((crc32 >> 8) & 0x00FFFFFFL);
    }

    // ** Put CRC in form client wants it
    return (-1L - crc32);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\advpack.c ===
//***************************************************************************
//*   Copyright (c) Microsoft Corporation 1995-1996. All rights reserved.   *
//***************************************************************************
//*                                                                         *
//* ADVPACK.C - Advanced helper-dll for WExtract.                           *
//*                                                                         *
//***************************************************************************

//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <io.h>
#include <windows.h>
#include <winerror.h>
#include <ole2.h>
#include "resource.h"
#include "cpldebug.h"
#include "ntapi.h"
#include "advpub.h"
#include "w95pub32.h"
#include "advpack.h"
#include "regstr.h"
#include "globals.h"
#include "sfp.h"

//***************************************************************************
//* GLOBAL VARIABLES                                                        *
//***************************************************************************
GETSETUPXERRORTEXT32            pfGetSETUPXErrorText32            = NULL;
CTLSETLDDPATH32                 pfCtlSetLddPath32                 = NULL;
GENINSTALL32                    pfGenInstall32                    = NULL;
GENFORMSTRWITHOUTPLACEHOLDERS32 pfGenFormStrWithoutPlaceHolders32 = NULL;

typedef HRESULT (*DLLINSTALL)(BOOL bInstall, LPCWSTR pszCmdLine);

HFONT   g_hFont = NULL;

LPCSTR c_szAdvDlls[3] = { "advpack.dll",
                          "w95inf16.dll",
                          "w95inf32.dll", };

LPCSTR c_szSetupAPIDlls[2] = { "setupapi.dll",
                               "cfgmgr32.dll" };

LPCSTR c_szSetupXDlls[1] = { "setupx.dll" };

#define UPDHLPDLLS_FORCED           0x00000001
#define UPDHLPDLLS_ALERTREBOOT      0x00000002

#define MAX_NUM_DRIVES      26

const CHAR c_szQRunPreSetupCommands[]  = "QRunPreSetupCommands";
const CHAR c_szQRunPostSetupCommands[] = "QRunPostSetupCommands";
const CHAR c_szRunPreSetupCommands[]  = "RunPreSetupCommands";
const CHAR c_szRunPostSetupCommands[] = "RunPostSetupCommands";

BOOL IsDrvChecked( char chDrv );
void SetControlFont();
void SetFontForControl(HWND hwnd, UINT uiID);
void MyGetPlatformSection(LPCSTR lpSec, LPCSTR lpInfFile, LPSTR szNewSection);

//***************************************************************************
//*                                                                         *
//* NAME:       DllMain                                                     *
//*                                                                         *
//* SYNOPSIS:   Main entry point for the DLL.                               *
//*                                                                         *
//* REQUIRES:   hInst:          Handle to the DLL instance.                 *
//*             dwReason:       Reason for calling this entry point.        *
//*             dwReserved:     Nothing                                     *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if DLL loaded OK, FALSE otherwise.     *
//*                                                                         *
//***************************************************************************
BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID dwReserved )
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    // The DLL is being loaded for the first time by a given process.
	    // Perform per-process initialization here.  If the initialization
	    // is successful, return TRUE; if unsuccessful, return FALSE.

    	//Initialize the global variable holding the hinstance:
        g_hInst = hInst;

        // check if need to start the logging file.

        if ( g_hAdvLogFile == INVALID_HANDLE_VALUE)
        {
            AdvStartLogging();
        }
        AdvWriteToLog("-------------------- advpack.dll is loaded or Attached ------------------------------\r\n");
        AdvLogDateAndTime();

	    break;

	case DLL_PROCESS_DETACH:
	    // The DLL is being unloaded by a given process.  Do any
	    // per-process clean up here, such as undoing what was done in
	    // DLL_PROCESS_ATTACH.  The return value is ignored.

        // if logging is turned on, close here.

        AdvWriteToLog("-------------------- advpack.dll is unloaded or Detached ----------------------------\r\n");
        AdvStopLogging();

	    break ;

	case DLL_THREAD_ATTACH:
	    // A thread is being created in a process that has already loaded
	    // this DLL.  Perform any per-thread initialization here.  The
	    // return value is ignored.
	    //Initialize the global variable holding the hinstance --
		//NOTE: this is probably taken care of already by DLL_PROCESS_ATTACH.
	    break;

	case DLL_THREAD_DETACH:
	    // A thread is exiting cleanly in a process that has already
	    // loaded this DLL.  Perform any per-thread clean up here.  The
	    // return value is ignored.
	    break;
    }
    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       DoInfInstall                                                *
//*                                                                         *
//* SYNOPSIS:   Installs an (advanced) INF file on Win95 or WinNT.          *
//*                                                                         *
//* REQUIRES:   AdvPackArgs:    Structure containing required info. See     *
//*                             AdvPack.H.                                  *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if successful, FALSE otherwise.        *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI DoInfInstall( ADVPACKARGS *AdvPackArgs )
{
    BOOL    fSavedContext = FALSE;
    HRESULT hr = E_FAIL;
    DWORD   dwFlags;

    AdvWriteToLog("DoInfInstall: InfFile=%1\r\n", AdvPackArgs->lpszInfFilename);
    if (!SaveGlobalContext())
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    fSavedContext = TRUE;

    ctx.hWnd       = AdvPackArgs->hWnd;
    ctx.lpszTitle  = AdvPackArgs->lpszTitle;
    ctx.wOSVer     = AdvPackArgs->wOSVer;
    ctx.wQuietMode = (WORD) (0xFFFF & AdvPackArgs->dwFlags);
    ctx.bCompressed = (AdvPackArgs->dwFlags & ADVFLAGS_COMPRESSED ) ? TRUE : FALSE;
    ctx.bUpdHlpDlls = (AdvPackArgs->dwFlags & ADVFLAGS_UPDHLPDLLS) ? TRUE : FALSE;

    dwFlags = (AdvPackArgs->dwFlags & ADVFLAGS_NGCONV) ? 0 : COREINSTALL_GRPCONV;
    dwFlags |= (AdvPackArgs->dwFlags & ADVFLAGS_DELAYREBOOT) ? COREINSTALL_DELAYREBOOT : 0;
    dwFlags |= (AdvPackArgs->dwFlags & ADVFLAGS_DELAYPOSTCMD) ? COREINSTALL_DELAYPOSTCMD : 0;

    hr = CoreInstall( AdvPackArgs->lpszInfFilename, AdvPackArgs->lpszInstallSection,
                              AdvPackArgs->lpszSourceDir, AdvPackArgs->dwPackInstSize,
                              dwFlags,
                              NULL );
done:
    if (fSavedContext)
    {
        RestoreGlobalContext();
    }
    AdvWriteToLog("DoInfInstall: %1 End hr=0x%2!x!\r\n", AdvPackArgs->lpszInfFilename, hr);
    return hr;
}

//***************************************************************************
//*                                                                         *
//* NAME:       LaunchINFSection                                            *
//*                                                                         *
//* SYNOPSIS:   Entry point for RunDLL.  Takes string parameter and parses  *
//*             it, then performs GenInstall.                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
INT WINAPI LaunchINFSection( HWND hwndOwner, HINSTANCE hInstance,
                             PSTR pszParms, INT nShow )
{
    CHAR szTitle[256]          = "Advanced INF Install";
    PSTR  pszInfFilename        = NULL;
    PSTR  pszSection            = NULL;
    PSTR  pszFlags              = NULL;
    PSTR  pszSmartReboot        = NULL;
    DWORD dwFlags               = 0;
    LPSTR pszTemp               = NULL;
    CHAR chTempChar            = '\0';
    CHAR szSourceDir[MAX_PATH];
    CHAR szFilename[MAX_PATH];
    UINT  uiErrid               = 0;
    PSTR  pszErrParm1           = NULL;
    int   iRet                  = 1;  // meaningless return
    BOOL    fSavedContext = FALSE;

    AdvWriteToLog("LaunchINFSection: Param=%1\r\n", pszParms);
    if (!SaveGlobalContext())
    {
        goto done;
    }

    fSavedContext = TRUE;

    ctx.lpszTitle = szTitle;

    // Parse the arguments, the last param to GetStringField to ask what quote char to check
    pszInfFilename = GetStringField( &pszParms, ",", '\"', TRUE );
    pszSection = GetStringField( &pszParms, ",", '\"', TRUE );
    pszFlags = GetStringField( &pszParms, ",", '\"', TRUE );
    pszSmartReboot = GetStringField( &pszParms, ",", '\"', TRUE );

    if ( pszFlags != NULL ) {
        dwFlags = My_atol(pszFlags);
    }

    if ( dwFlags & LIS_QUIET ) {
        ctx.wQuietMode = QUIETMODE_ALL;
    }

    if ( pszInfFilename == NULL || *pszInfFilename == '\0' ) {
        uiErrid = IDS_ERR_BAD_SYNTAX;
        goto done;
    }

    if ( ! GetFullPathName( pszInfFilename, sizeof(szFilename), szFilename, &pszTemp ) )
    {
        uiErrid = IDS_ERR_GET_PATH;
        pszErrParm1 = pszInfFilename;
        goto done;
    }

    if ( GetFileAttributes( szFilename ) == 0xFFFFFFFF ) {
        // If the file doesn't exist in the current directory, check the
        // Windows\inf directory

        if ( !GetWindowsDirectory( szFilename, sizeof( szFilename ) ) )
        {
            uiErrid = IDS_ERR_GET_WIN_DIR;
            goto done;
        }

        AddPath( szFilename, "inf" );
        lstrcpy( szSourceDir, szFilename );

        if ( (lstrlen(szFilename)+lstrlen(pszInfFilename)+2) > MAX_PATH )
        {
            uiErrid = IDS_ERR_CANT_FIND_FILE;
            pszErrParm1 = pszInfFilename;
            goto done;
        }

        AddPath( szFilename, pszInfFilename );

        if ( GetFileAttributes( szFilename ) == 0xFFFFFFFF )
        {
            uiErrid = IDS_ERR_CANT_FIND_FILE;
            pszErrParm1 = pszInfFilename;
            goto done;
        }
    }
    else
    {
        // Generate the source directory from the inf path.
        chTempChar = *pszTemp;
        *pszTemp = '\0';
        lstrcpy( szSourceDir, szFilename );
        *pszTemp = chTempChar;
    }


    if ( !FAILED( CoreInstall( szFilename, pszSection, szSourceDir, 0,
                              COREINSTALL_PROMPT |
                              ((dwFlags & LIS_NOGRPCONV)?0:COREINSTALL_GRPCONV) |
                              COREINSTALL_SMARTREBOOT,
                              pszSmartReboot ) ) )
    {
        if (fSavedContext)
        {
            RestoreGlobalContext();
        }
        AdvWriteToLog("LaunchINFSection: %1 End Succeed\r\n", szFilename);
        return 0;
    }


done:

    if ( uiErrid != 0 )
        ErrorMsg1Param( ctx.hWnd, uiErrid, pszErrParm1 );

    if (fSavedContext)
    {
        RestoreGlobalContext();
    }
    AdvWriteToLog("LaunchINFSection: %1 End Failed\r\n", szFilename);
    return 1;
}


//***************************************************************************
//*                                                                         *
//* NAME:       RunSetupCommand                                             *
//*                                                                         *
//* SYNOPSIS:   Download Component entry point.  Runs a setup command.      *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle to parent window.                    *
//*             szCmdName:      Name of command to run (INF or EXE)         *
//*             szInfSection:   INF section to install with. NULL=default   *
//*             szDir:          Directory containing source files           *
//*             lpszTitle:      Name to attach to windows.                  *
//*             phEXE:          Handle of EXE to wait on.                   *
//*             dwFlags:        Various flags to control behavior (advpub.h)*
//*             pvReserved:     Reserved for future use.                    *
//*                                                                         *
//* RETURNS:    HRESULT:        See advpub.h                                *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI RunSetupCommand( HWND hWnd, LPCSTR szCmdName,
                                LPCSTR szInfSection, LPCSTR szDir,
                                LPCSTR lpszTitle, HANDLE *phEXE,
                                DWORD dwFlags, LPVOID pvReserved )
{
    HRESULT hReturnCode     = S_OK;
    DWORD   dwRebootCheck   = 0;
    DWORD   dwCoreInstallFlags = 0;
    BOOL    fSavedContext = FALSE;

    AdvWriteToLog("RunSetupCommand:");
    if (!SaveGlobalContext())
    {
        hReturnCode = E_OUTOFMEMORY;
        goto done;
    }

    fSavedContext = TRUE;

    // Validate parameters:

    if ( szCmdName == NULL || szDir == NULL ) {
        return E_INVALIDARG;
    }

    AdvWriteToLog(" Cmd=%1\r\n", szCmdName);
    ctx.hWnd      = hWnd;
    ctx.lpszTitle = (LPSTR) lpszTitle;

    // If caller passes invalid HWND, we will silently turn off UI.
    // NULL uses Desktop as window and passing INVALID_HANDLE sets quiet mode.

    if ( hWnd && !IsWindow(hWnd) ) {
        dwFlags |= RSC_FLAG_QUIET;
        hWnd = NULL;
    }

    if ( dwFlags & RSC_FLAG_QUIET ) {
        ctx.wQuietMode = QUIETMODE_ALL;
    }
    else
    {
        ctx.wQuietMode = 0;
    }

    ctx.bUpdHlpDlls = ( dwFlags & RSC_FLAG_UPDHLPDLLS ) ? TRUE : FALSE;

    // Check flags to see if it's an INF command
    if ( dwFlags & RSC_FLAG_INF )
    {
        if(!(dwFlags & RSC_FLAG_NGCONV))
           dwCoreInstallFlags |= COREINSTALL_GRPCONV;

        if (dwFlags & RSC_FLAG_DELAYREGISTEROCX)
           dwCoreInstallFlags |= COREINSTALL_DELAYREGISTEROCX;

        if (dwFlags & RSC_FLAG_SETUPAPI )
            dwCoreInstallFlags |= COREINSTALL_SETUPAPI;

        hReturnCode = CoreInstall( (PSTR) szCmdName, szInfSection,
                                   (PSTR) szDir, 0, dwCoreInstallFlags,
                                   NULL );

        if ( FAILED( hReturnCode ) ) {
            goto done;
        }
    } else {
        if ( ! CheckOSVersion() ) {
            hReturnCode = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
            goto done;
        }

        dwRebootCheck = InternalNeedRebootInit( ctx.wOSVer );

        hReturnCode = LaunchAndWait( (LPSTR)szCmdName, (LPSTR)szDir, phEXE, INFINITE, 0 );
        if ( hReturnCode == S_OK )
        {
             if ( phEXE )
            hReturnCode = S_ASYNCHRONOUS;
        }
        else
        {
            hReturnCode = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }

        if (    hReturnCode == S_OK
             && InternalNeedReboot( dwRebootCheck, ctx.wOSVer ) )
        {
            hReturnCode = ERROR_SUCCESS_REBOOT_REQUIRED;
        }
    }

  done:

    if (fSavedContext)
    {
        RestoreGlobalContext();
    }
    AdvWriteToLog("RunSetupCommand: Cmd=%1 End hr=0x%2!x!\r\n", szCmdName, hReturnCode);
    return hReturnCode;
}


//***************************************************************************
//*                                                                         *
//* NAME:       GetInfInstallSectionName                                    *
//*                                                                         *
//* SYNOPSIS:   Gets the name of the section to install with.               *
//*                                                                         *
//* REQUIRES:   szInfFilename:  Name of INF to find install section in.     *
//*             szInfSection:   Name of INF section to install with.  If    *
//*                             NULL, then return required size of string.  *
//*                             If "\0", use DefaultInstall.  If            *
//*                             "DefaultInstall" and running NT, then check *
//*                             for "DefaultInstall.NT section. Anything    *
//*                             else will leave the section name alone.     *
//*             dwSize:         Size of szInfSection buffer.  If not big    *
//*                             enough to hold string, then required size   *
//*                             is returned.                                *
//*                                                                         *
//* RETURNS:    DWORD:          0 if error, otherwise size of section name. *
//*                                                                         *
//***************************************************************************
DWORD WINAPI GetInfInstallSectionName( LPCSTR pszInfFilename,
                                       LPSTR pszInfSection, DWORD dwSize )
{
    CHAR achTemp[5];
    char szGivenInfSection[MAX_PATH];
    char szNewInfSection[MAX_PATH];
    DWORD dwStringLength;
    DWORD dwRequiredSize;
    static const CHAR achDefaultInstall[]   = "DefaultInstall";
    //static const CHAR achDefaultInstallNT[] = "DefaultInstall.NT";

    // On NTx86:
    //(1) if  [<Sec>.NTx86] present, this section get GenInstall, exit.
    //(2) if (1) is not present, [<sec>.NT] present and get GenInstal, exitl;
    //(3) if both [<sec>.NTx86] and [<Sec>.NT] not present, [<Sec>] section get GenInstall;
    //(4) if none of the sections in (1), (2), (3) exist, do nothing.
    // the same logic apply to NTAlpha as well.
    // On win9x:
    //(1) if [<sec>.Win] present, GetInstall it.
    //(2) if (1) is not present, GenInstall [<Sec>]
    // otherwise, do nothing.

    if ( ! CheckOSVersion() )  {
        return 0;
    }

    // If we were passed a NULL for the install section, then assume
    // they want the "DefaultInstall" section.

    if ( pszInfSection == NULL || (*pszInfSection) == '\0' )
        lstrcpy(szGivenInfSection, achDefaultInstall);
    else
        lstrcpy(szGivenInfSection, pszInfSection);

    MyGetPlatformSection(szGivenInfSection, pszInfFilename, szNewInfSection);

    dwRequiredSize = lstrlen( szNewInfSection ) + 1;
    if ( pszInfSection != NULL && (dwRequiredSize <= dwSize) )
    {
        lstrcpy( pszInfSection, szNewInfSection );
    }

    return dwRequiredSize;
}

//***************************************************************************
//*                                                                         *
//* NAME:       NeedRebootInit                                              *
//*                                                                         *
//* SYNOPSIS:   Self-registers the OCX.                                     *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
DWORD WINAPI NeedRebootInit( VOID )
{
    if ( ! CheckOSVersion() ) {
        return 0;
    }

    return InternalNeedRebootInit( ctx.wOSVer );
}


//***************************************************************************
//*                                                                         *
//* NAME:       NeedReboot                                                  *
//*                                                                         *
//* SYNOPSIS:   Self-registers the OCX.                                     *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL WINAPI NeedReboot( DWORD dwRebootCheck )
{
    if ( ! CheckOSVersion() ) {
        return 0;
    }

    return InternalNeedReboot( dwRebootCheck, ctx.wOSVer );
}

//***************************************************************************
//*                                                                         *
//* NAME:       TranslateInfString                                          *
//*                                                                         *
//* SYNOPSIS:   Translates a string in an Advanced inf file -- replaces     *
//*             LDIDs with the directory.                                   *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI TranslateInfString( PCSTR pszInfFilename, PCSTR pszInstallSection,
                                   PCSTR pszTranslateSection, PCSTR pszTranslateKey,
                                   PSTR pszBuffer, DWORD dwBufferSize,
                                   PDWORD pdwRequiredSize, PVOID pvReserved )
{
    HRESULT hReturnCode = S_OK;
    CHAR   szRealInstallSection[256];
    BOOL    fSavedContext = FALSE;
    DWORD  dwFlags = 0;

    AdvWriteToLog("TranslateInfString:" );
    if (!SaveGlobalContext())
    {
        hReturnCode = E_OUTOFMEMORY;
        goto done;
    }
    fSavedContext = TRUE;

    ctx.wQuietMode = QUIETMODE_ALL;

    // Validate parameters
    if ( pszInfFilename == NULL  || pszTranslateSection == NULL
         || pszTranslateKey == NULL || pdwRequiredSize == NULL )
    {
        hReturnCode = E_INVALIDARG;
        goto done;
    }

    AdvWriteToLog("Inf=%1 Sec=%2 Key=%3\r\n", pszInfFilename, pszTranslateSection, pszTranslateKey);

    if ((ULONG_PTR)pvReserved & (ULONG_PTR)RSC_FLAG_SETUPAPI )
            dwFlags |= COREINSTALL_SETUPAPI;

    hReturnCode = CommonInstallInit( pszInfFilename, pszInstallSection,
                                     szRealInstallSection, sizeof(szRealInstallSection), NULL, FALSE, dwFlags );
    if ( FAILED( hReturnCode ) ) {
        goto done;
    }

    hReturnCode = SetLDIDs( (LPSTR) pszInfFilename, szRealInstallSection, 0, NULL );
    if ( FAILED( hReturnCode ) ) {
        goto done;
    }

    hReturnCode = GetTranslatedString( pszInfFilename, pszTranslateSection, pszTranslateKey,
                                       pszBuffer, dwBufferSize, pdwRequiredSize );
    if ( FAILED( hReturnCode ) ) {
        goto done;
    }

  done:

    CommonInstallCleanup();
    if (fSavedContext)
    {
        RestoreGlobalContext();
    }
    AdvWriteToLog("TranslateInfString: End hr=0x%1!x!\r\n",hReturnCode);
    return hReturnCode;
}


//***************************************************************************
//*                                                                         *
//* NAME:       RegisterOCX                                                 *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
INT WINAPI RegisterOCX( HWND hwndOwner, HINSTANCE hInstance, PSTR pszParms, INT nShow )
{
    CHAR szTitle[]       = "Advpack RegisterOCX()";
    BOOL  fOleInitialized = TRUE;
    INT   nReturnCode     = 0;
    REGOCXDATA RegOCX = { 0 };

    AdvWriteToLog("RegisterOCX: Param=%1\r\n", pszParms);
    ctx.lpszTitle = szTitle;

    // Parse the arguments, SETUP engine has processed \" so we only need to check on \'
    RegOCX.pszOCX = GetStringField( &pszParms, ",", '\"', TRUE );
    RegOCX.pszSwitch = GetStringField( &pszParms, ",", '\"', TRUE );
    RegOCX.pszParam = GetStringField( &pszParms, ",", '\"', TRUE );

    if ( RegOCX.pszOCX == NULL || *(RegOCX.pszOCX) == '\0' ) {
        ErrorMsg( ctx.hWnd, IDS_ERR_BAD_SYNTAX2 );
        nReturnCode = 1;
        goto done;
    }

    if ( FAILED( OleInitialize( NULL ) ) ) {
        fOleInitialized = FALSE;
    }

    // single OCX register, use 0, 0 for last params
    //
    if ( ! InstallOCX( &RegOCX, TRUE, TRUE, 0 ) ) {
        ErrorMsg1Param( ctx.hWnd, IDS_ERR_REG_OCX, RegOCX.pszOCX );
        nReturnCode = 1;
    }

  done:

    if ( fOleInitialized ) {
        OleUninitialize();
    }
    AdvWriteToLog("RegisterOCX: Param=%1 End status=%2\r\n", RegOCX.pszOCX, (nReturnCode==0)?"Succeed":"Failed");
    return nReturnCode;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CommonInstallInit                                           *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT CommonInstallInit( PCSTR c_pszInfFilename, PCSTR c_pszSection,
                           PSTR pszRealSection, DWORD dwRealSectionSize,
                           PCSTR c_pszSourceDir, BOOL fUpdDlls, DWORD dwFlags )
{
    HRESULT hReturnCode   = S_OK;
    DWORD   dwSize        = 0;

    if ( ! CheckOSVersion() ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
        goto done;
    }

    if ( ! ctx.fOSSupportsINFInstalls ) {
        ErrorMsg( ctx.hWnd, IDS_ERR_NO_INF_INSTALLS );
        hReturnCode = HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
        goto done;
    }

    if ( c_pszSection == NULL ) {
    	*pszRealSection = '\0';
    } else {
        lstrcpy( pszRealSection, c_pszSection );
    }

    dwSize = GetInfInstallSectionName( c_pszInfFilename, pszRealSection, dwRealSectionSize );
    if ( dwSize == 0 || dwSize > dwRealSectionSize ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto done;
    }


    if ( ! LoadSetupLib( c_pszInfFilename, pszRealSection, fUpdDlls, dwFlags ) ) {
        hReturnCode = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    if ( ctx.dwSetupEngine == ENGINE_SETUPAPI ) {
        if ( FAILED(hReturnCode = MySetupOpenInfFile( c_pszInfFilename)) )
            goto done;
    }

    if ( c_pszSourceDir != NULL ) {
        hReturnCode = SetLDIDs( c_pszInfFilename, pszRealSection,
                                0, c_pszSourceDir );
        if ( FAILED(hReturnCode) ) {
            goto done;
        }
    }

    if ( ! IsGoodAdvancedInfVersion( c_pszInfFilename ) ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);
        goto done;
    }

  done:

    return hReturnCode;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CommonInstallCleanup                                        *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
VOID CommonInstallCleanup( VOID )
{
    if ( ctx.dwSetupEngine == ENGINE_SETUPAPI ) {
        MySetupCloseInfFile();
    }

    UnloadSetupLib();
}


//***************************************************************************
//*                                                                         *
//* NAME:       CoreInstall                                                 *
//*                                                                         *
//* SYNOPSIS:   Installs an (advanced) INF file on Win95 or WinNT.          *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT CoreInstall( PCSTR c_pszInfFilename, PCSTR c_pszSection,
                     PCSTR c_pszSourceDir, DWORD dwInstallSize, DWORD dwFlags,
                     PCSTR pcszSmartRebootOverride )
{
    static const CHAR c_szSmartReboot[]          = "SmartReboot";
    static const CHAR c_szSmartRebootDefault[]   = "I";
    HRESULT hReturnCode           = S_OK;
    DWORD   dwRebootCheck         = 0;
    BOOL    fNeedReboot           = FALSE;
    HKEY    hkey                  = NULL;
    CHAR   szInstallSection[256];
    CHAR   szTitle[256];
    PSTR    pszOldTitle           = NULL;
    UINT    id                    = IDCANCEL;
    BOOL    fRebootCheck          = TRUE;
    CHAR   szSmartRebootValue[4];      // Allocate 4 chars for SmartReboot value
    BOOL    fRealNeedReboot       = FALSE;
    CHAR   szCatalogName[512]     = "";

#define GRPCONV "grpconv.exe -o"

    AdvWriteToLog("CoreInstall: InfFile=%1 ", c_pszInfFilename);
    lstrcpy( szSmartRebootValue, c_szSmartRebootDefault );

    hReturnCode = CommonInstallInit( c_pszInfFilename, c_pszSection,
                                     szInstallSection, sizeof(szInstallSection),
                                     c_pszSourceDir, TRUE, dwFlags );
    if ( FAILED( hReturnCode ) ) {
        goto done;
    }
    AdvWriteToLog("InstallSection=%1\r\n", szInstallSection);
    // check Admin right if INF specified
    if (GetTranslatedInt(c_pszInfFilename, szInstallSection, ADVINF_CHKADMIN, 0))
    {
        if ( (ctx.wOSVer != _OSVER_WIN95) && !IsNTAdmin( 0, NULL) )
        {
            WORD wSav = ctx.wQuietMode;

            ctx.wQuietMode |= QUIETMODE_SHOWMSG;
            hReturnCode = E_ABORT;
            ErrorMsg( ctx.hWnd, IDS_ERR_NONTADMIN );
            ctx.wQuietMode = wSav;
            goto done;
        }
    }

    if ( (dwFlags & COREINSTALL_PROMPT) && !(dwFlags & COREINSTALL_ROLLBACK) )
    {
        pszOldTitle = ctx.lpszTitle;
        if ( BeginPrompt( c_pszInfFilename, szInstallSection, szTitle, sizeof(szTitle) )
             == IDCANCEL )
        {
            hReturnCode = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            goto done;
        }
    }


    if ( !(dwFlags & COREINSTALL_DELAYREBOOT) )
        dwRebootCheck = InternalNeedRebootInit( ctx.wOSVer );

    // the flag is so far used to control the post setup commands, so pre setup command pass flag 0, NeedReboot FALSE
    hReturnCode = RunCommandsSections( c_pszInfFilename, szInstallSection, c_szRunPreSetupCommands, c_pszSourceDir, 0, FALSE );
    if ( FAILED( hReturnCode ) )
        goto done;

    // first set LDID, then all the INF processing can use LDIDs
    hReturnCode = SetLDIDs( (PSTR) c_pszInfFilename, szInstallSection, dwInstallSize, NULL );
    if ( FAILED( hReturnCode ) )
    {
        goto done;
    }

    hReturnCode = RunPatchingCommands( c_pszInfFilename, szInstallSection, c_pszSourceDir);
    if ( FAILED( hReturnCode ) ) 
    {
        goto done;
    }


    // Remove Old backup if needed; based on the ComponentVersion stamp in INF install section
    //
    if (!(dwFlags & COREINSTALL_ROLLBACK) )
        RemoveBackupBaseOnVer( c_pszInfFilename, szInstallSection );

    // get the catalog name, if specified
    // BUGBUG: (pritobla): if not on Millen, where should we copy the catalog for migration scenario?
    ZeroMemory(szCatalogName, sizeof(szCatalogName));

    // if ROLLBKDOALL is specified, try to get the catalog name from the registry;
    // if not found, get it from the inf
    if (dwFlags & COREINSTALL_ROLLBKDOALL)
    {
        CHAR szModule[MAX_PATH];

        *szModule = '\0';
        GetTranslatedString(c_pszInfFilename, szInstallSection, ADVINF_MODNAME, szModule, sizeof(szModule), NULL);
        if (*szModule)
        {
            CHAR szKey[MAX_PATH];
            HKEY hkCatalogKey;

            lstrcpy(szKey, REGKEY_SAVERESTORE);
            AddPath(szKey, szModule);
            AddPath(szKey, REGSUBK_CATALOGS);

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hkCatalogKey) == ERROR_SUCCESS)
            {
                PSTR pszCatalog;
                DWORD dwIndex, dwSize;
                DWORD dwSizeSoFar;

                dwSizeSoFar = 0;

                // build the list of catalogs
                pszCatalog = szCatalogName;
                dwIndex = 0;
                dwSize = sizeof(szCatalogName) - 1;
                while (RegEnumValue(hkCatalogKey, dwIndex, pszCatalog, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                {
                    dwSizeSoFar += dwSize + 1;

                    pszCatalog += dwSize + 1;
                    dwIndex++;
                    dwSize = sizeof(szCatalogName) - 1 - dwSizeSoFar;
                }

                RegCloseKey(hkCatalogKey);
            }
       }
    }

    if (*szCatalogName == '\0')
        GetTranslatedString(c_pszInfFilename, szInstallSection, ADVINF_CATALOG_NAME, szCatalogName, sizeof(szCatalogName), NULL);

    if (*szCatalogName)
    {
        // load sfc.dll and the relevant proc's
        if (!LoadSfcDLL())
        {
            // couldn't load -- so empty out CatalogName
            *szCatalogName = '\0';
        }
    }

    // before we start doing any work, we need to know if this is backup install mode.  If it is,
    // we will have to backup the Reg data and file data before continuing.
    if ( (dwFlags & COREINSTALL_BKINSTALL) || ( dwFlags & COREINSTALL_ROLLBACK ) )
    {
        // if it is rollback case, we don't need to do real GenInstall.  We need to unregister the previous
        // register section first
        //
        if ( dwFlags & COREINSTALL_ROLLBACK )
        {
            RegisterOCXs( (PSTR) c_pszInfFilename, szInstallSection, FALSE, FALSE, dwFlags );
        }

        hReturnCode = SaveRestoreInfo( c_pszInfFilename, szInstallSection, c_pszSourceDir, szCatalogName, dwFlags );
        if ( FAILED( hReturnCode ) )
            goto done;

        // if it is rollback case, we don't need to do real GenInstall.  All needed are registering OCXs
        if ( dwFlags & COREINSTALL_ROLLBACK )
        {
            // here is very tricky, if the reboot needed and old file can not be registerred,
            // if we just add entries blindly to the RunOnce(ex), it will cause the fault at reboot
            // time.  So we have to make sure if we need to do this re-register thing or just use
            // DelReg and AddReg take care it.  Need revisit here!!!
            //
            fRealNeedReboot = InternalNeedReboot( dwRebootCheck, ctx.wOSVer );
            RegisterOCXs( (PSTR) c_pszInfFilename, szInstallSection, fRealNeedReboot, TRUE, dwFlags );
            if ( fRealNeedReboot )
            {
                hReturnCode = ERROR_SUCCESS_REBOOT_REQUIRED;
            }
            // process DelDirs INF line
            DelDirs( c_pszInfFilename, szInstallSection );
            goto done;
        }
    }

    // No error handling because it's an uninstall.  If unregistering fails, we
    // should continue with the uninstall.

    // BUGBUG: if it is COREINSTALL_BKINSTALL case, do we need to unregister the Existing OCXs
    // get ready for registering the new once. Maybe have foll. call do it based on flags
    //
    if ( ctx.wOSVer != _OSVER_WINNT3X )
        RegisterOCXs( (PSTR) c_pszInfFilename, szInstallSection, FALSE, FALSE, dwFlags );

    // if a catalog is specified, try to install it before calling GenInstall()
    if (*szCatalogName)
    {
        DWORD dwRet;
        CHAR szFullCatalogName[MAX_PATH];

        lstrcpy(szFullCatalogName, c_pszSourceDir);
        AddPath(szFullCatalogName, szCatalogName);

        dwRet = g_pfSfpInstallCatalog(szFullCatalogName, NULL);
        AdvWriteToLog("CoreInstall: SfpInstallCatalog returned=%1!lu!\r\n", dwRet);

        UnloadSfcDLL();

        if (dwRet != ERROR_SUCCESS  &&  dwRet != ERROR_FILE_NOT_FOUND)
        {
            // if SfpInstallCatalog return already an HRESULT, use it.
            // otherwise convert to na HRESULT.
            if (dwRet & 0x80000000)
                hReturnCode = dwRet;
            else
                hReturnCode = HRESULT_FROM_WIN32(dwRet);
            goto done;
        }

        if (dwRet == ERROR_FILE_NOT_FOUND)
            *szCatalogName = '\0';
    }

    AdvWriteToLog("GenInstall: Sec=%1\r\n", szInstallSection);
    hReturnCode = GenInstall( (PSTR) c_pszInfFilename, szInstallSection, (PSTR) c_pszSourceDir );
    AdvWriteToLog("GenInstall return: Sec=%1 hr=0x%2!x!\r\n", szInstallSection, hReturnCode);
    if ( FAILED( hReturnCode ) )
        goto done;

    fRealNeedReboot = InternalNeedReboot( dwRebootCheck, ctx.wOSVer );
    fNeedReboot = fRealNeedReboot;

    // Process SmartReboot key
    if ( dwFlags & COREINSTALL_SMARTREBOOT )
    {
        if ( pcszSmartRebootOverride != NULL && *pcszSmartRebootOverride != '\0' )
        {
            lstrcpy( szSmartRebootValue, pcszSmartRebootOverride );
        }
        else
        {
             if ( FAILED( GetTranslatedString( c_pszInfFilename, szInstallSection, c_szSmartReboot,
                                               szSmartRebootValue, sizeof(szSmartRebootValue), NULL) ) )
             {
                lstrcpy( szSmartRebootValue, c_szSmartRebootDefault );
             }
        }

        switch ( szSmartRebootValue[0] )
        {
            case 'a':
            case 'A':
                fNeedReboot = TRUE;
                break;

            case 'N':
            case 'n':
                fNeedReboot = FALSE;
                break;

            case '\0':
                lstrcpy( szSmartRebootValue, c_szSmartRebootDefault );
                break;
       }
    }

    if ( ctx.wOSVer != _OSVER_WINNT3X )
    {
        if ( ! RegisterOCXs( (PSTR) c_pszInfFilename, szInstallSection, (fNeedReboot || fRealNeedReboot), TRUE, dwFlags ) )
        {
            hReturnCode = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }
    }

    // The reason we pass in the reboot flag is to be consistent with register OCX
    hReturnCode = RunCommandsSections( c_pszInfFilename, szInstallSection, c_szRunPostSetupCommands, c_pszSourceDir, dwFlags, (fNeedReboot || fRealNeedReboot) );
    if ( FAILED( hReturnCode ) )
       goto done;

    // process PerUserInstall section
    hReturnCode = ProcessPerUserSec( c_pszInfFilename, szInstallSection );
    if ( FAILED( hReturnCode ) )
       goto done;

    // if /R:P is passed in, check absolute reboot condition rather than delta
    if ( (dwFlags & COREINSTALL_DELAYPOSTCMD) || (hReturnCode == ERROR_SUCCESS_REBOOT_REQUIRED) )
        dwRebootCheck = 0;

    // Do we need a reboot now?  Lets find out...
    fRealNeedReboot = InternalNeedReboot( dwRebootCheck, ctx.wOSVer );
    if (GetTranslatedInt(c_pszInfFilename, szInstallSection, "Reboot", 0))
    {
        fRealNeedReboot = TRUE;
    }

    if ( fRealNeedReboot )
    {
        hReturnCode = ERROR_SUCCESS_REBOOT_REQUIRED;
    }

    // Process SmartReboot key
    if ( szSmartRebootValue[0] == 'i' || szSmartRebootValue[0] == 'I' )
    {
        fNeedReboot = fRealNeedReboot;
    }

    if ( ctx.wOSVer != _OSVER_WINNT3X )
    {
        if ( NeedToRunGrpconv() )
        {
            if ( (dwFlags & COREINSTALL_GRPCONV) && !fNeedReboot && !fRealNeedReboot )
            {
                char   szDir[MAX_PATH];

                GetWindowsDirectory( szDir, sizeof(szDir) );
                // only wait this unmoral member 30 secs
                LaunchAndWait( GRPCONV, szDir, NULL, 30000, (ctx.wQuietMode & QUIETMODE_ALL)? RUNCMDS_QUIET : 0 );
            }
            else
            {
                if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, 0, NULL,
                                    REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, NULL) == ERROR_SUCCESS )
                {
                    RegSetValueEx( hkey, "GrpConv", 0, REG_SZ, (LPBYTE) GRPCONV, lstrlen(GRPCONV) + 1 );
                    RegCloseKey(hkey);
                }
            }
        }
    }

    // process DelDirs INF line
    DelDirs( c_pszInfFilename, szInstallSection );

    if ( dwFlags & COREINSTALL_PROMPT ) {
    	EndPrompt( c_pszInfFilename, szInstallSection );
    }

    // process Cleanup INF line
    DoCleanup( c_pszInfFilename, szInstallSection );

    if ( fNeedReboot && (dwFlags & COREINSTALL_SMARTREBOOT) )
    {
        if ( szSmartRebootValue[1] == 's' || szSmartRebootValue[1] == 'S' )
        {
            id = IDYES;
        }
        else
        {
            id = MsgBox( ctx.hWnd, IDS_RESTARTYESNO, MB_ICONINFORMATION, MB_YESNO );
        }

        if ( id == IDYES )
        {
            if ( ctx.wOSVer == _OSVER_WIN95 )
            {
                // By default (all platforms), we assume powerdown is possible
                id = ExitWindowsEx( EWX_REBOOT, 0 );
            }
            else
            {
                MyNTReboot();
            }
        }
    }

  done:

    if ( dwFlags & COREINSTALL_PROMPT ) {
        ctx.lpszTitle = pszOldTitle;
    }

    if (*szCatalogName)
        UnloadSfcDLL();

    CommonInstallCleanup();

    AdvWriteToLog("CoreInstall: End InfFile=%1 hr=0x%2!x!\r\n", c_pszInfFilename, hReturnCode);
    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       RunCommandsSections                                         *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT RunCommandsSections( PCSTR pcszInf, PCSTR pcszSection, PCSTR c_pszKey,
                             PCSTR c_pszSourceDir, DWORD dwFlags, BOOL bNeedReboot )
{
    HRESULT hRet = S_OK;
    char szBuf[MAX_INFLINE];
    LPSTR pszOneSec, pszStr, pszFlag;
    DWORD dwCmdsFlags;

    szBuf[0] = 0;
    pszStr = szBuf;

    if ( FAILED(GetTranslatedString( pcszInf, pcszSection, c_pszKey, szBuf, sizeof(szBuf), NULL)))
        szBuf[0] = 0;

    // Parse the arguments, SETUP engine is not called to process this line.  So we check on \".
    pszOneSec = GetStringField( &pszStr, ",", '\"', TRUE );
    while ( (hRet == S_OK) && pszOneSec && *pszOneSec )
    {
        dwCmdsFlags  = 0;
        pszFlag = ANSIStrChr( pszOneSec, ':' );
        if ( pszFlag && (*pszFlag == ':') )
        {
            pszFlag = CharNext(pszFlag);
            *CharPrev(pszOneSec, pszFlag) = '\0';
            dwCmdsFlags = AtoL(pszFlag);
        }

        if ( (dwFlags & COREINSTALL_DELAYPOSTCMD) &&
             (!lstrcmpi(c_pszKey, c_szRunPostSetupCommands)) )
        {
            dwCmdsFlags |= RUNCMDS_DELAYPOSTCMD;
        }

        hRet = RunCommands( pcszInf, pszOneSec, c_pszSourceDir, dwCmdsFlags, bNeedReboot );

        pszOneSec = GetStringField( &pszStr, ",", '\"', TRUE );
    }

    return hRet;
}

//***************************************************************************
//*                                                                         *
//* NAME:       RunCommands                                                 *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT RunCommands( PCSTR pcszInfFilename, PCSTR pcszSection, PCSTR c_pszSourceDir,
                     DWORD dwCmdsFlags, BOOL bNeedReboot )
{
    HRESULT hReturnCode = S_OK;
    DWORD i = 0;
    PSTR pszCommand = NULL, pszNewCommand;
    CHAR szMessage[BIG_STRING];

    AdvWriteToLog("RunCommands: Sec=%1\r\n", pcszSection);
    pszNewCommand = (LPSTR) LocalAlloc( LPTR, BUF_1K );
    if ( !pszNewCommand )
    {
        hReturnCode = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    for ( i = 0; ; i += 1 )
    {
        if ( FAILED( GetTranslatedLine( pcszInfFilename, pcszSection,
                                        i, &pszCommand, NULL ) ) || !pszCommand )
        {
            break;
        }

        // check if this command need to be delayed
        // if there is reboot condition regardless who cause it, delay.
        if ( (dwCmdsFlags & RUNCMDS_DELAYPOSTCMD) &&
             (InternalNeedReboot( 0, ctx.wOSVer ) || bNeedReboot ) )
        {
            static int iSubKeyNum = 989;
            static int iLine = 0;
            static BOOL  bRunOnceEx = FALSE;
            HKEY hKey, hSubKey;
            LPSTR lpRegTmp;

            if ( iSubKeyNum == 989 )
            {
                if ( UseRunOnceEx() )
                {
                    bRunOnceEx = TRUE;
                }
            }

            // decide to add the entry to RunOnce or RunOnceEx
            if ( !bRunOnceEx )
            {
                // no ierunonce.dll, use RunOnce key rather than RunOnceEx key
                lpRegTmp = REGSTR_PATH_RUNONCE;
            }
            else
            {
                lpRegTmp = REGSTR_PATH_RUNONCEEX;
            }

            // open RunOnce or RunOnceEx key here
            if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, lpRegTmp, (ULONG)0, NULL,
                                 REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL,
                                 &hKey, NULL ) == ERROR_SUCCESS )
            {
                // SubKey "990" is the one used in one GenInstall section to
                // store all the delayed post cmds.
                if ( bRunOnceEx )
                {
                    if ( iSubKeyNum == 989 )
                        GetNextRunOnceExSubKey( hKey, szMessage, &iSubKeyNum );
                    else
                        wsprintf( szMessage, "%d", iSubKeyNum );

                    // Generate the Value Name and ValueData.
                    //
                    if ( RegCreateKeyEx( hKey, szMessage, (ULONG)0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                         NULL, &hSubKey, NULL ) == ERROR_SUCCESS )
                    {
                        GetNextRunOnceValName( hSubKey, "%03d", szMessage, iLine++ );
                        RegSetValueEx( hSubKey, szMessage, 0, REG_SZ, (LPBYTE)pszCommand, lstrlen(pszCommand)+1 );
                        AdvWriteToLog("RunOnceEx Entry: %1\r\n", pszCommand);
                        RegCloseKey( hSubKey );
                    }
                }
                else
                {
                    GetNextRunOnceValName( hKey, achIEXREG, szMessage, iLine++ );
                    RegSetValueEx( hKey, szMessage, 0, REG_SZ, (LPBYTE)pszCommand, lstrlen(pszCommand)+1 );
                    AdvWriteToLog("RunOnce Entry: %1\r\n", pszCommand);
                }

                RegCloseKey( hKey );

                // if we delay the commands, should trig the reboot.
                hReturnCode = ERROR_SUCCESS_REBOOT_REQUIRED;
            }
        }
        else
        {
            if ( ! IsFullPath( pszCommand ) )
            {
                lstrcpy( pszNewCommand, c_pszSourceDir );
                AddPath( pszNewCommand, pszCommand );
            }

            if ( ( *pszNewCommand == 0 ) ||
                 ( LaunchAndWait( pszNewCommand, NULL, NULL, INFINITE, dwCmdsFlags ) == E_FAIL ) )
            {
                if ( LaunchAndWait( pszCommand, NULL, NULL, INFINITE, dwCmdsFlags ) == E_FAIL )
                {
                    hReturnCode = HRESULT_FROM_WIN32(GetLastError());
                    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                    szMessage, sizeof(szMessage), NULL );
                    ErrorMsg2Param( ctx.hWnd, IDS_ERR_CREATE_PROCESS, pszCommand, szMessage );
                    break;
                }
            }
        }


        // release the buffer allocated by GetTranslatedLine
        LocalFree( pszCommand );
        pszCommand = NULL;
        *pszNewCommand = 0;
    }

    // release the local buffer
    if ( pszNewCommand )
        LocalFree( pszNewCommand );

    // release the buffer allocated by GetTranslatedLine
    if ( pszCommand )
        LocalFree( pszCommand );

  done:
    AdvWriteToLog("RunCommands: Sec=%1 End hr=0x%2!x!\r\n", pcszSection, hReturnCode);
    return hReturnCode;
}
//***************************************************************************
//*                                                                         *
//* NAME:       GetTranslatedInt                                         *
//*                                                                         *
//* SYNOPSIS:   Translates a string in an INF file.                         *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
DWORD GetTranslatedInt( PCSTR pszInfFilename, PCSTR pszTranslateSection,
                        PCSTR pszTranslateKey, DWORD dwDefault )
{
    CHAR    szBuf[100];
    //BOOL    bLocalInitSetupapi = FALSE;
	BOOL	bLocalAssignSetupEng = FALSE;
    DWORD   dwResult, dwRequiredSize;
    DWORD   dwSaveSetupEngine;

    dwResult = dwDefault;
    // since we are no using GetPrivateProfileString anymore if setupapi present
    // there are times this function called and setupapi.dll is not loaded yet.
    // so we need to check on in and initalize it if it is necessary
    if (ctx.hSetupLibrary==NULL)
    {
        if (CheckOSVersion() && (ctx.wOSVer != _OSVER_WIN95))
        {
            //dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPAPI;
            //bLocalAssignSetupEng = TRUE;
            if (InitializeSetupAPI())
            {
				// To avoid multiple times load and unload the NT setupapi DLLs
				// On NT, we are not unload the setuplib unless the INF engine need to be
				// updated.
				//
                if (FAILED(MySetupOpenInfFile(pszInfFilename)))
                {
                    // UnloadSetupLib();
                    goto done;
                }
                //bLocalInitSetupapi = TRUE;
            }
            else
            {
                goto done;
            }
        }
        else
        {
            // if setupx lib is not initialized yet, just use GetPrivateProfileString
            dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPX;
            bLocalAssignSetupEng = TRUE;

        }
    }

    if ( ctx.dwSetupEngine == ENGINE_SETUPX )
    {
        dwResult = (DWORD)GetPrivateProfileInt(pszTranslateSection, pszTranslateKey, dwDefault, pszInfFilename);
    }
    else
    {
        szBuf[0] = '\0';
        if ( FAILED(MySetupGetLineText( pszTranslateSection, pszTranslateKey, szBuf,
                                          sizeof(szBuf), &dwRequiredSize )))
        {
            goto done;
        }
        // convert the string to DWORD
        if (szBuf[0] != '\0')
            dwResult = (DWORD)AtoL(szBuf);
        else
            dwResult = dwDefault;
    }

done:
    //if (bLocalInitSetupapi)
    //{
        // uninitialize setupapi
        //CommonInstallCleanup();
    //}

    if (bLocalAssignSetupEng)
        ctx.dwSetupEngine = dwSaveSetupEngine;

    return dwResult;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetTranslatedString                                         *
//*                                                                         *
//* SYNOPSIS:   Translates a string in an INF file.                         *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT GetTranslatedString( PCSTR pszInfFilename, PCSTR pszTranslateSection,
                             PCSTR pszTranslateKey, PSTR pszBuffer, DWORD dwBufferSize, PDWORD pdwRequiredSize )
{
    HRESULT hReturnCode = S_OK;
    PSTR    pszPreTranslated = NULL;
    PSTR    pszPostTranslated = NULL;
    DWORD   dwSizePreTranslated = 2048;
    DWORD   dwSizePostTranslated = 4096;
    DWORD   dwRequiredSize = 0;
    //BOOL    bLocalInitSetupapi = FALSE;
	BOOL	bLocalAssignSetupEng = FALSE;
    DWORD   dwSaveSetupEngine;

    // since we are no using GetPrivateProfileString anymore if setupapi present
    // there are times this function called and setupapi.dll is not loaded yet.
    // so we need to check on in and initalize it if it is necessary
    if (ctx.hSetupLibrary==NULL)
    {
        if (CheckOSVersion() && (ctx.wOSVer != _OSVER_WIN95))
        {
  			// To avoid multiple times load and unload the NT setupapi DLLs
			// On NT, we are not unload the setuplib unless the INF engine need to be
			// updated.
			//
	        //dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPAPI;
            //bLocalAssignSetupEng = TRUE;
            if (InitializeSetupAPI())
            {
                hReturnCode = MySetupOpenInfFile(pszInfFilename);
                if (FAILED(hReturnCode))
                {
                    //UnloadSetupLib();
                    goto done;
                }
                //bLocalInitSetupapi = TRUE;
            }
            else
            {
                hReturnCode = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
                goto done;
            }
        }
        else
        {
            // if setupx lib is not initialized yet, just use GetPrivateProfileString
            dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPX;
            bLocalAssignSetupEng = TRUE;
        }
    }

    // NOTE: There should never be a value in an INF greater than 2k
    //       and translated strings shouldn't exceed 4k.

    pszPreTranslated = (PSTR) LocalAlloc( LPTR, dwSizePreTranslated );
    pszPostTranslated = (PSTR) LocalAlloc( LPTR, dwSizePostTranslated );

    if ( ! pszPreTranslated || ! pszPostTranslated ) {
        hReturnCode = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    if ( ctx.dwSetupEngine == ENGINE_SETUPX ) {
        if ( ! MyGetPrivateProfileString( pszInfFilename, pszTranslateSection, pszTranslateKey,
                                          pszPreTranslated, dwSizePreTranslated ) )
        {
            hReturnCode = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto done;
        }

        if ( ctx.hSetupLibrary )
        {
             if (!pfGenFormStrWithoutPlaceHolders32( pszPostTranslated, pszPreTranslated,
                                                 (LPSTR) pszInfFilename ) )
             {
                 hReturnCode = E_UNEXPECTED;
                 goto done;
             }
        }
        else
            FormStrWithoutPlaceHolders( pszPreTranslated, pszPostTranslated, dwSizePostTranslated, pszInfFilename );

        dwRequiredSize = lstrlen( pszPostTranslated ) + 1;
    }
    else
    {
        hReturnCode = MySetupGetLineText( pszTranslateSection, pszTranslateKey, pszPostTranslated,
                                          dwSizePostTranslated, &dwRequiredSize );

        if (FAILED(hReturnCode) && HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hReturnCode) 
        {
            // resize buffer and retry.
            LocalFree(pszPostTranslated);
            pszPostTranslated = LocalAlloc(LPTR, dwRequiredSize);
            dwSizePostTranslated = dwRequiredSize;
            if ( !pszPostTranslated ) {
                hReturnCode = HRESULT_FROM_WIN32(GetLastError());
                goto done;
            }

            hReturnCode = MySetupGetLineText( pszTranslateSection, pszTranslateKey,
                                             pszPostTranslated, dwSizePostTranslated,
                                             &dwRequiredSize );
        }

        if ( FAILED(hReturnCode) )
        {
            goto done;
        }
    }

    if ( pszBuffer == NULL ) {
        hReturnCode = S_OK;
        goto done;
    }

    if ( dwRequiredSize > dwBufferSize ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto done;
    }

    lstrcpy( pszBuffer, pszPostTranslated );

done:
    //if (bLocalInitSetupapi)
    //{
        // uninitialize setupapi
        //CommonInstallCleanup();
    //}

    if (bLocalAssignSetupEng)
        ctx.dwSetupEngine = dwSaveSetupEngine;

    if ( pdwRequiredSize ) {
        *pdwRequiredSize = dwRequiredSize;
    }

    if ( pszPreTranslated != NULL ) {
        LocalFree( pszPreTranslated );
    }

    if ( pszPostTranslated != NULL ) {
        LocalFree( pszPostTranslated );
    }

    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetTranslatedLine                                           *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT GetTranslatedLine( PCSTR c_pszInfFilename, PCSTR c_pszTranslateSection,
                           DWORD dwIndex, PSTR *ppszBuffer, PDWORD pdwRequiredSize )
{
    HRESULT hReturnCode      = S_OK;
    PSTR    pszPreTranslated = NULL;
    PSTR    pszPostTranslated = NULL;
    DWORD   dwPreTranslatedSize = 8192;
    DWORD   dwPostTranslatedSize = 4096;
    DWORD   dwRequiredSize = 0;
    DWORD   i             = 0;
    PSTR    pszPoint       = NULL;
    //BOOL    bLocalInitSetupapi = FALSE;
	BOOL	bLocalAssignSetupEng = FALSE;
    DWORD   dwSaveSetupEngine;

    // since we are no using GetPrivateProfileString anymore if setupapi present
    // there are times this function called and setupapi.dll is not loaded yet.
    // so we need to check on in and initalize it if it is necessary
    if (ctx.hSetupLibrary==NULL)
    {
        if (CheckOSVersion() && (ctx.wOSVer != _OSVER_WIN95))
        {
			// To avoid multiple times load and unload the NT setupapi DLLs
			// On NT, we are not unload the setuplib unless the INF engine need to be
			// updated.
			//

            //dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPAPI;
            //bLocalAssignSetupEng = TRUE;
            if (InitializeSetupAPI())
            {
                hReturnCode = MySetupOpenInfFile(c_pszInfFilename);
                if (FAILED(hReturnCode))
                {
                    //UnloadSetupLib();
                    goto done;
                }
                //bLocalInitSetupapi = TRUE;
            }
            else
            {
                hReturnCode = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
                goto done;
            }
        }
        else
        {
            // if setupx lib is not initialized yet, just use GetPrivateProfileString
            dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPX;
            bLocalAssignSetupEng = TRUE;
        }
    }

    // initial to NULL in the case of error, otherwise
    if ( ppszBuffer )
        *ppszBuffer = NULL;

    pszPreTranslated = (PSTR) LocalAlloc( LPTR, dwPreTranslatedSize );
    pszPostTranslated = (PSTR) LocalAlloc( LPTR, dwPostTranslatedSize );

    if ( !pszPreTranslated || !pszPostTranslated ) {
        hReturnCode = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    if ( ctx.dwSetupEngine == ENGINE_SETUPX )
    {
        // BUGBUG:  Should automagically change buffer size until we get a big
        // enough buffer to hold the full section.

        // BUGBUG:  For setupx engine, we don't support the multiple-inf line reading for the new
        // advance INF options.  In most case, there is no need for that.  If really need, set
        // RequireEngine=SETUPAPI,"string"

        dwRequiredSize = RO_GetPrivateProfileSection( c_pszTranslateSection, pszPreTranslated,
                                                      dwPreTranslatedSize, c_pszInfFilename );

        if ( dwRequiredSize == dwPreTranslatedSize - 2 ) {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, c_pszTranslateSection );
            hReturnCode = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto done;
        }

        pszPoint = pszPreTranslated;

        while ( *pszPoint == ';' ) {
            pszPoint += lstrlen(pszPoint) + 1;
        }

        for ( i = 0; i < dwIndex; i += 1 ) {
            pszPoint += lstrlen(pszPoint) + 1;

            if ( *pszPoint == '\0' ) {
                hReturnCode = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
                goto done;
            }

            while ( *pszPoint == ';' ) {
                pszPoint += lstrlen(pszPoint) + 1;
            }
        }

        if ( *pszPoint == '\0' ) {
            hReturnCode = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            goto done;
        }

        if ( ctx.hSetupLibrary )
        {
            if ( ! pfGenFormStrWithoutPlaceHolders32( pszPostTranslated, pszPoint,
                                                      (PSTR) c_pszInfFilename ) )
            {
                hReturnCode = E_UNEXPECTED;
                goto done;
            }
        }
        else
            FormStrWithoutPlaceHolders( pszPoint, pszPostTranslated, dwPostTranslatedSize, (PSTR) c_pszInfFilename );

        // strip out the double quotes
        pszPoint = pszPostTranslated;
        pszPostTranslated = GetStringField( &pszPoint, "\0", '\"', TRUE );
        dwRequiredSize = lstrlen( pszPostTranslated ) + 1;
    }
    else
    {
        hReturnCode = MySetupGetLineByIndex( c_pszTranslateSection, dwIndex,
                                             pszPostTranslated, dwPostTranslatedSize,
                                             &dwRequiredSize );
        
        if (FAILED(hReturnCode) && HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hReturnCode)
        {
            // resize buffer and retry.
            LocalFree(pszPostTranslated);
            pszPostTranslated = LocalAlloc(LPTR, dwRequiredSize);
            dwPostTranslatedSize = dwRequiredSize;
            if ( !pszPostTranslated ) {
                hReturnCode = HRESULT_FROM_WIN32(GetLastError());
                goto done;
            }

            hReturnCode = MySetupGetLineByIndex( c_pszTranslateSection, dwIndex,
                                             pszPostTranslated, dwPostTranslatedSize,
                                             &dwRequiredSize );
        }

        if ( FAILED(hReturnCode) ) {
            goto done;
        }
    }

    // if NULL, return only size
    //
    if ( !ppszBuffer )
    {
        LocalFree( pszPostTranslated );
    }
    else
    {
        // this buffer has to be released by the caller!!
        //
        *ppszBuffer = (LPSTR)LocalReAlloc( pszPostTranslated, (lstrlen(pszPostTranslated)+1), LMEM_MOVEABLE );
        if ( !*ppszBuffer )
            *ppszBuffer = pszPostTranslated;
    }

done:
    //if (bLocalInitSetupapi)
    //{
        // uninitialize setupapi
        //CommonInstallCleanup();
    //}

    if (bLocalAssignSetupEng)
        ctx.dwSetupEngine = dwSaveSetupEngine;

    if ( pdwRequiredSize ) {
        *pdwRequiredSize = dwRequiredSize;
    }

    if ( pszPreTranslated != NULL ) {
        LocalFree( pszPreTranslated );
    }

    if ( FAILED(hReturnCode) && (pszPostTranslated != NULL) )
    {
        if (ppszBuffer)
            *ppszBuffer = NULL;
        LocalFree( pszPostTranslated );
    }

    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetTranslatedSection                                        *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
DWORD GetTranslatedSection(PCSTR c_pszInfFilename, PCSTR c_pszTranslateSection,
                               PSTR pszBuffer, DWORD dwBufSize )
{
    CHAR    szPreTranslated[MAX_INFLINE];
    DWORD   dwSize = 0;
    //BOOL    bLocalInitSetupapi = FALSE,
	BOOL	bLocalAssignSetupEng = FALSE;
    DWORD   dwSaveSetupEngine;

    // since we are no using GetPrivateProfileString anymore if setupapi present
    // there are times this function called and setupapi.dll is not loaded yet.
    // so we need to check on in and initalize it if it is necessary
    if (ctx.hSetupLibrary==NULL)
    {
        if (CheckOSVersion() && (ctx.wOSVer != _OSVER_WIN95))
        {
			// To avoid multiple times load and unload the NT setupapi DLLs
			// On NT, we are not unload the setuplib unless the INF engine need to be
			// updated.
			//

            //dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPAPI;
            //bLocalAssignSetupEng = TRUE;
            if (InitializeSetupAPI())
            {
                if (FAILED(MySetupOpenInfFile(c_pszInfFilename)))
                {
                    //UnloadSetupLib();
                    goto done;
                }
                //bLocalInitSetupapi = TRUE;
            }
            else
            {
                goto done;
            }
        }
        else
        {
            // if setupx lib is not initialized yet, just use GetPrivateProfileString
            dwSaveSetupEngine = ctx.dwSetupEngine;
            ctx.dwSetupEngine = ENGINE_SETUPX;
            bLocalAssignSetupEng = TRUE;
        }
    }

    if ( ctx.dwSetupEngine == ENGINE_SETUPX )
    {
        dwSize = RO_GetPrivateProfileSection( c_pszTranslateSection, pszBuffer,
                                              dwBufSize, c_pszInfFilename );

        if ( dwSize == dwBufSize - 2 )
        {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, c_pszTranslateSection );
            goto done;
        }
    }
    else
    {
        int i, len;
        LPSTR pszTmp, pszStart;
        DWORD dwReqSize;
        char szBuf[MAX_INFLINE];

        pszStart = pszBuffer;
        *pszStart = '\0';

        for (i=0; ; i++)
        {
            // if key does not contain ',', setupapi's SetupGetLineText only return the value part
            // we need to get the corespondent key part to makeup the whole line text
            dwReqSize = 0;
            if (SUCCEEDED(MySetupGetStringField(c_pszTranslateSection, i, 0, szBuf,
                                                sizeof(szBuf), &dwReqSize)) && dwReqSize)
            {
                dwReqSize = 0;
                if ( SUCCEEDED(MySetupGetLineText( c_pszTranslateSection, szBuf, szPreTranslated,
                                                sizeof(szPreTranslated), &dwReqSize )) && dwReqSize)
                {
                    // got the key, so the line must be in the form A=B  or Just A forms, no comma.
                    lstrcat(szBuf, "=");
                    lstrcat(szBuf, szPreTranslated);
                }
            }
            else
            {
                // expect the line in the forms of A,B,C=B  or just A,B,C
                if ( FAILED(MySetupGetLineByIndex(c_pszTranslateSection, i,
                                                   szPreTranslated, sizeof(szPreTranslated),
                                                   &dwReqSize )))
                {
                    // should not be here since you are here, the line must have commas or no '='
                    break;
                }

                lstrcpy(szBuf, szPreTranslated);
            }

            len = lstrlen(szBuf)+1;
            if ((dwSize + len) < dwBufSize)
            {
                lstrcpy(pszStart, szBuf);
                pszStart += len;
                dwSize += len;
            }
            else
            {
                dwSize = dwBufSize - 2;
                break;
            }
        }

        if (pszStart > pszBuffer)
            *pszStart = '\0';
        else if (pszStart == pszBuffer)
            *(pszStart+1) = '\0';
    }

done:
    //if (bLocalInitSetupapi)
    //{
        // uninitialize setupapi
        //CommonInstallCleanup();
    //}

    if (bLocalAssignSetupEng)
        ctx.dwSetupEngine = dwSaveSetupEngine;

    return dwSize;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MyNTReboot                                                  *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL MyNTReboot( VOID )
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tkp;

    // get a token from this process
    if ( !OpenProcessToken( GetCurrentProcess(),
                            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) )
    {
        ErrorMsg( NULL, IDS_ERR_OPENPROCTK );
        return FALSE;
    }

    // get the LUID for the shutdown privilege
    LookupPrivilegeValue( NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid );

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //get the shutdown privilege for this proces
    if ( !AdjustTokenPrivileges( hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0 ) )
    {
        ErrorMsg( NULL, IDS_ERR_ADJTKPRIV );
        return FALSE;
    }

    // shutdown the system and force all applications to close
    if (!ExitWindowsEx( EWX_REBOOT, 0 ) )
    {
        ErrorMsg( NULL, IDS_ERR_EXITWINEX );
        return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetStringField                                              *
//*                                                                         *
//* SYNOPSIS:   Gets a field (separated with certain characters).           *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
PSTR GetStringField( PSTR *ppszString, PCSTR c_pszSeparators, CHAR chQuoteToCheck, BOOL bStripWhiteSpace)
{
    PSTR pszInternalString;
    PSTR pszPoint = NULL;
    BOOL fWithinQuotes = FALSE;
    CHAR ch1, chQuote = 0;
    PSTR pszTmp;

    pszInternalString = *ppszString;

    if ( pszInternalString == NULL )
    {
        return NULL;
    }

    pszPoint = pszInternalString;
    while ( 1 )
    {
        ch1 = *pszInternalString;

        if ( ch1 == chQuoteToCheck )
        {
            pszTmp = CharNext( pszInternalString );
            if ( chQuote == 0 )
            {
                // the first one
                chQuote = ch1;
                fWithinQuotes = !(fWithinQuotes);
                // strip out this quote
                MoveMemory( pszInternalString, pszTmp, lstrlen(pszTmp)+1 );
                if ( *pszInternalString == chQuote )
                    continue;
            }
            else if ( chQuote == ch1 )
            {
                if ( *pszTmp == ch1 )
                {
                    PSTR ptmp = CharNext( pszTmp );
                    // dest, src, count include terminate null char.
                    MoveMemory( pszTmp, ptmp, lstrlen(ptmp)+1 );
                }
                else
                {
                    fWithinQuotes = !(fWithinQuotes);
                    chQuote = 0;
                    MoveMemory( pszInternalString, pszTmp, lstrlen(pszTmp)+1 );
                }
            }
        }

        if ( *pszInternalString == '\0' )
        {
            break;
        }

        if ( !fWithinQuotes && IsSeparator( *pszInternalString, (PSTR) c_pszSeparators ) )
        {
            break;
        }
        pszInternalString = CharNext(pszInternalString);
    }

    if ( *pszInternalString == '\0' )
    {
        pszInternalString = NULL;
    }
    else
    {
       *pszInternalString = '\0';
        pszInternalString += 1;
    }

    if ( bStripWhiteSpace )
        pszPoint = StripWhitespace( pszPoint );

    *ppszString = pszInternalString;
    return pszPoint;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetStringFieldNoQuote                                       *
//*                                                                         *
//* SYNOPSIS:   Gets a field (separated with certain characters).           *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
LPSTR GetStringFieldNoQuote( PSTR *ppszString, PCSTR c_pszSeparators, BOOL bStripWhiteSpace)
{
    LPSTR pszInternalString;
    LPSTR pszPoint = NULL;

    pszInternalString = *ppszString;
    if ( pszInternalString == NULL )
    {
        return NULL;
    }

    pszPoint = pszInternalString;
    while ( *pszInternalString )
    {
        if ( IsSeparator( *pszInternalString, c_pszSeparators ) )
        {
            break;
        }
        pszInternalString = CharNext(pszInternalString);
    }

    if ( *pszInternalString == '\0' )
    {
        pszInternalString = NULL;
    }
    else
    {
       *pszInternalString = '\0';
        pszInternalString += 1;
    }

    if ( bStripWhiteSpace )
        pszPoint = StripWhitespace( pszPoint );

    *ppszString = pszInternalString;
    return pszPoint;
}

//***************************************************************************
//*                                                                         *
//* NAME:       IsSeparator                                                 *
//*                                                                         *
//* SYNOPSIS:   Returns TRUE if the character is in the string. Else FALSE. *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL IsSeparator( CHAR chChar, PCSTR pszSeparators )
{
    if ( chChar == '\0' || pszSeparators == NULL ) {
        return FALSE;
    }

    while ( *pszSeparators != chChar ) {
        if ( *pszSeparators == '\0' ) {
            return FALSE;
        }

        pszSeparators += 1;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       StripWhitespace                                             *
//*                                                                         *
//* SYNOPSIS:   Strips spaces and tabs from both sides of given string.     *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
PSTR StripWhitespace( PSTR pszString )
{
    PSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlen(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}

//***************************************************************************
//*                                                                         *
//* NAME:       StripQuotes                                                 *
//*                                                                         *
//* SYNOPSIS:   Strips quotes from both sides of given string.              *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
#if 0
PSTR StripQuotes( PSTR pszString )
{
    PSTR pszTemp = NULL;
    CHAR chQuote;

    if ( pszString == NULL )
    {
        return NULL;
    }

    ch = *pszString;
    if ( ch == '"' || ch == '\'' )
    {
        pszTemp = pszString + 1;
    }
    else
    {
        return pszString;
    }

    pszString += lstrlen(pszString) - 1;

    if ( *pszString == ch )
    {
        *pszString = '\0';
    }
    else
    {
        pszTemp--;
    }

    return pszTemp;
}

#endif
//***************************************************************************
//*                                                                         *
//* NAME:       IsGoodAdvancedInfVersion                                    *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL IsGoodAdvancedInfVersion( PCSTR c_pszInfFilename )
{
    static const CHAR c_szSection[] = "Version";
    static const CHAR c_szKey[] = "AdvancedINF";
    PSTR pszVersionData = NULL;
    PSTR pszMajorVersion = NULL;
    PSTR pszMinorVersion = NULL;
    DWORD dwRequiredSize;
    DWORD dwSize;
    PSTR pszVersion = NULL;
    PSTR pszErrorMsg = NULL;
    DWORD dwVersion = 0;
    BOOL fSuccess = TRUE;
    PSTR pszTmp;

    if ( FAILED( GetTranslatedString( c_pszInfFilename, c_szSection, c_szKey, pszVersionData,
                                      0, &dwRequiredSize ) ) )
    {
        // We return TRUE because even though they didn't specify a version, I still
        // want to process the INF file.
        fSuccess = TRUE;
        goto done;
    }

    pszVersionData = (PSTR) LocalAlloc( LPTR, dwRequiredSize );
    if ( !pszVersionData ) {
        ErrorMsg( ctx.hWnd, IDS_ERR_NO_MEMORY );
        fSuccess = FALSE;
        goto done;
    }

    if ( FAILED( GetTranslatedString( c_pszInfFilename, c_szSection, c_szKey,
                                      pszVersionData, dwRequiredSize, &dwSize ) ) )
    {
        // This guy should never fail because the call above didn't fail.
        fSuccess = FALSE;
        goto done;
    }

    pszTmp = pszVersionData;
    // Parse the arguments, SETUP engine has processed \" so we only need to check on \'
    pszVersion = GetStringField( &pszTmp, ",", '\'', TRUE );
    pszErrorMsg = GetStringField( &pszTmp, ",", '\'', TRUE );

    if ( pszVersion == NULL || *pszVersion == '\0' ) {
        // If they don't specify a version, process the INF file anyway
        fSuccess = TRUE;
        goto done;
    }

    // Parse the arguments, SETUP engine has processed \" so we only need to check on \'
    pszTmp = pszVersion;
    pszMajorVersion = GetStringField( &pszTmp, ".", '\'', TRUE );
    pszMinorVersion = GetStringField( &pszTmp, ".", '\'', TRUE );

    if ( pszMajorVersion == NULL || pszMajorVersion == '\0' ) {
        fSuccess = TRUE;
        goto done;
    }

    dwVersion = ((DWORD) My_atol(pszMajorVersion)) * 100;

    if ( pszMinorVersion != NULL ) {
    	dwVersion += (DWORD) My_atol(pszMinorVersion);
    }

    if ( dwVersion > ADVPACK_VERSION ) {
        fSuccess = FALSE;
        if ( pszErrorMsg != NULL && *pszErrorMsg != '\0' ) {
            ErrorMsg1Param( ctx.hWnd, IDS_PROMPT, pszErrorMsg );
            AdvWriteToLog("Advpack.dll Version check failed! InfFile=%1\r\n", c_pszInfFilename);

        }
        goto done;
    }

  done:

    if ( pszVersionData ) {
        LocalFree( pszVersionData );
    }

    return fSuccess;
}


//***************************************************************************
//*                                                                         *
//* NAME:       SelectSetupEngine                                           *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL SelectSetupEngine( PCSTR c_pszInfFilename, PCSTR c_pszSection, DWORD dwFlags )
{
    static const CHAR c_szKey[] = "RequiredEngine";
    static const CHAR c_szSetupX[] = "SETUPX";
    static const CHAR c_szSetupAPI[] = "SETUPAPI";
    PSTR  pszEngine = NULL;
    PSTR  pszErrorMsg = NULL;
    BOOL  fSuccess = TRUE;
    PSTR  pszDll = NULL;
    PSTR  pszFilePart = NULL;
    CHAR szBuffer[MAX_PATH];
    CHAR szEngineData[2048];
    PSTR pszStr;
    BOOL bMustSetupapi = FALSE;

    if ( (dwFlags & COREINSTALL_BKINSTALL) || (dwFlags & COREINSTALL_ROLLBACK) ||
         (dwFlags & COREINSTALL_REBOOTCHECKONINSTALL) || (dwFlags & COREINSTALL_SETUPAPI)||(ctx.wOSVer != _OSVER_WIN95))
    {
        ctx.dwSetupEngine = ENGINE_SETUPAPI;
        bMustSetupapi = TRUE;
        if (ctx.wOSVer != _OSVER_WIN95)
            goto done;
    }
    else
    {
        ctx.dwSetupEngine = ENGINE_SETUPX;
    }


    if (FAILED(GetTranslatedString(c_pszInfFilename, c_pszSection, c_szKey,
                                    szEngineData, sizeof(szEngineData), NULL)))
    {
        fSuccess = TRUE;
        goto done;
    }

    // Parse the arguments, SETUP engine is NOT called. So we need to check on \"
    pszStr = szEngineData;
    pszEngine = GetStringField( &pszStr, ",", '\"', TRUE );
    pszErrorMsg = GetStringField( &pszStr, ",", '\"', TRUE );

    if ( pszEngine == NULL || *pszEngine == '\0' ) {
        // If they don't specify an engine, process the INF file anyway
        fSuccess = TRUE;
        goto done;
    }


    if ( !bMustSetupapi && (lstrcmpi( pszEngine, c_szSetupX ) == 0) ) {
        pszDll = W95INF32DLL;
        ctx.dwSetupEngine = ENGINE_SETUPX;
    } else {
        pszDll = SETUPAPIDLL;
        ctx.dwSetupEngine = ENGINE_SETUPAPI;
    }

    // only if you don't have the INF engine file and you don't have the UpdateINFEngine On, error out
    if (!SearchPath( NULL, pszDll, NULL, sizeof(szBuffer), szBuffer, &pszFilePart ) &&
        (GetTranslatedInt(c_pszInfFilename, c_pszSection, ADVINF_UPDINFENG, 0)==0))
    {
        fSuccess = FALSE;
        if ( pszErrorMsg != NULL && *pszErrorMsg != '\0' )
        {
            ErrorMsg1Param( ctx.hWnd, IDS_PROMPT, pszErrorMsg );
        }
        else
            ErrorMsg1Param( NULL, IDS_ERR_LOAD_DLL, SETUPAPIDLL );
    }

done:

    return fSuccess;
}


//***************************************************************************
//*                                                                         *
//* NAME:       BeginPrompt                                                 *
//*                                                                         *
//* SYNOPSIS:   Displays beginning (confirmation) prompt.                   *
//*									                                        *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
INT BeginPrompt( PCSTR c_pszInfFilename, PCSTR c_pszSection, PSTR pszTitle, DWORD dwTitleSize )
{
    static const CHAR c_szBeginPromptKey[] = "BeginPrompt";
    static const CHAR c_szPromptKey[]      = "Prompt";
    static const CHAR c_szButtonTypeKey[]  = "ButtonType";
    static const CHAR c_szTitleKey[]       = "Title";
    static const CHAR c_szButtonYesNo[]    = "YESNO";
    CHAR szBeginPromptSection[256];
    PSTR  pszPrompt = NULL;
    DWORD dwPromptSize = 2048;
    INT   nReturnCode = 0;
    CHAR szButtonType[128];
    UINT  nButtons = 0;
    DWORD dwSize;


    if ( FAILED( GetTranslatedString( c_pszInfFilename, c_pszSection, c_szBeginPromptKey,
                                      szBeginPromptSection, sizeof(szBeginPromptSection), &dwSize ) ) )
    {
        nReturnCode = IDOK;
        goto done;
    }

    if ( ! FAILED( GetTranslatedString( c_pszInfFilename, szBeginPromptSection, c_szTitleKey,
                                        pszTitle, dwTitleSize, &dwSize ) ) )
    {
        ctx.lpszTitle = pszTitle;
    }

    pszPrompt = (PSTR) LocalAlloc( LPTR, dwPromptSize );
    if ( ! pszPrompt ) {
        ErrorMsg( ctx.hWnd, IDS_ERR_NO_MEMORY );
        nReturnCode = IDCANCEL;
        goto done;
    }

    if ( FAILED( GetTranslatedString( c_pszInfFilename, szBeginPromptSection, c_szPromptKey,
                                      pszPrompt, dwPromptSize, &dwSize ) ) )
    {
        nReturnCode = IDOK;
        goto done;
    }

    GetTranslatedString( c_pszInfFilename, szBeginPromptSection, c_szButtonTypeKey,
                         szButtonType, sizeof(szButtonType), &dwSize );

    if ( lstrcmpi( szButtonType, c_szButtonYesNo ) == 0 ) {
        nButtons = MB_YESNO;
    } else {
        nButtons = MB_OKCANCEL;
    }

    nReturnCode = MsgBox1Param( ctx.hWnd, IDS_PROMPT, pszPrompt, MB_ICONQUESTION, nButtons | MB_DEFBUTTON2 );
    if ( nReturnCode == 0 ) {
        ErrorMsg( ctx.hWnd, IDS_ERR_NO_MEMORY );
        nReturnCode = IDCANCEL;
        goto done;
    }

  done:

    if ( pszPrompt ) {
        LocalFree( pszPrompt );
    }

    // Map all cancel buttons to IDCANCEL
    if ( nReturnCode == IDNO ) {
        nReturnCode = IDCANCEL;
    }

    return nReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       EndPrompt                                                   *
//*                                                                         *
//* SYNOPSIS:   Displays end prompt.                                        *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
VOID EndPrompt( PCSTR c_pszInfFilename, PCSTR c_pszSection )
{
    static const CHAR c_szEndPromptKey[] = "EndPrompt";
    static const CHAR c_szPromptKey[] = "Prompt";
    CHAR szEndPromptSection[256];
    PSTR  pszPrompt = NULL;
    DWORD dwPromptSize = 2048;
    DWORD dwSize = 0;

    if ( FAILED( GetTranslatedString( c_pszInfFilename, c_pszSection, c_szEndPromptKey,
                                      szEndPromptSection, sizeof(szEndPromptSection), &dwSize ) ) )
    {
        goto done;
    }

    pszPrompt = (PSTR) LocalAlloc( LPTR, dwPromptSize );
    if ( ! pszPrompt ) {
        goto done;
    }

    if ( FAILED( GetTranslatedString( c_pszInfFilename, szEndPromptSection, c_szPromptKey,
                                      pszPrompt, dwPromptSize, &dwSize ) ) )
    {
        goto done;
    }

    MsgBox1Param( ctx.hWnd, IDS_PROMPT, pszPrompt, MB_ICONINFORMATION, MB_OK );

  done:

    if ( pszPrompt ) {
        LocalFree( pszPrompt );
    }

    return;
}

//***************************************************************************
//*                                                                         *
//* NAME:       MyGetPrivateProfileString                                   *
//*                                                                         *
//* SYNOPSIS:   Gets string from INF file.  TRUE if success, else FALSE.    *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL MyGetPrivateProfileString( PCSTR c_pszInfFilename, PCSTR c_pszSection,
                                PCSTR c_pszKey, PSTR pszBuffer, DWORD dwBufferSize )
{
    DWORD dwSize = 0;
    static const CHAR c_szDefault[] = "ZzZzZzZz";

    dwSize = GetPrivateProfileString( c_pszSection, c_pszKey, c_szDefault,
                                      pszBuffer, dwBufferSize,
                                      c_pszInfFilename );
    if ( dwSize == (dwBufferSize - 1)
        || lstrcmp( pszBuffer, c_szDefault ) == 0 )
    {
        return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       InitializeSetupAPI                                          *
//*                                                                         *
//* SYNOPSIS:   Load the proper setup library and functions (for Win95)     *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL InitializeSetupAPI()
{
	if ( ctx.hSetupLibrary == NULL )
	{
		ctx.hSetupLibrary = MyLoadLibrary( SETUPAPIDLL );
		if ( ctx.hSetupLibrary == NULL )
		{
			ErrorMsg1Param( NULL, IDS_ERR_LOAD_DLL, SETUPAPIDLL );
			return FALSE;
		}

		if ( ! LoadSetupAPIFuncs() )
		{
			ErrorMsg( NULL, IDS_ERR_GET_PROC_ADDR );
			FreeLibrary( ctx.hSetupLibrary );
			ctx.hSetupLibrary = NULL;
			return FALSE;
		}
	}
	return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       LoadSetupLib                                                *
//*                                                                         *
//* SYNOPSIS:   Load the proper setup library and functions (for Win95)     *
//*                                                                         *
//* REQUIRES:   CheckOSV                                                    *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL LoadSetupLib( PCSTR c_pszInfFilename, PCSTR c_pszSection, BOOL fUpdDlls, DWORD dwFlags )
{
    MSG tmpmsg;

    if ( ! SelectSetupEngine( c_pszInfFilename, c_pszSection, dwFlags) ) {
        return FALSE;
    }

    // update the advpack.dll etc if needed
    if ( fUpdDlls && (ctx.wOSVer < _OSVER_WINNT50) && !RunningOnMillennium())
    {
        if (!UpdateHelpDlls( c_szAdvDlls, ((ctx.wOSVer ==_OSVER_WIN95)?3:1), NULL, "Advpack",
                                      (ctx.bUpdHlpDlls?UPDHLPDLLS_FORCED:0) ) )
        {
            return FALSE;
        }
    }

    // update INF Engine dlls if needed
    if ( GetTranslatedInt(c_pszInfFilename, c_pszSection, ADVINF_UPDINFENG, 0) )
    {
        char szSrcPath[MAX_PATH];

        lstrcpy(szSrcPath, c_pszInfFilename);
        GetParentDir(szSrcPath);
        if (ctx.dwSetupEngine == ENGINE_SETUPAPI)
        {
			// setupapi.dll may be loaded.  So free it up before update
			//
			CommonInstallCleanup();
            if (!UpdateHelpDlls(c_szSetupAPIDlls, 2, szSrcPath, "SetupAPI",
                                UPDHLPDLLS_FORCED|UPDHLPDLLS_ALERTREBOOT) )
            {
                return FALSE;
            }
        }
        else
        {
            if (!UpdateHelpDlls(c_szSetupXDlls, 1, szSrcPath, "SetupX",
                                UPDHLPDLLS_FORCED|UPDHLPDLLS_ALERTREBOOT) )
            {
                return FALSE;
            }
        }
    }

    // Under Win95 load W95INF32.DLL to thunk down to 16-bit land.
    // Under WinNT load SETUPAPI.DLL and call in directly.
    if ( ctx.dwSetupEngine == ENGINE_SETUPX )
    {
        ctx.hSetupLibrary = MyLoadLibrary( W95INF32DLL );
        if ( ctx.hSetupLibrary == NULL ) {
            ErrorMsg1Param( NULL, IDS_ERR_LOAD_DLL, W95INF32DLL );
            return FALSE;
        }

        pfCtlSetLddPath32                 = (CTLSETLDDPATH32) GetProcAddress( ctx.hSetupLibrary, achCTLSETLDDPATH32 );
        pfGenInstall32                    = (GENINSTALL32) GetProcAddress( ctx.hSetupLibrary, achGENINSTALL32 );
        pfGetSETUPXErrorText32            = (GETSETUPXERRORTEXT32) GetProcAddress( ctx.hSetupLibrary, achGETSETUPXERRORTEXT32 );
        pfGenFormStrWithoutPlaceHolders32 = (GENFORMSTRWITHOUTPLACEHOLDERS32) GetProcAddress( ctx.hSetupLibrary, achGENFORMSTRWITHOUTPLACEHOLDERS32 );

        if (    pfCtlSetLddPath32 == NULL
             || pfGenInstall32 == NULL
             || pfGetSETUPXErrorText32 == NULL
             || pfGenFormStrWithoutPlaceHolders32 == NULL )
        {
            ErrorMsg( NULL, IDS_ERR_GET_PROC_ADDR );
            FreeLibrary( ctx.hSetupLibrary );
			ctx.hSetupLibrary = NULL;
            return FALSE;
        }
    }
    else
    {
        if (!InitializeSetupAPI())
            return FALSE;

        // BUGBUG: HACK: On NT if we are kicking off setupapi in silent mode,
        // it hangs in a GetMessage() call. This is probably because the corr.
        // PostThreadMessage() that ted posts fails because no Message Queue has
        // been created. The following call should create a queue. Till Ted
        // fixes SETUPAPI.DLL, I have added thsi hack!!!
        //
        PeekMessage(&tmpmsg, NULL, 0, 0, PM_NOREMOVE) ;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       UnloadSetupLib                                              *
//*                                                                         *
//* SYNOPSIS:   Load the proper setup library and functions (for Win95)     *
//*                                                                         *
//* REQUIRES:   CheckOSV                                                    *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
VOID UnloadSetupLib( VOID )
{
    if ( ctx.hSetupLibrary != NULL )
	{
        FreeLibrary( ctx.hSetupLibrary );
        ctx.hSetupLibrary = NULL;
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       CheckOSVersion                                              *
//*                                                                         *
//* SYNOPSIS:   Checks the OS version and sets some global variables.       *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if successful, FALSE otherwise.        *
//*                                                                         *
//***************************************************************************
BOOL CheckOSVersion( VOID )
{
    OSVERSIONINFO verinfo;        // Version Check

    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( GetVersionEx( &verinfo ) == FALSE )
    {
        ErrorMsg( ctx.hWnd, IDS_ERR_OS_VERSION );
        return FALSE;
    }

    switch( verinfo.dwPlatformId )
    {
        case VER_PLATFORM_WIN32_WINDOWS: // Win95
            ctx.wOSVer = _OSVER_WIN95;
            ctx.fOSSupportsINFInstalls = TRUE;
            return TRUE;

        case VER_PLATFORM_WIN32_NT: // Win NT
            ctx.fOSSupportsINFInstalls = TRUE;
            ctx.wOSVer = _OSVER_WINNT40;

            if ( verinfo.dwMajorVersion <= 3 )
            {
                ctx.wOSVer = _OSVER_WINNT3X;
                if ( (verinfo.dwMajorVersion < 3) ||
                     ((verinfo.dwMajorVersion == 3) && (verinfo.dwMinorVersion < 51 )) )
                {
                    // Reject for INF installs and Reject for animations
                    ctx.fOSSupportsINFInstalls = FALSE;
                }
            }
            else if ( verinfo.dwMajorVersion == 5  && 
                      verinfo.dwMinorVersion == 0) 
            {
                    ctx.wOSVer = _OSVER_WINNT50;
            }
            else if ( (verinfo.dwMajorVersion == 5  && 
                       verinfo.dwMinorVersion > 0) || 
                      verinfo.dwMajorVersion > 5)
                ctx.wOSVer = _OSVER_WINNT51;

            return TRUE;

        default:
            ErrorMsg( ctx.hWnd, IDS_ERR_OS_UNSUPPORTED );
            return FALSE;
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       MsgBox2Param                                                *
//*                                                                         *
//* SYNOPSIS:   Displays a message box with the specified string ID using   *
//*             2 string parameters.                                        *
//*                                                                         *
//* REQUIRES:   hWnd:           Parent window                               *
//*             nMsgID:         String resource ID                          *
//*             szParam1:       Parameter 1 (or NULL)                       *
//*             szParam2:       Parameter 2 (or NULL)                       *
//*             uIcon:          Icon to display (or 0)                      *
//*             uButtons:       Buttons to display                          *
//*                                                                         *
//* RETURNS:    INT:            ID of button pressed                        *
//*                                                                         *
//* NOTES:      Macros are provided for displaying 1 parameter or 0         *
//*             parameter message boxes.  Also see ErrorMsg() macros.       *
//*                                                                         *
//***************************************************************************
INT MsgBox2Param( HWND hWnd, UINT nMsgID, LPCSTR szParam1, LPCSTR szParam2,
		  UINT uIcon, UINT uButtons )
{
    CHAR achMsgBuf[BIG_STRING];
    CHAR szTitle[MAX_PATH];
    LPSTR szMessage = NULL;
    LPSTR pszTitle;
    INT   nReturn;
    CHAR achError[] = "Unexpected Error.  Could not load resource.";
    LPSTR aszParams[2];

    // BUGBUG: quiet mode return code should be caller's param passed in.
    // we may need to check on FormatMessage's return code and handle it in more completed fashion.
    //
    if ( (ctx.wQuietMode & QUIETMODE_SHOWMSG) || !(ctx.wQuietMode & QUIETMODE_ALL) )
    {
        aszParams[0] = (LPSTR) szParam1;
        aszParams[1] = (LPSTR) szParam2;

        LoadSz( nMsgID, achMsgBuf, sizeof(achMsgBuf) );

        if ( (*achMsgBuf) == '\0' ) {
            lstrcpy( achMsgBuf, achError );
        }

        if ( FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY
                          | FORMAT_MESSAGE_ALLOCATE_BUFFER, achMsgBuf, 0, 0, (LPSTR) (&szMessage),
                            0, (va_list *)aszParams ) )
        {
            MessageBeep( uIcon );

            if ( ctx.lpszTitle == NULL )
            {
                LoadSz( IDS_ADVDEFTITLE, szTitle, sizeof(szTitle) );
                if ( szTitle[0] == '\0' )
                {
                    lstrcpy( szTitle, achError );
                }
                pszTitle = szTitle;
            }
            else
                pszTitle = ctx.lpszTitle;

            nReturn = MessageBox( hWnd, szMessage, pszTitle, uIcon |
                                  uButtons | MB_APPLMODAL | MB_SETFOREGROUND | 
                                  ((RunningOnWin95BiDiLoc() && IsBiDiLocalizedBinary(g_hInst,RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO))) ? (MB_RIGHT | MB_RTLREADING) : 0) );

            LocalFree( szMessage );
        }

        return nReturn;
    }
    else
        return IDOK;
}

//***************************************************************************
//*                                                                         *
//* NAME:       LoadSz                                                      *
//*                                                                         *
//* SYNOPSIS:   Loads specified string resource into buffer.                *
//*                                                                         *
//* REQUIRES:   idString:                                                   *
//*             lpszBuf:                                                    *
//*             cbBuf:                                                      *
//*                                                                         *
//* RETURNS:    LPSTR:     Pointer to the passed-in buffer.                 *
//*                                                                         *
//* NOTES:      If this function fails (most likely due to low memory), the *
//*             returned buffer will have a leading NULL so it is generally *
//*             safe to use this without checking for failure.              *
//*                                                                         *
//***************************************************************************
LPSTR LoadSz( UINT idString, LPSTR lpszBuf, UINT cbBuf )
{
    ASSERT( lpszBuf );

    // Clear the buffer and load the string
    if ( lpszBuf ) {
        *lpszBuf = '\0';
        LoadString( g_hInst, idString, lpszBuf, cbBuf );
    }

    return lpszBuf;
}


//***************************************************************************
//*                                                                         *
//* NAME:       UserDirPrompt                                               *
//*                                                                         *
//* SYNOPSIS:   Pops up a dialog to ask the user for a directory.           *
//*                                                                         *
//* REQUIRES:   lpszPromptText: Prompt to display or if null, use next parm *
//*             uiPromptResID:  ID of string to display as prompt           *
//*             lpszDefault:    Default directory to put in edit box.       *
//*             lpszDestDir:    Buffer to store user selected directory     *
//*             cbDestDirSize:  Size of this buffer                         *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if everything went well, FALSE         *
//*                             if the user cancelled, or error.            *
//*                                                                         *
//***************************************************************************
BOOL UserDirPrompt( LPSTR lpszPromptText,
                    LPSTR lpszDefault, LPSTR lpszDestDir,
                    ULONG cbDestDirSize, DWORD dwInstNeedSize )
{
    BOOL        fDlgRC;
    DIRDLGPARMS DirDlgParms;

    DirDlgParms.lpszPromptText   = lpszPromptText;
    DirDlgParms.lpszDefault      = lpszDefault;
    DirDlgParms.lpszDestDir      = lpszDestDir;
    DirDlgParms.cbDestDirSize  = cbDestDirSize;
    DirDlgParms.dwInstNeedSize = dwInstNeedSize;

    SetControlFont();

    fDlgRC = (BOOL) DialogBoxParam( g_hInst, MAKEINTRESOURCE(IDD_DIRDLG),
                                    NULL, (DLGPROC) DirDlgProc,
                                    (LPARAM) &DirDlgParms );

    if (g_hFont)
    {
        DeleteObject(g_hFont);
        g_hFont = NULL;
    }

    return fDlgRC;
}


//***************************************************************************
//*                                                                         *
//* NAME:       DirDlgProc                                                  *
//*                                                                         *
//* SYNOPSIS:   Dialog Procedure for our dir dialog window.                 *
//*                                                                         *
//* REQUIRES:   hwndDlg:                                                    *
//*             uMsg:                                                       *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL CALLBACK DirDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam,
                          LPARAM lParam )
{
    static CHAR  achDir[MAX_PATH];
    static CHAR  achMsg[BIG_STRING];
    static LPSTR lpszDestDir;
    static LPSTR lpszDefaultDir;
    static ULONG  cbDestDirSize;
    static DWORD  dwInstNeedSize;

    switch (uMsg)  {

      //*********************************************************************
        case WM_INITDIALOG:
      //*********************************************************************
        {
            DIRDLGPARMS *DirDlgParms = (DIRDLGPARMS *) lParam;

            lpszDestDir = DirDlgParms->lpszDestDir;
            lpszDefaultDir = DirDlgParms->lpszDefault;
            cbDestDirSize = DirDlgParms->cbDestDirSize;
            dwInstNeedSize = DirDlgParms->dwInstNeedSize;

            CenterWindow( hwndDlg, GetDesktopWindow() );
            SetWindowText( hwndDlg, ctx.lpszTitle );


            if ( ! SetDlgItemText( hwndDlg, IDC_TEMPTEXT, DirDlgParms->lpszPromptText ) )
            {
                ErrorMsg( hwndDlg, IDS_ERR_UPDATE_DIR );
                EndDialog( hwndDlg, FALSE );
                return TRUE;
            }

            SetFontForControl(hwndDlg, IDC_EDIT_DIR);
            if ( ! SetDlgItemText( hwndDlg, IDC_EDIT_DIR, DirDlgParms->lpszDefault ) )
            {
                ErrorMsg( hwndDlg, IDS_ERR_UPDATE_DIR );
                EndDialog( hwndDlg, FALSE );
                return TRUE;
            }

            // limit edit control length
            SendDlgItemMessage( hwndDlg, IDC_EDIT_DIR, EM_SETLIMITTEXT, (MAX_PATH - 1), 0 );

            if ( ctx.wOSVer == _OSVER_WINNT3X ) {
                EnableWindow( GetDlgItem(  hwndDlg, IDC_BUT_BROWSE ), FALSE );
            }

            return TRUE;
        }


        //*********************************************************************
        case WM_CLOSE:
        //*********************************************************************

            EndDialog( hwndDlg, FALSE );
            return TRUE;


        //*********************************************************************
        case WM_COMMAND:
        //*********************************************************************

            switch ( wParam )
            {

            //*************************************************************
            case IDOK:
            //*************************************************************
            {
                DWORD dwAttribs = 0, dwTemp;

                // Read the user's entry. If it is different from the default 
                // and does not exist, prompt user. If user accepts
                // create it 

               if ( ! GetDlgItemText( hwndDlg, IDC_EDIT_DIR,
                            lpszDestDir, cbDestDirSize - 1 ) || !IsFullPath(lpszDestDir) )
                {
                    ErrorMsg( hwndDlg, IDS_ERR_EMPTY_DIR_FIELD );
                    return TRUE;
                }

                // check on the DestDir size if this is not UNC and this drive has not been checked
                if ( (*lpszDestDir != '\\' ) && !IsDrvChecked( *lpszDestDir ) )
                {
                    if ( !IsEnoughInstSpace( lpszDestDir, dwInstNeedSize, &dwTemp ) )
                    {
                        CHAR szSize[10];

                        if ( dwTemp )
                        {
                            wsprintf( szSize, "%lu", dwTemp );
                            if ( MsgBox1Param( hwndDlg, IDS_ERR_NO_SPACE_INST, szSize,
                                               MB_ICONQUESTION, MB_YESNO|MB_DEFBUTTON2 ) == IDNO )
                                return TRUE;
                        }
                        else // given drive cannot be checked, error has been posted.  no further needed
                            return TRUE;
                    }
                }

                dwAttribs = GetFileAttributes( lpszDestDir );
                if ( dwAttribs == 0xFFFFFFFF )
                {
                    // If this new entry is different from the original, then prompt the user.
                    if ((lstrcmpi(lpszDestDir, lpszDefaultDir) == 0) ||
                        MsgBox1Param( hwndDlg, IDS_CREATE_DIR, lpszDestDir, MB_ICONQUESTION, MB_YESNO )
                                    == IDYES )
                    {
                        if ( FAILED(CreateFullPath( lpszDestDir, FALSE )) )
                        {
                            ErrorMsg1Param( hwndDlg, IDS_ERR_CREATE_DIR, lpszDestDir );
                            return TRUE;
                        }
                    }
                    else
                    {
                        return TRUE;
                    }
                }

                if ( ! IsGoodDir( lpszDestDir ) )  {
                    ErrorMsg( hwndDlg, IDS_ERR_INVALID_DIR );
                    return TRUE;
                }

                EndDialog( hwndDlg, TRUE );

                return TRUE;
            }

            //*************************************************************
            case IDCANCEL:
            //*************************************************************

                EndDialog( hwndDlg, FALSE );
                return TRUE;


            //*************************************************************
            case IDC_BUT_BROWSE:
            //*************************************************************

                if ( LoadString( g_hInst, IDS_SELECTDIR, achMsg,
                                  sizeof(achMsg) ) == 0 )
                {
                    ErrorMsg( hwndDlg, IDS_ERR_NO_RESOURCE );
                    EndDialog( hwndDlg, FALSE );
                    return TRUE;
                }

                if ( ! BrowseForDir( hwndDlg, achMsg, achDir ) )  {
                    return TRUE;
                }

                if ( ! SetDlgItemText( hwndDlg, IDC_EDIT_DIR, achDir ) )
                {
                    ErrorMsg( hwndDlg, IDS_ERR_UPDATE_DIR );
                    EndDialog( hwndDlg, FALSE );
                    return TRUE;
                }

                return TRUE;
        }

        return TRUE;
    }

    return FALSE;
}


int CALLBACK BrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch(uMsg) {
        case BFFM_INITIALIZED:
            // lpData is the path string
            SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
            break;
    }
    return 0;
}


//***************************************************************************
//*                                                                         *
//* NAME:       BrowseForDir                                                *
//*                                                                         *
//* SYNOPSIS:   Let user browse for a directory on their system or network. *
//*                                                                         *
//* REQUIRES:   hwndParent:                                                 *
//*             szTitle:                                                    *
//*             szResult:                                                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//* NOTES:      It would be really cool to set the status line of the       *
//*             browse window to display "Yes, there's enough space", or    *
//*             "no there is not".                                          *
//*                                                                         *
//***************************************************************************
BOOL BrowseForDir( HWND hwndParent, LPCSTR szTitle, LPSTR szResult )
{
    BROWSEINFO   bi;
    LPITEMIDLIST pidl;
    HINSTANCE    hShell32Lib;
    SHFREE       pfSHFree;
    SHGETPATHFROMIDLIST        pfSHGetPathFromIDList;
    SHBROWSEFORFOLDER          pfSHBrowseForFolder;
    static const CHAR achShell32Lib[]                 = "SHELL32.DLL";
    static const CHAR achSHBrowseForFolder[]          = "SHBrowseForFolder";
    static const CHAR achSHGetPathFromIDList[]        = "SHGetPathFromIDList";

    ASSERT( szResult );

    // Load the Shell 32 Library to get the SHBrowseForFolder() features

    if ( ( hShell32Lib = LoadLibrary( achShell32Lib ) ) != NULL )  {

        if ( ( ! ( pfSHBrowseForFolder = (SHBROWSEFORFOLDER)
              GetProcAddress( hShell32Lib, achSHBrowseForFolder ) ) )
            || ( ! ( pfSHFree = (SHFREE) GetProcAddress( hShell32Lib,
              MAKEINTRESOURCE(SHFREE_ORDINAL) ) ) )
            || ( ! ( pfSHGetPathFromIDList = (SHGETPATHFROMIDLIST)
              GetProcAddress( hShell32Lib, achSHGetPathFromIDList ) ) ) )
        {
            FreeLibrary( hShell32Lib );
            ErrorMsg( hwndParent, IDS_ERR_LOADFUNCS );
            return FALSE;
        }
        } else  {
        ErrorMsg( hwndParent, IDS_ERR_LOADDLL );
        return FALSE;
    }

    if ( ! ctx.szBrowsePath[0] )
    {
        GetProgramFilesDir( ctx.szBrowsePath, sizeof(ctx.szBrowsePath) );
    }

    szResult[0]       = 0;

    bi.hwndOwner      = hwndParent;
    bi.pidlRoot       = NULL;
    bi.pszDisplayName = NULL;
    bi.lpszTitle      = szTitle;
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;
    bi.lpfn           = BrowseCallback;
    bi.lParam         = (LPARAM)ctx.szBrowsePath;

    pidl              = pfSHBrowseForFolder( &bi );


    if ( pidl )  {
        pfSHGetPathFromIDList( pidl, ctx.szBrowsePath );
        if ( ctx.szBrowsePath[0] )  {
            lstrcpy( szResult, ctx.szBrowsePath );
        }
        pfSHFree( pidl );
    }


    FreeLibrary( hShell32Lib );

    if ( szResult[0] != 0 ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

//***************************************************************************
//*                                                                         *
//* NAME:       CenterWindow                                                *
//*                                                                         *
//* SYNOPSIS:   Center one window within another.                           *
//*                                                                         *
//* REQUIRES:   hwndChild:                                                  *
//*             hWndParent:                                                 *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if successful, FALSE otherwise         *
//*                                                                         *
//***************************************************************************
BOOL CenterWindow( HWND hwndChild, HWND hwndParent )
{
    RECT rChild;
    RECT rParent;
    int  wChild;
    int  hChild;
    int  wParent;
    int  hParent;
    int  wScreen;
    int  hScreen;
    int  xNew;
    int  yNew;
    HDC  hdc;

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect (hwndParent, &rParent);
    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    hdc = GetDC (hwndChild);
    wScreen = GetDeviceCaps (hdc, HORZRES);
    hScreen = GetDeviceCaps (hdc, VERTRES);
    ReleaseDC (hwndChild, hdc);

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0) {
        xNew = 0;
    } else if ((xNew+wChild) > wScreen) {
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0) {
        yNew = 0;
    } else if ((yNew+hChild) > hScreen) {
        yNew = hScreen - hChild;
    }

    // Set it, and return
    return( SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER));
}


//***************************************************************************
//*                                                                         *
//* NAME:       IsGoodDir                                                   *
//*                                                                         *
//* SYNOPSIS:   Find out if it's a good temporary directory or not.         *
//*                                                                         *
//* REQUIRES:   szPath:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if good, FALSE if nogood               *
//*                                                                         *
//***************************************************************************
BOOL IsGoodDir( LPCSTR szPath )
{
    DWORD  dwAttribs;
    HANDLE hFile;
    char   szTestFile[MAX_PATH];

    lstrcpy( szTestFile, szPath );
    AddPath( szTestFile, "TMP4352$.TMP" );
    DeleteFile( szTestFile );
    hFile = CreateFile( szTestFile, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )  {
        return( FALSE );
    }

    CloseHandle( hFile );
    dwAttribs = GetFileAttributes( szPath );

    if ( ( dwAttribs != 0xFFFFFFFF )
         && ( dwAttribs & FILE_ATTRIBUTE_DIRECTORY ) )
    {
        return( TRUE );
    }

    return( FALSE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       CtlSetLDDPath                                               *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT CtlSetLddPath( UINT uiLDID, LPSTR lpszPath, DWORD dwSwitches )
{
    PSTR    pszNewPath    = NULL;
    BOOL    fSuccess      = TRUE;
    DWORD   dwNewPathSize = 0;
    HRESULT hResult       = S_OK;
    PSTR    lpTmp;
    BOOL    bDBC = FALSE;

    dwNewPathSize = max( MAX_PATH, lstrlen(lpszPath) + 1 );

    pszNewPath = (PSTR) LocalAlloc( LPTR, dwNewPathSize );
    if ( !pszNewPath ) {
        hResult = HRESULT_FROM_WIN32(GetLastError());
        ErrorMsg( ctx.hWnd, IDS_ERR_NO_MEMORY );
        goto done;
    }

    if ( ((ctx.dwSetupEngine == ENGINE_SETUPX) && (dwSwitches & LDID_SFN)) ||
         ((dwSwitches & LDID_SFN_NT_ALSO)&& (ctx.wOSVer == _OSVER_WIN95)) )
    {
        if ( GetShortPathName( lpszPath, pszNewPath, dwNewPathSize ) == 0 )
        {
            hResult = HRESULT_FROM_WIN32(GetLastError());
            ErrorMsg( ctx.hWnd, IDS_ERR_SHORT_NAME );
            goto done;
        }
    }
    else
        lstrcpy( pszNewPath, lpszPath );

    if ( ctx.dwSetupEngine == ENGINE_SETUPX ){

    if ( dwSwitches & LDID_OEM_CHARS ) {
        CharToOem( pszNewPath, pszNewPath );
    }

    lpTmp = pszNewPath + lstrlen(pszNewPath) - 1;
    if (*lpTmp == '\\')     // Is the last byte a backslash
    {
        // Check if it is the trail byte of a DBC
        lpTmp = pszNewPath;
        do
        {
            bDBC = IsDBCSLeadByte(*lpTmp);
            lpTmp = CharNext(lpTmp);
        } while (*lpTmp);

        if (bDBC)
        {
            // The backslash is a trail byte. Add another backslash
            AddPath(pszNewPath, "");
        }
    }

    if ( pfCtlSetLddPath32( uiLDID, pszNewPath ) ) {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_SET_LDID, pszNewPath );
            hResult = E_FAIL;
            goto done;
        }
    }
    else
    {
        hResult = MySetupSetDirectoryId( uiLDID, pszNewPath );
        if (  FAILED( hResult ) ) {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_SET_LDID, pszNewPath );
            goto done;
        }
    }

  done:

    if ( pszNewPath ) {
        LocalFree( pszNewPath );
    }

    return hResult;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GenInstall                                                  *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:   lpszInfFileName: Filename of INF file.                      *
//*             lpszSection:     Section of the INF to install              *
//*             lpszDirectory:   Directory of CABs (Temp Dir).              *
//*                                                                         *
//* RETURNS:    BOOL: Error result, FALSE == ERROR                          *
//*                                                                         *
//***************************************************************************
HRESULT GenInstall( LPSTR lpszInfFilename, LPSTR lpszInstallSection, LPSTR lpszSourceDir )
{
    CHAR   szErrorText[BIG_STRING];
    DWORD   dwError                  = 0;
    HRESULT hResult                  = S_OK;
    CHAR   szSourceDir[MAX_PATH];
    DWORD   dwLen                    = 0;

    // Remove trailing backslash from the source directory
    lstrcpy( szSourceDir, lpszSourceDir );
    dwLen = lstrlen( szSourceDir );
    if ( szSourceDir[dwLen-2] != ':' && szSourceDir[dwLen-1] == '\\' ) {
    	szSourceDir[dwLen-1] = '\0';
    }

    if ( ctx.dwSetupEngine == ENGINE_SETUPX )
    {
        CHAR szSFNInf[MAX_PATH] = { 0 };

        GetShortPathName( lpszInfFilename, szSFNInf, sizeof(szSFNInf) );
        GetShortPathName( szSourceDir, szSourceDir, sizeof(szSourceDir) );
        dwError = pfGenInstall32( szSFNInf, lpszInstallSection,
                                  szSourceDir, (DWORD) ctx.wQuietMode,
                                  HandleToUlong(ctx.hWnd)
								);
        if ( dwError ) {
            szErrorText[0] = '\0';
            pfGetSETUPXErrorText32( dwError, szErrorText, sizeof(szErrorText) );
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_FAIL, szErrorText );
            hResult = E_FAIL;
        }
    } else {
        hResult = InstallOnNT( lpszInstallSection, szSourceDir );
        if ( FAILED( hResult ) )
        {
            if ( !FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                                szErrorText, sizeof(szErrorText), NULL) )
            {
                LoadSz( IDS_ERR_FMTMSG, szErrorText, sizeof(szErrorText) );
                if ( *szErrorText == 0 )
                    lstrcpy( szErrorText, "Could not get the system message. You may run out of the resource." );
            }

            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_FAILURE, szErrorText );
        }
    }

    return hResult;
}


//***************************************************************************
//*                                                                         *
//* NAME:       GetValueFromRegistry                                        *
//*                                                                         *
//* SYNOPSIS:   Get an app-path out of the registry as specified.           *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    BOOL: Error result, FALSE == ERROR                          *
//*                                                                         *
//***************************************************************************
BOOL GetValueFromRegistry( LPSTR szPath, UINT cbPath, LPSTR szKey,
                           LPSTR szSubKey, LPSTR szVName )
{
    HKEY  hkPath = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    HKEY  hkRoot = NULL;
    PSTR  pszTemp = NULL;

    // Figure out what root key they want to check

    if ( lstrcmpi( szKey, "HKCR" ) == 0 ) {
        hkRoot = HKEY_CLASSES_ROOT;
    } else if ( lstrcmpi( szKey, "HKCU" ) == 0 ) {
        hkRoot = HKEY_CURRENT_USER;
    } else if ( lstrcmpi( szKey, "HKLM" ) == 0 ) {
        hkRoot = HKEY_LOCAL_MACHINE;
    } else if ( lstrcmpi( szKey, "HKU" ) == 0 ) {
        hkRoot = HKEY_USERS;
    } else if ( *szKey == '\0' ) {
        // If they don't specify a root key, then assume they don't want to check
        // the registry.  So just return as if the registry key doesn't exist.
        return FALSE;
    } else {
        ErrorMsg( ctx.hWnd, IDS_ERR_INVALID_REGROOT );
        return FALSE;
    }

    // Get Path to program from the registry

    if ( RegOpenKeyEx( hkRoot, szSubKey, (ULONG) 0, KEY_READ, &hkPath ) != ERROR_SUCCESS ) {
        return( FALSE );
    }

    dwSize = cbPath;
    if ( RegQueryValueEx( hkPath, szVName, NULL, &dwType, (LPBYTE) szPath, &dwSize)
         != ERROR_SUCCESS )
    {
        RegCloseKey( hkPath );
        return( FALSE );
    }

    RegCloseKey( hkPath );

    // If we got nothing or it wasn't a string then we bail out
    if ( (dwSize == 0) || (dwType != REG_SZ && dwType != REG_EXPAND_SZ) ) {
        return( FALSE );
    }

    if ( dwType == REG_EXPAND_SZ ) {
        pszTemp = (PSTR) LocalAlloc( LPTR, cbPath );
        if ( pszTemp == NULL ) {
            return( FALSE );
        }
        lstrcpy( pszTemp, szPath );
        dwSize = ExpandEnvironmentStrings( pszTemp, szPath, cbPath );
        LocalFree( pszTemp );

        if ( dwSize == 0 || dwSize > cbPath ) {
            return( FALSE );
        }
    }

    return( TRUE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       SetLDIDs                                                    *
//*                                                                         *
//* SYNOPSIS:   Sets the LDIDs as specified in the INF file.                *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//* NOTE:       If c_pszSourceDir != NULL then we want to set the source    *
//*             directory and nothing else.                                 *
//*                                                                         *
//***************************************************************************
HRESULT SetLDIDs( PCSTR c_pszInfFilename, PCSTR c_pszInstallSection,
                  DWORD dwInstNeedSize, PCSTR c_pszSourceDir )
{
    CHAR    szDestSection[256];
    CHAR    szDestLDIDs[512];
    PSTR    pszDestLDID          = NULL;
    PSTR    pszNextDestLDID      = NULL;
    CHAR    szDestData[256];
    DWORD   dwStringLength       = 0;
    LPSTR   pszCustomSection;
    DWORD   dwLDID[4]            = { 0 };
    DWORD   dwSwitches           = 0;
    DWORD   i                    = 0;
    DWORD   dwFlag               = 1;
    HRESULT hResult              = S_OK;
    CHAR    szBuffer[MAX_PATH+2];
    static const CHAR c_szCustDest[] = "CustomDestination";
    static const CHAR c_szSourceDirKey[] = "SourceDir";
    PSTR    pszTmp;

    // Get section name that specifies the custom LDID information.

    if ( FAILED(GetTranslatedString( c_pszInfFilename, c_pszInstallSection, c_szCustDest,
                                     szDestSection, sizeof(szDestSection), NULL)))
    {
        // There is no Custom Destination specification -- this probably
        // means they didn't want to have a custom destination section,
        // so we just return with a warm, tingly feeling
        hResult = S_OK;
        goto done;
    }

    // author defined CustomDestination, so add some system directories to the reg before continuing
    SetSysPathsInReg();


    dwStringLength = GetTranslatedSection( c_pszInfFilename, szDestSection,
                                           szDestLDIDs, sizeof(szDestLDIDs));
    if ( dwStringLength == 0 ) {
        ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, szDestSection );
        hResult = E_FAIL;
        goto done;
    }

    pszDestLDID = szDestLDIDs;

    while ( *pszDestLDID != '\0' ) {
        pszNextDestLDID = pszDestLDID + lstrlen(pszDestLDID) + 1;

        if (*pszDestLDID == ';')
        {
            pszDestLDID = pszNextDestLDID;
            continue;
        }

#if 0
        hResult = GetTranslatedString( c_pszInfFilename, szDestSection, pszDestLDID,
                                         szDestData, sizeof(szDestData), NULL);

        if (FAILED(hResult))
        {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, szDestSection );
            goto done;
        }
#endif

        if ( pszTmp = ANSIStrChr(pszDestLDID, '=') )
        {
            lstrcpy(szDestData, CharNext(pszTmp));
            *pszTmp = '\0';
        }
        else
        {
            // invalid define LDID line skip
            pszDestLDID = pszNextDestLDID;
            continue;
        }

        // Parse out the information in this line.
        dwFlag = ParseDestinationLine( pszDestLDID, szDestData, &pszCustomSection,
                                       &dwLDID[0], &dwLDID[1], &dwLDID[2], &dwLDID[3] );
        if ( dwFlag == -1 ) {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, szDestSection );
            hResult = E_FAIL;
            goto done;
        }

        if ( lstrcmpi( pszCustomSection, c_szSourceDirKey ) == 0 )
        {
            if ( c_pszSourceDir == NULL )
            {
                // The line specifies "SourceDir" but we don't want to set the source dir
                pszDestLDID = pszNextDestLDID;
                continue;
            }
        }
        else
        {
            if ( c_pszSourceDir != NULL )
            {
                // The line doesn't specify "SourceDir" but we want to set the source dir
                pszDestLDID = pszNextDestLDID;
                continue;
            }
        }

        if ( c_pszSourceDir != NULL )
        {
            // szBuffer is MAX_PATH big and c_pszSourceDir is a path, so we
            // shouldn't have a problem.

            lstrcpy( szBuffer, c_pszSourceDir );
        }
        else
        {
            hResult = GetDestinationDir( c_pszInfFilename, pszCustomSection, dwFlag,
                                         dwInstNeedSize, szBuffer, sizeof(szBuffer) );
            if ( FAILED(hResult) ) {
            // Error message displayed in GetDestinationDir
            goto done;
            }
        }

        for ( i = 0; i < 4; i += 1 )
        {
            // Default is ANSI LFN
            dwSwitches = 0;

        if ( dwLDID[i] == 0 ) {
            continue;
        }

        if ( i == 0 || i == 3 ) {
            dwSwitches |= LDID_OEM_CHARS;
        }

        if (    (i == 0 || i == 2)
                && (dwFlag & FLAG_VALUE && !(dwFlag & FLAG_NODIRCHECK) ) )
        {
            dwSwitches |= LDID_SFN;
            if ((i==0) && (dwLDID[3] != 0) )
            {
                dwSwitches |= LDID_SFN_NT_ALSO;
            }

            if ((i==2) && (dwLDID[1] != 0))
            {
                dwSwitches |= LDID_SFN_NT_ALSO;
            }
        }

        hResult = CtlSetLddPath( dwLDID[i], szBuffer, dwSwitches );
        if ( FAILED( hResult ) )
        {
            // Error message is displayed in ClSetLddPath function.
            goto done;
        }
     }

     pszDestLDID = pszNextDestLDID;
  }

  done:

    return hResult;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetDestinationDir                                           *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT GetDestinationDir( PCSTR c_pszInfFilename, PCSTR c_pszCustomSection,
                           DWORD dwFlag, DWORD dwInstNeedSize,
                           PSTR pszBuffer, DWORD dwBufferSize )
{
    BOOL    fFoundRegKey         = FALSE;
    BOOL    fFoundLine           = FALSE;
    DWORD   j                    = 0;
    PSTR    pszCustomData        = NULL;
    PSTR    pszCurCustomData     = NULL;
    LPSTR   pszRootKey           = NULL;
    LPSTR   pszBranch            = NULL;
    LPSTR   pszValueName         = NULL;
    LPSTR   pszPrompt            = NULL;
    LPSTR   pszDefault           = NULL;
    HRESULT hResult              = S_OK;
    CHAR   szValue[MAX_PATH+2];

    ASSERT( pszBuffer != NULL );

    // Reset reg key found flag.  For each custom destination, we want to set
    // this flag to TRUE if any one of the registry keys are found.
    fFoundRegKey = FALSE;
    fFoundLine = FALSE;

    for ( j = 0; ; j += 1 )
    {
        if ( FAILED( GetTranslatedLine( c_pszInfFilename, c_pszCustomSection,
                                        j, &pszCurCustomData, NULL ) ) || !pszCurCustomData )
        {
            break;
        }

        fFoundLine = TRUE;

        // save the last valid customData line before the break off
        if ( pszCustomData )
        {
            LocalFree( pszCustomData );
        }
        pszCustomData = pszCurCustomData;

        // Parse out the fields in the custom destination line.
        if ( ! ParseCustomLine( pszCustomData, &pszRootKey, &pszBranch,
                                &pszValueName, &pszPrompt, &pszDefault, TRUE, TRUE ) )
        {
            ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, c_pszCustomSection );
            hResult = E_FAIL;
            goto done;
        }

        // Check the specified registry branch and grab the contents.
        if ( GetValueFromRegistry( szValue, sizeof(szValue), pszRootKey, pszBranch, pszValueName )
                            == TRUE )
        {
            LPSTR pszTmp;

            // If the INF says to strip trailing semi-colon,
            // and there is a trailing semi-colon,
            // then strip it.

            if ( !( dwFlag & FLAG_NOSTRIP ) )
            {
                if ( dwFlag & FLAG_STRIPAFTER_FIRST )
                {
                    pszTmp = ANSIStrChr( szValue, ';' );
                    if ( pszTmp )
                        *pszTmp = '\0';
                }
                else
                {
                   if ( szValue[lstrlen(szValue)-1] == ';' )
                   {
                       szValue[lstrlen(szValue)-1] = '\0';
                   }
                }
            }

           // strip off the trailing blanks
           pszTmp = szValue;
           pszTmp += lstrlen(szValue) - 1;

           while ( *pszTmp == ' ' )
           {
               *pszTmp = '\0';
               pszTmp -= 1;
           }

            // If the INF says to check if directory exists,
            // and the directory doesn't exist,
            // then treat as if the reg key wasn't found

            if ( ! ( dwFlag & FLAG_NODIRCHECK )
                 && ! DirExists( szValue ) )
            {
                // Directory doesn't exist.  Don't break out of loop.
            }
            else
            {
                // Directory exists
                // If the INF says to save the branch in the LDID,
                // then save the branch.
                // Otherwise save the value.
                if ( dwFlag & FLAG_VALUE )
                {
                    pszDefault = szValue;
                }
                else
                {
                    pszDefault = pszBranch;
                }

                fFoundRegKey = TRUE;
                break;
            }
        }
            // Note;  If the registry key is not found, then the defaults as specified in
            // the INF file are used.
    }

    if ( ! fFoundLine ) {
        ErrorMsg1Param( ctx.hWnd, IDS_ERR_INF_SYNTAX, c_pszCustomSection );
        hResult = E_FAIL;
        goto done;
    }

    // 2 specified + 32 not specified + not found reg
    // 2 specified + 32     specified +     found reg
    if ( ((dwFlag & FLAG_FAIL) && (!(dwFlag & FLAG_FAIL_NOT)) && (fFoundRegKey == FALSE))
         || ((dwFlag & FLAG_FAIL) &&   (dwFlag & FLAG_FAIL_NOT)  && (fFoundRegKey == TRUE)) )
    {
        // NOTE: This uses the prompt specified in the INF file.
        ErrorMsg1Param( ctx.hWnd, IDS_PROMPT, pszPrompt );
        hResult = E_FAIL;
        goto done;
    }

    // Prompt the user for the destination directory.
    if ( (dwFlag & FLAG_VALUE) && (! (dwFlag & FLAG_NODIRCHECK)) )
    {
        if ( ctx.wQuietMode || (dwFlag & FLAG_QUIET) )
        {
            lstrcpy( szValue, pszDefault );

            // check if the directory has enough disk space to install the program
            if ( !IsFullPath(szValue) ) {
                hResult = E_FAIL;
                goto done;
            }

            if ( !IsEnoughInstSpace( szValue, dwInstNeedSize, NULL ) ) {
                ErrorMsg( ctx.hWnd, IDS_ERR_USER_CANCEL_INST );
                hResult = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
                goto done;
            }

            if ( ! DirExists( szValue ) ) {
                hResult = CreateFullPath( szValue, FALSE );
                if ( FAILED(hResult) ) {
                    goto done;
                }
            }
            if ( ! IsGoodDir( szValue ) )  {
                hResult = E_FAIL;
                goto done;
            }

            pszDefault = szValue;
        }
        else
        {
            CHAR szLFNValue[MAX_PATH*2];

            MakeLFNPath(pszDefault, szLFNValue, TRUE);
            if ( UserDirPrompt( pszPrompt, szLFNValue, szValue, sizeof(szValue), dwInstNeedSize ) )
            {
                pszDefault = szValue;
            }
            else
            {
                ErrorMsg( ctx.hWnd, IDS_ERR_USER_CANCEL_INST );
                hResult = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                goto done;
            }
        }
    }

    if ( (DWORD)lstrlen(pszDefault) >= dwBufferSize ) {
        ErrorMsg( ctx.hWnd, IDS_ERR_TOO_BIG );
        hResult = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto done;
    }

    lstrcpy( pszBuffer, pszDefault );

  done:
    // free the buf allocated by GetTranslatedLine
    if ( pszCustomData )
    {
        if ( pszCustomData == pszCurCustomData )
            pszCurCustomData = NULL;
        LocalFree( pszCustomData );
    }

    if ( pszCurCustomData )
    {
        LocalFree( pszCurCustomData );
    }

    return hResult;
}


//***************************************************************************
//*                                                                         *
//* NAME:       DirExists                                                   *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL DirExists( LPSTR szDir )
{
    DWORD dwAttribs = 0;

    if ( szDir == NULL ) {
        return FALSE;
    }

    dwAttribs = GetFileAttributes( szDir );
    if ( ( dwAttribs != 0xFFFFFFFF )
         && ( dwAttribs & FILE_ATTRIBUTE_DIRECTORY ) )
    {
        return TRUE;
    }

    return FALSE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       ParseDestinationLine                                        *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//* Bitwise flags:                                                          *
//*                                                                         *
//*  bit  Off                        On                             Value   *
//*  ---  --------------------       ----------------------------   -----   *
//*  0    Get value                  Get branch                     1       *
//*  1    Use default if none exist  Fail if none exist             2       *
//*  2    Non-quiet mode             Quiet mode                     4       *
//*  3    Strip trailing ";"         Don't strip trailing ";"       8       *
//*  4    Treat value as directory   Treat value as plain string    16      *
//*                                                                         *
//***************************************************************************
DWORD ParseDestinationLine( PSTR pszLDIDs, PSTR pszValue, PSTR *ppszSectionName,
                            PDWORD pdwLDID1, PDWORD pdwLDID2,
                            PDWORD pdwLDID3, PDWORD pdwLDID4 )
{
    PSTR  pszPoint  = NULL;
    DWORD dwFlag    = DEFAULT_FLAGS;
    DWORD dwLDID[4] = { 0 };
    DWORD i         = 0;
    PSTR  pszStr;

    pszPoint = pszLDIDs;

    for ( i = 0; i < 4; i += 1 )
    {
        // Parse the arguments, SETUP engine is not called. So we only need to check on \'
        pszStr = GetStringField( &pszPoint, ",", '\"', TRUE );

        if ( pszStr == NULL )
        {
            dwLDID[i] = 0;
        }
        else
        {
            dwLDID[i] = (DWORD) My_atol(pszStr);
        }
    }

    *pdwLDID1 = dwLDID[0];
    *pdwLDID2 = dwLDID[1];
    *pdwLDID3 = dwLDID[2];
    *pdwLDID4 = dwLDID[3];

    pszStr = pszValue;
    *ppszSectionName = GetStringField( &pszStr, ",", '\"', TRUE );
    if ( *ppszSectionName == NULL || **ppszSectionName == '\0' ) {
        return (DWORD)-1;
    }

    pszPoint = GetStringField( &pszStr, ",", '\"', TRUE );
    if ( pszPoint != NULL && *pszPoint != '\0' ) {
        dwFlag = (DWORD) My_atol(pszPoint);
    }

    // Special case this.  We definitely don't want to prompt the user
    // for a registry branch to use!
    if ( !( dwFlag & FLAG_VALUE ) ) {
        dwFlag |= FLAG_QUIET;
    }

    return dwFlag;
}


//***************************************************************************
//*                                                                         *
//* NAME:       ParseCustomLine                                             *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL ParseCustomLine( PSTR pszCheckKey, PSTR *ppszRootKey, PSTR *ppszBranch,
                      PSTR *ppszValueName, PSTR *ppszPrompt, PSTR *ppszDefault,
                      BOOL bStripWhiteSpace, BOOL bProcQuote )
{
    DWORD i           = 0;
    PSTR  pszField[5] = { NULL };
    BOOL  bRet = TRUE;

    for ( i = 0; i < 5; i++ )
    {
        // Parse the arguments, SETUP engine has processed \" so we only need to check on \'
        if (bProcQuote)
            pszField[i] = GetStringField( &pszCheckKey, ",", '\'', bStripWhiteSpace );
        else
            pszField[i] = GetStringFieldNoQuote( &pszCheckKey, ",", bStripWhiteSpace );

        if ( pszField[i] == NULL )
        {
            bRet = FALSE;
            break;
        }
    }

    *ppszRootKey   = pszField[0];
    *ppszBranch    = pszField[1];
    *ppszValueName = pszField[2];
    *ppszPrompt    = pszField[3];
    *ppszDefault   = pszField[4];

    return bRet;
}


//***************************************************************************
//*                                                                         *
//* NAME:       RegisterOCXs                                                *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL RegisterOCXs( LPSTR szInfFilename, LPSTR szInstallSection,
                   BOOL fNeedReboot, BOOL fRegister, DWORD dwFlags )
{
    HRESULT hReturnCode              = S_OK;
    BOOL    fOleInitialized          = TRUE;
    PSTR    pszOCXLine               = NULL;
    BOOL    fSuccess                 = TRUE;
    PSTR    pszSection               = NULL;
    DWORD   i                        = 0;
    REGOCXDATA  RegOCX = { 0 };
    CHAR   szRegisterSection[256];
    PSTR    pszNotUsed;
    static const CHAR c_szREGISTEROCXSECTION[]   = "RegisterOCXs";
    static const CHAR c_szUNREGISTEROCXSECTION[] = "UnRegisterOCXs";

    // If we want to register, then use the register section.
    // If we want to unregister, then use the unregister section.
    if ( fRegister )
    {
        if ( dwFlags & COREINSTALL_ROLLBACK )
        {
            pszSection = (PSTR) c_szUNREGISTEROCXSECTION;
            if ( FAILED(GetTranslatedString( szInfFilename, szInstallSection, pszSection,
                                             szRegisterSection, sizeof(szRegisterSection), NULL)))
            {
                pszSection = (PSTR) c_szREGISTEROCXSECTION;
            }
        }
        else
            pszSection = (PSTR) c_szREGISTEROCXSECTION;
    }
    else
    {
        // if it is call with ROLLBACKL flag on,
        // we have backed up all the files and reg data.  Now we need to unregist (the new)OCXs from Register list
        // before register the old one.
        //
        if ( dwFlags & COREINSTALL_ROLLBACK )
            pszSection = (PSTR) c_szREGISTEROCXSECTION;
        else
            pszSection = (PSTR) c_szUNREGISTEROCXSECTION;
    }

    // Grab the section name of the Register OCX section
    if ( FAILED(GetTranslatedString( szInfFilename, szInstallSection, pszSection,
                                     szRegisterSection, sizeof(szRegisterSection), NULL)))
    {
        // There is no Register OCX section. Assume the user wanted it that
        // way and return with a big smile.
        return TRUE;
    }

    if ( FAILED( OleInitialize( NULL ) ) )
    {
        fOleInitialized = FALSE;
    }
// #pragma prefast(disable:56,"False warning at OemToChar line. Using workaround to disable it - PREfast bug 643")
    for ( i = 0; ; i += 1 )
    {
        if ( pszOCXLine )
        {
            LocalFree( pszOCXLine );
            pszOCXLine = NULL;
        }

        if ( FAILED( GetTranslatedLine( szInfFilename, szRegisterSection, i, &pszOCXLine, NULL ) ) )
        {
            break;
        }

        // process OCX line:  Name [,<switch>,<str>] where switch - i== call both entries; in == only call
        // DllRegister; n == call none;  Empty means just call old  DllRegister.
        ParseCustomLine( pszOCXLine, &(RegOCX.pszOCX), &(RegOCX.pszSwitch), &(RegOCX.pszParam), &pszNotUsed, &pszNotUsed, TRUE, FALSE );

        if ( ctx.dwSetupEngine == ENGINE_SETUPX ) {
            OemToChar( RegOCX.pszOCX, RegOCX.pszOCX );
        }

        // before re-regiester OCX at ROLLBACK case, we need to check if the file exists.
        // IF not, we don't want to try to register it.
        if ( dwFlags & COREINSTALL_ROLLBACK )
        {
            DWORD dwAttr;

            dwAttr = GetFileAttributes( RegOCX.pszOCX );
            if ( (dwAttr == -1 ) || (dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
            {
                //skip this one
                continue;
            }
        }

        // If we need to reboot, then just add registrations to the run once entry.
        // Otherwise try to register right away.
        // If we are unregistering OCXs, then fNeedReboot should always be FALSE,
        // since unregistration happens before a GenInstall.

        if ( !fNeedReboot && ( !fRegister || !(dwFlags & COREINSTALL_DELAYREGISTEROCX) ) )
        {
            // no reboot case, the last one params are ignored.
            if ( !InstallOCX( &RegOCX, TRUE, fRegister, i ) && !(dwFlags & COREINSTALL_ROLLBACK) )
            {
                fSuccess = FALSE;

                if ( fRegister )
                {
                    ErrorMsg1Param( ctx.hWnd, IDS_ERR_REG_OCX, RegOCX.pszOCX );
                    goto done;
                }
                else
                {
                    ErrorMsg1Param( ctx.hWnd, IDS_ERR_UNREG_OCX, RegOCX.pszOCX );
                }
            }
        }
        else
        {

            // Add a runonce entry so that the OCX is registered on next boot.
            //
            if ( !InstallOCX( &RegOCX, FALSE, fRegister, i ) )
            {
                ErrorMsg1Param( ctx.hWnd, IDS_ERR_RUNONCE_REG_OCX, RegOCX.pszOCX );
                fSuccess = FALSE;
                goto done;
            }
        }

    }
 // #pragma prefast(enable:56,"")
done:

    if ( fOleInitialized ) {
        OleUninitialize();
    }

    if ( pszOCXLine )
    {
        LocalFree( pszOCXLine );
    }

    return fSuccess;
}

//***************************************************************************
//*                                                                         *
//* NAME:       DelDirs                                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
void DelDirs( LPCSTR szInfFilename, LPCSTR szInstallSection )
{
    PSTR   pszFolder = NULL;
    CHAR   szDelDirsSection[MAX_PATH];
    DWORD   i = 0;

    if ( FAILED(GetTranslatedString( szInfFilename, szInstallSection, ADVINF_DELDIRS,
                                     szDelDirsSection, sizeof(szDelDirsSection), NULL)))
    {
        // no demands on remove folders
        return;
    }

    for ( i = 0; ; i++ )
    {
        if ( FAILED( GetTranslatedLine( szInfFilename, szDelDirsSection,
                                        i, &pszFolder, NULL ) ) || !pszFolder )
        {
            break;
        }

        MyRemoveDirectory( pszFolder );

        LocalFree( pszFolder );
        pszFolder = NULL;
    }
    return;
}

//***************************************************************************
//*                                                                         *
//* NAME:       DoCleanup                                                    *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
void DoCleanup( LPCSTR szInfFilename, LPCSTR szInstallSection )
{
    int iFlags;

    iFlags = GetTranslatedInt(szInfFilename, szInstallSection, ADVINF_CLEANUP, 0);

    if ( iFlags & CLEN_REMVINF )
    {
    	DeleteFile( szInfFilename );
    }

    return;
}

// greater than 4.71.0219
//
#define ROEX_VERSION_MS 0x00040047      // 4.71
#define ROEX_VERSION_LS 0x00DB0000      // 0219.0


BOOL UseRunOnceEx()
{
    DWORD dwMV, dwLV;
    BOOL  bRet = FALSE;
    char  szPath[MAX_PATH] = "";
    char  szBuf[MAX_PATH] = "";
    DWORD dwTmp;

    GetSystemDirectory( szPath,sizeof( szPath ) );
    AddPath( szPath, "iernonce.dll" );
    GetVersionFromFile( szPath, &dwMV, &dwLV, TRUE );

    // greater than 4.71.0230
    //
    if ( ( dwMV > ROEX_VERSION_MS ) || (( dwMV == ROEX_VERSION_MS ) && ( dwLV >= ROEX_VERSION_LS ))  )
    {
        GetWindowsDirectory( szBuf, MAX_PATH );
        AddPath( szBuf, "explorer.exe" );
        GetVersionFromFile( szBuf, &dwMV, &dwLV, TRUE );
        if (( dwMV < ROEX_VERSION_MS) || (( dwMV == ROEX_VERSION_MS) && ( dwLV < ROEX_VERSION_LS )) )
        {
            HKEY hkey;
            if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, (ULONG)0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dwTmp ) == ERROR_SUCCESS )
            {
                wsprintf( szBuf, RUNONCE_IERNONCE, szPath );
                if ( RegSetValueEx( hkey, RUNONCEEX, 0, REG_SZ, (CONST UCHAR *)szBuf, lstrlen(szBuf)+1 )
                                    != ERROR_SUCCESS )
                {
                    bRet = FALSE;
                    RegCloseKey( hkey );
                    goto done;
                }
                RegCloseKey( hkey );
            }
            else
                bRet = FALSE;
        }
        bRet = TRUE;
    }

done:
    return bRet;
}

void GetNextRunOnceExSubKey( HKEY hKey, PSTR pszSubKey, int *piSubKeyNum )
{
    HKEY hSubKey;

    for (;;)
    {
        wsprintf( pszSubKey, "%d", ++*piSubKeyNum );
        if ( RegOpenKeyEx( hKey, pszSubKey,(ULONG) 0, KEY_READ, &hSubKey ) != ERROR_SUCCESS )
        {
            break;
        }
        else
        {
            RegCloseKey( hSubKey );
        }
    }
}

void GetNextRunOnceValName( HKEY hKey, PCSTR pszFormat, PSTR pszValName, int line )
{

    do
    {
        wsprintf( pszValName, pszFormat, line++ );

    } while ( RegQueryValueEx( hKey, pszValName, 0, NULL, NULL, NULL ) == ERROR_SUCCESS );

}


BOOL DoDllReg( HANDLE hOCX, BOOL fRegister )
{
    FARPROC   lpfnDllRegisterServer = NULL;
    PSTR      pszRegSvr             = NULL;
    BOOL      fSuccess              = FALSE;

    if ( fRegister )
    {
        pszRegSvr = (PSTR) achREGSVRDLL;
    }
    else
    {
        pszRegSvr = (PSTR) achUNREGSVRDLL;
    }

    lpfnDllRegisterServer = GetProcAddress( hOCX, pszRegSvr );
    if ( lpfnDllRegisterServer )
    {
        if ( SUCCEEDED( lpfnDllRegisterServer() ) )
        {
            fSuccess = TRUE;
        }
    }
    return fSuccess;
}

BOOL DoDllInst( HANDLE hOCX, BOOL fRegister, PCSTR pszParam )
{
    WCHAR   pwstrDllInstArg[MAX_PATH];
    DLLINSTALL  pfnDllInstall = NULL;
    BOOL    fSuccess = FALSE;

    if ( pszParam == NULL )
        pszParam = "";

    pfnDllInstall = (DLLINSTALL)GetProcAddress( hOCX, "DllInstall" );
    if ( pfnDllInstall )
    {
        MultiByteToWideChar(CP_ACP, 0, pszParam, -1, pwstrDllInstArg, ARRAYSIZE(pwstrDllInstArg));

        if ( SUCCEEDED( pfnDllInstall( fRegister, pwstrDllInstArg ) ) )
            fSuccess = TRUE;
    }
    return fSuccess;
}


//***************************************************************************
//*                                                                         *
//* NAME:       InstallOCX                                                  *
//*                                                                         *
//* SYNOPSIS:   Self-registers the OCX.                                     *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL InstallOCX( PREGOCXDATA pRegOCX, BOOL fDoItNow, BOOL fRegister, int line )
{
    PSTR   lpszCmdLine  = NULL;
    PSTR   lpszCmdLine2  = NULL;
    BOOL    fSuccess     = TRUE;
    HKEY    hKey = NULL, hSubKey = NULL;
    HANDLE  hOCX = NULL;
    BOOL    bDoDllReg = TRUE, bDoDllInst = FALSE;
    PSTR    pszCmds[2] = { 0 };
    int     i;

    AdvWriteToLog("InstallOCX: %1 %2\r\n", pRegOCX->pszOCX, fRegister?"Register":"UnRegister" );
    // parse what kind OCX entry points to call
    if ( pRegOCX->pszSwitch && *pRegOCX->pszSwitch )
    {
        if ( ANSIStrChr( CharUpper(pRegOCX->pszSwitch), 'I' ) )
        {
            bDoDllInst = TRUE;
            if ( ANSIStrChr( CharUpper(pRegOCX->pszSwitch), 'N' ) )
                bDoDllReg = FALSE;
        }
        else
        {
            fSuccess = FALSE;
            goto done;
        }
    }

    lpszCmdLine = (LPSTR) LocalAlloc( LPTR,   BUF_1K );
    lpszCmdLine2 = (LPSTR) LocalAlloc( LPTR,   BUF_1K );
    if ( !lpszCmdLine || !lpszCmdLine2) {
        ErrorMsg( ctx.hWnd, IDS_ERR_NO_MEMORY );
        fSuccess = FALSE;
        goto done;
    }

    // fDoItNow says whether we should add to runonce or register the OCX right away
    if ( fDoItNow )
    {
        LPCSTR              szExtension           = NULL;

        // ignore the display name line in this case
        if ( *(pRegOCX->pszOCX) == '@' )
        {
            goto done;
        }

        // Figure out what type of OCX we are trying to register: two choices
        //   1. EXE
        //   2. DLL/OCX/etc
        //
        szExtension = &pRegOCX->pszOCX[lstrlen(pRegOCX->pszOCX)-3];

        if ( lstrcmpi( szExtension, "EXE" ) == 0 )
        {
            PSTR   pszRegSvr;

            if ( fRegister )
                pszRegSvr = (PSTR) achREGSVREXE;
            else
                pszRegSvr = (PSTR) achUNREGSVREXE;

            lstrcpy( lpszCmdLine, pRegOCX->pszOCX );
            lstrcat( lpszCmdLine, pszRegSvr );


            if ( LaunchAndWait( lpszCmdLine, NULL, NULL, INFINITE, 0 ) == E_FAIL )
            {
                AdvWriteToLog("InstallOCX: %1 Failed\r\n", lpszCmdLine);
                fSuccess = FALSE;
                goto done;
            }
            AdvWriteToLog("%1 : Succeeded.\r\n", lpszCmdLine);
        }
        else
        {
            AdvWriteToLog("LoadLibrary %1\r\n", pRegOCX->pszOCX);
            hOCX = LoadLibraryEx( pRegOCX->pszOCX, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
            if ( hOCX == NULL )
            {
                fSuccess = FALSE;
                goto done;
            }

            // Install time order:  DllRegisterServer, DllInstall
            // Uninstall order:  DllInstall, DllRegisterServer
            if ( fRegister )
            {
                if ( bDoDllReg )
                {
                    fSuccess = DoDllReg( hOCX, fRegister );
                    AdvWriteToLog("Register: DoDllReg: %1\r\n", fSuccess?"Succeeded":"Failed" );
                }

                if ( fSuccess && bDoDllInst )
                {
                    fSuccess = DoDllInst( hOCX, fRegister, pRegOCX->pszParam );
                    AdvWriteToLog("Register: DoDllInstall: %1\r\n", fSuccess?"Succeeded":"Failed" );
                }
            }
            else
            {
                if ( bDoDllInst )
                {
                    fSuccess = DoDllInst( hOCX, fRegister, pRegOCX->pszParam );
                    AdvWriteToLog("UnRegister: DoDllReg: %1\r\n", fSuccess?"Succeeded":"Failed" );
                }

                if ( fSuccess && bDoDllReg )
                {
                    fSuccess = DoDllReg( hOCX, fRegister );
                    AdvWriteToLog("UnRegister: DoDllInstall: %1\r\n", fSuccess?"Succeeded":"Failed" );
                }
            }
        }
    }
    else
    {
        // Add to runonce or runonceex
        // from current logic, Unregister OCX will never be here!
        //
        char    szPath[MAX_PATH];
        LPCSTR  lpRegTmp;
        DWORD   dwTmp;
        HKEY    hRealKey;
        static BOOL bRunOnceEx       = FALSE;
        static int iSubKeyNum        = 0;

        if ( iSubKeyNum == 0 )
        {
            if ( UseRunOnceEx() )
            {
                iSubKeyNum = 799;
                bRunOnceEx = TRUE;
            }
        }

        // decide to add the entry to RunOnce or RunOnceEx
        if ( !bRunOnceEx )
        {
            // ignore the display name line in this case
            if ( *(pRegOCX->pszOCX) == '@' )
            {
                goto done;
            }
            // no ierunonce.dll, use RunOnce key rather than RunOnceEx key
            lpRegTmp = REGSTR_PATH_RUNONCE;
        }
        else
        {
            lpRegTmp = REGSTR_PATH_RUNONCEEX;
        }

        // open RunOnce or RunOnceEx key here
        if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, lpRegTmp, (ULONG)0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hKey, &dwTmp ) != ERROR_SUCCESS )
        {
            fSuccess = FALSE;
            goto done;
        }

        // Generate the next unused SubKey name
        //
        if ( bRunOnceEx )
        {
            if ( line == 0 )
                GetNextRunOnceExSubKey( hKey, szPath, &iSubKeyNum );
            else
                wsprintf( szPath, "%d", iSubKeyNum );
        }

        // Generate the Value Name and ValueData.
        //
        if ( bRunOnceEx )
        {
            if ( RegCreateKeyEx( hKey, szPath, (ULONG)0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                 NULL, &hSubKey, &dwTmp ) != ERROR_SUCCESS )
            {
                fSuccess = FALSE;
                goto done;
            }

            // if use RunOnceEx, process @ leaded display name.
            if ( *pRegOCX->pszOCX == '@' )
            {
                if ( RegSetValue( hKey, szPath, REG_SZ, (LPCSTR)CharNext(pRegOCX->pszOCX),
                                  lstrlen(CharNext(pRegOCX->pszOCX))+1 ) != ERROR_SUCCESS )
                {
                    fSuccess = FALSE;
                }
                goto done;
            }

            GetNextRunOnceValName( hSubKey, "%03d", szPath, line );
            if ( bDoDllReg )
            {
                wsprintf( lpszCmdLine, RUNONCEEXDATA, pRegOCX->pszOCX, fRegister? achREGSVRDLL : achUNREGSVRDLL );
            }

            if ( bDoDllInst )
            {
                wsprintf( lpszCmdLine2, "%s|%s|%c,%s",pRegOCX->pszOCX, "DllInstall",
                          fRegister? 'i':'u', pRegOCX->pszParam ? pRegOCX->pszParam : "" );
            }
            hRealKey = hSubKey;
            if ( fRegister )
            {
                pszCmds[0] = lpszCmdLine;
                pszCmds[1] = lpszCmdLine2;
            }
            else
            {
                pszCmds[1] = lpszCmdLine;
                pszCmds[0] = lpszCmdLine2;
            }
        }
        else
        {
            GetNextRunOnceValName( hKey, achIEXREG, szPath, line );
            wsprintf( lpszCmdLine, achRUNDLL, pRegOCX->pszOCX,
                      pRegOCX->pszSwitch ?pRegOCX->pszSwitch:"",
                      pRegOCX->pszParam ? pRegOCX->pszParam : "" );
            hRealKey = hKey;
            pszCmds[0] = lpszCmdLine;
            pszCmds[1] = "";
        }

        for ( i=0; i<2; i++ )
        {
            if (*pszCmds[i])
            {
                AdvWriteToLog("Delay Register: Value=%1  Data=%2\r\n", szPath, pszCmds[i]);
                if ( RegSetValueEx( hRealKey, szPath, 0, REG_SZ, (CONST UCHAR *) pszCmds[i], lstrlen(pszCmds[i])+1 )
                                    != ERROR_SUCCESS )
                {
                    fSuccess = FALSE;
                    goto done;
                }

                if ( bRunOnceEx )
                    GetNextRunOnceValName( hRealKey, "%03d", szPath, line );
            }
        }
    }

done:

    if ( hOCX != NULL ) {
        FreeLibrary( hOCX );
    }

    if ( hSubKey != NULL ) {
        RegCloseKey( hSubKey );
    }

    if ( hKey != NULL ) {
        RegCloseKey( hKey );
    }

    if ( lpszCmdLine != NULL ) {
        LocalFree( lpszCmdLine );
    }

    if ( lpszCmdLine2 != NULL )
        LocalFree( lpszCmdLine2 );

    AdvWriteToLog("InstallOCX: End %1\r\n", pRegOCX->pszOCX);
    return fSuccess;
}


//***************************************************************************
//
// FormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc, LPCSTR lpFile );
//
// This function can be easily described by giving examples of what it
// does:
//        Input:  GenFormStrWithoutPlaceHolders(dest,"desc=%MS_XYZ%", hinf) ;
//                INF file has MS_VGA="Microsoft XYZ" in its [Strings] section!
//
//        Output: "desc=Microsoft XYZ" in buffer dest when done.
//
//
// ENTRY:
//  szDst         - the destination where the string after the substitutions
//                  for the place holders (the ones enclosed in "%' chars!)
//                  is placed. This buffer should be big enough (LINE_LEN)
//  szSrc         - the string with the place holders.
//
// EXIT:
//
//***************************************************************************
DWORD FormStrWithoutPlaceHolders( LPCSTR szSrc, LPSTR szDst, DWORD dwDstSize, LPCSTR szInfFilename )
{
    INT     uCnt ;
    CHAR   *pszTmp;
    LPSTR  pszSaveDst;

    pszSaveDst = szDst;

    // Do until we reach the end of source (null char)
    while( ( *szDst++ = *szSrc ) )
    {
        // Increment source as we have only incremented destination above
        if( *szSrc++ == '%' ) {
            if ( *szSrc == '%' ) {
                // One can use %% to get a single percentage char in message
                szSrc++;
                continue;
            }

            // see if it is well formed -- there should be a '%' delimiter

            pszTmp = (LPSTR) szSrc;
            while ( (*pszTmp != '\0') && (*pszTmp != '%') )
            {
                pszTmp += 1;
            }

            if ( *pszTmp == '%' ) {
                szDst--; // get back to the '%' char to replace

            // yes, there is a STR_KEY to be looked for in [Strings] sect.
            *pszTmp = '\0' ; // replace '%' with a NULL char

            // szSrc points to the replaceable key now as we put the NULL char above.

            if ( ! MyGetPrivateProfileString( szInfFilename, "Strings", szSrc,
                                              szDst, dwDstSize - (DWORD)(szDst - pszSaveDst) ) )
            {
                // key is missing in [Strings] section!
                return (DWORD) -1;
            }
            else
            {
                // all was well, Dst filled right, but unfortunately count not passed
                // back, like it used too... :-( quick fix is a lstrlen()...
                uCnt = lstrlen( szDst ) ;
            }

            *pszTmp = '%'; // put back original character
            szSrc = pszTmp + 1 ;      // set Src after the second '%'
            szDst += uCnt ;           // set Dst also right.
            }
            // else it is ill-formed -- we use the '%' as such!
            else
            {
            return (DWORD)-1;
            }
        }

    } /* while */
    return (DWORD)lstrlen(pszSaveDst);

}


// BUGBUG:BUGBUG:BUGBUG:BUGBUG
// The code below is duplicated in wextract.exe. If you do changed/fixes to this code
// make sure to also change the code in wextract.exe


//***************************************************************************
//*                                                                         *
//* NAME:       GetWininitSize                                              *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// Returns the size of wininit.ini in the windows directory.
// 0 if not found
DWORD GetWininitSize()
{
    CHAR   szPath[MAX_PATH];
    HFILE   hFile;
    DWORD   dwSize = (DWORD)0;
    if ( GetWindowsDirectory( szPath, MAX_PATH ) )
    {
        AddPath( szPath, "wininit.ini" );
        if ((hFile = _lopen(szPath, OF_READ|OF_SHARE_DENY_NONE)) != HFILE_ERROR)
        {
            dwSize = _llseek(hFile, 0L, FILE_END);
            _lclose(hFile);
        }
    }
    return dwSize;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetRegValueSize                                             *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// Returns the size of the value lpcszValue under lpcszRegKey
// 0 if the registry key or the value were not found
DWORD GetRegValueSize(LPCSTR lpcszRegKey, LPCSTR lpcszValue)
{
    HKEY        hKey;
    DWORD       dwValueSize = (DWORD)0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpcszRegKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey, lpcszValue, NULL, NULL, NULL,&dwValueSize) != ERROR_SUCCESS)
            dwValueSize = (DWORD)0;
        RegCloseKey(hKey);
    }
    return dwValueSize;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetNumberOfValues                                           *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// Returns the number of Values in the key
// 0 if the registry key was not found or RegQueryInfoKey failed
DWORD GetNumberOfValues(LPCSTR lpcszRegKey)
{
    HKEY        hKey;
    DWORD       dwValueSize = (DWORD)0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpcszRegKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryInfoKey(hKey,
                            NULL, NULL, NULL, NULL, NULL, NULL,
                            &dwValueSize,
                            NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
            dwValueSize = (DWORD)0;
        RegCloseKey(hKey);
    }
    return dwValueSize;
}

//***************************************************************************
//*                                                                         *
//* NAME:       InternalNeedRebootInit                                      *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// Returns the rebootcheck value depending on the OS we get passed in.
DWORD InternalNeedRebootInit(WORD wOSVer)
{
    DWORD   dwReturn = (DWORD)0;

    switch (wOSVer)
    {
        case _OSVER_WIN95:
            dwReturn = GetWininitSize();
            break;

        case _OSVER_WINNT40:
        case _OSVER_WINNT50:
        case _OSVER_WINNT51:
            dwReturn = GetRegValueSize(szNT4XDelayUntilReboot, szNT4XPendingValue);
            break;

        case _OSVER_WINNT3X:
            dwReturn = GetNumberOfValues(szNT3XDelayUntilReboot);
            break;

    }
    return dwReturn;
}

//***************************************************************************
//*                                                                         *
//* NAME:       InternalNeedReboot                                          *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// Checks the passed in reboot check value against the current value.
// If they are different, we need to reboot.
// The reboot check value is dependend on the OS
BOOL InternalNeedReboot(DWORD dwRebootCheck, WORD wOSVer)
{
    return (dwRebootCheck != InternalNeedRebootInit(wOSVer));
}


//***************************************************************************
//*                                                                         *
//* NAME:       IsEnoughInstSpace                                           *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// Checks the install destination dir free disk space
//
BOOL IsEnoughInstSpace( LPSTR szPath, DWORD dwInstNeedSize, LPDWORD pdwPadSize )
{
    DWORD   dwFreeBytes       = 0;
    CHAR    achDrive[MAX_PATH];
    DWORD   dwVolFlags;
    DWORD   dwMaxCompLen;

    ASSERT( szPath );

    // set to zero to indicate to called that the given drive can not be checked.
    if ( pdwPadSize )
        *pdwPadSize = 0;

    // If you are here, we expect that the caller have validated the path which
    // has the Fullpath directory name
    //
    if ( dwInstNeedSize == 0 )
        return TRUE;

    if ( szPath[1] == ':' )
    {
        lstrcpyn( achDrive, szPath, 4 );
    }
    else if ( (szPath[0] == '\\') && (szPath[1] == '\\') )
    {
        return TRUE; //no way to get it
    }
    else
        return FALSE; // you should not get here, if so, we don't know how to check it.

    if ((dwFreeBytes=GetSpace(achDrive))==0)
    {
        ErrorMsg1Param( NULL, IDS_ERR_GET_DISKSPACE, achDrive );
        //SetCurrentDirectory( achOldPath );
        return( FALSE );
    }

    // find out if the drive is compressed
    if ( !GetVolumeInformation( achDrive, NULL, 0, NULL,
            &dwMaxCompLen, &dwVolFlags, NULL, 0 ) )
    {
        ErrorMsg1Param( NULL, IDS_ERR_GETVOLINFOR, achDrive );
        //SetCurrentDirectory( achOldPath );
        return( FALSE );
    }

    if ( pdwPadSize )
        *pdwPadSize = dwInstNeedSize;

    if ( (dwVolFlags & FS_VOL_IS_COMPRESSED) && ctx.bCompressed )
    {
        dwInstNeedSize = dwInstNeedSize + dwInstNeedSize/4;
        if ( pdwPadSize )
            *pdwPadSize = dwInstNeedSize;
    }

    if ( dwInstNeedSize > dwFreeBytes )
        return FALSE;
    else
        return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       My_atol                                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
LONG My_atol( LPSTR nptr )
{
    INT  c;
    LONG total;
    INT  sign;

    while ( *nptr == ' ' || *nptr == '\t' ) {
        ++nptr;
    }

    c = (INT)(UCHAR) *nptr++;
    sign = c;
    if ( c == '-' || c == '+' ) {
        c = (INT)(UCHAR) *nptr++;
    }

    total = 0;

    while ( c >= '0' && c <= '9' ) {
        total = 10 * total + (c - '0');
        c = (INT)(UCHAR) *nptr++;
    }

    if ( sign == '-' ) {
        return -total;
    } else {
        return total;
    }
}

//***************************************************************************
//*                                                                         *
//* NAME:       My_atoi                                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
INT My_atoi( LPSTR nptr )
{
    return (INT) My_atol(nptr);
}


//***************************************************************************
//*                                                                         *
//* NAME:       IsFullPath                                                  *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// return TRUE if given path is FULL pathname
//
BOOL IsFullPath( PCSTR pszPath )
{
    if ( (pszPath == NULL) || (lstrlen(pszPath) < 3) )
    {
        return FALSE;
    }

    if ( (pszPath[1] == ':') || ((pszPath[0] == '\\') && (pszPath[1]=='\\') ) )
        return TRUE;
    else
        return FALSE;
}



//***************************************************************************
//*                                                                         *
//* NAME:       GetUNCroot                                                  *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
/*
BOOL GetUNCroot( LPSTR pszinPath, LPSTR pszoutPath )
{
    ASSERT(pszinPath);
    ASSERT(pszoutPath);

    //  if you are called, called is sure that you are UNC path
    // get \\ first
    *pszoutPath++ = *pszinPath++;
    *pszoutPath++ = *pszinPath++;

    if ( *pszinPath == '\\' )
    {
	return FALSE; // catch '\\\' case
    }

    while ( *pszinPath != '\0' )
    {
	if ( *pszinPath == '\\' )
	{
	    break;
	}
	*pszoutPath++ = *pszinPath++;
    }

    if ( *(pszinPath-1) == '\\' )
    {
	return FALSE;
    }

    *pszoutPath = '\0';
    return TRUE;
}
*/



//***************************************************************************
//*                                                                         *
//* NAME:       MyFileSize                                                  *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************

DWORD MyFileSize( PCSTR pszFile )
{
    HANDLE hFile;
    DWORD dwSize = 0;

    if ( *pszFile == 0 )
        return 0;

    hFile = CreateFile( pszFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );
    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwSize = GetFileSize( hFile, NULL );
        CloseHandle( hFile );
    }

    return dwSize;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CreateFullPath                                              *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT CreateFullPath( PCSTR c_pszPath, BOOL bHiden )
{
    CHAR szPath[MAX_PATH];
    PSTR  pszPoint = NULL;
    BOOL  fLastDir = FALSE;
    HRESULT hReturnCode = S_OK;
    LPSTR szTmp;
    int   i;

    if ( ! IsFullPath( (PSTR)c_pszPath ) ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto done;
    }

    lstrcpy( szPath, c_pszPath );

    if ( lstrlen(szPath) > 3 ) {
        szTmp = CharPrev(szPath, szPath + lstrlen(szPath)) ;
        if ( szTmp > szPath && *szTmp == '\\' )
            *szTmp = '\0';
    }

    // If it's a UNC path, seek up to the first share name.
    if ( szPath[0] == '\\' && szPath[1] == '\\' ) {
        pszPoint = &szPath[2];
        for (i=0; i < 2; i++) {
            while ( *pszPoint != '\\' ) {
                if ( *pszPoint == '\0' ) {

                    // Share name missing? Else, nothing after sare name!
                    if (i == 0)
                        hReturnCode = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);

                    goto done;
                }
                pszPoint = CharNext( pszPoint );
            }
        }
        pszPoint = CharNext( pszPoint );
    } else {
        // Otherwise, just point to the beginning of the first directory
        pszPoint = &szPath[3];
    }

    while ( *pszPoint != '\0' ) 
    {
        while ( *pszPoint != '\\' && *pszPoint != '\0' ) 
        {
            pszPoint = CharNext( pszPoint );
        }

        if ( *pszPoint == '\0' ) 
        {
            fLastDir = TRUE;
        }

        *pszPoint = '\0';

        if ( GetFileAttributes( szPath ) == 0xFFFFFFFF ) 
        {
            if ( ! CreateDirectory( szPath, NULL ) ) 
            {
                hReturnCode = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
            else
            {
                if ( fLastDir && bHiden )
                    SetFileAttributes( szPath, FILE_ATTRIBUTE_HIDDEN );
            }
        }
        if ( fLastDir ) 
        {
            break;
        }

        *pszPoint = '\\';
        pszPoint = CharNext( pszPoint );
    }

  done:

    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       LaunchAndWait                                               *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT LaunchAndWait(LPSTR pszCmd, LPSTR pszDir, HANDLE *phProc, DWORD dwWaitTime, DWORD dwCmdsFlags)
{
   STARTUPINFO startInfo = { 0 };
   PROCESS_INFORMATION processInfo;
   HRESULT hr = S_OK;
   BOOL fRet;

   if(phProc)
      *phProc = NULL;

   AdvWriteToLog("LaunchAndWait: Cmd=%1\r\n", pszCmd);
   // Create process on pszCmd
   startInfo.cb = sizeof(startInfo);
   startInfo.dwFlags |= STARTF_USESHOWWINDOW;
   if ( dwCmdsFlags & RUNCMDS_QUIET )
        startInfo.wShowWindow = SW_HIDE;
   else
        startInfo.wShowWindow = SW_SHOWNORMAL ;

   fRet = CreateProcess(NULL, pszCmd, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE | NORMAL_PRIORITY_CLASS,
                        NULL, pszDir, &startInfo, &processInfo);

   if(!fRet)
   {
      // Create Process failed
      hr = E_FAIL;
      goto done;
   }
   else
   {
      HANDLE pHandle;
      BOOL fQuit = FALSE;
      DWORD dwRet;

      CloseHandle( processInfo.hThread );

      pHandle = processInfo.hProcess;

      if( phProc )
      {
          *phProc = processInfo.hProcess;
          goto done;
      }
      else if ( dwCmdsFlags & RUNCMDS_NOWAIT )
      {
          goto done;
      }

      while(!fQuit)
      {
           dwRet = MsgWaitForMultipleObjects(1, &pHandle, FALSE, dwWaitTime, QS_ALLINPUT);
           // Give abort the highest priority
           if( (dwRet == WAIT_OBJECT_0) || ( dwRet == WAIT_TIMEOUT) )
           {
                if (dwRet == WAIT_TIMEOUT)
                    AdvWriteToLog("LaunchAndWait: %1: TimedOut.\r\n", pszCmd);
                fQuit = TRUE;
           }
           else
           {
                MSG msg;
                // read all of the messages in this next loop
                // removing each message as we read it
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {

                    // if it's a quit message we're out of here
                    if (msg.message == WM_QUIT)
                        fQuit = TRUE;
                    else
                    {
                        // otherwise dispatch it
                        DispatchMessage(&msg);
                    } // end of PeekMessage while loop
                }
            }
      }
      CloseHandle( pHandle );
   }

done:
   AdvWriteToLog("LaunchAndWait: End hr=0x%1!x!, %2\r\n", hr, pszCmd);
   return hr;
}


// RO_GetPrivateProfileSection
//   ensure the file attribute is not read-only because the kernel api bug
//
DWORD RO_GetPrivateProfileSection( LPCSTR lpSec, LPSTR lpBuf, DWORD dwSize, LPCSTR lpFile)
{
    DWORD dwRealSize;
    DWORD dwAttr;
    BOOL  bHaveRead = FALSE;

    dwAttr = GetFileAttributes( lpFile );
    if ( (dwAttr != -1) && (dwAttr & FILE_ATTRIBUTE_READONLY) )
    {
        if ( !SetFileAttributes( lpFile, FILE_ATTRIBUTE_NORMAL ) )
        {
            char szInfFilePath[MAX_PATH];
            char szInfFileName[MAX_PATH];

            // ErrorMsg1Param( NULL, IDS_ERR_CANT_SETA_FILE, lpFile );

            if ( GetTempPath(sizeof(szInfFilePath), szInfFilePath) )
            {
                if ( !IsGoodDir( szInfFilePath ) )
                {
                    GetWindowsDirectory( szInfFilePath, sizeof(szInfFilePath) );
                }

                if ( GetTempFileName(szInfFilePath, TEXT("INF"), 0, szInfFileName) )
                {
                    SetFileAttributes( szInfFileName, FILE_ATTRIBUTE_NORMAL );
                    DeleteFile( szInfFileName );
                    CopyFile( lpFile, szInfFileName, FALSE );
                    SetFileAttributes( szInfFileName, FILE_ATTRIBUTE_NORMAL );
                    dwRealSize = GetPrivateProfileSection( lpSec, lpBuf, dwSize, szInfFileName );
                    bHaveRead = TRUE;
                    DeleteFile( szInfFileName );
                }
            }

            //if ( !bHaveRead )
                //ErrorMsg1Param( NULL, IDS_ERR_CANT_SETA_FILE, lpFile );
        }
    }

    if ( !bHaveRead )
        dwRealSize = GetPrivateProfileSection( lpSec, lpBuf, dwSize, lpFile );

    if ( (dwAttr != -1) && (dwAttr & FILE_ATTRIBUTE_READONLY) )
    {
        SetFileAttributes( lpFile, dwAttr );
    }

    return dwRealSize;

}

BOOL GetThisModulePath( LPSTR lpPath, int size )
{
    LPSTR lpTmp;

    ASSERT(lpPath);

    if ( GetModuleFileName( g_hInst, lpPath, size ) )
    {

        lpTmp = CharPrev( lpPath, lpPath+lstrlen(lpPath));

        // chop filename off
        //
        while ( (lpTmp > lpPath) && *lpTmp && (*lpTmp != '\\') )
        lpTmp = CharPrev( lpPath, lpTmp );

        if ( *CharPrev( lpPath, lpTmp ) != ':' )
            *lpTmp = '\0';
        else
            *CharNext( lpTmp ) = '\0';
        return TRUE;
    }

    return FALSE;
}

HINSTANCE MyLoadLibrary( LPSTR lpFile )
{
    CHAR szPath[MAX_PATH];
    HINSTANCE hInst = NULL;
    DWORD dwAttr;

    ASSERT( lpFile );

    if ( GetThisModulePath( szPath, sizeof(szPath) ) )
    {
        AddPath( szPath, lpFile );
        if ( ((dwAttr = GetFileAttributes(szPath)) != -1) &&
             !( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) )
        {
            hInst = LoadLibraryEx( szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
        }
    }

    // If we did not load the DLL yet, try plain LoadLibrary
    if (hInst == NULL)
        hInst = LoadLibrary( lpFile );

    return hInst;
}

// typedef into advpack.h file
//typedef struct tagVERHEAD {
//    WORD wTotLen;
//    WORD wValLen;
//    WORD wType;         /* always 0 */
//    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
//    VS_FIXEDFILEINFO vsf;
//} VERHEAD ;

/*
 *  MyGetFileVersionInfo: Maps a file directly without using LoadLibrary.  This ensures
 *   that the right version of the file is examined without regard to where the loaded image
 *   is.  Since this is local, it allocates the memory which is freed by the caller.
 */
BOOL
NTGetFileVersionInfo(LPTSTR lpszFilename, LPVOID *lpVersionInfo)
{
    VS_FIXEDFILEINFO  *pvsFFI = NULL;
    UINT              uiBytes = 0;
    HINSTANCE         hinst;
    HRSRC             hVerRes;
    HANDLE            FileHandle = NULL;
    HANDLE            MappingHandle = NULL;
    LPVOID            DllBase = NULL;
    VERHEAD           *pVerHead;
    BOOL              bResult = FALSE;
    DWORD             dwHandle;
    DWORD             dwLength;

    if (!lpVersionInfo)
        return FALSE;

    *lpVersionInfo = NULL;

    FileHandle = CreateFile( lpszFilename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL
                            );
    if (FileHandle == INVALID_HANDLE_VALUE)
        goto Cleanup;

    MappingHandle = CreateFileMapping( FileHandle,
                                        NULL,
                                        PAGE_READONLY,
                                        0,
                                        0,
                                        NULL
                                      );

    if (MappingHandle == NULL)
        goto Cleanup;

    DllBase = MapViewOfFileEx( MappingHandle,
                               FILE_MAP_READ,
                               0,
                               0,
                               0,
                               NULL
                             );
    if (DllBase == NULL)
        goto Cleanup;

    hinst = (HMODULE)((ULONG_PTR)DllBase | 0x00000001);

    hVerRes = FindResource(hinst, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO);
    if (hVerRes == NULL)
    {
        // Probably a 16-bit file.  Fall back to system APIs.
        if(!(dwLength = GetFileVersionInfoSize(lpszFilename, &dwHandle)))
        {
            if(!GetLastError())
                SetLastError(ERROR_RESOURCE_DATA_NOT_FOUND);
            goto Cleanup;
        }

        if(!(*lpVersionInfo = LocalAlloc(LPTR, dwLength)))
            goto Cleanup;

        if(!GetFileVersionInfo(lpszFilename, 0, dwLength, *lpVersionInfo))
            goto Cleanup;

        bResult = TRUE;
        goto Cleanup;
    }

    pVerHead = (VERHEAD*)LoadResource(hinst, hVerRes);
    if (pVerHead == NULL)
        goto Cleanup;

    *lpVersionInfo = LocalAlloc(LPTR, pVerHead->wTotLen + pVerHead->wTotLen/2);
    if (*lpVersionInfo == NULL)
        goto Cleanup;

    memcpy(*lpVersionInfo, (PVOID)pVerHead, pVerHead->wTotLen);
    bResult = TRUE;

Cleanup:
    if (FileHandle)
        CloseHandle(FileHandle);
    if (MappingHandle)
        CloseHandle(MappingHandle);
    if (DllBase)
        UnmapViewOfFile(DllBase);
    if (*lpVersionInfo && bResult == FALSE)
        LocalFree(*lpVersionInfo);

    return bResult;
}

// this API will always get the version of the disk file

HRESULT WINAPI GetVersionFromFileEx(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion)
{
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    void FAR   *lpBuffer = NULL;
    LPVOID      lpVerBuffer;
    CHAR        szNewName[MAX_PATH];
    BOOL        bToCleanup = FALSE;
    BOOL        bContinue = FALSE;

    *pdwMSVer = *pdwLSVer = 0L;

    bContinue = NTGetFileVersionInfo(lpszFilename, &lpBuffer);

    if ( bContinue )
    {
        if (bVersion)
        {
            // Get the value for Translation
            if (VerQueryValue(lpBuffer, "\\", (LPVOID*)&lpVSFixedFileInfo, &uiSize) &&
                             (uiSize))

            {
                *pdwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                *pdwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
            }
        }
        else
        {
            if (VerQueryValue(lpBuffer, "\\VarFileInfo\\Translation", &lpVerBuffer, &uiSize) &&
                            (uiSize))
            {
                *pdwMSVer = LOWORD(*((DWORD *) lpVerBuffer));   // Language ID
                *pdwLSVer = HIWORD(*((DWORD *) lpVerBuffer));   // Codepage ID
            }
        }
    }

    if ( bToCleanup )
        DeleteFile( szNewName );
    if ( lpBuffer )
        LocalFree( lpBuffer );
    return  S_OK;
}

//this api will get the version of the file being loaded

HRESULT WINAPI GetVersionFromFile(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion)
{
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    void FAR   *lpBuffer;
    LPVOID      lpVerBuffer;
    CHAR        szNewName[MAX_PATH];
    BOOL        bToCleanup = FALSE;

    *pdwMSVer = *pdwLSVer = 0L;

    dwVerInfoSize = GetFileVersionInfoSize(lpszFilename, &dwHandle);
    lstrcpy( szNewName, lpszFilename );
    if ( (dwVerInfoSize == 0) && FileExists( szNewName ) )
    {
        CHAR szPath[MAX_PATH];
        // due to version.dll bug, file in extended character path will failed version.dll apis.
        // So we copy it to a normal path and get its version info from there then clean it up.
        GetWindowsDirectory( szPath, sizeof(szPath) );
        GetTempFileName( szPath, "_&_", 0, szNewName );
        CopyFile( lpszFilename, szNewName, FALSE );
        bToCleanup = TRUE;
        dwVerInfoSize = GetFileVersionInfoSize( szNewName, &dwHandle );
    }

    if (dwVerInfoSize)
    {
        // Alloc the memory for the version stamping
        lpBuffer = LocalAlloc(LPTR, dwVerInfoSize);
        if (lpBuffer)
        {
            // Read version stamping info
            if (GetFileVersionInfo(szNewName, dwHandle, dwVerInfoSize, lpBuffer))
            {
                if (bVersion)
                {
                    // Get the value for Translation
                    if (VerQueryValue(lpBuffer, "\\", (LPVOID*)&lpVSFixedFileInfo, &uiSize) &&
                                     (uiSize))

                    {
                        *pdwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                        *pdwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
                    }
                }
                else
                {
                    if (VerQueryValue(lpBuffer, "\\VarFileInfo\\Translation", &lpVerBuffer, &uiSize) &&
                                    (uiSize))
                    {
                        *pdwMSVer = LOWORD(*((DWORD *) lpVerBuffer));   // Language ID
                        *pdwLSVer = HIWORD(*((DWORD *) lpVerBuffer));   // Codepage ID
                    }
                }
            }
            LocalFree(lpBuffer);
        }
    }

    if ( bToCleanup )
        DeleteFile( szNewName );
    return  S_OK;
}



#define WININIT_INI    "wininit.ini"

// when the files is busy, adding them to wininit.ini
//
BOOL AddWinInit( LPSTR from, LPSTR to)
{
    LPSTR  lpWininit;
    BOOL    bRet = FALSE;

    if ( ctx.wOSVer == _OSVER_WIN95 )
    {
        lpWininit = (LPSTR) LocalAlloc( LPTR, MAX_PATH );
        if ( !lpWininit )
        {
            ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
            return FALSE;
        }

        GetWindowsDirectory( lpWininit, MAX_PATH);
        AddPath( lpWininit, WININIT_INI);

        WritePrivateProfileString( NULL, NULL, NULL, lpWininit );

        if ( WritePrivateProfileString( "Rename", to, from, lpWininit ) )
            bRet = TRUE;

        WritePrivateProfileString( NULL, NULL, NULL, lpWininit );

        LocalFree( lpWininit );
    }
    else
    {
        bRet = MoveFileEx(from, to, MOVEFILE_DELAY_UNTIL_REBOOT | MOVEFILE_REPLACE_EXISTING);
    }
    return bRet;
}

void GetBackupName( LPSTR lpName, BOOL fOld )
{
    LPSTR pTmp;
    LPSTR pExt;

#define BACK_OLD ".~ol"
#define BACK_NEW ".~nw"

    if ( fOld )
       pExt = BACK_OLD;
    else
       pExt = BACK_NEW;

    pTmp = CharPrev( lpName, lpName + lstrlen(lpName) );

    while ( (pTmp>lpName) && *pTmp && (*pTmp != '\\') && (*pTmp != '.') )
    {
        pTmp = CharPrev( lpName, pTmp );
    }
    if ( (pTmp==lpName) || (*pTmp == '\\') )
    {
        lstrcat( lpName, pExt );
    }
    else
    {
        lstrcpy( pTmp, pExt );
    }

}

BOOL UpdateHelpDlls( LPCSTR *ppszDlls, INT numDlls, LPSTR pszPath, LPSTR pszMsg, DWORD dwFlag)
{
     DWORD   dwSysMsV, dwSysLsV, dwTmpMsV, dwTmpLsV;
     int     i = 0;
     LPSTR  pSysEnd;
     LPSTR  pTmpEnd;
     CHAR   szTmpPath[MAX_PATH] = { 0 };
     CHAR   szSystemPath[MAX_PATH] = { 0 };
     CHAR   szBuf[MAX_PATH];
     BOOL   fCopySucc = TRUE;
     BOOL   bRet = TRUE;
     BOOL   fBackup[3] = {0};
     BOOL   bAlertReboot = FALSE;

     // This function is used to update all the help Dlls: advpack, setupapi or setupx
     // based on passed in ppDlls

     // if not path passed in, get the module path (tmp path)
     if (pszPath==NULL)
     {
         if (!GetThisModulePath( szTmpPath, sizeof(szTmpPath) ) )
         {
            DEBUGMSG("Can not get ModuleFileName directory");
            return FALSE;
         }
     }
     else
         lstrcpy( szTmpPath, pszPath);

     pTmpEnd = szTmpPath + lstrlen(szTmpPath);

     // check if the newer or equal version files exist
     if ( !GetSystemDirectory( szSystemPath, sizeof(szSystemPath) ) )
     {
         DEBUGMSG("Can not get system directory");
         return FALSE;
     }
     pSysEnd = szSystemPath + lstrlen(szSystemPath);

     // check if the.dll need to be updated
     //
     for ( i = 0; i < numDlls; i += 1 )
     {
        // restore the systemPath and ModulePath
        *pTmpEnd = '\0';
        *pSysEnd = '\0';

        AddPath( szTmpPath, ppszDlls[i] );

        if ( GetFileAttributes( szTmpPath ) == -1 )
        {
            continue;
        }
        GetVersionFromFile( szTmpPath, &dwTmpMsV, &dwTmpLsV, TRUE );

        AddPath( szSystemPath, ppszDlls[i] );
        if ( GetFileAttributes( szSystemPath ) != -1 )
        {
            GetVersionFromFile( szSystemPath, &dwSysMsV, &dwSysLsV, TRUE );

            // compare if we need to copy those files
            //
            if ( (dwSysMsV > dwTmpMsV) ||
                 ((dwSysMsV == dwTmpMsV) && (dwSysLsV >= dwTmpLsV)) )
            {
                continue;
            }
            SetFileAttributes( szSystemPath, FILE_ATTRIBUTE_NORMAL );

            //backup the original files first
            lstrcpy( szBuf, szSystemPath );
            GetBackupName( szBuf, TRUE );
            SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
            DeleteFile( szBuf );
            if ( MoveFile( szSystemPath, szBuf ) )
            {
                fBackup[i] = TRUE;
            }
        }

        if ( !CopyFile( szTmpPath, szSystemPath, FALSE ) )
        {
            //if forced to update
            if ( dwFlag & UPDHLPDLLS_FORCED )
            {
                // copy to a basename.000 format
                lstrcpy( szBuf, szSystemPath );
                // get the temp name in destination dir to copy to
                GetBackupName( szBuf, FALSE );
                SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
                if ( CopyFile( szTmpPath, szBuf, FALSE ) )
                {
                    if ( AddWinInit( szBuf, szSystemPath ) )
                    {
                        if (dwFlag & UPDHLPDLLS_ALERTREBOOT)
                            bAlertReboot = TRUE;
                        continue;
                    }
                    else
                        bRet = FALSE;
                }
                else
                {
                    wsprintf( szBuf, "Cannot create TMP file for %s Dll.", pszMsg );
                    DEBUGMSG(szBuf);
                    bRet = FALSE;
                }
            }

            // you are here, means the current CopyFile/delay-CopyFile failed.
            // restore the original state, clean-up backup file if there.
            //

            while ( i >= 0 )
            {
                if ( fBackup[i] )
                {
                    *pSysEnd = '\0';
                    AddPath( szSystemPath, ppszDlls[i] );
                    lstrcpy( szBuf, szSystemPath );
                    GetBackupName( szBuf, TRUE );
                    SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
                    DeleteFile( szSystemPath );
                    if( !MoveFile( szBuf, szSystemPath ) )
                    {
                        wsprintf(szBuf, "Cannot restore %s dlls.", pszMsg);
                        DEBUGMSG(szBuf);
                    }
                }
                i--;
            }

            fCopySucc = FALSE;
            break;
        }
     }

     // clean up .~ol files
     if ( fCopySucc )
     {
        for ( i=0; i<numDlls; i++)
        {
            if ( fBackup[i] )
            {
                *pSysEnd = '\0';
                AddPath( szSystemPath, ppszDlls[i]);
                lstrcpy( szBuf, szSystemPath );
                GetBackupName( szBuf, TRUE );
                SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
                DeleteFile( szBuf );
            }
        }

        // if caller want ot alert reboot, means that they want to get false return if the dlls is not
        // in place now.
        if (bAlertReboot)
            bRet = FALSE;
     }
     return bRet;
}

void MyRemoveDirectory( LPSTR szFolder )
{
    while ( RemoveDirectory( szFolder ) )
    {
        GetParentDir( szFolder );
    }
}


BOOL IsDrvChecked( char chDrv )
{
    static char szDrvChecked[MAX_NUM_DRIVES] = { 0 };
    int idx;

    idx = (CHAR)CharUpper( (PSTR)chDrv ) - 'A';

    if ( szDrvChecked[idx] )
        return TRUE;
    else
        szDrvChecked[idx] = chDrv;

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: DelNode
//
// SYNOPSIS:    Deletes a file or directory
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#define ADN_NO_SAFETY_CHECKS    0x40000000                                  // undocumented flag

HRESULT WINAPI DelNode(LPCSTR pszFileOrDirName, DWORD dwFlags)
{
    HRESULT hResult = S_OK;

    // we won't handle relative paths and UNC's(unless flag specified)
    // BUGBUG: <oliverl> we're not checking for UNC server here

    if (!IsFullPath(pszFileOrDirName)  ||  
        (pszFileOrDirName[0] == '\\' && pszFileOrDirName[1] == '\\' && 
        !(dwFlags & ADN_DEL_UNC_PATHS)))
        return E_FAIL;

    if (!(GetFileAttributes(pszFileOrDirName) & FILE_ATTRIBUTE_DIRECTORY))  // file
    {
        SetFileAttributes(pszFileOrDirName, FILE_ATTRIBUTE_NORMAL);
        if (!DeleteFile(pszFileOrDirName))
            hResult = E_FAIL;
    }
    else if (dwFlags & ADN_DEL_IF_EMPTY)                                    // delete the dir only if it's empty
    {
        SetFileAttributes(pszFileOrDirName, FILE_ATTRIBUTE_NORMAL);
        if (!RemoveDirectory(pszFileOrDirName))
            hResult = E_FAIL;
    }
    else                                                                    // delete the node
    {
        char szFile[MAX_PATH], *pszPtr;
        WIN32_FIND_DATA fileData;
        HANDLE hFindFile;

        if (!(dwFlags & ADN_NO_SAFETY_CHECKS))
        {
            // if pszFileOrDirName is the root dir or windows dir or system dir or
            // Program Files dir, return E_FAIL; this is just a safety precaution
            hResult = DirSafe(pszFileOrDirName);
        }

        if (SUCCEEDED(hResult))
        {
            lstrcpy(szFile, pszFileOrDirName);
            AddPath(szFile, "");
            pszPtr = szFile + lstrlen(szFile);                              // save this position

            lstrcpy(pszPtr, "*");

            if ((hFindFile = FindFirstFile(szFile, &fileData)) != INVALID_HANDLE_VALUE)
            {
                do
                {
                    // skip "." and ".."; if ADN_DONT_DEL_SUBDIRS is specified, skip all sub-dirs
                    if ((fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)  &&
                        (lstrcmp(fileData.cFileName, ".") == 0  ||
                         lstrcmp(fileData.cFileName, "..") == 0 ||
                         (dwFlags & ADN_DONT_DEL_SUBDIRS)))
                        continue;

                    lstrcpy(pszPtr, fileData.cFileName);

                    // we need to pass along the ADN_DEL_UNC_PATHS flag, but all other flags
                    // are only for the top level node

                    if (dwFlags & ADN_DEL_UNC_PATHS)
                        hResult = DelNode(szFile, ADN_DEL_UNC_PATHS);
                    else
                        hResult = DelNode(szFile, 0);                           // delete the file or sub-dir
                } while (SUCCEEDED(hResult)  &&  FindNextFile(hFindFile, &fileData));

                FindClose(hFindFile);

                if (SUCCEEDED(hResult)  &&  !(dwFlags & ADN_DONT_DEL_DIR))
                {
                    // delete the dir; if DelNode fails, it's an error condition if ADN_DONT_DEL_SUBDIRS is not specified

                    if (dwFlags & ADN_DEL_UNC_PATHS)
                    {
                        if (FAILED(DelNode(pszFileOrDirName, ADN_DEL_IF_EMPTY | ADN_DEL_UNC_PATHS))  &&
                            !(dwFlags & ADN_DONT_DEL_SUBDIRS))
                            hResult = E_FAIL;
                    }
                    else
                    {
                        if (FAILED(DelNode(pszFileOrDirName, ADN_DEL_IF_EMPTY))  &&  !(dwFlags & ADN_DONT_DEL_SUBDIRS))
                            hResult = E_FAIL;
                    }

                }
            }
            else
                hResult = E_FAIL;
        }
    }

    return hResult;
}


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: DelNodeRunDLL32
//
// SYNOPSIS:    Deletes a file or directory; the parameters to this API are of
//              WinMain type
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI DelNodeRunDLL32(HWND hwnd, HINSTANCE hInstance, PSTR pszParms, INT nShow)
{
    PSTR pszFileOrDirName = GetStringField(&pszParms, ",", '\"', TRUE);
    PSTR pszFlags = GetStringField(&pszParms, ",", '\"', TRUE);

    return DelNode(pszFileOrDirName, (pszFlags != NULL) ? My_atol(pszFlags) : 0);
}


HRESULT DirSafe(LPCSTR pszDir)
// If pszDir is the root drive of windows dir or windows dir or system dir or
// Program Files dir, return E_FAIL; otherwise, return S_OK
{
    char szUnsafeDir[MAX_PATH], szDir[MAX_PATH];

    lstrcpy(szDir, pszDir);
    AddPath(szDir, "");

    *szUnsafeDir = '\0';
    GetWindowsDirectory(szUnsafeDir, sizeof(szUnsafeDir));
    AddPath(szUnsafeDir, "");

    if (lstrcmpi(szDir, szUnsafeDir) == 0)              // windows dir
        return E_FAIL;
    else
    {
        szUnsafeDir[3] = '\0';

        if (lstrcmpi(szDir, szUnsafeDir) == 0)          // root drive of windows dir
            return E_FAIL;
        else
        {
            *szUnsafeDir = '\0';
            GetSystemDirectory(szUnsafeDir, sizeof(szUnsafeDir));
            AddPath(szUnsafeDir, "");

            if (lstrcmpi(szDir, szUnsafeDir) == 0)      // system dir
                return E_FAIL;
            else
            {
                *szUnsafeDir = '\0';
                GetProgramFilesDir(szUnsafeDir, sizeof(szUnsafeDir));
                AddPath(szUnsafeDir, "");

                if (lstrcmpi(szDir, szUnsafeDir) == 0)  // program files dir
                    return E_FAIL;
                else
                {
                    // check for the short pathname of the program files dir
                    GetShortPathName(szUnsafeDir, szUnsafeDir, sizeof(szUnsafeDir));
                    AddPath(szUnsafeDir, "");

                    if (lstrcmpi(szDir, szUnsafeDir) == 0)  // short pathname of program files dir
                        return E_FAIL;
                }
            }
        }
    }

    return S_OK;
}


void SetControlFont()
{
   LOGFONT lFont;
   if (GetSystemMetrics(SM_DBCSENABLED) &&
       (GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof (lFont), &lFont) > 0))
   {
       g_hFont = CreateFontIndirect((LPLOGFONT)&lFont);
   }
}

void SetFontForControl(HWND hwnd, UINT uiID)
{
   if (g_hFont)
   {
      SendDlgItemMessage(hwnd, uiID, WM_SETFONT, (WPARAM)g_hFont ,0L);
   }
}

void MyGetPlatformSection(LPCSTR lpSec, LPCSTR lpInfFile, LPSTR szNewSection)
{
    OSVERSIONINFO VerInfo;
    SYSTEM_INFO SystemInfo;
    char        szSection[MAX_PATH];
    DWORD       dwReqSize = 0;


    lstrcpy(szSection, lpSec);
    lstrcpy(szNewSection, lpSec);
    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        GetSystemInfo( &SystemInfo );
        switch (SystemInfo.wProcessorArchitecture)
        {
            case PROCESSOR_ARCHITECTURE_INTEL:
                lstrcat( szSection, ".NTx86" );
                break;

            case PROCESSOR_ARCHITECTURE_AMD64:
                lstrcat( szSection, ".NTAmd64" );
                break;
            case PROCESSOR_ARCHITECTURE_IA64:
                lstrcat( szSection, ".NTIa64" );
                break;

            default:
                DEBUGMSG("MyGetPlatformSection - need to deal w/ new PROCESS_ARCHITECTURE type!!");
                ASSERT(FALSE);
                break;
        }

        if (SUCCEEDED(GetTranslatedLine(lpInfFile, szSection, 0,
                                        NULL, &dwReqSize )) && (dwReqSize!=0))
        {
            lstrcpy(szNewSection, szSection);
        }
        else
        {
            lstrcpy(szSection, lpSec);
            lstrcat(szSection, ".NT");
            if (SUCCEEDED(GetTranslatedLine(lpInfFile, szSection, 0,
                                            NULL, &dwReqSize )) && (dwReqSize!=0))
                lstrcpy(szNewSection, szSection);
        }
    }
    else
    {
        lstrcat(szSection, ".WIN");
        if (SUCCEEDED(GetTranslatedLine(lpInfFile, szSection, 0,
                                        NULL, &dwReqSize )) && (dwReqSize!=0))
            lstrcpy(szNewSection, szSection);
    }
}

typedef HRESULT (WINAPI *PFProcessDownloadSection)(HINF, HWND, BOOL, LPCSTR, LPCSTR, LPVOID); 

HRESULT  RunPatchingCommands(PCSTR c_pszInfFilename, PCSTR szInstallSection, PCSTR c_pszSourceDir)
{
    CHAR  szBuf[512];
    CHAR  szDllName[MAX_PATH];
    HRESULT hResult = S_OK;
    INFCONTEXT InfContext;
    static const CHAR c_szPatching[] = "Patching";
    static const CHAR c_szAdvpackExt[] = "LoadAdvpackExtension";
    

    //Check if patching is enabled for this section
    if(!GetTranslatedInt(c_pszInfFilename, szInstallSection, c_szPatching, 0))
    {
        goto done;
    }

    //Read the dllname and entry point from LoadAdvpackExtension= line 
    if(FAILED(GetTranslatedString(c_pszInfFilename, szInstallSection, c_szAdvpackExt, szBuf, sizeof(szBuf), NULL)))
    {
        goto done;
    }

    //Got the extension dll 
    if(GetFieldString(szBuf, 0, szDllName, sizeof(szDllName)))
    {
        CHAR szEntryPoint[MAX_PATH];
        HINSTANCE hInst = LoadLibrary(szDllName);
        if(!hInst)
        {
             hResult = HRESULT_FROM_WIN32(GetLastError());
             goto done;
        }

        if(GetFieldString(szBuf, 1, szEntryPoint, sizeof(szEntryPoint)))
        {
            PFProcessDownloadSection pfn = (PFProcessDownloadSection)GetProcAddress(hInst, szEntryPoint);
            if(!pfn)
            {
                 hResult = HRESULT_FROM_WIN32(GetLastError());
                 goto done;
            }

            hResult = pfn(ctx.hInf, ctx.hWnd, ctx.wQuietMode, szInstallSection, c_pszSourceDir, NULL);
        }

        FreeLibrary(hInst);

    }

done:

    return hResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\crc32.h ===
/***    crc32.h - 32-bit CRC generator
 *
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Mike Sliger
 *
 *  History:
 *      10-Aug-1993 bens    Copied from IMG2DMF directory.
 *
 *  Usage:
 *      ULONG   crc;
 *      //** Compute first block
 *      crc = CRC32Compute(pb,cb,CRC32_INITIAL_VALUE);
 *      //** Compute remaining blocks
 *      crc = CRC32Compute(pb,cb,crc);
 *      ...
 *      //** When you're done, crc has the CRC.
 *
 *      NOTE: See example function getFileChecksum() below that
 *            computes the checksum of a file!
 */

// ** Must use this as initial value for CRC
#define CRC32_INITIAL_VALUE 0L


/***    CRC32Compute - Compute 32-bit
 *
 *  Entry:
 *      pb    - Pointer to buffer to computer CRC on
 *      cb    - Count of bytes in buffer to CRC
 *      crc32 - Result from previous CRC32Compute call (on first call
 *              to CRC32Compute, must be CRC32_INITIAL_VALUE!!!!).
 *
 *  Exit:
 *      Returns updated CRC value.
 */

DWORD CRC32Compute(BYTE *pb,unsigned cb,ULONG crc32);


//** Include nice sample -- don't compile it
//
#ifdef HERE_IS_A_SAMPLE

/***    getFileChecksum - Compute file checksum
 *
 *  Entry:
 *      pszFile     - Filespec
 *      pchecksum   - Receives 32-bit checksum of file
 *      perr        - ERROR structure
 *
 *  Exit-Success:
 *      Returns TRUE, *pchecksum filled in.
 *
 *  Exit-Failure:
 *      Returns FALSE; perr filled in with error.
 */
BOOL getFileChecksum(char *pszFile, ULONG *pchecksum, PERROR perr)
{
#define cbCSUM_BUFFER   4096            // File buffer size
    int     cb;                         // Amount of data in read buffer
    ULONG   csum=CRC32_INITIAL_VALUE;   // Initialize CRC
    char   *pb=NULL;                    // Read buffer
    int     hf=-1;                      // File handle
    int     rc;
    BOOL    result=FALSE;               // Assume failure

    //** Initialize returned checksum (assume failure)
    *pchecksum = csum;

    //** Allocate file buffer
    if (!(pb = MemAlloc(cbCSUM_BUFFER))) {
        ErrSet(perr,pszDIAERR_NO_MEMORY_CRC,"%s",pszFile);
        return FALSE;
    }

    //** Open file
    hf = _open(pszFile,_O_RDONLY | _O_BINARY,&rc);
    if (hf == -1) {
        ErrSet(perr,pszDIAERR_OPEN_FAILED,"%s",pszFile);
        goto Exit;
    }

    //** Compute checksum
    while (_eof(hf) == 0) {
        cb = _read(hf,pb,cbCSUM_BUFFER);
        if (cb == -1) {
            ErrSet(perr,pszDIAERR_READ_FAIL_CRC,"%s",pszFile);
            goto Exit;
        }
        if (cb != 0) {
            csum = CRC32Compute(pb,cb,csum); // Accumulate CRC
        }
    }

    //** Success
    result = TRUE;
    *pchecksum = csum;                  // Store checksum for caller

Exit:
    if (hf != -1) {
        _close(hf);
    }
    if (pb != NULL) {
        MemFree(pb);
    }
    return result;
} /* getFileChecksum() */

#endif // HERE_IS_A_SAMPLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\mrcicode.h ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.H
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */

#ifndef FAR
#ifdef BIT16
#define     FAR     _far
#else
#define     FAR
#endif
#endif

#ifdef __cplusplus
extern "C"
{
#endif

extern unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

extern unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\globals.c ===
#include <windows.h>
#include <setupapi.h>
#include "globals.h"
#include "advpack.h"

//
// Note that the global context is initialized to all zeros.
//
ADVCONTEXT ctx = {
    0,                  // wOSVer
    0,                  // wQuietMode
    0,                  // bUpdHlpDlls
    NULL,               // hSetupLibrary
    FALSE,              // fOSSupportsINFInstalls
    NULL,               // lpszTitle
    NULL,               // hWnd
    ENGINE_SETUPAPI,    // dwSetupEngine
    FALSE,              // bCompressed
    { 0 },              // szBrowsePath
    NULL,               // hInf
    FALSE,				// bHiveLoaded
    { 0 }				// szRegHiveKey
};

DWORD cctxSaved = 0;
PADVCONTEXT pctxSave = NULL;
HINSTANCE g_hInst = NULL;
HANDLE g_hAdvLogFile = INVALID_HANDLE_VALUE;

BOOL SaveGlobalContext()
{
    if (pctxSave)
    {
        PADVCONTEXT pctxNew = LocalReAlloc(pctxSave, (cctxSaved + 1) * sizeof(ADVCONTEXT), LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (!pctxNew)
        {
            return FALSE;
        }
        pctxSave = pctxNew;
    }
    else
    {
        pctxSave = LocalAlloc(LPTR, sizeof(ADVCONTEXT));
        if (!pctxSave)
        {
            return FALSE;
        }
    }

    pctxSave[cctxSaved++] = ctx;

    //
    // Note that the global context is initialized to all zeros except the HINSTANCE
    // of this module
    //
    memset(&ctx, 0, sizeof(ADVCONTEXT));

    return TRUE;
}

BOOL RestoreGlobalContext()
{
    if (!cctxSaved)
    {
        return FALSE;
    }

	// before we release the current contex:ctx to make sure there is no opened handle not being released
	if (ctx.hSetupLibrary)
	{
		CommonInstallCleanup();
	}
    cctxSaved--;
    ctx = pctxSave[cctxSaved];
    if (cctxSaved)
    {
        PADVCONTEXT pctxNew = LocalReAlloc(pctxSave, cctxSaved * sizeof(ADVCONTEXT), LMEM_MOVEABLE | LMEM_ZEROINIT);

        if (pctxNew)
        {
            pctxSave = pctxNew;
        }
    }
    else
    {
        LocalFree(pctxSave);
        pctxSave = NULL;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\extract.c ===
#include <windows.h>
#include <winerror.h>
#include <ole2.h>
#include "cpldebug.h"
#include "cab_dll.h"



//typedef HRESULT (WINAPI *EXTRACT) (PSESSION psess, LPCSTR lpCabName);

VOID FreeFileList(PSESSION psess);
VOID FreeFileNode(PFNAME pfname);
BOOL IsFileInList(LPSTR pszFile, LPSTR pszFileList);
int PrepareFileList(LPSTR pszOutFileList, LPCSTR pszInFileList);

// BUGBUG: Minimum version of Cabinet DLL that supports the new Extract API
// the one that was formerly in URLMON.DLL.
//
#define MIN_CABINETDLL_MSVER 0
#define MIN_CABINETDLL_LSVER 0

//=--------------------------------------------------------------------------=
// ExtractFiles
//=--------------------------------------------------------------------------=
//
// Parameters:
//    LPCSTR	pszCabName	- [in]  full qualified filename to the .CAB file
//    LPCSTR	pszExpandDir- [in]  full qualified path to where to extract the file(s)
//    DWORD     dwFlags		- [in]  Flags, currently not used
//    LPCSTR    pszFileList - [in]  colon separated list of files to extract from pszCabName
//                                  or NULL for all files
//    LPVOID    lpReserved  - [in]  currently not used
//    DWORD		dwReserved	- [in]  currently not used
//
// Return HRESULT:
//      E_INVALIDARG    - if pszCabName or pszExpandDir == NULL
//      E_OUTOFMEMORY   - if we could not allocate our memory
//      E_FAIL          - if no files in pszFileList and pszFileList!=NULL
//                        if not all files from pszFileList are in the .CAB file
//                        if Extract return S_FALSE
//      any E_ code Extract returns
//
// Note: This function would not extract any file from the pszFileList, if not all
//       of them are in the .CAB file. If one or more are not in the .CAB file
//       the function does not extract any and returns E_FAIL
//
HRESULT WINAPI ExtractFiles( LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags,
                             LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved)
{
    HINSTANCE hinst;
    PSESSION  psess = NULL;
    PFNAME    pf = NULL;
    PFNAME    pfPriv = NULL;
    HRESULT   hr = E_FAIL;          // Return error
    LPSTR     pszMyFileList = NULL;
    PFN_EXTRACT   fpExtract = NULL;
    PFN_DLLGETVERSION fpGetVer = NULL;
    int       iFiles = 0;    // number of files in list
    CABINETDLLVERSIONINFO cabDllVer;

    // Do checking for valid values??
    if ((!pszCabName) || (!pszExpandDir))
        return E_INVALIDARG;

    hinst = LoadLibrary("CABINET.DLL");
    if (hinst)
    {
        fpGetVer = (PFN_DLLGETVERSION)GetProcAddress(hinst, "DllGetVersion");

        // Make sure this is the CABINET.DLL that supports the Extract API
        //
        if ( fpGetVer )
        {
            cabDllVer.cbStruct = sizeof(cabDllVer);
            fpGetVer( &cabDllVer );
            if ( (cabDllVer.dwFileVersionMS > MIN_CABINETDLL_MSVER) ||
                 (cabDllVer.dwFileVersionMS == MIN_CABINETDLL_MSVER) /* && (cabDllVer.dwFileVersionLS >= MIN_CABINETDLL_LSVER) */ )
            {
                fpExtract = (PFN_EXTRACT)GetProcAddress(hinst, "Extract");
            }
        }

        if (!fpExtract)
            FreeLibrary(hinst);
    }

    // If we did not get the Extract() API from cabinet.dll go for
    // URLMON.DLL
    //
    if (!fpExtract)
    {
        hinst = LoadLibrary("URLMON.DLL");
        if (hinst)
            fpExtract = (PFN_EXTRACT)GetProcAddress(hinst, "Extract");
    }

    if (fpExtract)
    {
        psess = (PSESSION)LocalAlloc(LPTR, sizeof(SESSION));
        if (psess) 
        {
            lstrcpy(psess->achLocation, pszExpandDir);
            // Initialize the structure
            if (pszFileList == NULL)
            {
                // Extract all
                psess->flags = SESSION_FLAG_EXTRACT_ALL|SESSION_FLAG_ENUMERATE;
                hr = fpExtract(psess, pszCabName);
                // BUGBUG: What if psess->erf reports an error??
            }
            else
            {
                // I append a '/0' therefor +2
                pszMyFileList = (LPSTR)LocalAlloc(LPTR, lstrlen(pszFileList)+2);
                if (pszMyFileList)
                {
                    iFiles = PrepareFileList(pszMyFileList, pszFileList);
                    psess->flags = SESSION_FLAG_ENUMERATE;

                    if  ((iFiles > 0) &&
                         ( !FAILED(hr = fpExtract(psess, pszCabName)) ))
                        // What if psess->erf reports an error??
                    {
                    // If there are files in the list and we enumarated files
                    
                        // Got the list of files in the cab
                        pfPriv = NULL;
                        pf = psess->pFileList;
                        while (pf != NULL )
                        {
                            if (!IsFileInList(pf->pszFilename, pszMyFileList))
                            {
                                // Delete the node from the list
                                if (pfPriv == NULL)
                                {
                                    // Delete the head
                                    psess->pFileList = pf->pNextName;
                                    FreeFileNode(pf);
                                    pf = psess->pFileList;
                                }
                                else
                                {
                                    pfPriv->pNextName = pf->pNextName;
                                    FreeFileNode(pf);
                                    pf = pfPriv->pNextName;
                                }
                            }
                            else
                            {
                                // Just go to the next one
                                pfPriv = pf;
                                pf = pf->pNextName;
                                iFiles--;
                            }
                        }

                        if ((psess->pFileList) && (iFiles == 0))
                        {
                            // Reset the error flag
                            psess->erf.fError = FALSE;
                            psess->erf.erfOper = 0;

                            psess->pFilesToExtract = psess->pFileList;
                            psess->flags &= ~SESSION_FLAG_ENUMERATE; // already enumerated
                            hr = fpExtract(psess, pszCabName);
                            // BUGBUG: What if psess->erf reports an error??
                        }
                        else
                            hr = E_FAIL;    // File(s) is not in cab.
                    }

                    LocalFree(pszMyFileList);
                    pszMyFileList = NULL;

                }
                else
                    hr = E_OUTOFMEMORY;
            }
            FreeFileList(psess);
            LocalFree(psess);
            psess = NULL;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    if (hinst)
        FreeLibrary(hinst);

    // Extract may only return S_FALSE in a failure case.
    if (!FAILED(hr) && (hr == S_FALSE))
        hr = E_FAIL;

    return (hr);
}


VOID FreeFileList(PSESSION psess)
{
    PFNAME      rover = psess->pFileList;
    PFNAME      roverprev;

    while (rover != NULL)  
    {

        roverprev = rover;  // save for free'ing current rover below
        rover = rover->pNextName;

        FreeFileNode(roverprev);
    }

    psess->pFileList = NULL; // prevent use after deletion!
}

VOID FreeFileNode(PFNAME pfname)
{
    CoTaskMemFree(pfname->pszFilename);
    CoTaskMemFree(pfname);
}


BOOL IsFileInList(LPSTR pszFile, LPSTR pszFileList)
{
    char *p;
    int  iLenFile = lstrlen(pszFile);
    BOOL bFound = FALSE;

    p = pszFileList;
    while ((*p != '\0') && (!bFound))
    {
        if (lstrlen(p) == iLenFile)
            bFound = (lstrcmpi(p, pszFile) == 0);
        if (!bFound)
            p += lstrlen(p) + 1;
    }
    return (bFound);
}

int PrepareFileList(LPSTR pszOutFileList, LPCSTR pszInFileList)
{
    int  iFiles = 0;                // number of files in list
    char *p;
    p = (LPSTR)pszInFileList;       // p is used to point into both arrays 

    // trim leading spaces, tabs or : 
    while ((*p == ' ') || (*p == '\t') || (*p == ':'))
        p++;
    lstrcpy(pszOutFileList, p);

    p = pszOutFileList;
    if (lstrlen(pszOutFileList) > 0)
    {
        // Only if we have atleast one character left.
        // This cannot be a space of tab, because we 
        // would have removed this above.
        p += (lstrlen(pszOutFileList) - 1);

        // trim railing spaces, tabs or :
        while ((*p == ' ') || (*p == '\t') || (*p == ':'))
            p--;

        // Put a '\0' for the last space/tab
        *(++p) = '\0';
    }

    if (*pszOutFileList)
    {
        iFiles++;
        // Now replace ':' with '\0'
        p = pszOutFileList;
        while (*p != '\0')
        {
            if (*p == ':')
            {
                *p = '\0';
                iFiles++;
            }
            p++;
        }
        // Make sure we have a double '\0' at the end.
        *(++p) = '\0';
    }
    return iFiles;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\globals.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* GLOBALS.H - Global Context save / restore                               *
//*                                                                         *
//***************************************************************************

#ifndef _GLOBALS_H_
#define _GLOBALS_H_

typedef struct {
    WORD        wOSVer;
    WORD        wQuietMode;
    BOOL        bUpdHlpDlls;
    HINSTANCE   hSetupLibrary;
    BOOL        fOSSupportsINFInstalls;
    LPSTR       lpszTitle;
    HWND        hWnd;
    DWORD       dwSetupEngine;
    BOOL        bCompressed;
    char        szBrowsePath[MAX_PATH];
    HINF        hInf;
    BOOL		bHiveLoaded;
    CHAR		szRegHiveKey[MAX_PATH];
} ADVCONTEXT, *PADVCONTEXT;

extern ADVCONTEXT ctx;
extern HINSTANCE g_hInst;
extern HANDLE g_hAdvLogFile;


BOOL SaveGlobalContext();
BOOL RestoreGlobalContext();

// related to logging
VOID AdvStartLogging();
VOID AdvWriteToLog(LPCSTR pcszFormatString, ...);
VOID AdvLogDateAndTime();
VOID AdvStopLogging();

#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\execcab.c ===
//***************************************************************************
//*   Copyright (c) Microsoft Corporation 1995-1996. All rights reserved.   *
//***************************************************************************
//*                                                                         *
//* ADVPACK.C - Advanced INF Installer.                                     *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <io.h>
#include <windows.h>
#include <winerror.h>
#include <ole2.h>
#include "resource.h"
#include "cpldebug.h"
#include "ntapi.h"
#include "advpub.h"
#include "w95pub32.h"
#include "advpack.h"
#include "regstr.h"
#include "globals.h"
#include "cfgmgr32.h"
#include "sfp.h"

//***************************************************************************
//* global defines                                                          *
//***************************************************************************

#define   YES   "1"
#define   NO    "0"

#define   FILELIST_SIZE     10*BUF_1K

//***************************************************************************
//* globals                                                                 *
//***************************************************************************

INFOPT  RegInfOpt[] = { ADVINF_ADDREG, ADVINF_DELREG, ADVINF_BKREG };  // code below depending on this orders

static PSTR gst_pszFiles;    
static PSTR gst_pszEndLastFile = NULL;
static HRESULT  gst_hNeedReboot; 
static PSTR gst_pszSmartReboot = NULL;

const char c_szActiveSetupKey[] = "software\\microsoft\\Active Setup\\Installed Components";

// globals for reg backup key and file names
const char c_szRegUninstPath[] = "BackupRegPathName";
const char c_szRegUninstSize[] = "BackupRegSize";

const char c_szHiveKey_FMT[] = "AINF%04d";

// NoBackupPlatform string table
LPCSTR c_pszPlatform[] = { "win9x", "NT3.5", "NT4", "NT5", "NT5.1" };

//-----------------------------------------------------------------------------------------
//
// PerUser section defines
//
//-----------------------------------------------------------------------------------------

const CHAR REGVAL_OLDDISPN[]=         "OldDisplayName";    
const CHAR REGVAL_OLDVER[]=           "OldVersion";
const CHAR REGVAL_OLDSTUB[]=          "OldStubPath";
const CHAR REGVAL_OLDLANG[]=          "OldLocale";
const CHAR REGVAL_OLDREALSTUBPATH[]=  "OldRealStubPath";

const CHAR REGVAL_REALSTUBPATH[]=     "RealStubPath";

const CHAR ADV_UNINSTSTUBWRAPPER[]=      "rundll32.exe advpack.dll,UserUnInstStubWrapper %s";
const CHAR ADV_INSTSTUBWRAPPER[]=        "rundll32.exe advpack.dll,UserInstStubWrapper %s";

const CHAR c_szRegDontAskValue[] =    "DontAsk";
/* Check the "Don't Ask" value.  If it's present, its value
 * is interpreted as follows:
 *
 * 0 --> ask the user
 * 1 --> do not run the stub
 * 2 --> always run the stub
 */

HRESULT ProcessOneRegSec( HWND hw, PCSTR pszTitle, PCSTR pszInf, PCSTR pszSec, HKEY hKey, HKEY hCUKey, DWORD dwFlags, BOOL *lpbOneRegSave  );
UINT WINAPI MyFileQueueCallback( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 );
UINT WINAPI MyFileQueueCallback2( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 );
void CleanRegLogFile( PCSTR pcszLogFileSecName );
BOOL VerifyBackupInfo( HKEY hKey, HKEY hCUKey );
void DeleteOldBackupData( HKEY hKey );
//int DeleteSubKey(HKEY root, char *keyname);
BOOL NeedBackupData(LPCSTR pszInf, LPCSTR pszSec);
BOOL GetUniBackupName( HKEY hKey, LPSTR pszBackupBase, DWORD dwInSize, LPCSTR pszBackupPath, LPCSTR pszModule );


//***************************************************************************
extern PFSetupDefaultQueueCallback       pfSetupDefaultQueueCallback;
extern PFSetupInstallFromInfSection      pfSetupInstallFromInfSection;
extern PFSetupInitDefaultQueueCallbackEx pfSetupInitDefaultQueueCallbackEx;
extern PFSetupTermDefaultQueueCallback   pfSetupTermDefaultQueueCallback;

//***************************************************************************
//*                                                                         *
//* NAME:       LaunchINFSectionEx                                          *
//*                                                                         *
//* SYNOPSIS:   Detect which shell mode you are in and flip it over to      *
//*             the other mode                                              *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI LaunchINFSectionEx( HWND hwnd, HINSTANCE hInstance, PSTR pszParms, INT nShow )
{
    LPSTR       pszFlags;
    PCABINFO    pcabInfo = NULL;
    HRESULT     hRet = S_OK;
   
    AdvWriteToLog("LaunchINFSectionEx: Param= %1\r\n", pszParms);
    pcabInfo = (PCABINFO)LocalAlloc( LPTR, sizeof(CABINFO) );
    if ( !pcabInfo )
    {
        ErrorMsg( hwnd, IDS_ERR_NO_MEMORY );
        goto done;
    }

    // Parse the arguments, SETUP engine is not called. So we only need to check on \".
    pcabInfo->pszInf = GetStringField( &pszParms, ",", '\"', TRUE );
    pcabInfo->pszSection = GetStringField( &pszParms, ",", '\"', TRUE );
    pcabInfo->pszCab = GetStringField( &pszParms, ",", '\"', TRUE );
    pszFlags = GetStringField( &pszParms, ",", '\"', TRUE );
    gst_pszSmartReboot = GetStringField( &pszParms, ",", '\"', TRUE );

    if ( pszFlags != NULL )
        pcabInfo->dwFlags = My_atol(pszFlags);

    if ( pcabInfo->pszCab != NULL && *pcabInfo->pszCab )
    {
        if ( IsFullPath( pcabInfo->pszCab ) )
        {
            lstrcpy( pcabInfo->szSrcPath, pcabInfo->pszCab );
            GetParentDir( pcabInfo->szSrcPath );
        }
        else
        {
            ErrorMsg1Param( hwnd, IDS_ERR_CABPATH, pcabInfo->pszCab );
            goto done;
        }
    }

    // if we need to switch the mode. call ExecuteCab()
    hRet = ExecuteCab( hwnd, pcabInfo, NULL );

done:
    if ( pcabInfo )
        LocalFree( pcabInfo );
    AdvWriteToLog("LaunchINFSectionEx: End hr=0x%1!x!\r\n",hRet);
    return hRet;

}

//***************************************************************************
//*                                                                         *
//* NAME:       ExecuteCab                                                  *
//*                                                                         *
//* SYNOPSIS:   Get INF from the cab and install it based on the flag.      *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle to parent window.                    *
//*                                                                         *
//* RETURNS:    HRESULT:        See advpub.h                                *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI ExecuteCab( HWND hWnd, PCABINFO pcabInfo, PVOID pvReserved )
{
    HRESULT hRet = S_OK, hRet1 = S_OK;
    DWORD   dwFlags;
    char    szFullPathInf[MAX_PATH];
    HKEY    hKey = NULL;
    char    szSec[MAX_PATH] = { 0 };  
    DWORD   dwSecSize = sizeof(szSec);
    BOOL    bExtracF = FALSE;    
    BOOL    bExtractCatalog = FALSE;
    BOOL    fSavedContext = FALSE;
    BOOL    fTmpInf = FALSE;
    char    szModule[MAX_PATH];
    char    szCatalogName[MAX_PATH];

    AdvWriteToLog("ExecuteCab:");
    if (!SaveGlobalContext())
    {
        hRet1 = E_OUTOFMEMORY;
        goto done;
    }

    fSavedContext = TRUE;
    
    // Validate parameters:
    // if INF filename info is missing, invalid.
    if ( !pcabInfo || !(pcabInfo->pszInf) || !*(pcabInfo->pszInf) )
        return E_INVALIDARG;

    AdvWriteToLog("Inf = %1\r\n", pcabInfo->pszInf);

    ctx.hWnd      = hWnd;

    // the flag ALINF_ROLLBACKDOALL includes meaning ALINF_ROLLBACK
    // TO avoid check both flag everywhere, we set both on if DOALL
    if ( pcabInfo->dwFlags & ALINF_ROLLBKDOALL )
    {
        pcabInfo->dwFlags |= ALINF_ROLLBACK;
    }

    // if INF is 8.3 format and the Cab file is given, extract INF out of the cab. Oterwise use it as it is.
    if ( pcabInfo->pszCab && *pcabInfo->pszCab )
    {
        if ( !IsFullPath( pcabInfo->pszInf ) )
        {                
            if ( SUCCEEDED(hRet = ExtractFiles( pcabInfo->pszCab, pcabInfo->szSrcPath, 0, pcabInfo->pszInf, 0, 0) ) )
                bExtracF = TRUE;
        }
    }
    else
    {
        if ( pcabInfo->dwFlags & ALINF_ROLLBACK )
        {
            pcabInfo->dwFlags |= ALINF_ROLLBKDOALL;
        }
    }
            
    if ( !GetFullInfNameAndSrcDir( pcabInfo->pszInf, szFullPathInf, pcabInfo->szSrcPath ) )
    {
        hRet1 = E_INVALIDARG;
        goto done;
    }
   
    // if rollback case, we want to make the tmp INF file to use in case the rollback will delete the real file.
    if ( (pcabInfo->dwFlags & ALINF_ROLLBACK) && !bExtracF )
    {
        PSTR pszFile;
        char szPath[MAX_PATH];
        char ch;

        pszFile = ANSIStrRChr( szFullPathInf, '\\' );
        if ( pszFile )
        {
            ch = *pszFile;
            *pszFile = '\0';
            if ( GetTempFileName( szFullPathInf, "INF", 0, szPath ) )
            {               
                DeleteFile( szPath );
                *pszFile = ch;
                if ( CopyFile( szFullPathInf, szPath, FALSE ) )
                {            
                    AdvWriteToLog("InfFile Rename: %1 becomes %2\r\n", szFullPathInf, szPath);
                    fTmpInf = TRUE;
                    lstrcpy( szFullPathInf, szPath );
                }
            }
        }
    }


    if ( pcabInfo->pszSection )
        lstrcpy( szSec, pcabInfo->pszSection );
    GetInfInstallSectionName( szFullPathInf, szSec, dwSecSize );

    // GetComponent Name
    if ( FAILED(GetTranslatedString( szFullPathInf, szSec, ADVINF_MODNAME,
                                        szModule, sizeof(szModule), NULL)) && szModule[0])
    {
        *szModule = '\0';   // Or should we exit if we don't find a module name????
    }

    // extract the catalog, if specified
    if (pcabInfo->pszCab  &&  *pcabInfo->pszCab)
    {
        *szCatalogName = '\0';

        GetTranslatedString(szFullPathInf, szSec, ADVINF_CATALOG_NAME, szCatalogName, sizeof(szCatalogName), NULL);
        if (*szCatalogName)
        {
            if (SUCCEEDED(ExtractFiles(pcabInfo->pszCab, pcabInfo->szSrcPath, 0, szCatalogName, 0, 0)))
                bExtractCatalog = TRUE;
        }
    }

    // start Pre-rollback
    //
    dwFlags = COREINSTALL_PROMPT;
    dwFlags |= (pcabInfo->dwFlags & ALINF_NGCONV ) ? 0 : COREINSTALL_GRPCONV;
    if ( pcabInfo->dwFlags & ALINF_QUIET ) 
        ctx.wQuietMode = QUIETMODE_ALL;

    if ( pcabInfo->dwFlags & ALINF_CHECKBKDATA || pcabInfo->dwFlags & ALINF_ROLLBACK )
    {
        char szUninstall[MAX_PATH];
        CHAR szBuf[MAX_PATH];
        HKEY hCUKey = NULL;

        if ( pcabInfo->dwFlags & ALINF_ROLLBACK )
        { 
            szUninstall[0] = 0;
            if ( SUCCEEDED(GetTranslatedString( szFullPathInf, szSec, ADVINF_PREROLBK,
                                                szUninstall, sizeof(szUninstall), NULL)) && szUninstall[0])
            {
                hRet = CoreInstall( szFullPathInf, szUninstall, pcabInfo->szSrcPath, 0, dwFlags, NULL );
                if ( FAILED( hRet ) )
                {
                    hRet1 = hRet;
                    goto done;
                }
            }
        }
        // if just want to checking backup data, process here and return
        //       
        hRet1 = E_UNEXPECTED;  //if HKLM does not have the \Advance INF setup\Module, it is unexpected.s

        if (*szModule)
        {
            // backup/restore the reg info referred by AddReg, DelReg, BackupReg lines inside the INF install section
            //
            lstrcpy( szBuf, REGKEY_SAVERESTORE );
            AddPath( szBuf, szModule );
            if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, szBuf, 0, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS)
            {
                RegOpenKeyEx( HKEY_CURRENT_USER, szBuf, 0, KEY_READ, &hCUKey);
                if ( VerifyBackupInfo( hKey, hCUKey ) )                
                    hRet1 = S_OK;                
                else
                    hRet1 = E_FAIL;
            }                            

            if ( hKey )
                RegCloseKey( hKey );
            if ( hCUKey )
                RegCloseKey( hCUKey );
        }    
        if ( FAILED(hRet1) || (pcabInfo->dwFlags == ALINF_CHECKBKDATA) )
        {
            goto done;
        }
    }

    dwFlags |= (pcabInfo->dwFlags & ALINF_DELAYREGISTEROCX) ? COREINSTALL_DELAYREGISTEROCX : 0;
    dwFlags |= (pcabInfo->dwFlags & ALINF_BKINSTALL) ? COREINSTALL_BKINSTALL : 0;
    dwFlags |= (pcabInfo->dwFlags & ALINF_ROLLBACK) ? COREINSTALL_ROLLBACK : 0;
    dwFlags |= (pcabInfo->dwFlags & ALINF_ROLLBKDOALL) ? COREINSTALL_ROLLBKDOALL : 0;
    dwFlags |= COREINSTALL_SMARTREBOOT;

    hRet1 = CoreInstall( szFullPathInf, szSec, pcabInfo->szSrcPath, 0, dwFlags, gst_pszSmartReboot );                   

    // save the cab file info
    if ( SUCCEEDED( hRet1 ) && pcabInfo->pszCab && *pcabInfo->pszCab && (pcabInfo->dwFlags & ALINF_BKINSTALL) )
    {                
        if ( hRet == ERROR_SUCCESS_REBOOT_REQUIRED )
            hRet1 = hRet;

        if (*szModule)
        {
            // reuse the buf so name is not acurate!!
            lstrcpy( szSec, REGKEY_SAVERESTORE );
            AddPath( szSec, szModule );
        
            if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, szSec, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                                 NULL, &hKey, &dwFlags ) == ERROR_SUCCESS )
            {
                RegSetValueEx( hKey, REGVAL_BKINSTCAB, 0, REG_SZ, pcabInfo->pszCab, lstrlen(pcabInfo->pszCab)+1 );
                RegCloseKey( hKey );
            }
        }
    }    
    

done:
    
    if (  bExtracF || fTmpInf )
    {
        // need to delete the INF file
        DeleteFile( szFullPathInf );
    }

    if (bExtractCatalog)
    {
        char szFullCatalogName[MAX_PATH];

        lstrcpy(szFullCatalogName, pcabInfo->szSrcPath);
        AddPath(szFullCatalogName, szCatalogName);
        DeleteFile(szFullCatalogName);
    }

    if (fSavedContext)
    {
        RestoreGlobalContext();
    }
    if (pcabInfo->pszInf)
        AdvWriteToLog("ExecuteCab: End hr=0x%1!x! Inf=%2\r\n", hRet1,pcabInfo->pszInf);
    else
        AdvWriteToLog("ExecuteCab: End hr=0x%1!x!\r\n", hRet1);

    return hRet1;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

HRESULT SaveRestoreInfo( PCSTR pszInf, PCSTR pszSection, PCSTR pszSrcDir, PCSTR pszCatalogs, DWORD dwFlags )
{
    char    szBuf[MAX_PATH];
    char    szModule[MAX_PATH];
    char    szBackupPath[MAX_PATH];
    char    szBackupBase[MAX_PATH];
    UINT    uErrid = 0;
    DWORD   dwTmp;
    PSTR    pszFileList = NULL;
    BOOL    bDeleteKey = FALSE; 
    HKEY    hKey = NULL, hSubKey = NULL, hCUSubKey = NULL;
    HRESULT hRet = S_OK;
    BOOL    bAtleastOneReg = FALSE;
    DWORD   adwAttr[8];
    
    // check if we need to backup the data
    if ( !NeedBackupData(pszInf, pszSection) )
        goto done;        

    AdvWriteToLog("SaveRestoreInfo: ");
    // GetComponent Name
    if ( FAILED(GetTranslatedString( pszInf, pszSection, ADVINF_MODNAME,
                                        szModule, sizeof(szModule), NULL)))
    {
        // error out if no component name
        goto done;
    }

    AdvWriteToLog("CompName=%1 pszInf=%2 Sec=%3\r\n", szModule, pszInf, pszSection);
    // backup/restore the reg info referred by AddReg, DelReg, BackupReg lines inside the INF install section
    //
    lstrcpy( szBuf, REGKEY_SAVERESTORE );
    if ( dwFlags & COREINSTALL_BKINSTALL )
    {
        CleanRegLogFile( REG_SAVE_LOG_KEY );
        CleanRegLogFile( REG_RESTORE_LOG_KEY );
    }

    AddPath( szBuf, szModule );
    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                         NULL, &hKey, &dwTmp ) != ERROR_SUCCESS )
    {     
        // If client does not have the access to this key, we may not want to fault out the rest setup process.
        // For some reason with Read only access set, this call return error code 2 instead of 5 access denied
        // so we just skip save rollback if this can not be opened/created
        goto done;
    }

    // create HKCU branch
    AddPath( szBuf, REGSUBK_REGBK );
    if ( RegCreateKeyEx( HKEY_CURRENT_USER, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE,
                         NULL, &hCUSubKey, NULL ) != ERROR_SUCCESS )
    {
        hRet = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // get the bacup info folder
    dwTmp = sizeof( szBackupPath );
    szBackupPath[0] = 0;
    RegQueryValueEx( hKey, REGVAL_BKDIR, NULL, NULL, szBackupPath, &dwTmp );
    if ( szBackupPath[0] == 0 )
    {
        DWORD dwSize;

        // use user specified: either the same as cab location #S or default location #D
        if ( FAILED( GetTranslatedString( pszInf, pszSection, ADVINF_BACKUPPATH, szBackupPath, 
                                          sizeof(szBackupPath), &dwSize) ) || !IsFullPath( szBackupPath )  )
        {
            // use default dir
            GetProgramFilesDir( szBackupPath, sizeof( szBackupPath ) );
            AddPath( szBackupPath, DEF_BACKUPPATH );
            CreateFullPath(szBackupPath, TRUE);
            //CreateDirectory( szBackupPath, NULL );
            //if ( dwFlags & COREINSTALL_BKINSTALL )
                //SetFileAttributes( szBackupPath, FILE_ATTRIBUTE_HIDDEN );
            AddPath( szBackupPath, szModule );
        }
    }

    // set the flags and Process the AddReg/DelReg lines 
    dwTmp = (dwFlags & COREINSTALL_ROLLBACK) ? IE4_RESTORE : 0;
    dwTmp |= (dwFlags & COREINSTALL_ROLLBKDOALL) ? IE4_FRDOALL : 0;
    dwTmp |= IE4_NOPROGRESS;

    // process files first ...
    GetUniBackupName( hKey, szBackupBase, sizeof(szBackupBase), szBackupPath, szModule );    
    hRet = ProcessAllFiles( ctx.hWnd, pszSection, pszSrcDir, szBackupPath, szBackupBase, pszCatalogs, szModule, dwTmp );

    // process regs second ...    
    
    // create/open the subkey where the registry backup info stored
    if ( FAILED(hRet) ) 
        goto done;

    // On win95 and save/rollback client and hive not loaded, proce
    if ( (ctx.wOSVer == _OSVER_WIN95) && !ctx.bHiveLoaded )
    {
        GetUniHiveKeyName( hKey, ctx.szRegHiveKey, sizeof(ctx.szRegHiveKey), szBackupPath );
        lstrcpy( szBuf, szBackupPath );
        // make sure the path folders are not hiden and not LFN
        // flag TRUE: Set the path folders to NORMAL, save the old once in adwAttr
        // BUGBUG:  assume no deep than 8 levels here
        //
        SetPathForRegHiveUse( szBuf, adwAttr, 8, TRUE );
        GetShortPathName( szBuf, szBuf, sizeof(szBuf) );
        AddPath( szBuf, ctx.szRegHiveKey );

        // 4 possibilities exist:
        // Case 1: Reg uinstall file exists but IE4RegBackup doesn't exist
        //          - user is upgrading over IE4, load the file as a hive

        // Case 2: Reg uinstall file doesn't exist and IE4RegBackup doesn't exist
        //          - clean install, create a hive under HKEY_LOCAL_MACHINE

        // Case 3: Reg uninstall file doesn't exist but IE4RegBackup exists
        //          - user is upgrading over an older IE4 build which saved
        //            the reg backup info into the registry itself, call RegSaveKey
        //            to export the backup key to a file, then delete the backup key
        //             and load the file as a hive

        // Case 4: Reg uninstall file exists and IE4RegBackup exists
        //          - THIS CASE SHOULDN'T HAPPEN AT ALL!  If somehow happens,
        //            we will default to Case 1.

        // to be safe, unload any previously loaded hive and delete the key
        RegUnLoadKey(HKEY_LOCAL_MACHINE, ctx.szRegHiveKey);
        RegDeleteKeyRecursively(HKEY_LOCAL_MACHINE, (char *) ctx.szRegHiveKey);

        // Case 1 (or Case 4)
        if (RegLoadKey(HKEY_LOCAL_MACHINE, ctx.szRegHiveKey, szBuf) == ERROR_SUCCESS)
        {
            ctx.bHiveLoaded = TRUE;
        }
        else
        {
            // To create a hive do the following steps:
            // Step 1: Create a subkey under HKEY_LOCAL_MACHINE
            // Step 2: Call RegSaveKey on the subkey to save it to a file
            // Step 3: Delete the subkey
            // Step 4: Load the file as a hive

            // Step 1
            if ( RegCreateKeyEx( hKey, REGSUBK_REGBK, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, 
                                 NULL, &hSubKey, NULL ) == ERROR_SUCCESS )
            {
                LONG lErr;

                // to be safe, delete any old reg unisntall file
                SetFileAttributes(szBuf, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(szBuf);

                lErr = RegSaveKey( hSubKey, szBuf, NULL);
                RegCloseKey(hSubKey);
                hSubKey = NULL;

                if (lErr == ERROR_SUCCESS)
                {
                    // Step 3
                    RegDeleteKeyRecursively(hKey, REGSUBK_REGBK);

                    // Step 4
                    if (RegLoadKey(HKEY_LOCAL_MACHINE, ctx.szRegHiveKey, szBuf) == ERROR_SUCCESS)
                    {
                        ctx.bHiveLoaded = TRUE;
                    }
                }
            }
            else
            {
                hRet = HRESULT_FROM_WIN32(GetLastError());
                goto done;
            }
        }
    }

    // create/open the backup reg key
    if (RegCreateKeyEx( ctx.bHiveLoaded ? HKEY_LOCAL_MACHINE : hKey,
                        ctx.bHiveLoaded ? ctx.szRegHiveKey : REGSUBK_REGBK,
                        0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_READ|KEY_WRITE, NULL, &hSubKey, NULL ) != ERROR_SUCCESS)
    {
        hRet = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    // set the flags and Process the AddReg/DelReg lines 
    dwTmp = (dwFlags & COREINSTALL_ROLLBACK) ? IE4_RESTORE : 0;
    dwTmp |= (dwFlags & COREINSTALL_ROLLBKDOALL) ? IE4_FRDOALL : 0;

    if ( dwFlags & COREINSTALL_ROLLBACK )
    {
        HRESULT hret1;

        // RegRestoreAllEx will restore all the backed-up reg entries in one shot
        hRet = RegRestoreAllEx( hSubKey );
        hret1 = RegRestoreAllEx( hCUSubKey );
        if ( FAILED(hret1) )
            hRet = hret1;
    }
    else
    {
        // Save all reg sections
        hRet = ProcessAllRegSec( ctx.hWnd, NULL, pszInf, pszSection, hSubKey, hCUSubKey, dwTmp, &bAtleastOneReg );
    }

    // after all the reg work, unload the hive to reg backup file and record where those 
    // reg backup data are in registry.
    if ( (ctx.wOSVer == _OSVER_WIN95) && ctx.bHiveLoaded )
    {
        // flush the key and unload the hive
        ctx.bHiveLoaded = FALSE;
        
        RegFlushKey(hSubKey);
        RegCloseKey(hSubKey);
        hSubKey = NULL;

        RegUnLoadKey(HKEY_LOCAL_MACHINE, ctx.szRegHiveKey);
        // Flag:  FALSE; reset the path folders to its orignal attributes
        SetPathForRegHiveUse( szBackupPath, adwAttr, 8, FALSE );

        if ( dwFlags & COREINSTALL_BKINSTALL )
        {
            // write the file<key>, path and size of the reg uninstall file to the registry
            RegSetValueEx( hKey, c_szRegUninstPath, 0, REG_SZ, (LPBYTE)szBuf, lstrlen(szBuf) + 1 );
            // the size can be used to validate the file during RegRestore; currently NOT USED
            dwTmp = MyFileSize( szBuf );
            RegSetValueEx( hKey, c_szRegUninstSize, 0, REG_DWORD, (LPBYTE)&dwTmp, sizeof(dwTmp) );
        }
        else if ( SUCCEEDED( hRet ) )
        {
            // delete reg data backup file
            SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
            DeleteFile( szBuf );
            RegDeleteValue(hKey, c_szRegUninstPath);
            RegDeleteValue(hKey, c_szRegUninstSize);
        }            
    }

    // store & cleanup the backup information
    if ( SUCCEEDED( hRet ) )
    {
        PSTR ptmp;
        PCSTR pszCatalogName;

        lstrcpy( szBuf, szBackupPath );
        AddPath( szBuf, szBackupBase );
        ptmp = szBuf + lstrlen(szBuf);
        lstrcpy( ptmp, ".DAT" );        

        if ( dwFlags & COREINSTALL_BKINSTALL )
        {   
            dwTmp = MyFileSize( szBuf );
            RegSetValueEx( hKey, REGVAL_BKFILE, 0, REG_SZ, szBuf, lstrlen(szBuf)+1 );
            RegSetValueEx( hKey, REGVAL_BKSIZE, 0, REG_DWORD, (LPBYTE)&dwTmp, sizeof(DWORD) );
            RegSetValueEx( hKey, REGVAL_BKDIR, 0, REG_SZ, szBackupPath, lstrlen(szBackupPath)+1 );
            RegSetValueEx( hKey, REGVAL_BKINSTINF, 0, REG_SZ, pszInf, lstrlen(pszInf)+1 );
            RegSetValueEx( hKey, REGVAL_BKINSTSEC, 0, REG_SZ, pszSection, lstrlen(pszSection)+1 );
            RegSetValueEx( hKey, REGVAL_BKREGDATA, 0, REG_SZ, bAtleastOneReg ? "y" : "n", 2 );
            if ( SUCCEEDED(GetTranslatedString( pszInf, pszSection, ADVINF_MODVER,
                                                szBuf, sizeof(szBuf), NULL)) && szBuf[0])                        
            {
                RegSetValueEx( hKey, REGVAL_BKMODVER, 0, REG_SZ, szBuf, lstrlen(szBuf)+1 );
            }
            for (pszCatalogName = pszCatalogs;  *pszCatalogName;  pszCatalogName += lstrlen(pszCatalogName) + 1)
            {
                HKEY hkCatalogKey;
                CHAR szFullCatalogName[MAX_PATH];

                if (RegCreateKeyEx(hKey, REGSUBK_CATALOGS, 0, NULL, REG_OPTION_NON_VOLATILE,
                                KEY_SET_VALUE, NULL, &hkCatalogKey, NULL) == ERROR_SUCCESS)
                {
                    DWORD dwVal = 1;

                    RegSetValueEx(hkCatalogKey, pszCatalogName, 0, REG_DWORD, (CONST BYTE *) &dwVal, sizeof(dwVal));
                    RegCloseKey(hkCatalogKey);
                }

                lstrcpy(szFullCatalogName, szBackupPath);
                AddPath(szFullCatalogName, pszCatalogName);
                if (FileExists(szFullCatalogName))
                    SetFileAttributes(szFullCatalogName, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY);
            }
        }
        else if ( dwFlags & COREINSTALL_ROLLBACK )
        {
            // delete the catalogs
            for (pszCatalogName = pszCatalogs;  *pszCatalogName;  pszCatalogName += lstrlen(pszCatalogName) + 1)
            {
                HKEY hkCatalogKey;
                CHAR szFullCatalogName[MAX_PATH];

                if (RegOpenKeyEx(hKey, REGSUBK_CATALOGS, 0, KEY_WRITE, &hkCatalogKey) == ERROR_SUCCESS)
                {
                    RegDeleteValue(hkCatalogKey, pszCatalogName);
                    RegCloseKey(hkCatalogKey);
                }

                lstrcpy(szFullCatalogName, szBackupPath);
                AddPath(szFullCatalogName, pszCatalogName);
                if (FileExists(szFullCatalogName))
                {
                    SetFileAttributes(szFullCatalogName, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(szFullCatalogName);
                }
            }

            // delete backup .dat .ini files
            SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
            DeleteFile( szBuf );
            lstrcpy( ptmp, ".INI" );
            SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
            DeleteFile( szBuf );
            MyRemoveDirectory( szBackupPath );

            // since we have rollback all the files and delete the backup .dat .ini files, we
            // should re-set the backup file size to ZERO to allow reg restore continue for whatever
            // following users.
            dwTmp = 0;
            RegSetValueEx( hKey, REGVAL_BKSIZE, 0, REG_DWORD, (LPBYTE)&dwTmp, sizeof(DWORD) );    
            RegSetValueEx( hKey, REGVAL_BKREGDATA, 0, REG_SZ, "n", 2 );
            RegDeleteValue( hKey, REGVAL_BKMODVER );
        }
    }

done:

    if ( hSubKey )
    {
        RegCloseKey( hSubKey );
    }

    if ( hKey )
    {
        RegCloseKey( hKey );
    }

    if ( hCUSubKey )
    {
        BOOL bEmpty = TRUE;
        DWORD dwKeys, dwValues;

        if ( (RegQueryInfoKey(hCUSubKey, NULL, NULL, NULL, &dwKeys, NULL, NULL, 
                              &dwValues, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) &&
             (dwKeys || dwValues) )
        {
            // not empty key
            bEmpty = FALSE;
        }

        RegCloseKey( hCUSubKey );

        if ( bEmpty )
        {
            // delete the empty key
            if ( RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_SAVERESTORE, 0, KEY_READ|KEY_WRITE, &hCUSubKey) == ERROR_SUCCESS)
            {
                RegDeleteKeyRecursively( hCUSubKey, szModule );
                RegCloseKey( hCUSubKey );
            }
        }

    }

    if ( gst_pszFiles )
    {
        LocalFree( gst_pszFiles );
        gst_pszFiles = NULL;
        gst_pszEndLastFile = NULL;
    }

    AdvWriteToLog("SaveRestoreInfo: End hr=0x%1!x! %2\r\n", hRet, szModule);
    return hRet;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

HRESULT ProcessAllRegSec( HWND hw, PCSTR pszTitle, PCSTR pszInf, PCSTR pszSection, HKEY hKey, HKEY hCUKey, DWORD dwFlags, BOOL *lpbOneReg )
{
    int     i, arraysize;
    PSTR    pszOneSec;
    PSTR    pszStr;
    HRESULT hRet = S_OK;
    char    szBuf[MAX_PATH];

    AdvWriteToLog("ProcessAllRegSec: \r\n");
    arraysize = ARRAYSIZE( RegInfOpt );
    for ( i=0; i<arraysize; i++ )
    {
        szBuf[0] = 0;
        pszStr = szBuf;

        GetTranslatedString( pszInf, pszSection, RegInfOpt[i].pszInfKey,
                             szBuf, sizeof(szBuf), NULL);
        
        // Parse the arguments, SETUP engine is not called to process this line.  So we check on \".
        pszOneSec = GetStringField( &pszStr, ",", '\"', TRUE );
        while ( (hRet == S_OK) && pszOneSec && *pszOneSec )
        {  
            if ( i == 0 )  // AddReg section only
                dwFlags |= IE4_NOENUMKEY;
            else
                dwFlags &= ~IE4_NOENUMKEY;
            
            if (*pszOneSec != '!')
                 hRet = ProcessOneRegSec( hw, pszTitle, pszInf, pszOneSec, hKey, hCUKey, dwFlags, lpbOneReg );

            pszOneSec = GetStringField( &pszStr, ",", '\"', TRUE );
        }

    }
    AdvWriteToLog("ProcessAllRegSec: End hr=0x%1!x!\r\n", hRet);
    return hRet;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

HRESULT ProcessOneRegSec( HWND hw, PCSTR pszTitle, PCSTR pszInf, PCSTR pszSec, HKEY hLMKey, HKEY hCUKey, DWORD dwFlags, BOOL *lpbOneReg  )
{
    int     j;
    PSTR    pszInfLine = NULL;                     
    HRESULT hResult = S_OK;
    PSTR    pszRootKey, pszSubKey, pszValueName, pszTmp1, pszTmp2;    
    HKEY    hKey;  
    
    AdvWriteToLog("ProcessOneRegSec: Section=%1\r\n", pszSec);
    for ( j=0; (hResult==S_OK); j++ ) 
    {
        if ( FAILED(hResult = GetTranslatedLine( pszInf, pszSec, j, &pszInfLine, NULL )) || 
                    !pszInfLine )
        {
        // if the failure due to no more items, set to normal return
        if ( hResult == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) )
            hResult = S_OK;

            break;
        }

        // at least, there is one reg data to be saved
        if ( lpbOneReg && !*lpbOneReg )
            *lpbOneReg = TRUE;

        // Parse out the fields Registry op-line.
        ParseCustomLine( pszInfLine, &pszRootKey, &pszSubKey, &pszValueName, &pszTmp1, &pszTmp2, FALSE, TRUE );

        if ( !lstrcmpi( pszRootKey, "HKCU") || !lstrcmpi( pszRootKey, "HKEY_CURRENT_USER" ) )
             hKey = hCUKey;
        else
             hKey = hLMKey;
        
        // Check the specified registry branch and grab the contents.
        hResult = RegSaveRestore( hw, pszTitle, hKey, pszRootKey, pszSubKey, pszValueName, dwFlags );

        LocalFree( pszInfLine );
        pszInfLine = NULL;
    }

    AdvWriteToLog("ProcessOneRegSec: End hr=0x%1!x! %2\r\n", hResult, pszSec);
    return hResult;
}        

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

HRESULT ProcessAllFiles( HWND hw, PCSTR pszSection, PCSTR pszSrcDir, PCSTR pszBackupPath,
                         PCSTR pszBaseName, PCSTR pszCatalogs, PCSTR pszModule, DWORD dwFlags  )
{    
    HRESULT hRet = S_OK;
    PCSTR pszCatalogName;

    AdvWriteToLog("ProcessAllFiles: Sec=%1, SrcDir=%2, BackupPath=%3\r\n", pszSection, pszSrcDir, pszBackupPath);
    // if CORESINSTALL_ROLLBKDOALL is on, no need to build the filelist.  FileRestore will 
    // rollback everything based on its .INI backup data index file.  Otherwise, build
    // file list gst_pszFiles inside    
    gst_pszFiles = NULL;
    if ( !(dwFlags & IE4_FRDOALL) )
    {
        // backup/restore the files referred by CopyFiles, DelFiles, RenFiles
        //
        gst_pszFiles = (PSTR)LocalAlloc( LPTR, FILELIST_SIZE );  // allocat 10k
        gst_pszEndLastFile = gst_pszFiles; // already will have 2 zeros
        if ( !gst_pszFiles )
        { 
            ErrorMsg( hw, IDS_ERR_NO_MEMORY );
            hRet = E_OUTOFMEMORY;
            return hRet;           
        }

        hRet = ProcessFileSections( pszSection, pszSrcDir, MyFileQueueCallback );
    }

    // if a catalog is specified, backup/restore it
    for (pszCatalogName = pszCatalogs;  SUCCEEDED(hRet) && *pszCatalogName;  pszCatalogName += lstrlen(pszCatalogName) + 1)
    {
        DWORD dwRet;
        CHAR szPrevCatalog[MAX_PATH];

        AdvWriteToLog("ProcessAllFiles: Processing catalog=%1\r\n", pszCatalogName);

        lstrcpy(szPrevCatalog, pszBackupPath);
        AddPath(szPrevCatalog, pszCatalogName);
            
        if ((dwFlags & IE4_RESTORE)  ||  (dwFlags & IE4_FRDOALL))
        {
            // first delete the current catalog and then install the previous one
            dwRet = g_pfSfpDeleteCatalog(pszCatalogName);
            AdvWriteToLog("\tProcessAllFiles: SfpDeleteCatalog returned=%1!lu!\r\n", dwRet);
            if (dwRet != ERROR_SUCCESS)
                hRet = E_FAIL;

            if (SUCCEEDED(hRet)  &&  FileExists(szPrevCatalog))
            {
                dwRet = g_pfSfpInstallCatalog(szPrevCatalog, NULL);
                AdvWriteToLog("\tProcessAllFiles: SfpInstallCatalog returned=%1!lu!\r\n", dwRet);
                if (dwRet != ERROR_SUCCESS)
                    hRet = E_FAIL;
            }
        }
        else
        {
            BOOL bBackupCatalog = FALSE;
            CHAR szBuf[MAX_PATH];

            if (pszModule != NULL)
            {
                HKEY hkCatalogKey;

                lstrcpy(szBuf, REGKEY_SAVERESTORE);
                AddPath(szBuf, pszModule);
                AddPath(szBuf, REGSUBK_CATALOGS);

                // back-up the catalog if it hasn't been already backed up
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, 0, KEY_QUERY_VALUE, &hkCatalogKey) == ERROR_SUCCESS)
                {
                    if (RegQueryValueEx(hkCatalogKey, pszCatalogName, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
                        bBackupCatalog = TRUE;

                    RegCloseKey(hkCatalogKey);
                }
                else
                    bBackupCatalog = TRUE;
            }
            else
            {
                // back-up the catalog if the file back-up .dat doesn't exist
                lstrcpy(szBuf, pszBackupPath);
                AddPath(szBuf, pszBaseName);
                lstrcat(szBuf, ".dat");

                if (!FileExists(szBuf))
                    bBackupCatalog = TRUE;
            }

            if (bBackupCatalog)
            {
                dwRet = g_pfSfpDuplicateCatalog(pszCatalogName, pszBackupPath);
                AdvWriteToLog("\tProcessAllFiles: SfpDuplicateCatalog returned=%1!lu!\r\n", dwRet);
                if (dwRet != ERROR_SUCCESS  &&  dwRet != ERROR_FILE_NOT_FOUND)
                    hRet = E_FAIL;
            }
        }
    }

    if ( SUCCEEDED(hRet) )
    {
        hRet = FileSaveRestore( hw, gst_pszFiles, (PSTR)pszBackupPath, (PSTR)pszBaseName, dwFlags );
    }

    AdvWriteToLog("ProcessAllFiles: End hr=0x%1!x!\r\n", hRet);
    return hRet;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

HRESULT ProcessFileSections( PCSTR pszSection, PCSTR pszSrcDir, MYFILEQUEUECALLBACK pMyFileQueueCallback )
{    
    PVOID    pContext = NULL;
    HRESULT  hResult  = S_OK;

    AdvWriteToLog("ProcessFileSections: Sec=%1\r\n", pszSection);
    // Build File list include all the files in CopyFiles/DelFiles/renFiles
    //

    // Setup Context data structure initialized for us for default UI provided by Setup API.
    pContext = pfSetupInitDefaultQueueCallbackEx( NULL, 
                                                  INVALID_HANDLE_VALUE,
                                                  0, 0, NULL );

    if ( pContext == INVALID_HANDLE_VALUE ) 
    {
        hResult = HRESULT_FROM_SETUPAPI(GetLastError());
        goto done;
    }

    if ( !pfSetupInstallFromInfSection( NULL, ctx.hInf, pszSection, SPINST_FILES, NULL,
                                        pszSrcDir, SP_COPY_NEWER,
                                        pMyFileQueueCallback,
                                        pContext, NULL, NULL ) )
    {
        hResult = HRESULT_FROM_SETUPAPI(GetLastError());
        pfSetupTermDefaultQueueCallback( pContext );
        goto done;
    }

    // Free Context Data structure
    pfSetupTermDefaultQueueCallback( pContext );

done:
    AdvWriteToLog("ProcessFileSections: End hr=0x%1!x!\r\n",hResult);
    return hResult;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

UINT WINAPI MyFileQueueCallback( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 )
{       
    UINT retVal = FILEOP_SKIP;

    switch(Notification)
    {
        case SPFILENOTIFY_STARTDELETE:
        case SPFILENOTIFY_STARTRENAME:
        case SPFILENOTIFY_STARTCOPY:
            {
                FILEPATHS *pFilePath;
                int len;
                PCSTR  pTmp;

                pFilePath = (FILEPATHS *)parm1;

                if ( !gst_pszFiles )
                {
                        retVal = FILEOP_ABORT;
                        SetLastError( ERROR_OUTOFMEMORY );
                        break;
                }
                
                if ( Notification == SPFILENOTIFY_STARTRENAME )
                {
                    len = lstrlen( pFilePath->Source ) + 1;
                    pTmp = pFilePath->Source;
                }
                else
                {
                    len = lstrlen( pFilePath->Target ) + 1;
                    pTmp = pFilePath->Target;
                }

                if ( (FILELIST_SIZE - (gst_pszEndLastFile - gst_pszFiles )) <= (len + 8) )
                {
                    retVal = FILEOP_ABORT;
                    SetLastError( ERROR_OUTOFMEMORY );
                    break;
                }

                lstrcpy( gst_pszEndLastFile, pTmp );
                gst_pszEndLastFile += len;
                *gst_pszEndLastFile = 0;      // the second '\0' to end the list                            
            }
            break;

        case SPFILENOTIFY_NEEDMEDIA:
            return ( MyFileQueueCallback2( Context, Notification, parm1, parm2 ) );

        default:
            return ( pfSetupDefaultQueueCallback( Context, Notification, parm1, parm2 ) );
    }

    return( retVal );
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

BOOL GetFullInfNameAndSrcDir( PCSTR pszInfFilename, PSTR pszFilename, PSTR pszSrcDir )
{
    BOOL bRet = FALSE;
    UINT uiErrid = 0;
    PCSTR pszErrParm1 = NULL;
    char szBuf[MAX_PATH];

    if ( !pszInfFilename || !pszFilename || !(*pszInfFilename) )
        goto done;

    if ( !IsFullPath( pszInfFilename ) && pszSrcDir && *pszSrcDir )
    {
        lstrcpy( szBuf, pszSrcDir );
        AddPath( szBuf, pszInfFilename );
    }
    else
        lstrcpy( szBuf, pszInfFilename );

    if ( GetFileAttributes( szBuf ) == 0xFFFFFFFF ) 
    {
        if ( IsFullPath( szBuf ) )
        {
            uiErrid = IDS_ERR_CANT_FIND_FILE;
            pszErrParm1 = pszInfFilename;
            goto done;
        }

        // If the file doesn't exist in the current directory, check the
        // Windows\inf directory

        if ( !GetWindowsDirectory( szBuf, sizeof(szBuf) ) )
        {
            uiErrid = IDS_ERR_GET_WIN_DIR;
            goto done;
        }

        AddPath( szBuf, "inf" );        
        AddPath( szBuf, pszInfFilename );

        if ( GetFileAttributes( szBuf) == 0xFFFFFFFF ) 
        {
            uiErrid = IDS_ERR_CANT_FIND_FILE;
            pszErrParm1 = pszInfFilename;
            goto done;
        }
    } 
    
    // Generate the source directory from the inf path.
    lstrcpy( pszFilename, szBuf );

    GetParentDir( szBuf );        
    lstrcpy( pszSrcDir, szBuf );    

    bRet = TRUE;

done:

    if ( uiErrid )
        ErrorMsg1Param( ctx.hWnd, uiErrid, pszErrParm1 );

    return bRet;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

void CleanRegLogFile( PCSTR pcszLogFileSecName )
{
    char szLogFileName[MAX_PATH];
    char szBuf[MAX_PATH];
    HKEY hkSubKey;

    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SAVERESTORE, 0, KEY_READ, &hkSubKey) == ERROR_SUCCESS)
    {
        DWORD dwDataLen = sizeof(szLogFileName);

        if (RegQueryValueEx(hkSubKey, pcszLogFileSecName, NULL, NULL, szLogFileName, &dwDataLen) != ERROR_SUCCESS)
            *szLogFileName = '\0';

        RegCloseKey(hkSubKey);
    }

    if (*szLogFileName)
    {
        if (szLogFileName[1] != ':')           // crude way of determining if fully qualified path is specified or not
        {
            GetWindowsDirectory(szBuf, sizeof(szBuf));          // default to windows dir
            AddPath(szBuf, szLogFileName);
        }
        else
            lstrcpy(szBuf, szLogFileName);

        DeleteFile( szBuf );
    }
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

BOOL VerifyBackupRegData( HKEY hKey )
{
    HKEY    hSubKey;
    char    szBackData[MAX_PATH];
    DWORD   dwSize = 0, dwBkSize;
    BOOL    bRet = FALSE;

    if ( ctx.wOSVer == _OSVER_WIN95 )
    {
        dwSize = sizeof( szBackData );
        if ( RegQueryValueEx( hKey, c_szRegUninstPath, NULL, NULL, szBackData, &dwSize ) == ERROR_SUCCESS )
        {
            dwSize = sizeof( DWORD );
            if ( RegQueryValueEx( hKey, c_szRegUninstSize, NULL, NULL, (LPBYTE)&dwBkSize, &dwSize ) == ERROR_SUCCESS )
            {
                if ( MyFileSize(szBackData) == dwBkSize )
                {
                    bRet = TRUE;
                    return bRet;
                }
            }
        }
    }

    // if you are here, the file backup info is OK. We check on reg backup info
    if ( RegOpenKeyEx( hKey, REGSUBK_REGBK, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS)
    {
        HKEY hsubsubKey;
    
        if ( RegOpenKeyEx( hSubKey, "0", 0, KEY_READ, &hsubsubKey) == ERROR_SUCCESS)
        {
            if ( (RegQueryInfoKey( hsubsubKey, NULL, NULL, NULL, NULL, NULL, NULL, &dwSize,
                                   NULL, NULL, NULL, NULL ) == ERROR_SUCCESS) && dwSize )
            {
                bRet = TRUE;
            }
            RegCloseKey( hsubsubKey );
        }
        RegCloseKey(hSubKey);
    }

    return bRet;
}

//-----------------------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------------------

BOOL VerifyBackupInfo( HKEY hKey, HKEY hCUKey )
{
    char    szBackData[MAX_PATH];
    DWORD   dwSize, dwBkSize = 0;
    BOOL    bRet = FALSE;
    HKEY    hSubKey = NULL;
    
    if ( hKey )
    {
        // verify the backup file first
        dwSize = sizeof( szBackData );
        if ( RegQueryValueEx( hKey, REGVAL_BKFILE, NULL, NULL, szBackData, &dwSize ) == ERROR_SUCCESS )
        {
            dwSize = sizeof( DWORD );
            if ( RegQueryValueEx( hKey, REGVAL_BKSIZE, NULL, NULL, (LPBYTE)&dwBkSize, &dwSize ) == ERROR_SUCCESS )
            {
                if ( MyFileSize(szBackData) == dwBkSize )
                {
                    // if you are here, the file backup info is OK. We check on reg backup info
                    dwSize = sizeof( szBackData );
                    if ( (RegQueryValueEx( hKey, REGVAL_BKREGDATA, NULL, NULL, (LPBYTE)szBackData, &dwSize ) == ERROR_SUCCESS )  &&
                         ( szBackData[0] == 'n' ) )
                    {
                        // no registry data backed up, so no need to verify further
                        bRet = TRUE;
                    }
                    else
                    {
                        if ( VerifyBackupRegData( hKey ) || (hCUKey && VerifyBackupRegData( hCUKey )) )
                        {
                            bRet = TRUE;
                        }
                    }
                }
            }
        }
    }
    return bRet;
}


typedef HRESULT (*CHECKTOKENMEMBERSHIP)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);

BOOL CheckToken(BOOL *pfIsAdmin)
{
    BOOL bNewNT5check = FALSE;
    HINSTANCE hAdvapi32 = NULL;
    CHECKTOKENMEMBERSHIP pf;
    PSID AdministratorsGroup;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    hAdvapi32 = LoadLibrary("advapi32.dll");
    if (hAdvapi32)
    {
        pf = (CHECKTOKENMEMBERSHIP)GetProcAddress(hAdvapi32, "CheckTokenMembership");
        if (pf)
        {
            bNewNT5check = TRUE;
            *pfIsAdmin = FALSE;
            if(AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup) )
            {
                pf(NULL, AdministratorsGroup, pfIsAdmin);
                FreeSid(AdministratorsGroup);
            }
        }
        FreeLibrary(hAdvapi32);
    }
    return bNewNT5check;
}
//***************************************************************************
//* Functions:  IsNTAdmin()                                                 *
//*                                                                         *
//* Returns     TRUE if our process has admin priviliges.                   *
//*             FALSE otherwise.                                            *
//***************************************************************************
BOOL WINAPI IsNTAdmin( DWORD dwReserved, DWORD *lpdwReserved )
{
      static int    fIsAdmin = 2;
      HANDLE        hAccessToken;
      PTOKEN_GROUPS ptgGroups;
      DWORD         dwReqSize;
      UINT          i;
      SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
      PSID AdministratorsGroup;
      BOOL bRet;

      //
      // If we have cached a value, return the cached value. Note I never
      // set the cached value to false as I want to retry each time in
      // case a previous failure was just a temp. problem (ie net access down)
      //

      bRet = FALSE;
      ptgGroups = NULL;

      if( fIsAdmin != 2 )
         return (BOOL)fIsAdmin;

      if (!CheckToken(&bRet))
      {
          if(!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hAccessToken ) )
             return FALSE;

          // See how big of a buffer we need for the token information
          if(!GetTokenInformation( hAccessToken, TokenGroups, NULL, 0, &dwReqSize))
          {
              // GetTokenInfo should the buffer size we need - Alloc a buffer
              if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                  ptgGroups = (PTOKEN_GROUPS) LocalAlloc(LMEM_FIXED, dwReqSize);
              
          }
          
          // ptgGroups could be NULL for a coupla reasons here:
          // 1. The alloc above failed
          // 2. GetTokenInformation actually managed to succeed the first time (possible?)
          // 3. GetTokenInfo failed for a reason other than insufficient buffer
          // Any of these seem justification for bailing.
          
          // So, make sure it isn't null, then get the token info
          if(ptgGroups && GetTokenInformation(hAccessToken, TokenGroups, ptgGroups, dwReqSize, &dwReqSize))
          {
              if(AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup) )
              {
                  
                  // Search thru all the groups this process belongs to looking for the
                  // Admistrators Group.
                  
                  for( i=0; i < ptgGroups->GroupCount; i++ )
                  {
                      if( EqualSid(ptgGroups->Groups[i].Sid, AdministratorsGroup) )
                      {
                          // Yea! This guy looks like an admin
                          fIsAdmin = TRUE;
                          bRet = TRUE;
                          break;
                      }
                  }
                  FreeSid(AdministratorsGroup);
              }
          }
          if(ptgGroups)
              LocalFree(ptgGroups);

          // BUGBUG: Close handle here? doc's aren't clear whether this is needed.
          CloseHandle(hAccessToken);
      }
      else if (bRet)
          fIsAdmin = TRUE;

      return bRet;
}

//-----------------------------------------------------------------------------------------
//
// MyFileCheckCallback()
//
//-----------------------------------------------------------------------------------------

UINT WINAPI MyFileCheckCallback( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 )
{       
    UINT retVal = FILEOP_SKIP;

    switch(Notification)
    {
        case SPFILENOTIFY_STARTDELETE:
        case SPFILENOTIFY_STARTRENAME:
        case SPFILENOTIFY_STARTCOPY:
        {
            FILEPATHS   *pFilePath;
            PCSTR       pTmp;
            HANDLE      hFile;

            pFilePath = (FILEPATHS *)parm1;
            
            if ( Notification == SPFILENOTIFY_STARTRENAME )
            {
                pTmp = pFilePath->Source;
            }
            else
            {
                pTmp = pFilePath->Target;
            }

            if ( FileExists(pTmp) )                        // original file exists
            {
                // check if the File is in use
                if ((hFile = CreateFile(pTmp, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
                {
                    // File is in use which will trig the reboot if we actually install this section.                      
                    gst_hNeedReboot = S_OK;

                    // no need to continue if at least one file is in use, reboot is needed.
                    retVal = FILEOP_ABORT;
                }
                else
                {
                    // file not in use
                    CloseHandle(hFile);
                }
            }
        }
        break;

        case SPFILENOTIFY_NEEDMEDIA:
            return ( MyFileQueueCallback2( Context, Notification, parm1, parm2 ) );

        default:
            return ( pfSetupDefaultQueueCallback( Context, Notification, parm1, parm2 ) );
    }

    return( retVal );
}

//***************************************************************************
//*                                                                         *
//* NAME:       RebootCheckOnInstall                                        *
//*                                                                         *
//* SYNOPSIS:   Check reboot condition if given INF install section is      *
//*             installed.                                                  *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle to parent window.                    *
//*             PCSTR           The INF filename                            *
//*             PCSTR           INF Section name                            *
//*                                                                         *
//* RETURNS:    HRESULT:                                                    *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI RebootCheckOnInstall( HWND hWnd, PCSTR pszINF, PCSTR pszSection, DWORD dwFlags )
{
    HRESULT hRet = S_FALSE;
    char    szSrcDir[MAX_PATH];
    char    szRealSec[100];
    
    // Validate parameters:
    // if INF filename info is missing, invalid.
    if ( !pszINF || !*pszINF )
        return hRet;

    ctx.wQuietMode = QUIETMODE_ALL;
    ctx.hWnd      = hWnd;

    if ( !IsFullPath( pszINF ) )
    {
         hRet = E_INVALIDARG;
         goto done;
    }
    else
    {
        lstrcpy( szSrcDir, pszINF );
        GetParentDir( szSrcDir );
    }

    hRet = CommonInstallInit( pszINF, pszSection, szRealSec, sizeof(szRealSec), NULL, FALSE, COREINSTALL_REBOOTCHECKONINSTALL );
    if ( FAILED( hRet ) ) 
    {
        goto done;
    }

    hRet = SetLDIDs( pszINF, szRealSec, 0, NULL );
    if ( FAILED( hRet ) ) 
    {
        goto done;
    }

    gst_hNeedReboot = S_FALSE;
    hRet = ProcessFileSections( szRealSec, szSrcDir, MyFileCheckCallback );
    if ( SUCCEEDED(hRet) || (gst_hNeedReboot == S_OK) )
    {
        hRet = gst_hNeedReboot;
    }
    
  done:

    CommonInstallCleanup();
    return hRet;
}

//***************************************************************************
//*                                                                         *
//* NAME:       RegSaveRestoreOnINF                                         *
//*                                                                         *
//* SYNOPSIS:   Save or restore the given INF section to given reg key      *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle to parent window.                    *
//*             PCSTR           The Title if messagebox displayed           *
//*             PCSTR           The INF filename                            *
//*             PCSTR           INF Section name                            *
//*             HKEY            The backup reg key handle                   *
//*             DWORD           Flags                                       *
//*                                                                         *
//* RETURNS:    HRESULT:                                                    *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI RegSaveRestoreOnINF( HWND hWnd, PCSTR pcszTitle, PCSTR pszInf, 
                                    PCSTR pszSection, HKEY hLMBackKey, HKEY hCUBackKey, DWORD dwFlags )
{
    HRESULT hRet = S_OK;
    CHAR    szRealInstallSection[100];
    PSTR  pszOldTitle;
    HWND  hwndOld;
    BOOL  bDoCommonInit = FALSE;

    AdvWriteToLog("RegSaveRestoreOnINF: Inf=%1\r\n", pszInf);
    hwndOld = ctx.hWnd;
    pszOldTitle = ctx.lpszTitle;

    if (hWnd != INVALID_HANDLE_VALUE)
        ctx.hWnd = hWnd;

    if ( dwFlags & ARSR_NOMESSAGES )
        ctx.wQuietMode |= QUIETMODE_ALL;

    if ( pcszTitle != NULL )
        ctx.lpszTitle = (PSTR)pcszTitle;

    if ( (dwFlags & ARSR_RESTORE) && !(dwFlags & ARSR_REMOVREGBKDATA) && !pszInf && !pszSection  )
    {       
        HRESULT hret1 = S_OK;
        // restore all case
        if ( hLMBackKey )
            hRet = RegRestoreAllEx( hLMBackKey );
    
        if ( ( hLMBackKey != hCUBackKey) && hCUBackKey )
            hret1 = RegRestoreAllEx( hCUBackKey );

        if ( FAILED(hret1) )
            hRet = hret1;

        goto done;
    }
    
    // params validation checks
    if ( !IsFullPath(pszInf) || (!hLMBackKey && !hCUBackKey) || (dwFlags & ARSR_REGSECTION) && !pszSection 
         || !(dwFlags & ARSR_RESTORE) && (dwFlags & ARSR_REMOVREGBKDATA) )
    {
        hRet = E_INVALIDARG;	
        goto done;
    }

    if ( !hCUBackKey )
        hCUBackKey = hLMBackKey;
    else if ( !hLMBackKey )
        hLMBackKey = hCUBackKey;

    bDoCommonInit = TRUE;
    hRet = CommonInstallInit( pszInf, (dwFlags & ARSR_REGSECTION) ? NULL : pszSection, szRealInstallSection, 
                              sizeof(szRealInstallSection), NULL, FALSE, 0 );
    if ( FAILED( hRet ) ) 
    {
        goto done;
    }
 
    if ( dwFlags & ARSR_REGSECTION )
    {
        // process One Reg Section to do Save / restore based on given flags
        hRet = ProcessOneRegSec( hWnd, pcszTitle, pszInf, pszSection, hLMBackKey, hCUBackKey, dwFlags, NULL );
    }
    else
    {
        // process All Reg sections
        hRet = ProcessAllRegSec( hWnd, pcszTitle, pszInf, szRealInstallSection, hLMBackKey, hCUBackKey, dwFlags, NULL );
    }

done:
    if ( bDoCommonInit )
        CommonInstallCleanup();
    ctx.hWnd = hwndOld;
    ctx.lpszTitle = pszOldTitle;
    AdvWriteToLog("RegSaveRestoreOnINF: End hr=0x%1!x!\r\n", hRet);
    return hRet;

}

//***************************************************************************
//*                                                                         *
//* NAME:       FileSaveRestoreOnINF                                        *
//*                                                                         *
//* SYNOPSIS:   Save or restore Files defined by GenInstall INF section     *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle to parent window.                    *
//*				PCSTR			The Title if messagebox displayed			*
//*             PCSTR           The INF filename                            *
//*             PCSTR           INF Section name                            *
//*				PCSTR           backup directory path    					*
//*				PCSTR           backup file basename    					*
//*				DWORD			Flags										*
//*                                                                         *
//* RETURNS:    HRESULT:                                                    *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI FileSaveRestoreOnINF( HWND hWnd, PCSTR pszTitle, PCSTR pszInf, 
                                     PCSTR pszSection, PCSTR pszBackupDir, 
                                     PCSTR pszBaseBkFile, DWORD dwFlags )
{
    HRESULT	hRet = S_OK;
    char    szRealInstallSection[100] = {0};
    char    szSrcDir[MAX_PATH] = {0};
    PSTR    pszOldTitle;
    HWND    hOldwnd;
    BOOL    bDoCommonInit = FALSE;
    CHAR    szCatalogName[MAX_PATH];

    AdvWriteToLog("FileSaveRestoreOnINF: Inf=%1\r\n", (pszInf != NULL) ? pszInf : "NULL");
    if ( dwFlags & AFSR_NOMESSAGES )
        ctx.wQuietMode = QUIETMODE_ALL;

    hOldwnd = ctx.hWnd;
    if ( hWnd != INVALID_HANDLE_VALUE )
        ctx.hWnd = hWnd;

    pszOldTitle = ctx.lpszTitle;
    if ( pszTitle != NULL )
        ctx.lpszTitle = (PSTR)pszTitle;

    // params validation checks
    if ( !pszBackupDir || !*pszBackupDir || !pszBaseBkFile || !*pszBaseBkFile )
    {
        hRet = E_INVALIDARG;	
        goto done;
    }


    if ( (dwFlags & AFSR_RESTORE) && !pszInf && !pszSection  )
    {   
        dwFlags |= IE4_FRDOALL;
    }
    
    if ( !(dwFlags & IE4_FRDOALL) )
    {
        if ( !IsFullPath(pszInf) )
        {
            hRet = E_INVALIDARG;
            goto done;
        }
        else
        {
            bDoCommonInit = TRUE;
            hRet = CommonInstallInit( pszInf, pszSection, szRealInstallSection, 
                                      sizeof(szRealInstallSection), NULL, FALSE, 0 );
            if ( FAILED( hRet ) ) 
            {
                goto done;
            }
        }
    }

    if (pszInf != NULL)
    {
        lstrcpy( szSrcDir, pszInf );
        GetParentDir( szSrcDir );
    }

    // get the catalog name, if specified
    ZeroMemory(szCatalogName, sizeof(szCatalogName));

    if (pszInf == NULL)
    {
        CHAR szFullCatalogName[MAX_PATH];

        // NOTE: assume that the catalog name is <BaseBkFile>.cat.
        //       can't use the REGKEY_SAVERESTORE key to read the catalog name
        //       because this API doesn't go thru SaveRestoreInfo which updates
        //       the REGKEY_SAVERESTORE key.

        // check if the catalog file exists in the BackupDir
        lstrcpy(szFullCatalogName, pszBackupDir);
        AddPath(szFullCatalogName, pszBaseBkFile);
        lstrcat(szFullCatalogName, ".cat");
        if (FileExists(szFullCatalogName))
            wsprintf(szCatalogName, "%s.cat", pszBaseBkFile);
    }
    else
        GetTranslatedString(pszInf, szRealInstallSection, ADVINF_CATALOG_NAME, szCatalogName, sizeof(szCatalogName), NULL);

    if (*szCatalogName)
    {
        // load sfc.dll and the relevant proc's
        if (!LoadSfcDLL())
        {
            // couldn't load -- so empty out CatalogName
            *szCatalogName = '\0';
        }
    }

    // Process all the INF file sections
    hRet = ProcessAllFiles( hWnd, szRealInstallSection, szSrcDir, pszBackupDir, pszBaseBkFile, szCatalogName, NULL, dwFlags );

done:
    UnloadSfcDLL();
    if ( bDoCommonInit )
        CommonInstallCleanup();
    ctx.lpszTitle = pszOldTitle;
    ctx.hWnd = hOldwnd;
    AdvWriteToLog("FileSaveRestoreOnINF: End hr=0x%1!x!\r\n", hRet);
    return hRet;

}
#if 0
//-----------------------------------------------------------------------------------------
//
// MyGetSpecialFolder( int )
//
//-----------------------------------------------------------------------------------------
HRESULT MyGetSpecialFolder( HWND hwnd, int nFd, PSTR szPath )
{
    LPITEMIDLIST pidl;
    HRESULT      hRet;
    
    *szPath = 0;

    hRet = SHGetSpecialFolderLocation( hwnd, nFd, &pidl );
    if ( hRet == NOERROR )
    {
        if ( !SHGetPathFromIDList( pidl, szPath ) )
        {
            hRet = E_INVALIDARG;
        }
    }
    return hRet;
}
#endif
    
void MySetSpecialFolder( HKEY hkey, PCSTR pcszValueN, PSTR pszPath )
{
    DWORD dwTmp;

    if ( (ctx.wOSVer >= _OSVER_WINNT40) && AddEnvInPath( pszPath, pszPath ) )
        dwTmp = REG_EXPAND_SZ;
    else
        dwTmp = REG_SZ;

    RegSetValueExA( hkey, pcszValueN, 0, dwTmp, pszPath, lstrlen(pszPath)+1 );
}


//-----------------------------------------------------------------------------------------
//
// SetSysPathsInReg()
//
//-----------------------------------------------------------------------------------------
void SetSysPathsInReg()
{
    HKEY    hkey;
    char    szPath[MAX_PATH];
    char    szAS[100];
    DWORD   dwTmp;
    int     i = 0;
    PSTR    pszValName, pszKeyName;

    // Add StartUp, StartMenu, Programs and accessories sys pathes to registries for further ref
    // only if it is not set before.
    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, 0, KEY_READ|KEY_WRITE, &hkey) == ERROR_SUCCESS )
    {        
        // Program Files path
        dwTmp = sizeof( szPath );
        if ( RegQueryValueEx( hkey, REGVAL_PROGRAMFILESPATH, 0, NULL, (LPBYTE)szPath, &dwTmp ) != ERROR_SUCCESS )
        {
            if ( GetProgramFilesDir( szPath, sizeof(szPath) ) )
            {
                MySetSpecialFolder( hkey, REGVAL_PROGRAMFILESPATH, szPath );
            }
        }

        // use wordpad.inf to look into the strings
        GetWindowsDirectory( szPath, sizeof(szPath) );
        AddPath( szPath, "inf\\wordpad.inf" );            

        // accessories Names
        for ( i=0; i<2; i++ )
        {
            if ( i == 0 )
            {
                // start menu name
                pszValName = REGVAL_SM_ACCESSORIES;
                pszKeyName = "APPS_DESC";
            }
            else
            {
                pszValName = REGVAL_PF_ACCESSORIES;
                if ( ctx.wOSVer >= _OSVER_WINNT40 )
                    pszKeyName = "APPS_DESC";
                else
                    pszKeyName = "Accessories";
            }

            dwTmp = sizeof( szAS );
            if ( RegQueryValueEx( hkey, pszValName, 0, NULL, (LPBYTE)szAS, &dwTmp ) != ERROR_SUCCESS )
            {       
                // need to open the new INF so save the current context
                if (SaveGlobalContext())
                {
                    if ( FAILED(GetTranslatedString(szPath, "Strings", pszKeyName, szAS, sizeof(szAS), NULL)))
                    {
                        lstrcpy(szAS, "Accessories");
                    }
                    RegSetValueExA( hkey, pszValName, 0, REG_SZ, szAS, lstrlen(szAS)+1 );
                    RestoreGlobalContext();
                }
            }
        }

        RegCloseKey(hkey);
    }

}

//-----------------------------------------------------------------------------------------
//
// ProcessPerUserSec
//
//-----------------------------------------------------------------------------------------

HRESULT ProcessPerUserSec( PCSTR pcszInf, PCSTR pcszSec )
{
    char szSec[MAX_PATH];
    DWORD dwTmp;
    HRESULT hRet = S_OK;
    PERUSERSECTION PU_Sec = {0};


    if (SUCCEEDED(GetTranslatedString(pcszInf, pcszSec, ADVINF_PERUSER, szSec, sizeof(szSec), NULL)))
    {
        AdvWriteToLog("ProcessPerUserSec: \r\n");
        AdvWriteToLog("Inf=%1, InstallSec=%2, PerUserInstall=%3\r\n", pcszInf, pcszSec, szSec);
        // get GUID to create subkey
        if ( SUCCEEDED( GetTranslatedString( pcszInf, szSec, ADVINF_PU_GUID, PU_Sec.szGUID, sizeof(PU_Sec.szGUID), &dwTmp) ) )
        {                        
            PU_Sec.dwIsInstalled = GetTranslatedInt(pcszInf, szSec, ADVINF_PU_ISINST, 999);
            PU_Sec.bRollback = (BOOL)GetTranslatedInt(pcszInf, szSec, ADVINF_PU_ROLLBK, 0);
            GetTranslatedString( pcszInf, szSec, ADVINF_PU_DSP, PU_Sec.szDispName, sizeof(PU_Sec.szDispName), &dwTmp);
            GetTranslatedString( pcszInf, szSec, ADVINF_PU_VER, PU_Sec.szVersion, sizeof(PU_Sec.szVersion), &dwTmp);
            GetTranslatedString( pcszInf, szSec, ADVINF_PU_STUB, PU_Sec.szStub, sizeof(PU_Sec.szStub), &dwTmp);
            GetTranslatedString( pcszInf, szSec, ADVINF_PU_LANG, PU_Sec.szLocale, sizeof(PU_Sec.szLocale), &dwTmp);
            GetTranslatedString( pcszInf, szSec, ADVINF_PU_CID, PU_Sec.szCompID, sizeof(PU_Sec.szCompID), &dwTmp);
   
            // since we are close to beta1, we may hack here to avoid the external comp changes
            //if (IsThisRollbkUninst(PU_Sec.szGUID))
            //    PU_Sec.bRollback = TRUE;

            hRet = SetPerUserSecValues(&PU_Sec);
        }
        else
        {
            AdvWriteToLog("Failure: No GUID specified\r\n");
            //hRet = E_FAIL;  //unknown GUID, advpack will do nothing for this comp!
        }
        AdvWriteToLog("ProcessPerUserSec: End hr=0x%1!x!\r\n", hRet);
    }
    
    return hRet;
}

//-----------------------------------------------------------------------------------------
//
// SetPerUserSecValues help functions
//
//-----------------------------------------------------------------------------------------
    
BOOL CopyRegValue( HKEY hFromkey, HKEY hTokey, LPCSTR pszFromVal, LPCSTR pszToVal)
{
    DWORD dwSize,dwType;
    char  szBuf[BUF_1K];
    BOOL  bRet = FALSE;

    //backup the older reg values    
    //AdvWriteToLog("CopyRegValue:");
    dwSize = sizeof(szBuf);
    if (RegQueryValueEx(hFromkey, pszFromVal, NULL, &dwType, (LPBYTE)szBuf, &dwSize)==ERROR_SUCCESS)
    {
        if (RegSetValueEx(hTokey, pszToVal, 0, dwType, szBuf, lstrlen(szBuf)+1)==ERROR_SUCCESS)
        {
            //AdvWriteToLog("From %1 to %2: %3", pszFromVal, pszToVal, szBuf);
            bRet = TRUE;
        }
    }
    //AdvWriteToLog("\r\n");
    return bRet;
}

void SetSecRegValues( HKEY hSubKey, PPERUSERSECTION pPU, BOOL bUseStubWrapper )
{
    char szBuf[BUF_1K];

    if (pPU->szStub[0]) 
    {
        if (ctx.wOSVer >= _OSVER_WINNT40)
        {
            AddEnvInPath( pPU->szStub, szBuf );
            if (bUseStubWrapper)
                RegSetValueEx( hSubKey, REGVAL_REALSTUBPATH, 0, REG_EXPAND_SZ, szBuf, lstrlen(szBuf)+1 );
            else
                RegSetValueEx( hSubKey, ADVINF_PU_STUB, 0, REG_EXPAND_SZ, szBuf, lstrlen(szBuf)+1 );
        }
        else 
        {
            if (bUseStubWrapper)
                RegSetValueEx( hSubKey, REGVAL_REALSTUBPATH, 0, REG_SZ, pPU->szStub, lstrlen(pPU->szStub)+1 );
            else
                RegSetValueEx( hSubKey, ADVINF_PU_STUB, 0, REG_SZ, pPU->szStub, lstrlen(pPU->szStub)+1 );
        }
    }

    if (pPU->szVersion[0])
    {
        RegSetValueEx( hSubKey, ADVINF_PU_VER, 0, REG_SZ, pPU->szVersion, lstrlen(pPU->szVersion)+1 );
        // if we update the base version value, delete the previous QFE version
        RegDeleteValue( hSubKey, "QFEVersion" );
    }

    if (pPU->szLocale[0])        
        RegSetValueEx( hSubKey, ADVINF_PU_LANG, 0, REG_SZ, pPU->szLocale, lstrlen(pPU->szLocale)+1 );

    if (pPU->szCompID[0])
        RegSetValueEx( hSubKey, ADVINF_PU_CID, 0, REG_SZ, pPU->szCompID, lstrlen(pPU->szCompID)+1 );

    if (pPU->szDispName[0])
        RegSetValueEx( hSubKey, "", 0, REG_SZ, pPU->szDispName, lstrlen(pPU->szDispName)+1 );

    RegSetValueEx( hSubKey, ADVINF_PU_ISINST, 0, REG_DWORD, (LPBYTE)&(pPU->dwIsInstalled), sizeof(DWORD) );

}

//-----------------------------------------------------------------------------------------
//
// SetPerUserSecValues
//
//-----------------------------------------------------------------------------------------

HRESULT WINAPI SetPerUserSecValues( PPERUSERSECTION pPU )
{
    HKEY hkey = NULL;
    HKEY hSubKey = NULL;
    HKEY hCUKey;
    HRESULT hRet = S_OK;
    DWORD dwTmp, dwSize;
    char szBuf[BUF_1K];
    BOOL bStubWrapper = FALSE;

    AdvWriteToLog("SetPerUserSecValues:\r\n");

    if ( (pPU == NULL) || (pPU->szGUID[0]==0) )
    {        
        AdvWriteToLog("SetPerUserSecValues: End Warning: No Data\r\n");
        return hRet;
    }

    AdvWriteToLog("Input params: %1,%2,%3,%4,%5,%6\r\n",
                  pPU->szGUID, pPU->szDispName, pPU->szLocale, pPU->szStub, pPU->szVersion,
                  pPU->dwIsInstalled ? "1" : "0");
    
    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, c_szActiveSetupKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                         NULL, &hkey, &dwTmp ) != ERROR_SUCCESS )
    {
        hRet = E_FAIL;
        AdvWriteToLog("Failure: Cannot open %1 key\r\n", c_szActiveSetupKey);
        goto done;
    }

    if ( RegCreateKeyEx( hkey, pPU->szGUID, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE,
                         NULL, &hSubKey, &dwTmp ) != ERROR_SUCCESS )
    {
        hRet = E_FAIL;
        AdvWriteToLog("Failure: Cannot create %1 key\r\n", pPU->szGUID);
        goto done;
    }          

    if (pPU->dwIsInstalled == 1)
    {
        // This is the install case. Need to do the following tasks:
        //
        // 1) If the given GUID key exists, has IsInstalled set to 1. Then check
        //    if the existing major version is smaller than the one to be installed. If so,
        //    backup the existing Version, Locale, StubPath values to OldVersion, OldLocale,
        //    OldStubPath first. Set the StubPath to advpack Install Stub Wrapper function.
        //    Set the Version, Locale, InstallStubPath based on the current INF PerUserInstall section values.
        // 2) If there is no exist GUID key or the existing GUID key has IsInstalled set to 0,
        //    just set the current values and set IsInstalled to 1. ( as it is today)
        // 3) Delete {GUID}.Restore key if exists.
        //
        dwSize = sizeof(DWORD);
        if ((pPU->bRollback) &&   
            (RegQueryValueEx(hSubKey, ADVINF_PU_ISINST, NULL, NULL, (LPBYTE)&dwTmp, &dwSize)==ERROR_SUCCESS) &&
            (dwTmp == 1) )
        {
            WORD wRegVer[4], wInfVer[4];

            // case (1)
            dwSize = sizeof(szBuf);
            if (RegQueryValueEx(hSubKey, ADVINF_PU_VER, NULL, NULL, (LPBYTE)szBuf, &dwSize)==ERROR_SUCCESS)
            {
                ConvertVersionString(szBuf, wRegVer, ',');
                if (pPU->szVersion[0])
                {
                    ConvertVersionString(pPU->szVersion, wInfVer, ',');
                    // we only rollback to previous major version now so we only compare major ver.
                    if ( wRegVer[0] < wInfVer[0] )
                    {
                        CopyRegValue(hSubKey, hSubKey, "", REGVAL_OLDDISPN);
                        CopyRegValue(hSubKey, hSubKey, ADVINF_PU_VER, REGVAL_OLDVER);
                        CopyRegValue(hSubKey, hSubKey, ADVINF_PU_LANG, REGVAL_OLDLANG);                        
                        if (CopyRegValue(hSubKey, hSubKey, ADVINF_PU_STUB, REGVAL_OLDSTUB))
                        {
                            CopyRegValue(hSubKey, hSubKey, REGVAL_REALSTUBPATH, REGVAL_OLDREALSTUBPATH);

                            wsprintf(szBuf, ADV_INSTSTUBWRAPPER, pPU->szGUID);                        
                            RegSetValueEx( hSubKey, ADVINF_PU_STUB, 0, REG_SZ, szBuf, lstrlen(szBuf)+1 );
                            bStubWrapper = TRUE;
                        }
                    }
                    else  
                    {
                        // the case user have already backup the previous state, we only update
                        // the real stub path since its StubPath will point to Wrapper function
                        dwSize = sizeof(szBuf);
                        if (RegQueryValueEx(hSubKey, REGVAL_REALSTUBPATH, NULL, NULL, (LPBYTE)szBuf, &dwSize)==ERROR_SUCCESS)
                            bStubWrapper = TRUE;
                    }
                }
            }
        }

        // case (2)
        SetSecRegValues(hSubKey, pPU, bStubWrapper);

        // case (3)
        lstrcpy(szBuf, pPU->szGUID);
        lstrcat(szBuf, ".Restore");
        RegDeleteKey(hkey, szBuf);           
    }
    else if (pPU->dwIsInstalled == 0)
    {
        // This is the uninstall case, need to do the following tasks
        //
        // 1) If the {GUID} key OldVersion, OldStubpath, OldLocale exist, set them back to Version, Locale StubPath value and set IsInstall to 1 to reflect the current install state;
        // 2) Then, Create the '{GUID}.Restore' key with the values of the version ( adjusted max( GUIDs Version, GUIDs MaxRestoreVersion)+1 ), locale, stubpath calling 
        //    advpack.dll UserStubWraper with the {GUID}.Restore as param and the RestoreStubPath with the INF StubPath value.  Set IsInstalled to 1.
        // 3) If none of the above is applied, just set the current GUID key IsInstall to 0 like it is now.
        //
        if (CopyRegValue(hSubKey, hSubKey, REGVAL_OLDVER, ADVINF_PU_VER))
        {
            HKEY hResKey;

            // case (1)
            // restore the old version data
            CopyRegValue(hSubKey, hSubKey, REGVAL_OLDDISPN, "");
            CopyRegValue(hSubKey, hSubKey, REGVAL_OLDLANG, ADVINF_PU_LANG);
            if(CopyRegValue(hSubKey, hSubKey, REGVAL_OLDSTUB, ADVINF_PU_STUB))
            {
                CopyRegValue(hSubKey, hSubKey, REGVAL_OLDREALSTUBPATH, REGVAL_REALSTUBPATH);            

                // case (2)
                lstrcpy(szBuf, pPU->szGUID);
                lstrcat(szBuf, ".Restore" );
                if (RegCreateKeyEx(hkey, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE,
                                   NULL, &hResKey, &dwTmp ) == ERROR_SUCCESS )
                {
                    wsprintf(szBuf, ADV_UNINSTSTUBWRAPPER, pPU->szGUID);
                    RegSetValueEx(hResKey, ADVINF_PU_STUB, 0, REG_SZ, szBuf, lstrlen(szBuf)+1);                
                    bStubWrapper = TRUE;

                    // also copy DontAskFlag
                    CopyRegValue(hSubKey, hResKey, c_szRegDontAskValue, c_szRegDontAskValue);                            

                    SetSecRegValues(hResKey, pPU, bStubWrapper);
                    RegCloseKey(hResKey);
                }
            }

            // cleanup the backup data
            RegDeleteValue(hSubKey, REGVAL_OLDDISPN);
            RegDeleteValue(hSubKey, REGVAL_OLDLANG);
            RegDeleteValue(hSubKey, REGVAL_OLDVER);
            RegDeleteValue(hSubKey, REGVAL_OLDSTUB);
            RegDeleteValue(hSubKey, REGVAL_OLDREALSTUBPATH);
        }
        else
        {
            // case (3)
            SetSecRegValues(hSubKey, pPU, bStubWrapper);
        }
    }

done:
    if ( hSubKey )
        RegCloseKey( hSubKey );

    if ( hkey )
        RegCloseKey( hkey );

    AdvWriteToLog("SetPerUserSecValues: End hr=0x%1!x!\r\n", hRet);

    return hRet;
}

//-----------------------------------------------------------------------------------------
//
//  PerUser Install stub wrapper
//
//-----------------------------------------------------------------------------------------

HRESULT WINAPI UserInstStubWrapper(HWND hwnd, HINSTANCE hInst, LPSTR pszParams, INT nShow)
{
    HKEY hkList, hkcuGUIDRes, hkGUID;
    char szBuf[MAX_PATH];
    DWORD cbData,dwType;
    HRESULT hRet = S_OK;

    /* Component is an uninstall stub. */
    if ((pszParams == NULL) || (*pszParams == 0))
    {
        hRet = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        return hRet;
    }

    AdvWriteToLog("UserInstStubWrapper:\r\n");
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szActiveSetupKey, 0,
                       KEY_READ, &hkList) == ERROR_SUCCESS) 
    {
        if ( RegOpenKeyEx(hkList, pszParams, 0, KEY_READ, &hkGUID) == ERROR_SUCCESS) 
        {
            // run the real stub first
            cbData = sizeof(szBuf);
            if ((RegQueryValueEx(hkGUID, REGVAL_REALSTUBPATH, NULL, &dwType, 
                                (LPBYTE)szBuf, &cbData) == ERROR_SUCCESS) && szBuf[0])
            {
                char szBuf2[MAX_PATH*2];

                if (dwType == REG_EXPAND_SZ)                
                    ExpandEnvironmentStrings(szBuf, szBuf2, sizeof(szBuf2));                
                else
                    lstrcpy(szBuf2,szBuf);

                if ( LaunchAndWait( szBuf2, NULL, NULL, INFINITE, RUNCMDS_QUIET ) == E_FAIL )
                {
                    char szMessage[BIG_STRING];

                    hRet = HRESULT_FROM_WIN32(GetLastError());
                    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                                   szMessage, sizeof(szMessage), NULL );
                    ErrorMsg2Param( ctx.hWnd, IDS_ERR_CREATE_PROCESS, szBuf2, szMessage );
                    RegCloseKey(hkGUID);
                    RegCloseKey(hkList);
                    return hRet;
                }
            }    

            // create {GUID}.Restore to enable the uninstall later
            lstrcpy(szBuf, c_szActiveSetupKey);
            AddPath(szBuf, pszParams);
            lstrcat(szBuf,".Restore");
            if (RegCreateKeyEx( HKEY_CURRENT_USER, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, 
                                KEY_READ|KEY_WRITE, NULL, &hkcuGUIDRes, &cbData) == ERROR_SUCCESS) 
            {
                CopyRegValue(hkGUID, hkcuGUIDRes, ADVINF_PU_VER, ADVINF_PU_VER);
                CopyRegValue(hkGUID, hkcuGUIDRes, ADVINF_PU_LANG, ADVINF_PU_LANG);
                
                RegCloseKey(hkcuGUIDRes);                  
            }
            RegCloseKey(hkGUID);            
        }          
        RegCloseKey(hkList);
    }
    AdvWriteToLog("UserInstStubWrapper: End hr=0x%1!x!\r\n", hRet);
    return hRet;
}

//-----------------------------------------------------------------------------------------
//
// PerUser uninstall stub wrapper
//
//-----------------------------------------------------------------------------------------

HRESULT WINAPI UserUnInstStubWrapper(HWND hwnd, HINSTANCE hInst, LPSTR pszParams, INT nShow)
{
    HKEY hkList, hkGUIDRes, hkGUID, hkcuGUID;
    char szBuf[MAX_PATH];
    DWORD cbData, dwType;
    HRESULT hRet = S_OK;

    
    /* Component is an uninstall stub. */
    if ((pszParams == NULL) || (*pszParams == 0))
    {
        hRet = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        return hRet;
    }
    AdvWriteToLog("UserUnInstStubWrapper:\r\n");
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szActiveSetupKey, 0,
                       KEY_READ|KEY_WRITE, &hkList) == ERROR_SUCCESS) 
    {
        // restore the Installed IE version from HKLM
        if ( RegOpenKeyEx( hkList, pszParams, 0, KEY_READ, &hkGUID) == ERROR_SUCCESS) 
        {
            lstrcpy(szBuf, c_szActiveSetupKey);
            AddPath(szBuf, pszParams);
            if ( RegOpenKeyEx( HKEY_CURRENT_USER, szBuf, 0,
                               KEY_READ|KEY_WRITE, &hkcuGUID) == ERROR_SUCCESS) 
            {
                CopyRegValue(hkGUID, hkcuGUID, ADVINF_PU_VER, ADVINF_PU_VER);
                CopyRegValue(hkGUID, hkcuGUID, ADVINF_PU_LANG, ADVINF_PU_LANG);
                RegCloseKey(hkcuGUID);
            }
            RegCloseKey(hkGUID);
        }
          
        // run the stub if needed
        lstrcpy(szBuf, pszParams);
        lstrcat(szBuf,".Restore");

        if (RegOpenKeyEx( hkList, szBuf, 0, KEY_READ, &hkGUIDRes) == ERROR_SUCCESS) 
        {
            cbData = sizeof(szBuf);
            if ((RegQueryValueEx(hkGUIDRes, REGVAL_REALSTUBPATH, NULL, &dwType, 
                                (LPBYTE)szBuf, &cbData) == ERROR_SUCCESS) && szBuf[0])
            {
                char szBuf2[MAX_PATH*2];

                if (dwType == REG_EXPAND_SZ)                
                    ExpandEnvironmentStrings(szBuf, szBuf2, sizeof(szBuf2));                
                else
                    lstrcpy(szBuf2,szBuf);

                if ( LaunchAndWait( szBuf2, NULL, NULL, INFINITE, RUNCMDS_QUIET ) == E_FAIL )
                {
                    char szMessage[BIG_STRING];

                    hRet = HRESULT_FROM_WIN32(GetLastError());
                    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                                   szMessage, sizeof(szMessage), NULL );
                    ErrorMsg2Param( ctx.hWnd, IDS_ERR_CREATE_PROCESS, szBuf2, szMessage );
                }
            }    
            RegCloseKey(hkGUIDRes);
        }    
        RegCloseKey(hkList);
    }
    AdvWriteToLog("UserUnInstStubWrapper: End hr=0x%1!x!\r\n", hRet);
    return hRet;
}

                                                                          
//***************************************************************************
//*                                                                         *
//* NAME:       TranslateInfStringEx                                        *
//*                                                                         *
//* SYNOPSIS:   Translates a string in an Advanced inf file -- replaces     *
//*             LDIDs with the directory. This new API requires called to   *
//*             init the INF first for efficiency.                          *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI TranslateInfStringEx( HINF hInf, PCSTR pszInfFilename, 
                                     PCSTR pszTranslateSection, PCSTR pszTranslateKey,
                                     PSTR pszBuffer, DWORD dwBufferSize,
                                     PDWORD pdwRequiredSize, PVOID pvReserved )
{
    HRESULT hReturnCode = S_OK;

    // Validate parameters
    if ( (hInf != ctx.hInf) || pszInfFilename == NULL  || pszTranslateSection == NULL
         || pszTranslateKey == NULL || pdwRequiredSize == NULL )
    {
        hReturnCode = E_INVALIDARG;
        goto done;
    }

    hReturnCode = GetTranslatedString( pszInfFilename, pszTranslateSection, pszTranslateKey,
                                       pszBuffer, dwBufferSize, pdwRequiredSize );

  done:
    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       OpenINFEngine                                               *
//*                                                                         *
//* SYNOPSIS:   Initialize the INF Engine and open INF file for use.        *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    HINF hInf the opened INF file handle                        *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI OpenINFEngine( PCSTR pszInfFilename, PCSTR pszInstallSection,                                                                      
                              DWORD dwFlags, HINF *phInf, PVOID pvReserved )
{
    HRESULT hReturnCode = S_OK;
    CHAR   szRealInstallSection[256];
    BOOL   fSaveContext = FALSE;

    // Validate parameters
    if ( (pszInfFilename == NULL) || !phInf)         
    {
        hReturnCode = E_INVALIDARG;
        goto done;
    }

    *phInf = NULL;

    if (!SaveGlobalContext())
    {
        hReturnCode = E_OUTOFMEMORY;
        goto done;
    }
    fSaveContext = TRUE;

    ctx.wQuietMode = QUIETMODE_ALL;

   
    hReturnCode = CommonInstallInit( pszInfFilename, pszInstallSection,
                                     szRealInstallSection, sizeof(szRealInstallSection), NULL, FALSE, 0 );
    if ( FAILED( hReturnCode ) ) {
        goto done;
    }

    if ( ctx.dwSetupEngine != ENGINE_SETUPAPI ) 
    {
        hReturnCode = E_UNEXPECTED;
        goto done;
    }

    hReturnCode = SetLDIDs( (LPSTR)pszInfFilename, szRealInstallSection, 0, NULL );
    if ( FAILED( hReturnCode ) ) {
        goto done;
    }

    *phInf = ctx.hInf;

done:
    if ( FAILED(hReturnCode) )
    {
        CommonInstallCleanup();
        if ( fSaveContext )
        {
            RestoreGlobalContext();
        }
    }

    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       CloseINFEngine                                              *
//*                                                                         *
//* SYNOPSIS:   Close the INF Engine and the current INF file.              *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    HINF hInf the opened INF file handle                        *
//*                                                                         *
//***************************************************************************
HRESULT WINAPI CloseINFEngine( HINF hInf )
{
    if ( hInf == ctx.hInf )
    {
        CommonInstallCleanup();
        RestoreGlobalContext();
    }
    else
        return E_INVALIDARG;
            
    return S_OK;
}

#define BACKUPBASE "%s.%03d"

BOOL GetUniBackupName( HKEY hKey, LPSTR pszBackupBase, DWORD dwInSize, LPCSTR pszBackupPath, LPCSTR pszModule )
{
    char szBuf[MAX_PATH];
    DWORD dwSize;
    BOOL  bFound = FALSE;


    // 1st check to see if the backup filename already in registry, if so, we use it.
    dwSize = sizeof( szBuf );
    if ( RegQueryValueEx(hKey, REGVAL_BKFILE, NULL, NULL, szBuf, &dwSize) == ERROR_SUCCESS )
    {
        LPSTR pszTmp;

        pszTmp = ANSIStrRChr( szBuf, '\\' );
        if ( pszTmp )
        {
            lstrcpy( pszBackupBase, CharNext(pszTmp) );
            pszTmp = ANSIStrRChr( pszBackupBase, '.' );
            if ( pszTmp && (lstrcmpi(pszTmp, ".dat")==0) )
            {
               *pszTmp = 0;
            }               
            bFound = TRUE;
        }
    }

    if ( !bFound )
    {
        int i;
        char szFilePath[MAX_PATH];

        // 2nd, check to see if the default Module name has been used as the basename
        lstrcpy( szFilePath, pszBackupPath );
        AddPath( szFilePath, pszModule );
        lstrcat( szFilePath, ".dat" );
        if ( !FileExists(szFilePath) )
        {
           bFound = TRUE;
           lstrcpy( pszBackupBase, pszModule );
        }
        else
        {
           for ( i = 1; i<999; i++ )
           {
               wsprintf( szBuf, BACKUPBASE, pszModule, i );
               lstrcpy( szFilePath, pszBackupPath);
               AddPath( szFilePath, szBuf );
               lstrcat( szFilePath, ".dat" );
               if ( !FileExists(szFilePath) )
               {
                   bFound = TRUE;
                   lstrcpy( pszBackupBase, szBuf );
                   break;
               }
           }
        }
    }

    return bFound;
}


BOOL GetUniHiveKeyName( HKEY hKey, LPSTR pszRegHiveKey, DWORD dwInSize, LPCSTR pszBackupPath )
{
    char szBuf[MAX_PATH];
    DWORD dwSize;
    BOOL  bFound = FALSE;

    // For each component, we always try to get the HIVE key from the reg backup filename
    // 4 possibilities exist:
    // Case 1: Reg uinstall file exists but IE4RegBackup doesn't exist
    //          - user is upgrading over IE4, load the file as a hive

    // Case 2: Reg uinstall file doesn't exist and IE4RegBackup doesn't exist
    //          - clean install, create a hive under HKEY_LOCAL_MACHINE

    // Case 3: Reg uninstall file doesn't exist but IE4RegBackup exists
    //          - user is upgrading over an older IE4 build which saved
    //            the reg backup info into the registry itself, call RegSaveKey
    //            to export the backup key to a file, then delete the backup key
    //             and load the file as a hive

    // Case 4: Reg uninstall file exists and IE4RegBackup exists
    //          - THIS CASE SHOULDN'T HAPPEN AT ALL!  If somehow happens,
    //            we will default to Case 1.

    // For case 1 & 4:  we should get the hive key name out of the existing reg value data
    // For case 2 & 3:  we should generate the unique hive key name with "AINF%d" format
    dwSize = sizeof( szBuf );
    if ( RegQueryValueEx(hKey, c_szRegUninstPath, NULL, NULL, szBuf, &dwSize) == ERROR_SUCCESS )
    {
        LPSTR pszTmp;

        pszTmp = ANSIStrRChr( szBuf, '\\' );
        if ( pszTmp )
        {
            lstrcpy( pszRegHiveKey, CharNext(pszTmp) );
            bFound = TRUE;
        }
    }

    if ( !bFound )
    {
        int i;
        HKEY hKey;
        char szRegFilePath[MAX_PATH];

        for ( i = 0; i<9999; i++ )
        {
            wsprintf( szBuf, c_szHiveKey_FMT, i );
            if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, szBuf, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
            {
                RegCloseKey( hKey );
            }
            else 
            {
                lstrcpy( szRegFilePath, pszBackupPath);
                AddPath( szRegFilePath, szBuf );
                if ( GetFileAttributes( szRegFilePath ) == (DWORD)-1 )
                {
                  bFound = TRUE;
                  lstrcpy( pszRegHiveKey, szBuf );
                  break;
                }
            }
        }
    }

    return bFound;
}


void SetPathForRegHiveUse( LPSTR pszPath, DWORD * adwAttr, int iLevels, BOOL bSave )
{
    int i;
    char  szBuf[MAX_PATH];

    lstrcpy( szBuf, pszPath );
    // create the folder if it does not exist without hiden
    if ( bSave )
        CreateFullPath( szBuf, FALSE );
    for ( i =0; i<iLevels ; i++ )
    {
        if ( bSave )
        {
            adwAttr[i] = GetFileAttributes( szBuf );
            SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
        }
        else
        {
            SetFileAttributes( szBuf, adwAttr[i] );
        }
        if ( !GetParentDir( szBuf ) )
            break;
    }
}

BOOL NeedBackupData(LPCSTR pszInf, LPCSTR pszSec)
{
    char szBuf[MAX_PATH];
    BOOL bRet = TRUE;   

    if ( (ctx.wOSVer >= _OSVER_WINNT50) &&
         GetEnvironmentVariable( "Upgrade", szBuf, sizeof(szBuf) ) )
    {
         if ( GetModuleFileName( NULL, szBuf, sizeof(szBuf) ) )
         {
             LPSTR pszFile;

             // if setup.exe is last filenane
             pszFile = ANSIStrRChr( szBuf,'\\' );
             if ( pszFile++ && (lstrcmpi(pszFile,"setup.exe")==0) )
                 bRet = FALSE;
         }
    }
    
    if (bRet)
    {
        // check if INF specify not backup on this platform
        if (SUCCEEDED(GetTranslatedString(pszInf, pszSec, ADVINF_NOBACKPLATF, szBuf, sizeof(szBuf), NULL)) && szBuf[0])
        {
            char szInfPlatform[10];
            int i = 0;
                
            while (GetFieldString(szBuf, i++, szInfPlatform, sizeof(szInfPlatform)))
            {
                if (!lstrcmpi(c_pszPlatform[ctx.wOSVer], szInfPlatform))
                {
                    bRet = FALSE;
                    break;
                }                
            }
        }
    }
        
    return bRet;
}

void DeleteOldBackupData( HKEY hKey )
{
    CHAR szBuf[MAX_PATH];
    DWORD   dwSize;

    // delete the backup files
    dwSize = sizeof(szBuf);
    if ( RegQueryValueEx( hKey, REGVAL_BKFILE, NULL, NULL, szBuf, &dwSize ) == ERROR_SUCCESS )
    {
        LPSTR pszExt;

        SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( szBuf );

        pszExt = ANSIStrRChr( szBuf, '.' );
        if ( pszExt )
        {
            lstrcpy( pszExt, ".INI" );
            SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
            DeleteFile( szBuf );
        }

        // delete the catalogs
        dwSize = sizeof(szBuf);
        if (RegQueryValueEx(hKey, REGVAL_BKDIR, NULL, NULL, szBuf, &dwSize) == ERROR_SUCCESS)
        {
            HKEY hkCatalogKey;

            if (RegOpenKeyEx(hKey, REGSUBK_CATALOGS, 0, KEY_READ, &hkCatalogKey) == ERROR_SUCCESS)
            {
                CHAR szCatalogName[MAX_PATH];
                DWORD dwIndex;

                dwIndex = 0;
                dwSize = sizeof(szCatalogName);
                while (RegEnumValue(hkCatalogKey, dwIndex, szCatalogName, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                {
                    CHAR szFullCatalogName[MAX_PATH];

                    lstrcpy(szFullCatalogName, szBuf);
                    AddPath(szFullCatalogName, szCatalogName);

                    SetFileAttributes(szFullCatalogName, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(szFullCatalogName);

                    dwIndex++;
                    dwSize = sizeof(szCatalogName);
                }

                RegCloseKey(hkCatalogKey);
            }
        }
    }

    // delete reg data backup file if there
    dwSize = sizeof(szBuf);
    if ( RegQueryValueEx( hKey, c_szRegUninstPath, NULL, NULL, szBuf, &dwSize ) == ERROR_SUCCESS )
    {
        SetFileAttributes( szBuf, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( szBuf );
    }

    return;
}   

BOOL RemoveBackupBaseOnVer( LPCSTR pszInf, LPCSTR pszSection )
{ 
    BOOL fRet = TRUE;
    char szBuf[MAX_PATH], szModule[MAX_PATH];
    HKEY hKey, hRootKey;
    DWORD dwSize;
    WORD  wInfVer, wRegVer;

    if (FAILED(GetTranslatedString( pszInf, pszSection, ADVINF_MODNAME, szModule, sizeof(szModule), NULL)))
    {
        // no ops if there is no ComponentName
        goto done;
    }

    // Check if the Component MajorVer matches up the backup data version stamp, if not, delete the old backup data.
    //
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGKEY_SAVERESTORE, 0, KEY_WRITE|KEY_READ, &hRootKey) == ERROR_SUCCESS)
    {
        if ( RegOpenKeyEx( hRootKey, szModule, 0, KEY_WRITE|KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szBuf);
            if ( RegQueryValueEx( hKey, REGVAL_BKMODVER, NULL, NULL, szBuf, &dwSize ) == ERROR_SUCCESS )
            {
                WORD wVer[4];
        
                ConvertVersionString( szBuf, wVer, '.' );
                wRegVer = wVer[0];  // taking Major version only
            }
            else
                wRegVer = 0;       // indication no version stamp

            if (SUCCEEDED(GetTranslatedString(pszInf, pszSection, ADVINF_MODVER, szBuf, sizeof(szBuf), NULL)))
            {
                WORD wVer[4];
        
                ConvertVersionString( szBuf, wVer, '.' );
                wInfVer = wVer[0];  // taking Major version only
            }
            else
                wInfVer = 0;       // indication no version stamp

            if ( wInfVer > wRegVer )
            {
                // delete HKLM branch
                DeleteOldBackupData( hKey );
                RegCloseKey( hKey );                
                RegDeleteKeyRecursively( hRootKey, szModule );
                
                // delete HKCU branch
                if ( RegOpenKeyEx( HKEY_CURRENT_USER, REGKEY_SAVERESTORE, 0, KEY_WRITE, &hKey) == ERROR_SUCCESS)
                {
                    RegDeleteKeyRecursively( hKey, szModule );
                    RegCloseKey( hKey );
                }
                hKey = NULL;
            }
            if ( hKey )
            {
                RegCloseKey( hKey );             
            }
        }
        RegCloseKey( hRootKey );       
    }

done:
    return fRet;
}


VOID AdvStartLogging()
{
    CHAR szBuf[MAX_PATH], szLogFileName[MAX_PATH];
    HKEY hKey;

    // Need to 0 the buffer, becauce if the registry branch below does not exist
    // Advpack would use what ever (garbage) was in the buffer to create a log file
    *szLogFileName = '\0';
    // check if logging is enabled
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SAVERESTORE, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwDataLen = sizeof(szLogFileName);

        if (RegQueryValueEx(hKey, "AdvpackLogFile", NULL, NULL, szLogFileName, &dwDataLen) != ERROR_SUCCESS)
            *szLogFileName = '\0';

        RegCloseKey(hKey);
    }

    if (*szLogFileName)
    {
        if (szLogFileName[1] != ':')           // crude way of determining if fully qualified path is specified or not
        {
            GetWindowsDirectory(szBuf, sizeof(szBuf));          // default to windows dir
            AddPath(szBuf, szLogFileName);
        }
        else
            lstrcpy(szBuf, szLogFileName);

        if ((g_hAdvLogFile == INVALID_HANDLE_VALUE) && 
            (g_hAdvLogFile = CreateFile(szBuf, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
            SetFilePointer(g_hAdvLogFile, 0, NULL, FILE_END);      // append logging info to the file
    }
}


VOID AdvWriteToLog(PCSTR pcszFormatString, ...)
{
    va_list vaArgs;
    LPSTR pszFullErrMsg = NULL;
    DWORD dwBytesWritten;

    if (g_hAdvLogFile != INVALID_HANDLE_VALUE)
    {
        va_start(vaArgs, pcszFormatString);

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                      (LPCVOID) pcszFormatString, 0, 0, (LPSTR) &pszFullErrMsg, 0, &vaArgs);

        if (pszFullErrMsg != NULL)
        {
            WriteFile(g_hAdvLogFile, pszFullErrMsg, lstrlen(pszFullErrMsg), &dwBytesWritten, NULL);
            LocalFree(pszFullErrMsg);
        }
    }
}


VOID AdvStopLogging()
{
    if (g_hAdvLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hAdvLogFile);
        g_hAdvLogFile = INVALID_HANDLE_VALUE;
    }
}

VOID AdvLogDateAndTime()
{
    if (g_hAdvLogFile != INVALID_HANDLE_VALUE)
    {
        SYSTEMTIME SystemTime;

        GetLocalTime(&SystemTime);

        AdvWriteToLog("Date: %1!02d!/%2!02d!/%3!04d! (mm/dd/yyyy)\tTime: %4!02d!:%5!02d!:%6!02d! (hh:mm:ss)\r\n",
                                        SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,
                                        SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\mrcicode.c ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.C
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */

#include "mrcicode.h"                   /* prototype verification */

#include <assert.h>                     /* use NDEBUG to inhibit */
#include <setjmp.h>                     /* fast overflow recovery */

#define LOGCHASH        (13)            /* Log of max. no. of hash buckets */
#define CHASH           (1U << LOGCHASH) /* Reasonably large table */

#define hash(w)         ((w) & (CHASH - 1))
                                        /* Simply toss the high-order bits */
#define word(p)         ((p)[0] + (((p)[1]) << 8))
                                        /* Return word at location (above will work on ALPHA)*/

#define BITMASK(x)      ((1 << x) - 1)  /* returns lower 'x' bits set */

#define LOGDISPSMALL    (6)             /* Number of bits in small disp */
#define LOGDISPMED      (8)             /* Number of bits in medium disp */
#define LOGDISPBIG      (12)            /* Number of bits in big displacement */

#define MAXDISPSMALL    ((1 << LOGDISPSMALL) - 1)
                                        /* Maximum small displacement */
#define MAXDISPMED      ((1 << LOGDISPMED) + MAXDISPSMALL)
                                        /* Maximum medium displacement */
#define MAXDISPBIG      ((1 << LOGDISPBIG) + MAXDISPMED)
                                        /* Maximum big displacement */

#define MINDISPSMALL    (0)             /* Minimum small displacement */
#define MINDISPMED      (MAXDISPSMALL + 1)
                                        /* Minimum medium displacement */
#define MINDISPBIG      (MAXDISPMED + 1)/* Minimum big displacement */

#define DISPMAX         (MAXDISPBIG - 1)/* MAXDISPBIG is our end marker */

#define MINMATCH1       (2)             /* Minimum match length for MRCI1 */
#define MINMATCH2       (3)             /* Minimum match length for MRCI2 */
#define MAXMATCH        (512)           /* Maximum match length */

#define EOB             (0)             /* length used to mean end of block */

#define SECTOR          (512)           /* blocking factor */

#define SIG_SIZE        (4)             /* # of block type prefix bytes */


/* local variables */

#ifdef BIT16
#define     FARBSS      _far
#else
#define     FARBSS
#endif

static unsigned abits;                  /* Array of bits */
static unsigned cbitsleft;              /* Number of bits in abits */
static unsigned char FAR *pCompressed;  /* pointer into compressed data */
static unsigned cCompressed;            /* # bytes remaining @ pCompressed */
static jmp_buf bailout;                 /* longjmp if cCompressed exceeded */

static unsigned FARBSS ahash[CHASH];    /* Hash table */
static unsigned FARBSS alink[MAXDISPBIG];  /* Links */


/* compression internal functions */

#ifdef BIT16
#define  FAST  _near _pascal            /* speed up local calls */
#else
#define  FAST
#endif

static void FAST inithash(void);
static void FAST charbuf(unsigned c);
static void FAST putbits(unsigned bits,unsigned cbits);
static void FAST outlength(unsigned cb);

static void FAST mrci1outsingle(unsigned ch);
static void FAST mrci1outstring(unsigned disp,unsigned cb);

static void FAST mrci2outsingle(unsigned ch);
static void FAST mrci2outstring(unsigned disp,unsigned cb);

/* decompression internal functions */

static unsigned FAST getbit(void);
static unsigned FAST getbits(unsigned cbits);
static void FAST expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb);


/*
 *  (compress) Reset the hash tables between blocks.
 */

static void FAST inithash(void)
{
    unsigned FAR *entry;
    int i;

    entry = ahash;
    i = CHASH;

    do
    {
        *entry++ = (unsigned) -1;       /* Mark all entries as empty */
    } while (--i);
}


/*
 *  (compress) Add a character to compressed output buffer.
 */

static void FAST charbuf(unsigned c)
{
    if (cCompressed-- == 0)             /* make sure there's room */
    {
        longjmp(bailout,1);             /* Data expanding! */
    }

    *pCompressed++ = (unsigned char) c; /* Put character into buffer */
}


/*
 *  (compress) Write n bits to the compressed bitstream.
 */

static void FAST putbits(unsigned ab,unsigned cbits)
{
    do                                  /* Loop to emit bits */
    {
        if (cbits > cbitsleft)          /* if not enough space */
        {
            cbits -= cbitsleft;         /* doing partial */

            abits |= (ab << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            ab >>= cbitsleft;           /* clip sent bits */

            charbuf(abits);             /* Emit the buffer */
            cbitsleft = 8;              /* Reset buffer count */
            abits = 0;                  /* Reset buffer */
        }
        else                            /* can do all in one pass */
        {
            abits |= ((ab & BITMASK(cbits)) << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            cbitsleft -= cbits;         /* used up some buffer */

            if (cbitsleft == 0)         /* If buffer full */
            {
                charbuf(abits);         /* Emit the buffer */
                cbitsleft = 8;          /* Reset buffer count */
                abits = 0;              /* Reset buffer */
            }

            break;                      /* we've done all cbits */
        }
    } while (cbits);                    /* repeat until done */
}


/*
 *  (compress) Encode a length into the compressed stream.
 */

static void FAST outlength(unsigned cb)
{
    unsigned alogbits, clogbits;
    unsigned avaluebits, cvaluebits;

    assert(cb >= 2);                    /* Length must be at least two */
    assert(cb <= MAXMATCH);

    if (cb <= 2)
    {
        alogbits = 1;
        clogbits = 1;
        cvaluebits = 0;
    }
    else if (cb <= 4)
    {
        alogbits = 1 << 1;
        clogbits = 2;
        avaluebits = cb - 3;
        cvaluebits = 1;
    }
    else if (cb <= 8)
    {
        alogbits = 1 << 2;
        clogbits = 3;
        avaluebits = cb - 5;
        cvaluebits = 2;
    }
    else if (cb <= 16)
    {
        alogbits = 1 << 3;
        clogbits = 4;
        avaluebits = cb - 9;
        cvaluebits = 3;
    }
    else if (cb <= 32)
    {
        alogbits = 1 << 4;
        clogbits = 5;
        avaluebits = cb - 17;
        cvaluebits = 4;
    }
    else if (cb <= 64)
    {
        alogbits = 1 << 5;
        clogbits = 6;
        avaluebits = cb - 33;
        cvaluebits = 5;
    }
    else if (cb <= 128)
    {
        alogbits = 1 << 6;
        clogbits = 7;
        avaluebits = cb - 65;
        cvaluebits = 6;
    }
    else if (cb <= 256)
    {
        alogbits = 1 << 7;
        clogbits = 8;
        avaluebits = cb - 129;
        cvaluebits = 7;
    }
    else /* (cb <= 512) */
    {
        alogbits = 1 << 8;
        clogbits = 9;
        avaluebits = cb - 257;
        cvaluebits = 8;
    }

    putbits(alogbits,clogbits);

    if (cvaluebits)
    {
        putbits(avaluebits,cvaluebits);
    }
}


/*
 *  (MRCI1 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci1outsingle(unsigned ch)
{
    ch = (ch << 2) | ((ch & 0x80) ? 1 : 2);

    putbits(ch,9);
}

/*
 *  (MRCI2 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci2outsingle(unsigned ch)
{
    if (ch & 0x80)
    {
        putbits((ch << 2) | 3,9);
    }
    else
    {
        putbits(ch << 1,8);
    }
}

/*
 *  (MRCI1 compress) Encode a match into the compressed stream.
 */

static void FAST mrci1outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH1) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 2),LOGDISPSMALL + 2);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 3) | 3,LOGDISPMED + 3);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 3) | 7,LOGDISPBIG + 3);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb);                  /* Emit the match length */
    }
}

/*
 *  (MRCI2 compress) Encode a match into the compressed stream.
 */

static void FAST mrci2outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH2) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 3) | 1,LOGDISPSMALL + 3);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 4) | 5,LOGDISPMED + 4);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 4) | 13,LOGDISPBIG + 4);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb - 1);              /* Emit the match length */
    }
}

/*
 *  (MRCI1) MaxCompress
 */

unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'D';
    *pCompressed++ = 'S';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH1)   /* If we have a string match */
            {
                mrci1outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci1outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci1outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci1outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return((unsigned int)(pCompressed - pchcmpBase));   /* Return compressed size */
}


/*
 *  (MRCI2) MaxCompress
 */

unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'J';
    *pCompressed++ = 'M';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH2)   /* If we have a string match */
            {
                mrci2outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci2outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci2outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci2outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return((unsigned int)(pCompressed - pchcmpBase));   /* Return compressed size */
}

/*
 *  (decompress) Get a single bit from the compressed input stream.
 */

static unsigned FAST getbit(void)
{
    unsigned bit;                       /* Bit */

    if (cbitsleft)                      /* If bits available */
    {
        cbitsleft--;                    /* Decrement bit count */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }
    else                                /* no bits available */
    {
        if (cCompressed-- == 0)         /* If buffer empty */
        {
            longjmp(bailout,1);         /* input overrun */
        }

        cbitsleft = 7;                  /* Reset count */

        abits = *pCompressed++;         /* Get a byte */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }

    return(bit);                        /* Return the bit */
}


/*
 *  (decompress) Get multiple bits from the compressed input stream.
 */

static unsigned FAST getbits(unsigned cbits)
{
    unsigned bits;                      /* Bits to return */
    unsigned cbitsdone;                 /* number of bits added so far */
    unsigned cbitsneeded;               /* number of bits still needed */

    if (cbits <= cbitsleft)             /* If we have enough bits */
    {
        bits = abits;                   /* Get the bits */
        cbitsleft -= cbits;             /* Decrement bit count */
        abits >>= cbits;                /* Remove used bits */
    }
    else                                /* If we'll need to read more bits */
    {
        bits = 0;                       /* No bits set yet */
        cbitsdone = 0;                  /* no bits added yet */
        cbitsneeded = cbits;            /* bits needed */

        do
        {
            if (cbitsleft == 0)         /* If no bits ready */
            {
                if (cCompressed-- == 0) /* count down used */
                {
                    longjmp(bailout,1); /* if input overrun */
                }

                cbitsleft = 8;          /* Reset count */

                abits = *pCompressed++;  /* Get 8 new bits */
            }

            bits |= (abits << cbitsdone);  /* copy bits for output */

            if (cbitsleft >= cbitsneeded)  /* if enough now */
            {
                cbitsleft -= cbitsneeded;  /* reduce bits remaining available */
                abits >>= cbitsneeded;  /* discard used bits */
                break;                  /* got them */
            }
            else                        /* if not enough yet */
            {
                cbitsneeded -= cbitsleft;  /* reduce bits still needed */
                cbitsdone += cbitsleft;  /* increase shift for future bits */
                cbitsleft = 0;          /* reduce bits remaining available */
            }
        } while (cbitsneeded);          /* go back if more bits needed */
    }

    return(bits & BITMASK(cbits));      /* Return the bits */
}


/*
 *  (decompress) Expand a match.
 *
 *  Note: source overwrite is required (so we can't memcpy or memmove)
 */

static void FAST expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb)
{
    unsigned char FAR *source;
    unsigned char FAR *target;

    assert(cb != 0);

    target = *ppchout;                  /* where the bytes go */
    source = target - disp;             /* where the bytes come from */

    *ppchout += cb;                     /* Update the output pointer */

    while (cb--)
    {
        *target++ = *source++;
    }
}


/*
 *  (MRCI1) Decompress
 */

unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned b;                         /* A byte */
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'D') || (*pCompressed++ != 'S'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        b = getbits(2);                 /* get two bits */

        if (b == 1)                     /* If single byte 128..255 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) (getbits(7) | 0x80);
            continue;                   /* Next token */
        }

        if (b == 2)                     /* If single byte 0..127 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) getbits(7);
            continue;                   /* Next token */
        }

        if (b == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else  /* b == 3 */
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(b <= 15);                /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length);  /* Copy the match */
    }

    return((unsigned int)(pchout - pchdecBase));      /* Return decompressed size */
}

/*
 *  (MRCI2) Decompress
 */

unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'J') || (*pCompressed++ != 'M'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        if (getbit() == 0)              /* literal 00..7F */
        {
            *pchout++ = (unsigned char) getbits(7);

            continue;                   /* Next token */
        }

        if (getbit() == 1)              /* literal 80..FF */
        {
            *pchout++ = (unsigned char)(getbits(7) | 0x80);

            continue;                   /* Next token */
        }

        if (getbit() == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(length <= 15);           /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length + 1);  /* Copy the match */
    }

    return((unsigned int)(pchout - pchdecBase));      /* Return decompressed size */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\ntapi.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* NTAPI.H                                                                 *
//*                                                                         *
//***************************************************************************

#ifndef _NTAPI_H_
#define _NTAPI_H_

//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <windows.h>
#include <winerror.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <setupapi.h>
#include <wtypes.h>

//***************************************************************************
//* TYPE DEFINITIONS                                                        *
//***************************************************************************
typedef UINT  (WINAPI *PFSetupDefaultQueueCallback)( PVOID, UINT, UINT_PTR, UINT_PTR );
typedef BOOL  (WINAPI *PFSetupInstallFromInfSection)( HWND, HINF, PCSTR, UINT, HKEY, PCSTR, UINT, PSP_FILE_CALLBACK_A, PVOID, HDEVINFO, PSP_DEVINFO_DATA );
typedef HINF  (WINAPI *PFSetupOpenInfFile)( PCSTR, PCSTR, DWORD, PUINT );
typedef BOOL  (WINAPI *PFSetupOpenAppendInfFile)( PCSTR, HINF, PUINT );
typedef VOID  (WINAPI *PFSetupCloseInfFile)( HINF );
typedef PVOID (WINAPI *PFSetupInitDefaultQueueCallbackEx)( HWND,HWND,UINT,DWORD,PVOID );
typedef VOID  (WINAPI *PFSetupTermDefaultQueueCallback)( PVOID );
typedef BOOL  (WINAPI *PFSetupSetDirectoryId)( HINF, DWORD, PCSTR );
typedef BOOL  (WINAPI *PFSetupFindFirstLine)( HINF, PCSTR, PCSTR, PINFCONTEXT );
typedef BOOL  (WINAPI *PFSetupFindNextMatchLine)( PINFCONTEXT, PCSTR, PINFCONTEXT );
typedef BOOL  (WINAPI *PFSetupGetLineText)( PINFCONTEXT, HINF, PCSTR, PCSTR, PSTR, DWORD, PDWORD );
typedef BOOL  (WINAPI *PFSetupGetLineByIndex)( HINF, PCSTR, DWORD, PINFCONTEXT );
typedef BOOL  (WINAPI *PFSetupFindFirstLine)( HINF, PCSTR, PCSTR, PINFCONTEXT );
typedef BOOL  (WINAPI *PFSetupFindNextLine)( PINFCONTEXT, PINFCONTEXT );
typedef HSPFILEQ (WINAPI *PFSetupOpenFileQueue)( VOID );
typedef BOOL  (WINAPI *PFSetupCloseFileQueue)( HSPFILEQ );
typedef BOOL  (WINAPI *PFSetupQueueCopy)( HSPFILEQ, PCSTR, PCSTR, PCSTR, PCSTR, PCSTR, PCSTR, PCSTR, DWORD );
typedef BOOL  (WINAPI *PFSetupCommitFileQueue)( HWND, HSPFILEQ, PSP_FILE_CALLBACK_A, PVOID );
typedef BOOL  (WINAPI *PFSetupGetStringField)(PINFCONTEXT, DWORD, PSTR, DWORD, PDWORD);  

//***************************************************************************
//* GLOBAL CONSTANTS                                                        *
//***************************************************************************
static const TCHAR c_szSetupDefaultQueueCallback[]       = "SetupDefaultQueueCallbackA";
static const TCHAR c_szSetupInstallFromInfSection[]      = "SetupInstallFromInfSectionA";
static const TCHAR c_szSetupOpenInfFile[]                = "SetupOpenInfFileA";
static const TCHAR c_szSetupOpenAppendInfFile[]          = "SetupOpenAppendInfFileA";
static const TCHAR c_szSetupCloseInfFile[]               = "SetupCloseInfFile";
static const TCHAR c_szSetupInitDefaultQueueCallbackEx[] = "SetupInitDefaultQueueCallbackEx";
static const TCHAR c_szSetupTermDefaultQueueCallback[]   = "SetupTermDefaultQueueCallback";
static const TCHAR c_szSetupSetDirectoryId[]             = "SetupSetDirectoryIdA";
static const TCHAR c_szSetupGetLineText[]                = "SetupGetLineTextA";
static const TCHAR c_szSetupGetLineByIndex[]             = "SetupGetLineByIndexA";
static const TCHAR c_szSetupFindFirstLine[]              = "SetupFindFirstLineA";
static const TCHAR c_szSetupFindNextLine[]               = "SetupFindNextLine";
static const TCHAR c_szSetupOpenFileQueue[]              = "SetupOpenFileQueue";
static const TCHAR c_szSetupCloseFileQueue[]             = "SetupCloseFileQueue";
static const TCHAR c_szSetupQueueCopy[]                  = "SetupQueueCopyA";
static const TCHAR c_szSetupCommitFileQueue[]            = "SetupCommitFileQueueA";
static const TCHAR c_szSetupGetStringField[]             = "SetupGetStringFieldA";


//***************************************************************************
//* FUNCTION PROTOTYPES                                                     *
//***************************************************************************
BOOL    LoadSetupAPIFuncs( VOID );
HRESULT InstallOnNT( PSTR, PSTR );
HRESULT MySetupOpenInfFile( PCSTR );
VOID    MySetupCloseInfFile( VOID );
HRESULT MySetupSetDirectoryId( DWORD, PSTR );
BOOL    GetNTInfLine( PSTR, PSTR, DWORD );
HRESULT MySetupGetLineText( PCSTR, PCSTR, PSTR, DWORD, PDWORD );
HRESULT MySetupGetLineByIndex( PCSTR, DWORD, PSTR, DWORD, PDWORD );
HRESULT MySetupGetStringField( PCSTR c_pszSection, DWORD dwLineIndex, DWORD dwFieldIndex,
                               PSTR pszBuffer, DWORD dwBufferSize, PDWORD pdwRequiredSize );


#endif // _NTAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\ntapi.c ===
//***************************************************************************
//*   Copyright (c) Microsoft Corporation 1995-1996. All rights reserved.   *
//***************************************************************************
//*                                                                         *
//* NTAPI.C -                                                               *
//*                                                                         *
//***************************************************************************

//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include "ntapi.h"
#include <winnt.h>
#include "advpack.h"
#include "advpub.h"
#include "globals.h"
#include "resource.h"

UINT WINAPI AIFSetupQueueCallback(PVOID Context, UINT Notification, UINT_PTR Param1, UINT_PTR Param2);
UINT WINAPI AIFQuietSetupQueueCallback(PVOID Context, UINT Notification, UINT_PTR Param1, UINT_PTR Param2);
UINT WINAPI MyFileQueueCallback2( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 );
void MakeRootDir(LPSTR pszPath);

//***************************************************************************
//* GLOBAL VARIABLES                                                        *
//***************************************************************************
PFSetupDefaultQueueCallback       pfSetupDefaultQueueCallback       = NULL;
PFSetupInstallFromInfSection      pfSetupInstallFromInfSection      = NULL;
PFSetupOpenInfFile                pfSetupOpenInfFile                = NULL;
PFSetupOpenAppendInfFile          pfSetupOpenAppendInfFile          = NULL;
PFSetupCloseInfFile               pfSetupCloseInfFile               = NULL;
PFSetupInitDefaultQueueCallbackEx pfSetupInitDefaultQueueCallbackEx = NULL;
PFSetupTermDefaultQueueCallback   pfSetupTermDefaultQueueCallback   = NULL;
PFSetupSetDirectoryId             pfSetupSetDirectoryId             = NULL;
PFSetupGetLineText                pfSetupGetLineText                = NULL;
PFSetupGetLineByIndex             pfSetupGetLineByIndex             = NULL;
PFSetupFindFirstLine              pfSetupFindFirstLine              = NULL;
PFSetupFindNextLine               pfSetupFindNextLine               = NULL;
PFSetupOpenFileQueue              pfSetupOpenFileQueue              = NULL;
PFSetupCloseFileQueue             pfSetupCloseFileQueue             = NULL;
PFSetupQueueCopy                  pfSetupQueueCopy                  = NULL;
PFSetupCommitFileQueue            pfSetupCommitFileQueue            = NULL;
PFSetupGetStringField             pfSetupGetStringField             = NULL;

//***************************************************************************
//*                                                                         *
//* NAME:                                                                   *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL LoadSetupAPIFuncs( VOID )
{
    pfSetupGetStringField             = (PFSetupGetStringField)             GetProcAddress( ctx.hSetupLibrary, c_szSetupGetStringField );
    pfSetupDefaultQueueCallback       = (PFSetupDefaultQueueCallback)       GetProcAddress( ctx.hSetupLibrary, c_szSetupDefaultQueueCallback );
    pfSetupInstallFromInfSection      = (PFSetupInstallFromInfSection)      GetProcAddress( ctx.hSetupLibrary, c_szSetupInstallFromInfSection );
    pfSetupOpenInfFile                = (PFSetupOpenInfFile)                GetProcAddress( ctx.hSetupLibrary, c_szSetupOpenInfFile );
    pfSetupOpenAppendInfFile          = (PFSetupOpenAppendInfFile)          GetProcAddress( ctx.hSetupLibrary, c_szSetupOpenAppendInfFile );
    pfSetupCloseInfFile               = (PFSetupCloseInfFile)               GetProcAddress( ctx.hSetupLibrary, c_szSetupCloseInfFile );
    pfSetupInitDefaultQueueCallbackEx = (PFSetupInitDefaultQueueCallbackEx) GetProcAddress( ctx.hSetupLibrary, c_szSetupInitDefaultQueueCallbackEx );
    pfSetupTermDefaultQueueCallback   = (PFSetupTermDefaultQueueCallback)   GetProcAddress( ctx.hSetupLibrary, c_szSetupTermDefaultQueueCallback );
    pfSetupSetDirectoryId             = (PFSetupSetDirectoryId)             GetProcAddress( ctx.hSetupLibrary, c_szSetupSetDirectoryId );
    pfSetupGetLineText                = (PFSetupGetLineText)                GetProcAddress( ctx.hSetupLibrary, c_szSetupGetLineText );
    pfSetupGetLineByIndex             = (PFSetupGetLineByIndex)             GetProcAddress( ctx.hSetupLibrary, c_szSetupGetLineByIndex );
    pfSetupFindFirstLine              = (PFSetupFindFirstLine)              GetProcAddress( ctx.hSetupLibrary, c_szSetupFindFirstLine );
    pfSetupFindNextLine               = (PFSetupFindNextLine)               GetProcAddress( ctx.hSetupLibrary, c_szSetupFindNextLine );
    pfSetupOpenFileQueue              = (PFSetupOpenFileQueue)              GetProcAddress( ctx.hSetupLibrary, c_szSetupOpenFileQueue );
    pfSetupCloseFileQueue             = (PFSetupCloseFileQueue)             GetProcAddress( ctx.hSetupLibrary, c_szSetupCloseFileQueue );
    pfSetupQueueCopy                  = (PFSetupQueueCopy)                  GetProcAddress( ctx.hSetupLibrary, c_szSetupQueueCopy );
    pfSetupCommitFileQueue            = (PFSetupCommitFileQueue)            GetProcAddress( ctx.hSetupLibrary, c_szSetupCommitFileQueue );

    if (pfSetupDefaultQueueCallback       == NULL
     || pfSetupInstallFromInfSection      == NULL
     || pfSetupOpenInfFile                == NULL
     || pfSetupCloseInfFile               == NULL
     || pfSetupInitDefaultQueueCallbackEx == NULL
     || pfSetupTermDefaultQueueCallback   == NULL
     || pfSetupSetDirectoryId             == NULL
     || pfSetupGetLineText                == NULL
     || pfSetupGetLineByIndex             == NULL
     || pfSetupFindFirstLine              == NULL
     || pfSetupFindNextLine               == NULL
     || pfSetupOpenFileQueue              == NULL
     || pfSetupCloseFileQueue             == NULL
     || pfSetupQueueCopy                  == NULL
     || pfSetupCommitFileQueue            == NULL
     || pfSetupGetStringField             == NULL )
    {
        return FALSE;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       InstallOnNT                                                 *
//*                                                                         *
//* SYNOPSIS:   This function will make all the calls to WinNT SUR's        *
//*             SETUPAPI.DLL to do the installation on NT SUR.              *
//*                                                                         *
//* REQUIRES:   pszSection:     Section to install                          *
//*             pszSourceDir:   Directory to CABs or expanded files         *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT InstallOnNT( PSTR pszSection, PSTR pszSourceDir )
{
    PVOID    pContext    = NULL;
    HRESULT  hReturnCode = S_OK;
    HSPFILEQ hFileQueue = NULL;
    UINT     uFlags;


    // Install Files

    // Setup Context data structure initialized for us for default UI provided by Setup API.
    pContext = pfSetupInitDefaultQueueCallbackEx( NULL, (ctx.wQuietMode) ?
                          INVALID_HANDLE_VALUE : NULL,
                          0, 0, NULL );

    if ( pContext == NULL ) {
        hReturnCode = HRESULT_FROM_SETUPAPI(GetLastError());
        goto done;
    }

    if ( ! pfSetupInstallFromInfSection( NULL, ctx.hInf, pszSection, SPINST_FILES, NULL,
                     pszSourceDir, SP_COPY_NEWER,
                     MyFileQueueCallback2,
                     pContext, NULL, NULL ) )
    {
        hReturnCode = HRESULT_FROM_SETUPAPI(GetLastError());
        pfSetupTermDefaultQueueCallback( pContext );
        goto done;
    }

    // Free Context Data structure
    pfSetupTermDefaultQueueCallback( pContext );

    
    uFlags = SPINST_REGISTRY | SPINST_INIFILES;
    if ( ctx.wOSVer >= _OSVER_WINNT50 )
        uFlags = uFlags | SPINST_PROFILEITEMS;

    // Install registry entries
    if ( ! pfSetupInstallFromInfSection( NULL, ctx.hInf, pszSection,
                     uFlags,
                     HKEY_LOCAL_MACHINE, NULL, 0, NULL,
                     NULL, NULL, NULL ) )
    {
        hReturnCode = HRESULT_FROM_SETUPAPI(GetLastError());
        goto done;
    }

  done:

    return hReturnCode;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MySetupOpenInfFile                                          *
//*                                                                         *
//* SYNOPSIS:   This function will map to a function in setupapi.dll which  *
//*             will open the INF file.                                     *
//*                                                                         *
//* REQUIRES:   pszInfFilename:                                             *
//*                                                                         *
//* RETURNS:    DWORD:          Return value - OK means successfull.        *
//*                                                                         *
//***************************************************************************
HRESULT MySetupOpenInfFile( PCSTR pszInfFilename )
{
    UINT line;

    if ( ctx.hInf == NULL ) 
    {
        ctx.hInf = pfSetupOpenInfFile( pszInfFilename, NULL, INF_STYLE_WIN4, NULL );

        if ( ctx.hInf == NULL || ctx.hInf == INVALID_HANDLE_VALUE ) 
        {
            ctx.hInf = NULL;
            return HRESULT_FROM_SETUPAPI(GetLastError());
        }

        // process LayoutFile line of [version] section if any
        pfSetupOpenAppendInfFile( NULL, ctx.hInf, &line );
    }

    return S_OK;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MySetupCloseInfFile                                         *
//*                                                                         *
//* SYNOPSIS:   This function will map to an API function in setupapi.dll.  *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    VOID                                                        *
//*                                                                         *
//***************************************************************************
VOID MySetupCloseInfFile( VOID )
{
    if ( ctx.hInf ) 
    {
        pfSetupCloseInfFile( ctx.hInf );
        ctx.hInf = NULL;
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       MySetupSetDirectoryId                                       *
//*                                                                         *
//* SYNOPSIS:   This function will map to a function in setupapi.dll to     *
//*             set the directory ID's that are used in our INF.            *
//*                                                                         *
//* REQUIRES:   dwDirID:        Numerical value used to define the DirID    *
//*             pszPath:        DirID will point to this path.              *
//*                                                                         *
//* RETURNS:    DWORD:          Error value (OK if successfull)             *
//*                                                                         *
//***************************************************************************
HRESULT MySetupSetDirectoryId( DWORD dwDirID, PSTR pszPath )
{
    if ( ! pfSetupSetDirectoryId( ctx.hInf, dwDirID, pszPath ) ) {
        return HRESULT_FROM_SETUPAPI(GetLastError());
    }

    return S_OK;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MySetupGetLineText                                          *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT MySetupGetLineText( PCSTR pszSection, PCSTR pszKey, PSTR pszReturnBuffer,
                DWORD dwReturnBufferSize, PDWORD pdwRequiredSize )
{
    if ( ! pfSetupGetLineText( NULL, ctx.hInf, pszSection, pszKey,
                   pszReturnBuffer, dwReturnBufferSize,
                   pdwRequiredSize ) )
    {
        return HRESULT_FROM_SETUPAPI(GetLastError());
    }

    return S_OK;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MySetupGetLineByIndex                                       *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT MySetupGetLineByIndex( PCSTR c_pszSection, DWORD dwIndex,
                   PSTR pszBuffer, DWORD dwBufferSize,
                   PDWORD pdwRequiredSize )
{
    HRESULT hReturnCode = S_OK;
    INFCONTEXT InfContext;
    DWORD i = 0;

    if ( ! pfSetupFindFirstLine( ctx.hInf, c_pszSection, NULL, &InfContext ) ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto done;
    }

    for ( i = 0; i < dwIndex; i += 1 ) {
        if ( !pfSetupFindNextLine( &InfContext, &InfContext ) ) {
            hReturnCode = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            goto done;
        }
    }

#if 0
    if ( ! pfSetupGetLineByIndex( ctx.hInf, c_pszSection, dwIndex, &InfContext ) )
    {
        hReturnCode = HRESULT_FROM_SETUPAPI(GetLastError());
        goto done;
    }
#endif

    if ( ! pfSetupGetLineText( &InfContext, NULL, NULL, NULL,
                   pszBuffer, dwBufferSize, pdwRequiredSize ) )
    {
        hReturnCode = HRESULT_FROM_SETUPAPI(GetLastError());
        goto done;
    }

  done:

    return hReturnCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       MySetupGetStringField                                       *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
HRESULT MySetupGetStringField( PCSTR c_pszSection, DWORD dwLineIndex, DWORD dwFieldIndex,
                               PSTR pszBuffer, DWORD dwBufferSize, PDWORD pdwRequiredSize )
{
    HRESULT hReturnCode = S_OK;
    INFCONTEXT InfContext;
    DWORD i = 0;

    if ( !pfSetupFindFirstLine( ctx.hInf, c_pszSection, NULL, &InfContext ) ) {
        hReturnCode = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto done;
    }

    for ( i = 0; i < dwLineIndex; i += 1 ) 
    {
        if ( !pfSetupFindNextLine( &InfContext, &InfContext ) ) 
        {
            hReturnCode = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            goto done;
        }
    }

    if ( !pfSetupGetStringField( &InfContext, dwFieldIndex, 
                                 pszBuffer, dwBufferSize, pdwRequiredSize ) )
    {
        hReturnCode = HRESULT_FROM_SETUPAPI(GetLastError());
        goto done;
    }

  done:

    return hReturnCode;
}


HRESULT WINAPI AdvInstallFile(HWND hwnd, LPCSTR lpszSourceDir, LPCSTR lpszSourceFile,
               LPCSTR lpszDestDir, LPCSTR lpszDestFile, DWORD dwFlags, DWORD dwReserved)
{
    HRESULT     hr = E_FAIL;
    HSPFILEQ    FileQueue;
    char    szSrcDrv[MAX_PATH];
    LPCSTR  lpSrcPath;
    LPVOID  lpContext;
    DWORD   dwCopyFlags;
    DWORD   dwRebootCheck;

    if ( (lpszSourceDir == NULL) || (*lpszSourceDir == '\0') ||
         (lpszSourceFile == NULL) || (*lpszSourceFile == '\0') ||
         (lstrlen(lpszSourceDir) < 3) ||
         (lpszDestDir == NULL) )
        return E_INVALIDARG;

    if (!SaveGlobalContext())
        return hr;

    ctx.hWnd = hwnd;

    if ( !CheckOSVersion() )
    {
        RestoreGlobalContext();
        return HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION);
    }
    dwRebootCheck = InternalNeedRebootInit( ctx.wOSVer );

    // LoadLibrary for setupapi.dll
    ctx.hSetupLibrary = MyLoadLibrary( SETUPAPIDLL );
    if ( ctx.hSetupLibrary == NULL )
    {
        ErrorMsg1Param( NULL, IDS_ERR_LOAD_DLL, SETUPAPIDLL );
        hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);
        goto Cleanup;
    }
    if ( ! LoadSetupAPIFuncs() )
    {
        ErrorMsg( NULL, IDS_ERR_GET_PROC_ADDR );
        hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        goto Cleanup;
    }

    // SetupOpenFileQueue
    FileQueue = pfSetupOpenFileQueue();
    if (FileQueue == INVALID_HANDLE_VALUE)
    {
        ErrorMsg1Param( NULL, IDS_ERR_LOAD_DLL, c_szSetupOpenFileQueue );
        hr = HRESULT_FROM_SETUPAPI(GetLastError());
        goto Cleanup;
    }

    lstrcpy(szSrcDrv, lpszSourceDir);
    MakeRootDir(szSrcDrv);
    lpSrcPath = lpszSourceDir + lstrlen(szSrcDrv);  // This will point to the first subdir.

    dwCopyFlags = SP_COPY_SOURCE_ABSOLUTE |
                  SP_COPY_IN_USE_NEEDS_REBOOT|
                  SP_COPY_NEWER |
                  SP_COPY_LANGUAGEAWARE;

    if (dwFlags & AIF_FORCE_FILE_IN_USE)
        dwCopyFlags |= SP_COPY_FORCE_IN_USE;

    if (dwFlags & AIF_NOVERSIONCHECK)
        dwCopyFlags &= ~SP_COPY_NEWER;

    if (dwFlags & AIF_NOLANGUAGECHECK)
        dwCopyFlags &= ~SP_COPY_LANGUAGEAWARE;

    if (dwFlags & AIF_NO_VERSION_DIALOG)
        dwCopyFlags |= SP_COPY_FORCE_NEWER;

    if (dwFlags & AIF_REPLACEONLY)
        dwCopyFlags |= SP_COPY_REPLACEONLY;

    if (dwFlags & AIF_NOOVERWRITE)
        dwCopyFlags |= SP_COPY_NOOVERWRITE;

    if (dwFlags & AIF_NOSKIP)
        dwCopyFlags |= SP_COPY_NOSKIP;

    if (dwFlags & AIF_WARNIFSKIP)
        dwCopyFlags |= SP_COPY_WARNIFSKIP;

    if (pfSetupQueueCopy(FileQueue,
                 szSrcDrv,
                 lpSrcPath,
                 lpszSourceFile,
                 NULL,
                 NULL,
                 lpszDestDir,
                 lpszDestFile,
                 dwCopyFlags))
    {
        lpContext = pfSetupInitDefaultQueueCallbackEx(hwnd, INVALID_HANDLE_VALUE, 0, 0, NULL);
        hr = S_OK;

        //
        // SetupCommitFileQueue
        if (!pfSetupCommitFileQueue( hwnd, FileQueue,
                                (dwFlags & AIF_QUIET)?AIFQuietSetupQueueCallback:AIFSetupQueueCallback,
                                lpContext))
        {
            hr = HRESULT_FROM_SETUPAPI(GetLastError());
        }

        pfSetupTermDefaultQueueCallback(lpContext);
    }
    else
        hr = HRESULT_FROM_SETUPAPI(GetLastError());

    // SetupCloseFileQueue
    pfSetupCloseFileQueue(FileQueue);

    if ( SUCCEEDED(hr) &&
         InternalNeedReboot( dwRebootCheck, ctx.wOSVer ) )
    {
        hr = ERROR_SUCCESS_REBOOT_REQUIRED;
    }

Cleanup:

    RestoreGlobalContext();

    return hr;
}


// This callback will display error messages, but will not show any progress dialog
UINT WINAPI AIFSetupQueueCallback(PVOID  Context,        // context used by the default callback routine
                                UINT     Notification,  // queue notification
                                UINT_PTR Param1,        // additional notification information
                                UINT_PTR Param2 // additional notification information
                                )
{
    switch (Notification)
    {
        case SPFILENOTIFY_STARTQUEUE:
        case SPFILENOTIFY_ENDQUEUE:
        case SPFILENOTIFY_STARTSUBQUEUE:
        case SPFILENOTIFY_ENDSUBQUEUE:

        case SPFILENOTIFY_STARTRENAME:
        case SPFILENOTIFY_ENDRENAME:
        case SPFILENOTIFY_STARTDELETE:
        case SPFILENOTIFY_ENDDELETE:
        case SPFILENOTIFY_STARTCOPY:
        case SPFILENOTIFY_ENDCOPY:
            return FILEOP_DOIT;

        default:
            return (pfSetupDefaultQueueCallback(Context, Notification, Param1, Param2));
    }
}

// This callback will not display any dialog
UINT WINAPI AIFQuietSetupQueueCallback(PVOID Context,   // context used by the default callback routine
                                    UINT     Notification,  // queue notification
                                    UINT_PTR Param1,        // additional notification information
                                    UINT_PTR Param2 // additional notification information
                                    )
{
    return FILEOP_DOIT;
}

UINT WINAPI MyFileQueueCallback2( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 )
{
    switch(Notification)
    {
        case SPFILENOTIFY_NEEDMEDIA:
            {
                CHAR szDrv[5];
                PSOURCE_MEDIA psrcMed;

                psrcMed = (PSOURCE_MEDIA)parm1;

                if ( lstrlen( psrcMed->SourcePath  ) > 3 )
                {
                    lstrcpyn( szDrv, psrcMed->SourcePath, 4 );

                    if ( (szDrv[1] == ':') && (GetDriveType( szDrv ) == DRIVE_REMOVABLE) )
                    {
                        CHAR szFile[MAX_PATH];

                        lstrcpy( szFile, psrcMed->SourcePath );

                        if ( psrcMed->Tagfile && *psrcMed->Tagfile )
                            AddPath( szFile, psrcMed->Tagfile );
                        else
                            AddPath( szFile, psrcMed->SourceFile );

                        if ( FileExists( szFile ) )
                        {
                            lstrcpy( (PSTR)parm2, psrcMed->SourcePath );
                            return ( FILEOP_NEWPATH );
                        }
                    }

                }
            }

        default:
            return ( pfSetupDefaultQueueCallback( Context, Notification, parm1, parm2 ) );
    }
}

void MakeRootDir(LPSTR pszPath)
{
    LPSTR pTmp;
    if (pszPath[1] == ':') 
        pszPath[3] = '\0';
    else if ((pszPath[0] == '\\') && (pszPath[1]=='\\'))
    {
        pTmp = &pszPath[2];
        // Find the sever share separation
        while ((*pTmp) && (*pTmp != '\\'))
            pTmp = CharNext(pTmp);
        if (*pTmp)
        {
            pTmp = CharNext(pTmp);
            // Find the end of the share
            while ((*pTmp) && (*pTmp != '\\'))
                pTmp = CharNext(pTmp);
            if (*pTmp == '\\')
            {
                pTmp = CharNext(pTmp);
                *pTmp ='\0';
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\resource.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* RESOURCE.H -                                                            *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* STRING RESOURCE IDS                                                     *
//***************************************************************************
#define IDS_SELECTDIR               1000
#define IDS_CREATE_DIR              1001
#define IDS_PROMPT                  1002
#define IDS_RESTARTYESNO            1004

#define IDS_ERR_NO_RESOURCE         1100
#define IDS_ERR_OS_VERSION          1101
#define IDS_ERR_NO_MEMORY           1102
#define IDS_ERR_INVALID_DIR         1103
#define IDS_ERR_EMPTY_DIR_FIELD     1104
#define IDS_ERR_UPDATE_DIR          1105
#define IDS_ERR_LOADFUNCS           1106
#define IDS_ERR_LOADDLL             1107
#define IDS_ERR_NO_INF_INSTALLS     1108
#define IDS_ERR_LOAD_DLL            1109
#define IDS_ERR_GET_PROC_ADDR       1110
#define IDS_ERR_OS_UNSUPPORTED      1111
#define IDS_ERR_CREATE_DIR          1112
#define IDS_ERR_SET_LDID            1113
#define IDS_ERR_INF_FAIL            1114
#define IDS_ERR_INF_FAILURE         1115
#define IDS_ERR_INF_SYNTAX          1117
#define IDS_ERR_USER_CANCEL_INST    1121
#define IDS_ERR_SHORT_NAME          1122
#define IDS_ERR_REG_OCX             1123
#define IDS_ERR_RUNONCE_REG_OCX     1124
#define IDS_ERR_INVALID_REGROOT     1125
#define IDS_ERR_GET_WIN_DIR         1126
#define IDS_ERR_NO_SPACE_INST       1130
#define IDS_ERR_GET_DISKSPACE       1132
#define IDS_ERR_UNREG_OCX           1133
#define IDS_ERR_OPENPROCTK          1134
#define IDS_ERR_ADJTKPRIV           1135
#define IDS_ERR_EXITWINEX           1136
#define IDS_ERR_BAD_SYNTAX          1137
#define IDS_ERR_BAD_SYNTAX2         1138
#define IDS_ERR_GET_PATH            1140
#define IDS_ERR_CREATE_PROCESS      1142
#define IDS_ERR_GETVOLINFOR         1143
#define IDS_ERR_TOO_BIG             1144
#define IDS_ERR_CANT_FIND_FILE      1145
#define IDS_ERR_CABPATH             1149

#define IDS_INVALID_ROOTKEY         1151
#define IDS_NO_SEPARATOR_CHAR       1152
#define IDS_ERR_REGSETVALUE         1153
#define IDS_ERR_REGQUERYVALUE       1154

#define IDS_FILEBACKUP_ERROR        1155
#define IDS_BACKUPINIT_ERROR        1156
#define IDS_BACKUPDAT_ERROR         1157
#define IDS_RESTORE_ERROR           1158
#define IDS_RESTORE_ERROR2          1159
#define IDS_FILEBACKUP_TITLE        1160
#define IDS_FILERESTORE_TITLE       1161
#define IDD_SAVERESTOREDLG          1162
#define IDC_SAVERESTORE_PROGRESS    1163
#define IDS_SAVEINFO_TEXT           1164
#define IDS_RESTOREINFO_TEXT        1165
#define IDS_ERR_NONTADMIN           1166
#define IDS_ADVDEFTITLE             1167
#define IDS_ERR_FMTMSG              1168

//***************************************************************************
//* DIALOG IDS                                                              *
//***************************************************************************
#define IDD_DIRDLG      2000


//***************************************************************************
//* DIALOG CONTROL IDS                                                      *
//***************************************************************************
#define IDC_EDIT_DIR    2100
#define IDC_BUT_BROWSE  2101
#define IDC_TEMPTEXT    2102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\sfp.c ===
#include <windows.h>
#include <setupapi.h>
#include "globals.h"
#include "sfp.h"


// globals
SFPINSTALLCATALOG   g_pfSfpInstallCatalog   = NULL;
SFPDELETECATALOG    g_pfSfpDeleteCatalog    = NULL;
SFPDUPLICATECATALOG g_pfSfpDuplicateCatalog = NULL;


// static variables
static HINSTANCE s_hSfcDll = NULL;


BOOL LoadSfcDLL()
{
    BOOL bRet = FALSE;

    if ((s_hSfcDll = LoadLibrary("sfc.dll")) != NULL)
    {
        // ordinal 8 is SfpInstallCatalog, and
        // ordinal 9 is SfpDeleteCatalog
        g_pfSfpInstallCatalog   = (SFPINSTALLCATALOG)   GetProcAddress(s_hSfcDll, MAKEINTRESOURCE(8));
        g_pfSfpDeleteCatalog    = (SFPDELETECATALOG)    GetProcAddress(s_hSfcDll, MAKEINTRESOURCE(9));
        g_pfSfpDuplicateCatalog = (SFPDUPLICATECATALOG) GetProcAddress(s_hSfcDll, "SfpDuplicateCatalog");

        if (g_pfSfpInstallCatalog   != NULL  &&
            g_pfSfpDeleteCatalog    != NULL  &&
            g_pfSfpDuplicateCatalog != NULL)
        {
            bRet = TRUE;
        }
    }
    else
    {
        DWORD dwRet = GetLastError();
        AdvWriteToLog("LoadSfcDLL: LoadLibrary of sfc.dll failed with %1!lu!\r\n", dwRet);
    }

    return bRet;
}


VOID UnloadSfcDLL()
{
    if (s_hSfcDll != NULL)
    {
        FreeLibrary(s_hSfcDll);
        s_hSfcDll = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\regsvrst.c ===
#include "ntapi.h"
#include "advpack.h"
#include "globals.h"
#include "crc32.h"
#include "resource.h"


// macro definitions
#define VDH_EXISTENCE_ONLY  0x01
#define VDH_GET_VALUE       0x02
#define VDH_DEL_VALUE       0x04



#define BIG_BUF_SIZE        (1024 + 512)                    // 1.5K


// type definitions
typedef struct tagROOTKEY
{
    PCSTR pcszRootKey;
    HKEY hkRootKey;
} ROOTKEY;


// prototype declarations
VOID EnumerateSubKey();
BOOL RegSaveRestoreHelperWrapper(PCSTR pcszValueName, PCSTR pcszCRCValueName);

BOOL RegSaveHelper(HKEY hkBckupKey, HKEY hkRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, PCSTR pcszCRCValueName);
BOOL RegRestoreHelper(HKEY hkBckupKey, HKEY hkRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, PCSTR pcszCRCValueName);

BOOL AddDelMapping(HKEY hkBckupKey, PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, DWORD dwFlags);
BOOL MappingExists(HKEY hkBckupKey, PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName);

BOOL SetValueData(HKEY hkBckupKey, PCSTR pcszValueName, CONST BYTE *pcbValueData, DWORD dwValueDataLen);
BOOL ValueDataExists(HKEY hkBckupKey, PCSTR pcszValueName);
BOOL GetValueData(HKEY hkBckupKey, PCSTR pcszValueName, PBYTE *ppbValueData, PDWORD pdwValueDataLen);
BOOL DelValueData(HKEY hkBckupKey, PCSTR pcszValueName);
BOOL ValueDataHelper(HKEY hkBckupKey, PCSTR pcszValueName, PBYTE *ppbValueData, PDWORD pdwValueDataLen, DWORD dwFlags);
VOID Convert2CRC(PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, PSTR pszCRCValueName);

BOOL MapRootRegStr2Key(PCSTR pcszRootKey, HKEY *phkRootKey);
CHAR FindSeparator(PCSTR pcszSubKey, PCSTR pcszValueName);
BOOL RegKeyEmpty(HKEY hkRootKey, PCSTR pcszSubKey);

PSTR GetNextToken(PSTR *ppszData, CHAR chDeLim);

BOOL FRunningOnNT();


// global variables
BOOL g_bRet, g_fRestore, g_fAtleastOneRegSaved, g_fRemovBkData;
HKEY g_hkBckupKey, g_hkRootKey;
PCSTR g_pcszRootKey, g_pcszValueName;
PSTR g_pszCRCTempBuf = NULL, g_pszSubKey = NULL, g_pszCRCSubKey = NULL;


// related to logging
VOID StartLogging(PCSTR pcszLogFileSecName);
VOID WriteToLog(PCSTR pcszFormatString, ...);
VOID StopLogging();

HANDLE g_hLogFile = INVALID_HANDLE_VALUE;


HRESULT WINAPI RegSaveRestore(HWND hWnd, PCSTR pszTitleString, HKEY hkBckupKey, PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, DWORD dwFlags)
{
    HWND hSaveWnd = ctx.hWnd;
    WORD wSaveQuietMode = ctx.wQuietMode;
    LPSTR lpszSaveTitle = ctx.lpszTitle;

    g_bRet = g_fAtleastOneRegSaved = FALSE;

    if ( (hWnd == INVALID_HANDLE_VALUE) || (dwFlags & ARSR_NOMESSAGES) )
        ctx.wQuietMode |= QUIETMODE_ALL;
    
    if ( hWnd != INVALID_HANDLE_VALUE )
        ctx.hWnd = hWnd;

    if (pszTitleString != NULL)
        ctx.lpszTitle = (PSTR)pszTitleString;

    g_hkBckupKey = hkBckupKey;
    g_pcszRootKey = pcszRootKey;
    g_pcszValueName = pcszValueName;

    g_fRestore = (dwFlags & IE4_RESTORE);
    g_fRemovBkData = (dwFlags & IE4_REMOVREGBKDATA) && g_fRestore;

    StartLogging(g_fRestore ? REG_RESTORE_LOG_KEY : REG_SAVE_LOG_KEY);

    if (!MapRootRegStr2Key(pcszRootKey, &g_hkRootKey))
    {
        ErrorMsg1Param(ctx.hWnd, IDS_INVALID_ROOTKEY, pcszRootKey);
        goto ErrExit;
    }

    // allocate a 1.5K buffer for g_pszCRCTempBuf
    if ((g_pszCRCTempBuf = (PSTR) LocalAlloc(LPTR, BIG_BUF_SIZE)) == NULL)
    {
        ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
        goto ErrExit;
    }

    if (!g_fRestore  &&  pcszValueName == NULL  &&  !(dwFlags & IE4_NOENUMKEY))
    {
        HKEY hk;

        // check if pcszSubKey exits; if it doesn't and it has not been already backed up,
        // set the IE4_NOENUMKEY flag so that an entry for this subkey is made in the backup branch
        if (RegOpenKeyEx(g_hkRootKey, pcszSubKey, 0, KEY_READ, &hk) != ERROR_SUCCESS)
        {
            if (!MappingExists(hkBckupKey, pcszRootKey, pcszSubKey, pcszValueName))
                dwFlags |= IE4_NOENUMKEY;
        }
        else
            RegCloseKey(hk);
    }

    if (pcszValueName != NULL  ||  (dwFlags & IE4_NOENUMKEY))
    {
        g_pszSubKey = g_pszCRCSubKey = (PSTR) pcszSubKey;
        g_bRet = RegSaveRestoreHelperWrapper(g_pcszValueName, g_pcszValueName);
        if (!(dwFlags & IE4_NO_CRC_MAPPING)  &&  g_bRet)
        {
            // store the RootKey, SubKey, Flags and ValueName in *.map.
            // this info would be used by the caller during the restore phase.
            g_bRet = AddDelMapping(g_hkBckupKey, g_pcszRootKey, g_pszSubKey, g_pcszValueName, dwFlags);
        }
    }
    else                        // save or restore pcszSubKey recursively
    {
        // allocate a 1K buffer for g_pszCRCSubKey
        if ((g_pszCRCSubKey = (PSTR) LocalAlloc(LPTR, 1024)) == NULL)
        {
            ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
            goto ErrExit;
        }

        if (!g_fRestore)
        {
            // if backup info exists for pcszRootKey\pcszSubKey, then we won't re-backup
            // the key recursively again; if we don't do this, then during an upgrade or reinstall
            // over a build, we would backup potentially newer values that got added during the running
            // of the program.
            if (MappingExists(hkBckupKey, pcszRootKey, pcszSubKey, pcszValueName))
            {
                g_bRet = TRUE;

                LocalFree(g_pszCRCSubKey);
                g_pszCRCSubKey = NULL;

                goto ErrExit;
            }

            // allocate a 1K buffer for g_pszSubKey
            if ((g_pszSubKey = (PSTR) LocalAlloc(LPTR, 1024)) == NULL)
            {
                ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
                LocalFree(g_pszCRCSubKey);
                goto ErrExit;
            }
        }
        else
            g_pszSubKey = (PSTR) pcszSubKey;

        g_bRet = TRUE;
        lstrcpy(g_pszCRCSubKey, pcszSubKey);
        if (!g_fRestore)
            lstrcpy(g_pszSubKey, pcszSubKey);

        EnumerateSubKey();
        if (!(dwFlags & IE4_NO_CRC_MAPPING))
        {
            if (g_fRestore)
            {
                if (g_bRet)
                {
                    // if we couldn't restore everything; then we shouldn't delete the mapping info.
                    g_bRet = AddDelMapping(g_hkBckupKey, g_pcszRootKey, g_pszSubKey, g_pcszValueName, dwFlags);
                }
            }
            else
            {
                if (g_fAtleastOneRegSaved)
                {
                    // save the mapping info only if atleast one reg entry was saved
                    g_bRet = AddDelMapping(g_hkBckupKey, g_pcszRootKey, g_pszSubKey, g_pcszValueName, dwFlags);
                }
            }
        }

        LocalFree(g_pszCRCSubKey);
        g_pszCRCSubKey = NULL;
        if (!g_fRestore)
        {
            LocalFree(g_pszSubKey);
            g_pszSubKey = NULL;
        }

    }

ErrExit:
    StopLogging();

    if (g_pszCRCTempBuf != NULL)
    {
        LocalFree(g_pszCRCTempBuf);
        g_pszCRCTempBuf = NULL;
    }

    ctx.hWnd = hSaveWnd;
    ctx.wQuietMode = wSaveQuietMode;
    ctx.lpszTitle = lpszSaveTitle;

    return g_bRet ? S_OK : E_FAIL;
}


HRESULT WINAPI RegRestoreAll(HWND hWnd, PSTR pszTitleString, HKEY hkBckupKey)
{
    HWND hSaveWnd = ctx.hWnd;
    WORD wSaveQuietMode = ctx.wQuietMode;
    LPSTR lpszSaveTitle = ctx.lpszTitle;
    HRESULT hRet;

    if (hWnd != INVALID_HANDLE_VALUE)
        ctx.hWnd = hWnd;
    else
        ctx.wQuietMode |= QUIETMODE_ALL;

    if (pszTitleString != NULL)
        ctx.lpszTitle = pszTitleString;

    hRet = RegRestoreAllEx( hkBckupKey );

    ctx.hWnd = hSaveWnd;
    ctx.wQuietMode = wSaveQuietMode;
    ctx.lpszTitle = lpszSaveTitle;

    return hRet;
}


HRESULT RegRestoreAllEx( HKEY hkBckupKey )
// In one shot restore all the reg entries by enumerating all the values under hkBckupKey\*.map keys
// and calling RegSaveRestore on each one of them.
{
    BOOL bRet = TRUE;
    PSTR pszMappedValueData = NULL;
    CHAR szBuf[32];
    CHAR szSubKey[32];
    DWORD dwKeyIndex;
    HKEY hkSubKey;
    LONG lRetVal;

    if ((pszMappedValueData = (PSTR) LocalAlloc(LPTR, BIG_BUF_SIZE)) == NULL)
    {
        ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
        return E_FAIL;
    }

    // enumerate all the sub-keys under hkBckupKey
    for (dwKeyIndex = 0;  ; dwKeyIndex++)
    {
        PSTR pszPtr;

        lRetVal = RegEnumKey(hkBckupKey, dwKeyIndex, szSubKey, sizeof(szSubKey));
        if (lRetVal != ERROR_SUCCESS)
        {
            if (lRetVal != ERROR_NO_MORE_ITEMS)
                bRet = FALSE;
            break;
        }

        // check if the keyname is of the form *.map
        if ((pszPtr = ANSIStrChr(szSubKey, '.')) != NULL  &&  lstrcmpi(pszPtr, ".map") == 0)
        {
            if (RegOpenKeyEx(hkBckupKey, szSubKey, 0, KEY_READ, &hkSubKey) == ERROR_SUCCESS)
            {
                DWORD dwValIndex, dwValueLen, dwDataLen;

                // enumerate all the values under this key and restore each one of them
                dwValueLen = sizeof(szBuf);
                dwDataLen = BIG_BUF_SIZE;
                for (dwValIndex = 0;  ;  dwValIndex++)
                {
                    CHAR chSeparator;
                    PSTR pszFlags, pszRootKey, pszSubKey, pszValueName, pszPtr;
                    DWORD dwMappedFlags;

                    lRetVal = RegEnumValue(hkSubKey, dwValIndex, szBuf, &dwValueLen, NULL, NULL, pszMappedValueData, &dwDataLen);
                    if (lRetVal != ERROR_SUCCESS)
                    {
                        if (lRetVal != ERROR_NO_MORE_ITEMS)
                            bRet = FALSE;
                        break;
                    }

                    // get the separator char first and then point to RootKey, SubKey and ValueName in pszMappedValueData
                    pszPtr = pszMappedValueData;
                    chSeparator = *pszPtr++;
                    pszFlags = GetNextToken(&pszPtr, chSeparator);
                    pszRootKey = GetNextToken(&pszPtr, chSeparator);
                    pszSubKey = GetNextToken(&pszPtr, chSeparator);
                    pszValueName = GetNextToken(&pszPtr, chSeparator);

                    dwMappedFlags = (pszFlags != NULL) ? (DWORD) My_atoi(pszFlags) : 0;

                    if (SUCCEEDED(RegSaveRestore( ctx.hWnd, ctx.lpszTitle, hkBckupKey, pszRootKey, pszSubKey, pszValueName, dwMappedFlags)))
                        dwValIndex--;                               // RegSaveRestore would delete this value
                    else
                        bRet = FALSE;

                    dwValueLen = sizeof(szBuf);
                    dwDataLen = BIG_BUF_SIZE;
                }

                RegCloseKey(hkSubKey);
            }
            else
                bRet = FALSE;
        }
    }

    LocalFree(pszMappedValueData);

    // delete all the empty subkeys
    for (dwKeyIndex = 0;  ; dwKeyIndex++)
    {
        lRetVal = RegEnumKey(hkBckupKey, dwKeyIndex, szSubKey, sizeof(szSubKey));
        if (lRetVal != ERROR_SUCCESS)
        {
            if (lRetVal != ERROR_NO_MORE_ITEMS)
                bRet = FALSE;
            break;
        }

        if (RegKeyEmpty(hkBckupKey, szSubKey)  &&  RegDeleteKey(hkBckupKey, szSubKey) == ERROR_SUCCESS)
            dwKeyIndex--;
    }

    return bRet ? S_OK : E_FAIL;
}


VOID EnumerateSubKey()
// Recursively enumerate value names and sub-keys and call Save/Restore on each of them
{
    HKEY hkSubKey;
    DWORD dwIndex;
    static DWORD dwLen;
    static PCSTR pcszSubKeyPrefix = "_$Sub#";
    static PCSTR pcszValueNamePrefix = "_$Val#";
    static PCSTR pcszValueNamePrefix0 = "_$Val#0";
    static CHAR szValueName[MAX_PATH], szBckupCRCValueName[MAX_PATH];
    static PSTR pszPtr;

    if (g_fRestore)
    {
        // check if there is an entry in the back-up branch for just the g_pszCRCSubKey itself
        Convert2CRC(g_pcszRootKey, g_pszCRCSubKey, NULL, szBckupCRCValueName);
        if (ValueDataExists(g_hkBckupKey, szBckupCRCValueName))     // restore the no value names sub-key
            g_bRet = RegSaveRestoreHelperWrapper(NULL, NULL)  &&  g_bRet;
        else
        {
            // enumerate values using the aliases
            for (dwIndex = 0;  ;  dwIndex++)
            {
                wsprintf(szValueName, "%s%lu", pcszValueNamePrefix, dwIndex);
                Convert2CRC(g_pcszRootKey, g_pszCRCSubKey, szValueName, szBckupCRCValueName);
                if (ValueDataExists(g_hkBckupKey, szBckupCRCValueName))
                    g_bRet = RegSaveRestoreHelperWrapper(NULL, szValueName)  &&  g_bRet;
                else
                    break;                                          // no more value names
            }
        }

        // enumerate sub-keys using the aliases
        for (dwIndex = 0;  ;  dwIndex++)
        {
            // check if there is any sub-key under g_pszCRCSubKey; if none, this is our terminating condition.
            // NOTE: a sub-key under g_pszCRCSubKey exists if:
            // (1) the sub-key itself exists OR
            // (2) the sub-key contains atleast one value name.

            // check if a sub-key by itself exists
            pszPtr = g_pszCRCSubKey + lstrlen(g_pszCRCSubKey);
            wsprintf(pszPtr, "\\%s%lu", pcszSubKeyPrefix, dwIndex);
            Convert2CRC(g_pcszRootKey, g_pszCRCSubKey, NULL, szBckupCRCValueName);
            if (ValueDataExists(g_hkBckupKey, szBckupCRCValueName))
                EnumerateSubKey();
            else
            {
                // check if the sub-key has the first value name alias - "_$Val#0"
                Convert2CRC(g_pcszRootKey, g_pszCRCSubKey, pcszValueNamePrefix0, szBckupCRCValueName);
                if (ValueDataExists(g_hkBckupKey, szBckupCRCValueName))
                    EnumerateSubKey();
                else
                {
                    GetParentDir(g_pszCRCSubKey);
                    break;                                          // no more sub-keys
                }
            }

            GetParentDir(g_pszCRCSubKey);
        }
    }
    else                                                            // backup the key
    {
        if (RegOpenKeyEx(g_hkRootKey, g_pszSubKey, 0, KEY_READ, &hkSubKey) == ERROR_SUCCESS)
        {
            dwLen = sizeof(szValueName);
            if (RegEnumValue(hkSubKey, 0, szValueName, &dwLen, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
            {
                // no value names; just save the key itself
                g_bRet = g_bRet  &&  RegSaveRestoreHelperWrapper(NULL, NULL);
            }
            else
            {
                // enumerate the values
                dwIndex = 0;
                dwLen = sizeof(szValueName);
                while (RegEnumValue(hkSubKey, dwIndex, szValueName, &dwLen, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                {
                    // szBckupCRCValueName is really szCRCValueName
                    wsprintf(szBckupCRCValueName, "%s%lu", pcszValueNamePrefix, dwIndex);
                    g_bRet = g_bRet  &&  RegSaveRestoreHelperWrapper(szValueName, szBckupCRCValueName);

                    dwIndex++;
                    dwLen = sizeof(szValueName);
                }
            }

            // enumerate sub-keys
            dwIndex = 0;
            // append '\\' to g_pszSubKey and make pszPtr point to the char after this last '\\' so that
            // when RegEnumKey puts a sub-key name at pszPtr, g_pszSubKey would have the complete sub-key path.
            dwLen = lstrlen(g_pszSubKey);
            pszPtr = g_pszSubKey + dwLen;
            *pszPtr++ = '\\';
            while (RegEnumKey(hkSubKey, dwIndex, pszPtr, 1024 - dwLen - 1) == ERROR_SUCCESS)
            {
                // prepare the sub-key alias
                pszPtr = g_pszCRCSubKey + lstrlen(g_pszCRCSubKey);
                wsprintf(pszPtr, "\\%s%lu", pcszSubKeyPrefix, dwIndex);

                EnumerateSubKey();

                GetParentDir(g_pszSubKey);
                GetParentDir(g_pszCRCSubKey);

                dwIndex++;

                // append '\\' to g_pszSubKey and make pszPtr point to the char after this last '\\' so that
                // when RegEnumKey puts a sub-key name at pszPtr, g_pszSubKey would have the complete sub-key path.
                dwLen = lstrlen(g_pszSubKey);
                pszPtr = g_pszSubKey + dwLen;
                *pszPtr++ = '\\';
            }

            *--pszPtr = '\0';                       // chop the last '\\'; no DBCS clash because we added it

            RegCloseKey(hkSubKey);
        }
    }
}


BOOL RegSaveRestoreHelperWrapper(PCSTR pcszValueName, PCSTR pcszCRCValueName)
{
    CHAR szBckupCRCValueName[32];

    // a unique back-up value name is obtained by concatenating pcszRootKey, pcszSubKey and pcszValueName
    // and the concatenated value name is stored as a 16-byte CRC value (space optimization)
    Convert2CRC(g_pcszRootKey, g_pszCRCSubKey, pcszCRCValueName, szBckupCRCValueName);

    WriteToLog("\r\nValueName = %1,%2", g_pcszRootKey, g_pszSubKey);
    if (pcszValueName != NULL)
        WriteToLog(",%1", pcszValueName);
    WriteToLog("\r\nCRCValueName = %1\r\n", szBckupCRCValueName);

    return (g_fRestore) ?
                RegRestoreHelper(g_hkBckupKey, g_hkRootKey, g_pszSubKey, pcszValueName, szBckupCRCValueName) :
                RegSaveHelper(g_hkBckupKey, g_hkRootKey, g_pszSubKey, pcszValueName, szBckupCRCValueName);
}


BOOL RegSaveHelper(HKEY hkBckupKey, HKEY hkRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, PCSTR pcszCRCValueName)
// If pcszValueName exists in the registry, back-up its value data; otherwise, remember how much of pcszSubKey
// is present in the registry.  This info would help during restoration.
{
    HKEY hkSubKey = NULL;
    PSTR pszBckupData = NULL, pszCOSubKey = NULL, pszPtr;
    DWORD dwValueDataLen, dwValueType, dwBckupDataLen;
    CHAR chSeparator;
    BOOL fSubKeyValid;

    // don't backup the value data of pcszCRCValueName if it has been already backed-up
    if (ValueDataExists(hkBckupKey, pcszCRCValueName))
        return TRUE;

    // make a copy of pcszSubKey
    if ((pszCOSubKey = (PSTR) LocalAlloc(LPTR, lstrlen(pcszSubKey) + 1)) == NULL)
    {
        ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
        goto RegSaveHelperErr;
    }
    lstrcpy(pszCOSubKey, pcszSubKey);

    // loop through each branch in pszCOSubKey to find out how much of it is already present in the registry.
    // start with the whole sub key first and then chop one branch at a time from the end
    fSubKeyValid = TRUE;
    do
    {
        if (RegOpenKeyEx(hkRootKey, pszCOSubKey, 0, KEY_READ, &hkSubKey) == ERROR_SUCCESS)
            break;
    } while (fSubKeyValid = GetParentDir(pszCOSubKey));

    // NOTE: fSubKeyValid == FALSE here means that no branch of pcszSubKey is present

    if (fSubKeyValid  &&  lstrcmpi(pcszSubKey, pszCOSubKey) == 0)
                                        // entire subkey is present in the registry
    {
        if (pcszValueName != NULL)
        {
            if (*pcszValueName  ||  FRunningOnNT())
            {
                // check if pcszValueName is present in the registry
                if (RegQueryValueEx(hkSubKey, pcszValueName, NULL, &dwValueType, NULL, &dwValueDataLen) != ERROR_SUCCESS)
                    pcszValueName = NULL;
            }
            else
            {
                LONG lRetVal;
                CHAR szDummyBuf[1];

                // On Win95, for the default value name, its existence is checked as follows:
                //  - pass in a dummy buffer for the value data but pass in the size of the buffer as 0
                //  - the query would succeed if and only if there is no value data set
                //  - for all other cases, including the case where the value data is just the empty string,
                //      the query would fail and dwValueDataLen would contain the no. of bytes needed to
                //      fit in the value data
                // On NT4.0, if no value data is set, the query returns ERROR_FILE_NOT_FOUND
                //  NOTE: To minimize risk, we don't follow this code path if running on NT4.0

                dwValueDataLen = 0;
                lRetVal = RegQueryValueEx(hkSubKey, pcszValueName, NULL, &dwValueType, (LPBYTE) szDummyBuf, &dwValueDataLen);
                if (lRetVal == ERROR_SUCCESS  ||  lRetVal == ERROR_FILE_NOT_FOUND)
                    pcszValueName = NULL;
            }
        }
    }
    else
        pcszValueName = NULL;

    WriteToLog("BckupSubKey = ");

    // compute the length required for pszBckupData
    // format of pszBckupData is (assume that the separator char is ','):
    //     ,[<szSubKey>,[<szValueName>,\0<dwValueType><dwValueDataLen><ValueData>]]
    dwBckupDataLen = 1 + 1;     // the separator char + '\0'
    if (fSubKeyValid)
    {
        WriteToLog("%1", pszCOSubKey);
        dwBckupDataLen += lstrlen(pszCOSubKey) + 1;

        if (pcszValueName != NULL)
        {
            WriteToLog(", BckupValueName = %1", pcszValueName);
            dwBckupDataLen += lstrlen(pcszValueName) + 1 + 2 * sizeof(DWORD) + dwValueDataLen;
                                // 2 * sizeof(DWORD) == sizeof(dwValueType) + sizeof(dwValueDataLen)
        }
    }

    WriteToLog("\r\n");

    // determine a valid separator char that is not one of the chars in SubKey and ValueName
    if ((chSeparator = FindSeparator(fSubKeyValid ? pszCOSubKey : NULL, pcszValueName)) == '\0')
    {
        ErrorMsg(ctx.hWnd, IDS_NO_SEPARATOR_CHAR);
        goto RegSaveHelperErr;
    }

    // allocate memory for pszBckupData
    if ((pszBckupData = (PSTR) LocalAlloc(LPTR, dwBckupDataLen)) == NULL)
    {
        ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
        goto RegSaveHelperErr;
    }

    // start building pszBckupData
    // format of pszBckupData is (assume that the separator char is ','):
    //     ,[<szSubKey>,[<szValueName>,\0<dwValueType><dwValueDataLen><ValueData>]]
    pszPtr = pszBckupData;
    *pszPtr++ = chSeparator;
    *pszPtr = '\0';
    if (fSubKeyValid)
    {
        lstrcpy(pszPtr, pszCOSubKey);
        pszPtr += lstrlen(pszPtr);
        *pszPtr++ = chSeparator;
        *pszPtr = '\0';

        if (pcszValueName != NULL)
        {
            lstrcpy(pszPtr, pcszValueName);
            pszPtr += lstrlen(pszPtr);
            *pszPtr++ = chSeparator;
            *pszPtr++ = '\0';                       // include the '\0' char

            *((DWORD UNALIGNED *) pszPtr)++ = dwValueType;
            *((DWORD UNALIGNED *) pszPtr)++ = dwValueDataLen;

            // NOTE: pszPtr points to the start position of value data in pszBckupData
            RegQueryValueEx(hkSubKey, pcszValueName, NULL, &dwValueType, (PBYTE) pszPtr, &dwValueDataLen);
        }
    }

    if (!SetValueData(hkBckupKey, pcszCRCValueName, (CONST BYTE *) pszBckupData, dwBckupDataLen))
    {
        ErrorMsg1Param(ctx.hWnd, IDS_ERR_REGSETVALUE, pcszCRCValueName);
        goto RegSaveHelperErr;
    }
    WriteToLog("Value backed-up\r\n");

    g_fAtleastOneRegSaved = TRUE;

    if (hkSubKey != NULL)
        RegCloseKey(hkSubKey);
    LocalFree(pszCOSubKey);
    LocalFree(pszBckupData);

    return TRUE;

RegSaveHelperErr:
    if (hkSubKey != NULL)
        RegCloseKey(hkSubKey);
    if (pszCOSubKey != NULL)
        LocalFree(pszCOSubKey);
    if (pszBckupData != NULL)
        LocalFree(pszBckupData);

    return FALSE;
}


BOOL RegRestoreHelper(HKEY hkBckupKey, HKEY hkRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, PCSTR pcszCRCValueName)
// (1) If the value name in the backed-up value data is not NULL, it means that pcszValueName existed during
//     back-up time; so, restore the original value data.
// (2) If the value name in the backed-up value data is NULL and pcszValueName is not NULL, it means that
//     pcszValueName didn't exist during the back-up time; so, delete it.
// (3) If the backed-up sub key is shorter than pcszSubKey, then delete one branch at a time, if it is empty,
//     from the end in pcszSubKey till pcszSubKey becomes identical to the backed-up sub key.
{
    HKEY hkSubKey = NULL;
    PSTR pszBckupData = NULL, pszCOSubKey, pszPtr, pszBckupSubKey, pszBckupValueName;
    DWORD dwValueDataLen, dwValueType, dwBckupDataLen, dwDisposition;
    CHAR chSeparator;

    if (!GetValueData(hkBckupKey, pcszCRCValueName, &pszBckupData, &dwBckupDataLen))
    {
        ErrorMsg1Param(ctx.hWnd, IDS_ERR_REGQUERYVALUE, pcszCRCValueName);
        goto RegRestoreHelperErr;
    }

    // format of pszBckupData is (assume that the separator char is ','):
    //     ,[<szSubKey>,[<szValueName>,\0<dwValueType><dwValueDataLen><ValueData>]]
    pszPtr = pszBckupData;
    chSeparator = *pszPtr++;                // initialize the separator char; since it is not part of
                                            // Leading or Trailing DBCS Character Set, pszPtr++ is fine
    pszBckupSubKey = GetNextToken(&pszPtr, chSeparator);
    pszBckupValueName = GetNextToken(&pszPtr, chSeparator);
    pszPtr++;                               // skip '\0'

    if (g_fRemovBkData)
        WriteToLog("RemoveRegistryBackupData: ");

    WriteToLog("BckupSubKey = ");
    if (pszBckupSubKey != NULL)
    {
        WriteToLog("%1", pszBckupSubKey);
        if (pcszValueName == NULL  &&  lstrlen(pszBckupSubKey) > lstrlen(pcszSubKey))
        {
            // means that pcszSubKey was backed-up thru EnumerateSubKey
            pcszSubKey = pszBckupSubKey;
        }
    }

    // check to see if we want to restore the reg keys, values or remove reg backup data
    if (g_fRemovBkData)
    {
        if (pszBckupValueName != NULL)              // restore the backed-up value data -- case (1)
        {
            WriteToLog(", BckupValueName = %1", pcszValueName);
        }
        DelValueData(hkBckupKey, pcszCRCValueName);     // delete the back-up value name
        WriteToLog(" <Done>\r\n");
        goto Done;
    }

    if (RegCreateKeyEx(hkRootKey, pcszSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSubKey, &dwDisposition) == ERROR_SUCCESS)
    {
        if (pszBckupValueName != NULL)              // restore the backed-up value data -- case (1)
        {
            WriteToLog(", BckupValueName = %1", pcszValueName);
            dwValueType = *((DWORD UNALIGNED *) pszPtr)++;
            dwValueDataLen = *((DWORD UNALIGNED *) pszPtr)++;
            if (RegSetValueEx(hkSubKey, pszBckupValueName, 0, dwValueType, (CONST BYTE *) pszPtr, dwValueDataLen) != ERROR_SUCCESS)
            {
                ErrorMsg1Param(ctx.hWnd, IDS_ERR_REGSETVALUE, pszBckupValueName);
                goto RegRestoreHelperErr;
            }
        }
        else if (pcszValueName != NULL)
        {
            // means that the value name didn't exist while backing-up; so delete it -- case (2)
            RegDeleteValue(hkSubKey, pcszValueName);
        }

        RegCloseKey(hkSubKey);

        DelValueData(hkBckupKey, pcszCRCValueName);     // delete the back-up value name
        WriteToLog("\r\nBackup Value deleted");
    }

    WriteToLog("\r\n");

    dwBckupDataLen = 0;
    if (pszBckupValueName == NULL  &&  (pszBckupSubKey == NULL  ||  (DWORD) lstrlen(pcszSubKey) > (dwBckupDataLen = lstrlen(pszBckupSubKey))))
    {
        // only a part of the subkey was present in the registry during back-up;
        // delete the remaining branches if they are empty -- case (3)

        // make a copy of pcszSubKey
        if ((pszCOSubKey = (PSTR) LocalAlloc(LPTR, lstrlen(pcszSubKey) + 1)) != NULL)
        {
            lstrcpy(pszCOSubKey, pcszSubKey);

            // start processing one branch at a time from the end in pszCOSubKey;
            // if the branch is empty, delete it;
            // stop processing as soon as pszCOSubKey becomes identical to pszBckupSubKey
            do
            {
                // NOTE: Need to delete a key only if it's empty; otherwise, we would delete
                // more than what we backed up.  For example, if component A wanted to backup
                // HKLM,Software\Microsoft\Windows\CurrentVersion\Uninstall\InternetExplorer
                // and the machine didn't have the Uninstall key, we should not blow away the
                // entire Uninstall key when we uninstall A as other components might have added
                // their uninstall strings there.  So delete a key only if it's empty.
                if (RegKeyEmpty(hkRootKey, pszCOSubKey))
                    RegDeleteKey(hkRootKey, pszCOSubKey);
                else
                    break;
            } while (GetParentDir(pszCOSubKey)  &&  (DWORD) lstrlen(pszCOSubKey) > dwBckupDataLen);

            LocalFree(pszCOSubKey);
        }
    }

Done:
    LocalFree(pszBckupData);

    return TRUE;

RegRestoreHelperErr:
    if (hkSubKey != NULL)
        RegCloseKey(hkSubKey);
    if (pszBckupData != NULL)
        LocalFree(pszBckupData);

    return FALSE;
}


BOOL AddDelMapping(HKEY hkBckupKey, PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, DWORD dwFlags)
{
    CHAR szCRCValueName[32], szBuf[32];
    DWORD dwIndex;
    BOOL bFound = FALSE;
    HKEY hkSubKey = NULL;

    Convert2CRC(pcszRootKey, pcszSubKey, pcszValueName, szCRCValueName);

    // enumerate all the sub-keys under hkBckupKey
    for (dwIndex = 0;  !bFound && RegEnumKey(hkBckupKey, dwIndex, szBuf, sizeof(szBuf)) == ERROR_SUCCESS;  dwIndex++)
    {
        PSTR pszPtr;

        // check if the keyname is of the form *.map
        if ((pszPtr = ANSIStrChr(szBuf, '.')) != NULL  &&  lstrcmpi(pszPtr, ".map") == 0)
        {
            if (RegOpenKeyEx(hkBckupKey, szBuf, 0, KEY_READ | KEY_WRITE, &hkSubKey) == ERROR_SUCCESS)
            {
                if (RegQueryValueEx(hkSubKey, szCRCValueName, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                    bFound = TRUE;
                else
                {
                    RegCloseKey(hkSubKey);
                    hkSubKey = NULL;
                }
            }
        }
    }

    if (g_fRestore)
    {
        if (bFound)
            RegDeleteValue(hkSubKey, szCRCValueName);
    }
    else
    {
        if (!bFound)
        {
            DWORD dwMapKeyIndex = 0;

            // add the quadruplet, i.e., ",Flags,RootKey,SubKey,ValueName" to hkBckupKey\*.map
            wsprintf(szBuf, "%lu.map", dwMapKeyIndex);
            if (RegCreateKeyEx(hkBckupKey, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSubKey, NULL) == ERROR_SUCCESS)
            {
                PSTR pszPtr;
                CHAR chSeparator;

                // IMPORTANT: the global buffer g_pszCRCTempBuf is used in Convert2CRC;
                // so be very careful if you want to call Convert2CRC after g_pszCRCTempBuf has been initialized here.
                pszPtr = g_pszCRCTempBuf;

                // determine a valid separator char that is not one of the chars in SubKey and ValueName
                if ((chSeparator = FindSeparator(pcszSubKey, pcszValueName)) == '\0')
                {
                    ErrorMsg(ctx.hWnd, IDS_NO_SEPARATOR_CHAR);
                }
                else
                {
                    // reset the IE4_BACKNEW bit and set the IE4_RESTORE bit
                    dwFlags &= ~IE4_BACKNEW;
                    dwFlags |= IE4_RESTORE;
                    wsprintf(szBuf, "%lu", dwFlags);

                    // format of mapping data is (say ',' is chSeparator): ,<Flags>,<RootKey>,<SubKey>,[<ValueName>,]
                    {
                        *pszPtr++ = chSeparator;

                        lstrcpy(pszPtr, szBuf);
                        pszPtr += lstrlen(pszPtr);
                        *pszPtr++ = chSeparator;

                        lstrcpy(pszPtr, pcszRootKey);
                        pszPtr += lstrlen(pszPtr);
                        *pszPtr++ = chSeparator;

                        lstrcpy(pszPtr, pcszSubKey);
                        pszPtr += lstrlen(pszPtr);
                        *pszPtr++ = chSeparator;

                        if (pcszValueName != NULL)
                        {
                            lstrcpy(pszPtr, pcszValueName);
                            pszPtr += lstrlen(pszPtr);
                            *pszPtr++ = chSeparator;
                        }

                        *pszPtr = '\0';
                    }

                    if (RegSetValueEx(hkSubKey, szCRCValueName, 0, REG_SZ, (CONST BYTE *) g_pszCRCTempBuf, lstrlen(g_pszCRCTempBuf) + 1) != ERROR_SUCCESS)
                    {
                        do
                        {
                            // hkBckupKey\<dwIndex>.map key may have reached the 64K limit; create another sub-key
                            RegCloseKey(hkSubKey);
                            hkSubKey = NULL;

                            wsprintf(szBuf, "%lu.map", ++dwMapKeyIndex);
                            if (RegCreateKeyEx(hkBckupKey, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSubKey, NULL) == ERROR_SUCCESS)
                            {
                                bFound = RegSetValueEx(hkSubKey, szCRCValueName, 0, REG_SZ, (CONST BYTE *) g_pszCRCTempBuf, lstrlen(g_pszCRCTempBuf) + 1) == ERROR_SUCCESS;
                            }
                        } while (!bFound  &&  dwMapKeyIndex < 64);
                    }
                    else
                        bFound = TRUE;
                }
            }
        }
    }

    if (hkSubKey != NULL)
        RegCloseKey(hkSubKey);

    return bFound;
}


BOOL MappingExists(HKEY hkBckupKey, PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName)
{
    CHAR szCRCValueName[32], szBuf[32];
    DWORD dwIndex;
    BOOL bFound = FALSE;

    Convert2CRC(pcszRootKey, pcszSubKey, pcszValueName, szCRCValueName);

    // enumerate all the sub-keys under hkBckupKey
    for (dwIndex = 0;  !bFound && RegEnumKey(hkBckupKey, dwIndex, szBuf, sizeof(szBuf)) == ERROR_SUCCESS;  dwIndex++)
    {
        PSTR pszPtr;

        // check if the keyname is of the form *.map
        if ((pszPtr = ANSIStrChr(szBuf, '.')) != NULL  &&  lstrcmpi(pszPtr, ".map") == 0)
        {
            HKEY hkSubKey;

            if (RegOpenKeyEx(hkBckupKey, szBuf, 0, KEY_READ | KEY_WRITE, &hkSubKey) == ERROR_SUCCESS)
            {
                if (RegQueryValueEx(hkSubKey, szCRCValueName, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                    bFound = TRUE;

                RegCloseKey(hkSubKey);
            }
        }
    }

    return bFound;
}


BOOL SetValueData(HKEY hkBckupKey, PCSTR pcszValueName, CONST BYTE *pcbValueData, DWORD dwValueDataLen)
// Set the (pcszValueName, pcbValueData) pair in hkBckupKey
{
    BOOL fDone = FALSE;
    HKEY hkSubKey;
    DWORD dwDisposition, dwSubKey;
    CHAR szSubKey[16];

    // since a key has a size limit of 64K, automatically generate a new sub-key if the other ones are full
    for (dwSubKey = 0;  !fDone && dwSubKey < 64;  dwSubKey++)
    {
        wsprintf(szSubKey, "%lu", dwSubKey);        // sub-keys are named 0, 1, 2, etc.
        if (RegCreateKeyEx(hkBckupKey, szSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkSubKey, &dwDisposition) == ERROR_SUCCESS)
        {
            if (RegSetValueEx(hkSubKey, pcszValueName, 0, REG_BINARY, pcbValueData, dwValueDataLen) == ERROR_SUCCESS)
                fDone = TRUE;

            RegCloseKey(hkSubKey);
        }
    }

    return fDone;
}


BOOL ValueDataExists(HKEY hkBckupKey, PCSTR pcszValueName)
// Return TRUE if pcszValueName exists in hkBckupKey; otherwise, return FALSE
{
    return ValueDataHelper(hkBckupKey, pcszValueName, NULL, NULL, VDH_EXISTENCE_ONLY);
}


BOOL GetValueData(HKEY hkBckupKey, PCSTR pcszValueName, PBYTE *ppbValueData, PDWORD pdwValueDataLen)
// Allocate a buffer of required size and return the value data of pcszValueName in hkBckupKey
{
    return ValueDataHelper(hkBckupKey, pcszValueName, ppbValueData, pdwValueDataLen, VDH_GET_VALUE);
}


BOOL DelValueData(HKEY hkBckupKey, PCSTR pcszValueName)
// Delete pcszValueName from hkBckupKey
{
    return ValueDataHelper(hkBckupKey, pcszValueName, NULL, NULL, VDH_DEL_VALUE);
}


BOOL ValueDataHelper(HKEY hkBckupKey, PCSTR pcszValueName, PBYTE *ppbValueData, PDWORD pdwValueDataLen, DWORD dwFlags)
{
    BOOL fDone = FALSE;
    HKEY hkSubKey;
    CHAR szSubKey[16];
    DWORD dwIndex, dwDataLen;

    if (dwFlags == VDH_GET_VALUE  &&  ppbValueData == NULL)
        return FALSE;

    // search for pcszValueName in all the sub-keys
    for (dwIndex = 0;  !fDone && RegEnumKey(hkBckupKey, dwIndex, szSubKey, sizeof(szSubKey)) == ERROR_SUCCESS;  dwIndex++)
    {
        if ( ANSIStrChr(szSubKey, '.') == NULL)           // check only in non *.map keys
        {
            if (RegOpenKeyEx(hkBckupKey, szSubKey, 0, KEY_READ | KEY_WRITE, &hkSubKey) == ERROR_SUCCESS)
            {
                if (RegQueryValueEx(hkSubKey, pcszValueName, NULL, NULL, NULL, &dwDataLen) == ERROR_SUCCESS)
                {
                    switch (dwFlags)
                    {
                    case VDH_DEL_VALUE:
                        RegDeleteValue(hkSubKey, pcszValueName);
                        break;

                    case VDH_GET_VALUE:
                        if ((*ppbValueData = (PBYTE) LocalAlloc(LPTR, dwDataLen)) == NULL)
                        {
                            RegCloseKey(hkSubKey);
                            ErrorMsg(ctx.hWnd, IDS_ERR_NO_MEMORY);
                            return FALSE;
                        }

                        *pdwValueDataLen = dwDataLen;
                        RegQueryValueEx(hkSubKey, pcszValueName, NULL, NULL, *ppbValueData, &dwDataLen);

                        break;

                    case VDH_EXISTENCE_ONLY:
                        break;
                    }

                    fDone = TRUE;
                }

                RegCloseKey(hkSubKey);
            }
        }
    }

    return fDone;
}


VOID Convert2CRC(PCSTR pcszRootKey, PCSTR pcszSubKey, PCSTR pcszValueName, PSTR pszCRCValueName)
// Concatenate pcszRootKey, pcszSubKey and pcszValueName and convert the concatenated value name
// to a 16-byte CRC value.
{
    PSTR pszPtr = g_pszCRCTempBuf;
    ULONG ulCRC = CRC32_INITIAL_VALUE;
    DWORD dwLen;

    // concatenate pcszRootKey, pcszSubKey, pcszValueName
    lstrcpy(pszPtr, pcszRootKey);
    lstrcat(pszPtr, pcszSubKey);
    if (pcszValueName != NULL)
        lstrcat(pszPtr, pcszValueName);

    // call CRC32Compute on each half of szBuf and store the 2-DWORD result in ASCII form (16 bytes)
    for (dwLen = lstrlen(pszPtr) / 2;  dwLen;  dwLen = lstrlen(pszPtr))
    {
        ulCRC = CRC32Compute(pszPtr, dwLen, ulCRC);

        wsprintf(pszCRCValueName, "%08x", ulCRC);
        pszCRCValueName += 8;

        pszPtr += dwLen;                // point to the beginning of the other half
    }
}


static ROOTKEY rkRoots[] =
{
    {"HKEY_LOCAL_MACHINE",  HKEY_LOCAL_MACHINE},
    {"HKLM",                HKEY_LOCAL_MACHINE},
    {"HKEY_CLASSES_ROOT",   HKEY_CLASSES_ROOT},
    {"HKCR",                HKEY_CLASSES_ROOT},
    {"",                    HKEY_CLASSES_ROOT},
    {"HKEY_CURRENT_USER",   HKEY_CURRENT_USER},
    {"HKCU",                HKEY_CURRENT_USER},
    {"HKEY_USERS",          HKEY_USERS},
    {"HKU",                 HKEY_USERS}
};

BOOL MapRootRegStr2Key(PCSTR pcszRootKey, HKEY *phkRootKey)
{
    INT iIndex;

    for (iIndex = 0;  iIndex < ARRAYSIZE(rkRoots);  iIndex++)
        if (lstrcmpi(rkRoots[iIndex].pcszRootKey, pcszRootKey) == 0)
        {
            *phkRootKey = rkRoots[iIndex].hkRootKey;
            return TRUE;
        }

    return FALSE;
}


CHAR FindSeparator(PCSTR pcszSubKey, PCSTR pcszValueName)
// Go through pcszSeparatorList and return the first char that doesn't appear in any of the parameters;
//   if such a char is not found, return '\0'
{
    PCSTR pcszSeparatorList = ",$'?%;:";        // since the separator chars are 'pure' ASCII chars, i.e.,
                                                // they are not part of Leading or Trailing DBCS Character Set,
                                                // IsSeparator(), which assumes a 'pure' ASCII ch to look for,
                                                // can be used
    CHAR ch;

    while (ch = *pcszSeparatorList++)
        if (!IsSeparator(ch, pcszSubKey)  &&  !IsSeparator(ch, pcszValueName))
            break;

    return ch;
}


BOOL RegKeyEmpty(HKEY hkRootKey, PCSTR pcszSubKey)
// Return TRUE if pcszSubKey is emtpy, i.e., no sub keys and value names; otherwise, return FALSE
{
    HKEY hkKey;
    BOOL bRet = FALSE;
    CHAR szBuf[1];
    DWORD dwBufLen = sizeof(szBuf);

    if (RegOpenKeyEx(hkRootKey, pcszSubKey, 0, KEY_READ, &hkKey) == ERROR_SUCCESS)
    {
        if (RegEnumKey(hkKey, 0, szBuf, dwBufLen) == ERROR_NO_MORE_ITEMS  &&
            RegEnumValue(hkKey, 0, szBuf, &dwBufLen, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
            bRet = TRUE;

        RegCloseKey(hkKey);
    }

    return bRet;
}


PSTR GetNextToken(PSTR *ppszData, CHAR chDeLim)
// If the next token in *ppszData is delimited by the chDeLim char, replace chDeLim
//   in *ppszData by '\0', set *ppszData to point to the char after '\0' and return
//   ptr to the beginning of the token; otherwise, return NULL
{
    PSTR pszPos;

    if (ppszData == NULL  ||  *ppszData == NULL  ||  **ppszData == '\0')
        return NULL;

    if ((pszPos = ANSIStrChr(*ppszData, chDeLim)) != NULL)
    {
        PSTR pszT = *ppszData;

        *pszPos = '\0';                 // replace chDeLim with '\0'
        *ppszData = pszPos + 1;
        pszPos = pszT;
    }
    else                                // chDeLim not found; set *ppszData to point to
                                        //   to the end of szData; the next invocation
                                        //   of this function would return NULL
    {
        pszPos = *ppszData;
        *ppszData = pszPos + lstrlen(pszPos);
    }

    return pszPos;
}


BOOL FRunningOnNT()
{
    static BOOL fIsNT4 = 2;

    if (fIsNT4 == 2)
    {
        OSVERSIONINFO osviVerInfo;

        osviVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&osviVerInfo);

        fIsNT4 = osviVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT;
    }

    return fIsNT4;
}


VOID StartLogging(PCSTR pcszLogFileSecName)
{
    CHAR szBuf[MAX_PATH], szLogFileName[MAX_PATH];
    HKEY hkSubKey;

    szLogFileName[0] = '\0';

    // check if logging is enabled
    GetProfileString("RegBackup", pcszLogFileSecName, "", szLogFileName, sizeof(szLogFileName));
    if (*szLogFileName == '\0')               // check in the registry
    {
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SAVERESTORE, 0, KEY_READ, &hkSubKey) == ERROR_SUCCESS)
        {
            DWORD dwDataLen = sizeof(szLogFileName);

            if (RegQueryValueEx(hkSubKey, pcszLogFileSecName, NULL, NULL, szLogFileName, &dwDataLen) != ERROR_SUCCESS)
                *szLogFileName = '\0';

            RegCloseKey(hkSubKey);
        }
    }

    if (*szLogFileName)
    {
        if (szLogFileName[1] != ':')           // crude way of determining if fully qualified path is specified or not
        {
            GetWindowsDirectory(szBuf, sizeof(szBuf));          // default to windows dir
            AddPath(szBuf, szLogFileName);
        }
        else
            lstrcpy(szBuf, szLogFileName);

        if ((g_hLogFile = CreateFile(szBuf, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
            SetFilePointer(g_hLogFile, 0, NULL, FILE_END);      // append logging info to the file
    }
}


VOID WriteToLog(PCSTR pcszFormatString, ...)
{
    va_list vaArgs;
    PSTR pszFullErrMsg = NULL;
    DWORD dwBytesWritten;

    if (g_hLogFile != INVALID_HANDLE_VALUE)
    {
        va_start(vaArgs, pcszFormatString);

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                      (LPCVOID) pcszFormatString, 0, 0, (PSTR) &pszFullErrMsg, 0, &vaArgs);

        if (pszFullErrMsg != NULL)
        {
            WriteFile(g_hLogFile, pszFullErrMsg, lstrlen(pszFullErrMsg), &dwBytesWritten, NULL);
            LocalFree(pszFullErrMsg);
        }
    }
}


VOID StopLogging()
{
    if (g_hLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hLogFile);
        g_hLogFile = INVALID_HANDLE_VALUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\sfp.h ===
// This file contains the prototype declaration of SFP API's on Millennium (in sfc.dll)


// typedef's
typedef DWORD (WINAPI * SFPINSTALLCATALOG)  (LPCTSTR, LPCTSTR);
typedef DWORD (WINAPI * SFPDELETECATALOG)   (LPCTSTR);
typedef DWORD (WINAPI * SFPDUPLICATECATALOG)(LPCTSTR, LPCTSTR);


// extern declarations
// functions
extern BOOL LoadSfcDLL();
extern VOID UnloadSfcDLL();

// variables
extern SFPINSTALLCATALOG   g_pfSfpInstallCatalog;
extern SFPDELETECATALOG    g_pfSfpDeleteCatalog;
extern SFPDUPLICATECATALOG g_pfSfpDuplicateCatalog;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\reginst.c ===
/*** reginst.c - RegInstall API
 *
 *  This file contains the RegInstall API and its implementation.
 *
 *  Copyright (c) 1996 Microsoft Corporation
 *  Author:     Matt Squires (MattSq)
 *  Created     08/12/96
 */

#include <windows.h>
#include <ole2.h>
#include <advpub.h>
#include <setupapi.h>
#include "globals.h"
#include "advpack.h"
#include "regstr.h"

// FIXFIX - Sundown - let's use public de
// #define IS_RESOURCE(x)  ((((LPTSTR)(x)) <= MAKEINTRESOURCE(-1)) && (((LPTSTR)(x)) != NULL))
#define IS_RESOURCE(x)     ( (((LPTSTR)(x)) != NULL) && IS_INTRESOURCE(x) )

#define  FILESIZE_63K   64449

BOOL GetProgramFilesDir( LPSTR pszPrgfDir, int iSize )
{
    *pszPrgfDir = 0;

    if ( ctx.wOSVer >= _OSVER_WINNT50 )
    {
        if ( GetEnvironmentVariable( TEXT("ProgramFiles"), pszPrgfDir, iSize ) )
            return TRUE;
    }

    if ( GetValueFromRegistry( pszPrgfDir, iSize, "HKLM", REGSTR_PATH_SETUP, REGVAL_PROGRAMFILES ) )
    {
        if ( ctx.wOSVer >= _OSVER_WINNT40 )
        {
            char szSysDrv[5] = { 0 };

            // combine reg value and systemDrive to get the acurate ProgramFiles dir
            if ( GetEnvironmentVariable( TEXT("SystemDrive"), szSysDrv, ARRAYSIZE(szSysDrv) ) &&
                 szSysDrv[0] )
                *pszPrgfDir = szSysDrv[0];
        }

        return TRUE;
    }
     
    return FALSE;
}

/***LP CreateInfFile - Create an INF file from an hmodule
 *
 *  ENTRY
 *      hm - hmodule that contains the REGINST resource
 *      pszInfFileName -> the location to get the INF filename
 *
 *  EXIT
 *      Standard API return
 */
HRESULT CreateInfFile(HMODULE hm, LPTSTR pszInfFileName, DWORD *pdwFileSize)
{
    HRESULT hr = E_FAIL;
    TCHAR szInfFilePath[MAX_PATH] = { 0 };
    LPVOID pvInfData;
    HRSRC hrsrcInfData;
    DWORD cbInfData, cbWritten;
    HANDLE hfileInf = INVALID_HANDLE_VALUE;

    if ( pdwFileSize )
        *pdwFileSize = 0;

    if (GetTempPath(ARRAYSIZE(szInfFilePath), szInfFilePath) > ARRAYSIZE(szInfFilePath))
    {
        goto Cleanup;
    }

    if ( !IsGoodDir( szInfFilePath ) )
    {
        GetWindowsDirectory( szInfFilePath, sizeof(szInfFilePath) );
    }

    if (GetTempFileName(szInfFilePath, TEXT("RGI"), 0, pszInfFileName) == 0)
    {
        goto Cleanup;
    }

    hrsrcInfData = FindResource(hm, TEXT("REGINST"), TEXT("REGINST"));
    if (hrsrcInfData == NULL)
    {
        goto Cleanup;
    }

    cbInfData = SizeofResource(hm, hrsrcInfData);

    pvInfData = LockResource(LoadResource(hm, hrsrcInfData));
    if (pvInfData == NULL)
    {
        goto Cleanup;
    }

    WritePrivateProfileString( NULL, NULL, NULL, pszInfFileName );

    hfileInf = CreateFile(pszInfFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL, NULL);
    if (hfileInf == INVALID_HANDLE_VALUE)
    {        
        goto Cleanup;
    }

    if ((WriteFile(hfileInf, pvInfData, cbInfData, &cbWritten, NULL) == FALSE) ||
        (cbWritten != cbInfData))
    {
        goto Cleanup;
    }

    if ( pdwFileSize )
        *pdwFileSize = cbWritten;

    hr = S_OK;

Cleanup:
    if (hfileInf != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hfileInf);
    }

    return hr;
}

#if 0

LPTSTR CheckPrefix(LPTSTR lpszStr,  LPCTSTR lpszSub )
{
    int     ilen;
    TCHAR   chTmp;
    LPTSTR  lpTmp = NULL;

    ilen = lstrlen( lpszSub );
    lpTmp = lpszStr;
    while ( ilen && *lpTmp )
    {
        lpTmp = CharNext( lpTmp );
        ilen--;
    }

    chTmp = *lpTmp;
    *lpTmp = '\0';
    if ( lstrcmpi( lpszSub, lpszStr ) )
    {
        *lpTmp = chTmp;
        lpTmp = NULL;
    }
    else
        *lpTmp = chTmp;
    return lpTmp;
}
#endif

BOOL ReplaceSubString( LPSTR pszOutLine, LPSTR pszOldLine, LPCSTR pszSubStr, LPCSTR pszSubReplacement )
{
    LPSTR lpszStart = NULL;
    LPSTR lpszNewLine;
    LPSTR lpszCur;
    BOOL  bFound = FALSE;
    int   ilen;

    lpszCur = pszOldLine;
    lpszNewLine = pszOutLine;
    while ( lpszStart = ANSIStrStrI( lpszCur, pszSubStr ) )
    {
        // this module path has the systemroot            
        ilen = (int)(lpszStart - lpszCur);
        if ( ilen )
        {
            lstrcpyn( lpszNewLine, lpszCur, ilen + 1 );
            lpszNewLine += ilen;
        }
        lstrcpy( lpszNewLine, pszSubReplacement );

        lpszCur = lpszStart + lstrlen(pszSubStr);
        lpszNewLine += lstrlen(pszSubReplacement);
        bFound = TRUE;
    }

    lstrcpy( lpszNewLine, lpszCur );

    return bFound;
}

//==========================================================================================
//
//==========================================================================================

BOOL AddEnvInPath( PSTR pszOldPath, PSTR pszNew )
{
    CHAR szBuf[MAX_PATH];
    CHAR szBuf2[MAX_PATH];
    CHAR szEnvVar[100];
    CHAR szReplaceStr[100];    
    CHAR szSysDrv[5];
    BOOL bFound = FALSE;
    BOOL bRet;
    LPSTR pszFinalStr;

    pszFinalStr = pszOldPath;

    // replace c:\winnt Windows folder
    if ( GetEnvironmentVariable( "SystemRoot", szEnvVar, ARRAYSIZE(szEnvVar) ) )
    {
        if ( ReplaceSubString( szBuf, pszFinalStr, szEnvVar, "%SystemRoot%" ) )
        {
            bFound = TRUE;
            pszFinalStr = szBuf;
        }
    }

    if ( GetProgramFilesDir( szEnvVar, sizeof(szEnvVar) ) &&  
         GetEnvironmentVariable( "SystemDrive", szSysDrv, ARRAYSIZE(szSysDrv) )  )
    {
        // Get the replacement string first, so c:\program files replacement is
        // %SystemDrive%\program files or %ProgramFiles% if >= WINNT50
        // Replace the c:\Program Files folder 
        //
        if ( ctx.wOSVer >= _OSVER_WINNT50 )
        {
            if ( ReplaceSubString( szBuf2, pszFinalStr, szEnvVar, "%ProgramFiles%" ) )
            {
                bFound = TRUE;
                lstrcpy( szBuf, szBuf2 );
                pszFinalStr = szBuf;
            }
        }
        
        // Replace the c: System Drive letter
        if ( ReplaceSubString( szBuf2, pszFinalStr, szSysDrv, "%SystemDrive%" ) )
        {
            lstrcpy( szBuf, szBuf2 );
            pszFinalStr = szBuf;
            bFound = TRUE;
        }
    }

    // this way, if caller pass the same location for both params, still OK.
    if ( bFound ||  ( pszNew != pszOldPath ) )
        lstrcpy( pszNew, pszFinalStr );
    return bFound;    
}

//==========================================================================================
//
//==========================================================================================

BOOL MySmartWrite( LPCSTR pcszSection, LPCSTR pcszKey, LPCSTR pcszValue, LPCSTR pcszFilename, DWORD dwFileSize )
{
    DWORD cbData, cbWritten = 0;
    BOOL  bRet = FALSE;

    if ( dwFileSize <= FILESIZE_63K )
    {
        bRet = WritePrivateProfileString( pcszSection, pcszKey, pcszValue, pcszFilename );
    }
    else
    {
        HANDLE hfileInf = INVALID_HANDLE_VALUE;
        LPSTR  pszBuf = NULL;
        const char c_szLineTmplate[] = "%s=\"%s\"\r\n";
        const char c_szLineTmplate2[] = "%s=%s\r\n";

        pszBuf = LocalAlloc( LPTR, 1024 );
        if ( !pszBuf )
            return bRet;

        hfileInf = CreateFile( pcszFilename, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL, NULL);
        if (hfileInf == INVALID_HANDLE_VALUE)
        {    
            if ( pszBuf )
                LocalFree( pszBuf );
            return bRet;
        }

        if ( SetFilePointer( hfileInf, 0 , NULL, FILE_END ) != 0xFFFFFFFF )
        {   
            if ( *pcszValue != '"' )
                wsprintf( pszBuf, c_szLineTmplate, pcszKey, pcszValue );
            else
                wsprintf( pszBuf, c_szLineTmplate2, pcszKey, pcszValue );
            cbData = lstrlen(pszBuf);   // key="value"\r\n
            WriteFile(hfileInf, pszBuf, cbData, &cbWritten, NULL);
            bRet = (cbData == cbWritten);
        }
        CloseHandle(hfileInf);

        if ( pszBuf )
            LocalFree( pszBuf );
    }
    return bRet;
}
    

/***LP WritePredefinedStrings - Write all predefined strings to an INF
 *
 *  ENTRY
 *      pszInfFileName -> name of INF file
 *      hm - hmodule of caller
 *
 *  EXIT
 *      Standard API return
 */
HRESULT WritePredefinedStrings( LPCTSTR pszInfFileName, HMODULE hm, DWORD dwFileSize )
{
    HRESULT hr = E_FAIL;
    TCHAR szModulePath[MAX_PATH + 2];
    BOOL  bSysModPath = FALSE;

    szModulePath[0] = '"';
    if (GetModuleFileName(hm, &szModulePath[1], ARRAYSIZE(szModulePath) - 2) == 0)
    {
        goto Cleanup;
    }
    lstrcat( szModulePath, "\"" );

    MySmartWrite(TEXT("Strings"), TEXT("_MOD_PATH"), szModulePath, pszInfFileName, dwFileSize);

    if ( CheckOSVersion() )
    {

        // BOOL  bFound = FALSE;

        if ( ctx.wOSVer >= _OSVER_WINNT40 )
        {
            if ( AddEnvInPath( szModulePath, szModulePath) )
            {    
                MySmartWrite(TEXT("Strings"), TEXT("_SYS_MOD_PATH"), szModulePath, pszInfFileName, dwFileSize);
                bSysModPath = TRUE;
            }
        }
    }

    if ( !bSysModPath )
        MySmartWrite(TEXT("Strings"), TEXT("_SYS_MOD_PATH"), szModulePath, pszInfFileName, dwFileSize);

    hr = S_OK;

Cleanup:

    return hr;
}

/***LP WriteCallerStrings - Write caller supplied strings to an INF
 *
 *  ENTRY
 *      pszInfFileName -> name of INF file
 *      hm - hmodule of caller
 *      pstTable - caller supplied string table
 *
 *  EXIT
 *      Standard API return
 */
HRESULT WriteCallerStrings(LPCTSTR pszInfFileName, HMODULE hm, LPCSTRTABLE pstTable, DWORD dwFileSize)
{
    HRESULT hr = E_FAIL;
    TCHAR szValue[MAX_PATH];
    DWORD i;
    LPSTRENTRY pse;
    TCHAR szQuoteValue[MAX_PATH];
    LPTSTR lpValue;     
    
    for (i=0, pse=pstTable->pse; i<pstTable->cEntries; i++, pse++)
    {
        if (IsBadReadPtr(pse, SIZEOF(*pse)))
        {
            goto Cleanup;
        }

        if (IS_RESOURCE(pse->pszValue))
        {
            if (LoadString(hm, (UINT)(ULONG_PTR)(pse->pszValue), szValue, ARRAYSIZE(szValue)) == 0)
            {
                goto Cleanup;
            }
            else
                lpValue = szValue;
        }
        else
            lpValue = pse->pszValue;

        if ( *lpValue != '"' )
        {
            // if no quote, insert it
            szQuoteValue[0] = '"';
            lstrcpy( &szQuoteValue[1], lpValue );
            lstrcat( szQuoteValue, "\"" );
            lpValue = szQuoteValue;
        }

        MySmartWrite(TEXT("Strings"), pse->pszName, lpValue, pszInfFileName, dwFileSize);        
    }

    hr = S_OK;

Cleanup:

    return hr;
}


BOOL GetRollbackSection( LPCSTR pcszModule, LPSTR pszSec, DWORD dwSize )
{
    HKEY hKey;
    TCHAR szBuf[MAX_PATH];
    DWORD dwTmp;
    BOOL  fRet = FALSE;

    lstrcpy( szBuf, REGKEY_SAVERESTORE );
    AddPath( szBuf, pcszModule );
    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, szBuf, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ,
                         NULL, &hKey, &dwTmp ) == ERROR_SUCCESS )
    {
        dwTmp = dwSize;
        if ( (RegQueryValueEx( hKey, REGVAL_BKINSTSEC, NULL, NULL, pszSec, &dwTmp ) == ERROR_SUCCESS) && *pszSec )
            fRet = TRUE;

        RegCloseKey( hKey );
    }

    return fRet;
}


/***LP ExecuteInfSection - Ask RunSetupCommand to execute an INF section
 *
 *  ENTRY
 *      pszInfFileName -> name of INF file
 *      pszInfSection -> section to execute
 *
 *  EXIT
 *      Standard API return
 */
HRESULT ExecuteInfSection(LPCTSTR pszInfFileName, LPCTSTR pszInfSection)
{
    HRESULT hr = E_FAIL;
    TCHAR szTempPath[MAX_PATH];
    TCHAR szBuf[MAX_PATH];
    BOOL fSavedContext = FALSE;
    DWORD dwFlags = 0;


    if (!SaveGlobalContext())
    {
        goto Cleanup;
    }

    fSavedContext = TRUE;

    // get the source dir
    if (GetTempPath(ARRAYSIZE(szTempPath), szTempPath) > ARRAYSIZE(szTempPath))
    {
        goto Cleanup;
    }

    // we check if this caller needs to do save/rollback, or just simple GenInstall
    if (SUCCEEDED(GetTranslatedString(pszInfFileName, pszInfSection, ADVINF_MODNAME, szBuf, ARRAYSIZE(szBuf), NULL)))
    {
        dwFlags = GetTranslatedInt(pszInfFileName, pszInfSection, ADVINF_FLAGS, 0);
    }

    if ( (dwFlags & ALINF_BKINSTALL) || (dwFlags & ALINF_ROLLBKDOALL) || (dwFlags & ALINF_ROLLBACK) )
    {
        CABINFO   cabInfo;

        ZeroMemory( &cabInfo, sizeof(CABINFO) );
        cabInfo.pszInf = (LPSTR)pszInfFileName;
        lstrcpy( cabInfo.szSrcPath, szTempPath );
        cabInfo.dwFlags = dwFlags;

        if ( dwFlags & ALINF_BKINSTALL  )
        {
            cabInfo.pszSection = (LPSTR)pszInfSection;
        }
        else
        {
            if ( !GetRollbackSection( szBuf, szTempPath, ARRAYSIZE(szTempPath) ) )
            {
                hr = E_UNEXPECTED;
                goto Cleanup;
            }

            cabInfo.pszSection = szTempPath;
        }                        
            
        hr = ExecuteCab( NULL, &cabInfo, NULL );
    }
    else
    {
        hr = RunSetupCommand(INVALID_HANDLE_VALUE, pszInfFileName, pszInfSection,
                            szTempPath, NULL, NULL, RSC_FLAG_INF | RSC_FLAG_QUIET,
                            NULL);
    }

Cleanup:

    if (fSavedContext)
    {
        RestoreGlobalContext();
    }

    return hr;
}

/***EP RegInstall - Install a registry INF
 *
 *  @doc    API REGINSTALL
 *
 *  @api    STDAPI | RegInstall | Install a registry INF
 *
 *  @parm   HMODULE | hm | The hmodule of the caller.  The INF is extracted
 *          from the module's resources (type="REGINST", name="REGINST").
 *
 *  @parm   LPCTSTR | pszSection | The section of the INF to execute.
 *
 *  @parm   LPCSTRTABLE | pstTable | A table of string mappings.
 *
 *  @rdesc  S_OK - registry INF successfully installed.
 *
 *  @rdesc  E_FAIL - error installing INF.
 */
STDAPI RegInstall(HMODULE hm, LPCTSTR pszSection, LPCSTRTABLE pstTable)
{
    HRESULT hr = E_FAIL;
    TCHAR szInfFileName[MAX_PATH];
    DWORD   dwFileSize = 0;

    AdvWriteToLog("RegInstall: Section=%1\r\n", pszSection);
    //
    // Create the INF file.
    //
    szInfFileName[0] = TEXT('\0');
    hr = CreateInfFile(hm, szInfFileName, &dwFileSize);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    //
    // Write out our predefined strings.
    //
    hr = WritePredefinedStrings(szInfFileName, hm, dwFileSize);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    //
    // Write out the user supplied strings.
    //
    if (pstTable)
    {
        hr = WriteCallerStrings(szInfFileName, hm, pstTable, dwFileSize);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    WritePrivateProfileString( NULL, NULL, NULL, szInfFileName );

    //
    // Execute the INF engine on the INF.
    //
    hr = ExecuteInfSection(szInfFileName, pszSection);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:

    //
    // Delete the INF file.
    //
    if (szInfFileName[0])
    {
        DeleteFile(szInfFileName);
    }
    AdvWriteToLog("RegInstall: Section=%1 End hr=%2!x!\r\n", pszSection, hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\uninstal.h ===
#ifndef _UNINSTAL_H


/*
 * Errors that *we* have defined
 */
#define MYERROR_UNKNOWN         -1      // maps to no msg
#define MYERROR_DISK_FULL       -2      // maps to MSG_ERROR_DISK_FULL
#define MYERROR_BAD_DATA        -3      // maps to MSG_ERROR_BAD_DATA
#define MYERROR_UNEXPECTED_EOF  -4      // maps to MSG_ERROR_UNEXPECTED_EOF
#define MYERROR_READ            -5      
#define MYERROR_WRITE           -6
#define MYERROR_BAD_SIG         -7
#define MYERROR_DECOMP_FAILURE  -8
#define MYERROR_OUTOFMEMORY     -9
#define MYERROR_BAD_BAK         -10
#define MYERROR_BAD_CRC         -11


// define the bad-backup file attribute value
#define NO_FILE     -1

typedef struct _BAKDATA {
    HANDLE  hDatFile;
    DWORD   dwDatOffset;
    char    szIniFileName[MAX_PATH];        // used while making temp ini files
    char    szFinalDir[MAX_PATH];       // Final resting place of w95undo.*
} BAKDATA, FAR *PBAKDATA;

typedef struct _FILELIST {
    char* name;
//    char* bakname;
    UINT   bak_exists;
    DWORD bak_attribute;
    FILETIME FileTime;
    DWORD dwSize;
    DWORD dwDatOffset;
    DWORD dwFileCRC;
    DWORD dwRefCount;
    struct _FILELIST * next;

} FILELIST;



//RC PRIVATE SaveBackups( );
BOOL BackupInit(PBAKDATA pbd, LPCSTR lpszPath);

int Files_need_backup( FILELIST *filelist );
BOOL ReplaceBackups(FILELIST * filelist, char * StfWinDir);
int Files_need_backup( FILELIST *filelist );
void backups_exist(FILELIST * filelist);
BOOL BackupSingleFile(FILELIST * filelist, PBAKDATA pbd);
BOOL GetValueForFileFromIni(FILELIST *FileList);
int DosPrintf(PBAKDATA pbd, FILELIST *filelist, DWORD dwFileSize,
              FILETIME FileTime, DWORD dwDatOffset, DWORD dwCRC);
void WriteUninstallDirToReg(LPSTR lpszUninstallDir);
void DeleteUninstallDirFromToReg();
//BOOL GetFieldString(LPSTR lpszLine, int iField, LPSTR lpszField, int cbSize); 
BOOL MakeBakName(LPSTR lpszName, LPSTR szBakName);
BOOL DoSaveUninstall(BOOL bStopUninstall);
BOOL GetUninstallDirFromReg(LPSTR lpszUninstallDir);
BOOL DetermineUninstallDir(FILELIST *FileList, LPSTR lpszUninstallDir, DWORD *pdwSizeNeeded);
BOOL UninstallInfoExists();
void DeleteUninstallFilesAndReg();
void SetUninstallFileAttrib(LPSTR szPath);
BOOL ValidateUninstallFiles(LPSTR lpszPath);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\uninstal.c ===
#define STRICT
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <wchar.h>
#include <stdlib.h>
#include <limits.h>
#include <commdlg.h>
#include "setupapi.h"
#include "resource.h"
#include "advpack.h"
#include "uninstal.h"
#include "globals.h"
#include "mrcicode.h"
#include "crc32.h"
#include <advpub.h>
#include <regstr.h>

#define MAX_STR_LEN     1024
#define SEC_RENAME  "Rename"
#define MAX_IOSIZE      32768
#define DAT_FILESIG     0x504A4743
#define OK           0
#define CR           13

const char c_szREGKEY_SHAREDLL[] = REGSTR_PATH_SETUP "\\SharedDlls";

const char c_szExtINI[] = ".INI";
const char c_szExtDAT[] = ".DAT";
//const char c_szIE4SECTIONNAME[] = "backup";
const char c_szNoFileLine[] = "-1,0,0,0,0,0,-1";

int RestoreSingleFile(FILELIST *filelist, LPSTR lpszBakFile, HANDLE hDatFile);
extern const char c_szNoFileLine[];

void MySetUninstallFileAttrib(LPSTR lpszPath, LPCSTR lpszBasename);
BOOL UninstallInfoInit(PBAKDATA pbd, LPCSTR lpszPath, LPCSTR lpszBasename, BOOL bBackup);
HRESULT BackupFiles( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags);
HRESULT RestoreFiles( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags);
void FillBackupInfo(LPCSTR lpINIFile, FILELIST *pFileList);
void initcopy(const char * StfWinDir, char * from, char * to);
unsigned long Mystrtoul (const char *nptr, char **endptr, int ibase);
BOOL CALLBACK SaveRestoreProgressDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM  lParam);
void GetListFromIniFile(LPSTR lpDir, LPSTR lpBaseName, LPSTR *lplpFileList);
void CreateFullPathForFile(LPSTR lpszBakFile);
DWORD GetRefCountFrReg( LPSTR lpFile );
HRESULT UpdateRefCount( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags );

HRESULT WINAPI FileSaveRestore( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags)
{
    char    szTitle[MAX_STR_LEN];
    LPSTR   lpszOldTitle = ctx.lpszTitle;
    HRESULT hr;

    if (!CheckOSVersion())
        return E_FAIL;

    ctx.lpszTitle = szTitle;        // Do we have to do this??

    if ( hDlg && !IsWindow(hDlg))
        dwFlags |= IE4_NOMESSAGES | IE4_NOPROGRESS;

    if (dwFlags & IE4_RESTORE)
    {
        LoadString(g_hInst, IDS_FILERESTORE_TITLE, szTitle, sizeof(szTitle));
        hr = RestoreFiles( hDlg, lpFileList, lpDir, lpBaseName, dwFlags);
    }
    else if ( dwFlags & AFSR_UPDREFCNT )
    {
        hr = UpdateRefCount( hDlg, lpFileList, lpDir, lpBaseName, dwFlags );
    }
    else
    {
        LoadString(g_hInst, IDS_FILEBACKUP_TITLE, szTitle, sizeof(szTitle));
        hr = BackupFiles( hDlg, lpFileList, lpDir, lpBaseName, dwFlags);
    }

    ctx.lpszTitle = lpszOldTitle;
    return hr;
}

HRESULT UpdateRefCount( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags )
{
    char szIniFile[MAX_PATH];
    char szLine[MAX_STR_LEN];
    char szBuf[MAX_PATH];
    DWORD dwRefCount = -1;
    DWORD dwOldAttr;
    LPSTR lpFile;

    if ( !lpFileList || !*lpFileList )
        return S_OK;

    lpFile = lpFileList;
    BuildPath( szIniFile, lpDir, lpBaseName );
    lstrcat( szIniFile, c_szExtINI );

    if ( FileExists( szIniFile ) )
    {
        dwOldAttr = GetFileAttributes( szIniFile );
        SetFileAttributes( szIniFile, FILE_ATTRIBUTE_NORMAL );
        while ( *lpFile )
        {
            if ( GetPrivateProfileString( c_szIE4SECTIONNAME, lpFile, "", szLine, sizeof(szLine), szIniFile) )
            {
                LPSTR lpszComma;
                int i, j;

                if ( GetFieldString(szLine, 6, szBuf, sizeof(szBuf)) )  // For the Attribute
                {
                    dwRefCount = My_atol( szBuf );
                    if ( dwRefCount == (DWORD)-1 )
                    {
                        dwRefCount = GetRefCountFrReg( lpFile );
                    }
                    else if ( dwFlags & AFSR_EXTRAINCREFCNT )
                        dwRefCount++;
                }
                else
                {
                    dwRefCount = GetRefCountFrReg( lpFile );
                }


                // re-write the updated INI line
                lpszComma = szLine;
                for ( i=0; i<6; i++ )
                {
                    lpszComma = ANSIStrChr(lpszComma, ',');
                    if ( !lpszComma  )
                        break;
                    else
                        lpszComma = CharNext(lpszComma);
                }

                if ( !lpszComma )
                {
                    for ( j=i; j<6; j++ )
                    {
                        lstrcat( szLine, "," );
                    }
                }
                else
                    *(++lpszComma) = '0';

                ULtoA( dwRefCount, szBuf, 10 );
                lstrcat( szLine, szBuf );
                
                WritePrivateProfileString( c_szIE4SECTIONNAME, lpFile, szLine, szIniFile );
            }

            lpFile += lstrlen(lpFile) + 1;
            
        }
        SetFileAttributes( szIniFile, dwOldAttr );

    }
    return S_OK;
}

DWORD GetRefCountFrReg( LPSTR lpFile )
{
    HKEY hKey;
    DWORD dwRefCount = 0;
    DWORD dwType;
    DWORD dwSize;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szREGKEY_SHAREDLL, (ULONG)0, KEY_READ, &hKey ) == ERROR_SUCCESS ) 
    {
        dwSize = sizeof(DWORD);
        if ( RegQueryValueEx( hKey, lpFile, NULL, &dwType, (LPBYTE)&dwRefCount, &dwSize ) != ERROR_SUCCESS ) 
        {
            dwRefCount = 0;
        }
        RegCloseKey( hKey );
    }
    return dwRefCount;
}
         
    

HRESULT BackupFiles( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags)
{
    HRESULT  hr = S_OK;
    BAKDATA  bd;
    FILELIST FileList;
    LPSTR    lpFile;
    char szLine[MAX_STR_LEN];
    char szValue[MAX_PATH];
    DWORD    dwItems = 0;
    HWND     hProgressDlg = NULL;

    if ((lpFileList) && (*lpFileList))
    {
        if (SUCCEEDED(CreateFullPath(lpDir, TRUE)) && UninstallInfoInit(&bd, lpDir, lpBaseName, TRUE))
        {
            if (!(dwFlags & IE4_NOPROGRESS))
            {
                hProgressDlg = CreateDialogParam(g_hInst, MAKEINTRESOURCE(IDD_SAVERESTOREDLG), hDlg, (DLGPROC) SaveRestoreProgressDlgProc, TRUE);
                ShowWindow(hProgressDlg, SW_SHOWNORMAL);

                lpFile = lpFileList;
                while (*lpFile)
                {
                    dwItems++;
                    lpFile += lstrlen(lpFile) + 1;
                }
                UpdateWindow(hProgressDlg);
                SendMessage(GetDlgItem(hProgressDlg, IDC_SAVERESTORE_PROGRESS), PBM_SETRANGE, 0, MAKELONG(0, dwItems));
                SendMessage(GetDlgItem(hProgressDlg, IDC_SAVERESTORE_PROGRESS), PBM_SETSTEP, 1, 0L);
            }
            lpFile = lpFileList;
            while ((hr == S_OK) && (*lpFile))
            {
                if (GetPrivateProfileString(c_szIE4SECTIONNAME, lpFile, "", szLine, sizeof(szLine), bd.szIniFileName) == 0)
                {
                    FileList.bak_attribute = GetFileAttributes( lpFile );
                    FileList.bak_exists = 0;
                }
                else
                {
                    FileList.bak_exists = 1;
                    FileList.bak_attribute = (DWORD)NO_FILE;
                    if (GetFieldString(szLine, 0, szValue, sizeof(szValue)))  // For the Attribute
                        FileList.bak_attribute = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

                    // If the file was in the list of files to backup the last time, but did not exist on the user machine
                    // but this time around it exists, only backup the file if the user specifies IE4_BACKUPNEW
                    if ((FileList.bak_attribute == (DWORD)NO_FILE) && (dwFlags & IE4_BACKNEW) )
                    {
                        FileList.bak_attribute = GetFileAttributes( lpFile );
                        FileList.bak_exists = 0;
                    }
                    else
                    {
                        // the existing INI fields: Attri[Filed0],size[Filed1],date-time(low)[Filed2], date-time(high)[Field3],offset[Field4],CRC[Field5]
                        // we are going to add the extra colume of reference count if not there already
                        if ( !GetFieldString(szLine, 6, szValue, sizeof(szValue)) )  // For the Ref-count field
                        {
                            lstrcat( szLine, ",-1" );
                            WritePrivateProfileString( c_szIE4SECTIONNAME, lpFile, szLine, bd.szIniFileName );
                        }
                    }
                }

                if (FileList.bak_exists == 0)
                {
                    if (FileList.bak_attribute != (DWORD)NO_FILE)
                    {
                        FileList.name = lpFile;
                        if (!BackupSingleFile(&FileList, &bd))
                        {  // If something went wrong, Sorry backup failed.
                            if (!(dwFlags & IE4_NOMESSAGES))
                            {
                                if (MsgBox1Param( hDlg, IDS_FILEBACKUP_ERROR, lpFile, MB_ICONEXCLAMATION, MB_YESNO) == IDNO)
                                {
                                    hr = E_FAIL;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        // File does not exist, nothing to backup, report this in the INI file.
                        WritePrivateProfileString(c_szIE4SECTIONNAME, lpFile, c_szNoFileLine, bd.szIniFileName);
                    }

                }
                // else we did already backup this file the previous install
                if (!(dwFlags & IE4_NOPROGRESS))
                {
                    UpdateWindow(hProgressDlg);
                    SendMessage(GetDlgItem(hProgressDlg, IDC_SAVERESTORE_PROGRESS), PBM_STEPIT, 0, 0L);
                }

                lpFile += lstrlen(lpFile) + 1;
            }

            if (bd.hDatFile != INVALID_HANDLE_VALUE)
               CloseHandle(bd.hDatFile);
            WritePrivateProfileString( NULL, NULL, NULL, bd.szIniFileName); // to make sure the ie4bak.ini file gets flushed
        }
        else
        {
            if (!(dwFlags & IE4_NOMESSAGES))
            {
                if (MsgBox( hDlg, IDS_BACKUPINIT_ERROR, MB_ICONEXCLAMATION , MB_YESNO) == IDNO)
                    hr = E_FAIL;
            }
        }
    }

    if (hProgressDlg)
        DestroyWindow(hProgressDlg);

    MySetUninstallFileAttrib(lpDir, lpBaseName);

    return hr;
}

BOOL UninstallInfoInit(PBAKDATA pbd, LPCSTR lpszPath, LPCSTR lpszBasename, BOOL bBackup)
{
    pbd->hDatFile = INVALID_HANDLE_VALUE;
    lstrcpy(pbd->szFinalDir, lpszPath);

    // the dat file and ini file are made on the first call to backup single file.
    if(pbd->hDatFile == INVALID_HANDLE_VALUE )
    {
        char szTmp[MAX_PATH];
       
        BuildPath(szTmp, pbd->szFinalDir, lpszBasename);
        lstrcat(szTmp, c_szExtDAT);
        SetFileAttributes(szTmp, FILE_ATTRIBUTE_NORMAL);
        pbd->hDatFile = CreateFile(szTmp, GENERIC_READ|GENERIC_WRITE, 0, NULL,
                                  (bBackup ? OPEN_ALWAYS : OPEN_EXISTING) , FILE_ATTRIBUTE_NORMAL, NULL);
        if(pbd->hDatFile == INVALID_HANDLE_VALUE)
            return FALSE;

        pbd->dwDatOffset = SetFilePointer(pbd->hDatFile, 0, NULL, FILE_END);

        BuildPath(pbd->szIniFileName, pbd->szFinalDir, lpszBasename);
        lstrcat(pbd->szIniFileName, c_szExtINI);
        SetFileAttributes(pbd->szIniFileName, FILE_ATTRIBUTE_NORMAL);
    }
    return TRUE;
}

void MySetUninstallFileAttrib(LPSTR lpszPath, LPCSTR lpszBasename)
{
    char szTmp[MAX_PATH];
   
    BuildPath(szTmp, lpszPath, lpszBasename);
    lstrcat(szTmp, c_szExtDAT);
    SetFileAttributes(szTmp, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY);

    BuildPath(szTmp, lpszPath, lpszBasename);
    lstrcat(szTmp, c_szExtINI);
    SetFileAttributes(szTmp, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY);
    return;
}


HRESULT RestoreFiles( HWND hDlg, LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName, DWORD dwFlags)
{
    HRESULT  hr = S_OK;
    int      iErr = 0;
    BAKDATA  bd;
    char     szFile[MAX_PATH];
    char     szWinDir[MAX_PATH];
    DWORD    dwItems = 0;
    HWND     hProgressDlg = NULL;
    LPSTR    lpFile;
    FILELIST FileList;
    BOOL     bGotListFromIniFile = FALSE;

    if (lpFileList == NULL)
    {
        GetListFromIniFile(lpDir, lpBaseName, &lpFileList);
        bGotListFromIniFile = TRUE;
    }

    if ((lpFileList == NULL) || !(*lpFileList))
        return hr;      // Nothing to restore.

    if (!UninstallInfoInit(&bd, lpDir, lpBaseName, FALSE))
    {
        if (!(dwFlags & IE4_NOMESSAGES))
            MsgBox( NULL, IDS_BACKUPDAT_ERROR, MB_ICONEXCLAMATION, MB_OK);
        if (bGotListFromIniFile)
        {
            LocalFree(lpFileList);
            lpFileList = NULL;
        }
        return E_FAIL;
    }

    if (!(dwFlags & IE4_NOPROGRESS))
    {
        hProgressDlg = CreateDialogParam(g_hInst, MAKEINTRESOURCE(IDD_SAVERESTOREDLG), hDlg, (DLGPROC) SaveRestoreProgressDlgProc, FALSE);
        ShowWindow(hProgressDlg, SW_SHOWNORMAL);

        lpFile = lpFileList;
        while (*lpFile)
        {
            dwItems++;
            lpFile += lstrlen(lpFile) + 1;
        }
        UpdateWindow(hProgressDlg);
        SendMessage(GetDlgItem(hProgressDlg, IDC_SAVERESTORE_PROGRESS), PBM_SETRANGE, 0, MAKELONG(0, dwItems));
        SendMessage(GetDlgItem(hProgressDlg, IDC_SAVERESTORE_PROGRESS), PBM_SETSTEP, 1, 0L);
    }
    GetWindowsDirectory(szWinDir, sizeof(szWinDir));

    lpFile = lpFileList;
    while ((hr == S_OK) && (*lpFile))
    {
        FileList.name = lpFile;
        FileList.dwSize = 0;
        FileList.dwDatOffset = (DWORD)-1;

        FillBackupInfo(bd.szIniFileName, &FileList);

        if ( (FileList.bak_attribute != NO_FILE) &&
            (FileList.dwSize > 0) && (FileList.dwDatOffset != (DWORD)-1))
        {
            if (!MakeBakName(FileList.name, szFile))
            {
                if (!(dwFlags & IE4_NOMESSAGES))
                {
                    if (MsgBox1Param( hDlg, IDS_RESTORE_ERROR2, FileList.name, MB_ICONEXCLAMATION, MB_YESNO) == IDNO)
                    {
                        // error creating a temp file for file to restore.
                        hr = E_FAIL;
                        break;
                    }
                }
                goto NextFile;
            }

            // if need to use the reg count, we only do it for those files have real ref count to begin with
            if ( (dwFlags & AFSR_USEREFCNT) && (FileList.dwRefCount!=(DWORD)-1) )
            {
                DWORD dwRefCntInReg;

                dwRefCntInReg = GetRefCountFrReg( FileList.name );
                if ( dwRefCntInReg > FileList.dwRefCount )
                    goto NextFile;                    
            }

            iErr = RestoreSingleFile(&FileList, szFile, bd.hDatFile);
            if (iErr != 0)
            {
                if (!(dwFlags & IE4_NOMESSAGES))
                {
                    wsprintf(szFile, "%d", iErr);   // reuse szFile, it is set on every call in MakeBakName
                    if (MsgBox2Param( hDlg, IDS_RESTORE_ERROR, FileList.name, szFile, MB_ICONEXCLAMATION, MB_YESNO) == IDNO)
                        hr = E_FAIL;
                }
            }
            else
            {
               SetFileAttributes( szFile, FileList.bak_attribute );
               if ( CopyFileA(szFile, FileList.name, FALSE))
               {
                   SetFileAttributes( szFile, FILE_ATTRIBUTE_NORMAL );
                   DeleteFile( szFile );
               }
               else
                   initcopy(szWinDir, szFile, FileList.name);
            }
        }
        else
        {
            // the file was never backed up, delete it if the caller want's us to
            if (!(dwFlags & IE4_NODELETENEW) )
            {
                if ( (!DeleteFile(lpFile)) && (GetFileAttributes(lpFile) != (DWORD)-1))
                    initcopy(szWinDir, lpFile, "NUL");  // If we could not delete the file. Add to reboot delete
            }
        }

NextFile:
        lpFile += lstrlen(lpFile) + 1;

        if (!(dwFlags & IE4_NOPROGRESS))
        {
            UpdateWindow(hProgressDlg);
            SendMessage(GetDlgItem(hProgressDlg, IDC_SAVERESTORE_PROGRESS), PBM_STEPIT, 0, 0L);
        }

    }

    if (hProgressDlg)
        DestroyWindow(hProgressDlg);

    if (bd.hDatFile != INVALID_HANDLE_VALUE)
        CloseHandle(bd.hDatFile);

    if (bGotListFromIniFile)
    {
        LocalFree(lpFileList);
        lpFileList = NULL;
    }
    return hr;
}

void FillBackupInfo(LPCSTR lpINIFile, FILELIST *pFileList)
{
    char szLine[MAX_STR_LEN];
    char szValue[MAX_PATH];

    pFileList->dwDatOffset = (DWORD)-1;
    pFileList->dwRefCount = (DWORD)-1;
    if (GetPrivateProfileString(c_szIE4SECTIONNAME, pFileList->name, "", szLine, sizeof(szLine), lpINIFile) != 0)
    {
        if (GetFieldString(szLine, 0, szValue, sizeof(szValue)))  // For the Attribute
            pFileList->bak_attribute = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

        if (pFileList->bak_attribute != (DWORD)NO_FILE)
        {
            pFileList->bak_exists = 1;
            if (GetFieldString(szLine, 1, szValue, sizeof(szValue)))  // For the size
                pFileList->dwSize = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

            if (GetFieldString(szLine, 2, szValue, sizeof(szValue)))  // For the time/date
                pFileList->FileTime.dwLowDateTime = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

            if (GetFieldString(szLine, 3, szValue, sizeof(szValue)))  // For the time/date
                pFileList->FileTime.dwHighDateTime = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

            if (GetFieldString(szLine, 4, szValue, sizeof(szValue)))  // For the Offset
                pFileList->dwDatOffset = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

            if (GetFieldString(szLine, 5, szValue, sizeof(szValue)))  // For the CRC
                pFileList->dwFileCRC = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);

            if (GetFieldString(szLine, 6, szValue, sizeof(szValue)))  // For the CRC
                pFileList->dwRefCount = (DWORD)Mystrtoul((const char*)szValue, NULL, 16);
        }
        else
            pFileList->bak_exists = 0;

    }
    else
        pFileList->bak_exists = 0;

    return;
}

BOOL MakeBakName(LPSTR lpszName, LPSTR szBakName)
{
static int iNum = 0;
   BOOL bOK = FALSE;
   LPSTR lpTmp;
   char szFilename[14];

   lstrcpy(szBakName, lpszName);
   lpTmp = CharPrev( szBakName, szBakName+lstrlen(szBakName));

   // chop filename off
   //
   while ( (lpTmp > szBakName) && *lpTmp && (*lpTmp != '\\') )
      lpTmp = CharPrev( szBakName, lpTmp );

   if ( *CharPrev( szBakName, lpTmp ) == ':' )
   {
       lpTmp = CharNext(lpTmp) ;
   }
   *lpTmp = '\0';

   while ((iNum < 1000) && !bOK)
   {
        *lpTmp = '\0';
        wsprintf(szFilename, "IEBAK%03d.TMP", iNum++);
        AddPath(szBakName, szFilename);
        bOK = (GetFileAttributes(szBakName) == 0xFFFFFFFF);  // File does not exist, then OK
   }

   if (!bOK)
   {
       // If we could not get a tempfile name with the above methode, try GetTempFileName
       // Retry once, if it does not work fail.
       *lpTmp = '\0';
       CreateFullPath(lpszName, FALSE); // If directory does not exist GetTempFileName() fails.
       bOK = GetTempFileName(szBakName, "IE4", 0, szBakName);
   }
   
   return bOK;
}




// copy files by, adding them to wininit.ini
void initcopy(const char * StfWinDir, char * from, char * to)
{
    char * wininitpath;
    char * wininitname = {"wininit.ini"};
    LPTSTR      lpBuf = NULL;
    LPTSTR      lpTmp;
    static DWORD dwBufSize = MAX_STR_LEN*3;
    DWORD       dwBytes;

    if (ctx.wOSVer == _OSVER_WIN95)
    {
        // 16 is just for padding
        wininitpath = (char*) LocalAlloc(LPTR, lstrlen(StfWinDir) + lstrlen(wininitname) + 2 + 16);
        if (wininitpath)
        {
            lstrcpy(wininitpath, StfWinDir);
            AddPath(wininitpath, wininitname);

            while (TRUE)
            {
                lpBuf = (LPTSTR)LocalAlloc( LPTR, (UINT)dwBufSize );
                if (lpBuf)
                {
                    dwBytes = GetPrivateProfileSection( SEC_RENAME, lpBuf, dwBufSize, wininitname );

                    //The 16 below is just padding (all we probably need is only 3 or so)...
                    if ( (dwBytes >= (dwBufSize - 2)) || (dwBytes+lstrlen(to)+lstrlen(from)+16) > dwBufSize )
                    {
                        // not enough buf size
                        dwBufSize += MAX_STR_LEN;
                        LocalFree( lpBuf );
                    }
                    else
                    {
                        lpTmp = lpBuf+dwBytes;
                        if (lstrcmpi(to, "NUL") == 0)
                            lstrcpy(lpTmp, to);
                        else
                            GetShortPathName( to, lpTmp, (dwBufSize - dwBytes) );
                        lstrcat( lpTmp, "=" );
                        GetShortPathName( from, lpTmp + lstrlen(lpTmp), (dwBufSize - dwBytes - lstrlen(lpTmp)) );

                        // MessageBox(NULL, lpTmp, wininitname, MB_OK);

                        lpTmp += lstrlen(lpTmp);
                        lpTmp++; //jump over the first '\0'
                        *lpTmp = '\0';

                        WritePrivateProfileSection( SEC_RENAME, lpBuf, wininitname );

                        break;
                    }
                }
                else
                    break;
            }

            if (lpBuf)
            {
                LocalFree( lpBuf );
                lpBuf = NULL;
            }

            LocalFree(wininitpath);
        }
    }
    else
    {
        if (lstrcmpi(to, "NUL") == 0)
            MoveFileEx(from, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);    // delete the file
        else
            MoveFileEx(from, to, MOVEFILE_DELAY_UNTIL_REBOOT | MOVEFILE_REPLACE_EXISTING);      // rename the file
    }   
}

BOOL BackupSingleFile(FILELIST * filelist, PBAKDATA pbd)
{
    HANDLE  hFile;
    BOOL    bErr=FALSE;
    DWORD   cbRead;
    DWORD   cbComp;
    LPBYTE  lpBuff;
    LPBYTE  lpBuffComp;
    DWORD   dwFileSig = DAT_FILESIG;
    DWORD   dwOrigDatOffset = pbd->dwDatOffset;
    DWORD   dwBytesWritten = 0;
    DWORD   dwFileSize;
    ULONG      ulCRC = CRC32_INITIAL_VALUE;
    FILETIME   FileTime = {0, 0};
    BOOL    bRet=TRUE;


    cbRead = (DWORD)MAX_IOSIZE;
    lpBuff = LocalAlloc(LPTR, cbRead + 32 ); 
    lpBuffComp = LocalAlloc(LPTR, cbRead + 32);

    if (!lpBuff || !lpBuffComp) 
    {
        bRet=FALSE;
    } 
    else 
    {
        hFile = CreateFile(filelist->name, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile==INVALID_HANDLE_VALUE) 
        {
           bRet=FALSE;
        } 
        else 
        {
            GetFileTime(hFile, NULL, NULL, &FileTime);
            dwFileSize = GetFileSize(hFile, NULL);

            if (!WriteFile(pbd->hDatFile, &dwFileSig, sizeof(dwFileSig), &dwBytesWritten, NULL))
            {
                cbRead = 0;             // prevent the loop from executing
                bRet=FALSE;
            }
            else
                pbd->dwDatOffset += sizeof(dwFileSig);

            while (cbRead == MAX_IOSIZE) 
            {
                if (!ReadFile (hFile, lpBuff, (DWORD)MAX_IOSIZE, &cbRead, NULL))
                {
                    bRet=FALSE;
                    break;
                }
                if (cbRead == 0)        // no more data, time to leave
                    break;

                ulCRC = CRC32Compute(lpBuff, cbRead, ulCRC);
                
                cbComp = Mrci1MaxCompress(lpBuff, cbRead, lpBuffComp, (DWORD)MAX_IOSIZE);
                if ((cbComp == (DWORD) -1) || (cbComp >= cbRead))
                {
                    cbComp = 0;
                }

                // We want to write out lpBuff if cbComp is ZERO, or
                // lpBuffComp is cbComp is NON-ZERO.  In any case, we
                // precede every chunk with two words:  cbRead and cbComp.

                dwFileSig = cbRead | ((DWORD)cbComp << 16);

                if (!WriteFile(pbd->hDatFile, &dwFileSig, sizeof(dwFileSig), &dwBytesWritten, NULL))
                {
                    bRet=FALSE;
                    break;
                }
                pbd->dwDatOffset += sizeof(dwFileSig);

                if (!cbComp) 
                {
                    bErr = !WriteFile(pbd->hDatFile, lpBuff, cbRead, &dwBytesWritten, NULL);
                } 
                else 
                {
                    bErr = !WriteFile(pbd->hDatFile, lpBuffComp, cbComp, &dwBytesWritten, NULL);
                }
                if (bErr) 
                {
                    bRet=FALSE;
                    break;
                }
                pbd->dwDatOffset += dwBytesWritten;
            }

            CloseHandle(hFile);

            // Write out size/date/time etc to ini file
            if (!bErr)
            {
                DosPrintf(pbd, filelist, 
                              dwFileSize,
                              FileTime,
                              dwOrigDatOffset,
                              ulCRC);
            }
        }
    }
    if (lpBuffComp)
        LocalFree(lpBuffComp);

    if (lpBuff)
        LocalFree(lpBuff);

    return bRet;
}

int DosPrintf(PBAKDATA pbd, FILELIST *filelist, DWORD dwFileSize,
              FILETIME FileTime, DWORD dwDatOffset, DWORD dwCRC)
{
    WORD cb;
    char szTmp[MAX_STR_LEN];

    // BUGBUG: if we rewrite the line, we lose the ref count and becomes -1 again.
    // UpdateRefCnt() will not get a chance to increase the count based on the original data.
    //
    cb = (WORD)wsprintf(szTmp, "%lx,%lx,%lx,%lx,%lx,%lx,%d", 
                         filelist->bak_attribute, 
                         dwFileSize,
                         FileTime.dwLowDateTime, 
                         FileTime.dwHighDateTime,
                         dwDatOffset, dwCRC, -1);
    WritePrivateProfileString(c_szIE4SECTIONNAME, filelist->name, szTmp, pbd->szIniFileName);
    return cb;
}

//
// Copied from Windows 95 unistal.exe cfg.c function CfgGetField
BOOL GetFieldString(LPSTR lpszLine, int iField, LPSTR lpszField, int cbSize)
{
    int cbField;
    LPSTR lpszChar, lpszEnd;
    // Find the field we are looking for

    lpszChar = lpszLine;

    // Each time we see a separator, decrement iField
    while (iField > 0 && (BYTE)*lpszChar > CR) {

        if (*lpszChar == '=' || *lpszChar == ',' || *lpszChar == ' ' ) {
            iField--;
            while (*lpszChar == '=' || *lpszChar== ',' || *lpszChar == ' ' && (BYTE)*lpszChar > 13)
                lpszChar++;
        }
        else
            lpszChar++;
    }

    // If we still have fields remaining then something went wrong
    if (iField)
        return FALSE;

    // Now find the end of this field
    lpszEnd = lpszChar;
    while (*lpszEnd != '=' && *lpszEnd != ',' && *lpszEnd != ' ' && (BYTE)*lpszEnd > CR)
        lpszEnd++;

    // Find the length of this field - make sure it'll fit in the buffer
    cbField = (int)((lpszEnd - lpszChar) + 1);

    if (cbField > cbSize) {     // I return an error if the requested
      //cbField = cbSize;       // data won't fit, rather than truncating
        return FALSE;           // it at some random point! -JTP
    }

    // Note that the C runtime treats cbField as the number of characters
    // to copy from the source, and if that doesn't happen to transfer a NULL,
    // too bad.  The Windows implementation of _lstrcpyn treats cbField as
    // the number of characters that can be stored in the destination, and
    // always copies a NULL (even if it means copying only cbField-1 characters
    // from the source).

    // The C runtime also pads the destination with NULLs if a NULL in the
    // source is found before cbField is exhausted.  _lstrcpyn essentially quits
    // after copying a NULL.


    lstrcpyn(lpszField, lpszChar, cbField);

    return TRUE;
}

int RestoreSingleFile(FILELIST *filelist, LPSTR lpszBakFile, HANDLE hDatFile)
{
   LPBYTE lpBuff;
   LPBYTE lpBuffDecomp;
   LPBYTE lpWrite;
   HANDLE   hFile;
   DWORD  dwFileSig;
   DWORD  dwByteRead;
   DWORD  dwByteDecomp;
   DWORD  dwBytesWritten;
   ULONG  ulCRC = CRC32_INITIAL_VALUE;
   int    iErr = OK;
   LONG   lSize = (LONG)filelist->dwSize;
   WORD   wComp;
   WORD   wRead;

   lpBuff = LocalAlloc(LPTR, MAX_IOSIZE);
   lpBuffDecomp = LocalAlloc(LPTR, MAX_IOSIZE);
   if ((lpBuff) && (lpBuffDecomp))
   {

      hFile= CreateFile(lpszBakFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
      if (hFile == INVALID_HANDLE_VALUE)
      {
          CreateFullPathForFile(lpszBakFile);
          hFile= CreateFile(lpszBakFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
      }

      if (hFile != INVALID_HANDLE_VALUE)
      {
         if (SetFilePointer(hDatFile, filelist->dwDatOffset, NULL, FILE_BEGIN) != (DWORD)-1)
         {
            if (ReadFile (hDatFile, (LPVOID)&dwFileSig, (DWORD)sizeof(dwFileSig), &dwByteRead, NULL))
            {
               if (dwFileSig != DAT_FILESIG)
                  iErr = MYERROR_BAD_SIG;
            }
            else
               iErr = MYERROR_READ;

         }
         else
            iErr = MYERROR_UNKNOWN;

         while ((iErr == OK) && (lSize > 0))  
         {
            if (!ReadFile (hDatFile, (LPVOID)&dwFileSig, (DWORD)sizeof(dwFileSig), &dwByteRead, NULL))
            {
               iErr = MYERROR_READ;
               break;
            }

            wComp = (WORD)(dwFileSig >> 16);
            wRead = (WORD)(dwFileSig & 0xffff);
            lpWrite = lpBuff;
            dwByteDecomp = (DWORD)wRead;

            if ((wComp > MAX_IOSIZE) ||  (wRead > MAX_IOSIZE))
            {
               iErr = MYERROR_BAD_DATA;
            }
            else if (wComp == 0)
            {
               if (!ReadFile (hDatFile, lpBuff, wRead, &dwByteDecomp, NULL))
               {
                  iErr = MYERROR_READ;
               }
               
            }
            else 
            {
               lpWrite = lpBuffDecomp;
               if (!ReadFile (hDatFile, lpBuff, wComp, &dwByteRead, NULL))
               {
                  iErr = MYERROR_READ;
               }
               else
               {
                  dwByteDecomp = Mrci1Decompress(lpBuff, wComp, lpBuffDecomp, wRead);
                  if (dwByteDecomp != (DWORD)wRead)
                     iErr = MYERROR_DECOMP_FAILURE;
               }
            }
            if (iErr != OK)
            {
               break;
            }
            ulCRC = CRC32Compute(lpWrite, dwByteDecomp, ulCRC);
            if (!WriteFile(hFile, lpWrite, dwByteDecomp, &dwBytesWritten, NULL))
            {
               iErr = MYERROR_WRITE;
               break;
            }
            lSize -= (LONG)dwBytesWritten;
         } // while

         SetFileTime(hFile, NULL, NULL, &filelist->FileTime);
         CloseHandle(hFile);

         if (ulCRC != filelist->dwFileCRC)
         {
            iErr = MYERROR_BAD_CRC;
         }

         if (iErr != OK)
         {
            DeleteFile(lpszBakFile);
         }
      }
      else
      {
         // Could not create backup file
         iErr = MYERROR_BAD_BAK;
      }
   }
   else
   {
      // Alloc failed
      iErr = MYERROR_OUTOFMEMORY;
   }

   if (lpBuff)
      LocalFree(lpBuff);
   if (lpBuffDecomp)
      LocalFree(lpBuffDecomp);

   return iErr;
}



#define IsSpace(c)              ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')

/* flag values */
#define FL_UNSIGNED   1       /* strtoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


unsigned long Mystrtoxl (
        const char *nptr,
        const char **endptr,
        int ibase,
        int flags
        )
{
        const char *p;
        char c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;

        p = nptr;                       /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read char */
        while ( IsSpace((int)(unsigned char)c) )
                c = *p++;               /* skip whitespace */

        if (c == '-') {
                flags |= FL_NEG;        /* remember minus sign */
                c = *p++;
        }
        else if (c == '+')
                c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
                /* bad base! */
                if (endptr)
                        /* store beginning of string in endptr */
                        *endptr = nptr;
                return 0L;              /* return 0 */
        }
        else if (ibase == 0) {
                /* determine base free-lance, based on first two chars of
                   string */
                if (c != '0')
                        ibase = 10;
                else if (*p == 'x' || *p == 'X')
                        ibase = 16;
                else
                        ibase = 8;
        }

        if (ibase == 16) {
                /* we might have 0x in front of number; remove if there */
                if (c == '0' && (*p == 'x' || *p == 'X')) {
                        ++p;
                        c = *p++;       /* advance past prefix */
                }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) {      /* exit in middle of loop */
                /* convert c to value */
                if ( c >= '0' && c <= '9' ) // isdigit
                        digval = c - '0';
                else if ( ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ))
                    // if ( isalpha((int)(unsigned char)c) )
                        digval = (unsigned)(ULONG_PTR)CharUpper((LPSTR)c) - 'A' + 10;
                else
                        break;
                if (digval >= (unsigned)ibase)
                        break;          /* exit loop if bad digit found */

                /* record the fact we have read one digit */
                flags |= FL_READDIGIT;

                /* we now need to compute number = number * base + digval,
                   but we need to know if overflow occured.  This requires
                   a tricky pre-check. */

                if (number < maxval || (number == maxval &&
                (unsigned long)digval <= ULONG_MAX % ibase)) {
                        /* we won't overflow, go ahead and multiply */
                        number = number * ibase + digval;
                }
                else {
                        /* we would have overflowed -- set the overflow flag */
                        flags |= FL_OVERFLOW;
                }

                c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
                /* no number there; return 0 and point to beginning of
                   string */
                if (endptr)
                        /* store beginning of string in endptr later on */
                        p = nptr;
                number = 0L;            /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
                  ( !(flags & FL_UNSIGNED) &&
                    ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                      ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
                /* overflow or signed overflow occurred */
                //errno = 34;     // 34 is the define of ERANGE from errno.h
                if ( flags & FL_UNSIGNED )
                        number = ULONG_MAX;
                else if ( flags & FL_NEG )
                        number = (unsigned long)(-LONG_MIN);
                else
                        number = LONG_MAX;
        }

        if (endptr != NULL)
                /* store pointer to char that stopped the scan */
                *endptr = p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned long)(-(long)number);

        return number;                  /* done. */
}

unsigned long Mystrtoul (
        const char *nptr,
        char **endptr,
        int ibase
        )
{
    return Mystrtoxl(nptr, endptr, ibase, FL_UNSIGNED);
}


BOOL CALLBACK SaveRestoreProgressDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM  lParam)
{
    switch( uMsg )
    {
        case WM_INITDIALOG:
            ShowWindow(GetDlgItem(hwndDlg, IDS_SAVEINFO_TEXT), lParam? SW_SHOW : SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDS_RESTOREINFO_TEXT), lParam? SW_HIDE : SW_SHOW );
            CenterWindow( hwndDlg, GetDesktopWindow());
            ShowWindow(hwndDlg, SW_SHOWNORMAL);
            break;
                    
        default:                            // For MSG switch
            return(FALSE);
    }
    return(TRUE);
}

//
// Creates the path for the full qualified file name.
// We have to get rid of the filename first, before we
// can attempt to create the path.
void CreateFullPathForFile(LPSTR lpszBakFile)
{
    char szDir[MAX_PATH];
    lstrcpy(szDir, lpszBakFile);
    GetParentDir(szDir);
    CreateFullPath(szDir, FALSE);
}


void GetListFromIniFile(LPSTR lpDir, LPSTR lpBaseName, LPSTR *lplpFileList)
{
    char szINI[MAX_PATH];
    WIN32_FIND_DATA FindFileData;
    HANDLE  hFind;
    LPSTR   lpTmp;

    BuildPath(szINI, lpDir, lpBaseName);
    lstrcat(szINI, c_szExtINI);
    if ((hFind = FindFirstFile(szINI, &FindFileData)) != INVALID_HANDLE_VALUE)
    {
        if (lpTmp = LocalAlloc(LPTR, FindFileData.nFileSizeLow))
        {
            GetPrivateProfileString(c_szIE4SECTIONNAME, NULL, "", lpTmp, FindFileData.nFileSizeLow, szINI);
            if (*lpTmp)
            {
                *lplpFileList = lpTmp;
            }
            else
                LocalFree(lpTmp);   // Nothing found in the INI file
        }
        FindClose(hFind);
    }

}


HRESULT AddDelBackupEntryHelper(LPCSTR lpcszFileList, LPCSTR lpcszBackupDir, LPCSTR lpcszBaseName, DWORD dwFlags)
{
    HRESULT  hr = S_OK;
    LPCSTR   lpcszFile;
    char     szIniFileName[MAX_PATH];

    if ((lpcszFileList) && (*lpcszFileList))
    {
        BuildPath(szIniFileName, lpcszBackupDir, lpcszBaseName);
        lstrcat(szIniFileName, c_szExtINI);
        SetFileAttributes(szIniFileName, FILE_ATTRIBUTE_NORMAL);
        lpcszFile = lpcszFileList;
        while (*lpcszFile)
        {
            WritePrivateProfileString(c_szIE4SECTIONNAME, lpcszFile, (dwFlags & AADBE_ADD_ENTRY) ? c_szNoFileLine : NULL, szIniFileName);
            lpcszFile += lstrlen(lpcszFile) + 1;
        }
        WritePrivateProfileString(NULL, NULL, NULL, szIniFileName);         // flush the INI file
        SetFileAttributes(szIniFileName, FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_READONLY);
    }
    return hr;
}


HRESULT WINAPI FileSaveMarkNotExist( LPSTR lpFileList, LPSTR lpDir, LPSTR lpBaseName)
{
    return AddDelBackupEntryHelper(lpFileList, lpDir, lpBaseName, AADBE_ADD_ENTRY);
}


HRESULT WINAPI AddDelBackupEntry(LPCSTR lpcszFileList, LPCSTR lpcszBackupDir, LPCSTR lpcszBaseName, DWORD dwFlags)
{
    return AddDelBackupEntryHelper(lpcszFileList, lpcszBackupDir, lpcszBaseName, dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\crc32.h ===
#ifndef _CRC32_H_
#define _CRC32_H_

#ifndef INLINE
#define INLINE __inline
#endif

extern const ULONG CrcTable32[ 256 ];     // defined in crctable.c

VOID GenerateCrc32Table( VOID );          // stubbed in crctable.c, but not used
                                          // (exists for compatibility)

ULONG
INLINE
Crc32(
    IN ULONG InitialCrc,
    IN PVOID Buffer,
    IN ULONG ByteCount
    )
    {

#ifdef _X86_

    __asm {

            mov     ecx, ByteCount          ; number of bytes in buffer
            xor     ebx, ebx                ; ebx (bl) will be our table index
            mov     esi, Buffer             ; buffer pointer
            test    ecx, ecx                ; test for zero length buffer
            mov     eax, InitialCrc         ; CRC-32 value

            jnz     short loopentry         ; if non-zero buffer, start loop
            jmp     short exitfunc          ; else exit (crc already in eax)

looptop:    shr     eax, 8                  ; (crc>>8)                      (U1)
            mov     edx, CrcTable32[ebx*4]  ; fetch Table[ index ]          (V1)

            xor     eax, edx                ; crc=(crc>>8)^Table[index]     (U1)
loopentry:  mov     bl, [esi]               ; fetch next *buffer            (V1)

            inc     esi                     ; buffer++                      (U1)
            xor     bl, al                  ; index=(byte)crc^*buffer       (V1)

            dec     ecx                     ; adjust counter                (U1)
            jnz     short looptop           ; loop while nBytes             (V1)

            shr     eax, 8                  ; remaining math on last byte
            xor     eax, CrcTable32[ebx*4]  ; eax returns new crc value

exitfunc:

        }

#else // ! _X86_

    ULONG Value = InitialCrc;
    ULONG Count = ByteCount;
    PUCHAR p    = Buffer;

    while ( Count-- ) {
        Value = ( Value >> 8 ) ^ CrcTable32[ (UCHAR)( *p++ ^ Value ) ];
        }

    return Value;

#endif // ! _X86_

    }

#endif // _CRC32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpack\w95pub32.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* W95PUB16.H - Public interface to W95INF16.DLL.                          *
//*                                                                         *
//***************************************************************************

#ifndef _W95PUB16_H_
#define _W95PUB16_H_

static const TCHAR achCTLSETLDDPATH32[]                 = "CtlSetLddPath32@8";
static const TCHAR achGENINSTALL32[]                    = "GenInstall32@20";
static const TCHAR achGETSETUPXERRORTEXT32[]            = "GetSETUPXErrorText32@12";
static const TCHAR achGENFORMSTRWITHOUTPLACEHOLDERS32[] = "GenFormStrWithoutPlaceHolders32@12";

typedef VOID (WINAPI *GETSETUPXERRORTEXT32)( DWORD, LPSTR, DWORD);
typedef WORD (WINAPI *CTLSETLDDPATH32)(UINT, LPSTR);
typedef WORD (WINAPI *GENINSTALL32)(LPSTR, LPSTR, LPSTR, DWORD, DWORD);
typedef BOOL (WINAPI *GENFORMSTRWITHOUTPLACEHOLDERS32)(LPSTR, LPSTR, LPSTR);

#endif // _W95PUB16_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\advpext.h ===
#include <setupapi.h>

#ifndef _ADVEXT
#define _ADVEXT


typedef struct _DOWNLOAD_FILEINFO DOWNLOAD_FILEINFO;
typedef DOWNLOAD_FILEINFO* PDOWNLOAD_FILEINFO;

struct _DOWNLOAD_FILEINFO 
{
    LPTSTR lpszFileNameToDownload;
    LPTSTR lpszExistingFileToPatchFrom;     
    LPTSTR lpszExistingFilePatchSignature;  
    DWORD  dwFlags;							
};

typedef struct _DOWNLOAD_INFO 
{
    DWORD dwFilesToDownload;
    DWORD dwFilesRemaining;
    DWORD dwBytesToDownload;
    DWORD dwBytesRemaining;
}DOWNLOAD_INFO, *PDOWNLOAD_INFO;


enum PATCH_DOWNLOAD_REASON 
{
    PATCH_DOWNLOAD_BEGIN,          
    PATCH_DOWNLOAD_FINDINGSITE,          
    PATCH_DOWNLOAD_CONNECTING,          
    PATCH_DOWNLOAD_DOWNLOADINGDATA,          
    PATCH_DOWNLOAD_ENDDOWNLOADINGDATA,          
    PATCH_DOWNLOAD_PROGRESS,            // AdditionalInfo is _DOWNLOAD_INFO
    PATCH_DOWNLOAD_FILE_COMPLETED,      // AdditionalInfo is _DOWNLOAD_FILEINFO
    PATCH_DOWNLOAD_FILE_FAILED,         // AdditionalInfo is _DOWNLOAD_FILEINFO
    PATCH_DOWNLOAD_ABORT  
};


#define PATCH_DOWNLOAD_FLAG_CONTINUE            0x00000001
#define PATCH_DOWNLOAD_FLAG_RETRY               0x00010000
#define PATCH_DOWNLOAD_FLAG_FAILED              0x00020000
#define PATCH_DOWNLOAD_FLAG_HASH_INCORRECT      0x00100000


typedef BOOL (WINAPI * PATCH_DOWNLOAD_CALLBACK)(PATCH_DOWNLOAD_REASON Reason, PVOID AdditionalInfo, PVOID CallBackContext);


HRESULT WINAPI ProcessFileSection(HINF hInf, HWND hWnd, BOOL fQuietMode, LPCSTR lpszSection, 
                                  LPCSTR lpszSrcDir, PATCH_DOWNLOAD_CALLBACK pfn, LPVOID lpvContext);

HRESULT WINAPI GetFileList(HINF hInf, LPCSTR lpszSection, PDOWNLOAD_FILEINFO* pFileList, DWORD* pdwFileCount);

HRESULT WINAPI DownloadAndPatchFiles(DWORD dwFileCount, DOWNLOAD_FILEINFO* pFileInfo,  LPCSTR SourceURLs,  
								LPCSTR   lpszPath, PATCH_DOWNLOAD_CALLBACK  pfnCallback, LPVOID lpvContext); 


BOOL WINAPI PatchCallback(PATCH_DOWNLOAD_REASON Reason, PVOID AdditionalInfo, PVOID CallBackContext);

int WINAPI CompareHashID(LPCTSTR lpszFile, LPCTSTR lpszHash);

HRESULT PrepareInstallDirectory(HINF hInf, LPCSTR lpszSection);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\download.h ===
#include <wininet.h>
#include <urlmon.h>

#ifndef _DOWNLOAD
#define _DOWNLOAD

class CDownloader
        : public IBindStatusCallback,
          public IAuthenticate,
          public IHttpNegotiate
   
{
   public:
      CDownloader();
      ~CDownloader();
    
      HRESULT DoDownload(LPCSTR pszUrl, LPCSTR szFilename);
      HRESULT Abort();

      
      STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
      STDMETHOD_(ULONG, AddRef)();
      STDMETHOD_(ULONG, Release)();

      STDMETHOD(OnStartBinding)(
            /* [in] */ DWORD grfBSCOption,
            /* [in] */ IBinding *pib);

      STDMETHOD(GetPriority)(
            /* [out] */ LONG *pnPriority);

      STDMETHOD(OnLowResource)(
            /* [in] */ DWORD reserved);

      STDMETHOD(OnProgress)(
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);

      STDMETHOD(OnStopBinding)(
            /* [in] */ HRESULT hresult,
            /* [in] */ LPCWSTR szError);

      STDMETHOD(GetBindInfo)(
            /* [out] */ DWORD *grfBINDINFOF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);

      STDMETHOD(OnDataAvailable)(
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);

      STDMETHOD(OnObjectAvailable)(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);

              // IAuthenticate methods
      STDMETHOD(Authenticate)(HWND *phwnd,
                              LPWSTR *pszUserName, LPWSTR *pszPassword);

      //IHttpNegotiate methods
              
      STDMETHODIMP BeginningTransaction(LPCWSTR  szURL,  LPCWSTR  szHeaders, DWORD  dwReserved,
                                        LPWSTR * pszAdditionalHeaders);

        
      STDMETHODIMP OnResponse(DWORD  dwResponseCode, LPCWSTR  szResponseHeaders, LPCWSTR  szRequestHeaders, 
                                    LPWSTR * pszAdditionalResquestHeaders);


   protected:
      IBinding            *_pBnd;
      DWORD                _cRef;
      IStream             *_pStm;
      BOOL                 _fTimeout;
      BOOL                 _fTimeoutValid;
      HANDLE               _hFile;
      HANDLE               _hDL;
      HRESULT              _hDLResult;
      UINT                 _uTickCount;
};


HRESULT GetAMoniker( LPOLESTR url, IMoniker ** ppmkr );

typedef struct _SITEINFO SITEINFO;
struct _SITEINFO
{
    LPTSTR lpszUrl;
    LPTSTR lpszSiteName;
    SITEINFO* pNextSite;
};

class CSiteMgr
{

    SITEINFO* m_pSites;
    SITEINFO* m_pCurrentSite;
    char m_szLang[10];
    HRESULT ParseSitesFile(LPTSTR);
    BOOL ParseAndAllocateDownloadSite(LPTSTR);

public:
    CSiteMgr();
    ~CSiteMgr();
    BOOL GetNextSite(LPTSTR* lpszUrl, LPTSTR* lpszName);
    HRESULT Initialize(LPCTSTR);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\crctable.c ===
const unsigned long CrcTable32[ 256 ] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };

void GenerateCrc32Table( void ) {}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\advpext.cpp ===
// advpext.cpp : Defines the entry point for the DLL application.
//
#include <windows.h>
#include <wininet.h>
#include "util.h"
#include "download.h"
#include "patchapi.h"
#include "resource.h"
#include "patchdownload.h"
#include "sdsutils.h"



#define FILECOUNT                    50

PDOWNLOAD_FILEINFO g_pDownloadFileList = NULL;
DWORD g_dwFileCount = 0;
DWORD g_dwArraySize = 0;

HRESULT g_hResult;
HINF g_hInf;
BOOL g_fPreparingDir;
BOOL g_QuietMode = FALSE;
BOOL g_fAbort = FALSE;
HWND g_hProgressDlg = NULL;
HINSTANCE g_hInstance;
HINSTANCE g_hSetupLibrary = NULL;

PFSetupDefaultQueueCallback       pfSetupDefaultQueueCallback       = NULL;
PFSetupInstallFromInfSection      pfSetupInstallFromInfSection      = NULL;
PFSetupInitDefaultQueueCallbackEx pfSetupInitDefaultQueueCallbackEx = NULL;
PFSetupTermDefaultQueueCallback   pfSetupTermDefaultQueueCallback   = NULL;
PFSetupGetLineText                pfSetupGetLineText                = NULL;
PFSetupFindFirstLine              pfSetupFindFirstLine              = NULL;
PFSetupFindNextLine               pfSetupFindNextLine               = NULL;
PFSetupGetStringField             pfSetupGetStringField             = NULL;
PFSetupDecompressOrCopyFile       pfSetupDecompressOrCopyFile       = NULL;




BOOL APIENTRY DllMain( HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    if(DLL_PROCESS_ATTACH == ul_reason_for_call)
    {
        InitLogFile();
        g_hInstance = (HINSTANCE)hModule;
    }

    if(DLL_PROCESS_DETACH == ul_reason_for_call)
    {
        if(g_hLogFile)
            CloseHandle(g_hLogFile);
        if(g_hSetupLibrary)
            FreeLibrary(g_hSetupLibrary);
    }

    return TRUE;
}



HRESULT WINAPI ProcessFileSection(HINF hInf, HWND hWnd, BOOL fQuietMode, LPCSTR lpszSection, LPCSTR lpszSourceDir,
                                  PATCH_DOWNLOAD_CALLBACK pfn, LPVOID lpvContext)
{
    HRESULT hr = S_OK;
    PDOWNLOAD_FILEINFO pFileList = NULL;
    char szUserName[MAX_PATH] = "", szPassword[MAX_PATH] = "", szUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR szSrcDir[MAX_PATH];
    DWORD dwFileCount=0;


    WriteToLog("ProcessFileSection: InfHandle= %1!lx!, Source Directory = %2\n", hInf, lpszSourceDir);
    g_hInf = hInf;
    g_fPreparingDir = FALSE;

    if(fQuietMode)
    {
        g_QuietMode = TRUE;
    }


    if(!g_QuietMode)
    {
        g_hProgressDlg = CreateDialog(g_hInstance, MAKEINTRESOURCE(IDD_PROGRESSDLG), hWnd, (DLGPROC)ProgressDlgProc);
        if (g_hProgressDlg)
        {
            ShowWindow(g_hProgressDlg, SW_SHOWNORMAL);
            UpdateWindow(g_hProgressDlg);
        }
    }

    SetProgressText(IDS_FILELIST);
    hr = GetFileList(hInf, lpszSection, &pFileList, &dwFileCount);
    if(FAILED(hr))
    {
        goto done;
    }

    if(dwFileCount)
    {
        if(!pfSetupGetLineText(NULL, hInf, lpszSection, "Url", szUrl, sizeof(szUrl), NULL))
        {
            hr = HRESULT_FROM_SETUPAPI(GetLastError());
            goto done;
        }

        hr = DownloadAndPatchFiles(dwFileCount, pFileList, szUrl, lpszSourceDir, pfn, lpvContext); 

        if(FAILED(hr) || g_fAbort)
        {
            goto done;
        }
    }

    hr = PrepareInstallDirectory(hInf, lpszSection);

        
done:

    if(pFileList)
    {
        FreeFileList(pFileList);
    }

    if(g_hProgressDlg)
    {
        DestroyWindow(g_hProgressDlg);
    }
    return hr;

}

HRESULT WINAPI GetFileList(HINF hInf, LPCSTR lpszSection, PDOWNLOAD_FILEINFO* pFileList, DWORD* pdwFileCount)
{
    
    HRESULT hr = LoadSetupAPIFuncs();
    if(FAILED(hr))
    {
        return hr;
    }

    WriteToLog("\nGetting the list of files\n");
    g_hResult = S_OK;
    //initially we allocate around 50 entries. We reallocate as and when needed
    g_dwArraySize = FILECOUNT;
    g_pDownloadFileList = (PDOWNLOAD_FILEINFO)ResizeBuffer(NULL, FILECOUNT*sizeof(DOWNLOAD_FILEINFO), FALSE);
    
    if(!g_pDownloadFileList)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    g_dwFileCount = 0;


    PVOID pContext = pfSetupInitDefaultQueueCallbackEx( NULL, (HWND)INVALID_HANDLE_VALUE, 0, 0, NULL );

    if ( pContext == INVALID_HANDLE_VALUE ) 
    {
        return HRESULT_FROM_SETUPAPI(GetLastError());
    }

    WriteToLog("Adding the Following Files\n");
    if (!pfSetupInstallFromInfSection( NULL, hInf, lpszSection, SPINST_FILES, NULL,
                                        NULL, SP_COPY_NEWER, (PSP_FILE_CALLBACK)MyFileQueueCallback, 
                                        pContext, NULL, NULL ) )
    {
        pfSetupTermDefaultQueueCallback( pContext );
        return HRESULT_FROM_SETUPAPI(GetLastError());
    }

    pfSetupTermDefaultQueueCallback( pContext );

    if(SUCCEEDED(g_hResult))
    {
        *pFileList = g_pDownloadFileList;
        *pdwFileCount = g_dwFileCount;
    }

    return g_hResult;
}



UINT WINAPI MyFileQueueCallback( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 )
{       
    UINT retVal = FILEOP_SKIP;

    switch(Notification)
    {
        case SPFILENOTIFY_STARTDELETE:
        case SPFILENOTIFY_STARTRENAME:
        case SPFILENOTIFY_COPYERROR:
        case SPFILENOTIFY_DELETEERROR:
        case SPFILENOTIFY_RENAMEERROR:
            break;

        case SPFILENOTIFY_STARTCOPY:
            {
                FILEPATHS *pFilePath;

                pFilePath = (FILEPATHS *)parm1;                            
                
                if (!MyFileSize(pFilePath->Source)) 
                {
                    DeleteFile(pFilePath->Source);

                    //If we are preparing the dir for installaion then copy the file to the current path.
                    //else we are in download mode, add it to the file list if required
                    if(g_fPreparingDir)
                    {

                        if(CopyFile(pFilePath->Target, pFilePath->Source, TRUE))
                            WriteToLog("Copying %1 file to %2\n", pFilePath->Target, pFilePath->Source);
                    }
                    else
                    {
                        //Check in the version in inf to see if we need to download
                        if(IsDownloadedNeeded(pFilePath->Source, pFilePath->Target))
                            AddToFileList(pFilePath->Source, pFilePath->Target);
                    }
                }

            }
            break;

        case SPFILENOTIFY_NEEDMEDIA:
            {
                char szFileName[MAX_PATH];
                PSOURCE_MEDIA psrcMed;

                psrcMed = (PSOURCE_MEDIA)parm1;
                wsprintf(szFileName, "%s\\%s", psrcMed->SourcePath, psrcMed->SourceFile);
                
                if(GetFileAttributes(szFileName) == 0xFFFFFFFF ) 
                {
                    if(g_fPreparingDir)
                    {
                        if(GetFileAttributes(szFileName) != 0xFFFFFFFF)
                            return retVal;
                    }


                    HANDLE hTempFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, 
                        CREATE_NEW, FILE_ATTRIBUTE_TEMPORARY, NULL );
                    

                    if (hTempFile != INVALID_HANDLE_VALUE)
                    {
                        CloseHandle( hTempFile );                        
                    }
                }


            }

        default:
            return (pfSetupDefaultQueueCallback( Context, Notification, parm1, parm2 ) );
    }

    return( retVal );
}


BOOL IsDownloadedNeeded(LPCTSTR lpszSrcFilePath, LPCTSTR lpszFilePath)
{
    char szVersion[MAX_PATH], szSrcFilePath[MAX_PATH];
    INFCONTEXT InfContext;
    LPTSTR lp;

    LPTSTR lpszSrcName = PathFindFileName(lpszSrcFilePath);


    if (!pfSetupFindFirstLine(g_hInf, "SourceDisksFiles", lpszSrcName, &InfContext ))
    {
        //No SourceDisksFiles entry. Assume that this file needs to be downloaded
        return TRUE;
    }

    DWORD   dwMSVer = 0, dwLSVer = 0, dwMSNewFileVer = 0, dwLSNewFileVer = 0;

    if(pfSetupGetStringField(&InfContext, 4, szVersion, sizeof(szVersion), NULL))
    {
        //Get version of file on the machine
        ConvertVersionStrToDwords(szVersion, &dwMSNewFileVer, &dwLSNewFileVer);    
        MyGetVersionFromFile((LPTSTR)lpszFilePath, &dwMSVer, &dwLSVer, TRUE);
    }

    if(dwMSVer == dwMSNewFileVer && dwLSVer == dwLSNewFileVer)
    {
        TCHAR szHashFromInf[40], szHashFromFile[40];

        if(GetHashidFromINF(lpszSrcName, szHashFromInf, sizeof(szHashFromInf)) && 
           GetFilePatchSignatureA(lpszFilePath, PATCH_OPTION_SIGNATURE_MD5, NULL, 0, 0, 0, 0, 
                                    sizeof(szHashFromFile), szHashFromFile))
        {
            if (lstrcmpi(szHashFromFile, szHashFromInf) == 0 ) 
            {
                return FALSE;
            }                
        }
        
        return TRUE;
    }

    if(dwMSVer < dwMSNewFileVer || ((dwMSVer == dwMSNewFileVer) && dwLSVer < dwLSNewFileVer))
    {
        return TRUE;
    }
    return FALSE;
}

void AddToFileList(LPCSTR lpszSrc, LPCSTR lpszTarget)
{
    TCHAR  Signature[40] = "";  // MD5 is 32 hex characters plus terminator


    if(g_dwFileCount >= g_dwArraySize)
    { 
        g_dwArraySize = g_dwArraySize + FILECOUNT;
        g_pDownloadFileList = (PDOWNLOAD_FILEINFO)ResizeBuffer(g_pDownloadFileList, 
                                        g_dwArraySize*sizeof(DOWNLOAD_FILEINFO), FALSE);
        
        if(!g_pDownloadFileList)
        {
            g_hResult = HRESULT_FROM_WIN32(GetLastError());
            return;
        }
    }


    GetFilePatchSignatureA(lpszTarget, PATCH_OPTION_USE_LZX_BEST, NULL, 0 , 0, 0, 0,
                            sizeof(Signature), Signature);
    if ( *Signature ) 
    {
        g_pDownloadFileList[g_dwFileCount].lpszExistingFilePatchSignature = StrDup(Signature);
    }
    else 
    {
        g_pDownloadFileList[g_dwFileCount].lpszExistingFilePatchSignature = NULL;
    }


    WriteToLog("%1  Destination:%2  Patch Signature:%3\n", PathFindFileName(lpszSrc), lpszTarget, Signature);
    g_pDownloadFileList[g_dwFileCount].lpszFileNameToDownload = StrDup(PathFindFileName(lpszSrc));
    g_pDownloadFileList[g_dwFileCount].lpszExistingFileToPatchFrom = StrDup(lpszTarget);     
    g_pDownloadFileList[g_dwFileCount].dwFlags = PATCHFLAG_DOWNLOAD_NEEDED;							
    g_dwFileCount++;

}

void FreeFileList(PDOWNLOAD_FILEINFO pFileList)
{
    int i = g_dwFileCount;
    while(i--)
    {
        if(pFileList[i].lpszFileNameToDownload)
        {
            LocalFree(pFileList[i].lpszFileNameToDownload);
        }

        if(pFileList[i].lpszExistingFileToPatchFrom)
        {
            LocalFree(pFileList[i].lpszExistingFileToPatchFrom);
        }

        if(pFileList[i].lpszExistingFilePatchSignature)
        {
            LocalFree(pFileList[i].lpszExistingFilePatchSignature);
        }
    }
    ResizeBuffer(pFileList, 0, 0);

}


HRESULT PrepareInstallDirectory(HINF hInf, LPCSTR lpszSection)
{
    g_hResult = S_OK; 
    g_fPreparingDir = TRUE;

    PVOID pContext = pfSetupInitDefaultQueueCallbackEx( NULL, (HWND)INVALID_HANDLE_VALUE, 0, 0, NULL );
    if ( pContext == INVALID_HANDLE_VALUE ) 
    {
        return HRESULT_FROM_SETUPAPI(GetLastError());
    }

    WriteToLog("Copying the Following Files from src dir\n");
    if (!pfSetupInstallFromInfSection( NULL, hInf, lpszSection, SPINST_FILES, NULL,
                                        NULL, SP_COPY_NEWER, (PSP_FILE_CALLBACK)MyFileQueueCallback, 
                                        pContext, NULL, NULL ) )
    {
        pfSetupTermDefaultQueueCallback( pContext );
        return HRESULT_FROM_SETUPAPI(GetLastError());
    }

    pfSetupTermDefaultQueueCallback( pContext );

    return g_hResult;
}


BOOL CALLBACK ProgressDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{

    switch (uMsg)
    {
        case WM_INITDIALOG:
            {
                CenterWindow (hDlg, GetDesktopWindow());
            }

            break;

        case WM_COMMAND:
            if(LOWORD(wParam) == IDCANCEL)
            {
                g_fAbort = TRUE;
            }

        default:
            return(FALSE);
    }
    return(TRUE);
}

BOOL SetProgressText(LPCTSTR lpszText)
{
    if(g_hProgressDlg)
    {
        SetDlgItemText(g_hProgressDlg, IDC_PROGRESSTEXT, lpszText);
    }
    return TRUE;
}

BOOL SetProgressText(UINT uID)
{
    if(g_hProgressDlg)
    {
        TCHAR szBuffer[MAX_PATH];
        LoadString(g_hInstance, uID, szBuffer, sizeof(szBuffer));
        SetDlgItemText(g_hProgressDlg, IDC_PROGRESSTEXT, szBuffer);
    }
    return TRUE;
}

HRESULT LoadSetupAPIFuncs()
{
    static BOOL fSetupLibLoaded = -1;
    HRESULT hr = S_OK;

    if(fSetupLibLoaded != -1)
    {
        return hr;
    }

    g_hSetupLibrary = LoadLibrary("SETUPAPI.DLL");

    if(!g_hSetupLibrary)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        WriteToLog("LoadLibrary for Setuapi.dll failed with error code:%1!lx!\n", hr);
        return hr;
    }


    pfSetupGetStringField             = (PFSetupGetStringField)             GetProcAddress(g_hSetupLibrary, c_szSetupGetStringField );
    pfSetupDefaultQueueCallback       = (PFSetupDefaultQueueCallback)       GetProcAddress(g_hSetupLibrary, c_szSetupDefaultQueueCallback );
    pfSetupInstallFromInfSection      = (PFSetupInstallFromInfSection)      GetProcAddress(g_hSetupLibrary, c_szSetupInstallFromInfSection );
    pfSetupInitDefaultQueueCallbackEx = (PFSetupInitDefaultQueueCallbackEx) GetProcAddress(g_hSetupLibrary, c_szSetupInitDefaultQueueCallbackEx );
    pfSetupTermDefaultQueueCallback   = (PFSetupTermDefaultQueueCallback)   GetProcAddress(g_hSetupLibrary, c_szSetupTermDefaultQueueCallback );
    pfSetupGetLineText                = (PFSetupGetLineText)                GetProcAddress(g_hSetupLibrary, c_szSetupGetLineText );
    pfSetupFindFirstLine              = (PFSetupFindFirstLine)              GetProcAddress(g_hSetupLibrary, c_szSetupFindFirstLine );
    pfSetupFindNextLine               = (PFSetupFindNextLine)               GetProcAddress(g_hSetupLibrary, c_szSetupFindNextLine );
    pfSetupDecompressOrCopyFile       = (PFSetupDecompressOrCopyFile)       GetProcAddress(g_hSetupLibrary, c_szSetupDecompressOrCopyFile );

    if (pfSetupDefaultQueueCallback       == NULL
     || pfSetupInstallFromInfSection      == NULL
     || pfSetupInitDefaultQueueCallbackEx == NULL
     || pfSetupTermDefaultQueueCallback   == NULL
     || pfSetupGetLineText                == NULL
     || pfSetupFindFirstLine              == NULL
     || pfSetupFindNextLine               == NULL
     || pfSetupDecompressOrCopyFile       == NULL
     || pfSetupGetStringField             == NULL )
    {
        return HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
    }

    fSetupLibLoaded = TRUE;
    WriteToLog("Setupapi.dll loaded successfully\n");
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\download.cpp ===
#include <windows.h>
#include "download.h"
#include "util.h"

#define BUFFERSIZE 4096
char g_szBuffer[BUFFERSIZE];

#define TIMEOUT_PERIOD   120


CDownloader::CDownloader()
{
   _pBnd   = NULL;
   _cRef   = 1;
   _pStm   = NULL;
   _hDL    = CreateEvent(NULL, TRUE, FALSE, NULL);
   _hFile  = INVALID_HANDLE_VALUE;
}


CDownloader::~CDownloader()
{
   if(_hDL)
      CloseHandle(_hDL);
}


STDMETHODIMP CDownloader::QueryInterface(const GUID &riid,void **ppv )
{
   *ppv = NULL ;
    if( IsEqualGUID(riid,IID_IUnknown) ) 
    {
        *ppv = (IUnknown *) (IBindStatusCallback *)this;
    } 
    else if (IsEqualGUID(riid,IID_IBindStatusCallback) ) 
    {
        *ppv = (IBindStatusCallback *) this;
    } 
    else if (IsEqualGUID(riid, IID_IAuthenticate))
    {
        *ppv = (IAuthenticate *) this;
    }
    else if (IsEqualGUID(riid,IID_IHttpNegotiate)) 
    {
        *ppv = (IHttpNegotiate*) this;
    } 


    if (*ppv)
    {
        // increment our reference count before we hand out our interface
        ((LPUNKNOWN)*ppv)->AddRef();
        return(NOERROR);
    }

    return( E_NOINTERFACE );
}


STDMETHODIMP_(ULONG) CDownloader::AddRef()
{
   return(++_cRef);
}


STDMETHODIMP_(ULONG) CDownloader::Release()
{
   if(!--_cRef)
   {
      delete this;
      return(0);
   }
   return( _cRef );
}


STDMETHODIMP CDownloader::GetBindInfo( DWORD *grfBINDF, BINDINFO *pbindInfo)
{
   // clear BINDINFO but keep its size
   DWORD cbSize = pbindInfo->cbSize;
   ZeroMemory( pbindInfo, cbSize );
   pbindInfo->cbSize = cbSize;
   
   *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_RESYNCHRONIZE;
   pbindInfo->dwBindVerb = BINDVERB_GET;
   return(NOERROR);
}


STDMETHODIMP CDownloader::OnStartBinding(DWORD /*grfBSCOption*/,IBinding *p)
{
   _pBnd = p;
   _pBnd->AddRef();
   return(NOERROR);
}


STDMETHODIMP CDownloader::GetPriority(LONG *pnPriority)
{
   return(E_NOTIMPL);
}

STDMETHODIMP CDownloader::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pwzStatusText)
{
   return NOERROR;
}

STDMETHODIMP CDownloader::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM *pstgmed)
{
   // bring in major changes here
   HRESULT hr = NOERROR;

   DWORD dwRead = 0;
   DWORD dwReadThisCall = 0;
   DWORD dwWritten = 0;
   
   if(!_pStm)
   {
      _pStm = pstgmed->pstm;
      _pStm->AddRef();
   }
 
   
   // should ignore WAIT_TIMEOUT while getting bytes from urlmon
   _fTimeoutValid = FALSE;

   do
   {
      hr = _pStm->Read(g_szBuffer, BUFFERSIZE, &dwRead);
      if( SUCCEEDED(hr) || ( (hr == E_PENDING) && (dwRead > 0) ) )
      {
         if(_hFile)
            if(!WriteFile(_hFile, g_szBuffer, dwRead, &dwWritten, NULL)) 
            {
               hr = E_FAIL;
               Abort();
            }
      }     
   }  while (hr == NOERROR);

   _uTickCount = 0;
   _fTimeoutValid = TRUE;            // should increment dwTickCount if WAIT_TIMEOUT occurs now
           
	return NOERROR;
}


STDMETHODIMP CDownloader::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
   return(E_NOTIMPL);
}


STDMETHODIMP CDownloader::OnLowResource(DWORD reserved)
{
   _pBnd->Abort();
   return(S_OK);
}

STDMETHODIMP CDownloader::OnStopBinding(HRESULT hrError, LPCWSTR szError)
{
   _fTimeoutValid = FALSE;
  
   if((hrError == E_ABORT) && _fTimeout)
   {
      // This is the timeout case
      _hDLResult = INET_E_CONNECTION_TIMEOUT;
   }
   else
   {
      // this is all other cases
      _hDLResult = hrError;
   }
  
   SetEvent(_hDL);
   return(NOERROR);
}

/* IAuthenticate::Authenticate
*/

STDMETHODIMP CDownloader::Authenticate(HWND *phwnd,
                          LPWSTR *pszUserName, LPWSTR *pszPassword)
{
    if (!phwnd || !pszUserName || !pszPassword)
        return E_POINTER;

    *pszUserName = NULL;
    *pszPassword = NULL;
    *phwnd = GetDesktopWindow() ;

    return S_OK;
}


HRESULT GetAMoniker( LPOLESTR url, IMoniker ** ppmkr )
{
   HRESULT hr = CreateURLMoniker(0,url,ppmkr);
   return( hr );
}


HRESULT CDownloader::DoDownload(LPCSTR pszUrl, LPCSTR lpszFilename)
{
   HRESULT hr = NOERROR;
   BOOL fQuit = FALSE;
   DWORD dwRet;   
      

   if(!pszUrl) return E_INVALIDARG;
   
   WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];
   MultiByteToWideChar(CP_ACP, 0, pszUrl, -1,wszUrl, sizeof(wszUrl)/sizeof(wszUrl[0]));


   IMoniker *ptmpmkr;
   
   hr = GetAMoniker(wszUrl, &ptmpmkr );

   IBindCtx * pBindCtx = 0;

   if( SUCCEEDED(hr) )
   {
      if(SUCCEEDED(::CreateBindCtx(0,&pBindCtx)))
         hr = ::RegisterBindStatusCallback(pBindCtx, (IBindStatusCallback *) this, 0, 0) ;
   }
   
  _fTimeout = FALSE;
  _fTimeoutValid = TRUE;
  _uTickCount = 0;   
  

  if(lpszFilename)
  {
       // Create the file
       _hFile = CreateFile(lpszFilename, GENERIC_READ | GENERIC_WRITE, 0, NULL, 
                     CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);  
   
       if(_hFile == INVALID_HANDLE_VALUE)
          hr = E_FAIL;
  }
    
         
   if( SUCCEEDED(hr) )
      hr = ptmpmkr->BindToStorage(pBindCtx, 0, IID_IStream, (void**)&_pStm );

   // we need this here because it synchronus *FAIL* case, 
   // we Set the event in onstopbinding, but we skip the loop below so it
   // never gets reset.
   // If BindToStorage fails without even sending onstopbinding, we are resetting
   // an unsignalled event, which is OK.
   if(FAILED(hr))
      ResetEvent(_hDL);

   // here we wait for Bind to complete
   //Wait for download event or abort
   while(SUCCEEDED(hr) && !fQuit)
   {
      dwRet = MsgWaitForMultipleObjects(1, &_hDL, FALSE, 1000, QS_ALLINPUT);
      if(dwRet == WAIT_OBJECT_0)
      {
         // Download is finished
         hr = _hDLResult;
         ResetEvent(_hDL);
         break;
      }      
      else if(dwRet == WAIT_TIMEOUT)  // our wait has expired
      {
         if(_fTimeoutValid)
            _uTickCount++;

          // if our tick count is past threshold, abort the download
          // BUGBUG: What about synch. case? We can't time out
          if(_uTickCount >= TIMEOUT_PERIOD)
          {
             _fTimeout = TRUE;
             Abort();
          }
      }  
      else
      {
         MSG msg;
         // read all of the messages in this next loop 
         // removing each message as we read it 
         while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
         { 
             // if it's a quit message we're out of here 
            if (msg.message == WM_QUIT)
               fQuit = TRUE; 
            else
            {
               // otherwise dispatch it 
              DispatchMessage(&msg); 
            } // end of PeekMessage while loop 
         }
      }
   }
   
   // clean up all our stuff
   if(_hFile != INVALID_HANDLE_VALUE)
      CloseHandle(_hFile);

   _hFile = INVALID_HANDLE_VALUE;

   if(_pBnd)
   {
      _pBnd->Release();
      _pBnd = 0;
   }

   
   if(_pStm)
   {
      _pStm->Release();
      _pStm = 0;
   }   

   return hr;
}



HRESULT CDownloader::Abort()
{
   if(_pBnd) 
   {
      _pBnd->Abort();
   }

   return NOERROR;
}

STDMETHODIMP CDownloader::BeginningTransaction(LPCWSTR  szURL,  LPCWSTR  szHeaders, DWORD  dwReserved,
                                        LPWSTR * pszAdditionalHeaders)
{
    return S_OK;
}



STDMETHODIMP CDownloader:: OnResponse(DWORD  dwResponseCode, LPCWSTR  szResponseHeaders, LPCWSTR  szRequestHeaders, 
                                    LPWSTR * pszAdditionalResquestHeaders)
{
    WriteToLog("\nResponse Header\n\n");
    char sz[1024];
    WideCharToMultiByte(CP_ACP, 0, szResponseHeaders, -1, sz, sizeof(sz), NULL, NULL);
    WriteToLog(sz);
    return S_OK;
}


CSiteMgr::CSiteMgr()
{
    m_pSites = NULL;
    m_pCurrentSite = NULL;
}


CSiteMgr::~CSiteMgr()
{
    while(m_pSites)
    {
        SITEINFO* pTemp = m_pSites;
        m_pSites = m_pSites->pNextSite;
        ResizeBuffer(pTemp->lpszUrl, 0, 0);        
        ResizeBuffer(pTemp->lpszSiteName, 0, 0);
        ResizeBuffer(pTemp, 0, 0);       
    }
}


BOOL CSiteMgr::GetNextSite(LPTSTR* lpszUrl, LPTSTR* lpszName)
{
    if(!m_pSites)
        return FALSE;

    if(!m_pCurrentSite)
    {
        m_pCurrentSite = m_pSites;
    }

    *lpszUrl = m_pCurrentSite->lpszUrl;
    *lpszName = m_pCurrentSite->lpszSiteName;
    m_pCurrentSite = m_pCurrentSite->pNextSite;

    return TRUE;
}

HRESULT CSiteMgr::Initialize(LPCTSTR lpszUrl)
{
    CDownloader cdwn;
    TCHAR szFileName[MAX_PATH], szTempPath[MAX_PATH];

    if(!GetTempPath(sizeof(szTempPath), szTempPath))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    GetLanguageString(m_szLang);

    LPTSTR lpszDatUrl = (LPTSTR)ResizeBuffer(NULL, lstrlen(lpszUrl) + 3 + sizeof("PatchSites.dat"), FALSE);
    wsprintf(lpszDatUrl, "%s/PatchSites.dat", lpszUrl);

    CombinePaths(szTempPath, "PatchSites.dat", szFileName);

    WriteToLog("Downloading %1\n", lpszDatUrl);
    HRESULT hr = cdwn.DoDownload(lpszDatUrl, szFileName);

    if(FAILED(hr))
    {
        WriteToLog("Downloading %1 failed with error code:%2!lx!\n", lpszDatUrl, hr);
        DeleteFile(szFileName);
        ResizeBuffer(lpszDatUrl, 0, 0);
        return hr;
    }

    BOOL flag = TRUE;

    hr = ParseSitesFile(szFileName);
    if(hr == E_UNEXPECTED && !m_pSites && flag)
    {
        flag = FALSE;
        lstrcpy(m_szLang, "EN");
        hr = ParseSitesFile(szFileName);
    }

    DeleteFile(szFileName);
    ResizeBuffer(lpszDatUrl, 0, 0);
    return hr;
}

HRESULT CSiteMgr::ParseSitesFile(LPTSTR pszPath)
{       
   DWORD dwSize;
   LPSTR pBuf, pCurrent, pEnd;


   HANDLE hfile = CreateFile(pszPath, GENERIC_READ, 0, NULL, 
                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);  

   if(hfile == INVALID_HANDLE_VALUE)
      return E_FAIL;

   
   dwSize = GetFileSize(hfile, NULL);
   pBuf = (LPSTR)ResizeBuffer(NULL, dwSize + 1, FALSE);

   if(!pBuf)
   {
      CloseHandle(hfile);
      return E_OUTOFMEMORY;
   }
   // Copy contents of file to our buffer
   
   ReadFile(hfile, pBuf, dwSize, &dwSize, NULL);
   
   pCurrent = pBuf;
   pEnd = pBuf + dwSize;
   *pEnd = 0;

   // One pass thru replacing \n or \r with \0
   while(pCurrent <= pEnd)
   {
      if(*pCurrent == '\r' || *pCurrent == '\n')
         *pCurrent = 0;
      pCurrent++;
   }

   pCurrent = pBuf;
   while(1)
   {
      while(pCurrent <= pEnd && *pCurrent == 0)
         pCurrent++;

      // we are now pointing at begginning of line or pCurrent > pBuf
      if(pCurrent > pEnd)
         break;

      ParseAndAllocateDownloadSite(pCurrent);      
      pCurrent += lstrlen(pCurrent);
   }

   ResizeBuffer(pBuf, 0, 0);
   CloseHandle(hfile);

   if(!m_pSites)
      return E_UNEXPECTED;
   else
      return NOERROR;
}


BOOL CSiteMgr::ParseAndAllocateDownloadSite(LPTSTR psz)
{
   char szUrl[1024];
   char szName[256];
   char szlang[256];
   char szregion[256];
   BOOL bQueryTrue = TRUE;

   GetStringField(psz, 0, szUrl, sizeof(szUrl)); 
   GetStringField(psz,1, szName, sizeof(szName));
   GetStringField(psz, 2, szlang, sizeof(szlang));
   GetStringField(psz, 3, szregion, sizeof(szregion));

   if(szUrl[0] == 0 || szName[0] == 0 || szlang[0] == 0 || szregion[0] == 0)
      return NULL;

   if(lstrcmpi(szlang, m_szLang))
   {
       return FALSE;
   }

   SITEINFO* pNewSite = (SITEINFO*) ResizeBuffer(NULL, sizeof(SITEINFO), FALSE);
   pNewSite->lpszSiteName = (LPTSTR) ResizeBuffer(NULL, lstrlen(szName) + 1, FALSE);
   lstrcpy(pNewSite->lpszSiteName, szName);

   pNewSite->lpszUrl = (LPTSTR) ResizeBuffer(NULL, lstrlen(szUrl) + 1, FALSE);
   lstrcpy(pNewSite->lpszUrl, szUrl);

   pNewSite->pNextSite = m_pSites;
   m_pSites = pNewSite;  

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\patchdownload.h ===
#ifndef _PATCHDOWNLOAD
#define _PATCHDOWNLOAD

#include "advpext.h"
#include "download.h"

#define WM_FILEAVAILABLE            WM_USER + 1
#define PATCHFLAG_DOWNLOAD_NEEDED   0x00000001



typedef struct {
    WORD        wOSVer;
    WORD        wQuietMode;
    BOOL        bUpdHlpDlls;
    HINSTANCE   hSetupLibrary;
    BOOL        fOSSupportsINFInstalls;
    LPSTR       lpszTitle;
    HWND        hWnd;
    DWORD       dwSetupEngine;
    BOOL        bCompressed;
    char        szBrowsePath[MAX_PATH];
    HINF        hInf;
    BOOL		bHiveLoaded;
    CHAR		szRegHiveKey[MAX_PATH];
} ADVCONTEXT, *PADVCONTEXT;


HRESULT ProcessFileSection(ADVCONTEXT ctx, LPCSTR lpszSrcDir);


typedef struct _FILE_LIST_INFO 
{
    PDOWNLOAD_FILEINFO          FileList;              //original file list
    DWORD                       FileCount;
    PATCH_DOWNLOAD_CALLBACK     Callback;
    PVOID                       CallbackContext;
}FILE_LIST_INFO, *PFILE_LIST_INFO;


typedef struct _PATCH_THREAD_INFO 
{
    //PATCH_QUEUE              PatchQueue;
    FILE_LIST_INFO           FileListInfo;          //original file list
    DOWNLOAD_INFO*           lpdwnProgressInfo;
    HANDLE                   hFileDownloadEvent;
}PATCH_THREAD_INFO, *PPATCH_THREAD_INFO;


typedef struct _FILE
{
    LPTSTR lpszFileName;
    DWORD  dwFileSize;
} FILE, *LPFILE;


class CPatchDownloader : public CDownloader
{
    DOWNLOAD_FILEINFO*  m_lpFileInfo;
    PATCH_DOWNLOAD_CALLBACK m_lpfnCallback;
    LPTSTR  m_lpszRequestBuffer;
    LPTSTR  m_lpszSiteName;
    TCHAR m_lpszDownLoadDir[MAX_PATH];

    DWORD m_dwFileCount;
    DWORD m_dwServerFileCount;
    DWORD m_dwRequestDataLength;
    DWORD m_dwCurrentFileSize;
    DWORD m_dwCurrFileSizeRemaining;
    DWORD m_dwCurrentFileIndex;
    DWORD m_dwPatchThreadId;

    HANDLE m_hCurrentFileHandle;
    HANDLE m_hSubAllocator;
    
    LPFILE m_lpFileList;
    LPVOID m_lpvContext;
    DOWNLOAD_INFO m_DownloadInfo;


    HRESULT CreateRequestBuffer(DWORD);
    BOOL ProcessDownloadChunk(LPTSTR lpBuffer, DWORD dwLength);

public:
    CPatchDownloader(DOWNLOAD_FILEINFO* pdwn, DWORD dwFileCount, PATCH_DOWNLOAD_CALLBACK lpfn);
    ~CPatchDownloader();
          
    STDMETHOD(GetBindInfo)(/* [out] */ DWORD *grfBINDINFOF,  /* [unique][out][in] */ BINDINFO *pbindinfo);
    
    STDMETHOD(OnProgress)(
        /* [in] */ ULONG ulProgress,
        /* [in] */ ULONG ulProgressMax,
        /* [in] */ ULONG ulStatusCode,
        /* [in] */ LPCWSTR szStatusText);

    STDMETHOD(OnDataAvailable)(
        /* [in] */ DWORD grfBSCF,
        /* [in] */ DWORD dwSize,
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pstgmed);



    HRESULT InternalDownloadAndPatchFiles(LPCTSTR lpszPath, CSiteMgr*, LPVOID lpvContext);
};

DWORD WINAPI PatchThread(IN LPVOID ThreadParam);
BOOL ProtectedPatchDownloadCallback(PATCH_DOWNLOAD_CALLBACK  Callback, IN PATCH_DOWNLOAD_REASON    CallbackReason, 
                                    IN PVOID CallbackData, IN PVOID CallbackContext);

void AddToFileList(LPCSTR lpszSrc, LPCSTR lpszTarget);
UINT WINAPI MyFileQueueCallback( PVOID Context,UINT Notification,UINT_PTR parm1,UINT_PTR parm2 );
void FreeFileList(PDOWNLOAD_FILEINFO pFileList);
HRESULT CreateRequestBuffer(DOWNLOAD_FILEINFO*pFileInfo, DWORD dwFileCount, DWORD dwDownloadClientID, 
                            LPTSTR* lpRequestBuffer, LPDWORD);


BOOL IsDownloadedNeeded(LPCTSTR lp, LPCTSTR lpszFileName);
BOOL CALLBACK ProgressDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
BOOL SetProgressText(LPCTSTR lpszText);
BOOL SetProgressText(UINT uID);
BOOL VerifyHash(LPTSTR lpszFile);
HRESULT LoadSetupAPIFuncs();
HRESULT ApplyPatchesToLocalFiles(DOWNLOAD_FILEINFO* pFileList, DWORD dwFileCount);


static const TCHAR c_szSetupDefaultQueueCallback[]       = "SetupDefaultQueueCallbackA";
static const TCHAR c_szSetupInstallFromInfSection[]      = "SetupInstallFromInfSectionA";
static const TCHAR c_szSetupInitDefaultQueueCallbackEx[] = "SetupInitDefaultQueueCallbackEx";
static const TCHAR c_szSetupTermDefaultQueueCallback[]   = "SetupTermDefaultQueueCallback";
static const TCHAR c_szSetupGetLineText[]                = "SetupGetLineTextA";
static const TCHAR c_szSetupFindFirstLine[]              = "SetupFindFirstLineA";
static const TCHAR c_szSetupFindNextLine[]               = "SetupFindNextLine";
static const TCHAR c_szSetupGetStringField[]             = "SetupGetStringFieldA";
static const TCHAR c_szSetupDecompressOrCopyFile[]       = "SetupDecompressOrCopyFileA";

typedef UINT  (WINAPI *PFSetupDefaultQueueCallback)( PVOID, UINT, UINT_PTR, UINT_PTR );
typedef BOOL  (WINAPI *PFSetupInstallFromInfSection)( HWND, HINF, PCSTR, UINT, HKEY, PCSTR, UINT, PSP_FILE_CALLBACK_A, PVOID, HDEVINFO, PSP_DEVINFO_DATA );
typedef PVOID (WINAPI *PFSetupInitDefaultQueueCallbackEx)( HWND,HWND,UINT,DWORD,PVOID );
typedef VOID  (WINAPI *PFSetupTermDefaultQueueCallback)( PVOID );
typedef BOOL  (WINAPI *PFSetupFindFirstLine)( HINF, PCSTR, PCSTR, PINFCONTEXT );
typedef BOOL  (WINAPI *PFSetupGetLineText)( PINFCONTEXT, HINF, PCSTR, PCSTR, PSTR, DWORD, PDWORD );
typedef BOOL  (WINAPI *PFSetupFindNextLine)( PINFCONTEXT, PINFCONTEXT );
typedef BOOL  (WINAPI *PFSetupGetStringField)(PINFCONTEXT, DWORD, PSTR, DWORD, PDWORD);  
typedef DWORD (WINAPI *PFSetupDecompressOrCopyFile)(PCTSTR, PCTSTR, PUINT);  


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\redblack.c ===
#include <windows.h>
#include "redblack.h"
/*
    redblack.c

    Implementation of red-black binary tree insertion, deletion, and search.
    This algorithm efficiently guarantees that the tree depth will never exceed
    2*Lg(N), so a one million node tree would have a worst case depth of 40.
    This insertion implementation is non-recursive and very efficient (the
    average insertion speed is less than twice the average search speed).

    Author: Tom McGuire (tommcg) 1/98

    Copyright (C) Microsoft, 1998.

    2/98, modified this version of redblack.c for debug symbol lookups.
    8/98, modified this version of redblack.h for generic name table.

*/

//
//  Rather than storing NULL links as NULL, we point NULL links to a special
//  "Empty" node which is always black and its children links point to itself.
//  We do this to simplify the color testing for children and grandchildren
//  such that any link can be dereferenced and even double-dereferenced without
//  explicitly checking for NULL.  The empty node must be colored black.
//

const NAME_NODE NameRbEmptyNode = { RBNIL, RBNIL };

extern PVOID __fastcall SubAllocate(IN HANDLE hAllocator, IN ULONG  Size);

ULONG
__fastcall
NameRbHash(
    IN LPCSTR Name,
    IN ULONG  Length
    )
    {
    ULONG Hash = ~Length;

    while ( Length-- ) {
        Hash = _rotl( Hash, 3 ) ^ *Name++;
        }

    return Hash;
    }


VOID
NameRbInitTree(
    IN OUT PNAME_TREE Tree,
    IN HANDLE SubAllocator
    )
    {
    Tree->Root = RBNIL;
    Tree->SubAllocator = SubAllocator;
    }


PNAME_NODE
NameRbFind(
    IN PNAME_TREE Tree,
    IN LPCSTR Name
    )
    {
    PNAME_NODE Node;
    ULONG      NameLength;
    ULONG      Hash;
    int        Compare;

    NameLength = strlen( Name );

    Hash = NameRbHash( Name, NameLength );

    Node = Tree->Root;

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            Node = Node->Right;
            }
        else {

            //
            //  Hashes equal, switch to strlen
            //

            do  {

                if ( NameLength < Node->NameLength ) {
                    Node = Node->Left;
                    }
                else if ( NameLength > Node->NameLength ) {
                    Node = Node->Right;
                    }
                else {

                    //
                    //  Lengths equal, switch to memcmp
                    //

                    do  {

                        Compare = memcmp( Name, Node->Name, NameLength );

                        if ( Compare == 0 ) {
                            return Node;
                            }
                        else if ( Compare < 0 ) {
                            Node = Node->Left;
                            }
                        else {
                            Node = Node->Right;
                            }
                        }

                    while ( Node != RBNIL );

                    }
                }

            while ( Node != RBNIL );

            }
        }

    return NULL;
    }


PNAME_NODE
NameRbInsert(
    IN OUT PNAME_TREE Tree,
    IN     LPCSTR Name
    )
    {
    PNAME_NODE * Stack[ MAX_DEPTH ];
    PNAME_NODE **StackPointer = Stack;
    PNAME_NODE * Link;
    PNAME_NODE   Node;
    PNAME_NODE   Sibling;
    PNAME_NODE   Parent;
    PNAME_NODE   Child;
    PNAME_NODE   NewNode;
    ULONG        NameLength;
    ULONG        Hash;
    int          Compare;

    NameLength = strlen( Name );

    Hash = NameRbHash( Name, NameLength );

    *StackPointer++ = &Tree->Root;

    Node = Tree->Root;

    //
    //  Walk down the tree to find either an existing node with the same key
    //  (in which case we simply return) or the insertion point for the new
    //  node.  At each traversal we need to store the address of the link to
    //  the next node so we can retrace the traversal path for balancing.
    //  The speed of insertion is highly dependent on traversing the tree
    //  quickly, so all balancing operations are deferred until after the
    //  traversal is complete.
    //

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            *StackPointer++ = &Node->Left;
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            *StackPointer++ = &Node->Right;
            Node = Node->Right;
            }
        else {

            //
            //  Hashes equal, switch to strlen
            //

            do  {

                if ( NameLength < Node->NameLength ) {
                    *StackPointer++ = &Node->Left;
                    Node = Node->Left;
                    }
                else if ( NameLength > Node->NameLength ) {
                    *StackPointer++ = &Node->Right;
                    Node = Node->Right;
                    }
                else {

                    //
                    //  Lengths equal, switch to memcmp
                    //

                    do  {

                        Compare = memcmp( Name, Node->Name, NameLength );

                        if ( Compare == 0 ) {
                            return Node;
                            }
                        else if ( Compare < 0 ) {
                            *StackPointer++ = &Node->Left;
                            Node = Node->Left;
                            }
                        else {
                            *StackPointer++ = &Node->Right;
                            Node = Node->Right;
                            }
                        }

                    while ( Node != RBNIL );

                    }
                }

            while ( Node != RBNIL );

            }
        }


    //
    //  Didn't find a matching entry, so allocate a new node and add it
    //  to the tree.  Note that we're not allocating space for a terminator
    //  for the name data since we store the length of the name in the node.
    //

    NewNode = SubAllocate( Tree->SubAllocator, ( sizeof( NAME_NODE ) + NameLength ));

    if ( NewNode == NULL ) {
        return NULL;
        }

    NewNode->Left  = RBNIL;
    NewNode->Right = RBNIL;
    NewNode->Hash  = Hash;
    NewNode->NameLengthAndColorBit = NameLength | 0x80000000;   // MARK_RED
    memcpy( NewNode->Name, Name, NameLength );

    //
    //  Insert new node under last link we traversed.  The top of the stack
    //  contains the address of the last link we traversed.
    //

    Link = *( --StackPointer );
    *Link = NewNode;

    //
    //  Now walk back up the traversal chain to see if any balancing is
    //  needed.  This terminates in one of three ways: we walk all the way
    //  up to the root (StackPointer == Stack), or find a black node that
    //  we don't need to change (no balancing needs to be done above a
    //  black node), or we perform a balancing rotation (only one necessary).
    //

    Node = NewNode;
    Child = RBNIL;

    while ( StackPointer > Stack ) {

        Link = *( --StackPointer );
        Parent = *Link;

        //
        //  Node is always red here.
        //

        if ( IS_BLACK( Parent )) {

            Sibling = ( Parent->Left == Node ) ? Parent->Right : Parent->Left;

            if ( IS_RED( Sibling )) {

                //
                //  Both Node and its Sibling are red, so change them both to
                //  black and make the Parent red.  This essentially moves the
                //  red link up the tree so balancing can be performed at a
                //  higher level.
                //
                //        Pb                     Pr
                //       /  \       ---->       /  \
                //      Cr  Sr                 Cb  Sb
                //

                MARK_BLACK( Sibling );
                MARK_BLACK( Node );
                MARK_RED( Parent );
                }

            else {

                //
                //  This is a terminal case.  The Parent is black, and it's
                //  not going to be changed to red.  If the Node's child is
                //  red, we perform an appropriate rotation to balance the
                //  tree.  If the Node's child is black, we're done.
                //

                if ( IS_RED( Child )) {

                    if ( Node->Left == Child ) {

                        if ( Parent->Left == Node ) {

                            //
                            //       Pb             Nb
                            //      /  \           /  \
                            //     Nr   Z   to    Cr  Pr
                            //    /  \                / \
                            //   Cr   Y              Y   Z
                            //

                            MARK_RED( Parent );
                            Parent->Left = Node->Right;
                            Node->Right = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            //
                            //       Pb                Cb
                            //      /  \              /  \
                            //     W    Nr    to     Pr   Nr
                            //         /  \         / \   / \
                            //        Cr   Z       W   X Y   Z
                            //       /  \
                            //      X    Y
                            //

                            MARK_RED( Parent );
                            Parent->Right = Child->Left;
                            Child->Left = Parent;
                            Node->Left = Child->Right;
                            Child->Right = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }

                    else {

                        if ( Parent->Right == Node ) {

                            MARK_RED( Parent );
                            Parent->Right = Node->Left;
                            Node->Left = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            MARK_RED( Parent );
                            Parent->Left = Child->Right;
                            Child->Right = Parent;
                            Node->Right = Child->Left;
                            Child->Left = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }
                    }

                return NewNode;
                }
            }

        Child = Node;
        Node = Parent;
        }

    //
    //  We bubbled red up to the root -- restore it to black.
    //

    MARK_BLACK( Tree->Root );
    return NewNode;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\patchapi.h ===
//
//  patchapi.h
//
//  Interface for creating and applying patches to files.
//
//  Copyright (C) Microsoft, 1997-1998.
//

#ifndef _PATCHAPI_H_
#define _PATCHAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following constants can be combined and used as the OptionFlags
//  parameter in the patch creation apis.
//

#define PATCH_OPTION_USE_BEST           0x00000000  // auto choose best (slower)

#define PATCH_OPTION_USE_LZX_BEST       0x00000003  // auto choose best of LZX
#define PATCH_OPTION_USE_LZX_A          0x00000001  // normal
#define PATCH_OPTION_USE_LZX_B          0x00000002  // better on some x86 binaries

#define PATCH_OPTION_NO_BINDFIX         0x00010000  // PE bound imports
#define PATCH_OPTION_NO_LOCKFIX         0x00020000  // PE smashed locks
#define PATCH_OPTION_NO_REBASE          0x00040000  // PE rebased image
#define PATCH_OPTION_FAIL_IF_SAME_FILE  0x00080000  // don't create if same
#define PATCH_OPTION_FAIL_IF_BIGGER     0x00100000  // fail if patch is larger than simply compressing new file (slower)
#define PATCH_OPTION_NO_CHECKSUM        0x00200000  // PE checksum zero
#define PATCH_OPTION_NO_RESTIMEFIX      0x00400000  // PE resource timestamps
#define PATCH_OPTION_NO_TIMESTAMP       0x00800000  // don't store new file timestamp in patch
#define PATCH_OPTION_SIGNATURE_MD5      0x01000000  // use MD5 instead of CRC32
#define PATCH_OPTION_RESERVED1          0x80000000  // (used internally)

#define PATCH_OPTION_VALID_FLAGS        0x80FF0003

#define PATCH_SYMBOL_NO_IMAGEHLP        0x00000001  // don't use imagehlp.dll
#define PATCH_SYMBOL_NO_FAILURES        0x00000002  // don't fail patch due to imagehlp failures
#define PATCH_SYMBOL_UNDECORATED_TOO    0x00000004  // after matching decorated symbols, try to match remaining by undecorated names
#define PATCH_SYMBOL_RESERVED1          0x80000000  // (used internally)


//
//  The following constants can be combined and used as the ApplyOptionFlags
//  parameter in the patch apply and test apis.
//

#define APPLY_OPTION_FAIL_IF_EXACT      0x00000001  // don't copy new file
#define APPLY_OPTION_FAIL_IF_CLOSE      0x00000002  // differ by rebase, bind
#define APPLY_OPTION_TEST_ONLY          0x00000004  // don't create new file
#define APPLY_OPTION_VALID_FLAGS        0x00000007

//
//  In addition to standard Win32 error codes, the following error codes may
//  be returned via GetLastError() when one of the patch APIs fails.
//

#define ERROR_PATCH_ENCODE_FAILURE          0xC00E3101  // create
#define ERROR_PATCH_INVALID_OPTIONS         0xC00E3102  // create
#define ERROR_PATCH_SAME_FILE               0xC00E3103  // create
#define ERROR_PATCH_RETAIN_RANGES_DIFFER    0xC00E3104  // create
#define ERROR_PATCH_BIGGER_THAN_COMPRESSED  0xC00E3105  // create
#define ERROR_PATCH_IMAGEHLP_FAILURE        0xC00E3106  // create

#define ERROR_PATCH_DECODE_FAILURE          0xC00E4101  // apply
#define ERROR_PATCH_CORRUPT                 0xC00E4102  // apply
#define ERROR_PATCH_NEWER_FORMAT            0xC00E4103  // apply
#define ERROR_PATCH_WRONG_FILE              0xC00E4104  // apply
#define ERROR_PATCH_NOT_NECESSARY           0xC00E4105  // apply
#define ERROR_PATCH_NOT_AVAILABLE           0xC00E4106  // apply

typedef BOOL (CALLBACK *PPATCH_PROGRESS_CALLBACK)(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    );

typedef BOOL (CALLBACK *PPATCH_SYMLOAD_CALLBACK)(
    IN ULONG  WhichFile,          // 0 for new file, 1 for first old file, etc
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,            // see SYM_TYPE in imagehlp.h
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    );

typedef struct _PATCH_IGNORE_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    } PATCH_IGNORE_RANGE, *PPATCH_IGNORE_RANGE;

typedef struct _PATCH_RETAIN_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    ULONG OffsetInNewFile;
    } PATCH_RETAIN_RANGE, *PPATCH_RETAIN_RANGE;

typedef struct _PATCH_OLD_FILE_INFO_A {
    ULONG               SizeOfThisStruct;
    LPCSTR              OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_A, *PPATCH_OLD_FILE_INFO_A;

typedef struct _PATCH_OLD_FILE_INFO_W {
    ULONG               SizeOfThisStruct;
    LPCWSTR             OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_W, *PPATCH_OLD_FILE_INFO_W;

typedef struct _PATCH_OLD_FILE_INFO_H {
    ULONG               SizeOfThisStruct;
    HANDLE              OldFileHandle;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_H, *PPATCH_OLD_FILE_INFO_H;

typedef struct _PATCH_OLD_FILE_INFO {
    ULONG               SizeOfThisStruct;
    union {
        LPCSTR          OldFileNameA;
        LPCWSTR         OldFileNameW;
        HANDLE          OldFileHandle;
        };
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO, *PPATCH_OLD_FILE_INFO;

typedef struct _PATCH_OPTION_DATA {
    ULONG                   SizeOfThisStruct;
    ULONG                   SymbolOptionFlags;      // PATCH_SYMBOL_xxx flags
    LPCSTR                  NewFileSymbolPath;      // always ANSI, never Unicode
    LPCSTR                 *OldFileSymbolPathArray; // array[ OldFileCount ]
    ULONG                   ExtendedOptionFlags;
    PPATCH_SYMLOAD_CALLBACK SymLoadCallback;
    PVOID                   SymLoadContext;
    } PATCH_OPTION_DATA, *PPATCH_OPTION_DATA;

//
//  Note that PATCH_OPTION_DATA contains LPCSTR paths, and no LPCWSTR (Unicode)
//  path argument is available, even when used with one of the Unicode APIs
//  such as CreatePatchFileW.  This is because the underlying system services
//  for symbol file handling (IMAGEHLP.DLL) only support ANSI file/path names.
//

//
//  A note about PATCH_RETAIN_RANGE specifiers with multiple old files:
//
//  Each old version file must have the same RetainRangeCount, and the same
//  retain range LengthInBytes and OffsetInNewFile values in the same order.
//  Only the OffsetInOldFile values can differ between old files for retain
//  ranges.
//

#ifdef IMPORTING_PATCHAPI_DLL
#define PATCHAPI WINAPI __declspec( dllimport )
#else
#define PATCHAPI WINAPI
#endif


//
//  The following prototypes are interface for creating patches from files.
//

BOOL
PATCHAPI
CreatePatchFileA(
    IN  LPCSTR OldFileName,
    IN  LPCSTR NewFileName,
    OUT LPCSTR PatchFileName,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileW(
    IN  LPCWSTR OldFileName,
    IN  LPCWSTR NewFileName,
    OUT LPCWSTR PatchFileName,
    IN  ULONG   OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileByHandles(
    IN  HANDLE OldFileHandle,
    IN  HANDLE NewFileHandle,
    OUT HANDLE PatchFileHandle,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileExA(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_A   OldFileInfoArray,
    IN  LPCSTR                   NewFileName,
    OUT LPCSTR                   PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileExW(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_W   OldFileInfoArray,
    IN  LPCWSTR                  NewFileName,
    OUT LPCWSTR                  PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileByHandlesEx(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_H   OldFileInfoArray,
    IN  HANDLE                   NewFileHandle,
    OUT HANDLE                   PatchFileHandle,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileA(
    IN  LPCSTR PatchFileName,
    OUT LPCSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileW(
    IN  LPCWSTR PatchFileName,
    OUT LPCWSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileByHandles(
    IN  HANDLE PatchFileHandle,
    OUT HANDLE PatchHeaderFileHandle
    );

//
//  The following prototypes are interface for creating new file from old file
//  and patch file.  Note that it is possible for the TestApply API to succeed
//  but the actual Apply to fail since the TestApply only verifies that the
//  old file has the correct CRC without actually applying the patch.  The
//  TestApply API only requires the patch header portion of the patch file,
//  but its CRC must be fixed up.
//

BOOL
PATCHAPI
TestApplyPatchToFileA(
    IN LPCSTR PatchFileName,
    IN LPCSTR OldFileName,
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileW(
    IN LPCWSTR PatchFileName,
    IN LPCWSTR OldFileName,
    IN ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileByHandles(
    IN HANDLE PatchFileHandle,      // requires GENERIC_READ access
    IN HANDLE OldFileHandle,        // requires GENERIC_READ access
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileA(
    IN  LPCSTR PatchFileName,
    IN  LPCSTR OldFileName,
    OUT LPCSTR NewFileName,
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileW(
    IN  LPCWSTR PatchFileName,
    IN  LPCWSTR OldFileName,
    OUT LPCWSTR NewFileName,
    IN  ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandles(
    IN  HANDLE PatchFileHandle,     // requires GENERIC_READ access
    IN  HANDLE OldFileHandle,       // requires GENERIC_READ access
    OUT HANDLE NewFileHandle,       // requires GENERIC_READ | GENERIC_WRITE
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileExA(
    IN  LPCSTR                   PatchFileName,
    IN  LPCSTR                   OldFileName,
    OUT LPCSTR                   NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileExW(
    IN  LPCWSTR                  PatchFileName,
    IN  LPCWSTR                  OldFileName,
    OUT LPCWSTR                  NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandlesEx(
    IN  HANDLE                   PatchFileHandle,
    IN  HANDLE                   OldFileHandle,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

//
//  The following prototypes provide a unique patch "signature" for a given
//  file.  Consider the case where you have a new foo.dll and the machines
//  to be updated with the new foo.dll may have one of three different old
//  foo.dll files.  Rather than creating a single large patch file that can
//  update any of the three older foo.dll files, three separate smaller patch
//  files can be created and "named" according to the patch signature of the
//  old file.  Then the patch applyer application can determine at runtime
//  which of the three foo.dll patch files is necessary given the specific
//  foo.dll to be updated.  If patch files are being downloaded over a slow
//  network connection (Internet over a modem), this signature scheme provides
//  a mechanism for choosing the correct single patch file to download at
//  application time thus decreasing total bytes necessary to download.
//

BOOL
GetFilePatchSignatureA(
    IN  LPCSTR FileName,
    IN  ULONG  OptionFlags,
    IN  PVOID  OptionData,
    IN  ULONG  IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG  RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG  SignatureBufferSize,
    OUT PVOID  SignatureBuffer
    );

BOOL
GetFilePatchSignatureW(
    IN  LPCWSTR FileName,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSizeInBytes,
    OUT PVOID   SignatureBuffer
    );

BOOL
GetFilePatchSignatureByHandle(
    IN  HANDLE  FileHandle,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSize,
    OUT PVOID   SignatureBuffer
    );


//
//  Depending on whether UNICODE is defined, map the generic API names to the
//  appropriate Unicode or Ansi APIs.
//

#ifdef UNICODE

    #define CreatePatchFile          CreatePatchFileW
    #define CreatePatchFileEx        CreatePatchFileExW
    #define TestApplyPatchToFile     TestApplyPatchToFileW
    #define ApplyPatchToFile         ApplyPatchToFileW
    #define ApplyPatchToFileEx       ApplyPatchToFileExW
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileW
    #define GetFilePatchSignature    GetFilePatchSignatureW

#else

    #define CreatePatchFile          CreatePatchFileA
    #define CreatePatchFileEx        CreatePatchFileExA
    #define TestApplyPatchToFile     TestApplyPatchToFileA
    #define ApplyPatchToFile         ApplyPatchToFileA
    #define ApplyPatchToFileEx       ApplyPatchToFileExA
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileA
    #define GetFilePatchSignature    GetFilePatchSignatureA

#endif // UNICODE

#ifdef __cplusplus
}
#endif

#endif // _PATCHAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\redblack.h ===
/*
    redblack.h

    Prototypes and node structure definition for red-black binary trees.
    See redblack.c for details and implementation.

    Author: Tom McGuire (tommcg) 1/98

    Copyright (C) Microsoft, 1998.

    2/98, modified this version of redblack.h for debug symbol lookups.
    8/98, modified this version of redblack.h for generic name table.

*/

#ifndef _REDBLACK_H_
#define _REDBLACK_H_

#pragma warning( disable: 4200 )    // zero-sized array in struct/union

typedef struct _NAME_NODE NAME_NODE, *PNAME_NODE;
typedef struct _NAME_TREE NAME_TREE, *PNAME_TREE;

struct _NAME_NODE {
    PNAME_NODE Left;
    PNAME_NODE Right;
    ULONG      Hash;
    union {
      ULONG    NameLengthAndColorBit;
      struct {
        ULONG  NameLength:31;
        ULONG  Red:1;
        };
      };
    PVOID Context;
    CHAR  Name[ 0 ];
    };

struct _NAME_TREE {
    PNAME_NODE Root;
    HANDLE SubAllocator;
    };


#define RBNIL ((PNAME_NODE)&NameRbEmptyNode)

extern const NAME_NODE NameRbEmptyNode;


//
//  Although "Red" can be stored in its own 1-byte or 4-byte field, keeping the
//  nodes smaller by encoding "Red" as a one-bit field with another value
//  provides better performance (more nodes tend to stay in the cache).  To
//  provide flexibility in storage of the RED property, all references to RED
//  and BLACK are made through the following macros which can be changed as
//  necessary:
//

#define IS_RED( Node )            (   (Node)->Red )
#define IS_BLACK( Node )          ( ! (Node)->Red )
#define MARK_RED( Node )          (   (Node)->Red = 1 )
#define MARK_BLACK( Node )        (   (Node)->Red = 0 )

//
//  The maximum tree depth is 2*Lg(N).  Since we could never have more than
//  2^X nodes with X-bit pointers, we can safely say the absolute maximum
//  depth will be 2*Lg(2^X) which is 2*X.  The size of a pointer in bits is
//  its size in bytes times 8 bits, so 2*(sizeof(p)*8) is our maximum depth.
//  So for 32-bit pointers, our maximum depth is 64.
//
//  If you know the maximum possible number of nodes in advance (like the size
//  of the address space divided by the size of a node), you can tweak this
//  value a bit smaller to 2*Lg(N).  Note that it's important for this max
//  depth be evalutated to a constant value at compile time.
//
//  For this implementation, we'll assume the maximum number of nodes is
//  1 million, so the max depth is 40 (2*Lg(2^20)).  Note that no runtime
//  checks are made to ensure we don't exceed this number.
//

#define MAX_DEPTH 40


//
//  The following prototypes are the red-black tree interface.
//

VOID
NameRbInitTree(
    IN OUT PNAME_TREE Tree,
    IN HANDLE SubAllocator
    );

PNAME_NODE
NameRbInsert(
    IN OUT PNAME_TREE Tree,
    IN     LPCSTR Name
    );

PNAME_NODE
NameRbFind(
    IN PNAME_TREE Tree,
    IN LPCSTR Name
    );

#endif // _REDBLACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\patchdownload.cpp ===
#include <windows.h>
#include <urlmon.h>
#include <wininet.h>
#include "resource.h"

#include "advpext.h"
#include "download.h"
#include "patchdownload.h"
#include "util.h"

extern "C"
{
#include "patchapi.h"
#include "redblack.h"
#include "crc32.h"
}

extern HINF g_hInf;
extern HINSTANCE g_hInstance;
extern HWND g_hProgressDlg;
extern BOOL g_fAbort;

HANDLE g_hDownloadProcess = NULL;




HRESULT WINAPI DownloadAndPatchFiles(DWORD dwFileCount, DOWNLOAD_FILEINFO* pFileInfo,  LPCSTR lpszUrl,  
								LPCSTR lpszPath, PATCH_DOWNLOAD_CALLBACK  pfnCallback, LPVOID lpvContext)
{
    HRESULT hr = S_OK;
    CSiteMgr csite;

    hr = LoadSetupAPIFuncs();
    if(FAILED(hr))
    {
        return hr;
    }


    SetProgressText(IDS_INIT);
    //Download the sites.dat file
    hr = csite.Initialize(lpszUrl);
    if(FAILED(hr))
    {
        return hr;
    }

    CPatchDownloader cpdwn(pFileInfo, dwFileCount, pfnCallback);
    return cpdwn.InternalDownloadAndPatchFiles(lpszPath, &csite, lpvContext);
}

HRESULT CPatchDownloader::InternalDownloadAndPatchFiles(LPCTSTR lpszPath, CSiteMgr* pSite, LPVOID lpvContext)
{

    HRESULT hr = S_OK;
    PATCH_THREAD_INFO PatchThreadInfo;
    HANDLE hThreadPatcher = NULL;
    ULONG DownloadClientId = 0;
    int nCount = 0;
    LPTSTR lpszUrl;
    BOOL fUseWin9xDirectory = FALSE;



    if(!GetTempPath(sizeof(m_lpszDownLoadDir), m_lpszDownLoadDir))
    {
        //Unable to get temp folder, Create a folder  in the path sent to us
        wsprintf(m_lpszDownLoadDir, "%s\\%s", lpszPath, "AdvExt");
    }

    //Since the binary is different for NT and 9x, because of binding, we cannot put the files
    //under same directory on server. So for 9x put it under a subdirectory and modify the
    //url accordingly. 

    HKEY hKey;
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);


    if(VER_PLATFORM_WIN32_NT != osvi.dwPlatformId && 
       ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Advanced INF Setup", 0, 
                                                KEY_ALL_ACCESS, &hKey))
    {
        DWORD dwSize = sizeof(DWORD);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, "Usewin9xDirectory", 0, 0, 
                                                (LPBYTE)&fUseWin9xDirectory, &dwSize))
        {
            RegDeleteValue(hKey, "Usewin9xDirectory");
        }

        RegCloseKey(hKey);
    }

    if (DownloadClientId == 0)
    {

        //  Need to generate a unique DownloadClientId for this machine, but
        //  it needs to be consistent (persistent) if same machine downloads
        //  twice, even across process destroy/restart.  First we check the
        //  registry to see if we have previously generated a unique Id for
        //  this machine, and use that if we find it.  Otherwise, we generate
        //  a unique DownloadClientId and store it in the registry so future
        //  instances will use the same value.
        //

        LONG  RegStatus;
        HKEY  hKey;
        DWORD dwHow;
        DWORD dwValueSize;
        DWORD dwValueType;
        DWORD dwValue;

        RegStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                        "SOFTWARE\\Microsoft\\Advanced INF Setup\\AdvExt",
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dwHow
                        );

        if ( RegStatus == ERROR_SUCCESS ) 
        {

            dwValueSize = sizeof(dwValue);
            RegStatus = RegQueryValueEx(hKey, "DownloadClientId",  NULL, &dwValueType, (LPBYTE)&dwValue, &dwValueSize);

            dwValue &= 0xFFFFFFF0;

            if ((RegStatus == ERROR_SUCCESS) && (dwValueType == REG_DWORD) && (dwValue != 0))
            {
                DownloadClientId = dwValue;
            }
            else
            {

                DownloadClientId = GenerateUniqueClientId();
                dwValue = DownloadClientId;

                RegSetValueEx(hKey, "DownloadClientId", 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
            }

            RegCloseKey( hKey );
        }
        else
        {
            //  Failed to open/create registry key, so fall back to just
            //  creating a unique ID for this process instance.  At least
            //  it will show the same client id if the user hits "retry".
            //
            DownloadClientId = GenerateUniqueClientId();
        }
    }

    m_hSubAllocator = CreateSubAllocator(0x10000, 0x10000);
    if(!m_hSubAllocator)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        WriteToLog("Memory allocation failed. Can't do much. Exiting with hr=%1!lx!\n", hr);
        goto done;
    }


    //Set the parameters that needs to be passed on to the thread.
    if(!m_lpfnCallback)
    {
        m_lpfnCallback = PatchCallback;
        m_lpvContext = (LPVOID)lpszPath;
    }
    else
    {
        m_lpvContext = lpvContext;
    }

    PatchThreadInfo.hFileDownloadEvent = _hDL;
    PatchThreadInfo.FileListInfo.FileList = m_lpFileInfo;
    PatchThreadInfo.FileListInfo.FileCount = m_dwFileCount;
    PatchThreadInfo.FileListInfo.Callback = m_lpfnCallback;
    PatchThreadInfo.FileListInfo.CallbackContext = m_lpvContext;

    PatchThreadInfo.lpdwnProgressInfo = &m_DownloadInfo;
        
    m_DownloadInfo.dwFilesRemaining = m_dwFileCount;
    m_DownloadInfo.dwFilesToDownload = m_dwFileCount;
    m_DownloadInfo.dwBytesToDownload = 0;
    m_DownloadInfo.dwBytesRemaining = 0;

    //Create an event to signal patchthread is ready to process download request
    g_hDownloadProcess = CreateEvent(NULL, TRUE, FALSE, NULL);

    if(!g_hDownloadProcess)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        WriteToLog("Create event failed with error code:%1!lx!\n", hr);
        goto done;
    }


    //Do till we have download files or we retry 3 times 
    while(nCount++ < 3 && m_DownloadInfo.dwFilesRemaining && !g_fAbort)
    {
        WriteToLog("\n%1!d! try:  Number of Files:%2!d!\n", nCount, m_DownloadInfo.dwFilesRemaining);
        _hDLResult = 0;

        ResetEvent(g_hDownloadProcess);
        hThreadPatcher = CreateThread(NULL, 0, PatchThread, &PatchThreadInfo, 0, &m_dwPatchThreadId);
        if(!hThreadPatcher)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }

        //Generate the request buffer that would be sent on POST
        hr = CreateRequestBuffer(DownloadClientId);
        if(FAILED(hr))
        {
            WriteToLog("\nCreateRequestBuffer failed with error code:%1!lx!\n", hr);
            goto done;
        } 
        
        //Get the url from where bytes needs to be downloaded.
        if(!pSite->GetNextSite(&lpszUrl, &m_lpszSiteName))
        {
            WriteToLog("GetNextSite returned false. No site info??");
            hr = E_UNEXPECTED;
            goto done;
        }

		TCHAR szURL[INTERNET_MAX_URL_LENGTH];

        if(fUseWin9xDirectory)
        {
			lstrcpy(szURL, lpszUrl);
            if(*(lpszUrl + lstrlen(lpszUrl) - 1) == '/')
            {
                lstrcat(szURL, "win9x");
            }
            else
            {
                lstrcat(szURL, "/win9x");
            }
            lpszUrl = szURL;
        }

        //Notify callback we are about to begin download
        ProtectedPatchDownloadCallback(m_lpfnCallback, PATCH_DOWNLOAD_BEGIN, (LPVOID)lpszUrl, m_lpvContext);
        
        hr = DoDownload(lpszUrl, NULL);
        WriteToLog("DownloadFile returned:%1!lx!\n\n", hr);
        SetProgressText(IDS_CLEANUP);

        //Ask the patch thread to quit once it finishes download.
        SetEvent(_hDL);

        //Wait till patch thread finishes its work
        while(1)
        {
            DWORD dw = MsgWaitForMultipleObjects(1, &hThreadPatcher, FALSE, 1000, QS_ALLINPUT);
            if(dw == WAIT_OBJECT_0)
            {
                break;
            }
                     
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                DispatchMessage(&msg); 
            }
        }

        CloseHandle(hThreadPatcher);
        hThreadPatcher = NULL;
        //Setup the downloadinfo structure, incase we need to re-download some files
        m_DownloadInfo.dwFilesToDownload = m_DownloadInfo.dwFilesRemaining;
        m_DownloadInfo.dwBytesToDownload = 0;
        m_DownloadInfo.dwBytesRemaining = 0;
        if(m_DownloadInfo.dwFilesToDownload)
        {
            SetProgressText(IDS_RETRY);
        }
        m_dwServerFileCount=0;
        ResetEvent(_hDL);
    }


done:

    if(g_hDownloadProcess)
    {
        CloseHandle(g_hDownloadProcess);
    }

    if(!hr && m_DownloadInfo.dwFilesToDownload)
    {
        hr = E_FAIL;
        WriteToLog("\nSome files could not be downloaded\n");
    }

    WriteToLog("DownloadAndPatchFiles returning:%1!lx!\n", hr);
    return hr;
}



HRESULT CPatchDownloader :: CreateRequestBuffer(DWORD dwDownloadClientID)
{
    LPTSTR lpRequestPointer, lpFileNamePortionOfRequest;
    HRESULT hr = S_OK;
    DWORD i;
    DWORD dwHeapSize  = 64*1024;

    if(!m_lpFileInfo)
    {
        return E_INVALIDARG;
    }

    m_lpszRequestBuffer = (LPTSTR)ResizeBuffer(NULL, dwHeapSize, FALSE);
    if(!m_lpszRequestBuffer)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }
 

    lpRequestPointer = m_lpszRequestBuffer;

    lpRequestPointer += wsprintf(lpRequestPointer, "SessionId:%u\n", dwDownloadClientID);
    lpRequestPointer += wsprintf(lpRequestPointer, "FileList:%d\n",  m_DownloadInfo.dwFilesToDownload);

    WriteToLog("Download ClientID:%1!lx!  Number of Files:%2!d!\n", dwDownloadClientID, m_DownloadInfo.dwFilesToDownload);

    lpFileNamePortionOfRequest = lpRequestPointer;

    for(i=0; i < m_dwFileCount; i++) 
    {
        if ((DWORD)( lpRequestPointer - m_lpszRequestBuffer ) > (DWORD)( dwHeapSize - (DWORD)MAX_PATH )) 
        {
            dwHeapSize = dwHeapSize * 2;
            m_lpszRequestBuffer =  (LPTSTR)ResizeBuffer(m_lpszRequestBuffer, dwHeapSize, FALSE);
            if(!m_lpszRequestBuffer)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto done;
            }
        }

        if(m_lpFileInfo[i].dwFlags != PATCHFLAG_DOWNLOAD_NEEDED)
        {
            //Probably already downloaded
            continue;
        }

        if ((m_lpFileInfo[i].lpszExistingFilePatchSignature == NULL ) ||
            (*m_lpFileInfo[i].lpszExistingFilePatchSignature == 0 )) 
        {
            //  No file to patch from, request whole file.

            lpRequestPointer += wsprintf(lpRequestPointer, "%s\n", m_lpFileInfo[i].lpszFileNameToDownload);
        }
        else 
        {
            lpRequestPointer += wsprintf(lpRequestPointer, "%s,%s\n", m_lpFileInfo[i].lpszFileNameToDownload, 
                                            m_lpFileInfo[i].lpszExistingFilePatchSignature);
        }

    }

    //  Now terminate list with "empty" entry.
    *lpRequestPointer++ = '\n';
    *lpRequestPointer++ = 0;

    m_dwRequestDataLength = lpRequestPointer - m_lpszRequestBuffer;

    //  Now lowercase all the filenames in the request (this offloads the case consistency work from 
    //  the server -- the server expects the request to be all lowercase).

    MyLowercase(lpFileNamePortionOfRequest);
    WriteToLog("RequestBuffer: Size=%1!d!\n\n", m_dwRequestDataLength);
    WriteToLog("%1", m_lpszRequestBuffer);

done:
    if(FAILED(hr))
    {
        ResizeBuffer(m_lpszRequestBuffer, 0, 0);
    }

    WriteToLog("\nCreateRequestBuffer returning %1!lx!\n", hr);
    return hr;
}


CPatchDownloader::CPatchDownloader(DOWNLOAD_FILEINFO* pdwn, DWORD dwFileCount, PATCH_DOWNLOAD_CALLBACK lpfn)
{
    m_lpFileInfo = pdwn;
    m_dwFileCount = dwFileCount;
    m_lpfnCallback = lpfn;
    m_hCurrentFileHandle = NULL;
    m_dwCurrentFileIndex = 0;
    m_lpFileList = NULL;
    m_dwServerFileCount = 0;
}

CPatchDownloader::~CPatchDownloader()
{
    DestroySubAllocator(m_hSubAllocator);    
}




STDMETHODIMP CPatchDownloader::GetBindInfo( DWORD *grfBINDF, BINDINFO *pbindInfo)
{
   *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_RESYNCHRONIZE | BINDF_NOWRITECACHE;
   pbindInfo->cbSize = sizeof(BINDINFO);
   
   memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
   pbindInfo->stgmedData.tymed = TYMED_HGLOBAL;
   pbindInfo->stgmedData.hGlobal = m_lpszRequestBuffer;
   pbindInfo->grfBindInfoF = BINDINFOF_URLENCODESTGMEDDATA;
   pbindInfo->dwBindVerb = BINDVERB_POST;
   pbindInfo->szCustomVerb = NULL;
   pbindInfo->cbstgmedData = m_dwRequestDataLength;
   pbindInfo->szExtraInfo = NULL;
   return(NOERROR);
}


STDMETHODIMP CPatchDownloader::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pwzStatusText)
{
    int PatchStatusCode = -1;
    UINT uID;
    switch(ulStatusCode)
    {
    case BINDSTATUS_FINDINGRESOURCE:
        PatchStatusCode = PATCH_DOWNLOAD_FINDINGSITE;
        uID = IDS_BINDS_FINDING;
        break;

    case BINDSTATUS_CONNECTING:
        PatchStatusCode = PATCH_DOWNLOAD_CONNECTING;
        uID = IDS_BINDS_CONN;
        break;

    case BINDSTATUS_BEGINDOWNLOADDATA:
        PatchStatusCode = PATCH_DOWNLOAD_DOWNLOADINGDATA;
        uID = IDS_BINDS_DOWNLOADING;
        break;


    case BINDSTATUS_ENDDOWNLOADDATA:
        PatchStatusCode = PATCH_DOWNLOAD_ENDDOWNLOADINGDATA;
        uID = IDS_BINDS_ENDDOWNLOAD;
        break;
    }

    if(PatchStatusCode != -1 && pwzStatusText)
    {
        TCHAR szBuffer[MAX_PATH], szTemplate[MAX_PATH];
        LoadString(g_hInstance, uID, szTemplate, sizeof(szTemplate));
        wsprintf(szBuffer, szTemplate, m_lpszSiteName);
        ProtectedPatchDownloadCallback(m_lpfnCallback, (PATCH_DOWNLOAD_REASON)PatchStatusCode, szBuffer, m_lpvContext);
    }
   return NOERROR;
}


STDMETHODIMP CPatchDownloader::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM *pstgmed)
{
   HRESULT hr = NOERROR;
   TCHAR szBuffer[4096];
   DWORD dwRead = 0, dwWritten=0;
   do
   {
      hr = pstgmed->pstm->Read(szBuffer, 4096, &dwRead);
      if((SUCCEEDED(hr) || (hr == E_PENDING)) && dwRead > 0)
      {
          if(!ProcessDownloadChunk(szBuffer, dwRead))
          {
              WriteToLog("ProcessDownloadChunk returning FALSE. Aborting downloading\n");
              hr = E_ABORT;
          }
      }     
   }  while (hr == NOERROR && !g_fAbort);

   if(g_fAbort)
       Abort();           
   return hr;
}


BOOL CPatchDownloader :: ProcessDownloadChunk(LPTSTR lpBuffer, DWORD dwLength)    
{
    CHAR  TargetFile[ MAX_PATH ];
    ULONG Actual;
    ULONG WriteSize;
    BOOL  Success;


    if ( m_dwServerFileCount == 0 ) 
    {

        //
        //  Haven't processed headers yet.
        //
        //  We expect header to look like this:
        //
        //             "<head><title>"
        //             "Download Stream of Files"
        //             "</title></head>\n"
        //             "<body>\n"
        //             "FileList:%d\n"
        //             "filename,%d\n"
        //             "filename,%d\n"
        //             ...etc...
        //             "filename,%d\n"
        //             "</body>\n"
        //
        //  BUGBUG: if headers don't all fit in first chunk, we're screwed.
        //

        PCHAR EndOfHeader;
        PCHAR FileCountText;
        PCHAR FileNameText;
        PCHAR FileSizeText;
        ULONG FileSize;
        ULONG FileBytes;
        ULONG i;
        PCHAR p;

        EndOfHeader = ScanForSequence(lpBuffer, dwLength,
                          "</body>\n",
                          sizeof( "</body>\n" ) - 1   // not including terminator
                          );

        if( EndOfHeader == NULL ) {
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
            }

        EndOfHeader += sizeof( "</body>\n" ) - 1 ;

        p = ScanForSequence(lpBuffer, EndOfHeader - lpBuffer, "FileList:", sizeof( "FileList:" ) - 1);

        if ( p == NULL ) 
        {
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }

        p += sizeof( "FileList:" ) - 1;

        FileCountText = p;

        p = ScanForChar( p, '\n', EndOfHeader - p );

        *p++ = 0;

        m_dwServerFileCount = StrToInt( FileCountText );
        
        WriteToLog("Total Files to be downloaded:%1!d!\n", m_dwServerFileCount);

        if(m_dwServerFileCount == 0 ) 
        {
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }

        m_lpFileList = (LPFILE) SubAllocate(m_hSubAllocator, m_dwServerFileCount * sizeof(FILE));
        if(!m_lpFileList)
        {
            return FALSE;
        }

        m_dwCurrentFileIndex = 0;
        FileBytes = 0;

        for ( i = 0; i < m_dwServerFileCount; i++ ) 
        {

            FileNameText = p;
            p = ScanForChar( p, ',', EndOfHeader - p );

            if (( p == NULL ) || ( p == FileNameText )) 
            {
                SetLastError( ERROR_INVALID_DATA );
                return FALSE;
            }

            *p++ = 0;

            FileSizeText = p;

            p = ScanForChar( p, '\n', EndOfHeader - p );

            if ( p == NULL ) 
            {
                SetLastError( ERROR_INVALID_DATA );
                return FALSE;
            }

            *p++ = 0;

            FileSize = TextToUnsignedNum(FileSizeText);

            if ( FileSize == 0 ) 
            {
                SetLastError( ERROR_INVALID_DATA );
                return FALSE;
            }

            FileBytes += FileSize;

            m_lpFileList[i].dwFileSize = FileSize;
            m_lpFileList[i].lpszFileName = MySubAllocStrDup(m_hSubAllocator, FileNameText);

            if (m_lpFileList[i].lpszFileName == NULL) 
            {
                return FALSE;
            }

            WriteToLog("File Name:%1 \t  File Size:%2!d!\n", m_lpFileList[i].lpszFileName, m_lpFileList[i].dwFileSize);
        }

        //  If we get to here, all the files in the header have been processed,
        //  so we can set the state variables and continue with parsing raw
        //  file data.

        m_DownloadInfo.dwBytesToDownload  = FileBytes;
        m_DownloadInfo.dwBytesRemaining = FileBytes;
        dwLength -= ( EndOfHeader - lpBuffer );
        lpBuffer = EndOfHeader;  

        WriteToLog("\nTotal %1!d! bytes(%2!d! Files) to be downloaded\n", FileBytes, m_dwServerFileCount);

    }

    //  Process raw file info.

    m_DownloadInfo.dwBytesRemaining -= dwLength;    
    if(!ProtectedPatchDownloadCallback(m_lpfnCallback, PATCH_DOWNLOAD_PROGRESS, (LPVOID)&m_DownloadInfo, m_lpvContext))
    {
        g_fAbort = TRUE;
        return FALSE;
    }


    while(dwLength > 0) 
    {

        if (m_hCurrentFileHandle == NULL  || m_hCurrentFileHandle == INVALID_HANDLE_VALUE) 
        {

            if (m_dwCurrentFileIndex >= m_dwServerFileCount) 
            {
                SetLastError( ERROR_INVALID_DATA );
                return FALSE;    // more data than we expected                
            }

            //  Now open this file.
            CombinePaths(m_lpszDownLoadDir, m_lpFileList[m_dwCurrentFileIndex].lpszFileName, TargetFile );

            m_dwCurrentFileSize = m_lpFileList[m_dwCurrentFileIndex].dwFileSize;
            m_dwCurrFileSizeRemaining = m_dwCurrentFileSize;
            
            m_hCurrentFileHandle = CreateFile(TargetFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, 
                                              CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

            if (m_hCurrentFileHandle == INVALID_HANDLE_VALUE ) 
            {
                return FALSE;                
            }            
        }

        WriteSize = min( dwLength, m_dwCurrFileSizeRemaining);

        Success = WriteFile(m_hCurrentFileHandle, lpBuffer, WriteSize, &Actual, NULL);

        if(!Success) 
        {
            return FALSE;            
        }

        if(Actual != WriteSize) 
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            WriteToLog("Error:Actual size not equal to write size for %1. Aborting\n", 
                        m_lpFileList[m_dwCurrentFileIndex].lpszFileName);
            return FALSE;            
        }

        m_dwCurrFileSizeRemaining -= WriteSize;

        if(m_dwCurrFileSizeRemaining == 0 ) 
        {

            CloseHandle(m_hCurrentFileHandle);
            m_hCurrentFileHandle = NULL;

            //  Pass this file off to the patch thread.
            LPTSTR lpszFileName =  (LPTSTR)ResizeBuffer(NULL, MAX_PATH, FALSE);
            CombinePaths(m_lpszDownLoadDir, m_lpFileList[m_dwCurrentFileIndex].lpszFileName, TargetFile );
            lstrcpy(lpszFileName, TargetFile);
            WaitForSingleObject(g_hDownloadProcess, 10000);
            PostThreadMessage(m_dwPatchThreadId, WM_FILEAVAILABLE, 0, (LPARAM)lpszFileName);
            m_dwCurrentFileIndex += 1;            
        }

        lpBuffer     += WriteSize;
        dwLength -= WriteSize;        
    }

    return TRUE;    
}


    
  
    
DWORD WINAPI PatchThread(IN LPVOID ThreadParam)
{
    PPATCH_THREAD_INFO        PatchThreadInfo = (PPATCH_THREAD_INFO) ThreadParam;
    PFILE_LIST_INFO           FileListInfo    = &PatchThreadInfo->FileListInfo;
    PDOWNLOAD_INFO            ProgressInfo    = PatchThreadInfo->lpdwnProgressInfo;
    
    NAME_TREE                 FileNameTree;
    PNAME_NODE                FileNameNode;
    PDOWNLOAD_FILEINFO        FileInfo;
    DWORD                     Status;
    BOOL                      bIsPatch;
    HANDLE                    hSubAllocator;
    ULONG                     i;
    BOOL                      fSuccess, fQuit = FALSE;
    MSG msg;

    //
    //  First thing we need to do is construct a btree of the filenames
    //  we expect to get in the queue so we can quickly find the corresponding
    //  FileList entry when given a filename by the downloader.  It will take
    //  the downloader a little while to get connected, so this CPU intensive
    //  task shouldn't slow anything down.
    //

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);
    PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE); 
    hSubAllocator = CreateSubAllocator( 0x10000, 0x10000 );

    if ( hSubAllocator == NULL ) 
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    NameRbInitTree( &FileNameTree, hSubAllocator );
    TCHAR SourceFileName[MAX_PATH];

    for ( i = 0; i < FileListInfo->FileCount; i++ ) 
    {

        if(FileListInfo->FileList[ i ].dwFlags != PATCHFLAG_DOWNLOAD_NEEDED)
        {
            //Probably already downloaded and this is the second attempt
            continue;
        }

        lstrcpy( SourceFileName, FileListInfo->FileList[ i ].lpszFileNameToDownload);
        MyLowercase( SourceFileName );

        FileNameNode = NameRbInsert(&FileNameTree,  SourceFileName);

        if ( FileNameNode == NULL ) 
        {
            DestroySubAllocator( hSubAllocator );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (FileNameNode->Context != NULL ) 
        {

            //
            //  BUGBUG: Same filename in list twice.  Should never be the
            //          case since we check for duplicates before putting
            //          them in the queue.
            //
        }

        FileNameNode->Context = &FileListInfo->FileList[ i ];

        //  Now add another node in the tree based on the compressed filename.
        ConvertToCompressedFileName( SourceFileName );

        FileNameNode = NameRbInsert(&FileNameTree, SourceFileName);

        if ( FileNameNode == NULL ) 
        {
            DestroySubAllocator( hSubAllocator );
            return ERROR_NOT_ENOUGH_MEMORY;            
        }

        if ( FileNameNode->Context != NULL ) 
        {

            //  BUGBUG: Same filename in list twice.  This can happen if two
            //          different files collide on a compressed name (like
            //          foo.db1 and foo.db2 colliding on foo.db_).
            //
            //          We don't have a good solution for this right now.
            //

         }

        //Set the contect to the file info. When we get back the file from server, we can get the full
        //info about this
        FileNameNode->Context = &FileListInfo->FileList[ i ]; 

        //Make sure we are not asked to quit
        if(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) && msg.message == WM_QUIT)
        {
            goto done;
        }
    }

    //
    //  Now wait for file downloads to be delivered to us.
    //

    SetEvent(g_hDownloadProcess);
    while (!g_fAbort && !fQuit) 
    {
        LPTSTR  lpszDownloadFileName, lpszSourceFileName;
        TCHAR szRealFileName[MAX_PATH];

        //
        //  We're going to wait here with a timeout so that if the download
        //  is stuck in InternetReadFile waiting for data, we can keep a
        //  heartbeat going to the progress dialog and also check for cancel.
        //

        Status = MsgWaitForMultipleObjects(1, &PatchThreadInfo->hFileDownloadEvent, FALSE, 1000, QS_ALLINPUT);
        if (Status == WAIT_TIMEOUT ) 
        {
            //Keep updating the callback 
            fSuccess = ProtectedPatchDownloadCallback(FileListInfo->Callback, PATCH_DOWNLOAD_PROGRESS, 
                                                    ProgressInfo, FileListInfo->CallbackContext);
            if (!fSuccess) 
            {
                g_fAbort = TRUE;
                break;
            }
            continue;
        }

        if(Status == WAIT_OBJECT_0)
        {
            fQuit = TRUE;
        }
            
        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if(msg.message == WM_FILEAVAILABLE)
            {
                lpszDownloadFileName = (LPTSTR)msg.lParam;
            }
            else
            {
                continue;
            } 

            //  Ok, now we have a filename lpszDownloadFileName that was just downloaded to the 
            //  temp directory.The filename may be in one of the following 
            //  forms:
            //      foo.dll
            //      foo.dl_
            //      foo.dll._p
            //
            //  We have both "foo.dll" and "foo.dl_" in our name tree, but we
            //  don't have "foo.dll._p", so we look for that form of the name
            //  first and convert it to "foo.dll" before looking in name tree.

            fSuccess = TRUE;
            lpszSourceFileName = PathFindFileName(lpszDownloadFileName);
            ASSERT(lpszSourceFileName);

            lstrcpyn(szRealFileName, lpszDownloadFileName, lpszSourceFileName - lpszDownloadFileName + 1);

            MyLowercase(lpszSourceFileName);
        
            LPTSTR lpExt = PathFindExtension(lpszSourceFileName);
            bIsPatch = FALSE;

            if(lpExt && !lstrcmp(lpExt, "._p"))
            {
                bIsPatch = TRUE;
                *lpExt = 0;         // truncate trailing "._p" to leave base file name            
            }

            FileNameNode = NameRbFind( &FileNameTree, lpszSourceFileName);

            if ( bIsPatch ) 
            {
                *lpExt = '.';       // restore complete patch source file name
            }

            if (FileNameNode != NULL) 
            {

                FileInfo = (PDOWNLOAD_FILEINFO)FileNameNode->Context;
                lstrcat(szRealFileName, FileInfo->lpszFileNameToDownload);
                if ( bIsPatch ) 
                {
                    fSuccess = ApplyPatchToFile(
                                  lpszDownloadFileName,                     // patch file
                                  FileInfo->lpszExistingFileToPatchFrom,  // old file
                                  szRealFileName,                     // new file
                                  0
                                  );
                }
                else 
                {

                    FixTimeStampOnCompressedFile(lpszSourceFileName);
                    if(lstrcmpi(lpszDownloadFileName, szRealFileName))
                    {
                        fSuccess = MySetupDecompressOrCopyFile(
                                  lpszDownloadFileName,             // compressed or whole file
                                  szRealFileName                  // new file
                                  );
                    }
                 }

                if (fSuccess) 
                {
                    //Notify callback. If it thinks that the hash is incorrect, don't mark the file
                    //as downloaded, so that we may retry download of this file.

                    fSuccess = VerifyHash(szRealFileName);

                    if(fSuccess)
                    {
                        fSuccess = ProtectedPatchDownloadCallback(FileListInfo->Callback, PATCH_DOWNLOAD_FILE_COMPLETED,
                                  szRealFileName, FileListInfo->CallbackContext);
                        
                        if(fSuccess == FALSE)
                        {
                            //If callback returned false, we need to abort
                            WriteToLog("\tDownload complete callback returned false. Aborting\n");
                            ProtectedPatchDownloadCallback(FileListInfo->Callback, PATCH_DOWNLOAD_ABORT,
                                          NULL, FileListInfo->CallbackContext);
                            break;
                        }
                        else
                        {
                            FileInfo->dwFlags = 0;
                            //Notify callback that 1 file was successfully downloaded
                            WriteToLog("\tSuccesssfully downloaded %1\n", FileInfo->lpszFileNameToDownload);
                            ProgressInfo->dwFilesRemaining -= 1;
                            fSuccess = ProtectedPatchDownloadCallback(FileListInfo->Callback, PATCH_DOWNLOAD_PROGRESS,
                                          ProgressInfo, FileListInfo->CallbackContext);
                            if(!fSuccess)    
                            {
                                g_fAbort = TRUE;
                                return FALSE;
                            }

                        }
                    }
                    else 
                    {
                        //Mark it so that we resend the request. Remove patch signature so we get full files instead
                        // of patches.
                        WriteToLog("\tHash Incorrect. Need to Re-download %1\n", FileInfo->lpszFileNameToDownload);
                        FileInfo->dwFlags = PATCHFLAG_DOWNLOAD_NEEDED;
                        if(FileInfo->lpszExistingFilePatchSignature)
                        {
                            LocalFree(FileInfo->lpszExistingFilePatchSignature);
                            FileInfo->lpszExistingFilePatchSignature = NULL;
                        }
                    }




                }            
                else 
                {
                    //  Patch or decompress failed. notify callback it failed.

                    WriteToLog("\tPatch or decompression failed for %1\n", FileInfo->lpszFileNameToDownload);
                    fSuccess = ProtectedPatchDownloadCallback(FileListInfo->Callback, PATCH_DOWNLOAD_FILE_FAILED,
                                  FileInfo, FileListInfo->CallbackContext);
                    //If callback says to continue or retry download, we do so. If it needs to abort, it return 0
                    if (!fSuccess) 
                    {
                        ProtectedPatchDownloadCallback(FileListInfo->Callback, PATCH_DOWNLOAD_ABORT,
                                      NULL, FileListInfo->CallbackContext);
                        break;                    
                    }

                    if(fSuccess == PATCH_DOWNLOAD_FLAG_RETRY)
                    {
                        FileInfo->dwFlags = PATCHFLAG_DOWNLOAD_NEEDED;
                        if(FileInfo->lpszExistingFilePatchSignature)
                        {
                            LocalFree(FileInfo->lpszExistingFilePatchSignature);
                            FileInfo->lpszExistingFilePatchSignature = NULL;
                        }
                    }
                    else if(fSuccess == PATCH_DOWNLOAD_FLAG_CONTINUE)
                    {
                        FileInfo->dwFlags = 0;
                    }                    
                }                    
            
                //Delete the temp file. We might be having 2 temp files if this was a patch.
                if(lstrcmpi(lpszDownloadFileName, szRealFileName))
                {
                    DeleteFile(lpszDownloadFileName);
                }
                DeleteFile(szRealFileName); 
                ResizeBuffer(lpszDownloadFileName, 0, 0);
            }   
        }
    }

done:
    DestroySubAllocator( hSubAllocator );   // free entire btree
    return 0;
}


BOOL VerifyHash(LPTSTR lpszFile)
{

    TCHAR szHashFromInf[40];
    TCHAR szHashFromFile[40];

    //   Verify MD5 of new file against the MD5 from inf. If we cannot verify
    //   the MD5 for any reason, then leave the file alone (success).
    //   Only if computed MD5 does not match do we reject the file.


    LPTSTR lpFileName = PathFindFileName(lpszFile);

    if(GetHashidFromINF(lpFileName, szHashFromInf, sizeof(szHashFromInf)) && 
       GetFilePatchSignatureA(lpszFile, PATCH_OPTION_SIGNATURE_MD5, NULL, 0, 0, 0, 0, 
                                sizeof(szHashFromFile), szHashFromFile))
    {
        if (lstrcmpi(szHashFromFile, szHashFromInf)) 
        {
            WriteToLog("Hash Incorrect. File hash: %1 Inf hash: %2. Need to Re-download %3\n", 
                        szHashFromFile, szHashFromInf, lpFileName);
            return FALSE;
        }                
    }
    else
    {
         WriteToLog("Warning:Could not get hashid for %1 in inf file\n", lpFileName);
    }

    return TRUE;
}

BOOL ProtectedPatchDownloadCallback(PATCH_DOWNLOAD_CALLBACK  Callback, IN PATCH_DOWNLOAD_REASON CallbackReason, 
                                    IN PVOID CallbackData, IN PVOID CallBackContext)
{
    
    BOOL Success = TRUE;
    
    if (Callback != NULL )
    {
        __try 
        {            
            Success = Callback(CallbackReason, CallbackData, CallBackContext);            
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) 
        {
            SetLastError( GetExceptionCode());
            Success = FALSE;            
        }
    }

    return Success;    
}

BOOL WINAPI PatchCallback(PATCH_DOWNLOAD_REASON Reason, PVOID lpvInfo, PVOID lpvCallBackContext)
{

    switch (Reason) 
    {
        case PATCH_DOWNLOAD_ENDDOWNLOADINGDATA:
        case PATCH_DOWNLOAD_CONNECTING:   
        case PATCH_DOWNLOAD_FINDINGSITE:
        case PATCH_DOWNLOAD_DOWNLOADINGDATA:
            {
                LPTSTR lpsz = (LPTSTR)lpvInfo;
                lpsz[90] = NULL;
                SetProgressText(lpsz);
            }
            break;

        case PATCH_DOWNLOAD_PROGRESS:
            {
                char szBuffer[100], szText[MAX_PATH];
                PDOWNLOAD_INFO ProgressInfo = (PDOWNLOAD_INFO)lpvInfo;
                LoadString(g_hInstance, IDS_BYTEINFO, szBuffer, sizeof(szBuffer));
                DWORD dwBytesDownloaded = ProgressInfo->dwBytesToDownload - ProgressInfo->dwBytesRemaining;
                wsprintf(szText, szBuffer, dwBytesDownloaded, ProgressInfo->dwBytesToDownload);
                if(g_hProgressDlg && ProgressInfo->dwBytesToDownload)
                {
                    SetProgressText(szText);
                }
                break;
            }


        case PATCH_DOWNLOAD_FILE_COMPLETED:     // AdditionalInfo is Source file downloaded
            {
                TCHAR szDstFile[MAX_PATH];
                LPTSTR lpFileName = PathFindFileName((LPCTSTR)lpvInfo);
                CombinePaths((LPTSTR)lpvCallBackContext, lpFileName, szDstFile);
                CopyFile((LPCTSTR)lpvInfo, szDstFile, FALSE);
            }

            break;
        case PATCH_DOWNLOAD_FILE_FAILED:
            //ask it to retry
            return PATCH_DOWNLOAD_FLAG_RETRY;
        default:
            break;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\resource.h ===
// Used by advpext.rc
//
#define IDS_INIT                        1
#define IDS_BINDS_CONN                  2
#define IDS_BINDS_FINDING               3
#define IDS_BINDS_DOWNLOADING           4
#define IDS_BINDS_ENDDOWNLOAD           5
#define IDS_BYTEINFO                    6
#define IDS_CLEANUP                     7
#define IDS_FILELIST                    8
#define IDS_RETRY                       9

#define IDD_PROGRESSDLG                 101
#define IDC_PROGRESSTEXT                1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\util.cpp ===
#include "util.h"
#include "patchdownload.h"
#include "sdsutils.h"

extern "C"
{
#include "crc32.h"
}

#define CR           13
HANDLE g_hLogFile = NULL;
extern HINF g_hInf;
extern HINSTANCE g_hInstance;

struct LangID
{
    DWORD dwLangID;
    char szLanguage[3];
};

const LangID g_LangID [] = 
{
    {0x404, "TW"},   
    {0x804,  "CN"},
    {0x405, "CS"},
    {0x406, "DA"},
    {0x413, "NL"},
    {0x409, "EN"},
    {0x40B, "FI"},
    {0x40C, "FR"},
    {0x407, "DE"},
    {0x408, "EL"},
    {0x40E, "HU"},
    {0x410, "IT"},
    {0x411, "JA"},
    {0x412, "KO"},
    {0x414, "NO"},
    {0x415, "PL"},
    {0x416, "BR"},
    {0x816, "PT"},
    {0x419, "RU"},
    {0x424, "SL"},
    {0xC0A, "ES"},
    {0x41D, "SV"},
    {0x41E, "TH"},
    {0x41F, "TR"},
    {0x42A, "VI"},
    {0x41B, "SK"},
    {0x401, "AR"},
    {0x403, "CA"},
    {0x42D, "EU"},
    {0x40D, "HE"},
    {0x40F, "IS"},
    {-1, NULL}
};


extern PFSetupFindFirstLine              pfSetupFindFirstLine;
extern PFSetupGetStringField             pfSetupGetStringField;
extern PFSetupDecompressOrCopyFile       pfSetupDecompressOrCopyFile;


PVOID __fastcall MyVirtualAlloc(ULONG Size)    
{
    return VirtualAlloc( NULL, Size, MEM_COMMIT, PAGE_READWRITE );    
}


VOID __fastcall MyVirtualFree(PVOID Allocation)    
{
    VirtualFree( Allocation, 0, MEM_RELEASE );    
}


extern "C" HANDLE CreateSubAllocator(IN ULONG InitialCommitSize,  IN ULONG GrowthCommitSize)    
{
    PSUBALLOCATOR SubAllocator;
    ULONG InitialSize;
    ULONG GrowthSize;

    InitialSize = ROUNDUP2( InitialCommitSize, MINIMUM_VM_ALLOCATION );
    GrowthSize  = ROUNDUP2( GrowthCommitSize,  MINIMUM_VM_ALLOCATION );

    SubAllocator = (PSUBALLOCATOR)MyVirtualAlloc( InitialSize );

    //
    //  If can't allocate entire initial size, back off to minimum size.
    //  Very large initial requests sometimes cannot be allocated simply
    //  because there is not enough contiguous address space.
    //

    if ( SubAllocator == NULL ) 
    {
         SubAllocator = (PSUBALLOCATOR)MyVirtualAlloc( GrowthSize );
    }

    if ( SubAllocator == NULL ) 
    {
         SubAllocator = (PSUBALLOCATOR)MyVirtualAlloc( MINIMUM_VM_ALLOCATION );
    }

    if ( SubAllocator != NULL ) 
    {
        SubAllocator->NextAvailable = (PCHAR)SubAllocator + ROUNDUP2( sizeof( SUBALLOCATOR ), SUBALLOCATOR_ALIGNMENT );
        SubAllocator->LastAvailable = (PCHAR)SubAllocator + InitialSize;
        SubAllocator->VirtualList   = (PVOID*)SubAllocator;
        SubAllocator->GrowSize      = GrowthSize;
     }

    return (HANDLE) SubAllocator;    
}


extern "C" PVOID __fastcall SubAllocate(IN HANDLE hAllocator, IN ULONG  Size)
{
    PSUBALLOCATOR SubAllocator = (PSUBALLOCATOR) hAllocator;
    PCHAR NewVirtual;
    PCHAR Allocation;
    ULONG AllocSize;
    ULONG Available;
    ULONG GrowSize;

    ASSERT( Size < (ULONG)( ~(( SUBALLOCATOR_ALIGNMENT * 2 ) - 1 )));

    AllocSize = ROUNDUP2( Size, SUBALLOCATOR_ALIGNMENT );
    Available = SubAllocator->LastAvailable - SubAllocator->NextAvailable;

    if ( AllocSize <= Available ) 
    {
        Allocation = SubAllocator->NextAvailable;
        SubAllocator->NextAvailable = Allocation + AllocSize;
        return Allocation;
    }

    //
    //  Insufficient VM, so grow it.  Make sure we grow it enough to satisfy
    //  the allocation request in case the request is larger than the grow
    //  size specified in CreateSubAllocator.
    //


    GrowSize = SubAllocator->GrowSize;

    if ( GrowSize < ( AllocSize + SUBALLOCATOR_ALIGNMENT )) 
    {
        GrowSize = ROUNDUP2(( AllocSize + SUBALLOCATOR_ALIGNMENT ), MINIMUM_VM_ALLOCATION );
    }

    NewVirtual = (PCHAR)MyVirtualAlloc( GrowSize );

    //  If failed to alloc GrowSize VM, and the allocation could be satisfied
    //  with a minimum VM allocation, try allocating minimum VM to satisfy
    //  this request.
    //

    if (( NewVirtual == NULL ) && ( AllocSize <= ( MINIMUM_VM_ALLOCATION - SUBALLOCATOR_ALIGNMENT ))) 
    {
        GrowSize = MINIMUM_VM_ALLOCATION;
        NewVirtual = (PCHAR)MyVirtualAlloc( GrowSize );
    }

    if ( NewVirtual != NULL ) 
    {

        //  Set LastAvailable to end of new VM block.
        SubAllocator->LastAvailable = NewVirtual + GrowSize;

        //  Link new VM into list of VM allocations.

        *(PVOID*)NewVirtual = SubAllocator->VirtualList;
        SubAllocator->VirtualList = (PVOID*)NewVirtual;

        //  Requested allocation comes next.
        Allocation = NewVirtual + SUBALLOCATOR_ALIGNMENT;

        //  Then set the NextAvailable for what's remaining.

        SubAllocator->NextAvailable = Allocation + AllocSize;

        //  And return the allocation.

        return Allocation;        
    }

    //  Could not allocate enough VM to satisfy request.
    return NULL;
}


extern "C"  VOID DestroySubAllocator(IN HANDLE hAllocator)    
{
    PSUBALLOCATOR SubAllocator = (PSUBALLOCATOR) hAllocator;
    PVOID VirtualBlock = SubAllocator->VirtualList;
    PVOID NextVirtualBlock;

    do  
    {
        NextVirtualBlock = *(PVOID*)VirtualBlock;
        MyVirtualFree( VirtualBlock );
        VirtualBlock = NextVirtualBlock;

    }while (VirtualBlock != NULL);
}


HLOCAL ResizeBuffer(IN HLOCAL BufferHandle, IN DWORD Size,  IN BOOL Moveable)
{
    if (BufferHandle == NULL) 
    {        
        if (Size != 0) 
        {
            BufferHandle = LocalAlloc(Moveable ? LMEM_MOVEABLE : LMEM_FIXED, Size);
        }

    } 
    else if (Size == 0) 
    {
        BufferHandle = LocalFree(BufferHandle);
        BufferHandle=NULL;

    } 
    else 
    {
        HLOCAL TempBufferHandle = LocalReAlloc(BufferHandle, Size, LMEM_MOVEABLE);
		if ( TempBufferHandle )
		{
			BufferHandle = TempBufferHandle;
		}
		else
		{
			LocalFree(BufferHandle);
			BufferHandle = NULL;
		}
    }

    return BufferHandle;
}

VOID MyLowercase(IN OUT LPSTR String)
{
    LPSTR p;

    for ( p = String; *p; p++ ) 
    {
        if (( *p >= 'A' ) && ( *p <= 'Z' )) 
        {
            *p |= 0x20;
        }
    }
}

void InitLogFile()
{
    char szLogFileName[MAX_PATH], szTmp[MAX_PATH];
    HKEY hKey;
    BYTE cbData[MAX_PATH];
    DWORD dwSize = sizeof(cbData);

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Advanced INF Setup", 0, 
                                                KEY_ALL_ACCESS, &hKey))
    {
        return;
    }

    if(ERROR_SUCCESS != RegQueryValueEx(hKey, "AdvpextLog", 0, 0, cbData, &dwSize) ||
       lstrcmpi((char*)cbData, "yes"))
    {
        RegCloseKey(hKey);
        return;
    }

    RegCloseKey(hKey);
    
    if (GetWindowsDirectory(szTmp, sizeof(szTmp)))
    {
        wsprintf(szLogFileName, "%s\\%s", szTmp, LOGFILENAME);
        if (GetFileAttributes(szLogFileName) != 0xFFFFFFFF)
        {
            // Make a backup of the current log file
            lstrcpyn(szTmp, szLogFileName, lstrlen(szLogFileName) - 2 );    // don't copy extension
            lstrcat(szTmp, "BAK");
            SetFileAttributes(szTmp, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szTmp);
            MoveFile(szLogFileName, szTmp);
        }

        g_hLogFile = CreateFile(szLogFileName, GENERIC_WRITE|GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0,0);
    }

}


void WriteToLog(char *pszFormatString, ...)
{
    va_list args;
    char *pszFullErrMsg = NULL;
    DWORD dwBytesWritten;

    if (g_hLogFile && g_hLogFile != INVALID_HANDLE_VALUE)
    {
        va_start(args, pszFormatString);
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                      (LPCVOID) pszFormatString, 0, 0, (LPTSTR) &pszFullErrMsg, 0, &args);
        if (pszFullErrMsg)
        {
            WriteFile(g_hLogFile, pszFullErrMsg, lstrlen(pszFullErrMsg), &dwBytesWritten, NULL);
            LocalFree(pszFullErrMsg);
        }
    }
}

DWORD GenerateUniqueClientId()
{
    CHAR  MachineName[MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD MachineNameLength;
    DWORD UniqueId;

    MachineNameLength = sizeof( MachineName );
    GetComputerName( MachineName, &MachineNameLength );

    do
    {
        UniqueId = GetTickCount();
        UniqueId = Crc32( UniqueId, MachineName, MachineNameLength );
        UniqueId = UniqueId & 0xFFFFFFF0;

    }while ( UniqueId == 0 );

    return UniqueId;
}

BOOL MySetupDecompressOrCopyFile(IN LPCSTR SourceFile, IN LPCSTR TargetFile)
{
    DWORD ErrorCode = pfSetupDecompressOrCopyFile( SourceFile, TargetFile, 0 );

    if ( ErrorCode != NO_ERROR ) {
        SetLastError( ErrorCode );
        return FALSE;
        }
    else {
        SetFileAttributes( TargetFile, FILE_ATTRIBUTE_NORMAL );
        return TRUE;
        }
}

ULONG __fastcall TextToUnsignedNum(IN LPCSTR Text)    
{
    LPCSTR p = Text;
    ULONG  n = 0;

    //
    //  Very simplistic conversion stops at first non digit character, does
    //  not require null-terminated string, and does not skip any whitespace
    //  or commas.
    //

    while (( *p >= '0' ) && ( *p <= '9' )) {
        n = ( n * 10 ) + ( *p++ - '0' );
        }

    return n;    
}

LPSTR CombinePaths(
    IN  LPCSTR ParentPath,
    IN  LPCSTR ChildPath,
    OUT LPSTR  TargetPath   // can be same as ParentPath if want to append
    )
    {
    ULONG ParentLength = strlen( ParentPath );
    LPSTR p;

    if ( ParentPath != TargetPath ) {
        memcpy( TargetPath, ParentPath, ParentLength );
        }

    p = TargetPath + ParentLength;

    if (( ParentLength > 0 )   &&
        ( *( p - 1 ) != '\\' ) &&
        ( *( p - 1 ) != '/'  )) {
        *p++ = '\\';
        }

    strcpy( p, ChildPath );

    return TargetPath;
    }

BOOL FixTimeStampOnCompressedFile(IN LPCSTR FileName)    
{

    //
    //  NT4 setupapi uses timestamp on compressed file to set on
    //  the target decompressed file.  With streaming download, we
    //  lose the timestamp on the file.  But, the correct timestamp
    //  lives inside the compressed file, so we'll open the file
    //  to see if it is a diamond compressed file and if so,
    //  extract the timestamp and set it on the compressed file.
    //  Then, when setupapi expands the compressed file, it will
    //  use that timestamp on the expanded file.
    //
    //  A better fix is probably to tunnel the timestamp in the
    //  pstream protocol, but too late to change that at this
    //  point.
    //

    FILETIME LocalFileTime;
    FILETIME UtcFileTime;
    BOOL     TimeSuccess;
    BOOL     MapSuccess;
    HANDLE   hSourceFile;
    PUCHAR   pSourceFileMapped;
    DWORD    dwSourceFileSize;
    DWORD    dwOffset;
    USHORT   DosDate;
    USHORT   DosTime;
    PUCHAR   p;

    TimeSuccess = FALSE;

    MapSuccess = MyMapViewOfFile(FileName, &dwSourceFileSize, &hSourceFile, (void**)&pSourceFileMapped);

    if ( MapSuccess ) 
    {

        __try {

            p = pSourceFileMapped;

            if (( *(DWORD*)( p ) == 'FCSM' ) &&     // "MSCF"
                ( *(BYTE *)( p + 24 ) == 3 ) &&     // minor version
                ( *(BYTE *)( p + 25 ) == 1 ) &&     // major version
                ( *(WORD *)( p + 26 ) == 1 ) &&     // 1 folder
                ( *(WORD *)( p + 28 ) == 1 )) {     // 1 file

                dwOffset = *(DWORD*)( p + 16 );

                if (( dwOffset + 16 ) < dwSourceFileSize ) {

                    DosDate = *(UNALIGNED WORD*)( p + dwOffset + 10 );
                    DosTime = *(UNALIGNED WORD*)( p + dwOffset + 12 );

                    if ( DosDateTimeToFileTime( DosDate, DosTime, &LocalFileTime ) &&
                         LocalFileTimeToFileTime( &LocalFileTime, &UtcFileTime )) {

                        TimeSuccess = TRUE;
                        }
                    }
                }
            }

        __except(EXCEPTION_EXECUTE_HANDLER) 
        {
            
        }

        MyUnmapViewOfFile( hSourceFile, pSourceFileMapped );        
    }

    if ( TimeSuccess ) {

        hSourceFile = CreateFile(
                          FileName,
                          GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          0,
                          NULL
                          );

        if ( hSourceFile != INVALID_HANDLE_VALUE ) {

            if ( ! SetFileTime( hSourceFile, &UtcFileTime, &UtcFileTime, &UtcFileTime )) {
                TimeSuccess = FALSE;
                }

            CloseHandle( hSourceFile );
            }
        }

    return TimeSuccess;
    }

BOOL Assert(LPCSTR szText, LPCSTR szFile, DWORD  dwLine)    
{
    CHAR Buffer[ 256 ];
    wsprintf( Buffer, "ASSERT( %s ) FAILED, %s (%d)\n", szText, szFile, dwLine );
    OutputDebugString( Buffer );
    DebugBreak();
    return FALSE;    
}

BOOL MyMapViewOfFileByHandle(IN  HANDLE  FileHandle, OUT ULONG  *FileSize, OUT PVOID  *MapBase)    
{
    ULONG  InternalFileSize;
    ULONG  InternalFileSizeHigh;
    HANDLE InternalMapHandle;
    PVOID  InternalMapBase;

    InternalFileSize = GetFileSize( FileHandle, &InternalFileSizeHigh );

    if ( InternalFileSizeHigh != 0 ) 
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    if ( InternalFileSize == 0 ) 
    {
        *MapBase  = NULL;
        *FileSize = 0;
        return TRUE;
    }

    if ( InternalFileSize != 0xFFFFFFFF ) 
    {

        InternalMapHandle = CreateFileMapping(
                                FileHandle,
                                NULL,
                                PAGE_WRITECOPY,
                                0,
                                0,
                                NULL
                                );

        if ( InternalMapHandle != NULL ) 
        {

            InternalMapBase = MapViewOfFile(InternalMapHandle, FILE_MAP_COPY, 0, 0, 0);
            CloseHandle( InternalMapHandle );

            if ( InternalMapBase != NULL ) 
            {
                DWORD dw = ROUNDUP2(InternalFileSize, 64);

                if(dw != InternalFileSize)
                {
                    ZeroMemory((PBYTE)InternalMapBase + InternalFileSize, dw - InternalFileSize);
                }

                *MapBase  = InternalMapBase;
                *FileSize = InternalFileSize;

                return TRUE;                
            }            
        }        
    }

    return FALSE;    
}


BOOL MyMapViewOfFile(IN  LPCSTR  FileName, OUT ULONG  *FileSize, OUT HANDLE *FileHandle, OUT PVOID  *MapBase)
{
    HANDLE InternalFileHandle;
    BOOL   Success;

    InternalFileHandle = CreateFileA(
                             FileName,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_SEQUENTIAL_SCAN,
                             NULL
                             );

    if ( InternalFileHandle != INVALID_HANDLE_VALUE ) 
    {

        Success = MyMapViewOfFileByHandle(InternalFileHandle, FileSize, MapBase);

        if ( Success ) 
        {

            *FileHandle = InternalFileHandle;
            return TRUE;
        }

        CloseHandle( InternalFileHandle );
    }

    return FALSE;
}

VOID MyUnmapViewOfFile(IN HANDLE FileHandle, IN PVOID  MapBase )
{
    ULONG LastError = GetLastError();
    UnmapViewOfFile( MapBase );
    CloseHandle( FileHandle );
    SetLastError( LastError );
}

VOID __fastcall ConvertToCompressedFileName(IN OUT LPSTR FileName)
{
    ULONG NameLength = strlen( FileName );
    ULONG DotIndex   = NameLength;

    while (( DotIndex > 0 ) && ( FileName[ --DotIndex ] != '.' )) {
        if ( FileName[ DotIndex ] == '\\' ) {   // end of filename part of path
            DotIndex = 0;                       // name has no extension
            break;
            }
        }

    if ( DotIndex > 0 ) {                       // name has an extension
        if (( NameLength - DotIndex ) <= 3 ) {  // extension less than 3 chars
            FileName[ NameLength++ ] = '_';     // append '_' to extension
            FileName[ NameLength   ] = 0;       // terminate
            }
        else {                                  // extension more than 3 chars
            FileName[ NameLength - 1 ] = '_';   // replace last char with '_'
            }
        }
    else {                                      // name has no extension
        FileName[ NameLength++ ] = '.';         // append '.'
        FileName[ NameLength++ ] = '_';         // append '_'
        FileName[ NameLength   ] = 0;           // terminate
        }
}


LPTSTR __fastcall MySubAllocStrDup(IN HANDLE SubAllocator, IN LPCSTR String)
{
    ULONG Length = lstrlen( String );
    LPTSTR Buffer = (LPTSTR)SubAllocate( SubAllocator, Length + 1 );

    if ( Buffer ) 
    {
        memcpy( Buffer, String, Length );   // no need to copy NULL terminator        
    }

    return Buffer;    
}

//
// Copied from Windows 95 unistal.exe cfg.c function CfgGetField
BOOL GetFieldString(LPSTR lpszLine, int iField, LPSTR lpszField, int cbSize)
{
    int cbField;
    LPSTR lpszChar, lpszEnd;
    // Find the field we are looking for

    lpszChar = lpszLine;

    // Each time we see a separator, decrement iField
    while (iField > 0 && (BYTE)*lpszChar > CR) {

        if (*lpszChar == '=' || *lpszChar == ',' || *lpszChar == ' ' ) {
            iField--;
            while (*lpszChar == '=' || *lpszChar== ',' || *lpszChar == ' ' && (BYTE)*lpszChar > 13)
                lpszChar++;
        }
        else
            lpszChar++;
    }

    // If we still have fields remaining then something went wrong
    if (iField)
        return FALSE;

    // Now find the end of this field
    lpszEnd = lpszChar;
    while (*lpszEnd != '=' && *lpszEnd != ',' && *lpszEnd != ' ' && (BYTE)*lpszEnd > CR)
        lpszEnd++;

    // Find the length of this field - make sure it'll fit in the buffer
    cbField = (int)((lpszEnd - lpszChar) + 1);

    if (cbField > cbSize) {     // I return an error if the requested
      //cbField = cbSize;       // data won't fit, rather than truncating
        return FALSE;           // it at some random point! -JTP
    }

    // Note that the C runtime treats cbField as the number of characters
    // to copy from the source, and if that doesn't happen to transfer a NULL,
    // too bad.  The Windows implementation of _lstrcpyn treats cbField as
    // the number of characters that can be stored in the destination, and
    // always copies a NULL (even if it means copying only cbField-1 characters
    // from the source).

    // The C runtime also pads the destination with NULLs if a NULL in the
    // source is found before cbField is exhausted.  _lstrcpyn essentially quits
    // after copying a NULL.


    lstrcpyn(lpszField, lpszChar, cbField);

    return TRUE;
}

#define NUM_VERSION_NUM 4
void ConvertVersionStrToDwords(LPSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild)
{
    WORD rwVer[NUM_VERSION_NUM];

    for(int i = 0; i < NUM_VERSION_NUM; i++)
        rwVer[i] = 0;

    for(i = 0; i < NUM_VERSION_NUM && pszVer; i++)
    {
        rwVer[i] = (WORD) StrToInt(pszVer);
        pszVer = ScanForChar(pszVer, '.', lstrlen(pszVer));
        if (pszVer)
            pszVer++;
    }

   *pdwVer = (rwVer[0]<< 16) + rwVer[1];
   *pdwBuild = (rwVer[2] << 16) + rwVer[3];

}

LPSTR FindChar(LPSTR pszStr, char ch)
{
   while( *pszStr != 0 && *pszStr != ch )
      pszStr++;
   return pszStr;
}

DWORD GetStringField(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize)
{
   LPSTR pszBegin = szStr;
   LPSTR pszEnd;
   UINT i = 0;
   DWORD dwToCopy;

   if(cBufSize == 0)
       return 0;

   szBuf[0] = 0;

   if(szStr == NULL)
      return 0;

   while(*pszBegin != 0 && i < uField)
   {
      pszBegin = FindChar(pszBegin, ',');
      if(*pszBegin != 0)
         pszBegin++;
      i++;
   }

   // we reached end of string, no field
   if(*pszBegin == 0)
   {
      return 0;
   }


   pszEnd = FindChar(pszBegin, ',');
   while(pszBegin <= pszEnd && *pszBegin == ' ')  
      pszBegin++;

   while(pszEnd > pszBegin && *(pszEnd - 1) == ' ')
      pszEnd--;
   
   if(pszEnd > (pszBegin + 1) && *pszBegin == '"' && *(pszEnd-1) == '"')
   {
      pszBegin++;
      pszEnd--;
   }

   dwToCopy = pszEnd - pszBegin + 1;
   
   if(dwToCopy > cBufSize)
      dwToCopy = cBufSize;

   lstrcpynA(szBuf, pszBegin, dwToCopy);
   
   return dwToCopy - 1;
}

BOOL GetHashidFromINF(LPCTSTR lpFileName, LPTSTR lpszHash, DWORD dwSize)
{
    INFCONTEXT InfContext;

    if (pfSetupFindFirstLine(g_hInf, "SourceDisksFiles", lpFileName, &InfContext ))
    {
        if (pfSetupGetStringField(&InfContext, 5, lpszHash, dwSize, NULL )) 
        {
            return TRUE;
        }                
    }

    return FALSE;
}


#ifdef _M_IX86

//
//  Stupid x86 compiler doesn't have an intrinsic memchr, so we'll do our own.
//

#pragma warning( disable: 4035 )    // no return value

LPSTR ScanForChar(
    IN LPSTR Buffer,
    IN CHAR  SearchFor,
    IN ULONG MaxLength
    )
{
    __asm {

        mov     edi, Buffer         // pointer for scasb in edi
        mov     al,  SearchFor      // looking for this char
        mov     ecx, MaxLength      // don't scan past this
        repne   scasb               // find the char
        lea     eax, [edi-1]        // edi points one past the found char
        jz      RETURNIT            // if didn't find it,
        xor     eax, eax            // return NULL

RETURNIT:

        }
}

#pragma warning( default: 4035 )    // no return value

#else   // ! _M_IX86

LPSTR ScanForChar(IN LPSTR Buffer, IN CHAR  SearchFor, IN ULONG MaxLength)    
{
    return memchr( Buffer, SearchFor, MaxLength );
}

#endif  // ! _M_IX86


PCHAR ScanForSequence(IN PCHAR Buffer, IN ULONG BufferLength, IN PCHAR Sequence, IN ULONG SequenceLength)    
{
    if ( BufferLength >= SequenceLength ) 
    {

        PCHAR ScanEnd = Buffer + ( BufferLength - SequenceLength ) + 1;
        PCHAR ScanPtr = Buffer;

        while ( ScanPtr < ScanEnd ) 
        {

            ScanPtr = ScanForChar( ScanPtr, *Sequence, ScanEnd - ScanPtr );

            if ( ScanPtr == NULL ) 
            {
                return NULL;
            }

            if ( memcmp( ScanPtr, Sequence, SequenceLength ) == 0 ) 
            {
                return ScanPtr;
            }

            ++ScanPtr;
        }
    }

    return NULL;
}


//From shlwapi....
#define FAST_CharNext(p)    CharNext(p)
#define FILENAME_SEPARATOR       '\\'
#define CH_WHACK TEXT(FILENAME_SEPARATOR)


LPTSTR PathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT = pPath;
    
    if (pPath)
    {
        for ( ; *pPath; pPath = FAST_CharNext(pPath))
        {
            if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':') || pPath[0] == TEXT('/'))
                && pPath[1] &&  pPath[1] != TEXT('\\')  &&   pPath[1] != TEXT('/'))
                pT = pPath + 1;
        }
    }

    return (LPTSTR)pT;   // const -> non const
}

LPTSTR PathFindExtension(LPCTSTR pszPath)
{
    LPCTSTR pszDot = NULL;

    if (pszPath)
    {
        for (; *pszPath; pszPath = FAST_CharNext(pszPath))
        {
            switch (*pszPath) {
            case TEXT('.'):
                pszDot = pszPath;         // remember the last dot
                break;
            case CH_WHACK:
            case TEXT(' '):         // extensions can't have spaces
                pszDot = NULL;       // forget last dot, it was in a directory
                break;
            }
        }
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension) (cast->non const)
    return pszDot ? (LPTSTR)pszDot : (LPTSTR)pszPath;
}

LPSTR StrDup(LPCSTR psz)
{
    LPSTR pszRet = (LPSTR)LocalAlloc(LPTR, (lstrlenA(psz) + 1) * sizeof(*pszRet));
    if (pszRet) 
    {
        lstrcpyA(pszRet, psz);
    }
    return pszRet;
}


DWORD MyFileSize( PCSTR pszFile )
{
    HFILE hFile;
    OFSTRUCT ofStru;
    DWORD dwSize = 0;

    if ( *pszFile == 0 )
        return 0;

    hFile = OpenFile( pszFile, &ofStru, OF_READ );
    if ( hFile != HFILE_ERROR )
    {
        dwSize = GetFileSize( (HANDLE)hFile, NULL );
        _lclose( hFile );
    }

    return dwSize;
}

void GetLanguageString(LPTSTR lpszLang)
{
    char szTmp[MAX_PATH];
    DWORD dwLang, dwCharSet;

    //default to EN
    lstrcpy(lpszLang, "EN");
    GetModuleFileName( g_hInstance, szTmp, sizeof(szTmp) );
    MyGetVersionFromFile(szTmp, &dwLang, &dwCharSet, FALSE);

    for(int i = 0; g_LangID[i].dwLangID != -1; i++)
    {
        if(g_LangID[i].dwLangID == dwLang)
        {
            lstrcpy(lpszLang, g_LangID[i].szLanguage);
            break;
        }
    }

}

BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
	RECT    rChild, rParent;
	int     wChild, hChild, wParent, hParent;
	int     wScreen, hScreen, xNew, yNew;
	HDC     hdc;

	// Get the Height and Width of the child window
	GetWindowRect (hwndChild, &rChild);
	wChild = rChild.right - rChild.left;
	hChild = rChild.bottom - rChild.top;

	// Get the Height and Width of the parent window
	GetWindowRect (hwndParent, &rParent);
	wParent = rParent.right - rParent.left;
	hParent = rParent.bottom - rParent.top;

	// Get the display limits
	hdc = GetDC (hwndChild);
	wScreen = GetDeviceCaps (hdc, HORZRES);
	hScreen = GetDeviceCaps (hdc, VERTRES);
	ReleaseDC (hwndChild, hdc);

	// Calculate new X position, then adjust for screen
	xNew = rParent.left + ((wParent - wChild) /2);
	if (xNew < 0) {
		xNew = 0;
	} else if ((xNew+wChild) > wScreen) {
		xNew = wScreen - wChild;
	}

	// Calculate new Y position, then adjust for screen
	yNew = rParent.top  + ((hParent - hChild) /2);
	if (yNew < 0) {
		yNew = 0;
	} else if ((yNew+hChild) > hScreen) {
		yNew = hScreen - hChild;
	}

	// Set it, and return
	return SetWindowPos (hwndChild, NULL,
		xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\advpext\util.h ===
#ifndef __UTIL
#define __UTIL

#include <windows.h>


#define LOGFILENAME     "AdvpackExt.log"
#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))
#define MINIMUM_VM_ALLOCATION 0x10000
#define SUBALLOCATOR_ALIGNMENT 8

#define StrToInt TextToUnsignedNum

#ifndef ASSERT
    #ifdef DEBUG
        #define ASSERT( a ) (( a ) ? 1 : Assert( #a, __FILE__, __LINE__ ))
    #else
        #define ASSERT( a )
    #endif
#endif

extern HANDLE g_hLogFile;

extern "C"
{
struct _SUBALLOCATOR 
{
    PVOID  VirtualListTerminator;
    PVOID *VirtualList;
    PCHAR  NextAvailable;
    PCHAR  LastAvailable;
    ULONG  GrowSize;
};

typedef struct _SUBALLOCATOR SUBALLOCATOR, *PSUBALLOCATOR;


PVOID __fastcall SubAllocate(IN HANDLE hAllocator, IN ULONG  Size);
VOID DestroySubAllocator(IN HANDLE hAllocator);
HANDLE CreateSubAllocator(IN ULONG InitialCommitSize,  IN ULONG GrowthCommitSize);
}


HLOCAL ResizeBuffer(IN HLOCAL BufferHandle, IN DWORD Size,  IN BOOL Moveable);


VOID MyLowercase(IN OUT LPSTR String);
DWORD GenerateUniqueClientId();
BOOL MySetupDecompressOrCopyFile(IN LPCSTR SourceFile, IN LPCSTR TargetFile);
LPSTR CombinePaths(IN  LPCSTR ParentPath, IN  LPCSTR ChildPath, OUT LPSTR  TargetPath);
BOOL FixTimeStampOnCompressedFile(IN LPCSTR FileName);

BOOL MyMapViewOfFile(IN  LPCSTR  FileName, OUT ULONG  *FileSize, OUT HANDLE *FileHandle, OUT PVOID  *MapBase);
VOID MyUnmapViewOfFile(IN HANDLE FileHandle, IN PVOID  MapBase );
VOID __fastcall ConvertToCompressedFileName(IN OUT LPSTR FileName);
LPTSTR __fastcall MySubAllocStrDup(IN HANDLE SubAllocator, IN LPCSTR String);

BOOL GetFieldString(LPSTR lpszLine, int iField, LPSTR lpszField, int cbSize);
void ConvertVersionStrToDwords(LPSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild);
DWORD GetStringField(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize);
BOOL GetHashidFromINF(LPCTSTR lpFileName, LPTSTR lpszHash, DWORD dwSize);


PCHAR ScanForSequence(IN PCHAR Buffer,  IN ULONG BufferLength,  IN PCHAR Sequence, IN ULONG SequenceLength);
LPSTR ScanForChar(IN LPSTR Buffer, IN CHAR  SearchFor, IN ULONG MaxLength);
ULONG __fastcall TextToUnsignedNum(IN LPCSTR Text);
LPTSTR PathFindFileName(LPCTSTR pPath);
LPTSTR PathFindExtension(LPCTSTR pszPath);
LPSTR StrDup(LPCSTR psz);
DWORD MyFileSize(PCSTR pszFile);
void GetLanguageString(LPTSTR lpszLang);
BOOL CenterWindow (HWND hwndChild, HWND hwndParent);


    
void InitLogFile();
void WriteToLog(char *pszFormatString, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\basedll.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basedll.h

Abstract:

    This module contains private function prototypes
    and types for the 32-bit windows base APIs.

Author:

    Mark Lucovsky (markl) 18-Sep-1990

Revision History:

--*/

#ifndef _BASEP_
#define _BASEP_

#undef UNICODE
//
// Include Common Definitions.
//

#include <base.h>


//
// Include DLL definitions for CSR
//

#include "ntcsrdll.h"
#include "ntcsrsrv.h"

//
// Include message definitions for communicating between client and server
// portions of the Base portion of the Windows subsystem
//

#include "basemsg.h"

typedef struct _CMDSHOW {
    WORD wMustBe2;
    WORD wShowWindowValue;
} CMDSHOW, *PCMDSHOW;

typedef struct _LOAD_MODULE_PARAMS {
    LPVOID lpEnvAddress;
    LPSTR lpCmdLine;
    PCMDSHOW lpCmdShow;
    DWORD dwReserved;
} LOAD_MODULE_PARAMS, *PLOAD_MODULE_PARAMS;

typedef struct _RELATIVE_NAME {
    STRING RelativeName;
    HANDLE ContainingDirectory;
} RELATIVE_NAME, *PRELATIVE_NAME;

HANDLE BaseDllHandle;
HANDLE BaseNamedObjectDirectory;

PVOID BaseHeap;
BASE_HANDLE_TABLE BaseHeapHandleTable;


PVOID BaseAtomTable;
UNICODE_STRING BaseWindowsDirectory;
UNICODE_STRING BaseWindowsSystemDirectory;

UNICODE_STRING BasePathVariableName;
UNICODE_STRING BaseTmpVariableName;
UNICODE_STRING BaseTempVariableName;
UNICODE_STRING BaseDotVariableName;
UNICODE_STRING BaseDotTmpSuffixName;
UNICODE_STRING BaseDotComSuffixName;
UNICODE_STRING BaseDotPifSuffixName;
UNICODE_STRING BaseDotExeSuffixName;

UNICODE_STRING BaseDefaultPath;
UNICODE_STRING BaseDefaultPathAppend;
USHORT BaseWindowsMajorVersion;
USHORT BaseWindowsMinorVersion;
USHORT BaseBuildNumber;
PWSTR BaseCSDVersion;

UNICODE_STRING BaseConsoleInput;
UNICODE_STRING BaseConsoleOutput;
UNICODE_STRING BaseConsoleGeneric;
UNICODE_STRING BaseUnicodeCommandLine;
ANSI_STRING BaseAnsiCommandLine;

LPSTARTUPINFOA BaseAnsiStartupInfo;

PBASE_STATIC_SERVER_DATA BaseStaticServerData;

extern ULONG BaseGetTickMagicMultiplier;
extern LARGE_INTEGER BaseGetTickMagicDivisor;
extern CCHAR BaseGetTickMagicShiftCount;
extern BOOLEAN BaseRunningInServerProcess;

ULONG BaseIniFileUpdateCount;

#define ROUND_UP_TO_PAGES(SIZE) (((ULONG)(SIZE) + BaseStaticServerData->SysInfo.PageSize - 1) & ~(BaseStaticServerData->SysInfo.PageSize - 1))
#define ROUND_DOWN_TO_PAGES(SIZE) (((ULONG)(SIZE)) & ~(BaseStaticServerData->SysInfo.PageSize - 1))
#define BASE_COPY_FILE_CHUNK (64*1024)
#define BASE_MAX_PATH_STRING 4080

extern BOOLEAN BasepFileApisAreOem;

NTSTATUS
Basep8BitStringToUnicodeString(
    PUNICODE_STRING DestinationString,
    PANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
BasepUnicodeStringTo8BitString(
    PANSI_STRING DestinationString,
    PUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

ULONG
BasepUnicodeStringTo8BitSize(
    PUNICODE_STRING UnicodeString
    );

ULONG
Basep8BitStringToUnicodeSize(
    PANSI_STRING AnsiString
    );

HANDLE
BaseGetNamedObjectDirectory(
    VOID
    );

NTSTATUS
BaseDllInitializeMemoryManager( VOID );

typedef
NTSTATUS
(*BASECLIENTCONNECTROUTINE)(
    PVOID MustBeNull,
    PVOID ConnectionInformation,
    PULONG ConnectionInformationLength
    );


POBJECT_ATTRIBUTES
BaseFormatObjectAttributes(
    POBJECT_ATTRIBUTES ObjectAttributes,
    PSECURITY_ATTRIBUTES SecurityAttributes,
    PUNICODE_STRING ObjectName
    );

PLARGE_INTEGER
BaseFormatTimeOut(
    PLARGE_INTEGER TimeOut,
    DWORD Milliseconds
    );

ULONG
BaseSetLastNTError(
    NTSTATUS Status
    );

VOID
BaseSwitchStackThenTerminate(
    PVOID CurrentStack,
    PVOID NewStack,
    DWORD ExitCode
    );

VOID
BaseFreeStackAndTerminate(
    PVOID OldStack,
    DWORD ExitCode
    );

NTSTATUS
BaseCreateStack(
    HANDLE Process,
    ULONG StackSize,
    ULONG MaximumStackSize,
    PINITIAL_TEB InitialTeb
    );

VOID
BaseThreadStart(
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );

typedef DWORD (WINAPI *PPROCESS_START_ROUTINE)(
    VOID
    );

VOID
BaseProcessStart(
    PPROCESS_START_ROUTINE lpStartAddress
    );

VOID
BaseThreadStartThunk(
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );

VOID
BaseProcessStartThunk(
    LPVOID lpProcessStartAddress,
    LPVOID lpParameter
    );

VOID
BaseInitializeContext(
    PCONTEXT Context,
    PVOID Parameter,
    PVOID InitialPc,
    PVOID InitialSp,
    BOOLEAN NewThread
    );

#if defined (WX86)
NTSTATUS
BaseCreateWx86Tib(
    HANDLE Process,
    HANDLE Thread,
    ULONG InitialPc,
    ULONG CommittedStackSize,
    ULONG MaximumStackSize,
    BOOLEAN EmulateInitialPc
    );
#endif

VOID
BaseFreeThreadStack(
     HANDLE hProcess,
     HANDLE hThread,
     PINITIAL_TEB InitialTeb
     );

BOOL
BasePushProcessParameters(
    HANDLE Process,
    PPEB Peb,
    LPCWSTR ApplicationPathName,
    LPCWSTR CurrentDirectory,
    LPCWSTR CommandLine,
    LPVOID Environment,
    LPSTARTUPINFOW lpStartupInfo,
    DWORD dwCreationFlags,
    BOOL bInheritHandles
    );

LPWSTR
BaseComputeProcessDllPath(
    LPCWSTR ApplicationName,
    LPVOID Environment
    );

DWORD
BaseDebugAttachThread(
    LPVOID ThreadParameter
    );

VOID
BaseAttachCompleteThunk(
    VOID
    );

VOID
BaseAttachComplete(
    PCONTEXT Context
    );

#define BASE_FIND_FIRST_DEVICE_HANDLE (HANDLE)1

HANDLE
BaseFindFirstDevice(
    PUNICODE_STRING FileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );

PUNICODE_STRING
BaseIsThisAConsoleName(
    PUNICODE_STRING FileNameString,
    DWORD dwDesiredAccess
    );


typedef ULONG (FAR WINAPI *CSRREMOTEPROCPROC)(HANDLE, CLIENT_ID *);

#if DBG
VOID
BaseHeapBreakPoint( VOID );
#endif

ULONG
BaseGetTickCount (
   IN LARGE_INTEGER CurrentTime,
   IN LARGE_INTEGER BootTime
   );

ULONG
BasepOfShareToWin32Share(
    IN ULONG OfShare
    );

HANDLE
BaseCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile,
    STORAGE_TYPE StorageType
    );

#ifdef _CAIRO_
BOOL
BaseCopyStructuredStorage(
    HANDLE SourceFile,
    HANDLE DestFile,
    ULONG *CopySize
    );

NTSTATUS
BaseGetStorageType(
    HANDLE Handle,
    STORAGE_TYPE *StorageType
    );

NTSTATUS
BaseCopyOleAllInfo(
    HANDLE SrcHandle,
    HANDLE DstHandle
    );
#endif

BOOL
BaseCopyStream(
    HANDLE SourceFile,
    LPCWSTR lpNewFileName,
    HANDLE hFile,
    LARGE_INTEGER *lpFileSize,
    BOOL bFailIfExists,
    PHANDLE Destfile,
    LPDWORD lpCopySize,
    STORAGE_TYPE StorageType
    );


VOID
BaseMarkFileForDelete(
    HANDLE File,
    DWORD FileAttributes
    );


PVOID
BasepMapModuleHandle(
    IN HMODULE hModule,
    IN BOOLEAN bResourcesOnly
    );

//
// Data structures and interfaces used by dllini.c
//

typedef struct _INIFILE_CACHE {
    struct _INIFILE_CACHE *Next;
    ULONG EnvironmentUpdateCount;
    UNICODE_STRING NtFileName;
    PINIFILE_MAPPING_FILENAME FileMapping;
    HANDLE FileHandle;
    BOOLEAN WriteAccess;
    BOOLEAN UnicodeFile;
    BOOLEAN LockedFile;
    ULONG EndOfFile;
    PVOID BaseAddress;
    ULONG CommitSize;
    ULONG RegionSize;
    ULONG UpdateOffset;
    ULONG UpdateLength;
    ULONG DirectoryInformationLength;
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
} INIFILE_CACHE, *PINIFILE_CACHE;

typedef enum _INIFILE_OPERATION {
    FlushProfiles,
    ReadKeyValue,
    WriteKeyValue,
    DeleteKey,
    ReadKeyNames,
    ReadSectionNames,
    ReadSection,
    WriteSection,
    DeleteSection,
    RefreshIniFileMapping
} INIFILE_OPERATION;

typedef struct _INIFILE_PARAMETERS {
    INIFILE_OPERATION Operation;
    BOOLEAN WriteOperation;
    BOOLEAN Unicode;
    BOOLEAN ValueBufferAllocated;
    PINIFILE_MAPPING_FILENAME IniFileNameMapping;
    PINIFILE_CACHE IniFile;
    UNICODE_STRING BaseFileName;
    UNICODE_STRING FileName;
    UNICODE_STRING NtFileName;
    ANSI_STRING ApplicationName;
    ANSI_STRING VariableName;
    UNICODE_STRING ApplicationNameU;
    UNICODE_STRING VariableNameU;
    BOOLEAN MultiValueStrings;
    union {
        //
        // This structure filled in for write operations
        //
        struct {
            LPSTR ValueBuffer;
            ULONG ValueLength;
            PWSTR ValueBufferU;
            ULONG ValueLengthU;
        };
        //
        // This structure filled in for read operations
        //
        struct {
            ULONG ResultChars;
            ULONG ResultMaxChars;
            LPSTR ResultBuffer;
            PWSTR ResultBufferU;
        };
    };


    //
    // Remaining fields only valid when parsing an on disk .INI file mapped into
    // memory.
    //

    PVOID TextCurrent;
    PVOID TextStart;
    PVOID TextEnd;

    ANSI_STRING SectionName;
    ANSI_STRING KeywordName;
    ANSI_STRING KeywordValue;
    PANSI_STRING AnsiSectionName;
    PANSI_STRING AnsiKeywordName;
    PANSI_STRING AnsiKeywordValue;
    UNICODE_STRING SectionNameU;
    UNICODE_STRING KeywordNameU;
    UNICODE_STRING KeywordValueU;
    PUNICODE_STRING UnicodeSectionName;
    PUNICODE_STRING UnicodeKeywordName;
    PUNICODE_STRING UnicodeKeywordValue;
} INIFILE_PARAMETERS, *PINIFILE_PARAMETERS;

NTSTATUS
BaseDllInitializeIniFileMappings(
    PBASE_STATIC_SERVER_DATA StaticServerData
    );

NTSTATUS
BasepAcquirePrivilege(
    ULONG Privilege,
    PVOID *ReturnedState
    );

NTSTATUS
BasepAcquirePrivilegeEx(
    ULONG Privilege,
    PVOID *ReturnedState
    );

VOID
BasepReleasePrivilege(
    PVOID StatePointer
    );

ULONG BaseDllTag;

#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( BaseDllTag, t ))

#define TMP_TAG 0
#define BACKUP_TAG 1
#define INI_TAG 2
#define FIND_TAG 3
#define GMEM_TAG 4
#define LMEM_TAG 5
#define ENV_TAG 6
#define RES_TAG 7
#define VDM_TAG 8


#include <vdmapi.h>
#include "vdm.h"
#include "basevdm.h"

#include "stdlib.h"     // for atol
#include "stdio.h"     // for atol

#endif // _BASEP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\basertl.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basertl.h

Abstract:

    This is the main include file for the runtime routines that are shared
    by the client and server sides of the Windows Base API implementation.

Author:

    Steve Wood (stevewo) 25-Oct-1990

Revision History:

--*/

#if DBG
#undef RTLHEAP_TRACE_CALLS
#else
#undef RTLHEAP_TRACE_CALLS
#endif

NTSTATUS
BaseRtlCreateAtomTable(
    IN ULONG NumberOfBuckets,
    IN ULONG MaxAtomTableSize,
    OUT PVOID *AtomTableHandle
    );

NTSTATUS
BaseRtlDestroyAtomTable(
    IN PVOID AtomTableHandle
    );

NTSTATUS
BaseRtlAddAtomToAtomTable(
    IN PVOID AtomTableHandle,
    IN PUNICODE_STRING AtomName,
    IN PULONG AtomValue OPTIONAL,
    OUT PULONG Atom OPTIONAL
    );

NTSTATUS
BaseRtlLookupAtomInAtomTable(
    IN PVOID AtomTableHandle,
    IN PUNICODE_STRING AtomName,
    OUT PULONG AtomValue OPTIONAL,
    OUT PULONG Atom OPTIONAL
    );

NTSTATUS
BaseRtlSetAtomValueInAtomTable(
    IN PVOID AtomTableHandle,
    IN PUNICODE_STRING AtomName,
    IN ULONG AtomValue
    );

NTSTATUS
BaseRtlDeleteAtomFromAtomTable(
    IN PVOID AtomTableHandle,
    IN ULONG Atom
    );

NTSTATUS
BaseRtlQueryAtomInAtomTable(
    IN PVOID AtomTableHandle,
    IN ULONG Atom,
    IN OUT PUNICODE_STRING AtomName OPTIONAL,
    OUT PULONG AtomValue OPTIONAL,
    OUT PULONG AtomUsage OPTIONAL
    );

typedef struct _BASE_HANDLE_TABLE_ENTRY {
    USHORT LockCount;
    USHORT Flags;
    union {
        struct _BASE_HANDLE_TABLE_ENTRY *Next;      // Free handle
        PVOID Object;                               // Allocated handle
        ULONG Size;                                 // Handle to discarded obj.
    } u;
} BASE_HANDLE_TABLE_ENTRY, *PBASE_HANDLE_TABLE_ENTRY;

#define BASE_HANDLE_FREE        (USHORT)0x0001
#define BASE_HANDLE_MOVEABLE    (USHORT)0x0002
#define BASE_HANDLE_DISCARDABLE (USHORT)0x0004
#define BASE_HANDLE_DISCARDED   (USHORT)0x0008
#define BASE_HANDLE_SHARED      (USHORT)0x8000

//
// Handles are 32-bit pointers to the u.Object field of a
// BASE_HANDLE_TABLE_ENTRY.  Since this field is 4 bytes into the
// structure and the structures are always on 8 byte boundaries, we can
// test the 0x4 bit to see if it is a handle.
//

#define BASE_HANDLE_MARK_BIT (ULONG)0x00000004
#define BASE_HEAP_FLAG_MOVEABLE  HEAP_SETTABLE_USER_FLAG1
#define BASE_HEAP_FLAG_DDESHARE  HEAP_SETTABLE_USER_FLAG2

typedef struct _BASE_HANDLE_TABLE {
    ULONG MaximumNumberOfHandles;
    PBASE_HANDLE_TABLE_ENTRY FreeHandles;
    PBASE_HANDLE_TABLE_ENTRY CommittedHandles;
    PBASE_HANDLE_TABLE_ENTRY UnusedCommittedHandles;
    PBASE_HANDLE_TABLE_ENTRY UnCommittedHandles;
    PBASE_HANDLE_TABLE_ENTRY MaxReservedHandles;
} BASE_HANDLE_TABLE, *PBASE_HANDLE_TABLE;

NTSTATUS
BaseRtlInitializeHandleTable(
    IN ULONG MaximumNumberOfHandles,
    OUT PBASE_HANDLE_TABLE HandleTable
    );

NTSTATUS
BaseRtlDestroyHandleTable(
    IN OUT PBASE_HANDLE_TABLE HandleTable
    );

PBASE_HANDLE_TABLE_ENTRY
BaseRtlAllocateHandle(
    IN PBASE_HANDLE_TABLE HandleTable
    );

BOOLEAN
BaseRtlFreeHandle(
    IN PBASE_HANDLE_TABLE HandleTable,
    IN PBASE_HANDLE_TABLE_ENTRY Handle
    );


//
// These structures are kept in the global shared memory section created
// in the server and mapped readonly into each client address space when
// they connect to the server.
//

typedef struct _INIFILE_MAPPING_TARGET {
    struct _INIFILE_MAPPING_TARGET *Next;
    UNICODE_STRING RegistryPath;
} INIFILE_MAPPING_TARGET, *PINIFILE_MAPPING_TARGET;

typedef struct _INIFILE_MAPPING_VARNAME {
    struct _INIFILE_MAPPING_VARNAME *Next;
    UNICODE_STRING Name;
    ULONG MappingFlags;
    PINIFILE_MAPPING_TARGET MappingTarget;
} INIFILE_MAPPING_VARNAME, *PINIFILE_MAPPING_VARNAME;

#define INIFILE_MAPPING_WRITE_TO_INIFILE_TOO    0x00000001
#define INIFILE_MAPPING_INIT_FROM_INIFILE       0x00000002
#define INIFILE_MAPPING_READ_FROM_REGISTRY_ONLY 0x00000004
#define INIFILE_MAPPING_APPEND_BASE_NAME        0x10000000
#define INIFILE_MAPPING_APPEND_APPLICATION_NAME 0x20000000
#define INIFILE_MAPPING_SOFTWARE_RELATIVE       0x40000000
#define INIFILE_MAPPING_USER_RELATIVE           0x80000000

typedef struct _INIFILE_MAPPING_APPNAME {
    struct _INIFILE_MAPPING_APPNAME *Next;
    UNICODE_STRING Name;
    PINIFILE_MAPPING_VARNAME VariableNames;
    PINIFILE_MAPPING_VARNAME DefaultVarNameMapping;
} INIFILE_MAPPING_APPNAME, *PINIFILE_MAPPING_APPNAME;

typedef struct _INIFILE_MAPPING_FILENAME {
    struct _INIFILE_MAPPING_FILENAME *Next;
    UNICODE_STRING Name;
    PINIFILE_MAPPING_APPNAME ApplicationNames;
    PINIFILE_MAPPING_APPNAME DefaultAppNameMapping;
} INIFILE_MAPPING_FILENAME, *PINIFILE_MAPPING_FILENAME;


typedef struct _INIFILE_MAPPING {
    PINIFILE_MAPPING_FILENAME FileNames;
    PINIFILE_MAPPING_FILENAME DefaultFileNameMapping;
    PINIFILE_MAPPING_FILENAME WinIniFileMapping;
    ULONG Reserved;
} INIFILE_MAPPING, *PINIFILE_MAPPING;



//
// NLS Information.
//

#define NLS_INVALID_INFO_CHAR  0xffff       /* marks cache string as invalid */

#define MAX_REG_VAL_SIZE       80           /* max size of registry value */

typedef struct _NLS_USER_INFO {
    WCHAR sAbbrevLangName[MAX_REG_VAL_SIZE];
    WCHAR iCountry[MAX_REG_VAL_SIZE];
    WCHAR sCountry[MAX_REG_VAL_SIZE];
    WCHAR sList[MAX_REG_VAL_SIZE];
    WCHAR iMeasure[MAX_REG_VAL_SIZE];
    WCHAR sDecimal[MAX_REG_VAL_SIZE];
    WCHAR sThousand[MAX_REG_VAL_SIZE];
    WCHAR sGrouping[MAX_REG_VAL_SIZE];
    WCHAR iDigits[MAX_REG_VAL_SIZE];
    WCHAR iLZero[MAX_REG_VAL_SIZE];
    WCHAR iNegNumber[MAX_REG_VAL_SIZE];
    WCHAR sCurrency[MAX_REG_VAL_SIZE];
    WCHAR sMonDecSep[MAX_REG_VAL_SIZE];
    WCHAR sMonThouSep[MAX_REG_VAL_SIZE];
    WCHAR sMonGrouping[MAX_REG_VAL_SIZE];
    WCHAR iCurrDigits[MAX_REG_VAL_SIZE];
    WCHAR iCurrency[MAX_REG_VAL_SIZE];
    WCHAR iNegCurr[MAX_REG_VAL_SIZE];
    WCHAR sPosSign[MAX_REG_VAL_SIZE];
    WCHAR sNegSign[MAX_REG_VAL_SIZE];
    WCHAR sTimeFormat[MAX_REG_VAL_SIZE];
    WCHAR sTime[MAX_REG_VAL_SIZE];
    WCHAR iTime[MAX_REG_VAL_SIZE];
    WCHAR iTLZero[MAX_REG_VAL_SIZE];
    WCHAR iTimeMarkPosn[MAX_REG_VAL_SIZE];
    WCHAR s1159[MAX_REG_VAL_SIZE];
    WCHAR s2359[MAX_REG_VAL_SIZE];
    WCHAR sShortDate[MAX_REG_VAL_SIZE];
    WCHAR sDate[MAX_REG_VAL_SIZE];
    WCHAR iDate[MAX_REG_VAL_SIZE];
    WCHAR sLongDate[MAX_REG_VAL_SIZE];
    WCHAR iCalType[MAX_REG_VAL_SIZE];
    WCHAR iFirstDay[MAX_REG_VAL_SIZE];
    WCHAR iFirstWeek[MAX_REG_VAL_SIZE];
    WCHAR sLocale[MAX_REG_VAL_SIZE];
    LCID  UserLocaleId;
    BOOL  fCacheValid;
} NLS_USER_INFO, *PNLS_USER_INFO;


BOOLEAN
BaseRtlInitialize(
    PVOID DllHandle,
    PVOID Heap,
    ULONG TagBase
    );

ULONG BaseRtlTag;
PVOID BaseRtlHeap;

#define MAKE_RTL_TAG( t ) (RTL_HEAP_MAKE_TAG( BaseRtlTag, t ))

#define ATOM_TAG 0

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\cpldebug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME ""
#endif	// SZ_COMPNAME



static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
        if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
            break;
    }
    wsprintf(ach, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
	_AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  

    wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
	OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
	_DebugMsg(pszMsg);
	_asm {int 3};
}

#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP	_DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\base.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    base.h

Abstract:

    This include file defines the type and constant definitions that are
    shared by the client and server portions of the BASE portion of the
    Windows subsystem.

Author:

    Steve Wood (stevewo) 25-Oct-1990

Revision History:

--*/

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winbasep.h>
#include <string.h>
#include <stdarg.h>

//
// Define debugging flag as false if not defined already.
//

#ifndef DBG
#define DBG 0
#endif


//
// Define IF_DEBUG macro that can be used to enable debugging code that is
// optimized out if the debugging flag is false.
//

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

//
// Include Windows Subsystem common definitions
//

#include <winss.h>

//
// Include definitions for the runtime DLL shared between the client and
// server portions of the Base portion of the Windows subsystem
//

#include "basertl.h"

#define WIN32_SS_PIPE_FORMAT_STRING    "\\Device\\NamedPipe\\Win32Pipes.%08x.%08x"

typedef struct _BASE_STATIC_SERVER_DATA {
                UNICODE_STRING WindowsDirectory;
                UNICODE_STRING WindowsSystemDirectory;
                UNICODE_STRING NamedObjectDirectory;
                USHORT WindowsMajorVersion;
                USHORT WindowsMinorVersion;
                USHORT BuildNumber;
                WCHAR CSDVersion[ 128 ];
                SYSTEM_BASIC_INFORMATION SysInfo;
                SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;
                PINIFILE_MAPPING IniFileMapping;
                NLS_USER_INFO NlsUserInfo;
                BOOLEAN DefaultSeparateVDM;
                ULONG BaseRtlTag;
                ULONG LogicalDrives;
                UCHAR DriveTypes[ 32 ];
} BASE_STATIC_SERVER_DATA, *PBASE_STATIC_SERVER_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\basemsg.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basemsg.h

Abstract:

    This include file defines the message formats used to communicate
    between the client and server portions of the BASE portion of the
    Windows subsystem.

Author:

    Steve Wood (stevewo) 25-Oct-1990

Revision History:

--*/

//
// This structure is filled in by the client prior to connecting to the BASESRV
// DLL in the Windows subsystem server.  The server DLL will fill in the OUT
// fields if prior to accepting the connection.
//

typedef struct _BASESRV_API_CONNECTINFO {
    IN ULONG ExpectedVersion;
    OUT HANDLE DefaultObjectDirectory;
    OUT ULONG WindowsVersion;
    OUT ULONG CurrentVersion;
    OUT ULONG DebugFlags;
    OUT WCHAR WindowsDirectory[ MAX_PATH ];
    OUT WCHAR WindowsSystemDirectory[ MAX_PATH ];
} BASESRV_API_CONNECTINFO, *PBASESRV_API_CONNECTINFO;

#define BASESRV_VERSION 0x10000

//
// Message format for messages sent from the client to the server
//

typedef enum _BASESRV_API_NUMBER {
    BasepGlobalAddAtom = BASESRV_FIRST_API_NUMBER,
    BasepGlobalFindAtom,
    BasepGlobalDeleteAtom,
    BasepGlobalGetAtomName,
    BasepCreateProcess,
    BasepCreateThread,
    BasepGetTempFile,
    BasepExitProcess,
    BasepDebugProcess,
    BasepCheckVDM,
    BasepUpdateVDMEntry,
    BasepGetNextVDMCommand,
    BasepExitVDM,
    BasepIsFirstVDM,
    BasepGetVDMExitCode,
    BasepSetReenterCount,
    BasepSetProcessShutdownParam,
    BasepGetProcessShutdownParam,
    BasepNlsSetUserInfo,
    BasepNlsSetMultipleUserInfo,
    BasepNlsCreateSortSection,
    BasepNlsPreserveSection,
    BasepDefineDosDevice,
    BasepSetVDMCurDirs,
    BasepGetVDMCurDirs,
    BasepBatNotification,
    BasepRegisterWowExec,
    BasepSoundSentryNotification,
    BasepRefreshIniFileMapping,
    BasepRefreshDriveType,
#ifdef NTUSERK
    BasepDestroyGlobalAtomTable,
#endif
    BasepMaxApiNumber
} BASESRV_API_NUMBER, *PBASESRV_API_NUMBER;

typedef struct _BASE_NLS_SET_USER_INFO_MSG {
    LPWSTR pValue;
    LPWSTR pCacheString;
    LPWSTR pData;
    ULONG DataLength;
} BASE_NLS_SET_USER_INFO_MSG, *PBASE_NLS_SET_USER_INFO_MSG;

typedef struct _BASE_NLS_SET_MULTIPLE_USER_INFO_MSG {
    ULONG Flags;
    ULONG DataLength;
    LPWSTR pPicture;
    LPWSTR pSeparator;
    LPWSTR pOrder;
    LPWSTR pTLZero;
    LPWSTR pTimeMarkPosn;
} BASE_NLS_SET_MULTIPLE_USER_INFO_MSG, *PBASE_NLS_SET_MULTIPLE_USER_INFO_MSG;

typedef struct _BASE_NLS_CREATE_SORT_SECTION_MSG {
    UNICODE_STRING SectionName;
    HANDLE hNewSection;
    LARGE_INTEGER SectionSize;
} BASE_NLS_CREATE_SORT_SECTION_MSG, *PBASE_NLS_CREATE_SORT_SECTION_MSG;

typedef struct _BASE_NLS_PRESERVE_SECTION_MSG {
    HANDLE hSection;
} BASE_NLS_PRESERVE_SECTION_MSG, *PBASE_NLS_PRESERVE_SECTION_MSG;

typedef struct _BASE_DEFINEDOSDEVICE_MSG {
    ULONG Flags;
    UNICODE_STRING DeviceName;
    UNICODE_STRING TargetPath;
} BASE_DEFINEDOSDEVICE_MSG, *PBASE_DEFINEDOSDEVICE_MSG;

typedef struct _BASE_SHUTDOWNPARAM_MSG {
    ULONG ShutdownLevel;
    ULONG ShutdownFlags;
} BASE_SHUTDOWNPARAM_MSG, *PBASE_SHUTDOWNPARAM_MSG;

//
// Used for Add, Find and GetAtomName
//
typedef struct _BASE_GLOBALATOMNAME_MSG {
    ULONG Atom;
    BOOLEAN AtomNameInClient;
    UNICODE_STRING AtomName;
} BASE_GLOBALATOMNAME_MSG, *PBASE_GLOBALATOMNAME_MSG;

typedef struct _BASE_GLOBALDELETEATOM_MSG {
    ULONG Atom;
} BASE_GLOBALDELETEATOM_MSG, *PBASE_GLOBALDELETEATOM_MSG;

typedef struct _BASE_CREATEPROCESS_MSG {
    HANDLE ProcessHandle;
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;
    CLIENT_ID DebuggerClientId;
    ULONG CreationFlags;
    ULONG IsVDM;
    HANDLE hVDM;
} BASE_CREATEPROCESS_MSG, *PBASE_CREATEPROCESS_MSG;

typedef struct _BASE_CREATETHREAD_MSG {
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;
} BASE_CREATETHREAD_MSG, *PBASE_CREATETHREAD_MSG;

typedef struct _BASE_GETTEMPFILE_MSG {
    UINT uUnique;
} BASE_GETTEMPFILE_MSG, *PBASE_GETTEMPFILE_MSG;

typedef struct _BASE_EXITPROCESS_MSG {
    UINT uExitCode;
} BASE_EXITPROCESS_MSG, *PBASE_EXITPROCESS_MSG;

typedef struct _BASE_DEBUGPROCESS_MSG {
    DWORD dwProcessId;
    CLIENT_ID DebuggerClientId;
    PVOID AttachCompleteRoutine;
} BASE_DEBUGPROCESS_MSG, *PBASE_DEBUGPROCESS_MSG;

typedef struct _BASE_CHECKVDM_MSG {
    ULONG  iTask;		// Only for WOW
    HANDLE ConsoleHandle;
    ULONG  BinaryType;
    HANDLE WaitObjectForParent;
    HANDLE StdIn;
    HANDLE StdOut;
    HANDLE StdErr;
    PCHAR  CmdLine;
    PCHAR  Env;
    USHORT CurDrive;
    USHORT CmdLen;
    USHORT VDMState;
    ULONG  EnvLen;
    ULONG  CodePage;
    ULONG  dwCreationFlags;
    LPSTARTUPINFOA StartupInfo;
    PCHAR  Desktop;
    ULONG  DesktopLen;
    PCHAR  Title;
    ULONG  TitleLen;
    PCHAR  Reserved;
    ULONG  ReservedLen;
    PCHAR  CurDirectory;
    ULONG  CurDirectoryLen;
} BASE_CHECKVDM_MSG, *PBASE_CHECKVDM_MSG;

typedef struct _BASE_UPDATE_VDM_ENTRY_MSG {
    ULONG  iTask;		// Only for WOW
    HANDLE ConsoleHandle;
    HANDLE VDMProcessHandle;
    WORD   EntryIndex;
    WORD   VDMCreationState;
    HANDLE WaitObjectForParent;
} BASE_UPDATE_VDM_ENTRY_MSG, *PBASE_UPDATE_VDM_ENTRY_MSG;

typedef struct _BASE_GET_NEXT_VDM_COMMAND_MSG {
    HANDLE ConsoleHandle;
    HANDLE StdIn;
    HANDLE StdOut;
    HANDLE StdErr;
    PCHAR  CmdLine;
    PCHAR  Env;
    USHORT CurrentDrive;
    USHORT CmdLen;
    ULONG  EnvLen;
    ULONG  ExitCode;
    ULONG  VDMState;
    ULONG  iTask;
    HANDLE WaitObjectForVDM;
    ULONG  CodePage;
    ULONG  dwCreationFlags;
    LPSTARTUPINFOA StartupInfo;
    PCHAR  Desktop;
    ULONG  DesktopLen;
    PCHAR  Title;
    ULONG  TitleLen;
    PCHAR  Reserved;
    ULONG  ReservedLen;
    PCHAR  CurDirectory;
    ULONG  CurDirectoryLen;
    ULONG  fComingFromBat;
} BASE_GET_NEXT_VDM_COMMAND_MSG, *PBASE_GET_NEXT_VDM_COMMAND_MSG;

typedef struct _BASE_EXIT_VDM_MSG {
    HANDLE ConsoleHandle;
    ULONG  iWowTask;
    HANDLE WaitObjectForVDM;
} BASE_EXIT_VDM_MSG, *PBASE_EXIT_VDM_MSG;

typedef struct _BASE_SET_REENTER_COUNT {
    HANDLE ConsoleHandle;
    ULONG  fIncDec;
} BASE_SET_REENTER_COUNT_MSG, *PBASE_SET_REENTER_COUNT_MSG;

typedef struct _BASE_IS_FIRST_VDM_MSG {
    BOOL    FirstVDM;
} BASE_IS_FIRST_VDM_MSG, *PBASE_IS_FIRST_VDM_MSG;

typedef struct _BASE_GET_VDM_EXIT_CODE_MSG {
    HANDLE ConsoleHandle;
    HANDLE hParent;
    ULONG  ExitCode;
} BASE_GET_VDM_EXIT_CODE_MSG, *PBASE_GET_VDM_EXIT_CODE_MSG;

typedef struct _BASE_GET_SET_VDM_CUR_DIRS_MSG {
    HANDLE ConsoleHandle;
    PCHAR  lpszzCurDirs;
    ULONG  cchCurDirs;
} BASE_GET_SET_VDM_CUR_DIRS_MSG, *PBASE_GET_SET_VDM_CUR_DIRS_MSG;

typedef struct _BASE_BAT_NOTIFICATION_MSG {
    HANDLE ConsoleHandle;
    ULONG  fBeginEnd;
} BASE_BAT_NOTIFICATION_MSG, *PBASE_BAT_NOTIFICATION_MSG;

typedef struct _BASE_REGISTER_WOWEXEC_MSG {
    HANDLE hwndWowExec;
} BASE_REGISTER_WOWEXEC_MSG, *PBASE_REGISTER_WOWEXEC_MSG;

typedef struct _BASE_SOUNDSENTRY_NOTIFICATION_MSG {
    ULONG  VideoMode;
} BASE_SOUNDSENTRY_NOTIFICATION_MSG, *PBASE_SOUNDSENTRY_NOTIFICATION_MSG;

typedef struct _BASE_REFRESHINIFILEMAPPING_MSG {
    UNICODE_STRING IniFileName;
} BASE_REFRESHINIFILEMAPPING_MSG, *PBASE_REFRESHINIFILEMAPPING_MSG;

typedef struct _BASE_REFRESHDRIVETYPE_MSG {
    ULONG DriveNumber;
} BASE_REFRESHDRIVETYPE_MSG, *PBASE_REFRESHDRIVETYPE_MSG;

#ifdef NTUSERK
typedef struct _BASE_DESTROYGLOBALATOMTABLE_MSG {
    PVOID GlobalAtomTable;
} BASE_DESTROYGLOBALATOMTABLE_MSG, *PBASE_DESTROYGLOBALATOMTABLE_MSG;
#endif

typedef struct _BASE_API_MSG {
    PORT_MESSAGE h;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CSR_API_NUMBER ApiNumber;
    ULONG ReturnValue;
    ULONG Reserved;
    union {
        BASE_NLS_SET_USER_INFO_MSG NlsSetUserInfo;
        BASE_NLS_SET_MULTIPLE_USER_INFO_MSG NlsSetMultipleUserInfo;
        BASE_NLS_CREATE_SORT_SECTION_MSG NlsCreateSortSection;
        BASE_NLS_PRESERVE_SECTION_MSG NlsPreserveSection;
        BASE_DEFINEDOSDEVICE_MSG DefineDosDeviceApi;
        BASE_SHUTDOWNPARAM_MSG ShutdownParam;
        BASE_GLOBALATOMNAME_MSG GlobalAtomName;
        BASE_GLOBALDELETEATOM_MSG GlobalDeleteAtom;
        BASE_CREATEPROCESS_MSG CreateProcess;
        BASE_CREATETHREAD_MSG CreateThread;
        BASE_GETTEMPFILE_MSG GetTempFile;
        BASE_EXITPROCESS_MSG ExitProcess;
        BASE_DEBUGPROCESS_MSG DebugProcess;
        BASE_CHECKVDM_MSG CheckVDM;
        BASE_UPDATE_VDM_ENTRY_MSG UpdateVDMEntry;
        BASE_GET_NEXT_VDM_COMMAND_MSG GetNextVDMCommand;
        BASE_EXIT_VDM_MSG ExitVDM;
        BASE_IS_FIRST_VDM_MSG IsFirstVDM;
        BASE_GET_VDM_EXIT_CODE_MSG GetVDMExitCode;
        BASE_SET_REENTER_COUNT_MSG SetReenterCount;
        BASE_GET_SET_VDM_CUR_DIRS_MSG GetSetVDMCurDirs;
        BASE_BAT_NOTIFICATION_MSG BatNotification;
        BASE_REGISTER_WOWEXEC_MSG RegisterWowExec;
        BASE_SOUNDSENTRY_NOTIFICATION_MSG SoundSentryNotification;
        BASE_REFRESHINIFILEMAPPING_MSG RefreshIniFileMapping;
        BASE_REFRESHDRIVETYPE_MSG RefreshDriveType;
#ifdef NTUSERK
        BASE_DESTROYGLOBALATOMTABLE_MSG DestroyGlobalAtomTable;
#endif
    } u;
} BASE_API_MSG, *PBASE_API_MSG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\basevdm.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basevdm.h

Abstract:

    This module contains private function prototypes
    and types for vdm support.

Author:

    Sudeep Bharati (sudeepb) 15-Sep-1991

Revision History:

--*/

#define ROUND_UP(n,size)	(((ULONG)(n) + (size - 1)) & ~(size - 1))

// Update VDM entry indexes

#define UPDATE_VDM_UNDO_CREATION    0
#define UPDATE_VDM_PROCESS_HANDLE   1
#define UPDATE_VDM_HOOKED_CTRLC     2


// Undo VDM Creation States

#define VDM_PARTIALLY_CREATED	    1
#define VDM_FULLY_CREATED	    2
#define VDM_BEING_REUSED	    4
#define VDM_CREATION_SUCCESSFUL     8

// Defines for BinaryType

#define BINARY_TYPE_DOS 	    0x10
#define BINARY_TYPE_WIN16	    0x20
#define BINARY_SUBTYPE_MASK	    0xF
#define BINARY_TYPE_DOS_EXE	    01
#define BINARY_TYPE_DOS_COM	    02
#define BINARY_TYPE_DOS_PIF	    03

// Defines for VDMState

#define VDM_NOT_PRESENT 	    1
#define VDM_PRESENT_NOT_READY	    2
#define VDM_PRESENT_AND_READY	    4

#define VDM_STATE_MASK		    7


#define EXIT_VDM		    1
#define EXIT_VDM_NOTIFICATION	    2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\cabpack.c ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* CABPACK.C - Wizard to build a Win32 Self-Extracting and self-installing *
//*             EXE from a Cabinet (CAB) file.                              *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include "pch.h"
#pragma hdrstop
#include "cabpack.h"
#include <memory.h>
#include "sdsutils.h"

#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))
#define MAX_TARGVER     0xFFFFFFFF

#define FLAG_BLK        "OK"
#define FLAG_PMTYN      "YesNo"
#define FLAG_PMTOC      "OkCancel"

//***************************************************************************
//* GLOBAL VARIABLES                                                        *
//***************************************************************************

//---------------------------------------------------------------------------
// attention: 3\18\97: Update notes:
//                    We are changing our batch directive file extension from
//                    CDF to SED.  But all the internal data structure name 
//                    remain unchanged.  So if you see CDF, it means old CDF file
//                    or new SED file data.
//---------------------------------------------------------------------------

HINSTANCE    g_hInst        = NULL;     // Pointer to Instance
WIZARDSTATE *g_pWizardState = NULL;     // Pointer to global wizard state
BOOL         g_fQuitWizard  = FALSE;    // Global flag used to signal that we
                                        // want to terminate the wizard
                                        // ourselves
HFONT        g_hBigFont     = NULL;     // Bigger font used by dialogs.
extern CDF   g_CDF;                     // Contains stuff that we want to
                                        // store in the CABPack Directive
                                        // File
BOOL        g_fBuildNow;
FARPROC     g_lpfnOldMEditWndProc;
CHAR        g_szOverideCDF[MAX_PATH];
CHAR        g_szOverideSec[SMALL_BUF_LEN];
WORD        g_wQuietMode = 0;
WORD        g_wSilentMode = 0;
WORD        g_wRunDiamondMinimized = 0;
HFONT       g_hFont = NULL;

extern char         g_szInitialDir[];

BOOL IsOSNT3X(VOID);

// This table defines the dialog id's and functions for processing each page.
// Pages need only provide functions when they want non-default behavior for
// certain action (init,buttons,notifications,next/back/finish,cancel).

PAGEINFO PageInfo[NUM_WIZARD_PAGES] = {
    { IDD_WELCOME,    WelcomeInit,    WelcomeCmd,    NULL,        WelcomeOK,    NULL },
    { IDD_MODIFY,     ModifyInit,     NULL,          NULL,        ModifyOK,     NULL },
    { IDD_PACKPURPOSE,PackPurposeInit,PackPurposeCmd,NULL,        PackPurposeOK,NULL },
    { IDD_TITLE,      TitleInit,      NULL,          NULL,        TitleOK,      NULL },
    { IDD_PROMPT,     PromptInit,     PromptCmd,     NULL,        PromptOK,     NULL },
    { IDD_LICENSETXT, LicenseTxtInit, LicenseTxtCmd, NULL,        LicenseTxtOK, NULL },
    { IDD_FILES,      FilesInit,      FilesCmd,      FilesNotify, FilesOK,      NULL },
    { IDD_COMMAND,    CommandInit,    NULL,          NULL,        CommandOK,    NULL },
    { IDD_SHOWWINDOW, ShowWindowInit, NULL,          NULL,        ShowWindowOK, NULL },
    { IDD_FINISHMSG,  FinishMsgInit,  FinishMsgCmd,  NULL,        FinishMsgOK,  NULL },
    { IDD_TARGET,     TargetInit,     TargetCmd,     NULL,        TargetOK,     NULL },
    { IDD_TARGET_CAB, TargetCABInit,  TargetCABCmd,  NULL,        TargetCABOK,  NULL },
    { IDD_CABLABEL,   CabLabelInit,   CabLabelCmd,   NULL,        CabLabelOK,   NULL },
    { IDD_REBOOT,     RebootInit,     RebootCmd,     NULL,        RebootOK,     NULL },
    { IDD_SAVE,       SaveInit,       SaveCmd,       NULL,        SaveOK,       NULL },
    { IDD_CREATE,     CreateInit,     NULL,          NULL,        CreateOK,     NULL },
};

CDFSTRINGINFO CDFStrInfo[] = {
    { SEC_OPTIONS,  KEY_INSTPROMPT,     "", g_CDF.achPrompt,    sizeof(g_CDF.achPrompt),    g_szOverideSec, &g_CDF.fPrompt },
    { SEC_OPTIONS,  KEY_DSPLICENSE,     "", g_CDF.achLicense,   sizeof(g_CDF.achLicense),   g_szOverideSec, &g_CDF.fLicense },
    { SEC_OPTIONS,  KEY_ENDMSG,         "", g_CDF.achFinishMsg, sizeof(g_CDF.achFinishMsg), g_szOverideSec, &g_CDF.fFinishMsg },
    { SEC_OPTIONS,  KEY_PACKNAME,       "", g_CDF.achTarget,    sizeof(g_CDF.achTarget),    g_szOverideSec, NULL },
    { SEC_OPTIONS,  KEY_FRIENDLYNAME,   "", g_CDF.achTitle,     sizeof(g_CDF.achTitle),     g_szOverideSec, NULL },
    { SEC_OPTIONS,  KEY_APPLAUNCH,      "", g_CDF.achOrigiInstallCmd,sizeof(g_CDF.achInstallCmd),g_szOverideSec, NULL },
    { SEC_OPTIONS,  KEY_POSTAPPLAUNCH,  "", g_CDF.achOrigiPostInstCmd,sizeof(g_CDF.achPostInstCmd),g_szOverideSec, NULL },
    { SEC_OPTIONS,  KEY_ADMQCMD,        "", g_CDF.szOrigiAdmQCmd,    sizeof(g_CDF.szOrigiAdmQCmd),    g_szOverideSec, NULL },
    { SEC_OPTIONS,  KEY_USERQCMD,       "", g_CDF.szOrigiUsrQCmd,    sizeof(g_CDF.szOrigiUsrQCmd),    g_szOverideSec, NULL },
} ;

CDFOPTINFO CDFOptInfo[] = {
    { KEY_NOEXTRACTUI,  EXTRACTOPT_UI_NO },
    { KEY_USELFN,       EXTRACTOPT_LFN_YES },
    { KEY_PLATFORM_DIR, EXTRACTOPT_PLATFORM_DIR },
    { KEY_NESTCOMPRESSED, EXTRACTOPT_COMPRESSED },
    { KEY_UPDHELPDLLS,  EXTRACTOPT_UPDHLPDLLS },
    { KEY_CHKADMRIGHT,  EXTRACTOPT_CHKADMRIGHT },
    { KEY_PASSRETURN,   EXTRACTOPT_PASSINSTRET },
    { KEY_PASSRETALWAYS,EXTRACTOPT_PASSINSTRETALWAYS },
    { KEY_CMDSDEPENDED, EXTRACTOPT_CMDSDEPENDED },
};

CHAR *AdvDlls[] = { ADVANCEDLL, ADVANCEDLL32, ADVANCEDLL16 };
PSTR pResvSizes[] = { CAB_0K, CAB_2K, CAB_4K, CAB_6K };
void SetControlFont();
void TermApp();

//***************************************************************************
//*                                                                         *
//* NAME:       WinMain                                                     *
//*                                                                         *
//* SYNOPSIS:   Main entry point for the program.                           *
//*                                                                         *
//* REQUIRES:   hInstance:      Handle to the program instance              *
//*             hPrevInstance:  Handle to the previous instance (NULL)      *
//*             lpszCmdLine:    Command line arguments                      *
//*             nCmdShow:       How to show the window                      *
//*                                                                         *
//* RETURNS:    int:            Always 0                                    *
//*                                                                         *
//***************************************************************************
INT WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPSTR lpszCmdLine, INT nCmdShow )
{
    g_hInst = hInstance;
    g_fBuildNow = FALSE;
    g_szOverideCDF[0] = 0;
    g_szOverideSec[0] = 0;

    // init CDF filenaem
    g_CDF.achFilename[0] = '\0';
    g_CDF.achVerInfo[0] = '\0';
    g_CDF.lpszCookie = NULL;

    InitItemList();                     // Initilize our file item list.
    // Get the command line args.  If there is a "/N", then we want to
    // build NOW!


    if ( !ParseCmdLine( lpszCmdLine ) )
    {
        ErrorMsg( NULL, IDS_ERR_BADCMDLINE );
        return 1;  //error return case
    }

    if ( g_fBuildNow && lstrlen( g_CDF.achFilename ) > 0 )
    {
        // batch mode did not update the CDF file, no need for writeCDF
        if ( ReadCDF( NULL ) && MakePackage( NULL ) )
        {
            return 0;
        }
        else
        {
            return 1;
        }
    }

    // Allocate global structures
    g_pWizardState = (PWIZARDSTATE) malloc( sizeof( WIZARDSTATE) );

    if ( ! g_pWizardState )  {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
    } else  {
        SetControlFont();

        RunCABPackWizard();

        if (g_hFont)
            DeleteObject(g_hFont);
    }

    // Clean up dialog title font
    DestroyBigFont();
    TermApp();

    // Free global structures
    if ( g_pWizardState )  {
        free( g_pWizardState );
    }

    return 0;
}


// Free up the allocated resource
//
void TermApp()
{
    if ( g_CDF.lpszCookie )
    {
        LocalFree( g_CDF.lpszCookie );
    }

    if ( g_CDF.pVerInfo )
        LocalFree( g_CDF.pVerInfo );
}

//***************************************************************************
//*                                                                         *
//* NAME:       RunCABPackWizard                                            *
//*                                                                         *
//* SYNOPSIS:   Creates property sheet pages, initializes wizard property   *
//*             sheet and runs wizard.                                      *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:       TRUE if user runs wizard to completion, FALSE   *
//*                         if user cancels or an error occurs.             *
//*                                                                         *
//* NOTES:      Wizard pages all use one dialog proc (GenDlgProc). They may *
//*             specify their own handler procs to get called at init time  *
//*             or in response to Next, Cancel or a dialog control, or use  *
//*             the default behavior of GenDlgProc.                         *
//*                                                                         *
//***************************************************************************
BOOL RunCABPackWizard( VOID )
{
    HPROPSHEETPAGE  hWizPage[NUM_WIZARD_PAGES]; // array to hold handles to pages
    PROPSHEETPAGE   psPage;     // struct used to create prop sheet pages
    PROPSHEETHEADER psHeader;   // struct used to run wizard property sheet
    UINT            nPageIndex;
    UINT            nFreeIndex;
    INT_PTR         iRet;


    ASSERT( g_pWizardState );

    // initialize the app state structure
    InitWizardState( g_pWizardState );

    // zero out structures
    memset( &hWizPage, 0, sizeof(hWizPage) );
    memset( &psPage, 0, sizeof(psPage) );
    memset( &psHeader, 0, sizeof(psHeader) );

    // fill out common data property sheet page struct
    psPage.dwSize       = sizeof(psPage);
    psPage.dwFlags      = PSP_DEFAULT;
    psPage.hInstance    = g_hInst;
    psPage.pfnDlgProc   = GenDlgProc;

    // create a property sheet page for each page in the wizard
    for ( nPageIndex = 0; nPageIndex < NUM_WIZARD_PAGES; nPageIndex++ )  {
        psPage.pszTemplate = MAKEINTRESOURCE( PageInfo[nPageIndex].uDlgID );
        // set a pointer to the PAGEINFO struct as the private data for this
        // page
        psPage.lParam = (LPARAM) &PageInfo[nPageIndex];

        hWizPage[nPageIndex] = CreatePropertySheetPage( &psPage );

        if ( !hWizPage[nPageIndex] ) {
            // creating page failed, free any pages already created and bail
            ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
            for ( nFreeIndex = 0; nFreeIndex < nPageIndex; nFreeIndex++ ) {
                DestroyPropertySheetPage( hWizPage[nFreeIndex] );
            }

            return FALSE;
        }
    }

    // fill out property sheet header struct
    psHeader.dwSize     = sizeof(psHeader);
    psHeader.dwFlags    = PSH_WIZARD | PSH_USEICONID;
    psHeader.hwndParent = NULL;
    psHeader.hInstance  = g_hInst;
    psHeader.nPages     = NUM_WIZARD_PAGES;
    psHeader.phpage     = hWizPage;
    psHeader.pszIcon    = (LPSTR) IDI_ICON;

    // run the Wizard
    iRet = PropertySheet( &psHeader );

    if ( iRet < 0 ) {
        // property sheet failed, most likely due to lack of memory
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
    }

    // If the user Cancels out of the Wizard, there may be items
    // left in the file list.  Clean them up.
    DeleteAllItems();
    return ( iRet > 0 );
}


//***************************************************************************
//*                                                                         *
//* NAME:       GenDlgProc                                                  *
//*                                                                         *
//* SYNOPSIS:   Generic dialog proc for all wizard pages.                   *
//*                                                                         *
//* REQUIRES:   hDlg:                                                       *
//*             uMsg:                                                       *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//*                                                                         *
//* NOTES:      This dialog proc provides the following default behavior:   *
//*               init:       back and next buttons enabled                 *
//*               next btn:   switches to page following current page       *
//*               back btn:   switches to previous page                     *
//*               cancel btn: prompts user to confirm, and cancels wizard   *
//*               dlg ctrl:   does nothing (in response to WM_COMMANDs)     *
//*             Wizard pages can specify their own handler functions (in    *
//*             the PageInfo table) to override default behavior for any of *
//*             the above actions.                                          *
//*                                                                         *
//***************************************************************************
INT_PTR CALLBACK GenDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch ( uMsg ) {

      //*********************************************************************
        case WM_INITDIALOG:
      //*********************************************************************
        {
            LPPROPSHEETPAGE lpsp;       // get propsheet page struct passed in
            PPAGEINFO pPageInfo;        // fetch our private page info from
                                        // propsheet struct

            lpsp = (LPPROPSHEETPAGE) lParam;
            ASSERT( lpsp );
            pPageInfo = (PPAGEINFO) lpsp->lParam;
            ASSERT( pPageInfo );

            // store pointer to private page info in window data for later
            SetWindowLongPtr( hDlg, DWLP_USER, (LPARAM) pPageInfo );

            // set title text to large font
            InitBigFont( hDlg, IDC_BIGTEXT );

            // initialize 'back' and 'next' wizard buttons, if
            // page wants something different it can fix in init proc below
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT |
                                                               PSWIZB_BACK );

            // call init proc for this page if one is specified
            if ( pPageInfo->InitProc )  {
                return pPageInfo->InitProc( hDlg, TRUE );
            }

            return TRUE;

            break;
        }


      //*********************************************************************
        case WM_NOTIFY:
      //*********************************************************************
        {
            // get pointer to private page data out of window data
            PPAGEINFO pPageInfo;
            BOOL      fRet;
            BOOL      fKeepHistory = TRUE;
            NMHDR    *lpnm         = (NMHDR *) lParam;
            UINT      uNextPage    = 0;


            pPageInfo = (PPAGEINFO) GetWindowLongPtr( hDlg, DWLP_USER );
            ASSERT( pPageInfo );

            switch ( lpnm->code )  {

                //***********************************************************
                case PSN_SETACTIVE:
                //***********************************************************
                    // initialize 'back' and 'next' wizard buttons, if
                    // page wants something different it can fix in init proc
                    PropSheet_SetWizButtons( GetParent(hDlg), PSWIZB_NEXT |
                                                               PSWIZB_BACK );

                    // call init proc for this page if one is specified
                    if ( pPageInfo->InitProc )  {
                        return pPageInfo->InitProc(hDlg,FALSE);
                    }

                    return TRUE;

                    break;


                //***********************************************************
                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                //***********************************************************
                    // call OK proc for this page if one is specified
                    if ( pPageInfo->OKProc )
                        if ( ! pPageInfo->OKProc( hDlg, ( lpnm->code != PSN_WIZBACK ), &uNextPage, &fKeepHistory ) )
                        {
                            // stay on this page
                            SetPropSheetResult( hDlg, -1 );
                            return TRUE;
                        }

                    if ( lpnm->code != PSN_WIZBACK )  {
                        // 'next' pressed
                        ASSERT( g_pWizardState->uPagesCompleted <
                                                          NUM_WIZARD_PAGES );

                        // save the current page index in the page history,
                        // unless this page told us not to when we called
                        // its OK proc above
                        if ( fKeepHistory ) {
                            g_pWizardState->uPageHistory
                                            [g_pWizardState->uPagesCompleted]
                                            = g_pWizardState->uCurrentPage;
                            g_pWizardState->uPagesCompleted++;
                        }

                        // if no next page specified or no OK proc,
                        // advance page by one
                        if ( !uNextPage )  {
                            uNextPage = g_pWizardState->uCurrentPage + 1;
                        }
                    } else  {
                        // 'back' pressed
                        ASSERT( g_pWizardState->uPagesCompleted > 0 );

                        // get the last page from the history list
                        g_pWizardState->uPagesCompleted--;
                        uNextPage = g_pWizardState->
                                    uPageHistory[g_pWizardState->
                                    uPagesCompleted];
                    }

                    // if we need to exit the wizard now, send a 'cancel'
                    // message to ourselves (to keep the prop. page mgr happy)

                    if ( g_fQuitWizard ) {
                        PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
                        SetPropSheetResult( hDlg, -1 );
                        return TRUE;
                    }

                    // set next page, only if 'next' or 'back' button
                    // was pressed

                    if ( lpnm->code != PSN_WIZFINISH )  {
                        // set the next current page index
                        g_pWizardState->uCurrentPage = uNextPage;

                        // tell the prop sheet mgr what the next page to
                        // display is
                        SetPropSheetResult( hDlg,
                                            GetDlgIDFromIndex( uNextPage ) );
                        return TRUE;
                    }

                    break;


                //***********************************************************
                case PSN_QUERYCANCEL:
                //***********************************************************

                    // if global flag to exit is set, then this cancel
                    // is us pretending to push 'cancel' so prop page mgr
                    // will kill the wizard.  Let this through...

                    if ( g_fQuitWizard )  {
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
                        return TRUE;
                    }

                    // if this page has a special cancel proc, call it
                    if ( pPageInfo->CancelProc )
                        fRet = pPageInfo->CancelProc( hDlg );
                    else {
                        // default behavior: pop up a message box confirming
                        // the cancel
                        fRet = ( MsgBox( hDlg, IDS_QUERYCANCEL,
                                 MB_ICONQUESTION, MB_YESNO |
                                 MB_DEFBUTTON2 ) == IDYES );
                    }

                    // return the value thru window data
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, !fRet );
                    return TRUE;
                    break;


                //***********************************************************
                default:
                //***********************************************************

                    if ( pPageInfo->NotifyProc )  {
                        pPageInfo->NotifyProc( hDlg, wParam, lParam );
                    }
            }

            break;
        }


      //*********************************************************************
        case WM_COMMAND:
      //*********************************************************************
        {
            // get pointer to private page data out of window data
            PPAGEINFO pPageInfo;
            UINT      uNextPage    = 0;
            BOOL      fGotoPage    = FALSE;
            BOOL      fKeepHistory = TRUE;

            pPageInfo = (PPAGEINFO) GetWindowLongPtr( hDlg, DWLP_USER );
            ASSERT( pPageInfo );

            // if this page has a command handler proc, call it
            if ( pPageInfo->CmdProc )  {
                pPageInfo->CmdProc( hDlg, (UINT) LOWORD(wParam), &fGotoPage,
                                                 &uNextPage, &fKeepHistory );

                if ( fGotoPage )  {
                    ASSERT(   g_pWizardState->uPagesCompleted
                            < NUM_WIZARD_PAGES );
                    ASSERT( g_pWizardState->uPagesCompleted > 0 );

                    SetPropSheetResult( hDlg, uNextPage );
                    g_pWizardState->uCurrentPage = uNextPage;

                    if ( fKeepHistory ) {
                        g_pWizardState->uPageHistory[g_pWizardState->
                            uPagesCompleted] = g_pWizardState->uCurrentPage;
                        g_pWizardState->uPagesCompleted++;
                    }

                    // set the next current page index
                    g_pWizardState->uCurrentPage = uNextPage;

                    // tell the prop sheet mgr what the next page to
                    // display is
                    SetPropSheetResult( hDlg,
                                        GetDlgIDFromIndex( uNextPage ) );
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       InitWizardState                                             *
//*                                                                         *
//* SYNOPSIS:   Initializes wizard state structure.                         *
//*                                                                         *
//* REQUIRES:   pWizardState:                                               *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID InitWizardState( WIZARDSTATE *pWizardState )
{
    ASSERT( pWizardState );

    // zero out structure
    memset( pWizardState, 0, sizeof(WIZARDSTATE) );

    // set starting page
    pWizardState->uCurrentPage = ORD_PAGE_WELCOME;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MEditSubClassWnd                                            *
//*                                                                         *
//* SYNOPSIS:   Subclasses a multiline edit control so that a edit message  *
//*             to select the entire contents is ignored.                   *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle of the edit window                   *
//*             fnNewProc:      New window handler proc                     *
//*             lpfnOldProc:    (returns) Old window handler proc           *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//* NOTE:       A selected edit message is not generated when the user      *
//*             selects text with the keyboard or mouse.                    *
//*                                                                         *
//***************************************************************************
VOID NEAR PASCAL MEditSubClassWnd( HWND hWnd, FARPROC fnNewProc )
{
    g_lpfnOldMEditWndProc = (FARPROC) GetWindowLongPtr( hWnd, GWLP_WNDPROC );

    SetWindowLongPtr( hWnd, GWLP_WNDPROC, (LONG_PTR) MakeProcInstance( fnNewProc,
                   (HINSTANCE) GetWindowWord( hWnd, GWW_HINSTANCE ) ) );
}


//***************************************************************************
//*                                                                         *
//* NAME:       MEditSubProc                                                *
//*                                                                         *
//* SYNOPSIS:   New multiline edit window procedure to ignore selection of  *
//*             all contents.                                               *
//*                                                                         *
//* REQUIRES:   hWnd:                                                       *
//*             msg:                                                        *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    LONG:                                                       *
//*                                                                         *
//* NOTE:       A selected edit message is not generated when the user      *
//*             selects text with the keyboard or mouse.                    *
//*                                                                         *
//***************************************************************************
LRESULT CALLBACK MEditSubProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    if ( msg == EM_SETSEL )  {
        return 0;
        wParam = lParam;
        lParam = MAKELPARAM( LOWORD(lParam), LOWORD(lParam) );
    }

    return CallWindowProc( (WNDPROC) g_lpfnOldMEditWndProc, hWnd, msg,
                           wParam, lParam );
}


//***************************************************************************
//*                                                                         *
//* NAME:       GetDlgIDFromIndex                                           *
//*                                                                         *
//* SYNOPSIS:   For a given zero-based page index, returns the              *
//*             corresponding dialog ID for the page.                       *
//*                                                                         *
//* REQUIRES:   uPageIndex:                                                 *
//*                                                                         *
//* RETURNS:    UINT:                                                       *
//*                                                                         *
//***************************************************************************
UINT GetDlgIDFromIndex( UINT uPageIndex )
{
    ASSERT( uPageIndex < NUM_WIZARD_PAGES );

    return PageInfo[uPageIndex].uDlgID;
}


//***************************************************************************
//*                                                                         *
//* NAME:       EnableWizard                                                *
//*                                                                         *
//* SYNOPSIS:   Enables or disables the wizard buttons and the wizard page  *
//*             itself (so it can't receive focus).                         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fEnable:        TRUE to enable the wizard, FALSE to disable *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID EnableWizard( HWND hDlg, BOOL fEnable )
{
    HWND hwndWiz = GetParent( hDlg );

    // disable/enable back, next, cancel
    EnableWindow( GetDlgItem( hwndWiz, IDD_BACK ), fEnable );
    EnableWindow( GetDlgItem( hwndWiz, IDD_NEXT ), fEnable );
    EnableWindow( GetDlgItem( hwndWiz, IDCANCEL ), fEnable );

    // disable/enable wizard page
    EnableWindow( hwndWiz, fEnable );

    UpdateWindow( hwndWiz );

    if ( fEnable ) {
        SetForegroundWindow( hDlg );
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       MsgWaitForMultipleObjectsLoop                               *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:   hEvent:                                                     *
//*                                                                         *
//* RETURNS:    DWORD:                                                      *
//*                                                                         *
//***************************************************************************
DWORD MsgWaitForMultipleObjectsLoop( HANDLE hEvent )
{
    MSG msg;
    DWORD dwObject;

    while (1)
    {
        dwObject = MsgWaitForMultipleObjects( 1, &hEvent, FALSE,INFINITE,
                                                           QS_ALLINPUT );
        // Are we done waiting?
        switch ( dwObject )  {
            case WAIT_OBJECT_0:

            case WAIT_FAILED:
                return dwObject;

            case WAIT_OBJECT_0 + 1:
                // got a message, dispatch it and wait again
                while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE)) {
                    DispatchMessage(&msg);
                }
                break;
        }
    }

}


//***************************************************************************
//*                                                                         *
//* NAME:       MsgBox2Param                                                *
//*                                                                         *
//* SYNOPSIS:   Displays a message box with the specified string ID using   *
//*             2 string parameters.                                        *
//*                                                                         *
//* REQUIRES:   hWnd:           Parent window                               *
//*             nMsgID:         String resource ID                          *
//*             szParam1:       Parameter 1 (or NULL)                       *
//*             szParam2:       Parameter 2 (or NULL)                       *
//*             uIcon:          Icon to display (or 0)                      *
//*             uButtons:       Buttons to display                          *
//*                                                                         *
//* RETURNS:    INT:            ID of button pressed                        *
//*                                                                         *
//* NOTES:      Macros are provided for displaying 1 parameter or 0         *
//*             parameter message boxes.  Also see ErrorMsg() macros.       *
//*                                                                         *
//***************************************************************************
INT MsgBox2Param( HWND hWnd, UINT nMsgID, LPCSTR szParam1, LPCSTR szParam2,
                  UINT uIcon, UINT uButtons )
{
    CHAR achMsgBuf[STRING_BUF_LEN];
    CHAR achSmallBuf[SMALL_BUF_LEN];
    LPSTR szMessage;
    INT   nReturn;


    if ( !(g_wQuietMode == 1) )
    {
        LoadSz( IDS_APPNAME, achSmallBuf, sizeof(achSmallBuf) );
        LoadSz( nMsgID, achMsgBuf, sizeof(achMsgBuf) );

        if ( szParam2 != NULL )  {
            szMessage = (LPSTR) LocalAlloc( LPTR,   lstrlen( achMsgBuf )
                                                  + lstrlen( szParam1 )
                                                  + lstrlen( szParam2 ) + 100 );
            if ( ! szMessage )  {
                return -1;
            }

            wsprintf( szMessage, achMsgBuf, szParam1, szParam2 );
        } else if ( szParam1 != NULL )  {
            szMessage = (LPSTR) LocalAlloc( LPTR,   lstrlen( achMsgBuf )
                                                + lstrlen( szParam1 ) + 100 );
            if ( ! szMessage )  {
                return -1;
            }

            wsprintf( szMessage, achMsgBuf, szParam1, szParam2 );
        } else  {
            szMessage = (LPSTR) LocalAlloc( LPTR, lstrlen( achMsgBuf ) + 1 );
            if ( ! szMessage )  {
                return -1;
            }

            lstrcpy( szMessage, achMsgBuf );
        }

        MessageBeep( uIcon );

        nReturn = MessageBox( hWnd, szMessage, achSmallBuf, uIcon | uButtons |
                            MB_APPLMODAL | MB_SETFOREGROUND | 
                            ((RunningOnWin95BiDiLoc() && IsBiDiLocalizedBinary(g_hInst,RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO))) ? (MB_RIGHT | MB_RTLREADING) : 0) );

        LocalFree( szMessage );

        return nReturn;
    } else {
        return MB_OK;
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       DisplayFieldErrorMsg                                        *
//*                                                                         *
//* SYNOPSIS:   Pops up a warning message about a field, sets focus to the  *
//*             field and selects any text in it.                           *
//*                                                                         *
//* REQUIRES:   hDlg:           parent windows                              *
//*             uCtrlID:        ID of control left blank                    *
//*             uStrID:         ID of string resource with warning message  *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID DisplayFieldErrorMsg( HWND hDlg, UINT uCtrlID, UINT uStrID )
{
    ErrorMsg( hDlg, uStrID );
    SetFocus( GetDlgItem( hDlg, uCtrlID ) );
    SendDlgItemMessage( hDlg, uCtrlID, EM_SETSEL, 0, -1 );
}


//***************************************************************************
//*                                                                         *
//* NAME:       FileExists                                                  *
//*                                                                         *
//* SYNOPSIS:   Checks if a file exists.                                    *
//*                                                                         *
//* REQUIRES:   pszFilename                                                 *
//*                                                                         *
//* RETURNS:    BOOL:       TRUE if it exists, FALSE otherwise              *
//*                                                                         *
//***************************************************************************
BOOL FileExists( LPCSTR pszFilename )
{
    HANDLE hFile;

    ASSERT( pszFilename );

    hFile = CreateFile( pszFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL, NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }

    CloseHandle( hFile );

    return( TRUE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       InitBigFont                                                 *
//*                                                                         *
//* SYNOPSIS:   Sets the font of the specifed control to the large (title)  *
//*             font. Creates the font if it doesn't already exist.         *
//*                                                                         *
//* REQUIRES:   hwnd:                                                       *
//*             uCtrlID:                                                    *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//* NOTES:      Make sure to call DestroyBigFont before the app exits to    *
//*             dispose of the font.                                        *
//*                                                                         *
//*             Borrowed from Win 95 setup code.                            *
//*                                                                         *
//***************************************************************************
VOID InitBigFont( HWND hwnd, UINT uCtrlID )
{
    HFONT   hFont;
    HWND    hwndCtl;
    LOGFONT lFont;
    int     nLogPixelsY;
    HDC     hDC;

    // get the window for the specified control
    if ( ( hwndCtl = GetDlgItem( hwnd, uCtrlID ) ) == NULL ) {
        return;
    }

    // get the logical y pixels
    hDC = GetDC( NULL );
    ASSERT( hDC );
    if ( !hDC ) {
        return;
    }

    nLogPixelsY = GetDeviceCaps( hDC, LOGPIXELSY );
    ReleaseDC( NULL, hDC );

    if ( ! g_hBigFont ) {
        if ( ( hFont = (HFONT) (WORD) SendMessage( hwndCtl, WM_GETFONT, 0, 0L ) ) != NULL ) {
            if ( GetObject( hFont, sizeof(LOGFONT), (LPSTR) &lFont ) ) {
                lFont.lfWeight = FW_BOLD;
                LoadString( g_hInst, IDS_MSSERIF, lFont.lfFaceName, LF_FACESIZE - 1 );
                lFont.lfHeight = -1 * ( nLogPixelsY * LARGE_POINTSIZE / 72 );

                g_hBigFont = CreateFontIndirect( (LPLOGFONT) &lFont );
            }
        }
    }

    if ( g_hBigFont ) {
        SendMessage( hwndCtl, WM_SETFONT, (WPARAM) g_hBigFont, 0L );
    }
    else {
        // couldn't create font
//        DEBUGTRAP( "Couldn't create large font" );
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       DestroyBigFont                                              *
//*                                                                         *
//* SYNOPSIS:   Destroys the large font used for dialog titles, if it has   *
//*             been created.                                               *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID DestroyBigFont( VOID )
{
    if ( g_hBigFont ) {
        DeleteObject( g_hBigFont );
        g_hBigFont = NULL;
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       EnableDlgItem                                               *
//*                                                                         *
//* SYNOPSIS:   Makes it a little simpler to enable a dialog item.          *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog handle                               *
//*             uID:            ID of control                               *
//*             fEnable:        TRUE to enable, FALSE to disable            *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if successfull, FALSE otherwise        *
//*                                                                         *
//***************************************************************************
BOOL EnableDlgItem( HWND hDlg, UINT uID, BOOL fEnable )
{
    return EnableWindow( GetDlgItem( hDlg, uID ), fEnable );
}


//***************************************************************************
//*                                                                         *
//* NAME:       LoadSz                                                      *
//*                                                                         *
//* SYNOPSIS:   Loads specified string resource into buffer.                *
//*                                                                         *
//* REQUIRES:   idString:                                                   *
//*             lpszBuf:                                                    *
//*             cbBuf:                                                      *
//*                                                                         *
//* RETURNS:    LPSTR:      Pointer to the passed-in buffer.                *
//*                                                                         *
//* NOTES:      If this function fails (most likely due to low memory), the *
//*             returned buffer will have a leading NULL so it is generally *
//*             safe to use this without checking for failure.              *
//*                                                                         *
//***************************************************************************
LPSTR LoadSz( UINT idString, LPSTR lpszBuf, UINT cbBuf )
{
    ASSERT( lpszBuf );

    // Clear the buffer and load the string
    if ( lpszBuf ) {
        *lpszBuf = '\0';
        LoadString( g_hInst, idString, lpszBuf, cbBuf );
    }

    return lpszBuf;
}


//***************************************************************************
//*                                                                         *
//* NAME:       IsDuplicate                                                 *
//*                                                                         *
//* SYNOPSIS:   Checks if a file being added to the list view is already    *
//*             in the listview.                                            *
//*                                                                         *
//* REQUIRES:   hDlg:           dialog window                               *
//*             nDlgItem:       ID of list view control                     *
//*             szFilename:     Name of file to check for a dupe.           *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if it's a duplicate, FALSE otherwise   *
//*                                                                         *
//***************************************************************************
BOOL WINAPI IsDuplicate( HWND hDlg, INT nDlgItem, LPSTR szFilename, BOOL chkIsListbox )
{
    INT     nItems;
    HWND    hwndFiles;
    LV_ITEM lviCheck;
    PMYITEM pItem = NULL;
    INT     nIndex;


    if ( chkIsListbox )
    {
        hwndFiles = GetDlgItem( hDlg, nDlgItem );

        nItems = ListView_GetItemCount( hwndFiles );

        for ( nIndex = 0; nIndex < nItems; nIndex += 1 )  {
            lviCheck.mask     = LVIF_PARAM;
            lviCheck.iItem    = nIndex;
            lviCheck.iSubItem = 0;
            lviCheck.lParam   = (LPARAM) pItem;

            ListView_GetItem( hwndFiles, &lviCheck );

            if ( lstrcmpi( ((PMYITEM)(lviCheck.lParam))->aszCols[0],
                           szFilename ) == 0 )
            {
                return TRUE;
            }
        }
    }
    else  // check through the file item list
    {
        pItem = GetFirstItem();
        while ( ! LastItem( pItem ) )
        {
            if ( !lstrcmpi( szFilename, GetItemSz( pItem, 0 ) ) )
            {
                return TRUE;
            }
            pItem = GetNextItem( pItem );
        }
    }
    return FALSE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       IsMyKeyExists                                               *
//*                                                                         *
//* SYNOPSIS:   Checks if a specific key in the given section and given file*
//*             is defined.  IF so, get the value.  OW return -1            *
//*                                                                         *
//*                                                                         *
//***************************************************************************

LONG IsMyKeyExists( LPCSTR lpSec, LPCSTR lpKey, LPSTR lpBuf, UINT uSize, LPCSTR lpFile )
{
    LONG lRet;

    lRet = (LONG)GetPrivateProfileString( lpSec, lpKey, SYS_DEFAULT, lpBuf, uSize, lpFile );

    if ( lpSec && lpKey && (lRet == (LONG)(uSize-1)) || !lpKey && (lRet == (LONG)(uSize-2)) )
    {
        // not enough buffer size to read the string
        lRet = -2;
    }
    else if ( !lstrcmp( lpBuf, SYS_DEFAULT ) )
    {
         // no key defined
         lRet = -1;
    }
    return lRet;
}

ULONG FileSize( LPSTR lpFile )
{
    ULONG ulFileSize;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile;

    if ( *lpFile == 0 )
        return 0;

    hFile = FindFirstFile( lpFile, &FindFileData );
    ulFileSize = (FindFileData.nFileSizeHigh * MAXDWORD) + FindFileData.nFileSizeLow;
    FindClose( hFile );

    return ulFileSize;
}

void NotifyBadString( PCSTR pszBadname, UINT uMaxSize )
{
    char szSize[20];

    _itoa(uMaxSize, szSize, 10);
    MsgBox2Param( NULL, IDS_ERR_BADSTRING, pszBadname, szSize, MB_ICONSTOP, MB_OK );
}

//***************************************************************************
//
// FormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc, LPCSTR lpFile, UINT uSize );
//
// This function can be easily described by giving examples of what it
// does:
//        Input:  GenFormStrWithoutPlaceHolders(dest,"desc=%MS_XYZ%", hinf) ;
//                INF file has MS_VGA="Microsoft XYZ" in its [Strings] section!
//                    
//        Output: "desc=Microsoft XYZ" in buffer dest when done.
//
//
// ENTRY:
//  szDst         - the destination where the string after the substitutions
//                  for the place holders (the ones enclosed in "%' chars!)
//                  is placed. This buffer should be big enough (LINE_LEN)
//  szSrc         - the string with the place holders.
//  uSize         - the size of the output buffer
//
// EXIT:
//
// NOTES:
//  To use a '%' as such in the string, one would use %% in szSrc! BUGBUG For
//  the sake of simplicity, we have placed a restriction that the place
//  holder name string cannot have a '%' as part of it! If this is a problem
//  for internationalization, we can revisit this and support it too! Also,
//  the way it is implemented, if there is only one % in the string, it is
//  also used as such! Another point to note is that if the key is not
//  found in the [Strings] section, we just use the %strkey% as such in the
//  destination. This should really help in debugging.
//
//  BTW, CH_STRINGKEY, in the code below, is the symbolic name for '%'.
//
//  Get/modified it from setupx: gen1.c
//***************************************************************************

LONG FormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc, UINT uSize )
{
    int    uCnt ;
    LONG   lRet;
    CHAR   *pszTmp;
    LPSTR  pszSaveDst;

    pszSaveDst = szDst;
    // Do until we reach the end of source (null char)
    while( (*szDst++ = *szSrc) )
    {
        // Increment source as we have only incremented destination above
        if(*szSrc++ == CH_STRINGKEY)
        {
            if (*szSrc == CH_STRINGKEY)
            {
                // One can use %% to get a single percentage char in message
                szSrc++ ;
                continue ;
            }

            // see if it is well formed -- there should be a '%' delimiter
            if ( (pszTmp = strchr( szSrc, CH_STRINGKEY)) != NULL )
            {
                szDst--; // get back to the '%' char to replace

                // yes, there is a STR_KEY to be looked for in [Strings] sect.
                *pszTmp = '\0' ; // replace '%' with a NULL char

                // szSrc points to the replaceable key now as we put the NULL char above.

                if ( (g_szOverideCDF[0] == 0) || (g_CDF.achStrings[0] == 0) ||
                    (lRet = IsMyKeyExists( g_CDF.achStrings, szSrc, szDst, uSize, g_szOverideCDF )) == -1 )
                {
                    lRet = IsMyKeyExists( SEC_STRINGS, szSrc, szDst, uSize, g_CDF.achFilename );
                }

                if ( lRet == -1 )
                {
                    // key is missing in [Strings] section!
                    if ( MsgBox1Param( NULL, IDS_WARN_MISSSTRING, (LPSTR)szSrc, MB_ICONQUESTION, MB_YESNO ) == IDNO )
                        return lRet;

                    *pszTmp = CH_STRINGKEY;      // put back original character
                    szSrc-- ;                    // get back to first '%' in Src
                    uCnt = (INT)((pszTmp - szSrc) + 1); // include 2nd '%'

                    // UGHHH... It copies 1 less byte from szSrc so that it can put
                    // in a bad NULL character, that I don't care about!!!
                    // Different from the normal API I am used to...
                    lstrcpyn( szDst, szSrc, uCnt + 1 ) ;
                }
                else if ( lRet == -2 )
                {
                    NotifyBadString( szSrc, uSize );
                    return lRet;
                }
                else
                {
                    // all was well, Dst filled right, but unfortunately count not passed
                    // back, like it used too... :-( quick fix is a lstrlen()...
                    uCnt = lstrlen( szDst ) ;
                }

                *pszTmp = CH_STRINGKEY  ; // put back original character
                szSrc = pszTmp + 1 ;      // set Src after the second '%'
                szDst += uCnt ;           // set Dst also right.
            }
            // else it is ill-formed -- we use the '%' as such!
            else
            {
                if ( MsgBox1Param( NULL, IDS_ERR_READ_CDF, (LPSTR)(szSrc - 1), MB_ICONQUESTION, MB_YESNO ) == IDNO )
                    return -1;
            }
        }

    } /* while */
    return lstrlen(pszSaveDst);

} /* GenFormStrWithoutPlaceHolders */

//***************************************************************************
//*                                                                         *
//* NAME:       MyGetPrivateProfileString                                   *
//*                                                                         *
//* SYNOPSIS:   get key string vale from overide CDF if exists. Otherwise,  *
//*             get it from Main CDF. And expand to its real string value   *
//*             return -1 if key-string define error and user stops         *
//*                                                                         *
//***************************************************************************

LONG MyGetPrivateProfileString( LPCSTR lpSec, LPCSTR lpKey, LPCSTR lpDefault,
                                LPSTR lpBuf, UINT uSize, LPCSTR lpOverSec )
{
    PSTR pszNewLine;
    LONG lRet;

    if ( g_szOverideCDF[0] == 0 || *lpOverSec == 0 ||
         (lRet= IsMyKeyExists( lpOverSec, lpKey, lpBuf, uSize, g_szOverideCDF )) == -1 )
    {
        lRet = (LONG)GetPrivateProfileString( lpSec, lpKey, lpDefault, lpBuf, uSize, g_CDF.achFilename );
    }

    if ( lpKey == NULL )
    {
        return lRet;
    }

    pszNewLine = (LPSTR)LocalAlloc( LPTR, uSize );
    if ( pszNewLine )
    {
        lRet = FormStrWithoutPlaceHolders( pszNewLine, lpBuf, uSize );
        if ( lRet >= 0 )
            lstrcpy( lpBuf, pszNewLine );

        LocalFree( pszNewLine );
    }

    return lRet;
}

//***************************************************************************
//*                                                                         *
//* NAME:       MyGetPrivateProfileInt                                      *
//*                                                                         *
//* SYNOPSIS:   get key INT vale from overide CDF if exists. Otherwise,     *
//*             get it from Main CDF. And expand to its real string value   *
//*                                                                         *
//***************************************************************************

UINT MyGetPrivateProfileInt( LPCSTR lpSec, LPCSTR lpKey, int idefault, LPCSTR lpOverSec )
{
    UINT uRet = 999;    // means not valid value

    if ( g_szOverideCDF[0] && *lpOverSec )
         uRet = GetPrivateProfileInt( lpOverSec, lpKey, 999, g_szOverideCDF );

    if ( uRet == 999 )
        uRet = GetPrivateProfileInt( lpSec, lpKey, idefault, g_CDF.achFilename );

    return uRet;

}

//***************************************************************************
//*                                                                         *
//* NAME:       MyGetPrivateProfileSection                                  *
//*                                                                         *
//* SYNOPSIS:   get section from overide CDF if exists. Otherwise,          *
//*             get it from Main CDF.                                       *
//*                                                                         *
//***************************************************************************

LONG MyGetPrivateProfileSection( LPCSTR lpSec, LPSTR lpBuf, int size, BOOL bSingleCol )
{
    LONG lRet;


    if ( g_szOverideCDF[0] == 0 || (lRet=RO_GetPrivateProfileSection( lpSec, lpBuf, size, g_szOverideCDF, bSingleCol )) == 0 )
    {
        lRet = RO_GetPrivateProfileSection( lpSec, lpBuf, size, g_CDF.achFilename, bSingleCol );
    }
    return lRet;
}

//***************************************************************************
//*                                                                         *
//* NAME:       MyWritePrivateProfileString                                 *
//*                                                                         *
//* SYNOPSIS:   Write out all String value Key in its localizable format    *
//*             %...% If previouse keyname=%used-define% exists, reuse      *
//*             user-define as key in Strings section.  Otherwise, use      *
//*             %keyname% and define keyname in Strings section             *
//*                                                                         *
//***************************************************************************

void MyWritePrivateProfileString( LPCSTR lpSec, LPCSTR lpKey, LPSTR lpBuf, UINT uSize, BOOL fQuotes )
{
    CHAR   szTmpBuf[MAX_PATH];
    LPSTR   pszTmpBuf2 = NULL;
    BOOL    fUseDefault;

	pszTmpBuf2 = (LPSTR)LocalAlloc( LPTR, uSize+32 );
	if ( !pszTmpBuf2 )
		return;

    // when we write the string value out, we write it in a localizable fashion
    // if the item has %strKey% format, we re-use the %strKey% as its String refer key
    // otherwise, we use %item-name% as the string refer key
    GetPrivateProfileString( lpSec, lpKey, "", szTmpBuf, uSize, g_CDF.achFilename );

    if ( (szTmpBuf[0] == CH_STRINGKEY) && (szTmpBuf[lstrlen(szTmpBuf)-1] == CH_STRINGKEY) )
    {
        szTmpBuf[lstrlen(szTmpBuf)-1] = '\0';
        fUseDefault = FALSE;
    }
    else
    {
        lstrcpy( szTmpBuf, "%" );
        lstrcat( szTmpBuf, lpKey );
        lstrcat( szTmpBuf, "%" );
        WritePrivateProfileString( lpSec, lpKey, szTmpBuf, g_CDF.achFilename );
        fUseDefault = TRUE;
    }

    if ( fQuotes ) {
        lstrcpy( pszTmpBuf2, "\"" );
        lstrcat( pszTmpBuf2, lpBuf );
        lstrcat( pszTmpBuf2, "\"" );
    } else {
        lstrcpy( pszTmpBuf2, lpBuf );
    }

    WritePrivateProfileString( SEC_STRINGS, fUseDefault?lpKey:(szTmpBuf+1), pszTmpBuf2, g_CDF.achFilename );

	if ( pszTmpBuf2 )
		LocalFree( pszTmpBuf2 );

    return;
}

//***************************************************************************
//*                                                                         *
//* NAME:       CleanStringKey                                              *
//*                                                                         *
//* SYNOPSIS:   Cleanup the leftover File%d stuff in Strings                *
//*                                                                         *
//***************************************************************************

void CleanStringKey( LPSTR lpstrKey )
{
    LPSTR pszTmp;

    if ( lpstrKey == NULL )
        return;

    while ( *lpstrKey )
    {
       if ( *lpstrKey++ == CH_STRINGKEY )
       {
           if (*lpstrKey == CH_STRINGKEY)
           {
               // One can use %% to get a single percentage char in message
               lpstrKey++ ;
               continue ;
           }

           // see if it is well formed -- there should be a '%' delimiter
           if ( (pszTmp = strchr( lpstrKey, CH_STRINGKEY)) != NULL )
           {
               // yes, there is a STR_KEY to be looked for in [Strings] sect.
               *pszTmp = '\0' ; // replace '%' with a NULL char
               WritePrivateProfileString( SEC_STRINGS, lpstrKey, NULL, g_CDF.achFilename);
               *pszTmp = CH_STRINGKEY;
               lpstrKey = pszTmp+1;
           }
           else
               break;
       }
    }

}

//***************************************************************************
//*                                                                         *
//* NAME:       CleanupSection                                              *
//*                                                                         *
//* SYNOPSIS:   Cleanup the any given section with key=%xxxx% and its       *
//*             strings                                                     *
//*                                                                         *
//***************************************************************************

BOOL CleanupSection( LPSTR lpSec, BOOL fSingleCol )
{
    LPSTR  lpBuf, lpSave;
    CHAR   szStrKey[SMALL_BUF_LEN];
    int     size;

    size = FileSize( g_CDF.achFilename );
    lpBuf = (LPSTR) LocalAlloc( LPTR, size );
    if ( !lpBuf )
    {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        return FALSE;
    }

    lpSave = lpBuf;
    if ( fSingleCol )
        RO_GetPrivateProfileSection( lpSec, lpBuf, size, g_CDF.achFilename, TRUE );
    else
        GetPrivateProfileString( lpSec, NULL, "", lpBuf, size, g_CDF.achFilename );


    while ( *lpBuf )
    {
        if ( fSingleCol )
            CleanStringKey( lpBuf );
        else
        {
            GetPrivateProfileString( lpSec, lpBuf, "", szStrKey, sizeof(szStrKey), g_CDF.achFilename );
            CleanStringKey( szStrKey );
        }

        lpBuf += lstrlen(lpBuf);
        lpBuf++; //jump over the single '\0'
    }

    WritePrivateProfileString( lpSec, NULL, NULL, g_CDF.achFilename );
    LocalFree( lpSave );

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       CleanSourceFiles                                            *
//*                                                                         *
//* SYNOPSIS:   Cleanup the leftover SourceFile%d stuff                     *
//*                                                                         *
//***************************************************************************

BOOL CleanSourceFiles( LPSTR lpSection )
{
    LPSTR  lpBuf, lpSave;
    int     size;

    size = FileSize( g_CDF.achFilename );
    lpBuf = (LPSTR) LocalAlloc( LPTR, size );
    if ( !lpBuf )
    {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        return FALSE;
    }

    lpSave = lpBuf;

    GetPrivateProfileString( lpSection, NULL, "", lpBuf, size, g_CDF.achFilename );

    while ( *lpBuf )
    {
        if ( !CleanupSection( lpBuf, TRUE ) )
        {
            LocalFree( lpSave );
            return FALSE;
        }

        lpBuf += (lstrlen(lpBuf) + 1);
    }
    WritePrivateProfileString( lpSection, NULL, NULL, g_CDF.achFilename );
    LocalFree( lpSave );

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       MergerSection                                               *
//*                                                                         *
//***************************************************************************

BOOL MergeSection( LPSTR lpSec, LPSTR lpOverideSec )
{
    // always merge the lpOverideSec keys to lpSec
    LPSTR lpBuf, lpSave;
    CHAR  szValue[MAX_PATH];
    int    size;

    size =  __max( FileSize( g_CDF.achFilename ), FileSize( g_szOverideCDF ) ) ;
    lpBuf = (LPSTR) LocalAlloc( LPTR, size );
    if ( !lpBuf )
    {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        return FALSE;
    }

    lpSave = lpBuf;

    GetPrivateProfileString( lpOverideSec, NULL, "", lpBuf, size, g_szOverideCDF );

    while ( *lpBuf )
    {
        if ( MyGetPrivateProfileString( lpSec, lpBuf, "", szValue, sizeof(szValue), lpOverideSec ) == -1 )
        {
            LocalFree( lpSave );
            return FALSE;
        }

        MyWritePrivateProfileString( lpSec, lpBuf, szValue, sizeof(szValue), FALSE );

        lpBuf += (lstrlen(lpBuf) + 1);
    }

    LocalFree( lpSave );
    return TRUE;

}

//   If the next token in *pszData is delimited by the DeLim char, replace DeLim
//   in *pszData by chEos, set *pszData to point to the char after the chEos and return
//   ptr to the beginning of the token; otherwise, return NULL
//
LPSTR GetNextToken(LPSTR *pszData, char DeLim)
{
    LPSTR szPos;

    if (pszData == NULL  ||  *pszData == NULL  ||  **pszData == 0)
        return NULL;

    if ((szPos = strchr(*pszData, DeLim)) != NULL)
    {
        LPSTR szT = *pszData;

        *pszData = CharNext(szPos);
        *szPos = '\0';              
        szPos = szT;
    }
    else                          
    {
        szPos = *pszData;
        *pszData = szPos + lstrlen(szPos);
    }

    return szPos;
}


void SetVerUnlimit( PVERRANGE pVer )
{
    pVer->toVer.dwMV = MAX_TARGVER;
    pVer->toVer.dwLV = MAX_TARGVER;
    pVer->toVer.dwBd = MAX_TARGVER;
}



// given the str version range:  ver1-ver2
void SetVerRange( PVERRANGE pVR, LPSTR pstrVer, BOOL bFile )
{     
    LPSTR pTmp, pArg, pSubArg;
    DWORD dwVer[4];
    int   i, j;
    BOOL  bSingleVer;

    pArg = pstrVer;
    bSingleVer = strchr( pstrVer, '-' ) ? FALSE : TRUE;
    for ( i=0; i<2; i++ )
    {
        pTmp = GetNextToken( &pArg, '-' );

        if ( !pTmp ) 
        {
            if ( !bSingleVer )
            {
                // case1 -4.0.0  == 0.0.0-4.0.0
                // case2 4.0.0-  == 4.0.0-NoLimit
                //
                if ( i == 0 )
                    continue;
                else
                    SetVerUnlimit( pVR ); 
            }
            break;
        }

        for ( j=0; j<4; j++ )
        {
            dwVer[j] = strtoul( pTmp, &pSubArg, 10 );
            pTmp = CharNext(pSubArg);
        }

        if ( bFile )
        {
            DWORD dwMV, dwLV;

            dwMV = MAKELONG( (WORD)dwVer[1], (WORD)dwVer[0] );
            dwLV = MAKELONG( (WORD)dwVer[3], (WORD)dwVer[2] );

            if ( i == 0 )
            {
                pVR->frVer.dwMV = dwMV;
                pVR->frVer.dwLV = dwLV;
            }
            else
            {
                pVR->toVer.dwMV = dwMV;
                pVR->toVer.dwLV = dwLV;
            }
        }
        else
        {                           
            if ( i == 0 )  // start version (from version)
            {         
                pVR->frVer.dwMV = dwVer[0];
                pVR->frVer.dwLV = dwVer[1];
                pVR->frVer.dwBd = dwVer[2];
            }
            else
            {
                pVR->toVer.dwMV = dwVer[0];
                pVR->toVer.dwLV = dwVer[1];
                pVR->toVer.dwBd = dwVer[2];
            }
        }
    }
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetTargetVerCheck                                           *
//*                                                                         *
//* SYNOPSIS:   Get author specifined target versions                       *
//*                                                                         *
//***************************************************************************

BOOL ParseTargetVerCheck( LPSTR szBuf, PVERCHECK pVerCheck, LPSTR szMsg, BOOL bFile)
{
    int i, j;
    LPSTR pArg, pSubArg, pTmp;
    DWORD dwVer[4];

    *szMsg = 0;
    if ( szBuf[0] == 0 )
    {
        // this is the case that no versions are specified, meaning applying to all
        SetVerUnlimit( &(pVerCheck->vr[0]) );
        return TRUE;
    }
    
    // the loop for possible 3 fields: <ver range> : str : flags
    //
    pArg = szBuf;
    for ( i=0; i<3; i++ )
    {
        pTmp = GetNextToken( &pArg, ':' );

        if ( !pTmp )
            break;
        else if ( *pTmp == 0 )
        {
            if ( i == 0 )             
            {
                // empty version range field no bother further!
                SetVerUnlimit( &(pVerCheck->vr[0]) );
                break;
            }
            continue;
        }

        if ( i == 0 )
        {
            LPSTR pRange;

            // version range format:  ver1-ver2 , ver1-ver2 : 
            //
            for ( j = 0; j<2; j++)
            {
                pRange = GetNextToken( &pTmp, ',' );

                if ( !pRange )
                    break;
                else if ( *pRange == 0 ) 
                    continue;
                else
                    SetVerRange( &(pVerCheck->vr[j]), pRange, bFile );
            }
        }
        else if ( i == 1 )
        {
            // string field        
            lstrcpy( szMsg, pTmp );                    
        }
        else
        {
            // flag field
            if ( !lstrcmpi(pTmp, FLAG_BLK) )
                pVerCheck->dwFlag |= VERCHK_OK;
            else if ( !lstrcmpi(pTmp, FLAG_PMTYN) )
                pVerCheck->dwFlag |= VERCHK_YESNO;
            else if ( !lstrcmpi(pTmp, FLAG_PMTOC) )
                pVerCheck->dwFlag |= VERCHK_OKCANCEL;
            else
            {
                ErrorMsg1Param( NULL, IDS_ERR_VCHKFLAG, pTmp );
                return FALSE;
            }
        }        
    }

    // Just in case, we broke out early or user's to-ver is empty fill with from-ver.
    //
    for ( j = 0; j<2; j++ )
    {
        if ( !pVerCheck->vr[j].toVer.dwMV && !pVerCheck->vr[j].toVer.dwLV && !pVerCheck->vr[j].toVer.dwBd )
        {
            pVerCheck->vr[j].toVer = pVerCheck->vr[j].frVer;
        }
    }

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       OutFileListSection                                          *
//*                                                                         *
//* SYNOPSIS:   Write out the file list from the internal ItemList          *
//*                                                                         *
//***************************************************************************

BOOL OutFileListSection()
{
    PMYITEM pItem;
    LPSTR  lpFileStr;
    CHAR   szCurrSection[MAX_SECLEN];
    CHAR   szCurrFile[MAX_SECLEN];
    CHAR   szCurrSecValue[MAX_PATH];
    BOOL    fAllDone;
    int     idxSec = 0, idxFile = 0;
    LPSTR  pFileList;
    CHAR   achFilename[MAX_PATH+10];

// this will allocate enough space to build file key list
#define FILEKEYSIZE 20

    pFileList = (LPSTR) LocalAlloc( LPTR, g_CDF.cbFileListNum*FILEKEYSIZE );
    if ( !pFileList )
    {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        return FALSE;
    }

    do
    {
        fAllDone = TRUE;
        pItem = g_CDF.pTop;
        lpFileStr = pFileList;
        szCurrSection[0] = 0;
        *lpFileStr = '\0';

        while ( pItem )
        {
           if ( !pItem->fWroteOut )
           {
               if ( fAllDone )
                    fAllDone = FALSE;

               // if this section is not write out yet, write now
               if ( pItem->aszCols[1] && (szCurrSection[0] == 0) )
               {
                   lstrcpy( szCurrSection, KEY_FILELIST );
                   lstrcat( szCurrSection, _itoa(idxSec++, szCurrFile, 10 ) );

                   WritePrivateProfileString( g_CDF.achSourceFile, szCurrSection, pItem->aszCols[1], g_CDF.achFilename );
                   lstrcpy( szCurrSecValue, pItem->aszCols[1] );
               }

               if ( !lstrcmpi( szCurrSecValue,  pItem->aszCols[1] ) )
               {
                   pItem->fWroteOut = TRUE;
                   wsprintf( szCurrFile, KEY_FILEBASE, idxFile++ );
                   lstrcpy( achFilename, pItem->aszCols[0] );
                   MyWritePrivateProfileString( SEC_STRINGS, szCurrFile, achFilename, sizeof(achFilename), TRUE );
                   // build file list of this section
                   lstrcpy( lpFileStr, "%" );
                   lstrcat( lpFileStr, szCurrFile );
                   lstrcat( lpFileStr, "%=" );

                   lpFileStr += lstrlen(lpFileStr);
                   lpFileStr++; // jump over the '\0'
               }
           }
           pItem = pItem->Next;
        }

        if ( !fAllDone )
        {
            *lpFileStr = '\0';
            WritePrivateProfileSection( szCurrSection, pFileList, g_CDF.achFilename );
        }

    } while ( !fAllDone );

    LocalFree( pFileList );
    return TRUE;
}

// return the number of entries in the section
//
DWORD GetSecNumLines( LPCSTR pSec, LPCSTR pFile )
{
    char    szBuf[MAX_PATH];
    DWORD   dwNum = 0;
    int     i = 0;
    
    GetPrivateProfileString( pSec, NULL, "", szBuf, sizeof(szBuf), pFile );
    while ( szBuf[i] )
    {
        dwNum++;
        i += lstrlen( &szBuf[i] );
        i++;  // jump over the fence
    }

    return dwNum;
}
    
// check if need to alloc and how much is needed
//
BOOL AllocTargetVerInfo( LPSTR pInfFile )
{
    char    achBuf[MAX_INFLINE];
    DWORD   dwNumFiles = 0;
    BOOL    bRet = TRUE;
    DWORD   dwSize;

    if ( IsMyKeyExists( SEC_OPTIONS, KEY_SYSFILE, achBuf, sizeof(achBuf), pInfFile ) != -1 )
    {
        if (achBuf[0] == '@')
        {
            // process the file section
            dwNumFiles = GetSecNumLines( &achBuf[1], pInfFile );
        }
        else
            dwNumFiles = 1;
    }


    if ( dwNumFiles || 
         (IsMyKeyExists( SEC_OPTIONS, KEY_NTVERCHECK, achBuf, sizeof(achBuf), pInfFile ) != -1) ||
         (IsMyKeyExists( SEC_OPTIONS, KEY_WIN9XVERCHECK, achBuf, sizeof(achBuf), pInfFile ) != -1) )         
    {
        // alloc structure: fixed potion, Message string pool and variable number of filever check struct
        //
        dwSize = sizeof(TARGETVERINFO) + (3*MAX_PATH) + (sizeof(VERCHECK) + MAX_PATH)*dwNumFiles;
        if ( g_CDF.pVerInfo = (PTARGETVERINFO)LocalAlloc( LPTR, dwSize )  )
        {
            g_CDF.pVerInfo->dwNumFiles = dwNumFiles;
        }
        else
        {
            ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
            bRet = FALSE;
        }        
    }

    return bRet;
}

void SetAuthorStr( LPCSTR szMsg, DWORD *pdwOffset )
{   
    int     len = 0;
    LPSTR   pTmp;
    BOOL    bDup = FALSE;

    if ( szMsg[0] )
    {
        pTmp = &(g_CDF.pVerInfo->szBuf[1]);
        // there is an author defined message
        while ( pTmp && *pTmp )
        {
            if ( !lstrcmpi( pTmp, szMsg ) )
            {
                bDup = TRUE;
                break;
            }
            len = (lstrlen( pTmp )+1);
            pTmp += len;
        }

        if ( pTmp )
        {
            // only store the offset to szBuf 
            *pdwOffset = (DWORD)(pTmp - g_CDF.pVerInfo->szBuf);            

            if ( !bDup )
            {
                // meaning there is no existing one!
                // 
                lstrcpy( pTmp, szMsg );
                
                // store the end of the last string data offset
                g_CDF.pVerInfo->dwFileOffs = *pdwOffset + lstrlen(pTmp) + 1;
            }

        }
    }
}
 

BOOL ParseTargetFiles( LPCSTR pBuf, PVERCHECK pVer )
{
    LPSTR lpTmp1, lpTmp2;
    BOOL  bRet = FALSE;
    char  szPath[MAX_PATH];

    lpTmp1 = strchr( pBuf, ':' );
    if ( lpTmp1 )
    {
        char ch = (char)toupper(pBuf[1]);

        lpTmp2 = CharNext( lpTmp1 );
        *(lpTmp1) = '\0';
        if ( (pBuf[0] == '#') && ( (ch == 'S') || (ch == 'W') || (ch == 'A') ) )
        {
            if ( ParseTargetVerCheck( lpTmp2, pVer, szPath, TRUE ) )
            {               
                SetAuthorStr( szPath, &(pVer->dwstrOffs) );
                SetAuthorStr( pBuf, &(pVer->dwNameOffs) );
                bRet = TRUE;
            }
        }        
    }

    return bRet;
}

//***************************************************************************
//*                                                                         *
//* NAME:       WriteCDF                                                    *
//*                                                                         *
//* SYNOPSIS:   Write a CABPack Directive File. Uses information from       *
//*             Global CDF structure (g_CDF).                               *
//*                                                                         *
//* REQUIRES:   hDlg:           dialog window                               *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************

BOOL WriteCDF( HWND hDlg )
{
    CHAR    achBuf[2 * MAX_PATH];
    int      i, arraySize;

    // write class name.
    WritePrivateProfileString( SEC_VERSION, KEY_CLASS, IEXPRESS_CLASS, g_CDF.achFilename );

    // delete the old CDFVersion= line and add SEFVersion= line
    WritePrivateProfileString( SEC_VERSION, KEY_VERSION, NULL, g_CDF.achFilename );
    WritePrivateProfileString( SEC_VERSION, KEY_NEWVER, IEXPRESS_VER, g_CDF.achFilename );

    // Write the config info, numeric value.

    // if user has old ExtractOnly key, delete it first and re-create the new key PackagePurpose instead
    WritePrivateProfileString( SEC_OPTIONS, KEY_EXTRACTONLY, NULL, g_CDF.achFilename );

    switch ( g_CDF.uPackPurpose )
    {
        case IDC_CMD_RUNCMD:
        default:
            lstrcpy( achBuf, STR_INSTALLAPP );
            break;

        case IDC_CMD_EXTRACT:
            lstrcpy( achBuf, STR_EXTRACTONLY );
            break;

        case IDC_CMD_CREATECAB:
            lstrcpy( achBuf, STR_CREATECAB );
            break;
    }
    WritePrivateProfileString( SEC_OPTIONS, KEY_PACKPURPOSE, achBuf, g_CDF.achFilename );

    WritePrivateProfileString( SEC_OPTIONS, KEY_SHOWWIN, _itoa(g_CDF.uShowWindow, achBuf,10), g_CDF.achFilename );

    WritePrivateProfileString( SEC_OPTIONS, KEY_NOEXTRACTUI, _itoa( (g_CDF.uExtractOpt&EXTRACTOPT_UI_NO)?1:0, achBuf, 10), g_CDF.achFilename );
    WritePrivateProfileString( SEC_OPTIONS, KEY_USELFN, _itoa( (g_CDF.uExtractOpt&EXTRACTOPT_LFN_YES)?1:0, achBuf, 10), g_CDF.achFilename );
    WritePrivateProfileString( SEC_OPTIONS, KEY_NESTCOMPRESSED, _itoa( (g_CDF.uExtractOpt&EXTRACTOPT_COMPRESSED)?1:0, achBuf, 10), g_CDF.achFilename );

    WritePrivateProfileString( SEC_OPTIONS, KEY_CABFIXEDSIZE,
                               _itoa( (g_CDF.uExtractOpt & CAB_FIXEDSIZE)?1:0, achBuf, 10), g_CDF.achFilename );

    if ( g_CDF.uExtractOpt & CAB_RESVSP2K )
        i = 1;
    else if ( g_CDF.uExtractOpt & CAB_RESVSP4K )
        i = 2;
    else if ( g_CDF.uExtractOpt & CAB_RESVSP6K )
        i = 3;
    else
        i = 0;

    lstrcpy( achBuf, pResvSizes[i] );
    WritePrivateProfileString( SEC_OPTIONS, KEY_CABRESVCODESIGN, achBuf, g_CDF.achFilename );

    // get reboot settings
    achBuf[0] = 0;
    if ( g_CDF.dwReboot & REBOOT_YES )
    {
        if ( g_CDF.dwReboot & REBOOT_ALWAYS )
            lstrcpy( achBuf, "A" );
        else
            lstrcpy( achBuf, "I" );

        if ( g_CDF.dwReboot & REBOOT_SILENT )
            lstrcat( achBuf, "S" );
    }
    else
        lstrcpy( achBuf, "N" );

    WritePrivateProfileString( SEC_OPTIONS, KEY_REBOOTMODE, achBuf, g_CDF.achFilename );

    arraySize = ARRAY_SIZE( CDFStrInfo );
    // Start writting out the string value
    for ( i = 0; i < arraySize; i++ )
    {
        if ( CDFStrInfo[i].lpFlag )
        {
            if ( *CDFStrInfo[i].lpFlag )
            {
                MyWritePrivateProfileString( CDFStrInfo[i].lpSec, CDFStrInfo[i].lpKey, CDFStrInfo[i].lpBuf, CDFStrInfo[i].uSize, FALSE );
            }
            else
                MyWritePrivateProfileString( CDFStrInfo[i].lpSec, CDFStrInfo[i].lpKey, (LPSTR)CDFStrInfo[i].lpDef, CDFStrInfo[i].uSize, FALSE );

        }
        else
            MyWritePrivateProfileString( CDFStrInfo[i].lpSec, CDFStrInfo[i].lpKey, CDFStrInfo[i].lpBuf, CDFStrInfo[i].uSize, FALSE );
    }

    if ( g_CDF.uExtractOpt & CAB_FIXEDSIZE )
    {
        MyWritePrivateProfileString( SEC_OPTIONS, KEY_LAYOUTINF, g_CDF.achINF, sizeof(g_CDF.achINF), FALSE );
        MyWritePrivateProfileString( SEC_OPTIONS, KEY_CABLABEL, g_CDF.szCabLabel, sizeof(g_CDF.szCabLabel), FALSE );
    }

    // read in the exist one first
    GetVersionInfoFromFile();

    // cleanup VerInfo left over if needed
    if ( GetPrivateProfileString( SEC_OPTIONS, KEY_VERSIONINFO, "", achBuf, sizeof(achBuf), g_CDF.achFilename ) )
    {
        if ( lstrcmpi( achBuf, g_CDF.achVerInfo) )
        {
            if ( !CleanupSection( achBuf, FALSE) )
            {
                return FALSE;
            }
        }
    }

    // write Version information overwite section
    if ( g_CDF.achVerInfo[0] )
    {
        WritePrivateProfileString( SEC_OPTIONS, KEY_VERSIONINFO, g_CDF.achVerInfo, g_CDF.achFilename );
        if ( !MergeSection( g_CDF.achVerInfo, g_CDF.achVerInfo ) )
            return FALSE;
    }

    // if current SourceFiles has different name than the main CDF defined, clean the old one first
    if ( GetPrivateProfileString( SEC_OPTIONS, KEY_FILELIST, "", achBuf, sizeof(achBuf), g_CDF.achFilename ) )
    {
        if ( !CleanSourceFiles( achBuf ) )
            return FALSE;
    }

    WritePrivateProfileString( SEC_OPTIONS, KEY_FILELIST, g_CDF.achSourceFile, g_CDF.achFilename );
    // write the file list section
    return ( OutFileListSection() );
}


//***************************************************************************
//*                                                                         *
//* NAME:       ReadCDF                                                     *
//*                                                                         *
//* SYNOPSIS:   Read a CABPack Directive File into the Global CDF struct.   *
//*                                                                         *
//* REQUIRES:   hDlg:           dialog window                               *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
BOOL ReadCDF( HWND hDlg )
{
    CHAR    achBuf[2 * MAX_PATH];
    LPSTR   lpSave1=NULL, lpSave2=NULL;
    LPSTR   szFileList=NULL, szFileListKeys=NULL;
    ULONG   ulFileSize, uData;
    PMYITEM pMyItem;
    CHAR    szPath[MAX_PATH];
    int     i, arraySize;
    LONG    lRet;
    BOOL    bRetVal = FALSE;
    UINT    uErrid = 0;

    achBuf[0] = '\0';
    szPath[0] = '\0';

    if ( !FileExists(g_CDF.achFilename) )
    {
        uErrid = IDS_ERR_OPEN_CDF;
        goto EXIT;
    }

    // Check to make sure it's a CDF file.
    if ( MyGetPrivateProfileString( SEC_VERSION, KEY_CLASS, "", achBuf, sizeof(achBuf), g_szOverideSec ) < 0 )
        goto EXIT;

    if ( lstrcmpi( achBuf, "IEXPRESS" ) != 0 )
    {
        uErrid = IDS_ERR_CLASSNAME;
        goto EXIT;
    }
    
    if ( !AllocTargetVerInfo( g_CDF.achFilename ) )
        goto EXIT;
    
    // get string section name from overideCDF if there
    if ( g_szOverideCDF[0] && g_szOverideSec[0] )
    {
        if ( !AllocTargetVerInfo( g_szOverideCDF ) )
            goto EXIT;

        GetPrivateProfileString( g_szOverideSec, KEY_STRINGS, SEC_STRINGS, g_CDF.achStrings, sizeof(g_CDF.achStrings), g_szOverideCDF );
    }

    // Read the config info INT vaules.

    // If old ExtractOnly key exists, read it for compatiable purpose.
    // IExpress will never create both OLD and NEW keys.
    // If Old ExtractOnly key is not set to 1 or does not exist, read the New key.
    //
    if (  MyGetPrivateProfileInt( SEC_OPTIONS, KEY_EXTRACTONLY, 0, g_szOverideSec ) )
    {
        g_CDF.uPackPurpose = IDC_CMD_EXTRACT;
    }
    else
    {
        // if the old key is not set, check the new key
        //
        MyGetPrivateProfileString( SEC_OPTIONS, KEY_PACKPURPOSE, STR_INSTALLAPP, achBuf, sizeof(achBuf), g_szOverideSec );

        if ( !lstrcmpi( achBuf, STR_INSTALLAPP ) )
        {
            g_CDF.uPackPurpose = IDC_CMD_RUNCMD;
        }
        else if ( !lstrcmpi( achBuf, STR_EXTRACTONLY) )
        {
            g_CDF.uPackPurpose = IDC_CMD_EXTRACT;
        }
        else
            g_CDF.uPackPurpose = IDC_CMD_CREATECAB;
    }

    g_CDF.uShowWindow = MyGetPrivateProfileInt( SEC_OPTIONS, KEY_SHOWWIN, 0, g_szOverideSec );

    g_CDF.uExtractOpt = 0;
    arraySize = ARRAY_SIZE( CDFOptInfo );
    // Start writting out the string value
    for ( i = 0; i < arraySize; i++ )
    {
        uData = MyGetPrivateProfileInt( SEC_OPTIONS, CDFOptInfo[i].lpKey, 0, g_szOverideSec );
        if ( uData )
        {
            g_CDF.uExtractOpt |= CDFOptInfo[i].dwOpt;
        }
    }

    // get OneInstance check info
    MyGetPrivateProfileString( SEC_OPTIONS, KEY_INSTANCECHK, "", achBuf, sizeof(achBuf), g_szOverideSec );
    switch ( toupper( achBuf[0]) )
    {
        case 'P':
            g_CDF.uExtractOpt |= EXTRACTOPT_INSTCHKPROMPT;
            break;

        case 'B':
            g_CDF.uExtractOpt |= EXTRACTOPT_INSTCHKBLOCK;
            break;

        default:
            break;
    }

    if ( (g_CDF.uExtractOpt & EXTRACTOPT_INSTCHKPROMPT) ||
         (g_CDF.uExtractOpt & EXTRACTOPT_INSTCHKBLOCK) )
    {
        if ( !(lpSave1 = strchr( achBuf, '"' )) )
        {
            uErrid = IDS_ERR_COOKIE;
            goto EXIT;
        }

        lpSave2 = strchr( ++lpSave1, '"' );
        if ( lpSave2 )
        {
            *lpSave2 = '\0';
            g_CDF.lpszCookie = (LPSTR)LocalAlloc( LPTR, lstrlen(lpSave1)+1 );
            if ( g_CDF.lpszCookie )
            {
                lstrcpy( g_CDF.lpszCookie, lpSave1 );
            }
            else
            {
                uErrid = IDS_ERR_NO_MEMORY;
                goto EXIT;
            }
        }
        else
        {
           uErrid = IDS_ERR_COOKIE;
           goto EXIT;
        }
    }

    uData = MyGetPrivateProfileInt( SEC_OPTIONS, KEY_CABFIXEDSIZE, 0, g_szOverideSec );
    if ( uData )
    {
        g_CDF.uExtractOpt |= CAB_FIXEDSIZE;
    }

    MyGetPrivateProfileString( SEC_OPTIONS, KEY_LAYOUTINF, "", g_CDF.achINF, sizeof(g_CDF.achINF), g_szOverideSec );
    MyGetPrivateProfileString( SEC_OPTIONS, KEY_CABLABEL, CAB_DEFSETUPMEDIA, g_CDF.szCabLabel, sizeof(g_CDF.szCabLabel), g_szOverideSec );

    MyGetPrivateProfileString( SEC_OPTIONS, KEY_CABRESVCODESIGN, CAB_6K, achBuf, sizeof(achBuf), g_szOverideSec );
    if ( !lstrcmpi(achBuf, pResvSizes[1]) )
        g_CDF.uExtractOpt |= CAB_RESVSP2K;
    else if ( !lstrcmpi(achBuf, pResvSizes[2]) )
        g_CDF.uExtractOpt |= CAB_RESVSP4K;
    else if ( !lstrcmpi(achBuf, pResvSizes[3]) )
        g_CDF.uExtractOpt |= CAB_RESVSP6K;

    MyGetPrivateProfileString( SEC_OPTIONS, KEY_COMPRESSTYPE, "", achBuf, sizeof(achBuf), g_szOverideSec );
    if ( achBuf[0] == 0 )
    {
        // Get the compression type:  For MS Internal, "QUANTUM=value" can be set.
        g_CDF.uCompressionLevel = MyGetPrivateProfileInt( SEC_OPTIONS, KEY_QUANTUM, 999, g_szOverideSec );
        if ( g_CDF.uCompressionLevel == 999 ) 
        {
            g_CDF.szCompressionType = achMSZIP;
            g_CDF.uCompressionLevel = 7;
        } 
        else
        {
            g_CDF.szCompressionType = achQUANTUM;
        }
    }
    else
    {
        if ( !lstrcmpi( achBuf, achLZX ) )
        {
            g_CDF.szCompressionType = achLZX;
        }
        else if ( !lstrcmpi( achBuf, achQUANTUM ) )
        {
            g_CDF.szCompressionType = achQUANTUM;
        }
        else if ( !lstrcmpi( achBuf, achNONE ) )
        {
            g_CDF.szCompressionType = achNONE;
        }
        else 
        {
            g_CDF.szCompressionType = achMSZIP;            
        }        

        g_CDF.uCompressionLevel = 7;
    }

    // get reboot info
    g_CDF.dwReboot = 0;
    i = 0;
    MyGetPrivateProfileString( SEC_OPTIONS, KEY_REBOOTMODE, "I", achBuf, sizeof(achBuf), g_szOverideSec );
    while ( achBuf[i] != 0 )
    {
         switch ( toupper(achBuf[i++]) )
         {
             case 'A':
                 g_CDF.dwReboot |= REBOOT_ALWAYS;
                 g_CDF.dwReboot |= REBOOT_YES;
                 break;

             case 'S':
                 g_CDF.dwReboot |= REBOOT_SILENT;
                 break;

             case 'N':
                 g_CDF.dwReboot &= ~(REBOOT_YES);
                 break;

             case 'I':
                 g_CDF.dwReboot &= ~(REBOOT_ALWAYS);
                 g_CDF.dwReboot |= REBOOT_YES;
                 break;

             default:
                 break;
         }
    }

    // get package install space
    g_CDF.cbPackInstSpace = MyGetPrivateProfileInt( SEC_OPTIONS, KEY_PACKINSTSPACE, 0, g_szOverideSec );

    // use CDFStrInfo table to do read for a list of key strings
    arraySize = ARRAY_SIZE( CDFStrInfo );
    for ( i=0; i<arraySize; i++ )
    {
        if ( MyGetPrivateProfileString( CDFStrInfo[i].lpSec, CDFStrInfo[i].lpKey, 
                                             CDFStrInfo[i].lpDef, CDFStrInfo[i].lpBuf, 
                                             CDFStrInfo[i].uSize, CDFStrInfo[i].lpOverideSec ) < 0 )
            goto EXIT;

        if ( CDFStrInfo[i].lpFlag )
        {
            if ( CDFStrInfo[i].lpBuf[0] )
                *(CDFStrInfo[i].lpFlag) = TRUE;
            else
                *(CDFStrInfo[i].lpFlag) = FALSE;
        }
    }

    // generate cab name properly!
    if ( (g_CDF.uPackPurpose == IDC_CMD_CREATECAB ) &&
          !MakeCabName( hDlg, g_CDF.achTarget, g_CDF.achCABPath ) )
          goto EXIT;

    // Read the file list, adding it to our Item list as we go along.
    if ( MyGetPrivateProfileString( SEC_OPTIONS, KEY_FILELIST, "", g_CDF.achSourceFile, sizeof(g_CDF.achSourceFile), g_szOverideSec ) <= 0 )
    {
        uErrid = IDS_ERR_NOSOURCEFILE;
        goto EXIT;
    }

    ulFileSize = __max( FileSize( g_CDF.achFilename ), FileSize( g_szOverideCDF ) );

    //BUGBUG: be smart about buf size to allocate
    szFileList = (LPSTR) LocalAlloc( LPTR, ulFileSize );
    szFileListKeys = (LPSTR) LocalAlloc( LPTR, ulFileSize );
    if ( !szFileList || !szFileListKeys )
    {
        uErrid = IDS_ERR_NO_MEMORY;
        goto EXIT;
    }

    lpSave1 = szFileList;
    lpSave2 = szFileListKeys;
    MyGetPrivateProfileString( g_CDF.achSourceFile, NULL, "", szFileListKeys, ulFileSize/2, g_CDF.achSourceFile );

    while ( *szFileListKeys )
    {
        lstrcpy( achBuf, szFileListKeys );
        szFileListKeys += lstrlen(szFileListKeys);
        szFileListKeys++;  // jump over the single '\0'

        MyGetPrivateProfileString( g_CDF.achSourceFile, achBuf, "", szPath, sizeof(szPath), g_CDF.achSourceFile );

        lRet = MyGetPrivateProfileSection( achBuf, szFileList, ulFileSize, TRUE );

        if ( lRet == 0 )
        {
            // the current CDF format is not match with OS version
            uErrid = IDS_ERR_CDFFORMAT;
            LocalFree( lpSave1 );
            LocalFree( lpSave2 );
            goto EXIT;
        }
        else if ( lRet < 0 )
        {
            uErrid = IDS_ERR_INVALID_CDF;
            LocalFree( lpSave1 );
            LocalFree( lpSave2 );
            goto EXIT;
        }

        // make sure there is a '\' at the end of path
        AddPath( szPath, "" );

        while ( *szFileList )
        {
            FormStrWithoutPlaceHolders( achBuf, szFileList, sizeof(achBuf) );

            pMyItem = AddItem( achBuf, szPath );

            szFileList += lstrlen( szFileList );
            szFileList++;  // jump over the single '\0'
        }
        szFileList = lpSave1;
    }
    LocalFree( lpSave1 );
    LocalFree( lpSave2 );

    // get the target version check info
    //
    if ( g_CDF.pVerInfo )
    {
        lRet = MyGetPrivateProfileString( SEC_OPTIONS, KEY_NTVERCHECK, "", achBuf, sizeof(achBuf), g_szOverideSec );
        if ( (lRet<0) || !ParseTargetVerCheck( achBuf, &(g_CDF.pVerInfo->ntVerCheck), szPath, FALSE ) )
        {
            goto EXIT;
        }
        SetAuthorStr( szPath, &(g_CDF.pVerInfo->ntVerCheck.dwstrOffs) );

        lRet = MyGetPrivateProfileString( SEC_OPTIONS, KEY_WIN9XVERCHECK, "", achBuf, sizeof(achBuf), g_szOverideSec );
        if ( (lRet < 0) || !ParseTargetVerCheck( achBuf, &(g_CDF.pVerInfo->win9xVerCheck), szPath, FALSE ) )
        {
            goto EXIT;
        }
        SetAuthorStr( szPath, &(g_CDF.pVerInfo->win9xVerCheck.dwstrOffs) );

        lRet = MyGetPrivateProfileString( SEC_OPTIONS, KEY_SYSFILE, "", achBuf, sizeof(achBuf), g_szOverideSec );
        if ( lRet < 0 )
            goto EXIT;

        if ( achBuf[0] && g_CDF.pVerInfo->dwNumFiles )
        {
            PVERCHECK pVerChk = NULL;
            
            pVerChk = (PVERCHECK) LocalAlloc( LPTR, g_CDF.pVerInfo->dwNumFiles * (sizeof(VERCHECK)) );
            if ( !pVerChk )
            {
                uErrid = IDS_ERR_NO_MEMORY;
                goto EXIT;
            }

            if ( achBuf[0] == '@' )
            {
                char szLine[MAX_PATH];
                PVERCHECK pVerTmp;

                i = 0;

                pVerTmp = pVerChk;
                MyGetPrivateProfileString( &achBuf[1], NULL, "", szPath, sizeof(szPath), g_szOverideSec );
                while ( szPath[i] )
                {
                    MyGetPrivateProfileString( &achBuf[1], &szPath[i], "", szLine, sizeof(szLine), g_szOverideSec );
                    if ( !ParseTargetFiles( szLine, pVerTmp ) )
                    {
                        LocalFree( pVerChk );
                        uErrid = IDS_ERR_VCHKFILE;
                        goto EXIT;
                    }
                    
                    pVerTmp++;
                    i += lstrlen( &szPath[i] ) + 1;
                }
            }
            else if ( !ParseTargetFiles( achBuf, pVerChk ) )
            {
                LocalFree( pVerChk );
                uErrid = IDS_ERR_VCHKFILE;
                goto EXIT;
            }
            // up to now all the strings have been processed. Put the File data into the struct
            //
            memcpy( (g_CDF.pVerInfo->szBuf + g_CDF.pVerInfo->dwFileOffs), pVerChk, g_CDF.pVerInfo->dwNumFiles * sizeof(VERCHECK) );                        
            LocalFree( pVerChk );   

        }

        g_CDF.pVerInfo->dwSize = sizeof(TARGETVERINFO) + g_CDF.pVerInfo->dwFileOffs + sizeof(VERCHECK)*g_CDF.pVerInfo->dwNumFiles;
    }

    // make sure the target file path exist
    MakeDirectory( NULL, g_CDF.achTarget, FALSE );
    
    // if it is LFN command from FileList, make it consistant with filename in the CAB
    //
    MyProcessLFNCmd( g_CDF.achOrigiInstallCmd, g_CDF.achInstallCmd );
    MyProcessLFNCmd( g_CDF.achOrigiPostInstCmd, g_CDF.achPostInstCmd );
    MyProcessLFNCmd( g_CDF.szOrigiAdmQCmd, g_CDF.szAdmQCmd );
    MyProcessLFNCmd( g_CDF.szOrigiUsrQCmd, g_CDF.szUsrQCmd );

    // after file-list has been read in
    // set EXTRACTOPT_ADVDLL if needed, shorten the command name if needed
    // if the .INF file is not from the file list, return FALSE
    //
    if ( (g_CDF.uPackPurpose == IDC_CMD_RUNCMD) && 
         ( !CheckAdvBit( g_CDF.achOrigiInstallCmd ) ||
         !CheckAdvBit( g_CDF.achOrigiPostInstCmd ) ||
         !CheckAdvBit( g_CDF.szOrigiAdmQCmd ) ||
         !CheckAdvBit( g_CDF.szOrigiUsrQCmd ) ) )
    {
        goto EXIT;
    }

    // successful path
    bRetVal = TRUE;

EXIT:
    if ( uErrid )
        ErrorMsg( hDlg, uErrid );

    return bRetVal;
}

#define MAXDISK_SIZE    "1.44M"
#define CDROM_SIZE      "CDROM"

// define

//***************************************************************************
//*                                                                         *
//* NAME:       WriteDDF                                                    *
//*                                                                         *
//* SYNOPSIS:   Writes out a Diamond Directive File.                        *
//*                                                                         *
//* REQUIRES:   hDlg:           dialog window                               *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
BOOL WriteDDF( HWND hDlg )
{
    HANDLE  hFile;
    DWORD   dwAttr;
    DWORD   dwBytes;
    PMYITEM pMyItem;
    CHAR   achHeader[256];
    LPSTR   szTempLine;
    BOOL    fReturn = TRUE;
    CHAR   achShortPath[MAX_PATH];
    int     i, arraySize;
    LPSTR   lpCurrLine;
    LPSTR   lpFName;

    // These are the lines that will be written out.
    CHAR achLine1[]  = ".Set CabinetNameTemplate=%s\r\n";
    CHAR achLine2[]  = ".Set CompressionType=%s\r\n";
    CHAR achLine3[]  = ".Set CompressionLevel=%u\r\n";
    CHAR achLine4[]  = ".Set InfFileName=%s\r\n";
    CHAR achLine5[]  = ".Set RptFileName=%s\r\n";
    CHAR achLine6[]  = ".Set MaxDiskSize=%s\r\n";
    CHAR achLine7[]  = ".Set ReservePerCabinetSize=%s\r\n";
    CHAR achLine8[]  = ".Set InfCabinetLineFormat=""*cab#*=""%s"",""*cabfile*"",0""\r\n";
    CHAR achLine9[]  = ".Set Compress=%s\r\n";
    CHAR achLine10[] = ".Set CompressionMemory=%d\r\n";

    PSTR  pszDDFLine[] = {         //  11 lines no param needed
                ".Set DiskDirectoryTemplate=\r\n",
                ".Set Cabinet=ON\r\n",
                ".Set MaxCabinetSize=999999999\r\n",
                ".Set InfDiskHeader=\r\n",
                ".Set InfDiskLineFormat=\r\n",
                ".Set InfCabinetHeader=""[SourceDisksNames]""\r\n",
                ".Set InfFileHeader=""""\r\n",
                ".Set InfFileHeader1=""[SourceDisksFiles]""\r\n",
                ".Set InfFileLineFormat=""*file*=*cab#*,,*size*,*csum*""\r\n",
                NULL,
                };

    hFile = CreateFile( g_CDF.achDDF, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL, NULL );

    if ( hFile == INVALID_HANDLE_VALUE )  {
        ErrorMsg( hDlg, IDS_ERR_OPEN_DDF );
        return FALSE;
    }

    // allocate a working buffer once which is big enough for every line
    //
    szTempLine = (LPSTR) LocalAlloc( LPTR,  MAX_STRING );
    if ( ! szTempLine )  {
        ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
        CloseHandle( hFile );
        return FALSE;
    }

    LoadSz( IDS_DDF_HEADER, achHeader, sizeof(achHeader) );
    WriteFile( hFile, achHeader, lstrlen( achHeader ), &dwBytes, NULL );

    wsprintf( szTempLine, achLine1, g_CDF.achCABPath );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    wsprintf( szTempLine, achLine2, g_CDF.szCompressionType );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    wsprintf( szTempLine, achLine3, g_CDF.uCompressionLevel );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    wsprintf( szTempLine, achLine4, g_CDF.achINF );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    wsprintf( szTempLine, achLine5, g_CDF.achRPT );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    if ( g_CDF.uExtractOpt & CAB_FIXEDSIZE )
        lpCurrLine = MAXDISK_SIZE;
    else
        lpCurrLine = CDROM_SIZE;

    wsprintf( szTempLine, achLine6, lpCurrLine );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    if ( g_CDF.uExtractOpt & CAB_RESVSP2K )
        i = 1;
    else if ( g_CDF.uExtractOpt & CAB_RESVSP4K )
        i = 2;
    else if ( g_CDF.uExtractOpt & CAB_RESVSP6K )
        i = 3;
    else
        i = 0;

    wsprintf( szTempLine, achLine7, pResvSizes[i] );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    wsprintf( szTempLine, achLine8, g_CDF.szCabLabel );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    MyGetPrivateProfileString( SEC_OPTIONS, KEY_COMPRESS, "on", achShortPath, sizeof(achShortPath), g_szOverideSec );    
    wsprintf( szTempLine, achLine9, achShortPath );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    i = MyGetPrivateProfileInt( SEC_OPTIONS, KEY_COMPRESSMEMORY, 21, g_szOverideSec );    
    if ( i <= 0 )
        i = 21;
    wsprintf( szTempLine, achLine10, i );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    i = 0;
    while ( pszDDFLine[i] )
    {
       WriteFile( hFile, pszDDFLine[i], lstrlen( pszDDFLine[i] ), &dwBytes, NULL );
       i++;
    }

    pMyItem = GetFirstItem();
    while ( fReturn && ! LastItem( pMyItem ) )  {

        lstrcpy( szTempLine, GetItemSz( pMyItem, 1 ) );
        lstrcat( szTempLine, GetItemSz( pMyItem, 0 ) );

        dwAttr = GetFileAttributes( szTempLine );
        if ( ( dwAttr == -1 ) || ( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) )  {
            ErrorMsg1Param( hDlg, IDS_ERR_FILE_NOT_FOUND2, szTempLine );
            LocalFree( szTempLine );
            CloseHandle( hFile );
            return FALSE;
        }

        if ( g_CDF.uExtractOpt & EXTRACTOPT_LFN_YES )
        {
            lstrcpy( achShortPath, "\"" );
            lstrcat( achShortPath, szTempLine );
            lstrcat( achShortPath, "\"" );
        }
        else
        {
            if ( ! GetShortPathName( szTempLine, achShortPath,
                   sizeof(achShortPath) ) )
            {
                ErrorMsg( hDlg, IDS_ERR_SHORT_PATH );
                LocalFree( szTempLine );
                CloseHandle( hFile );
                return FALSE;
            }
        }

        WriteFile( hFile, achShortPath, lstrlen(achShortPath), &dwBytes, NULL );
        fReturn = WriteFile( hFile, "\r\n", lstrlen("\r\n"), &dwBytes, NULL );

        pMyItem = GetNextItem( pMyItem );
    }

    if ( fReturn && g_CDF.uExtractOpt & EXTRACTOPT_ADVDLL )
    {
        SYSTEM_INFO SystemInfo;
        int         ix86Processor;
        
        GetSystemInfo( &SystemInfo );
        ix86Processor = MyGetPrivateProfileInt( SEC_OPTIONS, KEY_CROSSPROCESSOR, -1, g_szOverideSec );
            
        if ( (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) && 
             (ix86Processor != 0) ||
             (SystemInfo.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) &&
             (ix86Processor == 1) )
        {           
            arraySize = ARRAY_SIZE( AdvDlls );
        }
        else
        {
            arraySize = 1;
        }        
       
        // add 3 advanced DLLS for handling OCX regiester or CustomDestination
        for ( i = 0; (i<arraySize) && fReturn; i++ )
        {
            if ( !IsDuplicate( NULL, 0, AdvDlls[i], FALSE) )
            {
                if ( !GetFileFromModulePath( AdvDlls[i], achShortPath, sizeof(achShortPath) ) )
                {
                    ErrorMsg1Param( hDlg, IDS_ERR_FILE_NOT_FOUND, achShortPath );
                    LocalFree( szTempLine );
                    CloseHandle( hFile );
                    return FALSE;
                }
                lstrcpy( szTempLine, "\"" );
                lstrcat( szTempLine, achShortPath );
                lstrcat( szTempLine, "\"" );
                WriteFile( hFile, szTempLine, lstrlen(szTempLine), &dwBytes, NULL );
                fReturn = WriteFile( hFile, "\r\n", strlen("\r\n"), &dwBytes, NULL );
            }
        }
    }

    LocalFree( szTempLine );
    CloseHandle( hFile );

    if ( fReturn == FALSE )  {
        ErrorMsg( hDlg, IDS_ERR_WRITE_DDF );
        return FALSE;
    } else  {
        return TRUE;
    }
}

//***************************************************************************
//*                                                                         *
//* NAME:       MasskePackage                                                 *
//*                                                                         *
//* SYNOPSIS:   Makes the full package (CAB and EXE).                       *
//*                                                                         *
//* REQUIRES:   hDlg:           Handle to the dialog                        *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL MakePackage( HWND hDlg )
{
    CHAR   achDrive[_MAX_DRIVE];
    CHAR   achDir[_MAX_DIR];
    CHAR   achStatus[MAX_STRING];
    CHAR   szExt[6];
    BOOL    fReturn = TRUE;
    PSTR   pTmp;

    // Build the paths to the files, using the target path as a
    // template.  We create the DDF, CAB and INF file in the
    // same directory as the target file.

    _splitpath( g_CDF.achTarget, achDrive, achDir, g_CDF.achTargetBase, szExt);

    lstrcpy( g_CDF.achTargetPath, achDrive );
    lstrcat( g_CDF.achTargetPath, achDir );

    lstrcpy( g_CDF.achDDF, g_CDF.achTargetPath );
    wsprintf( achStatus, CABPACK_TMPFILE, g_CDF.achTargetBase, EXT_DDF );
    AddPath( g_CDF.achDDF, achStatus );

    if ( g_CDF.achINF[0] == 0 )
    {
        lstrcpy( g_CDF.achINF, g_CDF.achTargetPath );
        wsprintf( achStatus, CABPACK_INFFILE, g_CDF.achTargetBase );
        AddPath( g_CDF.achINF, achStatus );
    }

    lstrcpy( g_CDF.achRPT, g_CDF.achTargetPath );
    wsprintf( achStatus, CABPACK_TMPFILE, g_CDF.achTargetBase, EXT_RPT );
    AddPath( g_CDF.achRPT, achStatus );

    if ( g_CDF.uPackPurpose != IDC_CMD_CREATECAB )
    {
        wsprintf( achStatus, CABPACK_TMPFILE, g_CDF.achTargetBase, EXT_CAB );
        lstrcpy( g_CDF.achCABPath, g_CDF.achTargetPath );
        AddPath( g_CDF.achCABPath, achStatus );
        g_CDF.szCompressionType = achLZX;
        g_CDF.uCompressionLevel = 7; 
    }

    if ( g_CDF.fSave )  {
        if ( ! WriteCDF( hDlg ) )  {
            LoadSz( IDS_STATUS_ERROR_CDF, achStatus, sizeof(achStatus) );
            Status( hDlg, IDC_MEDIT_STATUS, achStatus );
            fReturn = FALSE;
            goto done;
        }
    }

    if ( ! MakeCAB( hDlg ) )  {
        LoadSz( IDS_STATUS_ERROR_CAB, achStatus, sizeof(achStatus) );
        Status( hDlg, IDC_MEDIT_STATUS, achStatus );
        fReturn = FALSE;
        goto done;
    }

    // if use choose to create CAB file only, MakeEXE() is not needed
    //
    if ( g_CDF.uPackPurpose != IDC_CMD_CREATECAB )
    {
        if ( ! MakeEXE( hDlg ) )  {
            LoadSz( IDS_STATUS_ERROR_EXE, achStatus, sizeof(achStatus) );
            Status( hDlg, IDC_MEDIT_STATUS, achStatus );
            fReturn = FALSE;
            goto done;
        }

        if ( MyGetPrivateProfileInt( SEC_OPTIONS, KEY_KEEPCABINET, 0, g_szOverideSec )
             == 0 )
        {
            DeleteFile( g_CDF.achCABPath );
        }
    }

    LoadSz( IDS_STATUS_DONE, achStatus, sizeof(achStatus) );
    Status( hDlg, IDC_MEDIT_STATUS, achStatus );

  done:

    // if failure happen, clean the filewriteout flag to prepare for next CDF out
    if ( !fReturn )    
        CleanFileListWriteFlag();


    return fReturn;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MakeCAB                                                     *
//*                                                                         *
//* SYNOPSIS:   Makes the cabinet file if it is out of date.                *
//*                                                                         *
//* REQUIRES:   hDlg:           Handle to the dialog                        *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL MakeCAB( HWND hDlg )
{
    CHAR    achMessage[512];            // Used in FormatMessage()
    DWORD    dwError;                    // Used in GetLastError()
    LPSTR   szCommand;
    HANDLE   hFile;
    LPSTR    szTempFile;
    ULONG    ulFileSize;
    LPSTR    szFileContents;
    DWORD    dwBytes;
    CHAR    achDiamondExe[MAX_PATH];
    CHAR    achDiamondPath[MAX_PATH];
    CHAR    achStatus[MAX_STRING];
    BOOL     fFilesModified = FALSE;
    DWORD    dwExitCode;
    STARTUPINFO         sti;
    PROCESS_INFORMATION pi;             // Setup Process Launch
    WIN32_FIND_DATA     FindFileData;
    DWORD     dwCreationFlags;

    //FindClose( hFile );

    LoadSz( IDS_STATUS_MAKE_CAB, achStatus, sizeof(achStatus) );
    Status( hDlg, IDC_MEDIT_STATUS, achStatus );

    if ( ! WriteDDF( hDlg ) )  {
        return FALSE;
    }

    // Make the CAB file

    if ( lstrcmpi( g_CDF.szCompressionType, achQUANTUM ) == 0 ) {
        lstrcpy( achDiamondExe, DIAMONDEXE );
    } else {
        lstrcpy( achDiamondExe, DIANTZEXE );
    }

    if ( !GetFileFromModulePath( achDiamondExe, achDiamondPath, sizeof(achDiamondPath) ) )
    {
        ErrorMsg1Param( hDlg, IDS_ERR_FILE_NOT_FOUND, achDiamondPath );
        return FALSE;
    }

    // The +5 is to handle the " /f " in the wsprintf format string
    // and for the terminating null char.
    //
    szCommand = (LPSTR) LocalAlloc( LPTR,   lstrlen(achDiamondPath)
                                           + lstrlen(g_CDF.achDDF)
                                           + 10 );
    if ( ! szCommand )  {
        ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
        return FALSE;
    }
    wsprintf( szCommand, "%s /f \"%s\"", achDiamondPath, g_CDF.achDDF );

    memset( &sti, 0, sizeof(sti) );
    sti.cb = sizeof(STARTUPINFO);

	if (g_wRunDiamondMinimized) {
        sti.dwFlags = STARTF_USESHOWWINDOW;
        sti.wShowWindow = SW_MINIMIZE;
    }
    else if (g_wQuietMode || g_wSilentMode) {
        sti.dwFlags = STARTF_USESHOWWINDOW;
        sti.wShowWindow = SW_HIDE;
    }

    if (!g_wQuietMode)
        dwCreationFlags = 0;
    else
        dwCreationFlags = CREATE_NO_WINDOW;

    if ( CreateProcess( NULL, szCommand, NULL, NULL, FALSE,
                                     dwCreationFlags, NULL, NULL, &sti, &pi ) )
    {
        CloseHandle( pi.hThread );
        MsgWaitForMultipleObjectsLoop( pi.hProcess );
        GetExitCodeProcess( pi.hProcess, &dwExitCode );
        CloseHandle( pi.hProcess );
    } else  {
        dwError = GetLastError();
        FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0,
                       achMessage, sizeof(achMessage), NULL );
        ErrorMsg2Param( hDlg, IDS_ERR_START_DIAMOND, szCommand,
                        achMessage );
    }

    LocalFree( szCommand );

    Status( hDlg, IDC_MEDIT_STATUS, "---\r\n" );

    hFile = FindFirstFile( g_CDF.achRPT, &FindFileData );
    ulFileSize =   (FindFileData.nFileSizeHigh * MAXDWORD)
                 + FindFileData.nFileSizeLow;
    FindClose( hFile );

    hFile = CreateFile( g_CDF.achRPT, GENERIC_READ, 0, NULL,
                        OPEN_EXISTING, 0, NULL );
    if ( hFile == INVALID_HANDLE_VALUE ) {
        ErrorMsg1Param( hDlg, IDS_ERR_OPEN_RPT, g_CDF.achRPT );
        return FALSE;
    }

    szFileContents = (LPSTR) LocalAlloc( LPTR, ulFileSize + 1 );
    if ( ! szFileContents )  {
        ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
        return FALSE;
    }

    if ( ! ReadFile( hFile, szFileContents, ulFileSize,
                     &dwBytes, NULL ) ) {
        ErrorMsg1Param( hDlg, IDS_ERR_READ_RPT, g_CDF.achRPT );
        return FALSE;
    }

    CloseHandle( hFile );

    Status( hDlg, IDC_MEDIT_STATUS, szFileContents );

    LocalFree( szFileContents );

    Status( hDlg, IDC_MEDIT_STATUS, "---\r\n" );

    if ( MyGetPrivateProfileInt( SEC_OPTIONS, KEY_KEEPCABINET, 0, g_szOverideSec )
         == 0 )
    {
        DeleteFile( g_CDF.achDDF );
    }
    if ( !(g_CDF.uExtractOpt & CAB_FIXEDSIZE) )
        DeleteFile( g_CDF.achINF );
    DeleteFile( g_CDF.achRPT );

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       MakeEXE                                                     *
//*                                                                         *
//* SYNOPSIS:   Copies WEXTRACT.EXE to the target filename and adds         *
//*             resources to it.                                            *
//*                                                                         *
//* REQUIRES:   hDlg:           Handle to the dialog                        *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL MakeEXE( HWND hDlg )
{
    HANDLE  hUpdate;
    CHAR   achMessage[512];            // Used in FormatMessage()
    DWORD   dwError;                    // Used in GetLastError()
    PMYITEM pMyItem;
    HANDLE  hFile;
    LPSTR   szTempFile;
    ULONG   ulFileSize;
    LPSTR   szFileContents;
    DWORD   dwBytes;
    CHAR   achWExtractPath[MAX_PATH];
    CHAR   achStatus[MAX_STRING];
    WIN32_FIND_DATA FindFileData;
    DWORD   dwFileSizes[MAX_NUMCLUSTERS+1]; // store the filesize in each cluster sizes.
                            // the last of dwFileSizes is used to store real
                            // total file sizes later used for calculate
                            // progress bar in wextract
    DWORD   clusterCurrSize;
    int     i;
    UINT    idErr = IDS_ERR_UPDATE_RESOURCE;

    // get ExtractorStub based on CDF specification.  Wextract.exe is default one.
    //

    LoadSz( IDS_STATUS_MAKE_EXE, achStatus, sizeof(achStatus) );
    Status( hDlg, IDC_MEDIT_STATUS, achStatus );

    if ( !MyGetPrivateProfileString( SEC_OPTIONS, KEY_STUBEXE, WEXTRACTEXE, achStatus, sizeof(achStatus), g_szOverideSec ) )
    {
        lstrcpy( achStatus, WEXTRACTEXE );
    }

    if ( !GetFileFromModulePath(achStatus, achWExtractPath, sizeof(achWExtractPath) ) )
    {
        ErrorMsg1Param( hDlg, IDS_ERR_FILE_NOT_FOUND, achWExtractPath );
        return FALSE;
    }

    if ( ! CopyFile( achWExtractPath, g_CDF.achTarget, FALSE ) ) {
        dwError = GetLastError();
        FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0,
                       achMessage, sizeof(achMessage), NULL );
        ErrorMsg2Param( hDlg, IDS_ERR_CREATE_TARGET, g_CDF.achTarget,
                        achMessage );
        return FALSE;
    }

    // make sure the targe file is not read-only file
    SetFileAttributes( g_CDF.achTarget, FILE_ATTRIBUTE_NORMAL );

    // Initialize the EXE file for resource editing
    hUpdate = LocalBeginUpdateResource( g_CDF.achTarget, FALSE );
    if ( hUpdate == NULL ) {
        ErrorMsg1Param( hDlg, IDS_ERR_INIT_RESOURCE, g_CDF.achTarget );
        return FALSE;
    }


    //*******************************************************************
    //* TITLE ***********************************************************
    //*******************************************************************

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResTitle, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         g_CDF.achTitle, lstrlen( g_CDF.achTitle ) + 1 ) == FALSE )
    {
        goto ERR_OUT;
    }

    //*******************************************************************
    //* PROMPT **********************************************************
    //*******************************************************************

    if ( g_CDF.fPrompt )  {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResUPrompt, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             g_CDF.achPrompt, lstrlen( g_CDF.achPrompt ) + 1 ) == FALSE )
        {
            goto ERR_OUT;
        }
    } else  {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResUPrompt, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             achResNone, lstrlen( achResNone ) + 1 ) == FALSE )
        {
            goto ERR_OUT;
        }
    }

    //*******************************************************************
    //* LICENSE FILE ****************************************************
    //*******************************************************************

    if ( g_CDF.fLicense )  {
        hFile = FindFirstFile( g_CDF.achLicense, &FindFileData );
        ulFileSize =   (FindFileData.nFileSizeHigh * MAXDWORD)
                     + FindFileData.nFileSizeLow;
        FindClose( hFile );

        hFile = CreateFile( g_CDF.achLicense, GENERIC_READ, 0, NULL,
                            OPEN_EXISTING, 0, NULL );
        if ( hFile == INVALID_HANDLE_VALUE ) {
            ErrorMsg1Param( hDlg, IDS_ERR_OPEN_LICENSE, g_CDF.achLicense );
            DeleteFile(g_CDF.achTarget);
            return FALSE;
        }

        szFileContents = (LPSTR) LocalAlloc( LPTR, ulFileSize + 1 );
        if ( ! szFileContents )  {
            ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
            DeleteFile(g_CDF.achTarget);
            return FALSE;
        }

        if ( ! ReadFile( hFile, szFileContents, ulFileSize,
                         &dwBytes, NULL ) ) {
            ErrorMsg1Param( hDlg, IDS_ERR_READ_LICENSE, g_CDF.achLicense );
            DeleteFile(g_CDF.achTarget);
            return FALSE;
        }

        CloseHandle( hFile );

        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResLicense, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             szFileContents, ulFileSize+1 ) == FALSE )
        {            
            LocalFree( szFileContents );
            goto ERR_OUT;
        }

        LocalFree( szFileContents );
    } else  {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResLicense, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             achResNone, lstrlen( achResNone ) + 1 ) == FALSE )
        {
            goto ERR_OUT;
        }
    }

    //*******************************************************************
    //* COMMAND *********************************************************
    //*******************************************************************


    if ( g_CDF.uPackPurpose != IDC_CMD_EXTRACT )
    {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResRunProgram, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
             g_CDF.achInstallCmd, lstrlen(g_CDF.achInstallCmd)+1 ) == FALSE )
        {
            goto ERR_OUT;
        }

        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResPostRunCmd, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
             g_CDF.achPostInstCmd, lstrlen(g_CDF.achPostInstCmd)+1 ) == FALSE )
        {
            goto ERR_OUT;
        }

        //write quiet cmds resource
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResAdminQCmd, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
             g_CDF.szAdmQCmd[0]?g_CDF.szAdmQCmd : achResNone,
             g_CDF.szAdmQCmd[0]?(lstrlen(g_CDF.szAdmQCmd)+1) : (lstrlen(achResNone)+1) ) == FALSE )
        {
            goto ERR_OUT;
        }

        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResUserQCmd, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
             g_CDF.szUsrQCmd[0]?g_CDF.szUsrQCmd : achResNone,
             g_CDF.szUsrQCmd[0]?(lstrlen(g_CDF.szUsrQCmd)+1) : (lstrlen(achResNone)+1) ) == FALSE )
        {
            goto ERR_OUT;
        }

    }
    else
    {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResRunProgram, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             achResNone, lstrlen( achResNone ) + 1 ) == FALSE )
        {
            goto ERR_OUT;
        }
    }

    //*******************************************************************
    //* SHOW WINDOW *****************************************************
    //*******************************************************************

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResShowWindow, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         &g_CDF.uShowWindow, sizeof(g_CDF.uShowWindow) ) == FALSE )
    {
            goto ERR_OUT;
    }

    //*******************************************************************
    //* FINISHMSG *******************************************************
    //*******************************************************************

    if ( g_CDF.fFinishMsg )  {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResFinishMsg, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             g_CDF.achFinishMsg, lstrlen( g_CDF.achFinishMsg ) + 1 ) == FALSE )
        {
            goto ERR_OUT;
        }
    }
    else
    {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResFinishMsg, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             achResNone, lstrlen( achResNone ) + 1 ) == FALSE )
        {
            goto ERR_OUT;
        }
    }

    //*******************************************************************
    //* CABINET *********************************************************
    //*******************************************************************

    hFile = FindFirstFile( g_CDF.achCABPath, &FindFileData );
    ulFileSize =   (FindFileData.nFileSizeHigh * MAXDWORD)
                 + FindFileData.nFileSizeLow;
    FindClose( hFile );

    hFile = CreateFile( g_CDF.achCABPath, GENERIC_READ, 0, NULL,
                        OPEN_EXISTING, 0, NULL );
    if ( hFile == INVALID_HANDLE_VALUE ) {
        ErrorMsg1Param( hDlg, IDS_ERR_OPEN_CAB, g_CDF.achCABPath );
        DeleteFile(g_CDF.achTarget);
        return FALSE;
    }

    szFileContents = (LPSTR) LocalAlloc( LPTR, ulFileSize + 1 );
    if ( ! szFileContents )  {
        idErr = IDS_ERR_NO_MEMORY;
        goto ERR_OUT;
    }

    if ( ! ReadFile( hFile, szFileContents, ulFileSize, &dwBytes, NULL ) ) {
        ErrorMsg1Param( hDlg, IDS_ERR_READ_CAB, g_CDF.achCABPath );
        DeleteFile(g_CDF.achTarget);        
        return FALSE;
    }

    CloseHandle( hFile );

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResCabinet, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         szFileContents, ulFileSize ) == FALSE )
    {        
        LocalFree( szFileContents );
        goto ERR_OUT;
    }

    LocalFree( szFileContents );


    //*******************************************************************
    //* FILES ***********************************************************
    //*******************************************************************

    pMyItem = GetFirstItem();
    RtlZeroMemory( dwFileSizes, sizeof(dwFileSizes));

    while ( ! LastItem( pMyItem ) )  {

        szTempFile = (LPSTR) LocalAlloc( LPTR,
                       lstrlen( GetItemSz( pMyItem, 0 ) )
                     + lstrlen( GetItemSz( pMyItem, 1 ) ) + 1 );
        if ( ! szTempFile )  {
            idErr = IDS_ERR_NO_MEMORY;
            goto ERR_OUT;
        }
        lstrcpy( szTempFile, GetItemSz( pMyItem, 1 ) );
        lstrcat( szTempFile, GetItemSz( pMyItem, 0 ) );
        hFile = FindFirstFile( szTempFile, &FindFileData );
        ulFileSize =   (FindFileData.nFileSizeHigh * MAXDWORD)
                     + FindFileData.nFileSizeLow;
        FindClose( hFile );
        LocalFree( szTempFile );

        // calculate the file size in different cluster sizes
        clusterCurrSize = CLUSTER_BASESIZE;
        for ( i = 0; i<MAX_NUMCLUSTERS; i++)
        {

            dwFileSizes[i] += ((ulFileSize/clusterCurrSize)*clusterCurrSize +
                                (ulFileSize%clusterCurrSize?clusterCurrSize : 0));
            clusterCurrSize = (clusterCurrSize<<1);
        }

        // this size is not allocated size, just real accumulation
        // of the files for later progress bar UI use
        dwFileSizes[MAX_NUMCLUSTERS] += ulFileSize;

        pMyItem = GetNextItem( pMyItem );
    }

    for ( i = 0; i<MAX_NUMCLUSTERS; i++)
    {
        dwFileSizes[i] = (dwFileSizes[i]+1023)/1024;  //store in KB	
    }

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResSize, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         dwFileSizes, sizeof(dwFileSizes) ) == FALSE )
    {
            goto ERR_OUT;
    }

    //*******************************************************************
    //* REBOOT    *******************************************************
    //*******************************************************************

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResReboot, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         &g_CDF.dwReboot, sizeof(g_CDF.dwReboot) ) == FALSE )
    {
            goto ERR_OUT;
    }

    //*******************************************************************
    //* EXTRACTOPT   ****************************************************
    //*******************************************************************

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResExtractOpt, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         &g_CDF.uExtractOpt, sizeof(g_CDF.uExtractOpt) ) == FALSE )
    {
            goto ERR_OUT;
    }

    //*******************************************************************
    //* COOKIE       ****************************************************
    //*******************************************************************

    if ( g_CDF.lpszCookie && LocalUpdateResource( hUpdate, RT_RCDATA,
         achResOneInstCheck, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         g_CDF.lpszCookie, lstrlen(g_CDF.lpszCookie)+1 ) == FALSE )
    {
            goto ERR_OUT;
    }

    //*******************************************************************
    //* PACKINSTSPACE  **************************************************
    //*******************************************************************

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResPackInstSpace, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         &g_CDF.cbPackInstSpace, sizeof(g_CDF.cbPackInstSpace) ) == FALSE )
    {
            goto ERR_OUT;
    }

    // Update the version information. The function calls LocaleUpdateResource.
    if (!DoVersionInfo(hDlg, achWExtractPath, hUpdate))
    {
        idErr = IDS_ERR_VERSION_INFO;
        goto ERR_OUT;
    }

    //*******************************************************************
    //* TARGETVERSION  **************************************************
    //*******************************************************************
    if ( g_CDF.pVerInfo )
    {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResVerCheck, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             g_CDF.pVerInfo, g_CDF.pVerInfo->dwSize ) == FALSE )
        {
                goto ERR_OUT;
        }
    }
    //*******************************************************************
    //* DONE ************************************************************
    //*******************************************************************

    // Write out modified EXE
    if ( LocalEndUpdateResource( hUpdate, FALSE ) == FALSE )
    {
        idErr = IDS_ERR_CLOSE_RESOURCE;
        goto ERR_OUT;
    }

    return TRUE;

ERR_OUT:
    ErrorMsg( hDlg, idErr );
    // error occurs, clean up the uncompleted target file
    DeleteFile(g_CDF.achTarget);
    return FALSE;

}


//***************************************************************************
//*                                                                         *
//* NAME:       MyOpen                                                      *
//*                                                                         *
//* SYNOPSIS:   Makes popping up a common file open dialog simpler.         *
//*                                                                         *
//* REQUIRES:   Some of the members of the OPENFILENAME structure. See      *
//*             the docs on OPENFILENAME for more info.                     *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
BOOL MyOpen( HWND hWnd, UINT idFilter, LPSTR szFilename,
             DWORD dwMaxFilename, DWORD dwFlags, INT *nFileOffset,
             INT *nExtOffset, PSTR pszDefExt )
{
    OPENFILENAME ofn;
    BOOL         fResult;
    LPSTR        szFilter;

    szFilter = (LPSTR) LocalAlloc( LPTR, MAX_STRING );

    if ( ! szFilter )  {
        ErrorMsg( hWnd, IDS_ERR_NO_MEMORY );
        return FALSE;
    }

    LoadSz( idFilter, szFilter, MAX_STRING );

    ofn.lStructSize         = sizeof(OPENFILENAME);
    ofn.hwndOwner           = hWnd;
    ofn.hInstance           = NULL;
    ofn.lpstrFilter         = szFilter;
    ofn.lpstrCustomFilter   = NULL;
    ofn.nMaxCustFilter      = 0;
    ofn.nFilterIndex        = 1;
    ofn.lpstrFile           = szFilename;
    ofn.nMaxFile            = dwMaxFilename;
    ofn.lpstrFileTitle      = NULL;
    ofn.nMaxFileTitle       = 0;
    ofn.lpstrInitialDir     = g_szInitialDir;
    ofn.lpstrTitle          = NULL;
    ofn.Flags               = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
                              OFN_PATHMUSTEXIST | OFN_LONGNAMES    |
                              OFN_NOCHANGEDIR   | OFN_EXPLORER     |
                              OFN_NODEREFERENCELINKS | dwFlags;

    if ( IsOSNT3X() )
    {
        ofn.Flags &= ~OFN_ALLOWMULTISELECT;
    }

    ofn.lpstrDefExt         = pszDefExt;
    ofn.lCustData           = 0;
    ofn.lpfnHook            = NULL;
    ofn.lpTemplateName      = NULL;

    fResult = GetOpenFileName( &ofn );

    if ( nFileOffset != NULL )  {
        *nFileOffset = ofn.nFileOffset;
    }

    if ( nExtOffset != NULL )  {
        *nExtOffset = ofn.nFileExtension;
    }

    LocalFree( szFilter );

    return( fResult );
}


//***************************************************************************
//*                                                                         *
//* NAME:       MySave                                                      *
//*                                                                         *
//* SYNOPSIS:   Makes popping up a common file save dialog simpler.         *
//*                                                                         *
//* REQUIRES:   Some of the members of the OPENFILENAME structure. See      *
//*             the docs on OPENFILENAME for more info.                     *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
BOOL MySave( HWND hWnd, UINT idFilter, LPSTR szFilename,
             DWORD dwMaxFilename, DWORD dwFlags, INT *nFileOffset,
             INT *nExtOffset, PSTR pszDefExt )
{
    OPENFILENAME ofn;
    BOOL         fResult;
    LPSTR        szFilter;

    szFilter = (LPSTR) LocalAlloc( LPTR, MAX_STRING );
    if ( ! szFilter )  {
        ErrorMsg( hWnd, IDS_ERR_NO_MEMORY );
        return FALSE;
    }
    LoadSz( idFilter, szFilter, MAX_STRING );

    ofn.lStructSize         = sizeof(OPENFILENAME);
    ofn.hwndOwner           = hWnd;
    ofn.hInstance           = NULL;
    ofn.lpstrFilter         = szFilter;
    ofn.lpstrCustomFilter   = NULL;
    ofn.nMaxCustFilter      = 0;
    ofn.nFilterIndex        = 1;
    ofn.lpstrFile           = szFilename;
    ofn.nMaxFile            = dwMaxFilename;
    ofn.lpstrFileTitle      = NULL;
    ofn.nMaxFileTitle       = 0;
    ofn.lpstrInitialDir     = NULL;
    ofn.lpstrTitle          = NULL;
    ofn.Flags               = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST |
                              OFN_LONGNAMES    | OFN_NOCHANGEDIR   | dwFlags;
    ofn.lpstrDefExt         = pszDefExt;
    ofn.lCustData           = 0;
    ofn.lpfnHook            = NULL;
    ofn.lpTemplateName      = NULL;

    fResult = GetSaveFileName( &ofn );

    if ( nFileOffset != NULL )  {
        *nFileOffset = ofn.nFileOffset;
    }

    if ( nExtOffset != NULL )  {
        *nExtOffset = ofn.nFileExtension;
    }

    LocalFree( szFilter );
    
    return( fResult );
}


//***************************************************************************
//*                                                                         *
//* NAME:       Status                                                      *
//*                                                                         *
//* SYNOPSIS:   Adds a string to a status list box.                         *
//*                                                                         *
//* REQUIRES:   hDlg:           Handle to the dialog                        *
//*             uID:            ID of the list box.                         *
//*             szStatus:       Status string to add.                       *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID Status( HWND hDlg, UINT uID, LPSTR szStatus )
{
    ULONG ulLength;

    if ( hDlg != NULL )  {
        ulLength = (ULONG)SendDlgItemMessage( hDlg, uID, WM_GETTEXTLENGTH, 0, 0 );
        SendDlgItemMessage( hDlg, uID, EM_SETSEL, ulLength, ulLength );
        SendDlgItemMessage( hDlg, uID, EM_REPLACESEL,
                            (WPARAM) FALSE, (LPARAM) szStatus );
        SendDlgItemMessage( hDlg, uID, EM_SCROLLCARET, 0, 0 );
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       CompareFunc                                                 *
//*                                                                         *
//* SYNOPSIS:   Compares two items and returns result.                      *
//*                                                                         *
//* REQUIRES:   lParam1:        Pointer to the first item.                  *
//*             uID:            Pointer to the second item.                 *
//*             lParamSort:     Type of sorting to do.                      *
//*                                                                         *
//* RETURNS:    int:            -1 if lParam1 goes before lParam2           *
//*                              0 if lParam1 equals lParam2                *
//*                             +1 if lParam1 goes after lParam2            *
//*                                                                         *
//* NOTES:      For some weird reason, sorting the listview causes a        *
//*             really bad GPF (freezes the entire system).  For now it's   *
//*             not worth the effort to fix it, so sorting is disabled.     *
//*                                                                         *
//***************************************************************************
/*
int CALLBACK CompareFunc( LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort )
{
    PMYITEM pMyItem1 = (PMYITEM) lParam1;
    PMYITEM pMyItem2 = (PMYITEM) lParam2;
    int     nReverse = 1;
    UINT    uString  = 0;

    lParamSort = _SORT_DESCENDING | _SORT_FILENAME;

    if ( lParamSort & _SORT_ASCENDING )  {
        nReverse = -1;
    }

    if ( lParamSort & _SORT_PATH )  {
        uString = 1;
    }

    return ( nReverse * lstrcmp( GetItemSz( pMyItem1, uString ),
                                 GetItemSz( pMyItem2, uString ) ) );
}
*/

//***************************************************************************
//*                                                                         *
//* NAME:       InitItemList                                                *
//*                                                                         *
//* SYNOPSIS:   Initializes the item list.                                  *
//*                                                                         *
//* REQUIRES:   Nothing -- uses the global g_CDF.pTop                       *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID InitItemList()
{
    g_CDF.pTop = NULL;
    g_CDF.cbFileListNum = 0;
}

//***************************************************************************
//*                                                                         *
//* NAME:       DeleteAllItems                                              *
//*                                                                         *
//* SYNOPSIS:   Deletes all the items from our file list.                   *
//*                                                                         *
//* REQUIRES:   Nothing -- uses the global g_CDF.pTop                       *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID DeleteAllItems()
{
    PMYITEM pMyItem;
    PMYITEM pTempItem;

    pMyItem = GetFirstItem();

    while( ! LastItem( pMyItem ) ) {
        pTempItem = pMyItem;
        pMyItem = GetNextItem( pMyItem );

        FreeItem( &(pTempItem) );
    }

    InitItemList();
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetFirstItem                                                *
//*                                                                         *
//* SYNOPSIS:   Returns the first PMYITEM in the list                       *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    PMYITEM         The first item                              *
//*                                                                         *
//***************************************************************************
PMYITEM GetFirstItem( VOID )
{
    return g_CDF.pTop;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetNextItem                                                 *
//*                                                                         *
//* SYNOPSIS:   Given the current item, returns the next item in the list.  *
//*                                                                         *
//* REQUIRES:   pMyItem:        The current item.                           *
//*                                                                         *
//* RETURNS:    PMYITEM         The next item.                              *
//*                                                                         *
//***************************************************************************
PMYITEM GetNextItem( PMYITEM pMyItem )
{
    ASSERT( pMyItem != NULL );

    return pMyItem->Next;
}

//***************************************************************************
//*                                                                         *
//* NAME:       FreeItem                                                    *
//*                                                                         *
//* SYNOPSIS:   Frees the memory associated with an item.                   *
//*                                                                         *
//* REQUIRES:   *pMyItem        Pointer to a pointer to an item             *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID FreeItem( PMYITEM *pMyItem )
{
    LocalFree( (*pMyItem)->aszCols[0] );
    LocalFree( (*pMyItem)->aszCols[1] );
    LocalFree( (*pMyItem) );
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetItemSz                                                   *
//*                                                                         *
//* SYNOPSIS:   Returns a string associated with an item. You pick the      *
//*             string by passing the number of the string.                 *
//*                                                                         *
//* REQUIRES:   pMyItem:        The item                                    *
//*             nItem:          The string to return                        *
//*                                                                         *
//* RETURNS:    LPSTR:          The string                                  *
//*                                                                         *
//***************************************************************************
LPSTR GetItemSz( PMYITEM pMyItem, UINT nItem )
{
    ASSERT( pMyItem != NULL );
    ASSERT( nItem <= 1 );

    return pMyItem->aszCols[nItem];
}


//***************************************************************************
//*                                                                         *
//* NAME:       LastItem                                                    *
//*                                                                         *
//* SYNOPSIS:   Used to end a while loop when we've reached the end of list *
//*                                                                         *
//* REQUIRES:   pMyItem:        the current item                            *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if at end of list, FALSE otherwise     *
//*                                                                         *
//***************************************************************************
BOOL LastItem( PMYITEM pMyItem )
{
    return( pMyItem == NULL );
}

//***************************************************************************
//*                                                                         *
//* NAME:       AddItem                                                     *
//*                                                                         *
//* SYNOPSIS:   Adds an item to the list.                                   *
//*                                                                         *
//* REQUIRES:   szFilename, szPath - strings to add to structure.           *
//*                                                                         *
//* RETURNS:    PMYITEM         This function allocates memory which will   *
//*                             be freed later by FreeItem()                *
//*                                                                         *
//***************************************************************************
PMYITEM AddItem( LPCSTR szFilename, LPCSTR szPath )
{
    PMYITEM pMyItem;
    PMYITEM pTail;

    ASSERT( szFilename != NULL );
    ASSERT( szPath != NULL );

    pMyItem = (PMYITEM) LocalAlloc( GMEM_FIXED, sizeof(MYITEM) );

    if ( ! pMyItem )  {
        return NULL;
    }

    pMyItem->aszCols[0] = (LPSTR) LocalAlloc( LPTR, lstrlen( szFilename ) + 1 );
    pMyItem->aszCols[1] = (LPSTR) LocalAlloc( LPTR, lstrlen( szPath ) + 1 );

    if ( ! pMyItem->aszCols[0] || ! pMyItem->aszCols[1] )  {
        FreeItem( &pMyItem );
        return NULL;
    }

    lstrcpy( pMyItem->aszCols[0], szFilename );
    lstrcpy( pMyItem->aszCols[1], szPath );

    pMyItem->fWroteOut = FALSE;
    pMyItem->Next = NULL;

    if ( g_CDF.pTop == NULL )
    {
        g_CDF.pTop = pMyItem;
    }
    else
    {
        pTail = g_CDF.pTop;
        while ( pTail->Next != NULL )
        {
            pTail = pTail->Next;
        }

        pTail->Next = pMyItem;
    }

    g_CDF.cbFileListNum++;

    return pMyItem;
}


//***************************************************************************
//*                                                                         *
//* NAME:       RemoveItem                                                  *
//*                                                                         *
//* SYNOPSIS:   Removes an item from the list and frees the memory.         *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID RemoveItem( PMYITEM pMyItem )
{
    PMYITEM pCurItem;
    PMYITEM pLastItem;

    ASSERT( pMyItem != NULL );

    pCurItem = GetFirstItem();

    if ( pMyItem == pCurItem )  {
        g_CDF.pTop = pCurItem->Next;
        FreeItem( &pCurItem );
        return;
    }

    pLastItem = pCurItem;
    pCurItem = GetNextItem( pCurItem );

    while ( ! LastItem( pCurItem ) )  {
        if ( pCurItem == pMyItem )  {
            pLastItem->Next = pCurItem->Next;
            FreeItem( &pCurItem );
            return;
        }
        pLastItem = pCurItem;
        pCurItem = GetNextItem( pCurItem );
    }

    // We should never get here.
    ASSERT( TRUE );
}

//***************************************************************************
//*                                                                         *
//*  ParseCmdLine()                                                     *
//*                                                                         *
//*  Purpose:    Parses the command line looking for switches               *
//*                                                                         *
//*  Parameters: LPSTR lpszCmdLineOrg - Original command line               *
//*                                                                         *
//*                                                                         *
//*  Return:     (BOOL) TRUE if successful                                  *
//*                     FALSE if an error occurs                            *
//*                                                                         *
//***************************************************************************

BOOL ParseCmdLine( LPSTR lpszCmdLine )
{
    LPSTR pSubArg, pArg, pTmp;
    CHAR  szTmpBuf[MAX_PATH];

    if( (!lpszCmdLine) || (lpszCmdLine[0] == 0) )
       return TRUE;

    pArg = strtok( lpszCmdLine, " " );

    while ( pArg )
    {

       if ( lstrcmpi( pArg, "/N" ) == 0 )
       {
           g_fBuildNow = TRUE;
       }
       else if( (*pArg != '/' ) )
       {
           lstrcpyn( g_CDF.achFilename, pArg, sizeof(g_CDF.achFilename) );
           GetFullPathName( g_CDF.achFilename, sizeof(g_CDF.achFilename),
                                g_CDF.achFilename, &pTmp );
       }
       else if ( (*pArg == '/') && (toupper(*(pArg+1)) == 'O') && (*(pArg+2) == ':') )
       {
            lstrcpy( szTmpBuf, (pArg+3) );

            if ( pSubArg = strchr( szTmpBuf, ',' ) )
            {
                *pSubArg = '\0';
                lstrcpy( g_szOverideCDF, szTmpBuf );
                GetFullPathName( g_szOverideCDF, sizeof(g_szOverideCDF),
                                g_szOverideCDF, &pTmp );

                if ( *(pSubArg+1) )
                    lstrcpy( g_szOverideSec, (pSubArg+1) );
            }
       }
       else if ( lstrcmpi( pArg, "/Q" ) == 0 )
       {
            g_wQuietMode = 1;
       }
       else if ( lstrcmpi( pArg, "/S" ) == 0 )
       {
            g_wSilentMode = 1;
       }
       else if ( lstrcmpi( pArg, "/M" ) == 0 )
       {
            g_wRunDiamondMinimized = 1;
       }
       else
       {
           return FALSE;
       }
       pArg = strtok( NULL, " " );
    }

    if ( (g_wQuietMode == 1) && (g_fBuildNow == FALSE) ) {
        g_wQuietMode = 0;
    }

    return TRUE;
}



// RO_GetPrivateProfileSection
//   ensure the file attribute is not read-only.
//
LONG RO_GetPrivateProfileSection( LPCSTR lpSec, LPSTR lpBuf, DWORD dwSize, LPCSTR lpFile, BOOL bSingleCol)
{
    LONG lRealSize;
    DWORD dwAttr;
    int   iCDFVer;

    dwAttr = GetFileAttributes( lpFile );
    if ( (dwAttr != -1) && (dwAttr & FILE_ATTRIBUTE_READONLY) )
    {
        if ( !SetFileAttributes( lpFile, FILE_ATTRIBUTE_NORMAL ) )
        {
            ErrorMsg1Param( NULL, IDS_ERR_CANT_SETA_FILE, lpFile );
        }
    }

    if ( ( (iCDFVer = GetPrivateProfileInt( SEC_VERSION, KEY_VERSION, -1, lpFile )) == -1 ) &&
         ( (iCDFVer = GetPrivateProfileInt( SEC_VERSION, KEY_NEWVER, -1, lpFile )) == -1 ) )
    {
        return (iCDFVer);
    }

    if ( !bSingleCol )
    {
        lRealSize = (LONG)GetPrivateProfileSection( lpSec, lpBuf, dwSize, lpFile );
    }
    else
    {
        if ( iCDFVer < 3 )
            lRealSize = (LONG)GetPrivateProfileSection( lpSec, lpBuf, dwSize, lpFile );
        else
            lRealSize = (LONG)GetPrivateProfileString( lpSec, NULL, "", lpBuf, dwSize, lpFile );
    }

    if ( (dwAttr != -1) && (dwAttr & FILE_ATTRIBUTE_READONLY) )
    {
        SetFileAttributes( lpFile, dwAttr );
    }

    return lRealSize;

}

BOOL IsOSNT3X(VOID)
{
    OSVERSIONINFO verinfo;        // Version Check


    // Operating System Version Check: For NT versions below 3.50 set flag to
    // prevent use of common controls (progress bar and AVI) not available.

    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( GetVersionEx( &verinfo ) == FALSE )
    {
        // you definitly not windows 95 or NT 4.0
        return TRUE;
    }

    if ( verinfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
    {
        if ( verinfo.dwMajorVersion <= 3 )
        {
            return TRUE;
        }
    }
    return FALSE; // windows 95 or NT 4.0 above
}

void SetControlFont()
{
   LOGFONT lFont;
   if (GetSystemMetrics(SM_DBCSENABLED) &&
       (GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof (lFont), &lFont) > 0))
   {
       g_hFont = CreateFontIndirect((LPLOGFONT)&lFont);
   }
}

//==================================================================

BOOL GetThisModulePath( LPSTR lpPath, int size )
{
    LPSTR lpTmp;
    int   len;

    ASSERT(lpPath);
    ASSERT(size);

    *lpPath = 0;
    if ( GetModuleFileName( g_hInst, lpPath, size ) )
    {
        // chop filename off
        //
        lpTmp = ANSIStrRChr( lpPath, '\\' );
        if ( lpTmp )
        {
            *(CharNext(lpTmp)) = '\0';
        }
    }

    return (*lpPath != '\0');
}

// BUGBUG:  we don't need size param, since it is internal, we could assume
// MAX_PATH buffer
//
BOOL GetFileFromModulePath( LPCSTR pFile, LPSTR pPathBuf, int iBufSize )
{
    BOOL bRet;

    bRet = GetThisModulePath( pPathBuf, iBufSize );
    AddPath( pPathBuf, pFile );

    if ( bRet && GetFileAttributes( pPathBuf ) == -1 )
    {
        return FALSE;
    }
    return bRet;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MakeDirectory                                               *
//*                                                                         *
//* SYNOPSIS:   Make sure the directories along the given pathname exist.   *
//*                                                                         *
//* REQUIRES:   pszFile:        Name of the file being created.             *
//*                                                                         *
//* RETURNS:    nothing                                                     *
//*                                                                         *
//***************************************************************************

BOOL MakeDirectory( HWND hwnd, LPCSTR pszPath, BOOL bDoUI )
{
    LPTSTR pchChopper;
    int cExempt;
    DWORD  dwAttr;
    BOOL bRet = FALSE;

    if (pszPath[0] != '\0')
    {
        PSTR pszTmp = NULL;
        char ch;
        UINT umsg = 0;
        UINT ubutton = MB_YESNO;


        cExempt = 0;
        pszTmp = ANSIStrRChr( pszPath, '\\' );
        if ( pszTmp )
        {
            ch = *pszTmp;
            *pszTmp = '\0';
        }

        dwAttr = GetFileAttributes( pszPath );
        if ( bDoUI ) 
        {
            if ( dwAttr == 0xffffffff )
            {
                umsg = IDS_CREATEDIR;            
                ubutton = MB_YESNO;
            }
            else if ( !(dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
            {
                umsg = IDS_INVALIDPATH;
                ubutton = MB_OK;
            }
                
            if ( umsg && ( (MsgBox1Param( hwnd, umsg, (LPSTR)pszPath, MB_ICONQUESTION, ubutton ) == IDNO) ||
                 (ubutton == MB_OK) )  )
            {
                if ( pszTmp ) 
                    *pszTmp = ch;
                return bRet;
            }
        }

        if ( pszTmp ) 
            *pszTmp = ch;

        if ((pszPath[1] == ':') && (pszPath[2] == '\\'))
        {
            pchChopper = (LPTSTR) (pszPath + 3);   /* skip past "C:\" */
        }
        else if ((pszPath[0] == '\\') && (pszPath[1] == '\\'))
        {
            pchChopper = (LPTSTR) (pszPath + 2);   /* skip past "\\" */

            cExempt = 2;                /* machine & share names exempt */
        }
        else
        {
            pchChopper = (LPTSTR) (pszPath + 1);   /* skip past potential "\" */
        }

        while (*pchChopper != '\0')
        {
            if ((*pchChopper == '\\') && (*(pchChopper - 1) != ':'))
            {
                if (cExempt != 0)
                {
                    cExempt--;
                }
                else
                {
                    *pchChopper = '\0';

                    CreateDirectory(pszPath,NULL);

                    *pchChopper = '\\';
                }
            }

            pchChopper = CharNext(pchChopper);
        }

        bRet = TRUE;
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\cabpack.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* CABPACK.H - Wizard to build a Win32 Self-Extracting and self-installing *
//*             EXE from a Cabinet (CAB) file.                              *
//*                                                                         *
//***************************************************************************

#ifndef _CABPACK_H_
#define _CABPACK_H_

//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <prsht.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <io.h>
#include "resource.h"
#include "res.h"
#include "cpldebug.h"
#include "updres.h"
#include "pagefcns.h"


//***************************************************************************
//* DEFINES                                                                 *
//***************************************************************************

#define SMALL_BUF_LEN       48          // good size for small text buffers
#define STRING_BUF_LEN      512
#define MAX_STRING          512
#define MAX_INFLINE         MAX_PATH
#define LARGE_POINTSIZE     15
#define SIZE_CHECKSTRING    3

#define ORD_PAGE_WELCOME     0
#define ORD_PAGE_MODIFY      1
#define ORD_PAGE_PURPOSE     2
#define ORD_PAGE_TITLE       3
#define ORD_PAGE_PROMPT      4
#define ORD_PAGE_LICENSETXT  5
#define ORD_PAGE_FILES       6
#define ORD_PAGE_COMMAND     7
#define ORD_PAGE_SHOWWINDOW  8
#define ORD_PAGE_FINISHMSG   9
#define ORD_PAGE_TARGET      10
#define ORD_PAGE_TARGET_CAB  11
#define ORD_PAGE_CABLABEL    12
#define ORD_PAGE_REBOOT     13
#define ORD_PAGE_SAVE       14
#define ORD_PAGE_CREATE     15

#define NUM_WIZARD_PAGES    16  // total number of pages in wizard

//***************************************************************************
//* MACRO DEFINITIONS                                                       *
//***************************************************************************
#define SetPropSheetResult( hwnd, result ) SetWindowLongPtr( hwnd, DWLP_MSGRESULT, result )
#define MsgBox( hWnd, nMsgID, uIcon, uButtons ) \
        MsgBox2Param( hWnd, nMsgID, NULL, NULL, uIcon, uButtons )
#define MsgBox1Param( hWnd, nMsgID, szParam, uIcon, uButtons ) \
        MsgBox2Param( hWnd, nMsgID, szParam, NULL, uIcon, uButtons )
#define ErrorMsg( hWnd, nMsgID ) \
        MsgBox2Param( hWnd, nMsgID, NULL, NULL, MB_ICONERROR, MB_OK )
#define ErrorMsg1Param( hWnd, nMsgID, szParam ) \
        MsgBox2Param( hWnd, nMsgID, szParam, NULL, MB_ICONERROR, MB_OK )
#define ErrorMsg2Param( hWnd, nMsgID, szParam1, szParam2 ) \
        MsgBox2Param( hWnd, nMsgID, szParam1, szParam2, MB_ICONERROR, MB_OK )


//***************************************************************************
//* TYPE DEFINITIONS                                                        *
//***************************************************************************
// Structure to hold information about wizard state:
// keeps a history of which pages were visited, so user can
// back up and we know the last page completed in case of reboot.
typedef struct _WIZARDSTATE  {
    UINT  uCurrentPage;                 // index of current page wizard
    UINT  uPageHistory[NUM_WIZARD_PAGES]; // array of page #'s we visited
    UINT  uPagesCompleted;              // # of pages in uPageHistory
    DWORD dwRunFlags;                   // flags passed to us
} WIZARDSTATE, *PWIZARDSTATE;

// handler proc for OK, cancel, etc button handlers
typedef BOOL (* INITPROC)( HWND, BOOL );
typedef BOOL (* CMDPROC)( HWND, UINT, BOOL *, UINT *, BOOL * );
typedef BOOL (* NOTIFYPROC)( HWND, WPARAM, LPARAM );
typedef BOOL (* OKPROC)( HWND, BOOL, UINT *, BOOL * );
typedef BOOL (* CANCELPROC)( HWND );

// Structure with information for each wizard page:
// handler procedures for each page-- any of these can be
// NULL in which case the default behavior is used
typedef struct _PAGEINFO {
    UINT        uDlgID;                 // dialog ID to use for page
    INITPROC    InitProc;
    CMDPROC     CmdProc;
    NOTIFYPROC  NotifyProc;
    OKPROC      OKProc;
    CANCELPROC  CancelProc;
} PAGEINFO, *PPAGEINFO;

typedef struct _CDFSTRINGINFO {
    LPCSTR lpSec;
    LPCSTR lpKey;
    LPCSTR lpDef;
    LPSTR  lpBuf;
    UINT    uSize;
    LPCSTR lpOverideSec;
    BOOL*   lpFlag;
} CDFSTRINGINFO, *PCDFSTRINGINFO;

typedef struct _CDFOPTINFO {
    LPCSTR lpKey;
    DWORD  dwOpt;
} CDFOPTINFO, *PCDFOPTINFO;

//***************************************************************************
//* GLOBAL CONSTANTS                                                        *
//***************************************************************************

// These two variables are used to check the validity of the CABPack
// Directive File.  The version should be incremented when the format
// of the file changes.  The Check String is just a small character
// string that is used to make sure we're reading a CDF file.

// Since Channel Guy use the CDF as Channel Definition File, we change our
// IExpress batch directive file extension to SED (Self Extracting Directive file)

#define DIAMONDEXE "diamond.exe"

#define DIANTZEXE   "makecab.exe"

#define WEXTRACTEXE "wextract.exe"

//***************************************************************************
//* CDF batch file Key Name defines                                         *
//***************************************************************************

#define IEXPRESS_VER        "3"
#define IEXPRESS_CLASS      "IEXPRESS"

// pre-defined section name
#define SEC_OPTIONS     "Options"
#define SEC_STRINGS     "Strings"

#define SEC_COMMANDS    "AppCommands"

// pre-define key name for version section
#define KEY_CLASS           "Class"
#define KEY_VERSION         "CDFVersion"
#define KEY_NEWVER          "SEDVersion"

// pre-defined Key name for options section
#define KEY_SHOWWIN         "ShowInstallProgramWindow"
#define KEY_NOEXTRACTUI     "HideExtractAnimation"
#define KEY_EXTRACTONLY     "ExtractOnly"
#define KEY_REBOOTMODE      "RebootMode"
#define KEY_LOCALE          "Locale"
#define KEY_USELFN          "UseLongFileName"
#define KEY_QUANTUM         "Quantum"
#define KEY_PLATFORM_DIR    "PlatformDir"

#define KEY_FILELIST        "SourceFiles"
#define KEY_STRINGS         "Strings"
#define KEY_FILEBASE        "FILE%d"
#define KEY_VERSIONINFO     "VersionInfo"

#define KEY_INSTPROMPT      "InstallPrompt"
#define KEY_DSPLICENSE      "DisplayLicense"
#define KEY_APPLAUNCH       "AppLaunched"
#define KEY_POSTAPPLAUNCH   "PostInstallCmd"
#define KEY_ENDMSG          "FinishMessage"
#define KEY_PACKNAME        "TargetName"
#define KEY_FRIENDLYNAME    "FriendlyName"
#define KEY_PACKINSTSPACE   "PackageInstallSpace(KB)"
#define KEY_PACKPURPOSE     "PackagePurpose"
#define KEY_CABFIXEDSIZE    "CAB_FixedSize"
#define KEY_CABRESVCODESIGN "CAB_ResvCodeSigning"
#define KEY_LAYOUTINF       "IEXP_LayoutINF"
#define KEY_CABLABEL        "SourceMediaLabel"
#define KEY_NESTCOMPRESSED  "InsideCompressed"
#define KEY_KEEPCABINET     "KeepCabinet"
#define KEY_UPDHELPDLLS     "UpdateAdvDlls"
#define KEY_INSTANCECHK     "MultiInstanceCheck"
#define KEY_ADMQCMD         "AdminQuietInstCmd"
#define KEY_USERQCMD        "UserQuietInstCmd"
#define KEY_CHKADMRIGHT     "CheckAdminRights"
#define KEY_NTVERCHECK      "TargetNTVersion"
#define KEY_WIN9XVERCHECK   "TargetWin9xVersion"
#define KEY_SYSFILE         "TargetFileVersion"
#define KEY_PASSRETURN      "PropogateCmdExitCode"
#define KEY_PASSRETALWAYS   "AlwaysPropogateCmdExitCode"
#define KEY_STUBEXE         "ExtractorStub"
#define KEY_CROSSPROCESSOR  "PackageForX86"
#define KEY_COMPRESSTYPE    "CompressionType"
#define KEY_CMDSDEPENDED    "AppErrorCheck"
#define KEY_COMPRESS        "Compress"	 	
#define KEY_COMPRESSMEMORY  "CompressionMemory"

// ADVANCED DLL names
#define ADVANCEDLL          "ADVPACK.DLL"
#define ADVANCEDLL32        "W95INF32.DLL"
#define ADVANCEDLL16        "W95INF16.DLL"

//static CHAR achMSZIP[] = "MSZIP";
//static CHAR achQUANTUM[] = "QUANTUM";

// package purpose key string value
#define STR_INSTALLAPP      "InstallApp"
#define STR_EXTRACTONLY     "ExtractOnly"
#define STR_CREATECAB       "CreateCAB"

// code sign resv space
#define CAB_0K      "0"
#define CAB_2K      "2048"
#define CAB_4K      "4096"
#define CAB_6K      "6144"

// define temp filename for diamond to use
#define CABPACK_INFFILE     "~%s_LAYOUT.INF"
#define CABPACK_TMPFILE     "~%s%s"

// file extentions with dot 
#define EXT_RPT      ".RPT"
#define EXT_DDF      ".DDF"
#define EXT_CAB      ".CAB"
#define EXT_CDF      ".CDF"
#define EXT_SED      ".SED"

// file extentions without dot '.' used as default file extention
#define EXT_SED_NODOT    "SED"
#define EXT_CAB_NODOT    "CAB"
#define EXT_TXT_NODOT    "TXT"
#define EXT_EXE_NODOT    "EXE"
#define EXT_INF_NODOT    "INF"

#define CAB_DEFSETUPMEDIA   "Application Source Media"

#define CH_STRINGKEY        '%'
#define SYS_DEFAULT         "ZZZZZZ"
#define KBYTES              1000

//***************************************************************************
//* FUNCTION PROTOTYPES                                                     *
//***************************************************************************
BOOL             RunCABPackWizard( VOID );
INT_PTR CALLBACK GenDlgProc( HWND, UINT, WPARAM, LPARAM );
VOID             InitWizardState( PWIZARDSTATE );
VOID NEAR PASCAL MEditSubClassWnd( HWND, FARPROC );
LRESULT CALLBACK MEditSubProc( HWND, UINT, WPARAM, LPARAM );
UINT             GetDlgIDFromIndex( UINT );
VOID             EnableWizard( HWND, BOOL );
DWORD            MsgWaitForMultipleObjectsLoop( HANDLE );
INT              MsgBox2Param( HWND, UINT, LPCSTR, LPCSTR, UINT, UINT );
VOID             DisplayFieldErrorMsg( HWND, UINT, UINT );

VOID             InitBigFont( HWND, UINT );
VOID             DestroyBigFont( VOID );
BOOL             EnableDlgItem( HWND, UINT, BOOL );
LPSTR            LoadSz( UINT, LPSTR, UINT );
BOOL WINAPI      IsDuplicate( HWND, INT, LPSTR, BOOL );
BOOL             WriteCDF( HWND );
BOOL             ReadCDF( HWND );
BOOL             WriteDDF( HWND );
BOOL             MyOpen( HWND, UINT, LPSTR, DWORD, DWORD, INT *, INT *, PSTR );
BOOL             MySave( HWND, UINT, LPSTR, DWORD, DWORD, INT *, INT *, PSTR );
BOOL             MakePackage( HWND );
BOOL             MakeCAB( HWND );
BOOL             MakeEXE( HWND );
VOID             Status( HWND, UINT, LPSTR );
//int CALLBACK     CompareFunc( LPARAM, LPARAM, LPARAM );
VOID             InitItemList( VOID );
VOID             DeleteAllItems( VOID );
PMYITEM          GetFirstItem( VOID );
PMYITEM          GetNextItem( PMYITEM );
VOID             FreeItem( PMYITEM * );
LPSTR            GetItemSz( PMYITEM, UINT );
FILETIME         GetItemTime( PMYITEM );
VOID             SetItemTime( PMYITEM, FILETIME );
BOOL             LastItem( PMYITEM );
PMYITEM          AddItem( LPCSTR, LPCSTR );
VOID             RemoveItem( PMYITEM );
BOOL             ParseCmdLine( LPSTR lpszCmdLineOrg );
BOOL             DoVersionInfo(HWND hDlg, LPSTR szFile,HANDLE hUpdate);
LONG             RO_GetPrivateProfileSection( LPCSTR, LPSTR, DWORD, LPCSTR , BOOL );

BOOL            GetFileFromModulePath( LPCSTR pFile, LPSTR pPathBuf, int iBufSize );
BOOL            GetThisModulePath( LPSTR lpPath, int size );
BOOL            GetVersionInfoFromFile();
void            CleanFileListWriteFlag();
BOOL            MakeCabName( HWND hwnd, PSTR pszTarget, PSTR pszCab );
BOOL            MakeDirectory( HWND hwnd,LPCSTR pszPath, BOOL bDoUI );

#endif // _CABPACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\pch.h ===
#include <windows.h>
#include <commctrl.h>
#if WINNT  /* for odds-n-ends not automatically included in \\trango env */
#include <commdlg.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\common\cpldebug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME ""
#endif	// SZ_COMPNAME



static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
        if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
            break;
    }
    wsprintf(ach, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
	_AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  

    wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
	OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
	_DebugMsg(pszMsg);
	_asm {int 3};
}

#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP	_DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\pch.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\resource.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* IDS.H -                                                                 *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* STRING RESOURCE IDS                                                     *
//***************************************************************************
#define IDS_APPNAME                 1000
#define IDS_MSSERIF                 1001
#define IDS_QUERYCANCEL             1002

#define IDS_LOSE_CHANGES            1050
#define IDS_DDF_HEADER              1052
#define IDS_STATUS_MAKE_CAB         1053
#define IDS_STATUS_MAKE_EXE         1054
#define IDS_STATUS_ERROR_CAB        1055
#define IDS_STATUS_ERROR_EXE        1056
#define IDS_STATUS_ERROR_CDF        1057
#define IDS_STATUS_DONE             1058
#define IDS_FILTER_CDF              1059
#define IDS_FILTER_TXT              1060
#define IDS_FILTER_ALL              1061
#define IDS_FILTER_EXE              1062
#define IDS_HEADER_FILENAME         1070
#define IDS_HEADER_PATH             1071
#define IDS_CMD_RUNCMD              1074
#define IDS_CMD_EXTRACT             1075
#define IDS_CMD_CREATECAB           1076
#define IDS_FILTER_CAB              1077
#define IDS_FILTER_INF              1078

#define IDS_ERR_NO_MEMORY           1100
#define IDS_ERR_CDF_DOESNT_EXIST    1101
#define IDS_ERR_NO_TITLE            1102
#define IDS_ERR_NO_PROMPT           1103
#define IDS_ERR_NO_LICENSE          1104
#define IDS_ERR_LICENSE_NOT_FOUND   1105
#define IDS_ERR_DUPE_FILE           1106
#define IDS_ERR_NO_FILES            1107
#define IDS_ERR_NO_SELECT           1108
#define IDS_ERR_NO_CUSTOM           1109
#define IDS_ERR_NO_FINISHMSG        1110
#define IDS_ERR_NO_TARGET           1111
#define IDS_ERR_NO_SAVE_FILENAME    1114
#define IDS_ERR_CREATE_TARGET       1115
#define IDS_ERR_INIT_RESOURCE       1116
#define IDS_ERR_UPDATE_RESOURCE     1117
#define IDS_ERR_CLOSE_RESOURCE      1118
#define IDS_ERR_OPEN_CDF            1119
#define IDS_ERR_READ_CDF            1121
#define IDS_ERR_OPEN_DDF            1122
#define IDS_ERR_WRITE_DDF           1123
#define IDS_ERR_OPEN_RPT            1126
#define IDS_ERR_READ_RPT            1127
#define IDS_ERR_OPEN_LICENSE        1128
#define IDS_ERR_READ_LICENSE        1129
#define IDS_ERR_OPEN_CAB            1130
#define IDS_ERR_READ_CAB            1131
#define IDS_ERR_START_DIAMOND       1132
#define IDS_ERR_FILE_NOT_FOUND      1133
#define IDS_ERR_FILE_NOT_FOUND2     1134
#define IDS_ERR_SHORT_PATH          1135
#define IDS_ERR_VERSION_INFO        1137
#define IDS_ERR_BADCMDLINE          1138
#define IDS_WARN_OVERIDECDF         1139
#define IDS_WARN_MISSSTRING         1140
#define IDS_ERR_CLASSNAME           1141
#define IDS_ERR_NOSOURCEFILE        1142
#define IDS_WARN_USELFN             1143
#define IDS_ERR_WRITEFILE           1144
#define IDS_ERR_SYSERROR            1145
#define IDS_ERR_CABNAME             1146
#define IDS_ERR_CANT_SETA_FILE      1147
#define IDS_ERR_INVALID_CDF         1148
#define IDS_ERR_CDFFORMAT           1149
#define IDS_ERR_COOKIE              1151
#define IDS_ERR_VCHKFLAG            1152
#define IDS_ERR_VCHKFILE            1153
#define IDS_ERR_BADSTRING           1154
#define IDS_CREATEDIR               1155
#define IDS_INVALIDPATH             1156

//***************************************************************************
//* DIALOG PAGE IDS                                                         *
//***************************************************************************
#define IDD_WELCOME                 2000
#define IDD_MODIFY                  2001
#define IDD_TITLE                   2002
#define IDD_PROMPT                  2003
#define IDD_LICENSETXT              2004
#define IDD_FILES                   2005
#define IDD_COMMAND                 2006
#define IDD_SHOWWINDOW              2007
#define IDD_FINISHMSG               2008
#define IDD_TARGET                  2009
#define IDD_SAVE                    2010
#define IDD_CREATE                  2011
#define IDD_PACKPURPOSE             2012
#define IDD_REBOOT                  2013
#define IDD_TARGET_CAB              2014
#define IDD_CABLABEL                2015

//***************************************************************************
//* DIALOG CONTROL IDS                                                      *
//***************************************************************************
#define IDC_UNUSED                  -1
#define IDC_BMPFRAME                2100
#define IDC_BIGTEXT                 2101
#define IDC_BUT_BROWSE              2102
#define IDC_RAD_CREATE_NEW          2103
#define IDC_RAD_OPEN_EXISTING       2104
#define IDC_EDIT_OPEN_CDF           2105
#define IDC_EDIT_TITLE              2106
#define IDC_RAD_NO_PROMPT           2107
#define IDC_RAD_YES_PROMPT          2108
#define IDC_EDIT_PROMPT             2109
#define IDC_RAD_NO_LICENSE          2110
#define IDC_RAD_YES_LICENSE         2111
#define IDC_EDIT_LICENSE            2112
#define IDC_LV_CAB_FILES            2113
#define IDC_BUT_ADD                 2114
#define IDC_BUT_REMOVE              2115

#define IDC_RAD_DEFAULT             2120
#define IDC_RAD_HIDDEN              2121
#define IDC_RAD_MINIMIZED           2122
#define IDC_RAD_MAXIMIZED           2123
#define IDC_RAD_NO_FINISHMSG        2124
#define IDC_RAD_YES_FINISHMSG       2125
#define IDC_EDIT_FINISHMSG          2126
#define IDC_EDIT_TARGET             2127
#define IDC_RAD_YES_SAVE            2128
#define IDC_RAD_NO_SAVE             2129
#define IDC_EDIT_SAVE_CDF           2130
#define IDC_TEXT_CREATE1            2131
#define IDC_TEXT_CREATE2            2132
#define IDC_TEXT_STATUS             2133
#define IDC_MEDIT_STATUS            2134
#define IDC_RAD_MODIFY              2135
#define IDC_RAD_CREATE              2136

#define IDC_REBOOT_NO               2139
#define IDC_REBOOT_ALWAYS           2140
#define IDC_REBOOT_IFNEED           2141
#define IDC_REBOOT_SILENT           2142
#define IDC_CMD_NOTES               2143
#define IDC_HIDEEXTRACTUI           2144
#define IDC_CB_INSTALLCMD           2145
#define IDC_CB_POSTCMD              2146
#define IDC_USE_LFN                 2147

#define IDC_CMD_RUNCMD              2148
#define IDC_CMD_EXTRACT             2149
#define IDC_CMD_CREATECAB           2150

#define IDC_CB_RESVCABSP            2151
#define IDC_MULTIPLE_CAB            2152

#define IDC_EDIT_LAYOUTINF          2153
#define IDC_EDIT_CABLABEL           2154

//***************************************************************************
//* BITMAP AND ICON IDS                                                     *
//***************************************************************************
#define IDB_BMP                     2200
#define IDI_ICON                    2201



// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        1157
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         2155
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\updres.c ===
/*
 *
 * Resource Updating Functions
 */

#if WINNT  /* for UNICODE_STRING */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <malloc.h>
#include <stdlib.h>
#endif

#include <windows.h>
#include <imagehlp.h>
#pragma hdrstop
#include "cabpack.h"
#include "sdsutils.h"
#define DPrintf( a )
#define DPrintfn( a )
#define DPrintfu( a )

#define RtlAllocateHeap(a,b,c)    malloc( c )
#define RtlFreeHeap(a,b,c)        free( c )


/*
 * BUGBUG - OPTIMIZATION PROBLEM?
 * BUGBUG - The program mysteriously does not work correctly unless
 * BUGBUG   optimization is turned off in the early section of this file.
 * BUGBUG   I don't have time to debug this, if you do please tell me what
 * BUGBUG   is wrong
 */


#pragma optimize( "", off )



#define cbPadMax    16L
 char     *pchPad = "PADDINGXXPADDING";
 char     *pchZero = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";


extern CDF  g_CDF;  //global struct
extern HINSTANCE    g_hInst; // Pointer to Instance

WCHAR *
MakeUnicodeCopy( LPCSTR psz )
{
    LPWSTR result;

    if (((ULONG_PTR) psz) & (ULONG_PTR)0xFFFF0000)  {
        result = (LPWSTR) malloc( (lstrlen(psz) + 1) * sizeof(WCHAR) );
            // BUGBUG ERROR CHECKING!!! Internal tool only
        mbstowcs( result, psz, lstrlen(psz) + 1);
        return( result );
    } else {
        return( (WCHAR *) psz );
    }
}




/****************************************************************************
**
** API entry points
**
****************************************************************************/


/*++
    Routine Description
        Begins an update of resources.  Save away the name
        and current resources in a list, using EnumResourceXxx
        api set.

        Parameters:

            lpFileName - Supplies the name of the executable file that the
                resource specified by lpType/lpName/language will be updated
                in.  This file must be able to be opened for writing (ie, not
                currently executing, etc.)  The file may be fully qualified,
                or if not, the current directory is assumed.  It must be a
                valid Windows executable file.

            bDeleteExistingResources - if TRUE, existing resources are
                deleted, and only new resources will appear in the result.
                Otherwise, all resources in the input file will be in the
                output file unless specifically deleted or replaced.

        Return Value:

        NULL - The file specified was not able to be opened for writing.
        Either it was not an executable image, the executable image is
        already loaded, or the filename did not exist.  More information may
        be available via GetLastError api.

        HANDLE - A handle to be passed to the UpdateResource and
        EndUpdateResources function.
--*/


HANDLE
LocalBeginUpdateResource( LPCSTR pwch, BOOL bDeleteExistingResources )
{
    HMODULE     hModule;
    PUPDATEDATA pUpdate;
    HANDLE      hUpdate;
    LPSTR       pFileName;
    DWORD       attr;

    SetLastError(NO_ERROR);


    DEBUGMSG("LocalBeginUpdateResource() - Start");

        // Pointer Sanity check
    if (pwch == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

        // Allocate Resource Editing State (contains lists of resources)
    hUpdate = GlobalAlloc(GHND, sizeof(UPDATEDATA));
    if (hUpdate == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (pUpdate == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

        // Set reasonable start condition
    pUpdate->Status = NO_ERROR;

        // Copy Filename into state table
    pUpdate->hFileName = GlobalAlloc(GHND, (lstrlen(pwch)+1) * sizeof(TCHAR) );
    if (pUpdate->hFileName == NULL) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    pFileName = (LPSTR)GlobalLock(pUpdate->hFileName);
    if (pFileName == NULL) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    lstrcpy(pFileName, pwch);
    GlobalUnlock(pUpdate->hFileName);


        // Make sure file is writable, not a directory, etc.
    attr = GetFileAttributes(pFileName);
    if (attr == 0xffffffff) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        return NULL;
    } else if (attr & (FILE_ATTRIBUTE_READONLY |
                 FILE_ATTRIBUTE_SYSTEM |
                 FILE_ATTRIBUTE_HIDDEN |
                 FILE_ATTRIBUTE_DIRECTORY)) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_WRITE_PROTECT);
        return NULL;
    }


            // If not deleting all resources, load them all in
            // by enumerating all the resources
    if (! bDeleteExistingResources)  {
        hModule = LoadLibraryEx(pwch, NULL,LOAD_LIBRARY_AS_DATAFILE| DONT_RESOLVE_DLL_REFERENCES);
        if (hModule == NULL) {
            GlobalUnlock(hUpdate);
            GlobalFree(hUpdate);
            if (GetLastError() == NO_ERROR)
                SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        } else {
                EnumResourceTypes(hModule, EnumTypesFunc, (LONG_PTR) pUpdate);
        }
        FreeLibrary(hModule);
   }

    if (pUpdate->Status != NO_ERROR) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        return NULL;
    }

    GlobalUnlock(hUpdate);

    DEBUGMSG("LocalBeginUpdateResource() - Finish");
    return hUpdate;
}











/*++
    Routine Description
        This routine adds, deletes or modifies the input resource
        in the list initialized by BeginUpdateResource.  The modify
        case is simple, the add is easy, the delete is hard.
        The ASCII entry point converts inputs to UNICODE.

        Parameters:

            hUpdateFile - The handle returned by the BeginUpdateResources
                function.

            lpType - Points to a null-terminated character string that
                represents the type name of the resource to be updated or
                added.  May be an integer value passed to MAKEINTRESOURCE
                macro.  For predefined resource types, the lpType parameter
                should be one of the following values:

                  RT_ACCELERATOR - Accelerator table
                  RT_BITMAP - Bitmap resource
                  RT_DIALOG - Dialog box
                  RT_FONT - Font resource
                  RT_FONTDIR - Font directory resource
                  RT_MENU - Menu resource
                  RT_RCDATA - User-defined resource (raw data)
                  RT_VERSION - Version resource
                  RT_ICON - Icon resource
                  RT_CURSOR - Cursor resource



            lpName - Points to a null-terminated character string that
                represents the name of the resource to be updated or added.
                May be an integer value passed to MAKEINTRESOURCE macro.

            language - Is the word value that specifies the language of the
                resource to be updated.  A complete list of values is
                available in winnls.h.

            lpData - A pointer to the raw data to be inserted into the
                executable image's resource table and data.  If the data is
                one of the predefined types, it must be valid and properly
                aligned.  If lpData is NULL, the specified resource is to be
                deleted from the executable image.

            cb - count of bytes in the data.

        Return Value:

        TRUE - The resource specified was successfully replaced in, or added
        to, the specified executable image.

        FALSE/NULL - The resource specified was not successfully added to or
        updated in the executable image.  More information may be available
        via GetLastError api.
--*/


BOOL
LocalUpdateResource(
    HANDLE      hUpdate,
    LPCTSTR     lpType,
    LPCTSTR     lpName,
    WORD        language,
    LPVOID      lpData,
    ULONG       cb
    )
{
    PUPDATEDATA pUpdate;
    PSDATA      Type;
    PSDATA      Name;
    PVOID       lpCopy;
    LONG        fRet;

    LPWSTR      lpwType;
    LPWSTR      lpwName;


    DEBUGMSG("LocalUpdateResource() Start");

            // Reset Error
    SetLastError(0);

            // Get pointer to Resource Update Session
    pUpdate = (PUPDATEDATA) GlobalLock(hUpdate);


    lpwType = MakeUnicodeCopy( lpType );
    lpwName = MakeUnicodeCopy( lpName );
    if (lpwName == NULL || lpwType == NULL) {
        if (lpwType  && lpwType != (LPWSTR) lpType)
            free( lpwType );
        if (lpwName  && lpwName != (LPWSTR) lpName)
            free( lpwName );
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    Name = AddStringOrID(lpwName, pUpdate);
    if (Name == NULL) {
        if (lpwType != (LPWSTR) lpType)
            free( lpwType );
        if (lpwName != (LPWSTR) lpName)
            free( lpwName );
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    Type = AddStringOrID(lpwType, pUpdate);
    if (Type == NULL) {
        if (lpwType != (LPWSTR) lpType)
            free( lpwType );
        if (lpwName != (LPWSTR) lpName)
            free( lpwName );
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (lpwType != (LPWSTR) lpType)
        free( lpwType );
    if (lpwName != (LPWSTR) lpName)
        free( lpwName );

    if (cb == 0) {
        lpCopy = NULL;
    } else {
        // RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cb);
        lpCopy = malloc( cb );
        if (lpCopy == NULL) {
            pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
            GlobalUnlock(hUpdate);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        memcpy( lpCopy, lpData, cb);
    }

    fRet = AddResource(Type, Name, language, pUpdate, lpCopy, cb);
    GlobalUnlock(hUpdate);
    DEBUGMSG("LocalUpdateResource(): End");
    if (fRet == NO_ERROR)  {
        return TRUE;
    } else {
        SetLastError(fRet);
        if (lpData != NULL)
            free( lpData );
        return FALSE;
    }
}




/*++
    Routine Description
        Finishes the UpdateResource action.  Copies the
        input file to a temporary, adds the resources left
        in the list (hUpdate) to the exe.

        Parameters:

            hUpdateFile - The handle returned by the BeginUpdateResources
                function.

            fDiscard - If TRUE, discards all the updates, frees all memory.

        Return Value:

        FALSE - The file specified was not able to be written.  More
        information may be available via GetLastError api.

        TRUE -  The accumulated resources specified by UpdateResource calls
        were written to the executable file specified by the hUpdateFile
        handle.
--*/




BOOL
LocalEndUpdateResource(
                    HANDLE  hUpdate,
                    BOOL    fDiscard
                 )
{
    LPTSTR      pFileName;
    PUPDATEDATA pUpdate;
    TCHAR       pTempFileName[MAX_PATH];
    INT         cch;
    LPTSTR      p;
    LONG        rc;

    SetLastError(0);

    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);

    DEBUGMSG("LocalEndUpdateResource()");

    if (fDiscard) {
        rc = NO_ERROR;
    } else {
        pFileName = (LPTSTR)GlobalLock(pUpdate->hFileName);
        strcpy(pTempFileName, pFileName);
        cch = lstrlen(pTempFileName);
        p = pTempFileName + cch;
        while (*p != '\\' && p >= pTempFileName)
            p--;
        *(p+1) = 0;
        rc = GetTempFileName(pTempFileName, "RCX", 0, pTempFileName);
        if (rc == 0) {
            rc = GetTempPath(MAX_PATH, pTempFileName);
            if (rc == 0) {
                pTempFileName[0] = '.';
                pTempFileName[1] = '\\';
                pTempFileName[2] = 0;
            }
            rc = GetTempFileName(pTempFileName, "RCX", 0, pTempFileName);
            if (rc == 0) {
                rc = GetLastError();
            } else {
                rc =  WriteResFile(hUpdate, pTempFileName);
                if (rc == NO_ERROR) {
                    DeleteFile(pFileName);
                    MoveFile(pTempFileName, pFileName);
                } else {
                    SetLastError(rc);
                    DeleteFile(pTempFileName);
                }
            }
        } else {
            rc = WriteResFile(hUpdate, pTempFileName);
            if (rc == NO_ERROR) {
                DeleteFile(pFileName);
                MoveFile(pTempFileName, pFileName);
            } else {
                SetLastError(rc);
                DeleteFile(pTempFileName);
            }
        }
        GlobalUnlock(pUpdate->hFileName);
        GlobalFree(pUpdate->hFileName);
    }

    FreeData(pUpdate);
    GlobalUnlock(hUpdate);
    GlobalFree(hUpdate);
    DEBUGMSG("LocalEndUpdateResource(): End");
    return rc?FALSE:TRUE;
}



/**********************************************************************
**
**  End of API entry points.
**
**  Beginning of private entry points for worker routines to do the
**  real work.
**
***********************************************************************/


BOOL _stdcall
EnumTypesFunc(
    HANDLE hModule,
    LPCSTR lpType,
    LONG_PTR lParam
    )
{

    EnumResourceNames(hModule, lpType, EnumNamesFunc, lParam);

    return TRUE;
}



BOOL _stdcall
EnumNamesFunc(
    HANDLE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    LONG_PTR lParam
    )
{

    EnumResourceLanguages(hModule, lpType, lpName, EnumLangsFunc, lParam);
    return TRUE;
}



BOOL _stdcall
EnumLangsFunc(
    HANDLE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD language,
    LONG_PTR lParam
    )
{
    HANDLE  hResInfo;
    LONG    fError;
    PSDATA  Type;
    PSDATA  Name;
    ULONG   cb;
    PVOID   lpData;
    HANDLE  hResource;
    PVOID   lpResource;

    LPWSTR  lpwType;
    LPWSTR  lpwName;


    hResInfo = FindResourceEx(hModule, lpType, lpName, language);
    if (hResInfo == NULL) {
        return FALSE;
    }

    lpwType = MakeUnicodeCopy( lpType );
    lpwName = MakeUnicodeCopy( lpName );
    if (lpwType == NULL || lpwName == NULL) {
        ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    Type = AddStringOrID(lpwType, (PUPDATEDATA)lParam);
    if (lpType != (LPSTR) lpwType)
        free( lpwType );
    if (Type == NULL) {
        ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }
    Name = AddStringOrID(lpwName, (PUPDATEDATA)lParam);
    if (lpName != (LPSTR) lpwName)
        free( lpwName );
    if (Name == NULL) {
        ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    cb = SizeofResource(hModule, hResInfo);
    if (cb == 0) {
        return FALSE;
    }
    lpData = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cb);
    if (lpData == NULL) {
        return FALSE;
    }
    RtlZeroMemory(lpData, cb);

    hResource = LoadResource(hModule, hResInfo);
    if (hResource == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, lpData);
        return FALSE;
    }

    lpResource = (PVOID)LockResource(hResource);
    if (lpResource == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, lpData);
        return FALSE;
    }

    RtlCopyMemory(lpData, lpResource, cb);

    (VOID)UnlockResource(hResource);

    (VOID)FreeResource(hResource);

    fError = AddResource(Type, Name, language, (PUPDATEDATA)lParam, lpData, cb);
    if (fError != NO_ERROR) {
        ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    return TRUE;
}





/*
 * BUGBUG  END OF OPTIMIZATION PROBLEM
 */

#pragma optimize( "", on )







VOID
FreeOne(
    PRESNAME pRes
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes->OffsetToDataEntry);
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes);
}


VOID
FreeData(
    PUPDATEDATA pUpd
    )
{
    PRESTYPE    pType;
    PRESNAME    pRes;
    PSDATA      pstring, pStringTmp;

    for (pType=pUpd->ResTypeHeadID ; pUpd->ResTypeHeadID ; pType=pUpd->ResTypeHeadID) {
        pUpd->ResTypeHeadID = pUpd->ResTypeHeadID->pnext;

        for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) {
            pType->NameHeadID = pType->NameHeadID->pnext;
            FreeOne(pRes);
        }

        for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) {
            pType->NameHeadName = pType->NameHeadName->pnext;
            FreeOne(pRes);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pType);
    }

    for (pType=pUpd->ResTypeHeadName ; pUpd->ResTypeHeadName ; pType=pUpd->ResTypeHeadName) {
        pUpd->ResTypeHeadName = pUpd->ResTypeHeadName->pnext;

        for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) {
            pType->NameHeadID = pType->NameHeadID->pnext;
            FreeOne(pRes);
        }

        for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) {
            pType->NameHeadName = pType->NameHeadName->pnext;
            FreeOne(pRes);
        }

    }

    pstring = pUpd->StringHead;
    while (pstring != NULL) {
        pStringTmp = pstring->uu.ss.pnext;
    if (pstring->discriminant == IS_STRING)
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring->szStr);
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring);
        pstring = pStringTmp;
    }

    return;
}


/*+++

    Routines to register strings

---*/

//
//  Resources are DWORD aligned and may be in any order.
//

#define TABLE_ALIGN  4
#define DATA_ALIGN  4L



PSDATA
AddStringOrID(
    LPCWSTR     lp,
    PUPDATEDATA pupd
    )
{
    USHORT cb;
    PSDATA pstring;
    PPSDATA ppstring;

    if (((ULONG_PTR)lp & (ULONG_PTR)0xFFFF0000) == 0) {
        //
        // an ID
        //
        pstring = (PSDATA)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(SDATA));
    if (pstring == NULL)
        return NULL;
    RtlZeroMemory((PVOID)pstring, sizeof(SDATA));
    pstring->discriminant = IS_ID;

        pstring->uu.Ordinal = (WORD)((ULONG_PTR)lp & (ULONG_PTR)0x0000ffff);
    }
    else {
        //
        // a string
        //
        cb = wcslen(lp) + 1;
        ppstring = &pupd->StringHead;

        while ((pstring = *ppstring) != NULL) {
            if (!wcsncmp(pstring->szStr, lp, cb))
        break;
            ppstring = &(pstring->uu.ss.pnext);
        }

        if (!pstring) {

            //
            // allocate a new one
            //

            pstring = (PSDATA)RtlAllocateHeap(RtlProcessHeap(),
                                              MAKE_TAG( RES_TAG ) | HEAP_ZERO_MEMORY,
                                              sizeof(SDATA)
                                             );
        if (pstring == NULL)
            return NULL;
        RtlZeroMemory((PVOID)pstring, sizeof(SDATA));

            pstring->szStr = (WCHAR*)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ),
                            cb*sizeof(WCHAR));
            if (pstring->szStr == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring);
                return NULL;
        }
        pstring->discriminant = IS_STRING;
            pstring->OffsetToString = pupd->cbStringTable;

            pstring->cbData = sizeof(pstring->cbsz) + cb * sizeof(WCHAR);
            pstring->cbsz = cb - 1; /* don't include zero terminator */
            RtlCopyMemory(pstring->szStr, lp, cb*sizeof(WCHAR));

            pupd->cbStringTable += pstring->cbData;

            pstring->uu.ss.pnext=NULL;
            *ppstring=pstring;
        }
    }

    return(pstring);
}
//
// add a resource into the resource directory hiearchy
//


LONG
AddResource(
    IN PSDATA Type,
    IN PSDATA Name,
    IN WORD Language,
    IN PUPDATEDATA pupd,
    IN PVOID lpData,
    IN ULONG cb
    )
{
    PRESTYPE  pType;
    PPRESTYPE ppType;
    PRESNAME  pName;
    PRESNAME  pNameM;
    PPRESNAME ppName = NULL;
    BOOL fTypeID=(Type->discriminant == IS_ID);
    BOOL fNameID=(Name->discriminant == IS_ID);
    BOOL fSame=FALSE;

    //
    // figure out which list to store it in
    //

    ppType = fTypeID ? &pupd->ResTypeHeadID : &pupd->ResTypeHeadName;

    //
    // Try to find the Type in the list
    //

    while ((pType=*ppType) != NULL) {
        if (pType->Type->uu.Ordinal == Type->uu.Ordinal) {
            ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
            break;
        }
        if (fTypeID) {
            if (Type->uu.Ordinal < pType->Type->uu.Ordinal)
        break;
        }
    else {
            if (wcsncmp(Type->szStr, pType->Type->szStr, Type->cbsz) < 0)
        break;
        }
        ppType = &(pType->pnext);
    }

    //
    // Create a new type if needed
    //

    if (ppName == NULL) {
        pType = (PRESTYPE)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESTYPE));
    if (pType == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    RtlZeroMemory((PVOID)pType, sizeof(RESTYPE));
        pType->pnext = *ppType;
        *ppType = pType;
        pType->Type = Type;
        ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
    }

    //
    // Find proper place for name
    //

    while ( (pName = *ppName) != NULL) {
        if (fNameID) {
        if (Name->uu.Ordinal == pName->Name->uu.Ordinal) {
        fSame = TRUE;
        break;
        }
            if (Name->uu.Ordinal < pName->Name->uu.Ordinal)
        break;
        }
    else {
            if (wcsncmp(Name->szStr, pName->Name->szStr, Name->cbsz) == 0) {
        fSame = TRUE;
        break;
        }
            if (wcsncmp(Name->szStr, pName->Name->szStr, Name->cbsz) < 0)
        break;
        }
        ppName = &(pName->pnext);
    }

    //
    // check for delete/modify
    //

    if (fSame) {                /* same name, new language */
        if (pName->NumberOfLanguages == 1) {    /* one language currently ? */
            if (Language == pName->LanguageId) {    /* REPLACE || DELETE */
                pName->DataSize = cb;
                if (lpData == NULL) {           /* DELETE */
                    return DeleteResourceFromList(pupd, pType, pName, Language, fTypeID, fNameID);
                }
        RtlFreeHeap(RtlProcessHeap(),0,(PVOID)pName->OffsetToDataEntry);
                (PVOID)pName->OffsetToDataEntry = lpData;
                return NO_ERROR;
            }
        else {
                if (lpData == NULL) {           /* no data but new? */
                return ERROR_INVALID_PARAMETER; /* badness */
        }
        return InsertResourceIntoLangList(pupd, Type, Name, pType, pName, Language, fNameID, cb, lpData);
        }
        }
        else {                  /* many languages currently */
        pNameM = pName;         /* save head of lang list */
        while ( (pName = *ppName) != NULL) {/* find insertion point */
            if (pName->Name != pNameM->Name ||
            Language <= pName->LanguageId)  /* here? */
                break;              /* yes */
            ppName = &(pName->pnext);   /* traverse language list */
        }

        if (pName && Language == pName->LanguageId) { /* language found? */
        if (lpData == NULL) {           /* DELETE */
            return DeleteResourceFromList(pupd, pType, pName, Language, fTypeID, fNameID);
        }

                pName->DataSize = cb;           /* REPLACE */
        RtlFreeHeap(RtlProcessHeap(),0,(PVOID)pName->OffsetToDataEntry);
                (PVOID)pName->OffsetToDataEntry = lpData;
                return NO_ERROR;
        }
        else {                  /* add new language */
        return InsertResourceIntoLangList(pupd, Type, Name, pType, pNameM, Language, fNameID, cb, lpData);
        }
    }
    }
    else {                  /* unique name */
    if (lpData == NULL) {           /* can't delete new name */
        return ERROR_INVALID_PARAMETER;
    }
    }

    //
    // add new name/language
    //

    if (!fSame) {
        if (fNameID)
            pType->NumberOfNamesID++;
        else
            pType->NumberOfNamesName++;
    }

    pName = (PRESNAME)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESNAME));
    if (pName == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    RtlZeroMemory((PVOID)pName, sizeof(RESNAME));
    pName->pnext = *ppName;
    *ppName = pName;
    pName->Name = Name;
    pName->Type = Type;
    pName->NumberOfLanguages = 1;
    pName->LanguageId = Language;
    pName->DataSize = cb;
    (PVOID)pName->OffsetToDataEntry = lpData;

    return NO_ERROR;
}


BOOL
DeleteResourceFromList(
    PUPDATEDATA pUpd,
    PRESTYPE pType,
    PRESNAME pName,
    INT Language,
    INT fType,
    INT fName
    )
{
    PPRESTYPE   ppType;
    PPRESNAME   ppName;
    PRESNAME    pNameT;

    /* find previous type node */
    ppType = fType ? &pUpd->ResTypeHeadID : &pUpd->ResTypeHeadName;
    while (*ppType != pType) {
        ppType = &((*ppType)->pnext);
    }

    /* find previous type node */
    ppName = fName ? &pType->NameHeadID : &pType->NameHeadName;
    pNameT = NULL;
    while (*ppName != pName) {
    if (pNameT == NULL) {       /* find first Name in lang list */
        if (fName) {
        if ((*ppName)->Name->uu.Ordinal == pName->Name->uu.Ordinal) {
            pNameT = *ppName;
        }
        }
        else {
        if (wcsncmp((*ppName)->Name->szStr, pName->Name->szStr, (*ppName)->Name->cbsz) == 0) {
            pNameT = *ppName;
        }
        }
    }
        ppName = &((*ppName)->pnext);
    }

    if (pNameT == NULL) {   /* first of this name? */
    pNameT = pName->pnext;  /* then (possibly) make next head of lang */
    if (pNameT != NULL) {
        if (fName) {
        if (pNameT->Name->uu.Ordinal == pName->Name->uu.Ordinal) {
            pNameT->NumberOfLanguages = pName->NumberOfLanguages - 1;
        }
        }
        else {
        if (wcsncmp(pNameT->Name->szStr, pName->Name->szStr, pNameT->Name->cbsz) == 0) {
            pNameT->NumberOfLanguages = pName->NumberOfLanguages - 1;
        }
        }
    }
    }
    else
    pNameT->NumberOfLanguages--;

    if (pNameT) {
    if (pNameT->NumberOfLanguages == 0) {
        if (fName)
        pType->NumberOfNamesID -= 1;
        else
        pType->NumberOfNamesName -= 1;
    }
    }

    *ppName = pName->pnext;     /* link to next */
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pName->OffsetToDataEntry);
    RtlFreeHeap(RtlProcessHeap(), 0, pName);    /* and free */

    if (*ppName == NULL) {      /* type list completely empty? */
    *ppType = pType->pnext;         /* link to next */
    RtlFreeHeap(RtlProcessHeap(), 0, pType);    /* and free */
    }

    return NO_ERROR;
}

BOOL
InsertResourceIntoLangList(
    PUPDATEDATA pUpd,
    PSDATA Type,
    PSDATA Name,
    PRESTYPE pType,
    PRESNAME pName,
    INT Language,
    INT fName,
    INT cb,
    PVOID lpData
    )
{
    PRESNAME    pNameM;
    PRESNAME    pNameNew;
    PPRESNAME   ppName;

    pNameNew = (PRESNAME)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESNAME));
    if (pNameNew == NULL)
    return ERROR_NOT_ENOUGH_MEMORY;
    RtlZeroMemory((PVOID)pNameNew, sizeof(RESNAME));
    pNameNew->Name = Name;
    pNameNew->Type = Type;
    pNameNew->LanguageId = (WORD)Language;
    pNameNew->DataSize = cb;
    (PVOID)pNameNew->OffsetToDataEntry = lpData;

    if (Language < pName->LanguageId) {     /* have to add to the front */
    pNameNew->NumberOfLanguages = pName->NumberOfLanguages + 1;
    pName->NumberOfLanguages = 1;

        ppName = fName ? &pType->NameHeadID : &pType->NameHeadName;
    /* don't have to look for NULL at end of list !!! */
    while (pName != *ppName) {      /* find insertion point */
        ppName = &((*ppName)->pnext);   /* traverse language list */
    }
    pNameNew->pnext = *ppName;      /* insert */
    *ppName = pNameNew;
    }
    else {
    pNameM = pName;
    pName->NumberOfLanguages += 1;
    while (pName != NULL) {         /* find insertion point */
        if (Language <= pName->LanguageId)  /* here? */
        break;              /* yes */
        pNameM = pName;
        pName = pName->pnext;       /* traverse language list */
    }
    pName = pNameM->pnext;
    pNameM->pnext = pNameNew;
    pNameNew->pnext = pName;
    }
    return NO_ERROR;
}


/*
 * Utility routines
 */


ULONG
FilePos(int fh)
{

    return _llseek(fh, 0L, SEEK_CUR);
}



ULONG
MuMoveFilePos( INT fh, ULONG pos )
{
    return _llseek( fh, pos, SEEK_SET );
}



ULONG
MuWrite( INT fh, UCHAR*p, ULONG n )
{
    ULONG   n1;
    LPVOID  lpMsg;
    TCHAR  szBuf[MAX_STRING];

    n1 = _lwrite(fh, p, n);
    if ( n1 == HFILE_ERROR )
    {
        ULONG   cb;
        PUCHAR  pb;
        ULONG   cbDone, nBytes;

        // try on small buffer again
        pb = p;
        nBytes = n;
        while ( nBytes )
        {
            if (nBytes <= BUFSIZE)
                cb = nBytes;
            else
                cb = BUFSIZE;

            cbDone =  _lwrite( fh, pb, cb);
            if ( cbDone != HFILE_ERROR )
            {
                nBytes -= cbDone;
                pb += cbDone;
            }
            else
            {
                if ( FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    NULL, GetLastError(),
                                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                    (LPSTR)&lpMsg, 0, NULL ) )
                {
                     TCHAR szTmp[MAX_STRING];

                     LoadSz( IDS_ERR_WRITEFILE, szTmp, sizeof(szTmp) );
                     wsprintf( szBuf, szTmp, n, lpMsg );

                     MessageBox( NULL, szBuf, g_CDF.achTitle, MB_ICONERROR|MB_OK|
                                 ((RunningOnWin95BiDiLoc() && IsBiDiLocalizedBinary(g_hInst,RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO))) ? (MB_RIGHT | MB_RTLREADING) : 0));

                     LocalFree( lpMsg );
                }
                return cbDone;  // error return
            }
         }
         return 0;  //purely simulate the old normal return here.
    }
    else if ( n1 != n)
        return n1;
    else
        return 0;
}



ULONG
MuRead(INT fh, UCHAR*p, ULONG n )
{
    ULONG   n1;

    if ((n1 = _lread( fh, p, n )) != n) {
        return n1;
    }
    else
        return 0;
}



BOOL
MuCopy( INT srcfh, INT dstfh, ULONG nbytes )
{
    ULONG   n;
    ULONG   cb=0L;
    PUCHAR  pb;

    pb = (PUCHAR)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), BUFSIZE);
    if (pb == NULL)
        return 0;
    RtlZeroMemory((PVOID)pb, BUFSIZE);

    while (nbytes) {
        if (nbytes <= BUFSIZE)
            n = nbytes;
        else
            n = BUFSIZE;
        nbytes -= n;

        if (!MuRead( srcfh, pb, n )) {
        cb += n;
            MuWrite( dstfh, pb, n );
    }
        else {
        RtlFreeHeap(RtlProcessHeap(), 0, pb);
        return cb;
    }
    }
    RtlFreeHeap(RtlProcessHeap(), 0, pb);
    return cb;
}



VOID
SetResdata(
    PIMAGE_RESOURCE_DATA_ENTRY  pResData,
    ULONG           offset,
    ULONG           size)
{
    pResData->OffsetToData = offset;
    pResData->Size = size;
    pResData->CodePage = DEFAULT_CODEPAGE;
    pResData->Reserved = 0L;
}


VOID
SetRestab(
    PIMAGE_RESOURCE_DIRECTORY   pRestab,
    LONG            time,
    WORD            cNamed,
    WORD            cId)
{
    pRestab->Characteristics = 0L;
    pRestab->TimeDateStamp = time;
    pRestab->MajorVersion = MAJOR_RESOURCE_VERSION;
    pRestab->MinorVersion = MINOR_RESOURCE_VERSION;
    pRestab->NumberOfNamedEntries = cNamed;
    pRestab->NumberOfIdEntries = cId;
}


PIMAGE_SECTION_HEADER
FindSection(
    PIMAGE_SECTION_HEADER   pObjBottom,
    PIMAGE_SECTION_HEADER   pObjTop,
    LPSTR pName
    )
{

    while (pObjBottom < pObjTop) {
    if (strcmp(pObjBottom->Name, pName) == 0)
        return pObjBottom;
    pObjBottom++;
    }

    return NULL;
}


ULONG
AssignResourceToSection(
    PRESNAME    *ppRes,     /* resource to assign */
    ULONG   ExtraSectionOffset, /* offset between .rsrc and .rsrc1 */
    ULONG   Offset,     /* next available offset in section */
    LONG    Size,       /* Maximum size of .rsrc */
    PLONG   pSizeRsrc1
    )
{
    ULONG   cb;

    /* Assign this res to this section */
    cb = ROUNDUP((*ppRes)->DataSize, CBLONG);
    if (Offset < ExtraSectionOffset && Offset + cb > (ULONG)Size) {
    *pSizeRsrc1 = Offset;
    Offset = ExtraSectionOffset;
    DPrintf((DebugBuf, "<<< Secondary resource section @%#08lx >>>\n", Offset));
    }
    (*ppRes)->OffsetToData = Offset;
    *ppRes = (*ppRes)->pnext;
    DPrintf((DebugBuf, "    --> %#08lx bytes at %#08lx\n", cb, Offset));
    return Offset + cb;
}



/***************************** Main Worker Function ***************************
* LONG PEWriteResFile
*
* This function writes the resources to the named executable file.
* It assumes that resources have no fixups (even any existing resources
* that it removes from the executable.)  It places all the resources into
* one or two sections. The resources are packed tightly into the section,
* being aligned on dword boundaries.  Each section is padded to a file
* sector size (no invalid or zero-filled pages), and each
* resource is padded to the afore-mentioned dword boundary.  This
* function uses the capabilities of the NT system to enable it to easily
* manipulate the data:  to wit, it assumes that the system can allocate
* any sized piece of data, in particular the section and resource tables.
* If it did not, it might have to deal with temporary files (the system
* may have to grow the swap file, but that's what the system is for.)
*
* Return values are:
*     TRUE  - file was written succesfully.
*     FALSE - file was not written succesfully.
*
* Effects:
*
* History:
* Thur Apr 27, 1989        by     Floyd Rogers      [floydr]
*   Created.
* 12/8/89   sanfords    Added multiple section support.
* 12/11/90  floydr  Modified for new (NT) Linear Exe format
* 1/18/92   vich    Modified for new (NT) Portable Exe format
* 5/8/92    bryant    General cleanup so resonexe can work with unicode
* 6/9/92    floydr    incorporate bryan's changes
* 6/15/92   floydr    debug section separate from debug table
* 9/25/92   floydr    account for .rsrc not being last-1
* 9/28/92   floydr    account for adding lots of resources by adding
*             a second .rsrc section.
\****************************************************************************/

/*  */
LONG
PEWriteResFile(
    INT     inpfh,
    INT     outfh,
    ULONG   cbOldexe,
    PUPDATEDATA pUpdate
    )
{
    IMAGE_NT_HEADERS Old;   /* original header              */
    IMAGE_NT_HEADERS New;   /* working header       */
    PRESNAME    pRes;
    PRESNAME    pResSave;
    PRESTYPE    pType;
    ULONG   clock = GetTickCount(); /* current time */
    ULONG   cbName=0;   /* count of bytes in name strings */
    ULONG   cbType=0;   /* count of bytes in type strings */
    ULONG   cTypeStr=0; /* count of strings */
    ULONG   cNameStr=0; /* count of strings */
    LONG    cb;     /* temp byte count and file index */
    ULONG   cTypes = 0L;    /* count of resource types      */
    ULONG   cNames = 0L;    /* Count of names for multiple languages/name */
    ULONG   cRes = 0L;  /* count of resources      */
    ULONG   cbRestab;   /* count of resources      */
    LONG    cbNew = 0L; /* general count */
    ULONG   ibObjTab;
    ULONG   ibObjTabEnd;
    ULONG   ibSave;
    ULONG   adjust=0;
    PIMAGE_SECTION_HEADER   pObjtblOld,
        pObjtblNew,
        pObjDebug,
        pObjResourceOld,
        pObjResourceNew,
        pObjResourceOldX,
        pObjDebugDirOld,
        pObjDebugDirNew,
        pObjNew,
        pObjOld,
        pObjLast;
    PUCHAR  p;
    PIMAGE_RESOURCE_DIRECTORY   pResTab;
    PIMAGE_RESOURCE_DIRECTORY   pResTabN;
    PIMAGE_RESOURCE_DIRECTORY   pResTabL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirN;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirT;
    PIMAGE_RESOURCE_DATA_ENTRY  pResData;
    PUSHORT pResStr;
    PUSHORT pResStrEnd;
    PSDATA  pPreviousName;
    LONG    nObjResource=-1;
    LONG    nObjResourceX=-1;
    ULONG   cbResource;
    ULONG   cbMustPad = 0;
    ULONG       ibMaxDbgOffsetOld;

    MuMoveFilePos(inpfh, cbOldexe);
    MuRead(inpfh, (PUCHAR)&Old, sizeof(IMAGE_NT_HEADERS));
    ibObjTab = cbOldexe + sizeof(ULONG) + sizeof(IMAGE_FILE_HEADER) +
                              Old.FileHeader.SizeOfOptionalHeader;
    ibObjTabEnd = ibObjTab + Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);

    if (*(PUSHORT)&Old.Signature != IMAGE_NT_SIGNATURE)
    return ERROR_INVALID_EXE_SIGNATURE;

    if ((Old.FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0 &&
    (Old.FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) {
    return ERROR_EXE_MARKED_INVALID;
    }
    DPrintfn((DebugBuf, "\n"));

    /* New header is like old one.                  */
    RtlCopyMemory(&New, &Old, sizeof(IMAGE_NT_HEADERS));

    /* Read section table */
    pObjtblOld = (PIMAGE_SECTION_HEADER)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ),
    Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    if (pObjtblOld == NULL) {
    cb = ERROR_NOT_ENOUGH_MEMORY;
    goto AbortExit;
    }
    RtlZeroMemory((PVOID)pObjtblOld, Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER));
    DPrintf((DebugBuf, "Old section table: %#08lx bytes at %#08lx(mem)\n",
        Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
        pObjtblOld));
    MuMoveFilePos(inpfh, ibObjTab);
    MuRead(inpfh, (PUCHAR)pObjtblOld,
        Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    pObjLast = pObjtblOld + Old.FileHeader.NumberOfSections;
    ibMaxDbgOffsetOld = 0;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++) {
        if (pObjOld->PointerToRawData > ibMaxDbgOffsetOld) {
            ibMaxDbgOffsetOld = pObjOld->PointerToRawData + pObjOld->SizeOfRawData;
        }
    }
    DPrintf((DebugBuf, "Maximum debug offset in old file: %08x\n", ibMaxDbgOffsetOld ));

    /*
     * First, count up the resources.  We need this information
     * to discover how much room for header information to allocate
     * in the resource section.  cRes tells us how
     * many language directory entries/tables.  cNames and cTypes
     * is used for the respective tables and/or entries.  cbName totals
     * the bytes required to store the alpha names (including the leading
     * length word).  cNameStr counts these strings.
     */
    DPrintf((DebugBuf, "Beginning loop to count resources\n"));

    /* first, count those in the named type list */
    cbResource = 0;
    //DPrintf((DebugBuf, "Walk type: NAME list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL) {
    if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
        //DPrintf((DebugBuf, "Resource type "));
        //DPrintfu((pType->Type->szStr));
        //DPrintfn((DebugBuf, "\n"));
        cTypes++;
        cTypeStr++;
        cbType += (pType->Type->cbsz + 1) * sizeof(WORD);

            //DPrintf((DebugBuf, "Walk name: Alpha list\n"));
            pPreviousName = NULL;
        pRes = pType->NameHeadName;
        while (pRes) {
        //DPrintf((DebugBuf, "Resource "));
        //DPrintfu((pRes->Name->szStr));
        //DPrintfn((DebugBuf, "\n"));
        cRes++;
                if (pPreviousName == NULL ||
                    wcsncmp(pPreviousName->szStr,
                            pRes->Name->szStr,
                            pRes->Name->cbsz) != 0) {
            cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
            cNameStr++;
                    cNames++;
        }
        cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
        pRes = pRes->pnext;
        }

            //DPrintf((DebugBuf, "Walk name: ID list\n"));
            pPreviousName = NULL;
        pRes = pType->NameHeadID;
        while (pRes) {
        //DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
        cRes++;
                if (pPreviousName == NULL ||
                    pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                    cNames++;
                }
        cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
        pRes = pRes->pnext;
        }
        }
        pType = pType->pnext;
    }

    /* second, count those in the ID type list */
    //DPrintf((DebugBuf, "Walk type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL) {
    if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
        //DPrintf((DebugBuf, "Resource type %hu\n", pType->Type->uu.Ordinal));
        cTypes++;
            //DPrintf((DebugBuf, "Walk name: Alpha list\n"));
            pPreviousName = NULL;
        pRes = pType->NameHeadName;
        while (pRes) {
        //DPrintf((DebugBuf, "Resource "));
        //DPrintfu((pRes->Name->szStr));
        //DPrintfn((DebugBuf, "\n"));
        cRes++;
                if (pPreviousName == NULL ||
                    wcsncmp(pPreviousName->szStr,
                            pRes->Name->szStr,
                            pRes->Name->cbsz) != 0) {
                    cNames++;
            cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
            cNameStr++;
        }
        cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
        pRes = pRes->pnext;
        }

            //DPrintf((DebugBuf, "Walk name: ID list\n"));
            pPreviousName = NULL;
        pRes = pType->NameHeadID;
        while (pRes) {
        //DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
        cRes++;
                if (pPreviousName == NULL ||
                    pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                    cNames++;
                }
        cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
        pRes = pRes->pnext;
        }
    }
        pType = pType->pnext;
    }
    cb = REMAINDER(cbName + cbType, CBLONG);

    /* Add up the number of bytes needed to store the directory.  There is
     * one type table with cTypes entries.  They point to cTypes name tables
     * that have a total of cNames entries.  Each of them points to a language
     * table and there are a total of cRes entries in all the language tables.
     * Finally, we have the space needed for the Directory string entries,
     * some extra padding to attain the desired alignment, and the space for
     * cRes data entry headers.
     */
    cbRestab =   sizeof(IMAGE_RESOURCE_DIRECTORY) + /* root dir (types) */
    cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) + /* subdir2 (names) */
    cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) + /* subdir3 (langs) */
    cRes   * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    (cbName + cbType) +             /* name/type strings */
    cb +                        /* padding */
    cRes   * sizeof(IMAGE_RESOURCE_DATA_ENTRY); /* data entries */

    cbResource += cbRestab;     /* add in the resource table */

    // Find any current resource sections

    pObjResourceOld = FindSection(pObjtblOld, pObjLast, ".rsrc");
    pObjResourceOldX = FindSection(pObjtblOld, pObjLast, ".rsrc1");
    if (pObjResourceOld == NULL) {
    cb = 0x7fffffff;        /* can fill forever */
    }
    else if (pObjResourceOld + 1 == pObjResourceOldX) {
    nObjResource = (LONG)(pObjResourceOld - pObjtblOld);
    DPrintf((DebugBuf,"Old Resource section #%lu\n", nObjResource+1));
    DPrintf((DebugBuf,"Merging old Resource extra section #%lu\n", nObjResource+2));
    cb = 0x7fffffff;        /* merge resource sections */
    }
    else if ((pObjResourceOld + 1) >= pObjLast) {
        nObjResource = (LONG)(pObjResourceOld - pObjtblOld);
        cb = 0x7fffffff;        /* can fill forever (.rsrc is the last entry) */
    }
    else {
    nObjResource = (LONG)(pObjResourceOld - pObjtblOld);
    DPrintf((DebugBuf,"Old Resource section #%lu\n", nObjResource+1));
    cb = (pObjResourceOld+1)->VirtualAddress -
            pObjResourceOld->VirtualAddress;
    if (cbRestab > (ULONG)cb) {
        DPrintf((DebugBuf, "Resource Table Too Large\n"));
        return ERROR_INVALID_DATA;
    }
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if (pObjResourceOld != NULL && cbResource > (ULONG)cb) {
        if (pObjOld == pObjResourceOld + 1) {
            DPrintf((DebugBuf, "Large resource section  pushes .reloc\n"));
            cb = 0x7fffffff;        /* can fill forever */
        }
        else if (pObjResourceOldX == NULL) {
            DPrintf((DebugBuf, "Too much resource data for old .rsrc section\n"));
            nObjResourceX = (LONG)(pObjOld - pObjtblOld);
            adjust = pObjOld->VirtualAddress - pObjResourceOld->VirtualAddress;
        }
        else {      /* have already merged .rsrc & .rsrc1, if possible */
            DPrintf((DebugBuf, ".rsrc1 section not empty\n"));
            nObjResourceX = (LONG)(pObjResourceOldX - pObjtblOld);
            adjust = pObjResourceOldX->VirtualAddress -
                 pObjResourceOld ->VirtualAddress;
        }
    }

    /*
     * Walk the type lists and figure out where the Data entry header will
     * go.  Keep a running total of the size for each data element so we
     * can store this in the section header.
     */
    DPrintf((DebugBuf, "Beginning loop to assign resources to addresses\n"));

    /* first, those in the named type list */

    cbResource = cbRestab;  /* assign resource table to 1st rsrc section */
                /* adjust == offset to .rsrc1 */
                /* cb == size availble in .rsrc */
    cbNew = 0;          /* count of bytes in second .rsrc */
    DPrintf((DebugBuf, "Walk type: NAME list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL) {
    if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
        DPrintf((DebugBuf, "Resource type "));
        DPrintfu((pType->Type->szStr));
        DPrintfn((DebugBuf, "\n"));
        pRes = pType->NameHeadName;
        while (pRes) {
        DPrintf((DebugBuf, "Resource "));
        DPrintfu((pRes->Name->szStr));
        DPrintfn((DebugBuf, "\n"));
        cbResource = AssignResourceToSection(&pRes,
            adjust, cbResource, cb, &cbNew);
        }
        pRes = pType->NameHeadID;
        while (pRes) {
        DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
        cbResource = AssignResourceToSection(&pRes,
            adjust, cbResource, cb, &cbNew);
        }
    }
        pType = pType->pnext;
    }

    /* then, count those in the ID type list */

    DPrintf((DebugBuf, "Walk type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL) {
    if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
        DPrintf((DebugBuf, "Resource type %hu\n", pType->Type->uu.Ordinal));
        pRes = pType->NameHeadName;
        while (pRes) {
        DPrintf((DebugBuf, "Resource "));
        DPrintfu((pRes->Name->szStr));
        DPrintfn((DebugBuf, "\n"));
        cbResource = AssignResourceToSection(&pRes,
            adjust, cbResource, cb, &cbNew);
        }
        pRes = pType->NameHeadID;
        while (pRes) {
        DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
        cbResource = AssignResourceToSection(&pRes,
            adjust, cbResource, cb, &cbNew);
        }
    }
        pType = pType->pnext;
    }
    /*
     * At this point:
     * cbResource has offset of first byte past the last resource.
     * cbNew has the count of bytes in the first resource section,
     * if there are two sections.
     */
    if (cbNew == 0)
    cbNew = cbResource;

    /*
     * Discover where the Debug info is (if any)?
     */
    pObjDebug = FindSection(pObjtblOld, pObjLast, ".debug");
    if (pObjDebug != NULL) {
    if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress  == 0) {
        DPrintf((DebugBuf, ".debug section but no debug directory\n"));
        return ERROR_INVALID_DATA;
    }
    if (pObjDebug != pObjLast-1) {
        DPrintf((DebugBuf, "debug section not last section in file\n"));
        return ERROR_INVALID_DATA;
    }
    DPrintf((DebugBuf, "Debug section: %#08lx bytes @%#08lx\n",
         pObjDebug->SizeOfRawData,
         pObjDebug->PointerToRawData));
    }
    pObjDebugDirOld = NULL;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++) {
    if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress >= pObjOld->VirtualAddress &&
        Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress < pObjOld->VirtualAddress+pObjOld->SizeOfRawData) {
        pObjDebugDirOld = pObjOld;
        break;
    }
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if (nObjResource == -1) {       /* no old resource section */
    if (pObjOld != NULL)
        nObjResource = (LONG)(pObjOld - pObjtblOld);
    else if (pObjDebug != NULL)
        nObjResource = (LONG)(pObjDebug - pObjtblOld);
    else
        nObjResource = New.FileHeader.NumberOfSections;
    New.FileHeader.NumberOfSections++;
    }

    DPrintf((DebugBuf, "Resources assigned to section #%lu\n", nObjResource+1));
    if (nObjResourceX != -1) {
    if (pObjResourceOldX != NULL) {
        nObjResourceX = (LONG)(pObjResourceOldX - pObjtblOld);
        New.FileHeader.NumberOfSections--;
    }
    else if (pObjOld != NULL)
        nObjResourceX = (LONG)(pObjOld - pObjtblOld);
    else if (pObjDebug != NULL)
        nObjResourceX = (LONG)(pObjDebug - pObjtblOld);
    else
        nObjResourceX = New.FileHeader.NumberOfSections;
    New.FileHeader.NumberOfSections++;
    DPrintf((DebugBuf, "Extra resources assigned to section #%lu\n",
        nObjResourceX+1));
    }
    else if (pObjResourceOldX != NULL) {    /* Was old .rsrc1 section? */
    DPrintf((DebugBuf, "Extra resource section deleted\n"));
    New.FileHeader.NumberOfSections--;  /* yes, delete it */
    }

    /*
     * If we had to add anything to the header (section table),
     * then we have to update the header size and rva's in the header.
     */
    adjust = (New.FileHeader.NumberOfSections -
          Old.FileHeader.NumberOfSections) * sizeof(IMAGE_SECTION_HEADER);
    cb = Old.OptionalHeader.SizeOfHeaders -
    (Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER) +
     sizeof(IMAGE_NT_HEADERS) + cbOldexe );
    if (adjust > (ULONG)cb) {
    int i;

    adjust -= cb;
    DPrintf((DebugBuf, "Adjusting header RVAs by %#08lx\n", adjust));
    for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES ; i++) {
        if (New.OptionalHeader.DataDirectory[i].VirtualAddress &&
        New.OptionalHeader.DataDirectory[i].VirtualAddress < New.OptionalHeader.SizeOfHeaders) {
        DPrintf((DebugBuf, "Adjusting unit[%s] RVA from %#08lx to %#08lx\n",
             apszUnit[i],
             New.OptionalHeader.DataDirectory[i].VirtualAddress,
             New.OptionalHeader.DataDirectory[i].VirtualAddress + adjust));
        New.OptionalHeader.DataDirectory[i].VirtualAddress += adjust;
        }
    }
    New.OptionalHeader.SizeOfHeaders += adjust;
    }

    /* Allocate storage for new section table                */
    cb = New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    pObjtblNew = (PIMAGE_SECTION_HEADER)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), (short)cb);
    if (pObjtblNew == NULL) {
    cb = ERROR_NOT_ENOUGH_MEMORY;
    goto AbortExit;
    }
    RtlZeroMemory((PVOID)pObjtblNew, cb);
    DPrintf((DebugBuf, "New section table: %#08lx bytes at %#08lx\n", cb, pObjtblNew));
    pObjResourceNew = pObjtblNew + nObjResource;

    /*
     * copy old section table to new
     */
    adjust = 0;         /* adjustment to virtual address */
    for (pObjOld=pObjtblOld,pObjNew=pObjtblNew ; pObjOld<pObjLast ; pObjOld++) {
    if (pObjOld == pObjResourceOldX) {
        if (nObjResourceX == -1) {
            // we have to move back all the other section.
            // the .rsrc1 is bigger than what we need
            // adjust must be a negative number
            if (pObjOld+1 < pObjLast) {
                adjust -= (pObjOld+1)->VirtualAddress - pObjOld->VirtualAddress;
            }
        }
        continue;
    }
    else if (pObjNew == pObjResourceNew) {
        DPrintf((DebugBuf, "Resource Section %i\n", nObjResource+1));
        cb = ROUNDUP(cbNew, New.OptionalHeader.FileAlignment);
        if (pObjResourceOld == NULL) {
        adjust = ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
        RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
        strcpy(pObjNew->Name, ".rsrc");
        pObjNew->VirtualAddress = pObjOld->VirtualAddress;
        pObjNew->PointerToRawData = pObjOld->PointerToRawData;
        pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
            IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_INITIALIZED_DATA;
        pObjNew->SizeOfRawData = cb;
        pObjNew->Misc.VirtualSize = ROUNDUP(cb, New.OptionalHeader.SectionAlignment);
        }
        else {
        *pObjNew = *pObjOld;    /* copy obj table entry */
        pObjNew->SizeOfRawData = cb;
        pObjNew->Misc.VirtualSize = ROUNDUP(cb, New.OptionalHeader.SectionAlignment);
        if (pObjNew->SizeOfRawData == pObjOld->SizeOfRawData) {
            adjust = 0;
        }
        else if (pObjNew->SizeOfRawData > pObjOld->SizeOfRawData) {
            adjust += ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
            if (pObjOld+1 < pObjLast) {
                // if there is more stuff after pObjOld, shift it as well
                adjust -= ((pObjOld+1)->VirtualAddress-pObjOld->VirtualAddress);
            }
        }
        else {      /* is smaller, but pad so will be valid */
            adjust = 0;
            pObjNew->SizeOfRawData = pObjResourceOld->SizeOfRawData;
            pObjNew->Misc.VirtualSize = ROUNDUP(pObjNew->SizeOfRawData, New.OptionalHeader.SectionAlignment);
            /* don't need to set VirtualSize - will be the same */
            cbMustPad = pObjResourceOld->SizeOfRawData;
        }
        }
        pObjNew++;
        if (pObjResourceOld == NULL)
        goto rest_of_table;
    }
    else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) {
        DPrintf((DebugBuf, "Additional Resource Section %i\n",
        nObjResourceX+1));
        RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
        strcpy(pObjNew->Name, ".rsrc1");
        /*
         * Before we copy the virtual address we have to move back the
         * .reloc * virtual address. Otherwise we will keep moving the
         * reloc VirtualAddress forward.
         * We will have to move back the address of .rsrc1
         */
        if (pObjResourceOldX == NULL) {
        // This is the first time we have a .rsrc1
        pObjNew->VirtualAddress = pObjOld->VirtualAddress;
        pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
            IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_INITIALIZED_DATA;
        adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
            pObjResourceNew->VirtualAddress - pObjNew->VirtualAddress;
        DPrintf((DebugBuf, "Added .rsrc1. VirtualAddress %lu\t adjust: %lu\n", pObjNew->VirtualAddress, adjust ));
        }
        else {
        // we already have an .rsrc1 use the position of that and
        // calculate the new adjust
        pObjNew->VirtualAddress = pObjResourceOldX->VirtualAddress;
        pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
            IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_INITIALIZED_DATA;

        DPrintf((DebugBuf, ".rsrc1 Keep old position.\t\tVirtualAddress %lu\t", pObjNew->VirtualAddress ));
        // Check if we have enough room in the old .rsrc1
        // Include the full size of the section, data + roundup
        if (cbResource -
            (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress) <=
            pObjOld->VirtualAddress - pObjNew->VirtualAddress ) {
            // we have to move back all the other section.
            // the .rsrc1 is bigger than what we need
            // adjust must be a negative number
            // calc new adjust size
            adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
            pObjResourceNew->VirtualAddress -
            pObjOld->VirtualAddress;
            DPrintf((DebugBuf, "adjust: %ld\tsmall: New %lu\tOld %lu\n", adjust,
            cbResource -
            (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress),
            pObjOld->VirtualAddress - pObjNew->VirtualAddress));
        }
        else {
            // we have to move the section again.
            // The .rsrc1 is too small

            adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
            pObjResourceNew->VirtualAddress -
            pObjOld->VirtualAddress;
            DPrintf((DebugBuf, "adjust: %lu\tsmall: New %lu\tOld %lu\n", adjust,
            cbResource -
            (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress),
            pObjOld->VirtualAddress - pObjNew->VirtualAddress));
        }
        }
        pObjNew++;
        goto rest_of_table;
    }
    else if (pObjNew < pObjResourceNew) {
        DPrintf((DebugBuf, "copying section table entry %i@%#08lx\n",
             pObjOld - pObjtblOld + 1, pObjNew));
        *pObjNew++ = *pObjOld;      /* copy obj table entry */
    }
    else {
rest_of_table:
        DPrintf((DebugBuf, "copying section table entry %i@%#08lx\n",
             pObjOld - pObjtblOld + 1, pObjNew));
        DPrintf((DebugBuf, "adjusting VirtualAddress by %#08lx\n", adjust));
        *pObjNew++ = *pObjOld;
        (pObjNew-1)->VirtualAddress += adjust;
    }
    }


    pObjNew = pObjtblNew + New.FileHeader.NumberOfSections - 1;
    New.OptionalHeader.SizeOfImage = ROUNDUP(pObjNew->VirtualAddress +
                    pObjNew->SizeOfRawData,
                                    New.OptionalHeader.SectionAlignment);

    /* allocate room to build the resource directory/tables in */
    pResTab = (PIMAGE_RESOURCE_DIRECTORY)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cbRestab);
    if (pResTab == NULL) {
    cb = ERROR_NOT_ENOUGH_MEMORY;
    goto AbortExit;
    }

    /* First, setup the "root" type directory table.  It will be followed by */
    /* Types directory entries.                          */

    RtlZeroMemory((PVOID)pResTab, cbRestab);
    DPrintf((DebugBuf, "resource directory tables: %#08lx bytes at %#08lx(mem)\n", cbRestab, pResTab));
    p = (PUCHAR)pResTab;
    pResTab->Characteristics = 0L;
    pResTab->TimeDateStamp = clock;
    pResTab->MajorVersion = MAJOR_RESOURCE_VERSION;
    pResTab->MinorVersion = MINOR_RESOURCE_VERSION;
    pResTab->NumberOfNamedEntries = (USHORT)cTypeStr;
    pResTab->NumberOfIdEntries = (USHORT)(cTypes - cTypeStr);

    /* Calculate the start of the various parts of the resource table.  */
    /* We need the start of the Type/Name/Language directories as well  */
    /* as the start of the UNICODE strings and the actual data nodes.   */

    pResDirT = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTab + 1);

    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirT) +
        cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirN) +
        cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) +
        cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResData = (PIMAGE_RESOURCE_DATA_ENTRY)(((PUCHAR)pResDirL) +
        cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) +
        cRes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResStr  = (PUSHORT)(((PUCHAR)pResData) +
        cRes * sizeof(IMAGE_RESOURCE_DATA_ENTRY));

    pResStrEnd = (PUSHORT)(((PUCHAR)pResStr) + cbName + cbType);

    /*
     * Loop over type table, building the PE resource table.
     */

    /*
     * *****************************************************************
     * This code doesn't sort the table - the TYPEINFO and RESINFO    **
     * insertion code in rcp.c (AddResType and SaveResFile) do the    **
     * insertion by ordinal type and name, so we don't have to sort   **
     * it at this point.                                              **
     * *****************************************************************
     */
    DPrintf((DebugBuf, "building resource directory\n"));

    // First, add all the entries in the Types: Alpha list.

    DPrintf((DebugBuf, "Walk the type: Alpha list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
    DPrintf((DebugBuf, "resource type "));
    DPrintfu((pType->Type->szStr));
    DPrintfn((DebugBuf, "\n"));

    pResDirT->Name = (ULONG)((((PUCHAR)pResStr) - p) |
            IMAGE_RESOURCE_NAME_IS_STRING);
    pResDirT->OffsetToData = (ULONG)((((PUCHAR)pResDirN) - p) |
            IMAGE_RESOURCE_DATA_IS_DIRECTORY);
    pResDirT++;

    *pResStr = pType->Type->cbsz;
    wcsncpy((WCHAR*)(pResStr+1), pType->Type->szStr, pType->Type->cbsz);
    pResStr += pType->Type->cbsz + 1;

    pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
    SetRestab(pResTabN, clock,
        (USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

        pPreviousName = NULL;

    pRes = pType->NameHeadName;
    while (pRes) {
        DPrintf((DebugBuf, "resource "));
        DPrintfu((pRes->Name->szStr));
        DPrintfn((DebugBuf, "\n"));

            if (pPreviousName == NULL ||
                wcsncmp(pPreviousName->szStr,
                           pRes->Name->szStr,
                           pRes->Name->cbsz) != 0) {
                // Setup a new name directory

            pResDirN->Name = (ULONG)((((PUCHAR)pResStr)-p) |
            IMAGE_RESOURCE_NAME_IS_STRING);
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
            IMAGE_RESOURCE_DATA_IS_DIRECTORY);
            pResDirN++;

            // Copy the alpha name to a string entry

            *pResStr = pRes->Name->cbsz;
            wcsncpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz);
            pResStr += pRes->Name->cbsz + 1;

                pPreviousName = pRes->Name;

                // Setup the Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
        SetRestab(pResTabL, clock,
            (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new Language directory

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

        SetResdata(pResData,
        pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
        pRes->DataSize);
        pResData++;

        pRes = pRes->pnext;
    }

        pPreviousName = NULL;

    pRes = pType->NameHeadID;
    while (pRes) {
        DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));

            if (pPreviousName == NULL ||
                pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                // Setup the name directory to point to the next language
                // table

            pResDirN->Name = pRes->Name->uu.Ordinal;
            pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
            IMAGE_RESOURCE_DATA_IS_DIRECTORY);
            pResDirN++;

                pPreviousName = pRes->Name;

                // Init a new Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
        SetRestab(pResTabL, clock,
            (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new language directory entry to point to the next
            // resource

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

        SetResdata(pResData,
        pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
        pRes->DataSize);
        pResData++;

        pRes = pRes->pnext;
    }

    pType = pType->pnext;
    }

    //  Do the same thing, but this time, use the Types: ID list.

    DPrintf((DebugBuf, "Walk the type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType) {
    DPrintf((DebugBuf, "resource type %hu\n", pType->Type->uu.Ordinal));

    pResDirT->Name = (ULONG)pType->Type->uu.Ordinal;
    pResDirT->OffsetToData = (ULONG)((((PUCHAR)pResDirN) - p) |
            IMAGE_RESOURCE_DATA_IS_DIRECTORY);
    pResDirT++;

    pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
    SetRestab(pResTabN, clock,
        (USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

        pPreviousName = NULL;

    pRes = pType->NameHeadName;
    while (pRes) {
        DPrintf((DebugBuf, "resource "));
        DPrintfu((pRes->Name->szStr));
        DPrintfn((DebugBuf, "\n"));

            if (pPreviousName == NULL ||
                wcsncmp(pPreviousName->szStr,
                           pRes->Name->szStr,
                           pRes->Name->cbsz) != 0) {
                // Setup a new name directory

            pResDirN->Name = (ULONG)((((PUCHAR)pResStr)-p) |
            IMAGE_RESOURCE_NAME_IS_STRING);
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                        IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                // Copy the alpha name to a string entry.

            *pResStr = pRes->Name->cbsz;
            wcsncpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz);
            pResStr += pRes->Name->cbsz + 1;

                pPreviousName = pRes->Name;

                // Setup the Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
        SetRestab(pResTabL, clock,
            (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new Language directory

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

        SetResdata(pResData,
        pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
        pRes->DataSize);
        pResData++;

        pRes = pRes->pnext;
    }

        pPreviousName = NULL;

    pRes = pType->NameHeadID;
    while (pRes) {
        DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));

            if (pPreviousName == NULL ||
                pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                // Setup the name directory to point to the next language
                // table

            pResDirN->Name = pRes->Name->uu.Ordinal;
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                        IMAGE_RESOURCE_DATA_IS_DIRECTORY);
            pResDirN++;

                pPreviousName = pRes->Name;

                // Init a new Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
        SetRestab(pResTabL, clock,
            (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new language directory entry to point to the next
            // resource

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry


        SetResdata(pResData,
        pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
        pRes->DataSize);
        pResData++;

        pRes = pRes->pnext;
    }

    pType = pType->pnext;
    }
    DPrintf((DebugBuf, "Zeroing %u bytes after strings at %#08lx(mem)\n",
         (pResStrEnd - pResStr) * sizeof(*pResStr), pResStr));
    while (pResStr < pResStrEnd) {
    *pResStr++ = 0;
    }

#if DBG
    {
    USHORT  j = 0;
    PUSHORT pus = (PUSHORT)pResTab;

    while (pus < (PUSHORT)pResData) {
        DPrintf((DebugBuf, "%04x\t%04x %04x %04x %04x %04x %04x %04x %04x\n",
             j,
             *pus,
             *(pus + 1),
             *(pus + 2),
             *(pus + 3),
             *(pus + 4),
             *(pus + 5),
             *(pus + 6),
             *(pus + 7)));
        pus += 8;
        j += 16;
    }
    }
#endif /* DBG */

    /*
     * copy the Old exe header and stub, and allocate room for the PE header.
     */
    DPrintf((DebugBuf, "copying through PE header: %#08lx bytes @0x0\n",
         cbOldexe + sizeof(IMAGE_NT_HEADERS)));
    MuMoveFilePos(inpfh, 0L);
    MuCopy(inpfh, outfh, cbOldexe + sizeof(IMAGE_NT_HEADERS));

    /*
     * Copy rest of file header
     */
    DPrintf((DebugBuf, "skipping section table: %#08lx bytes @%#08lx\n",
         New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
         FilePos(outfh)));
    DPrintf((DebugBuf, "copying hdr data: %#08lx bytes @%#08lx ==> @%#08lx\n",
         Old.OptionalHeader.SizeOfHeaders - ibObjTabEnd,
         ibObjTabEnd,
         ibObjTabEnd + New.OptionalHeader.SizeOfHeaders -
            Old.OptionalHeader.SizeOfHeaders));

    MuMoveFilePos(outfh, ibObjTabEnd + New.OptionalHeader.SizeOfHeaders -
            Old.OptionalHeader.SizeOfHeaders);
    MuMoveFilePos(inpfh, ibObjTabEnd);
    MuCopy(inpfh, outfh, Old.OptionalHeader.SizeOfHeaders - ibObjTabEnd);

    /*
     * copy existing image sections
     */

    /* Align data sections on sector boundary           */

    cb = REMAINDER(New.OptionalHeader.SizeOfHeaders, New.OptionalHeader.FileAlignment);
    New.OptionalHeader.SizeOfHeaders += cb;

    /* [Inateeg update next 3 lines] */

    // Zero out the Bound Import Descriptor slot (we don't care about it for now)
    New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;
    New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

    cb = pObjtblOld->PointerToRawData - FilePos(outfh);

    DPrintf((DebugBuf, "padding header with %#08lx bytes @%#08lx\n", cb, FilePos(outfh)));
    while (cb >= cbPadMax) {
    MuWrite(outfh, pchZero, cbPadMax);
    cb -= cbPadMax;
    }
    MuWrite(outfh, pchZero, cb);

    cb = ROUNDUP(Old.OptionalHeader.SizeOfHeaders, Old.OptionalHeader.FileAlignment);
    MuMoveFilePos(inpfh, cb);

    /* copy one section at a time */
    New.OptionalHeader.SizeOfInitializedData = 0;
    for (pObjOld = pObjtblOld , pObjNew = pObjtblNew ;
        pObjOld < pObjLast ;
            pObjNew++) {
    if (pObjOld == pObjResourceOldX)
        pObjOld++;
    if (pObjNew == pObjResourceNew) {

        /* Write new resource section */
        DPrintf((DebugBuf, "Primary resource section %i to %#08lx\n",
            nObjResource+1, FilePos(outfh)));

        pObjNew->PointerToRawData = FilePos(outfh);
        New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = pObjResourceNew->VirtualAddress;
            New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = cbResource;
        ibSave = FilePos(outfh);
        DPrintf((DebugBuf,
            "writing resource header data: %#08lx bytes @%#08lx\n",
             cbRestab, ibSave));
        MuWrite(outfh, (PUCHAR)pResTab, cbRestab);

        pResSave = WriteResSection(pUpdate, outfh,
                    New.OptionalHeader.FileAlignment,
                    pObjResourceNew->SizeOfRawData-cbRestab,
                    NULL);
        cb = FilePos(outfh);
        DPrintf((DebugBuf, "wrote resource data: %#08lx bytes @%#08lx\n",
            cb - ibSave - cbRestab, ibSave + cbRestab));
        if (cbMustPad != 0) {
        cbMustPad -= cb - ibSave;
        DPrintf((DebugBuf, "writing MUNGE pad: %#04lx bytes @%#08lx\n",
             cbMustPad, cb));
        /* assumes that cbMustPad % cbpadMax == 0 */
        while (cbMustPad > 0) {
            MuWrite(outfh, pchPad, cbPadMax);
            cbMustPad -= cbPadMax;
        }
        cb = FilePos(outfh);
        }
        if (nObjResourceX == -1) {
        MuMoveFilePos(outfh, ibSave);
        DPrintf((DebugBuf,
            "re-writing resource directory: %#08x bytes @%#08lx\n",
            cbRestab, ibSave));
        MuWrite(outfh, (PUCHAR)pResTab, cbRestab);
        MuMoveFilePos(outfh, cb);
        cb = FilePos(inpfh);
        MuMoveFilePos(inpfh, cb+pObjOld->SizeOfRawData);
        }
        New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
        if (pObjResourceOld == NULL) {
        pObjNew++;
        goto next_section;
        }
        else
        pObjOld++;
    }
    else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) {

        /* Write new resource section */
        DPrintf((DebugBuf, "Secondary resource section %i @%#08lx\n",
            nObjResourceX+1, FilePos(outfh)));

        pObjNew->PointerToRawData = FilePos(outfh);
        (void)WriteResSection(pUpdate, outfh,
            New.OptionalHeader.FileAlignment, 0xffffffff, pResSave);
        cb = FilePos(outfh);
        pObjNew->SizeOfRawData = cb - pObjNew->PointerToRawData;
        pObjNew->Misc.VirtualSize = ROUNDUP(pObjNew->SizeOfRawData, New.OptionalHeader.SectionAlignment);
        DPrintf((DebugBuf, "wrote resource data: %#08lx bytes @%#08lx\n",
             pObjNew->SizeOfRawData, pObjNew->PointerToRawData));
        MuMoveFilePos(outfh, ibSave);
        DPrintf((DebugBuf,
            "re-writing resource directory: %#08x bytes @%#08lx\n",
            cbRestab, ibSave));
        MuWrite(outfh, (PUCHAR)pResTab, cbRestab);
        MuMoveFilePos(outfh, cb);
        New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
        pObjNew++;
        goto next_section;
    }
    else {
        if (pObjNew < pObjResourceNew &&
             pObjOld->PointerToRawData != 0 &&
        pObjOld->PointerToRawData != FilePos(outfh)) {
        MuMoveFilePos(outfh, pObjOld->PointerToRawData);
        }
next_section:
        /* Nop this section, because the author doesn't know what he's doing
            if ((Old.OptionalHeader.BaseOfCode == 0x400) &&
                (Old.FileHeader.Machine == IMAGE_FILE_MACHINE_R3000 ||
                 Old.FileHeader.Machine == IMAGE_FILE_MACHINE_R4000
                ) &&
                (pObjOld->PointerToRawData != 0) &&
                (pObjOld->VirtualAddress != New.OptionalHeader.BaseOfCode) &&
                ((pObjOld->Characteristics&IMAGE_SCN_CNT_CODE) != 0)
               ) {
                cb = FilePos(outfh) & 0xFFF;
                if (cb != 0) {
                    cb = (cb ^ 0xFFF) + 1;
                    DPrintf((DebugBuf, "padding driver code section %#08lx bytes @%#08lx\n", cb, FilePos(outfh)));
                    while (cb >= cbPadMax) {
                        MuWrite(outfh, pchZero, cbPadMax);
                        cb -= cbPadMax;
                    }
                    MuWrite(outfh, pchZero, cb);
                }
            }
        End nop. */

        DPrintf((DebugBuf, "copying section %i @%#08lx\n",
            pObjNew-pObjtblNew+1, FilePos(outfh)));
        if (pObjOld->PointerToRawData != 0) {
        pObjNew->PointerToRawData = FilePos(outfh);
        MuMoveFilePos(inpfh, pObjOld->PointerToRawData);
        MuCopy(inpfh, outfh, pObjOld->SizeOfRawData);
        }
        if (pObjOld == pObjDebugDirOld) {
        pObjDebugDirNew = pObjNew;
        }
            if ((pObjNew->Characteristics&IMAGE_SCN_CNT_INITIALIZED_DATA) != 0)
        New.OptionalHeader.SizeOfInitializedData +=
                pObjNew->SizeOfRawData;
        pObjOld++;
    }
    }
    if (pObjResourceOldX != NULL)
    New.OptionalHeader.SizeOfInitializedData -=
            pObjResourceOldX->SizeOfRawData;


    /* Update the address of the relocation table */
    pObjNew = FindSection(pObjtblNew,
              pObjtblNew+New.FileHeader.NumberOfSections,
              ".reloc");
    if (pObjNew != NULL) {
    New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = pObjNew->VirtualAddress;
    }

    /*
     * Write new section table out.
     */
    DPrintf((DebugBuf, "Writing new section table: %#08x bytes @%#08lx\n",
         New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
         ibObjTab));
    MuMoveFilePos(outfh, ibObjTab);
    MuWrite(outfh, (PUCHAR)pObjtblNew, New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));

    /* Seek to end of output file and issue truncating write */
    adjust = _llseek(outfh, 0L, SEEK_END);
    MuWrite(outfh, NULL, 0);
    DPrintf((DebugBuf, "File size is: %#08lx\n", adjust));

    /* If a debug section, fix up the debug table */
    pObjNew = FindSection(pObjtblNew,
              pObjtblNew+New.FileHeader.NumberOfSections,
              ".debug");
    cb = PatchDebug(inpfh, outfh,
        pObjDebug, pObjNew,
        pObjDebugDirOld, pObjDebugDirNew,
                &Old, &New, ibMaxDbgOffsetOld, &adjust);

    if (cb == NO_ERROR) {
    if (pObjResourceOld == NULL) {
        cb = (LONG)pObjResourceNew->SizeOfRawData;
    }
    else {
        cb = (LONG)pObjResourceOld->SizeOfRawData -
         (LONG)pObjResourceNew->SizeOfRawData;
    }
    cb = PatchRVAs(inpfh, outfh, pObjtblNew, cb,
        &New, Old.OptionalHeader.SizeOfHeaders);
    }

    /* copy NOTMAPPED debug info */
    if (pObjDebugDirOld != NULL && pObjDebug == NULL &&
        New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size
        != 0) {
    if (New.FileHeader.PointerToSymbolTable != 0)
        New.FileHeader.PointerToSymbolTable = adjust;   /* update symbol table ptr */
    ibSave = _llseek(inpfh, 0L, SEEK_END);  /* copy debug data */
    _llseek(outfh, 0L, SEEK_END);       /* to EOF */
    MuMoveFilePos(inpfh, adjust);   /* returned by PatchDebug */
    DPrintf((DebugBuf, "Copying NOTMAPPED Debug Information, %#08lx bytes\n", ibSave-adjust));
    MuCopy(inpfh, outfh, ibSave-adjust);
    }

    /*
     * Write updated PE header
     */
    DPrintf((DebugBuf, "Writing updated file header: %#08x bytes @%#08lx\n",
         sizeof(IMAGE_NT_HEADERS),
         cbOldexe));
    MuMoveFilePos(outfh, (long)cbOldexe);
    MuWrite(outfh, (char*)&New, sizeof(IMAGE_NT_HEADERS));

    /* free up allocated memory */

    DPrintf((DebugBuf, "Freeing old section table: %#08lx(mem)\n", pObjtblOld));
    RtlFreeHeap(RtlProcessHeap(), 0, pObjtblOld);
    DPrintf((DebugBuf, "Freeing resource directory: %#08lx(mem)\n", pResTab));
    RtlFreeHeap(RtlProcessHeap(), 0, pResTab);

AbortExit:
    DPrintf((DebugBuf, "Freeing new section table: %#08lx(mem)\n", pObjtblNew));
    RtlFreeHeap(RtlProcessHeap(), 0, pObjtblNew);
    return cb;
}


/***************************************************************************
 * WriteResSection
 *
 * This routine writes out the resources asked for into the current section.
 * It pads resources to dword (4-byte) boundaries.
 **************************************************************************/

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME    pResSave
    )
{
    ULONG   cbB=0;            /* bytes in current section    */
    ULONG   cbT;            /* bytes in current section    */
    ULONG   size;
    PRESNAME    pRes;
    PRESTYPE    pType;
    BOOL    fName;
    PVOID   lpData;

    /* Output contents associated with each resource */
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
    pRes = pType->NameHeadName;
    fName = TRUE;
loop1:
    for ( ; pRes ; pRes = pRes->pnext) {
        if (pResSave != NULL && pRes != pResSave)
        continue;
        pResSave = NULL;
#if DBG
        if (pType->Type->discriminant == IS_STRING) {
            DPrintf((DebugBuf, "    "));
            DPrintfu((pType->Type->szStr));
            DPrintfn((DebugBuf, "."));
        }
        else {
            DPrintf(( DebugBuf, "    %d.", pType->Type->uu.Ordinal ));
        }
        if (pRes->Name->discriminant == IS_STRING) {
            DPrintfu((pRes->Name->szStr));
        }
        else {
            DPrintfn(( DebugBuf, "%d", pRes->Name->uu.Ordinal ));
        }
#endif
        lpData = (PVOID)pRes->OffsetToDataEntry;
        DPrintfn((DebugBuf, "\n"));

        /* if there is room in the current section, write it there */
        size = pRes->DataSize;
        if (cbLeft != 0 && cbLeft >= size) {   /* resource fits?   */
        DPrintf((DebugBuf,
            "Writing resource: %#04lx bytes @%#08lx\n",
            size, FilePos(outfh)));
        MuWrite(outfh, lpData, size);
        /* pad resource     */
        cbT = REMAINDER(size, CBLONG);
#ifdef DBG
        if (cbT != 0)
            DPrintf((DebugBuf,
                "Writing small pad: %#04lx bytes @%#08lx\n",
                cbT, FilePos(outfh)));
#endif
        MuWrite(outfh, pchPad, cbT);    /* dword    */
        cbB += size + cbT;
        cbLeft -= size + cbT;       /* less left    */
        continue;       /* next resource    */
        }
        else {          /* will fill up section    */
        DPrintf((DebugBuf, "Done with .rsrc section\n"));
        goto write_pad;
        }
    }
    if (fName) {
        fName = FALSE;
        pRes = pType->NameHeadID;
        goto loop1;
    }
    pType = pType->pnext;
    }

    pType = pUpdate->ResTypeHeadID;
    while (pType) {
    pRes = pType->NameHeadName;
    fName = TRUE;
loop2:
    for ( ; pRes ; pRes = pRes->pnext) {
        if (pResSave != NULL && pRes != pResSave)
        continue;
        pResSave = NULL;
#if DBG
        if (pType->Type->discriminant == IS_STRING) {
            DPrintf((DebugBuf, "    "));
            DPrintfu((pType->Type->szStr));
            DPrintfn((DebugBuf, "."));
        }
        else {
            DPrintf(( DebugBuf, "    %d.", pType->Type->uu.Ordinal ));
        }
        if (pRes->Name->discriminant == IS_STRING) {
            DPrintfu((pRes->Name->szStr));
        }
        else {
            DPrintfn(( DebugBuf, "%d", pRes->Name->uu.Ordinal ));
        }
#endif
        lpData = (PVOID)pRes->OffsetToDataEntry;
        DPrintfn((DebugBuf, "\n"));

        /* if there is room in the current section, write it there */
        size = pRes->DataSize;
        if (cbLeft != 0 && cbLeft >= size) {   /* resource fits?   */
        DPrintf((DebugBuf,
            "Writing resource: %#04lx bytes @%#08lx\n",
            size, FilePos(outfh)));
        MuWrite(outfh, lpData, size);
        /* pad resource     */
        cbT = REMAINDER(size, CBLONG);
#ifdef DBG
        if (cbT != 0)
            DPrintf((DebugBuf,
                "Writing small pad: %#04lx bytes @%#08lx\n",
                cbT, FilePos(outfh)));
#endif
        MuWrite(outfh, pchPad, cbT);    /* dword    */
        cbB += size + cbT;
        cbLeft -= size + cbT;       /* less left    */
        continue;       /* next resource    */
        }
        else {          /* will fill up section    */
        DPrintf((DebugBuf, "Done with .rsrc section\n"));
        goto write_pad;
        }
    }
    if (fName) {
        fName = FALSE;
        pRes = pType->NameHeadID;
        goto loop2;
    }
    pType = pType->pnext;
    }
    pRes = NULL;

write_pad:
    /* pad to alignment boundary */
    cbB = FilePos(outfh);
    cbT = ROUNDUP(cbB, align);
    cbLeft = cbT - cbB;
    DPrintf((DebugBuf, "Writing file sector pad: %#04lx bytes @%#08lx\n",
         cbLeft, FilePos(outfh)));
    if (cbLeft != 0) {
    while (cbLeft >= cbPadMax) {
        MuWrite(outfh, pchPad, cbPadMax);
        cbLeft -= cbPadMax;
    }
    MuWrite(outfh, pchPad, cbLeft);
    }
    return pRes;
}



#if DBG

void
wchprintf(WCHAR*wch)
{
    UNICODE_STRING ustring;
    STRING  string;
    char    buf[257];
    ustring.MaximumLength = ustring.Length = wcslen(wch) * sizeof(WCHAR);
    ustring.Buffer = wch;

    string.Length = 0;
    string.MaximumLength = 256;
    string.Buffer = buf;

    RtlUnicodeStringToAnsiString(&string, &ustring, FALSE);
    buf[string.Length] = '\000';
    DPrintfn((DebugBuf, "%s", buf));
}
#endif

//
// adjust debug directory table
//

/*  */
LONG
PatchDebug(int  inpfh,
      int   outfh,
      PIMAGE_SECTION_HEADER pDebugOld,
      PIMAGE_SECTION_HEADER pDebugNew,
      PIMAGE_SECTION_HEADER pDebugDirOld,
      PIMAGE_SECTION_HEADER pDebugDirNew,
      PIMAGE_NT_HEADERS pOld,
      PIMAGE_NT_HEADERS pNew,
          ULONG ibMaxDbgOffsetOld,
      PULONG pPointerToRawData)
{
    PIMAGE_DEBUG_DIRECTORY pDbgLast;
    PIMAGE_DEBUG_DIRECTORY pDbgSave;
    PIMAGE_DEBUG_DIRECTORY pDbg;
    ULONG   ib;
    ULONG   adjust;
    ULONG   ibNew;

    if (pDebugDirOld == NULL ||
    pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size==0)
    return NO_ERROR;

    pDbgSave = pDbg = (PIMAGE_DEBUG_DIRECTORY)RtlAllocateHeap(
            RtlProcessHeap(), MAKE_TAG( RES_TAG ),
        pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    if (pDbg == NULL)
    return ERROR_NOT_ENOUGH_MEMORY;

    if (pDebugOld) {
    DPrintf((DebugBuf, "Patching dbg directory: @%#08lx ==> @%#08lx\n",
         pDebugOld->PointerToRawData, pDebugNew->PointerToRawData));
    }
    else
        adjust = *pPointerToRawData;    /* passed in EOF of new file */

    ib = pOld->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress - pDebugDirOld->VirtualAddress;
    MuMoveFilePos(inpfh, pDebugDirOld->PointerToRawData+ib);
    pDbgLast = pDbg + (pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size)/sizeof(IMAGE_DEBUG_DIRECTORY);
    MuRead(inpfh, (PUCHAR)pDbg, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);

    if (pDebugOld == NULL) {
    /* find 1st entry - use for offset */
        DPrintf((DebugBuf, "Adjust: %#08lx\n",adjust));
    for (ibNew=0xffffffff ; pDbg<pDbgLast ; pDbg++)
            if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld &&
                pDbg->PointerToRawData < ibNew
               )
                ibNew = pDbg->PointerToRawData;

    if (ibNew != 0xffffffff)
        *pPointerToRawData = ibNew;
    else
        *pPointerToRawData = _llseek(inpfh, 0L, SEEK_END);
    for (pDbg=pDbgSave ; pDbg<pDbgLast ; pDbg++) {
        DPrintf((DebugBuf, "Old debug file offset: %#08lx\n",
             pDbg->PointerToRawData));
            if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld)
                pDbg->PointerToRawData += adjust - ibNew;
        DPrintf((DebugBuf, "New debug file offset: %#08lx\n",
             pDbg->PointerToRawData));
    }
    }
    else {
    for ( ; pDbg<pDbgLast ; pDbg++) {
        DPrintf((DebugBuf, "Old debug addr: %#08lx, file offset: %#08lx\n",
             pDbg->AddressOfRawData,
             pDbg->PointerToRawData));
        pDbg->AddressOfRawData += pDebugNew->VirtualAddress -
                pDebugOld->VirtualAddress;
        pDbg->PointerToRawData += pDebugNew->PointerToRawData -
                pDebugOld->PointerToRawData;
        DPrintf((DebugBuf, "New debug addr: %#08lx, file offset: %#08lx\n",
             pDbg->AddressOfRawData,
             pDbg->PointerToRawData));
    }
    }

    MuMoveFilePos(outfh, pDebugDirNew->PointerToRawData+ib);
    MuWrite(outfh, (PUCHAR)pDbgSave, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    RtlFreeHeap(RtlProcessHeap(), 0, pDbgSave);

    return NO_ERROR;
}

//
// This routine patches various RVAs in the file to compensate
// for extra section table entries.
//


LONG
PatchRVAs(int   inpfh,
      int   outfh,
      PIMAGE_SECTION_HEADER po32,
      ULONG pagedelta,
      PIMAGE_NT_HEADERS pNew,
      ULONG OldSize)
{
    ULONG hdrdelta;
    ULONG offset, rvaiat, offiat, iat;
    IMAGE_EXPORT_DIRECTORY Exp;
    IMAGE_IMPORT_DESCRIPTOR Imp;
    ULONG i, cmod, cimp;

    hdrdelta = pNew->OptionalHeader.SizeOfHeaders - OldSize;
    if (hdrdelta == 0) {
    return NO_ERROR;
    }

    //
    // Patch export section RVAs
    //

    DPrintf((DebugBuf, "Export offset=%08lx, hdrsize=%08lx\n",
         pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress,
         pNew->OptionalHeader.SizeOfHeaders));
    if ((offset = pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) == 0)
    {
    DPrintf((DebugBuf, "No exports to patch\n"));
    }
    else if (offset >= pNew->OptionalHeader.SizeOfHeaders)
    {
    DPrintf((DebugBuf, "No exports in header to patch\n"));
    }
    else
    {
    MuMoveFilePos(inpfh, offset - hdrdelta);
    MuRead(inpfh, (PUCHAR) &Exp, sizeof(Exp));
    Exp.Name += hdrdelta;
    (ULONG)Exp.AddressOfFunctions += hdrdelta;
    (ULONG)Exp.AddressOfNames += hdrdelta;
    (ULONG)Exp.AddressOfNameOrdinals += hdrdelta;
    MuMoveFilePos(outfh, offset);
    MuWrite(outfh, (PUCHAR) &Exp, sizeof(Exp));
    }

    //
    // Patch import section RVAs
    //

    DPrintf((DebugBuf, "Import offset=%08lx, hdrsize=%08lx\n",
         pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress,
         pNew->OptionalHeader.SizeOfHeaders));
    if ((offset = pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) == 0)
    {
    DPrintf((DebugBuf, "No imports to patch\n"));
    }
    else if (offset >= pNew->OptionalHeader.SizeOfHeaders)
    {
    DPrintf((DebugBuf, "No imports in header to patch\n"));
    }
    else
    {
    for (cimp = cmod = 0; ; cmod++)
    {
        MuMoveFilePos(inpfh, offset + cmod * sizeof(Imp) - hdrdelta);
        MuRead(inpfh, (PUCHAR) &Imp, sizeof(Imp));
        if (Imp.FirstThunk == 0)
        {
        break;
        }
        Imp.Name += hdrdelta;
        MuMoveFilePos(outfh, offset + cmod * sizeof(Imp));
        MuWrite(outfh, (PUCHAR) &Imp, sizeof(Imp));

        rvaiat = (ULONG)Imp.FirstThunk;
        DPrintf((DebugBuf, "RVAIAT = %#08lx\n", (ULONG)rvaiat));
        for (i = 0; i < pNew->FileHeader.NumberOfSections; i++) {
        if (rvaiat >= po32[i].VirtualAddress &&
            rvaiat < po32[i].VirtualAddress + po32[i].SizeOfRawData) {

            offiat = rvaiat - po32[i].VirtualAddress + po32[i].PointerToRawData;
            goto found;
        }
        }
        DPrintf((DebugBuf, "IAT not found\n"));
        return ERROR_INVALID_DATA;
found:
        DPrintf((DebugBuf, "IAT offset: @%#08lx ==> @%#08lx\n",
             offiat - pagedelta,
             offiat));
        MuMoveFilePos(inpfh, offiat - pagedelta);
        MuMoveFilePos(outfh, offiat);
        for (;;) {
        MuRead(inpfh, (PUCHAR) &iat, sizeof(iat));
        if (iat == 0) {
            break;
        }
        if ((iat & IMAGE_ORDINAL_FLAG) == 0) {  // if import by name
            DPrintf((DebugBuf, "Patching IAT: %08lx + %04lx ==> %08lx\n",
                 iat,
                 hdrdelta,
                 iat + hdrdelta));
            iat += hdrdelta;
            cimp++;
        }
        MuWrite(outfh, (PUCHAR) &iat, sizeof(iat)); // Avoids seeking
        }
    }
    DPrintf((DebugBuf, "%u import module name RVAs patched\n", cmod));
    DPrintf((DebugBuf, "%u IAT name RVAs patched\n", cimp));
    if (cmod == 0)
    {
        DPrintf((DebugBuf, "No import modules to patch\n"));
    }
    if (cimp == 0)
    {
        DPrintf((DebugBuf, "No import name RVAs to patch\n"));
    }
    }

    return NO_ERROR;

}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  RecalcChecksum(CHAR *pszFile)                                            */
/*                                                                           */
/*  Generates a correct checksum for pszFile. Returns TRUE for success       */
/*                                                                           */
/*---------------------------------------------------------------------------*/

BOOL RecalcChecksum(CHAR *pszFile)
{
    BOOL fSuccess = FALSE;

    HANDLE hFile = CreateFile(pszFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile)
    {
        BY_HANDLE_FILE_INFORMATION fi;

        // We only do this for files smaller than 2^32-1 bytes
        if (GetFileInformationByHandle(hFile, &fi) && (0 == fi.nFileSizeHigh))
        {
            HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
            if (hMapping)
            {
                LPVOID pvView = MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, 0);

                if (pvView)
                {
                    DWORD dwCheckCurrent;
                    DWORD dwCheckNew;
                    PIMAGE_NT_HEADERS pih = CheckSumMappedFile(pvView, fi.nFileSizeLow, &dwCheckCurrent, &dwCheckNew);

                    if (pih)
                    {
                        pih->OptionalHeader.CheckSum = dwCheckNew;
                        fSuccess = TRUE;
                    }

                    UnmapViewOfFile(pvView);
                }

                CloseHandle(hMapping);
            }
        }

        CloseHandle(hFile);
    }

    return fSuccess;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteResFile() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/


LONG
WriteResFile(
    HANDLE  hUpdate,
    CHAR    *pDstname)
{
    HANDLE  inh;
    HANDLE  outh;
    INT     inpfh;
    INT     outfh;
    ULONG   onewexe;
    IMAGE_DOS_HEADER    oldexe;
    PUPDATEDATA pUpdate;
    INT     rc;
    CHAR    *pFilename;

    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    pFilename = (CHAR*)GlobalLock(pUpdate->hFileName);

    /* open the original exe file */
    inh = CreateFile(pFilename, GENERIC_READ, 0 /*exclusive access*/, NULL /* security attr */,  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    GlobalUnlock(pUpdate->hFileName);
    if ( inh == INVALID_HANDLE_VALUE )   {
        GlobalUnlock(hUpdate);
        return ERROR_OPEN_FAILED;
    }
    inpfh = (INT)HandleToLong(inh); 

    /* read the old format EXE header */
    rc = _lread(inpfh, (char*)&oldexe, sizeof(oldexe));
    if (rc != sizeof(oldexe)) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_READ_FAULT;
    }

    /* make sure its really an EXE file */
    if (oldexe.e_magic != IMAGE_DOS_SIGNATURE) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_INVALID_EXE_SIGNATURE;
    }

    /* make sure theres a new EXE header floating around somewhere */
    if (!(onewexe = oldexe.e_lfanew)) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_BAD_EXE_FORMAT;
    }

    outh = CreateFile(pDstname, GENERIC_READ|GENERIC_WRITE, 0 /*exclusive access*/, NULL /* security attr */, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (outh != INVALID_HANDLE_VALUE ) {
        outfh = (INT)HandleToLong(outh);
        rc = PEWriteResFile(inpfh, outfh, onewexe, pUpdate);
        _lclose(outfh);
    }
    _lclose(inpfh);

    /* Fix up the checksum for the destination file */
    RecalcChecksum(pDstname);

    GlobalUnlock(hUpdate);
    return rc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\updres.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    updres.h

Author:

    Floyd A Rogers 2/7/92

Revision History:
        Floyd Rogers
        Created
--*/

#define	DEFAULT_CODEPAGE	1252
#define	MAJOR_RESOURCE_VERSION	4
#define	MINOR_RESOURCE_VERSION	0

#define BUTTONCODE	0x80
#define EDITCODE	0x81
#define STATICCODE	0x82
#define LISTBOXCODE	0x83
#define SCROLLBARCODE	0x84
#define COMBOBOXCODE	0x85

#define	SEEK_SET	0
#define	SEEK_CUR	1
#define	SEEK_END	2
#define	MAXSTR		(256+1)

//
// An ID_WORD indicates the following WORD is an ordinal rather
// than a string
//

#define ID_WORD 0xffff

//typedef	WCHAR	*PWCHAR;



    /*
     * All TYPE and NAME's that are STRING's instead of ORDINAL values
     * are represented by one of these structures which links into the
     * table from the StringHead link of the UPDATEDATA structure
     */
   
typedef struct MY_STRING {
	ULONG discriminant;       // long to make the rest of the struct aligned
	union u {
		struct {
		  struct MY_STRING *pnext;
		  ULONG  ulOffsetToString;
		  USHORT cbD;
		  USHORT cb;
		  WCHAR  *sz;
		} ss;
		WORD     Ordinal;
	} uu;
} SDATA, *PSDATA, **PPSDATA;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz



    // Resource Name Information
typedef struct _RESNAME {
        struct _RESNAME *pnext;	    // The first three fields should be the
        PSDATA    Name;		        // same in both res structures
        ULONG     OffsetToData;

        PSDATA	  Type;
	    ULONG	  SectionNumber;
        ULONG	  DataSize;
        ULONG_PTR OffsetToDataEntry;
        USHORT    ResourceNumber;
        USHORT    NumberOfLanguages;
        WORD	  LanguageId;
} RESNAME, *PRESNAME, **PPRESNAME;

    // Resource Type Information    
typedef struct _RESTYPE {
        struct _RESTYPE *pnext;	    // The first three fields should be the
        PSDATA Type;		        // same in both res structures
        ULONG   OffsetToData;

        struct _RESNAME *NameHeadID;
        struct _RESNAME *NameHeadName;
        ULONG  NumberOfNamesID;
        ULONG  NumberOfNamesName;
} RESTYPE, *PRESTYPE, **PPRESTYPE;



    // Main Header for the linked lists of resources??
typedef struct _UPDATEDATA {
        ULONG	cbStringTable;
        PSDATA	StringHead;
        PRESNAME	ResHead;
        PRESTYPE	ResTypeHeadID;
        PRESTYPE	ResTypeHeadName;
        LONG	Status;
        HANDLE	hFileName;
} UPDATEDATA, *PUPDATEDATA;

//
// Round up a byte count to a power of 2:
//
#define ROUNDUP(cbin, align) (((cbin) + (align) - 1) & ~((align) - 1))

//
// Return the remainder, given a byte count and a power of 2:
//
#define REMAINDER(cbin,align) (((align)-((cbin)&((align)-1)))&((align)-1))

#define CBLONG		(sizeof(LONG))
#define BUFSIZE		(4L * 1024L)

/* functions for adding/deleting resources to update list */

LONG
AddResource(
    IN PSDATA Type,
    IN PSDATA Name,
    IN WORD Language,
    IN PUPDATEDATA pupd,
    IN PVOID lpData,
    IN ULONG  cb
    );

PSDATA
AddStringOrID(
    LPCWSTR     lp,
    PUPDATEDATA pupd
    );

BOOL
InsertResourceIntoLangList(
    PUPDATEDATA pUpd,
    PSDATA Type,
    PSDATA Name,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fName,
    INT cb,
    PVOID lpData
    );

BOOL
DeleteResourceFromList(
    PUPDATEDATA pUpd,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fType,
    INT	fName
    );

/* Prototypes for Enumeration done in BeginUpdateResource */

BOOL _stdcall
EnumTypesFunc(
    HANDLE hModule,
    LPCSTR lpType,
    LONG_PTR lParam
    );

BOOL _stdcall
EnumNamesFunc(
    HANDLE hModule,
    LPCSTR lpName,
    LPCSTR lpType,
    LONG_PTR lParam
    );

BOOL _stdcall
EnumLangsFunc(
    HANDLE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD languages,
    LONG_PTR lParam
    );

/* Prototypes for genral worker functions in updres.c */

LONG
WriteResFile(
    IN HANDLE	hUpdate,
    IN TCHAR	*pDstname
    );

VOID
FreeData(
    PUPDATEDATA pUpd
    );

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME pResSave
    );

LONG
PatchRVAs(
    int	inpfh,
    int	outfh,
    PIMAGE_SECTION_HEADER po32,
    ULONG pagedelta,
    PIMAGE_NT_HEADERS pNew,
    ULONG OldSize);

LONG
PatchDebug(
    int	inpfh,
    int	outfh,
    PIMAGE_SECTION_HEADER po32DebugOld,
    PIMAGE_SECTION_HEADER po32DebugNew,
    PIMAGE_SECTION_HEADER po32DebugDirOld,
    PIMAGE_SECTION_HEADER po32DebugDirNew,
    PIMAGE_NT_HEADERS pOld,
    PIMAGE_NT_HEADERS pNew,
    ULONG ibMaxDbgOffsetOld,
    PULONG pPointerToRawData);

HANDLE
LocalBeginUpdateResource(
                            LPCSTR pwch,
                            BOOL bDeleteExistingResources
                        );

BOOL
LocalUpdateResource(
    HANDLE	    hUpdate,
    LPCTSTR     lpType,
    LPCTSTR     lpName,
    WORD	    language,
    LPVOID	    lpData,
    ULONG	    cb
    );

BOOL
LocalEndUpdateResource(
                    HANDLE	hUpdate,
                    BOOL	fDiscard
                 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\pagefcns.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* PAGEFCNS.H -                                                            *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* DEFINES                                                                 *
//***************************************************************************
#define IDD_BACK            0x3023      // From commctrl defines...
#define IDD_NEXT            0x3024      // From commctrl defines...

#define MAX_SECLEN          80
#define MAX_TITLE           128         // Max size of Title
#define MAX_PROMPT          512         // Max size of prompt
#define MAX_CUSTOM          512         // Max size of Custom command
#define MAX_FINISHMSG       512         // Max size of Finished message
#define MAX_VERINFO         2048        // max size of version info

//***************************************************************************
//* Defines                                                                 *
//***************************************************************************
#define achExtEXE   ".EXE"
#define achExtBAT   ".BAT"
#define achExtCOM   ".COM"
#define achExtINF   ".INF"
#define achQUANTUM  "QUANTUM"
#define achMSZIP    "MSZIP"
#define achLZX      "LZX"
#define achNONE     "NONE"

//***************************************************************************
//* TYPE DEFINITIONS                                                        *
//***************************************************************************

// This structure holds the list of files that are in the List View
// Control.

typedef struct _MyItem {
    LPSTR  aszCols[2];     // Filename and Path
    BOOL   fWroteOut;
    struct _MyItem *Next;
} MYITEM, *PMYITEM;


// This structure (generally) holds all the information that will be
// saved in the CABPack Directive File.
typedef struct _CDF {
    BOOL     fSave;
    BOOL     fPrompt;
    BOOL     fLicense;
    BOOL     fFinishMsg;
    BOOL     fUseLFN;
    CHAR    achFilename[MAX_PATH];
    CHAR    achTitle[MAX_TITLE];
    CHAR    achPrompt[MAX_PROMPT];
    CHAR    achLicense[MAX_PATH];
    CHAR    achTarget[MAX_PATH];
    CHAR    achFinishMsg[MAX_FINISHMSG];
    CHAR    achTargetPath[MAX_PATH];
    CHAR    achTargetBase[MAX_PATH];
    CHAR    achDDF[MAX_PATH];
    CHAR    achCABPath[MAX_PATH];
    CHAR    achINF[MAX_PATH];
    CHAR    achRPT[MAX_PATH];
    CHAR    achPostInstCmd[MAX_CUSTOM];
    CHAR    achInstallCmd[MAX_PATH];
    CHAR    achOrigiPostInstCmd[MAX_CUSTOM];
    CHAR    achOrigiInstallCmd[MAX_PATH];
    CHAR    achStrings[MAX_SECLEN];
    CHAR    achLocale[MAX_SECLEN];
    CHAR    achSourceFile[MAX_SECLEN];
    CHAR    achVerInfo[MAX_SECLEN];
    CHAR    szCabLabel[MAX_PATH];
    CHAR    szAdmQCmd[MAX_PATH];    
    CHAR    szOrigiAdmQCmd[MAX_PATH];
    CHAR    szUsrQCmd[MAX_PATH];
    CHAR    szOrigiUsrQCmd[MAX_PATH];
    LPSTR   lpszCookie;
    LPCSTR  szCompressionType;
    UINT    uCompressionLevel;
    LPSTR   szCAB;
    UINT     uPackPurpose;
    UINT     uShowWindow;
    UINT     uExtractOpt;
    DWORD    dwPlatform;
    DWORD    dwReboot;
    DWORD    cbFileListNum;
    DWORD    cbPackInstSpace;
    PTARGETVERINFO  pVerInfo;
    PMYITEM  pTop;
} CDF, *PCDF;



//***************************************************************************
//* FUNCTION PROTOTYPES                                                     *
//***************************************************************************
BOOL WelcomeInit( HWND, BOOL );
BOOL WelcomeCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL WelcomeOK( HWND, BOOL, UINT *, BOOL * );

BOOL ModifyInit( HWND, BOOL );
BOOL ModifyOK( HWND, BOOL, UINT *, BOOL * );

BOOL TitleInit( HWND, BOOL );
BOOL TitleOK( HWND, BOOL, UINT *, BOOL * );

BOOL PromptInit( HWND, BOOL );
BOOL PromptCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL PromptOK( HWND, BOOL, UINT *, BOOL * );

BOOL LicenseTxtInit( HWND, BOOL );
BOOL LicenseTxtCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL LicenseTxtOK( HWND, BOOL, UINT *, BOOL * );

BOOL FilesInit( HWND, BOOL );
BOOL FilesCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL FilesNotify( HWND, WPARAM, LPARAM );
BOOL FilesOK( HWND, BOOL, UINT *, BOOL * );

BOOL CommandInit( HWND, BOOL );
BOOL CommandCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL CommandOK( HWND, BOOL, UINT *, BOOL * );

BOOL ShowWindowInit( HWND, BOOL );
BOOL ShowWindowOK( HWND, BOOL, UINT *, BOOL * );

BOOL FinishMsgInit( HWND, BOOL );
BOOL FinishMsgCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL FinishMsgOK( HWND, BOOL, UINT *, BOOL * );

BOOL TargetInit( HWND, BOOL );
BOOL TargetCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL TargetOK( HWND, BOOL, UINT *, BOOL * );

BOOL TargetCABInit( HWND, BOOL );
BOOL TargetCABCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL TargetCABOK( HWND, BOOL, UINT *, BOOL * );

BOOL SaveInit( HWND, BOOL );
BOOL SaveCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL SaveOK( HWND, BOOL, UINT *, BOOL * );

BOOL CreateInit( HWND, BOOL );
BOOL CreateOK( HWND, BOOL, UINT *, BOOL * );

BOOL PackPurposeInit( HWND, BOOL );
BOOL PackPurposeOK( HWND, BOOL, UINT *, BOOL * );
BOOL PackPurposeCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,BOOL *pfKeepHistory );

BOOL CabLabelInit( HWND, BOOL );
BOOL CabLabelOK( HWND, BOOL, UINT *, BOOL * );
BOOL CabLabelCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,BOOL *pfKeepHistory );

BOOL RebootInit( HWND, BOOL );
BOOL RebootOK( HWND, BOOL, UINT *, BOOL * );
BOOL RebootCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,BOOL *pfKeepHistory );

void RemoveBlanks( LPSTR lpData );
BOOL SetCurrSelect( HWND hDlg, UINT ctlId, LPSTR lpSelect );
BOOL CheckAdvBit( LPSTR szOrigiCommand );
void MyProcessLFNCmd( LPSTR szOrigiCmd, LPSTR szOutCmd );
void SysErrorMsg( HWND );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\pagefcns.c ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* PAGEFCNS.C -                                                            *
//*                                                                         *
//***************************************************************************
// MODIFYORCREATE page should have a button to 'quick display' CDF file

//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include "pch.h"
#pragma hdrstop
#include "cabpack.h"
#include "sdsutils.h"

void SetFontForControl(HWND hwnd, UINT uiID);
//***************************************************************************
//* GLOBAL VARIABLES                                                        *
//***************************************************************************
CDF   g_CDF = { 0 };                            // Generally, these are settings that
                                        // will be stored in the CABPack
                                        // Directive File.
BOOL  g_fFinish = FALSE;
char  g_szInitialDir[MAX_PATH];
extern HFONT g_hFont;
extern PSTR pResvSizes[];
extern HINSTANCE    g_hInst; // Pointer to Instance

//###########################################################################
//#                      ####################################################
//#  WELCOME PAGE        ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       WelcomeInit                                                 *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL WelcomeInit( HWND hDlg, BOOL fFirstInit )
{
    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
    SetFontForControl(hDlg, IDC_EDIT_OPEN_CDF);

    if ( fFirstInit )
    {
        if ( lstrlen( g_CDF.achFilename ) > 0 )  {
            CheckDlgButton( hDlg, IDC_RAD_CREATE_NEW,    FALSE );
            CheckDlgButton( hDlg, IDC_RAD_OPEN_EXISTING, TRUE );
            SetDlgItemText( hDlg, IDC_EDIT_OPEN_CDF, g_CDF.achFilename );
        } else  {
            CheckDlgButton( hDlg, IDC_RAD_CREATE_NEW,    TRUE );
            CheckDlgButton( hDlg, IDC_RAD_OPEN_EXISTING, FALSE );
            EnableDlgItem( hDlg, IDC_EDIT_OPEN_CDF, FALSE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, FALSE );
        }
    }

    // Initialize the CABPack Directive File information.

    g_CDF.fSave           = TRUE;
    g_CDF.uShowWindow     = bResShowDefault;
    g_CDF.uPackPurpose    = IDC_CMD_RUNCMD;
    g_CDF.dwReboot        |= REBOOT_YES;
    g_CDF.szCompressionType = achMSZIP;
    g_CDF.uCompressionLevel = 7;

    lstrcpy( g_CDF.szCabLabel, CAB_DEFSETUPMEDIA );
    
    lstrcpy( g_CDF.achSourceFile, KEY_FILELIST );
//    g_CDF.wSortOrder      = _SORT_DESCENDING | _SORT_FILENAME;

    // prepare for the GetOpenFileName init dir
    GetCurrentDirectory( sizeof(g_szInitialDir), g_szInitialDir );

    DeleteAllItems();

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       WelcomeCmd                                                  *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL WelcomeCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                 BOOL *pfKeepHistory )
{
    CHAR        achFilename[MAX_PATH] = { '\0' };
    BOOL         fResult;


    switch ( uCtrlID ) {

        case IDC_RAD_OPEN_EXISTING:
            EnableDlgItem( hDlg, IDC_EDIT_OPEN_CDF, TRUE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, TRUE );
            break;


        case IDC_RAD_CREATE_NEW:
            EnableDlgItem( hDlg, IDC_EDIT_OPEN_CDF, FALSE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, FALSE );
            break;


        case IDC_BUT_BROWSE:
            fResult = MyOpen( hDlg, IDS_FILTER_CDF,
                              achFilename, sizeof(achFilename), 0,
                              NULL, NULL, EXT_SED_NODOT );

            if ( fResult )  {
                SetDlgItemText( hDlg, IDC_EDIT_OPEN_CDF, achFilename );
            }

            break;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       WelcomeOK                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL WelcomeOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
                BOOL *pfKeepHistory )
{
    LPSTR szTemp;


    ASSERT( puNextPage );
    ASSERT( pfKeepHistory );
    ASSERT( fForward );                 // Only go forward from this page


    if ( fForward )  {
        if ( IsDlgButtonChecked( hDlg, IDC_RAD_OPEN_EXISTING ) )  {
            GetDlgItemText( hDlg, IDC_EDIT_OPEN_CDF, g_CDF.achFilename,
                            sizeof(g_CDF.achFilename) );

            if ( lstrlen( g_CDF.achFilename ) != 0 )  {
                GetFullPathName( g_CDF.achFilename, sizeof(g_CDF.achFilename),
                                 g_CDF.achFilename, &szTemp );
            }

            if ( ! FileExists( g_CDF.achFilename ) )  {
                DisplayFieldErrorMsg( hDlg, IDC_EDIT_OPEN_CDF,
                                      IDS_ERR_CDF_DOESNT_EXIST );
                return FALSE;
            } else  {
                if ( ! ReadCDF( hDlg ) )  {
                    return FALSE;
                }
                *puNextPage = ORD_PAGE_MODIFY;
            }
        } else  {
            g_CDF.achFilename[0] = '\0';

            *puNextPage = ORD_PAGE_PURPOSE;
        }
    }

    return TRUE;
}




//###########################################################################
//#                      ####################################################
//#  MODIFY PAGE         ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       ModifyInit                                                  *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL ModifyInit( HWND hDlg, BOOL fFirstInit )
{
    CheckDlgButton( hDlg, IDC_RAD_CREATE, TRUE );
    CheckDlgButton( hDlg, IDC_RAD_MODIFY, FALSE );

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       ModifyOK                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL ModifyOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
               BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );
    ASSERT( pfKeepHistory );

    *pfKeepHistory = FALSE;

    if ( fForward ) {
        if ( IsDlgButtonChecked( hDlg, IDC_RAD_CREATE ) )  {
            *puNextPage = ORD_PAGE_CREATE;
        }
    }

    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  TITLE PAGE          ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       TitleInit                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL TitleInit( HWND hDlg, BOOL fFirstInit )
{
    SetFontForControl(hDlg, IDC_EDIT_TITLE);
    SendDlgItemMessage( hDlg, IDC_EDIT_TITLE, EM_LIMITTEXT, MAX_TITLE-2, 0L );
    SetDlgItemText( hDlg, IDC_EDIT_TITLE, g_CDF.achTitle );
    
    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       TitleOK                                                     *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL TitleOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
              BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );
    ASSERT( pfKeepHistory );


    GetDlgItemText( hDlg, IDC_EDIT_TITLE, g_CDF.achTitle,
                    sizeof(g_CDF.achTitle) );

    if ( fForward )  {
        if ( lstrlen( g_CDF.achTitle ) == 0 )  {
            DisplayFieldErrorMsg( hDlg, IDC_EDIT_TITLE, IDS_ERR_NO_TITLE );
            return FALSE;
        }
    }


    return TRUE;
}




//###########################################################################
//#                      ####################################################
//#  PROMPT PAGE         ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       PromptInit                                                  *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL PromptInit( HWND hDlg, BOOL fFirstInit )
{
    SetFontForControl(hDlg, IDC_EDIT_PROMPT);
    SendDlgItemMessage( hDlg, IDC_EDIT_PROMPT, EM_LIMITTEXT, MAX_PROMPT-2, 0L );
    SetDlgItemText( hDlg, IDC_EDIT_PROMPT, g_CDF.achPrompt );


    if ( g_CDF.fPrompt )  {
        CheckDlgButton( hDlg, IDC_RAD_NO_PROMPT,  FALSE );
        CheckDlgButton( hDlg, IDC_RAD_YES_PROMPT, TRUE );
        EnableDlgItem( hDlg, IDC_EDIT_PROMPT, TRUE );
    } else  {
        CheckDlgButton( hDlg, IDC_RAD_NO_PROMPT,  TRUE );
        CheckDlgButton( hDlg, IDC_RAD_YES_PROMPT, FALSE );
        EnableDlgItem( hDlg, IDC_EDIT_PROMPT, FALSE );
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       PromptCmd                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL PromptCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                 BOOL *pfKeepHistory )
{
    switch ( uCtrlID ) {
        case IDC_RAD_YES_PROMPT:
            EnableDlgItem( hDlg, IDC_EDIT_PROMPT, TRUE );
            break;


        case IDC_RAD_NO_PROMPT:
            EnableDlgItem( hDlg, IDC_EDIT_PROMPT, FALSE );
            break;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       PromptOK                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL PromptOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
                BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );


    GetDlgItemText( hDlg, IDC_EDIT_PROMPT, g_CDF.achPrompt,
                    sizeof(g_CDF.achPrompt) );

    if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_PROMPT ) )  {
        g_CDF.fPrompt = TRUE;
    } else  {
        g_CDF.fPrompt = FALSE;
    }

    if ( fForward )  {
        if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_PROMPT ) )  {
            if ( lstrlen( g_CDF.achPrompt ) == 0 )  {
                DisplayFieldErrorMsg( hDlg, IDC_EDIT_PROMPT,
                                      IDS_ERR_NO_PROMPT );
                return FALSE;
            }
        }
    }

    return TRUE;
}




//###########################################################################
//#                      ####################################################
//#  LICENSE PAGE        ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       LicenseTxtInit                                              *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL LicenseTxtInit( HWND hDlg, BOOL fFirstInit )
{
    SetFontForControl(hDlg, IDC_EDIT_LICENSE);
    SetDlgItemText( hDlg, IDC_EDIT_LICENSE, g_CDF.achLicense );

    if ( g_CDF.fLicense )  {
        CheckDlgButton( hDlg, IDC_RAD_NO_LICENSE,  FALSE );
        CheckDlgButton( hDlg, IDC_RAD_YES_LICENSE, TRUE );
        EnableDlgItem( hDlg, IDC_EDIT_LICENSE, TRUE );
        EnableDlgItem( hDlg, IDC_BUT_BROWSE, TRUE );
    } else  {
        CheckDlgButton( hDlg, IDC_RAD_NO_LICENSE,  TRUE );
        CheckDlgButton( hDlg, IDC_RAD_YES_LICENSE, FALSE );
        EnableDlgItem( hDlg, IDC_EDIT_LICENSE, FALSE );
        EnableDlgItem( hDlg, IDC_BUT_BROWSE, FALSE );
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       LicenseTxtCmd                                               *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL LicenseTxtCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                    BOOL *pfKeepHistory )
{
    CHAR        achFilename[MAX_PATH] = { '\0' };
    BOOL         fResult;


    switch ( uCtrlID ) {

        case IDC_RAD_YES_LICENSE:
            EnableDlgItem( hDlg, IDC_EDIT_LICENSE, TRUE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, TRUE );
            break;


        case IDC_RAD_NO_LICENSE:
            EnableDlgItem( hDlg, IDC_EDIT_LICENSE, FALSE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, FALSE );
            break;


        case IDC_BUT_BROWSE:
            fResult = MyOpen( hDlg, IDS_FILTER_TXT,
                              achFilename, sizeof(achFilename), 0,
                              NULL, NULL, EXT_TXT_NODOT );

            if ( fResult )  {
                SetDlgItemText( hDlg, IDC_EDIT_LICENSE, achFilename );
            }

            break;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       LicenseTxtOK                                                *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL LicenseTxtOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
                   BOOL *pfKeepHistory )
{
    LPSTR szTemp;


    ASSERT( puNextPage );


    GetDlgItemText( hDlg, IDC_EDIT_LICENSE, g_CDF.achLicense,
                    sizeof(g_CDF.achLicense) );

    if ( lstrlen( g_CDF.achLicense ) != 0 )  {
        GetFullPathName( g_CDF.achLicense, sizeof(g_CDF.achLicense),
                         g_CDF.achLicense, &szTemp );
    }

    if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_LICENSE ) )  {
        g_CDF.fLicense = TRUE;
    } else  {
        g_CDF.fLicense = FALSE;
    }

    if ( fForward )  {
        if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_LICENSE ) )  {
            if ( lstrlen( g_CDF.achLicense ) == 0 )  {
                DisplayFieldErrorMsg( hDlg, IDC_EDIT_LICENSE,
                                      IDS_ERR_NO_LICENSE );
                return FALSE;
            }

            if ( ! FileExists( g_CDF.achLicense ) )  {
                DisplayFieldErrorMsg( hDlg, IDC_EDIT_LICENSE,
                                      IDS_ERR_LICENSE_NOT_FOUND );
                return FALSE;
            }
        }
    }

    return TRUE;
}




//###########################################################################
//#                      ####################################################
//#  FILES PAGE          ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       FilesInit                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL FilesInit( HWND hDlg, BOOL fFirstInit )
{
    LV_COLUMN lvc;
    RECT      Rect;
    PMYITEM   pMyItem;
    LV_ITEM   lvi;
    CHAR     achTemp[MAX_STRING];

    // Every time we enter this page, we clean out the list view
    // and add back all the items from our internal list.  This is
    // done because the list of items can change on other pages (like
    // if the user backs up to the first page, then loads another
    // CDF file).

    ListView_DeleteAllItems( GetDlgItem( hDlg, IDC_LV_CAB_FILES ) );

    lvi.mask      = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvi.state     = 0;
    lvi.stateMask = 0;
    lvi.pszText   = LPSTR_TEXTCALLBACK;
    lvi.iItem     = 0;
    lvi.iSubItem  = 0;

    pMyItem = GetFirstItem();

    while ( ! LastItem( pMyItem ) )  {
        lvi.lParam = (LPARAM) pMyItem;
        ListView_InsertItem( GetDlgItem( hDlg, IDC_LV_CAB_FILES ), &lvi );
        lvi.iItem += 1;
        pMyItem = GetNextItem( pMyItem );
    }

    if ( fFirstInit )  {

        // Setup the column headers

        GetWindowRect( GetDlgItem( hDlg, IDC_LV_CAB_FILES ), &Rect );

        lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
        lvc.fmt     = LVCFMT_LEFT;
        lvc.cx      = 80;
        LoadSz( IDS_HEADER_FILENAME, achTemp, sizeof(achTemp) );
        lvc.pszText = (LPSTR) LocalAlloc( LPTR, lstrlen(achTemp) + 1 );
        if ( ! lvc.pszText )  {
            ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
            return FALSE;
        }
        lstrcpy( lvc.pszText, achTemp );

        ListView_InsertColumn( GetDlgItem( hDlg, IDC_LV_CAB_FILES ), 0, &lvc );

        LocalFree( lvc.pszText );

        lvc.cx = Rect.right - Rect.left - 80;
        LoadSz( IDS_HEADER_PATH, achTemp, sizeof(achTemp) );
        lvc.pszText = (LPSTR) LocalAlloc( LPTR, lstrlen(achTemp) + 1 );
        if ( ! lvc.pszText )  {
            ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
            return FALSE;
        }
        lstrcpy( lvc.pszText, achTemp );

        ListView_InsertColumn( GetDlgItem( hDlg, IDC_LV_CAB_FILES ), 1, &lvc );

        LocalFree( lvc.pszText );

        EnableDlgItem( hDlg, IDC_BUT_REMOVE, FALSE );
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       FilesCmd                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL FilesCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
               BOOL *pfKeepHistory )
{
    LPSTR         achFilename;
    INT           FileOffset         = 0;
    INT           FileExtension      = 0;
    BOOL          fResult            = TRUE;
    char          szPath[MAX_PATH];
    ULONG         ulIndex = 0;
    INT           nIndex = 0;
    LV_ITEM       lvi;
    INT           nItem;
    HWND          hwndFiles;
    SYSTEMTIME    st;


    lvi.mask      = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvi.state     = 0;
    lvi.stateMask = 0;
    lvi.pszText   = LPSTR_TEXTCALLBACK;


    hwndFiles = GetDlgItem( hDlg, IDC_LV_CAB_FILES );

    switch ( uCtrlID ) 
    {

        case IDC_BUT_ADD:
            //allocate 8K buff to hold the file name list
            achFilename = LocalAlloc( LPTR, 1024*8 );

            if ( !achFilename ) 
            {
                ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
                return FALSE;
            }
            fResult = MyOpen( hDlg, IDS_FILTER_ALL,
                              achFilename, 1024*8,
                              OFN_ALLOWMULTISELECT,
                              &FileOffset, &FileExtension, 0 );

            // We should do some error checking to make sure all the files
            // could fit in the buffer. Currently the buffer is big enough to
            // hold tons of files.

            if ( fResult )  
            {
                lvi.iItem = ListView_GetItemCount( hwndFiles );

                // Add a trailing backslash to the pathname if it's not
                // the root dir

                lstrcpy( szPath, achFilename );
                lstrcpy( g_szInitialDir, szPath );
                AddPath( szPath, "" );

                // The open file common dialog returns two types of strings
                // when in MULTISELECT mode.  The first one is when
                // multiple files are selected -- it returns:
                // "path \0 file1 \0 file2 \0 ... \0 fileN \0 \0"
                // The second is when only 1 file is selected:
                // "path\filename \0 \0"

                ulIndex = lstrlen( achFilename ) + 1;

                while ( achFilename[ulIndex] != '\0' )
                {
                    if ( ! IsDuplicate( hDlg, IDC_LV_CAB_FILES,
                                        &achFilename[ulIndex], TRUE ) )
                    {
                        lvi.lParam = (LPARAM) AddItem( &achFilename[ulIndex],
                                                       szPath );
                        if ( ! lvi.lParam )  {
                            ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
                            LocalFree( achFilename );
                            return FALSE;
                        }

                        GetSystemTime( &st );
                        //SystemTimeToFileTime( &st, &g_CDF.ftFileListChange );
                        lvi.iItem    += 1;
                        lvi.iSubItem  = 0;
                        ListView_InsertItem( hwndFiles, &lvi );
                    } 
                    else  
                    {
                        ErrorMsg1Param( hDlg, IDS_ERR_DUPE_FILE,
                                        &achFilename[ulIndex] );
                    }

                    ulIndex = ulIndex + lstrlen( &achFilename[ulIndex] ) + 1;
                }

                
                if ( ulIndex == (ULONG)(lstrlen( achFilename ) + 1) )  
                {
                    if ( ! IsDuplicate( hDlg, IDC_LV_CAB_FILES,
                                        &achFilename[FileOffset], TRUE ) )
                    {
                        // should have '\' at the end
                        lstrcpyn( szPath, achFilename, FileOffset+1 );
                        lstrcpy( g_szInitialDir, szPath );
                        lvi.iSubItem = 0;
                        lvi.lParam = (LPARAM) AddItem(
                                                    &achFilename[FileOffset],
                                                    szPath );
                        if ( ! lvi.lParam )  {
                            ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
                            LocalFree( achFilename );
                            return FALSE;
                        }

                        ListView_InsertItem( hwndFiles, &lvi );
                    }
                    else
                    {
                        ErrorMsg1Param( hDlg, IDS_ERR_DUPE_FILE,
                                        &achFilename[FileOffset] );
                    }
                }
            }
            
            LocalFree( achFilename );

            if ( ListView_GetSelectedCount( hwndFiles ) )
            {
                EnableDlgItem( hDlg, IDC_BUT_REMOVE, TRUE );
            } else  {
                EnableDlgItem( hDlg, IDC_BUT_REMOVE, FALSE );
            }

            break;


        case IDC_BUT_REMOVE:

            nItem = ListView_GetNextItem( hwndFiles, -1,
                                          LVNI_ALL | LVNI_SELECTED );

            while ( nItem != -1 )
            {
                lvi.mask     = LVIF_PARAM;
                lvi.iItem    = nItem;
                lvi.iSubItem = 0;

                ListView_GetItem( hwndFiles, &lvi );

                RemoveItem( (PMYITEM) lvi.lParam );

                //GetSystemTime( &st );
                //SystemTimeToFileTime( &st, &g_CDF.ftFileListChange );

                ListView_DeleteItem( hwndFiles, nItem );

                nItem = ListView_GetNextItem( hwndFiles, -1,
                                              LVNI_ALL | LVNI_SELECTED );
            }

            EnableDlgItem( hDlg, IDC_BUT_REMOVE, FALSE );

            break;
    }

    return fResult;
}


//***************************************************************************
//*                                                                         *
//* NAME:       FilesNotify                                                 *
//*                                                                         *
//* SYNOPSIS:   Called when a notification message sent to this page.       *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL FilesNotify( HWND hDlg, WPARAM wParam, LPARAM lParam )
{
    switch ( ((LPNMHDR)lParam)->code )  {

        case LVN_GETDISPINFO:
        {
            LV_DISPINFO *pnmv = (LV_DISPINFO *) lParam;

            if ( pnmv->item.mask & LVIF_TEXT )
            {
                PMYITEM pMyItem = (PMYITEM) (pnmv->item.lParam);

                lstrcpy( pnmv->item.pszText,
                         GetItemSz( pMyItem, pnmv->item.iSubItem ) );
            }

            break;
        }


        case LVN_ITEMCHANGED:
        {
            if ( ListView_GetSelectedCount( GetDlgItem( hDlg,
                                            IDC_LV_CAB_FILES ) ) )
            {
                EnableDlgItem( hDlg, IDC_BUT_REMOVE, TRUE );
            } else  {
                EnableDlgItem( hDlg, IDC_BUT_REMOVE, FALSE );
            }

            break;
        }

/*
        case LVN_COLUMNCLICK :
        {
            NM_LISTVIEW FAR *pnmv = (NM_LISTVIEW FAR *) lParam;

            if ( pnmv->iSubItem == 1 )  {
                if ( g_CDF.wSortOrder & _SORT_FILENAME )  {
                    g_CDF.wSortOrder = g_CDF.wSortOrder ^ _SORT_ORDER;
                } else  {
                    g_CDF.wSortOrder = _SORT_FILENAME | _SORT_DESCENDING;
                }
            } else  {
                if ( g_CDF.wSortOrder & _SORT_PATH )  {
                    g_CDF.wSortOrder = g_CDF.wSortOrder ^ _SORT_ORDER;
                } else  {
                    g_CDF.wSortOrder = _SORT_PATH | _SORT_DESCENDING;
                }
            }

            ListView_SortItems( GetDlgItem( hDlg, IDC_LV_CAB_FILES ),
                                CompareFunc, g_CDF.wSortOrder );

            break;
        }
*/
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       FilesOK                                                     *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL FilesOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
              BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );


    if ( fForward )
    {
        if ( ListView_GetItemCount( GetDlgItem( hDlg, IDC_LV_CAB_FILES ) )
             == 0 )
        {
            ErrorMsg( hDlg, IDS_ERR_NO_FILES );
            return FALSE;
        }

        if ( g_CDF.uPackPurpose == IDC_CMD_EXTRACT )
        {
            *puNextPage = ORD_PAGE_SHOWWINDOW;
        }
        else if ( g_CDF.uPackPurpose == IDC_CMD_CREATECAB )
        {
            *puNextPage = ORD_PAGE_TARGET_CAB;
        }
        else
            ;  // normal page order
    }

    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  PACKPURPOSE PAGE    ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       PackPurposeInit                                             *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL PackPurposeInit( HWND hDlg, BOOL fFirstInit )
{
    CHAR msg[MAX_STRING];
    UINT  idMsg;

    if ( CheckRadioButton( hDlg, IDC_CMD_RUNCMD, IDC_CMD_CREATECAB, g_CDF.uPackPurpose ) )
    {
        if ( g_CDF.uPackPurpose == IDC_CMD_RUNCMD )
            idMsg = IDS_CMD_RUNCMD;
        else if ( g_CDF.uPackPurpose == IDC_CMD_EXTRACT )
            idMsg = IDS_CMD_EXTRACT;
        else
            idMsg = IDS_CMD_CREATECAB;

        LoadSz( idMsg, msg, sizeof(msg) );
        SendMessage( GetDlgItem( hDlg, IDC_CMD_NOTES), WM_SETTEXT, 0, (LPARAM)msg );
    }
    else
        SysErrorMsg( hDlg );

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       PackPurposeCmd                                              *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************

BOOL PackPurposeCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                     BOOL *pfKeepHistory )
{
    CHAR msg[MAX_STRING];
    int   idMsg;

    switch ( uCtrlID )
    {

        case IDC_CMD_RUNCMD:
            if ( IsDlgButtonChecked( hDlg, IDC_CMD_RUNCMD ) )
                idMsg = IDS_CMD_RUNCMD;
            break;

        case IDC_CMD_EXTRACT:
            if ( IsDlgButtonChecked( hDlg, IDC_CMD_EXTRACT ) )
                idMsg = IDS_CMD_EXTRACT;
            break;

        case IDC_CMD_CREATECAB:
            if ( IsDlgButtonChecked( hDlg, IDC_CMD_CREATECAB ) )
                idMsg = IDS_CMD_CREATECAB;
            break;

    }

    LoadSz( idMsg, msg, sizeof(msg) );
    SendMessage( GetDlgItem( hDlg, IDC_CMD_NOTES), WM_SETTEXT, 0, (LPARAM)msg );

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       PackPurposeOK                                               *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL PackPurposeOK( HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );

    if ( IsDlgButtonChecked( hDlg, IDC_CMD_RUNCMD ) )
    {
        g_CDF.uPackPurpose = IDC_CMD_RUNCMD;
    }
    else if ( IsDlgButtonChecked( hDlg, IDC_CMD_EXTRACT ) )
    {
        g_CDF.uPackPurpose = IDC_CMD_EXTRACT;
        // leave long file name
        g_CDF.uExtractOpt |= EXTRACTOPT_LFN_YES;
    }
    else
    {
        g_CDF.uPackPurpose = IDC_CMD_CREATECAB;
        // load Default messagebox title name
        LoadSz( IDS_APPNAME, g_CDF.achTitle, sizeof(g_CDF.achTitle) );
    }

    if ( fForward )
    {
        if ( g_CDF.uPackPurpose == IDC_CMD_CREATECAB )
        {
            g_CDF.uExtractOpt |= CAB_RESVSP6K;
            *puNextPage = ORD_PAGE_FILES;
        }
    }
    else
    {
        if ( MsgBox( hDlg, IDS_LOSE_CHANGES, MB_ICONQUESTION, MB_YESNO ) == IDNO )
        {
            return FALSE;
        }
    }

    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  COMMAND PAGE        ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       CommandInit                                                 *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL CommandInit( HWND hDlg, BOOL fFirstInit )
{
    LRESULT nCurSel;
    PMYITEM pMyItem;
    LPSTR   szFile;
    CHAR   achExt[_MAX_EXT];

    SetFontForControl(hDlg, IDC_CB_INSTALLCMD);
    SetFontForControl(hDlg, IDC_CB_POSTCMD);
    if ( !fFirstInit )
    {
        // cleanup old settings
        SendDlgItemMessage( hDlg, IDC_CB_INSTALLCMD, CB_RESETCONTENT, 0, 0 );
        SendDlgItemMessage( hDlg, IDC_CB_POSTCMD, CB_RESETCONTENT, 0, 0 );

        g_CDF.uExtractOpt &= ~(EXTRACTOPT_ADVDLL);

        // ADD EXE, BAT, COM and INF FILES TO THE COMBBOXes
        pMyItem = GetFirstItem();

        while ( ! LastItem( pMyItem ) )
        {
            szFile = GetItemSz( pMyItem, 0 );
            _splitpath( szFile, NULL, NULL, NULL, achExt );

            if (    lstrcmpi( achExt, achExtEXE ) == 0
                 || lstrcmpi( achExt, achExtBAT ) == 0
                 || lstrcmpi( achExt, achExtCOM ) == 0
                 || lstrcmpi( achExt, achExtINF ) == 0 )
            {
                SendDlgItemMessage( hDlg, IDC_CB_INSTALLCMD, CB_ADDSTRING, 0, (LPARAM)szFile );
                SendDlgItemMessage( hDlg, IDC_CB_POSTCMD, CB_ADDSTRING, 0, (LPARAM)szFile );
            }
            pMyItem = GetNextItem( pMyItem );
        }
        SetCurrSelect( hDlg, IDC_CB_INSTALLCMD, g_CDF.achOrigiInstallCmd );

        SendDlgItemMessage( hDlg, IDC_CB_POSTCMD, CB_ADDSTRING, 0, (LPARAM)achResNone );

        if ( !SetCurrSelect( hDlg, IDC_CB_POSTCMD, g_CDF.achOrigiPostInstCmd ) )
        {
            nCurSel = SendDlgItemMessage( hDlg, IDC_CB_POSTCMD,
                                          CB_FINDSTRINGEXACT, (WPARAM) -1,
                                          (LPARAM)achResNone );

            SendDlgItemMessage( hDlg, IDC_CB_POSTCMD, CB_SETCURSEL, (WPARAM)nCurSel, 0 );
        }
    }
    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CommandOK                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL CommandOK( HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory )
{

    ASSERT( puNextPage );

    SendMessage( GetDlgItem(hDlg, IDC_CB_INSTALLCMD), WM_GETTEXT,
                 (WPARAM)sizeof(g_CDF.achOrigiInstallCmd), (LPARAM)g_CDF.achOrigiInstallCmd );

    RemoveBlanks( g_CDF.achOrigiInstallCmd );

    if ( fForward && !lstrlen(g_CDF.achOrigiInstallCmd) )
    {
        ErrorMsg( hDlg, IDS_ERR_NO_SELECT );
        return FALSE;
    }

    // set EXTRACTOPT_ADVDLL if needed
    if ( !CheckAdvBit( g_CDF.achOrigiInstallCmd ) )
        return FALSE;

    SendMessage( GetDlgItem(hDlg, IDC_CB_POSTCMD), WM_GETTEXT,
                 (WPARAM)sizeof(g_CDF.achOrigiPostInstCmd), (LPARAM)g_CDF.achOrigiPostInstCmd );

    RemoveBlanks( g_CDF.achOrigiPostInstCmd );

    if ( lstrlen( g_CDF.achOrigiPostInstCmd ) && lstrcmpi(g_CDF.achOrigiPostInstCmd, achResNone) )
    {
        if ( !CheckAdvBit( g_CDF.achOrigiPostInstCmd ) )
            return FALSE;
    }
    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  SHOWWINDOW PAGE     ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       ShowWindowInit                                              *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL ShowWindowInit( HWND hDlg, BOOL fFirstInit )
{
    if ( g_CDF.uShowWindow == bResShowDefault )  {
        CheckDlgButton( hDlg, IDC_RAD_DEFAULT,   TRUE );
        CheckDlgButton( hDlg, IDC_RAD_HIDDEN,    FALSE );
        CheckDlgButton( hDlg, IDC_RAD_MINIMIZED, FALSE );
        CheckDlgButton( hDlg, IDC_RAD_MAXIMIZED, FALSE );
    } else if ( g_CDF.uShowWindow == bResShowHidden )  {
        CheckDlgButton( hDlg, IDC_RAD_DEFAULT,   FALSE );
        CheckDlgButton( hDlg, IDC_RAD_HIDDEN,    TRUE );
        CheckDlgButton( hDlg, IDC_RAD_MINIMIZED, FALSE );
        CheckDlgButton( hDlg, IDC_RAD_MAXIMIZED, FALSE );
    } else if ( g_CDF.uShowWindow == bResShowMin )  {
        CheckDlgButton( hDlg, IDC_RAD_DEFAULT,   FALSE );
        CheckDlgButton( hDlg, IDC_RAD_HIDDEN,    FALSE );
        CheckDlgButton( hDlg, IDC_RAD_MINIMIZED, TRUE );
        CheckDlgButton( hDlg, IDC_RAD_MAXIMIZED, FALSE );
    } else  {
        CheckDlgButton( hDlg, IDC_RAD_DEFAULT,   FALSE );
        CheckDlgButton( hDlg, IDC_RAD_HIDDEN,    FALSE );
        CheckDlgButton( hDlg, IDC_RAD_MINIMIZED, FALSE );
        CheckDlgButton( hDlg, IDC_RAD_MAXIMIZED, TRUE );
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       ShowWindowOK                                                *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL ShowWindowOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
                BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );

    if ( IsDlgButtonChecked( hDlg, IDC_RAD_DEFAULT ) )  {
        g_CDF.uShowWindow = bResShowDefault;
    } else if ( IsDlgButtonChecked( hDlg, IDC_RAD_HIDDEN ) )  {
        g_CDF.uShowWindow = bResShowHidden;
    } else if ( IsDlgButtonChecked( hDlg, IDC_RAD_MINIMIZED ) )  {
        g_CDF.uShowWindow = bResShowMin;
    } else {
        g_CDF.uShowWindow = bResShowMax;
    }

    return TRUE;
}




//###########################################################################
//#                      ####################################################
//#  FINISHMSG PAGE      ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       FinishMsgInit                                               *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL FinishMsgInit( HWND hDlg, BOOL fFirstInit )
{
    SetFontForControl(hDlg, IDC_EDIT_FINISHMSG);
    SendDlgItemMessage( hDlg, IDC_EDIT_FINISHMSG, EM_LIMITTEXT, MAX_FINISHMSG-2, 0L );
    SetDlgItemText( hDlg, IDC_EDIT_FINISHMSG, g_CDF.achFinishMsg );

    if ( g_CDF.fFinishMsg )  {
        CheckDlgButton( hDlg, IDC_RAD_NO_FINISHMSG,  FALSE );
        CheckDlgButton( hDlg, IDC_RAD_YES_FINISHMSG, TRUE );
        EnableDlgItem( hDlg, IDC_EDIT_FINISHMSG, TRUE );
    } else  {
        CheckDlgButton( hDlg, IDC_RAD_NO_FINISHMSG,  TRUE );
        CheckDlgButton( hDlg, IDC_RAD_YES_FINISHMSG, FALSE );
        EnableDlgItem( hDlg, IDC_EDIT_FINISHMSG, FALSE );
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       FinishMsgCmd                                                *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL FinishMsgCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage,
                   UINT *puNextPage, BOOL *pfKeepHistory )
{
    switch ( uCtrlID ) {
        case IDC_RAD_YES_FINISHMSG:
            EnableDlgItem( hDlg, IDC_EDIT_FINISHMSG, TRUE );
            break;


        case IDC_RAD_NO_FINISHMSG:
            EnableDlgItem( hDlg, IDC_EDIT_FINISHMSG, FALSE );
            break;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       FinishMsgOK                                                 *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL FinishMsgOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
                BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );


    GetDlgItemText( hDlg, IDC_EDIT_FINISHMSG, g_CDF.achFinishMsg,
                    sizeof(g_CDF.achFinishMsg) );

    if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_FINISHMSG ) )  {
        g_CDF.fFinishMsg = TRUE;
    } else  {
        g_CDF.fFinishMsg = FALSE;
    }

    if ( fForward )  {
        if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_FINISHMSG ) )  {
            if ( lstrlen( g_CDF.achFinishMsg ) == 0 )  {
                DisplayFieldErrorMsg( hDlg, IDC_EDIT_FINISHMSG,
                                      IDS_ERR_NO_FINISHMSG );
                return FALSE;
            }
        }
    }

    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  TARGET PAGE         ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       TargetInit                                                  *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL TargetInit( HWND hDlg, BOOL fFirstInit )
{
    SetFontForControl(hDlg, IDC_EDIT_TARGET);
    SetDlgItemText( hDlg, IDC_EDIT_TARGET, g_CDF.achTarget );

    if ( !(g_CDF.uExtractOpt & EXTRACTOPT_UI_NO) )
        CheckDlgButton( hDlg, IDC_HIDEEXTRACTUI, FALSE );
    else
        CheckDlgButton( hDlg, IDC_HIDEEXTRACTUI, TRUE );

    if ( g_CDF.uExtractOpt & EXTRACTOPT_LFN_YES )
        CheckDlgButton( hDlg, IDC_USE_LFN, TRUE );
    else
        CheckDlgButton( hDlg, IDC_USE_LFN, FALSE );


    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       TargetCmd                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL TargetCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                 BOOL *pfKeepHistory )
{
    CHAR        achFilename[MAX_PATH] = { '\0' };
    BOOL         fResult;


    switch ( uCtrlID )
    {

        case IDC_BUT_BROWSE:
            fResult = MySave( hDlg, IDS_FILTER_EXE,
                              achFilename, sizeof(achFilename), 0,
                              NULL, NULL, EXT_EXE_NODOT );

            if ( fResult )  {
                SetDlgItemText( hDlg, IDC_EDIT_TARGET, achFilename );
            }
            break;

        case IDC_USE_LFN:
            if ( IsDlgButtonChecked( hDlg, IDC_USE_LFN ) && (g_CDF.uPackPurpose != IDC_CMD_EXTRACT) )
            {
                if ( MsgBox( hDlg, IDS_WARN_USELFN, MB_ICONQUESTION, MB_YESNO) == IDNO )
                {
                    CheckDlgButton( hDlg, IDC_USE_LFN, FALSE );
                }
            }
            break;

    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       TargetOK                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL TargetOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
               BOOL *pfKeepHistory )
{
    LPSTR szTemp;
    LPSTR szExt;

    ASSERT( puNextPage );

    GetDlgItemText( hDlg, IDC_EDIT_TARGET, g_CDF.achTarget,
                    sizeof(g_CDF.achTarget) );

    RemoveBlanks( g_CDF.achTarget );

    if ( fForward )
    {
        if ( lstrlen( g_CDF.achTarget ) == 0 )
        {
            DisplayFieldErrorMsg( hDlg, IDC_EDIT_TARGET, IDS_ERR_NO_TARGET );
            return FALSE;
        }

        if ( !GetFullPathName( g_CDF.achTarget, sizeof(g_CDF.achTarget),
                               g_CDF.achTarget, &szTemp ) )
        {
            SysErrorMsg( hDlg );
            return FALSE;
        }

        // make sure that the path exists
        if ( !MakeDirectory( hDlg, g_CDF.achTarget, TRUE ) )
            return FALSE;

        if ( !(szExt = ANSIStrRChr(g_CDF.achTarget, '.')) || lstrcmpi( szExt, achExtEXE ) )
        {
            lstrcat( g_CDF.achTarget, achExtEXE );
        }

        // if goal is extract files only, no need for reboot page
        if ( g_CDF.uPackPurpose == IDC_CMD_EXTRACT )
        {
            *puNextPage = ORD_PAGE_SAVE;
        }
        else
        {
            // if you are in TARGET page, you should always jump over TARGET_CAB page
            *puNextPage = ORD_PAGE_REBOOT;
        }

        g_CDF.uExtractOpt &= ~(EXTRACTOPT_UI_NO | EXTRACTOPT_LFN_YES);

        if ( IsDlgButtonChecked( hDlg, IDC_HIDEEXTRACTUI ) )
            g_CDF.uExtractOpt |= EXTRACTOPT_UI_NO;

        if ( IsDlgButtonChecked( hDlg, IDC_USE_LFN ) )
             g_CDF.uExtractOpt |= EXTRACTOPT_LFN_YES;

        MyProcessLFNCmd( g_CDF.achOrigiInstallCmd, g_CDF.achInstallCmd );
        MyProcessLFNCmd( g_CDF.achOrigiPostInstCmd, g_CDF.achPostInstCmd );
    }

    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  TARGET_CAB PAGE     ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       TargetCABInit                                               *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL TargetCABInit( HWND hDlg, BOOL fFirstInit )
{
    int i;
    LRESULT nCurSel;

    SetFontForControl(hDlg, IDC_EDIT_TARGET);
    SetDlgItemText( hDlg, IDC_EDIT_TARGET, g_CDF.achTarget );

    // init CB box
    if ( !fFirstInit )
    {
        // cleanup old settings
        SendDlgItemMessage( hDlg, IDC_CB_RESVCABSP, CB_RESETCONTENT, 0, 0 );
        for ( i = 0; i<4; i++ )
        {
            nCurSel = SendDlgItemMessage( hDlg, IDC_CB_RESVCABSP, CB_ADDSTRING, 0, (LPARAM)pResvSizes[i] );
            if ( (nCurSel == (LRESULT)CB_ERR) || (nCurSel == (LRESULT)CB_ERRSPACE) )
            {
                ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
                return FALSE;
            }
        }

        if ( g_CDF.uExtractOpt & CAB_RESVSP2K )
            i = 1;
        else if ( g_CDF.uExtractOpt & CAB_RESVSP4K )
            i = 2;
        else if ( g_CDF.uExtractOpt & CAB_RESVSP6K )
            i = 3;
        else
            i = 0;

        if ( SendDlgItemMessage( hDlg, IDC_CB_RESVCABSP, CB_SETCURSEL, (WPARAM)i, (LPARAM)0 ) == (LRESULT)CB_ERR ) 
        {
            SendDlgItemMessage( hDlg, IDC_CB_RESVCABSP, CB_SETCURSEL, (WPARAM)0,(LPARAM)0 );
        }
    }

    // init Check boxes
    if ( g_CDF.uExtractOpt & CAB_FIXEDSIZE )
        CheckDlgButton( hDlg, IDC_MULTIPLE_CAB, TRUE );
    else
        CheckDlgButton( hDlg, IDC_MULTIPLE_CAB, FALSE );

    if ( g_CDF.uExtractOpt & EXTRACTOPT_LFN_YES )
        CheckDlgButton( hDlg, IDC_USE_LFN, TRUE );
    else
        CheckDlgButton( hDlg, IDC_USE_LFN, FALSE );

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       TargetCABCmd                                                *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL TargetCABCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                 BOOL *pfKeepHistory )
{
    CHAR        achFilename[MAX_PATH] = { '\0' };
    BOOL         fResult;


    switch ( uCtrlID )
    {

        case IDC_BUT_BROWSE:
            fResult = MySave( hDlg, IDS_FILTER_CAB,
                              achFilename, sizeof(achFilename), 0,
                              NULL, NULL, EXT_CAB_NODOT );

            if ( fResult )  {
                SetDlgItemText( hDlg, IDC_EDIT_TARGET, achFilename );
            }
            break;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       TargetCABOK                                                 *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL TargetCABOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
                BOOL *pfKeepHistory )
{
    LPSTR   szTemp;
    LPSTR   szExt;
    LRESULT nCurSel;

    ASSERT( puNextPage );

    GetDlgItemText( hDlg, IDC_EDIT_TARGET, g_CDF.achTarget,
                    sizeof(g_CDF.achTarget) );

    RemoveBlanks( g_CDF.achTarget );

    if ( fForward )
    {
        if ( lstrlen( g_CDF.achTarget ) == 0 )
        {
            DisplayFieldErrorMsg( hDlg, IDC_EDIT_TARGET, IDS_ERR_NO_TARGET );
            return FALSE;
        }
        
        // get the CAB format options
        //
        g_CDF.uExtractOpt &= ~(CAB_FIXEDSIZE | EXTRACTOPT_LFN_YES);
        g_CDF.uExtractOpt &= ~(CAB_RESVSP2K | CAB_RESVSP4K | CAB_RESVSP6K );

        nCurSel = SendDlgItemMessage( hDlg, IDC_CB_RESVCABSP, CB_GETCURSEL, (WPARAM)0,(LPARAM)0 );
        if ( nCurSel != (LRESULT)CB_ERR )
        {
            switch( nCurSel )
            {
                case 1:
                    g_CDF.uExtractOpt |= CAB_RESVSP2K;
                    break;
                case 2:
                    g_CDF.uExtractOpt |= CAB_RESVSP4K;
                    break;
                case 3:
                    g_CDF.uExtractOpt |= CAB_RESVSP6K;
                    break;
            }
        }

        if ( IsDlgButtonChecked( hDlg, IDC_MULTIPLE_CAB ) )
            g_CDF.uExtractOpt |= CAB_FIXEDSIZE;

        if ( IsDlgButtonChecked( hDlg, IDC_USE_LFN ) )
            g_CDF.uExtractOpt |= EXTRACTOPT_LFN_YES;

        // make sure CAB file name is 8.3 format
        //
        if ( !MakeCabName( hDlg, g_CDF.achTarget, g_CDF.achCABPath ) )
        {
            return FALSE;
        }

        if ( g_CDF.uExtractOpt & CAB_FIXEDSIZE )
        {
            // only user choose to get layout inf name and cab label
            *puNextPage = ORD_PAGE_CABLABEL;
        }
        else
        {
            // only user choose to create CAB only get this page
            // therefore, for sure no reboot page needed!
            *puNextPage = ORD_PAGE_SAVE;
        }

    }

    return TRUE;
}
//###########################################################################
//#                      ####################################################
//#  CABLABEL PAGE       ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       CABLABEL                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL CabLabelInit( HWND hDlg, BOOL fFirstInit )
{
    SetFontForControl(hDlg, IDC_EDIT_LAYOUTINF);
    SetFontForControl(hDlg, IDC_EDIT_CABLABEL);
    SendDlgItemMessage( hDlg, IDC_EDIT_LAYOUTINF, EM_LIMITTEXT, MAX_PATH-1, 0 );
    SendDlgItemMessage( hDlg, IDC_EDIT_CABLABEL, EM_LIMITTEXT, MAX_PATH-1, 0 );
    SetDlgItemText( hDlg, IDC_EDIT_LAYOUTINF, g_CDF.achINF );
    SetDlgItemText( hDlg, IDC_EDIT_CABLABEL, g_CDF.szCabLabel );

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CabLabelCmd                                                 *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL CabLabelCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                 BOOL *pfKeepHistory )
{
    CHAR        achFilename[MAX_PATH] = { '\0' };
    BOOL         fResult;

    switch ( uCtrlID )
    {

        case IDC_BUT_BROWSE:
            fResult = MySave( hDlg, IDS_FILTER_INF,
                              achFilename, sizeof(achFilename), 0,
                              NULL, NULL, EXT_INF_NODOT );

            if ( fResult )  {
                SetDlgItemText( hDlg, IDC_EDIT_LAYOUTINF, achFilename );
            }
            break;
    }

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       CabLabelOK                                                  *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL CabLabelOK( HWND hDlg, BOOL fForward, UINT *puNextPage,BOOL *pfKeepHistory )
{
    LPSTR szTemp;
    LPSTR szExt;

    ASSERT( puNextPage );

    GetDlgItemText( hDlg, IDC_EDIT_LAYOUTINF, g_CDF.achINF,sizeof(g_CDF.achINF) );
    GetDlgItemText( hDlg, IDC_EDIT_CABLABEL, g_CDF.szCabLabel,sizeof(g_CDF.szCabLabel) );

    RemoveBlanks( g_CDF.achINF );

    if ( fForward )
    {
        if ( lstrlen( g_CDF.achINF ) == 0 )
        {
            // use the default one
            lstrcpy( g_CDF.achINF, CABPACK_INFFILE );
        }

        if ( !GetFullPathName( g_CDF.achINF, sizeof(g_CDF.achINF),
                               g_CDF.achINF, &szTemp ) )
        {
            SysErrorMsg( hDlg );
            return FALSE;
        }

        if ( !(szExt = strchr(szTemp, '.')) )
        {
            lstrcat( szTemp, achExtINF );
        }
        else if ( lstrcmpi( szExt, achExtINF) )
        {
            lstrcpy( szExt, achExtINF );
        }

        *puNextPage = ORD_PAGE_SAVE;
    }

    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  REBOOT PAGE         ####################################################
//#                      ####################################################
//###########################################################################

//***************************************************************************
//*                                                                         *
//* NAME:       Reboot                                                      *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************

BOOL RebootInit( HWND hDlg, BOOL fFirstInit )
{
    BOOL state;

    if ( !(g_CDF.dwReboot & REBOOT_YES) )
    {
        CheckDlgButton( hDlg, IDC_REBOOT_NO, TRUE );
        CheckDlgButton( hDlg, IDC_REBOOT_ALWAYS, FALSE );
        CheckDlgButton( hDlg, IDC_REBOOT_IFNEED, FALSE );
        state = FALSE;
    }
    else
    {
        CheckDlgButton( hDlg, IDC_REBOOT_NO,   FALSE );

        CheckDlgButton( hDlg, IDC_REBOOT_ALWAYS, (g_CDF.dwReboot & REBOOT_ALWAYS) );
        CheckDlgButton( hDlg, IDC_REBOOT_IFNEED, !(g_CDF.dwReboot & REBOOT_ALWAYS) );
        state = TRUE;
    }


    CheckDlgButton( hDlg, IDC_REBOOT_SILENT, (g_CDF.dwReboot & REBOOT_SILENT) );

    EnableWindow( GetDlgItem(hDlg, IDC_REBOOT_SILENT), state );
    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       RebootCmd                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************

BOOL RebootCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                BOOL *pfKeepHistory )
{
    BOOL state;

    state = IsDlgButtonChecked( hDlg, IDC_REBOOT_NO );
    EnableWindow( GetDlgItem(hDlg, IDC_REBOOT_SILENT), !state );

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       RebootOK                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL RebootOK( HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );

    g_CDF.dwReboot = 0;

    if ( !IsDlgButtonChecked( hDlg, IDC_REBOOT_NO ) )
    {
        g_CDF.dwReboot |= REBOOT_YES;

        if ( IsDlgButtonChecked( hDlg, IDC_REBOOT_ALWAYS ) )
            g_CDF.dwReboot |= REBOOT_ALWAYS;
    }

    if ( IsDlgButtonChecked( hDlg, IDC_REBOOT_SILENT ) )
         g_CDF.dwReboot |= REBOOT_SILENT;

    return TRUE;
}


//###########################################################################
//#                      ####################################################
//#  SAVE PAGE           ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       SaveInit                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL SaveInit( HWND hDlg, BOOL fFirstInit )
{
    PSTR pszTmp;
    char szPath[MAX_PATH];

    SetFontForControl(hDlg, IDC_EDIT_SAVE_CDF);
    if ( g_CDF.achFilename[0] == 0 )
    {
        char ch;

        pszTmp = ANSIStrRChr( g_CDF.achTarget, '.' );
        if ( pszTmp )
        {
            ch = *pszTmp;
            *pszTmp = '\0';
            lstrcpy( szPath, g_CDF.achTarget );
            *pszTmp = ch;
            lstrcat( szPath, EXT_SED );
            pszTmp = szPath;
        }
        else
            pszTmp = g_CDF.achTarget;
    }
    else
    {
        pszTmp = ANSIStrRChr( g_CDF.achFilename, '.' );
        if ( pszTmp && !lstrcmpi( pszTmp, EXT_CDF ) )
            lstrcpy( pszTmp, EXT_SED );
        pszTmp = g_CDF.achFilename;
    }
    SetDlgItemText( hDlg, IDC_EDIT_SAVE_CDF, pszTmp );

    if ( g_CDF.fSave )  {
        CheckDlgButton( hDlg, IDC_RAD_YES_SAVE,   TRUE );
        CheckDlgButton( hDlg, IDC_RAD_NO_SAVE,    FALSE );
        EnableDlgItem( hDlg, IDC_EDIT_SAVE_CDF, TRUE );
        EnableDlgItem( hDlg, IDC_BUT_BROWSE, TRUE );
    } else  {
        CheckDlgButton( hDlg, IDC_RAD_YES_SAVE,   FALSE );
        CheckDlgButton( hDlg, IDC_RAD_NO_SAVE,    TRUE );
        EnableDlgItem( hDlg, IDC_EDIT_SAVE_CDF, FALSE );
        EnableDlgItem( hDlg, IDC_BUT_BROWSE, FALSE );
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       SaveCmd                                                     *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL SaveCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
              BOOL *pfKeepHistory )
{
    CHAR        achFilename[MAX_PATH] = { '\0' };
    BOOL         fResult;


    switch ( uCtrlID ) {

        case IDC_RAD_YES_SAVE:
            EnableDlgItem( hDlg, IDC_EDIT_SAVE_CDF, TRUE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, TRUE );
            break;


        case IDC_RAD_NO_SAVE:
            EnableDlgItem( hDlg, IDC_EDIT_SAVE_CDF, FALSE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, FALSE );
            break;


        case IDC_BUT_BROWSE:
            fResult = MySave( hDlg, IDS_FILTER_CDF,
                              achFilename, sizeof(achFilename), 0,
                              NULL, NULL, EXT_SED_NODOT );

            if ( fResult )  {
                SetDlgItemText( hDlg, IDC_EDIT_SAVE_CDF, achFilename );
            }

            break;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       SaveOK                                                      *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL SaveOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
             BOOL *pfKeepHistory )
{
    LPSTR szTemp;
    LPSTR szExt;
    CHAR szCDF[MAX_PATH];

    ASSERT( puNextPage );

    GetDlgItemText( hDlg, IDC_EDIT_SAVE_CDF, szCDF, sizeof(szCDF) );

    if ( fForward )
    {
        if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_SAVE ) )
        {
            if ( lstrlen( szCDF ) == 0 )
            {
                DisplayFieldErrorMsg( hDlg, IDC_EDIT_SAVE_CDF,
                                      IDS_ERR_NO_SAVE_FILENAME );
                return FALSE;
            }

            szExt = ANSIStrRChr( szCDF, '.' );
            if ( !szExt || lstrcmpi( szExt, EXT_SED ) )           // not given extension
            {
                lstrcat( szCDF, EXT_SED );
            }

            if ( ! GetFullPathName( szCDF, sizeof(szCDF), szCDF, &szTemp ) )
            {
                SysErrorMsg( hDlg );
                return FALSE;
            }

            // if there is existing CDF and is different name, copy it to new CDF first
            if ( lstrlen(g_CDF.achFilename) && lstrcmpi( szCDF, g_CDF.achFilename) )
            {
                if ( FileExists(szCDF) && MsgBox1Param( NULL, IDS_WARN_OVERIDECDF, szCDF, MB_ICONQUESTION, MB_YESNO ) == IDNO )
                    return FALSE;

                CopyFile( g_CDF.achFilename, szCDF, FALSE );
            }

            lstrcpy( g_CDF.achFilename, szCDF );
            g_CDF.fSave = TRUE;

            // make sure that the path exists
            if ( !MakeDirectory( hDlg, g_CDF.achFilename, TRUE ) )
                return FALSE;
        }
        else
            g_CDF.fSave = FALSE;

    }
    else
    {
        // back, means that the filelist may change.  Clean flag to prepare for next CDF out
        CleanFileListWriteFlag();
    }
    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  CREATE PAGE         ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       CreateInit                                                  *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL CreateInit( HWND hDlg, BOOL fFirstInit )
{
    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_NEXT );
    SetFontForControl(hDlg, IDC_MEDIT_STATUS);
    SetDlgItemText( hDlg, IDC_MEDIT_STATUS, "" );

    if ( fFirstInit )  {
        MEditSubClassWnd( GetDlgItem( hDlg, IDC_MEDIT_STATUS ),
                          (FARPROC) MEditSubProc );
    }

    ShowWindow( GetDlgItem( hDlg, IDC_TEXT_CREATE1 ), SW_SHOW );
    ShowWindow( GetDlgItem( hDlg, IDC_TEXT_CREATE2 ), SW_HIDE );
    ShowWindow( GetDlgItem( hDlg, IDC_TEXT_STATUS ), SW_HIDE );
    ShowWindow( GetDlgItem( hDlg, IDC_MEDIT_STATUS ), SW_HIDE );

    g_fFinish = FALSE;

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CreateOK                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL CreateOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
               BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );


    *pfKeepHistory = FALSE;

    // fForward in this case indicates a click on the Finish button

    if ( fForward )  {

        if ( g_fFinish )  {
            DeleteAllItems();
            return TRUE;
        }

        PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
        EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);
        SetDlgItemText( hDlg, IDC_MEDIT_STATUS, "" );
        ShowWindow( GetDlgItem( hDlg, IDC_TEXT_STATUS ), SW_SHOW );
        ShowWindow( GetDlgItem( hDlg, IDC_MEDIT_STATUS ), SW_SHOW );
        
        if ( ! MakePackage( hDlg ) )  {
            EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_NEXT );
            return FALSE;
        }
            
        EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
        if ( ! g_fFinish )  {
            g_fFinish = TRUE;
            ShowWindow( GetDlgItem( hDlg, IDC_TEXT_CREATE1 ), SW_HIDE );
            ShowWindow( GetDlgItem( hDlg, IDC_TEXT_CREATE2 ), SW_SHOW );
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_FINISH );
            return FALSE;
        }
    }

    return TRUE;
}


BOOL SetCurrSelect( HWND hDlg, UINT ctlId, LPSTR lpSelect )
{
    LRESULT nCurSel;
    BOOL    fRet = FALSE;

    if ( *lpSelect )
    {
        // Select the file that was last selected
        nCurSel = SendDlgItemMessage( hDlg, ctlId, CB_FINDSTRINGEXACT, (WPARAM) -1,
                                      (LPARAM) lpSelect );

        if ( nCurSel != (LRESULT)CB_ERR )
        {
            SendDlgItemMessage( hDlg, ctlId, CB_SETCURSEL, (WPARAM)nCurSel, 0 );
            fRet = TRUE;
        }
        else
        {
            fRet = SetDlgItemText( hDlg, ctlId, lpSelect );
        }

    }
    return fRet;
}

void RemoveBlanks( LPSTR lpData )
{
    CHAR   achBuf[MAX_PATH];
    int     i = 0;

    if ( !lpData || *lpData == 0)
    {
        return;
    }

    lstrcpy( achBuf, lpData );

    while ( achBuf[i] && achBuf[i] == ' ' )
        i++;

    lstrcpy( lpData, achBuf+i );
}

// returns start of next field (or null if null), sets start to begining of the first field,
// with fields separated by separaters and nulls first separater after the first field
CHAR* ExtractField( CHAR **pstart, CHAR * separaters)
{
    LPSTR start = *pstart;
    int x = 0;

    while(strchr(separaters, *start)) {
        if(*start == 0)
            return(NULL);
        start++;
        }

    *pstart = start;

    while(!strchr(separaters, start[x]) && (start[x] != 0))
        x++;

    if(start[x] == 0)
        return(start + x);

    start[x] = 0;

    return(start + x + 1);
}

BOOL GetFileFromList( LPSTR lpFile, LPSTR lpFullPath )
{
    PMYITEM pMyItem;

    pMyItem = GetFirstItem();
    while ( ! LastItem( pMyItem ) )
    {
        if ( !lstrcmpi( lpFile, GetItemSz( pMyItem, 0 ) ) )
        {
            lstrcpy( lpFullPath, GetItemSz( pMyItem, 1 ) );
            lstrcat( lpFullPath, GetItemSz( pMyItem, 0 ) );
            return TRUE;
        }
        pMyItem = GetNextItem( pMyItem );
    }
    return FALSE;
}

BOOL SetAdvDLLBit( LPSTR szInfFile  )
{
    CHAR szTempFile[MAX_PATH];
    CHAR szBuf[SMALL_BUF_LEN];

    szTempFile[0] = 0;

    // you are here, we expects the file is from the package
    if ( !GetFileFromList( szInfFile, szTempFile ) )
    {
        ErrorMsg( NULL, IDS_ERR_NO_CUSTOM );
        return FALSE;
    }

    // If the key "AdvancedInf" is defined, then we set the ADVDLL bit.
    // We don't care what the key is defined as -- we only care that it exists.
    if ( GetPrivateProfileString( SEC_VERSION, KEY_ADVINF, "", szBuf, sizeof(szBuf), szTempFile )
         > 0 )
    {
        g_CDF.uExtractOpt |= EXTRACTOPT_ADVDLL;
    }
    return TRUE;
}


BOOL SetCmdFromListWithCorrectForm( LPSTR szFile, LPSTR szOutCmd )
{
    CHAR   szTempFile[MAX_PATH];
    LPSTR  szShortFile;

    // you are here, we expects the file is from the package
    if ( GetFileFromList( szFile, szTempFile ) )
    {
        if ( !(g_CDF.uExtractOpt & EXTRACTOPT_LFN_YES) )
        {
            GetShortPathName( szTempFile, szTempFile, sizeof(szTempFile) );
            szShortFile = ANSIStrRChr( szTempFile, '\\' );
            lstrcpy( szOutCmd, szShortFile+1 );
        }
        else
        {           
            lstrcpy( szTempFile, "\"" );
            lstrcat( szTempFile, szFile );
            lstrcat( szTempFile, "\"" );
            lstrcpy( szOutCmd, szTempFile );
        }
        return TRUE;
    }
    return FALSE;
}


void MyProcessLFNCmd( LPSTR szOrigiCmd, LPSTR szOutCmd )
{
    LPSTR  szFirstField, szNextField;
    CHAR   szBuf[MAX_PATH];

    // store the original form first
    lstrcpy( szOutCmd, szOrigiCmd );

    // Three cases for LFN command or its params:
    // 1) Command has no params and is one of the files in the list;
    //      we make sure the command name is consistant with file in the CAB.
    // 2) Command has params and is one of the files in the list;
    //      user has to put "..." around the LFN to get processed correctly.
    // 3) Command is not one of the files in the list;
    //      user responsible to make sure the command in valid COMMAND-LINE format.
    //
    if ( SetCmdFromListWithCorrectForm( szOrigiCmd, szOutCmd ) )
    {
        // case 1)
        return;
    }

    lstrcpy( szBuf, szOrigiCmd );
    if ( szBuf[0] == '"' )
    {
        szFirstField = szBuf+1;
        szNextField = ExtractField( &szFirstField, "\"" );
        if ( szNextField && (*szNextField == '"') )
        {
            // special case for skipping the end of double quotes around the cmd
            szNextField = CharNext( szNextField );
        }
    }
    else
    {
        szFirstField = szBuf;
        szNextField = ExtractField( &szFirstField, " " );
    }

    if ( SetCmdFromListWithCorrectForm( szFirstField, szOutCmd  ) )
    {
        // case 2)
        if ( szNextField && *szNextField )
        {
            lstrcat( szOutCmd, " " );
            lstrcat( szOutCmd, szNextField );
        }
    }

    // case 3) command is outside the package, you are on your own.
    return;
}


BOOL CheckAdvBit( LPSTR szOrigiCommand )
{
    CHAR szTmp[MAX_PATH];
    LPSTR szNextField, szCurrField, szExt;

    lstrcpy( szTmp, szOrigiCommand );

    // check if the command is LFN name
    if ( szTmp[0] == '"' )
    {
        szCurrField = &szTmp[1];
        szNextField = ExtractField( &szCurrField, "\"" );
    }
    else
    {
        szCurrField = szTmp;
        szNextField = ExtractField( &szCurrField, " " );
    }

    // check if this is a INF file command
    if ( ((szExt = ANSIStrRChr( szCurrField, '.' )) != NULL) && !lstrcmpi( szExt, achExtINF ) )
    {
        if ( !SetAdvDLLBit( szCurrField ) )
            return FALSE;
    }
    return TRUE;
}


void SysErrorMsg( HWND hWnd )
{
    LPVOID  lpMsg;
    DWORD   dwErr;

    dwErr = GetLastError();

    if ( FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        NULL, dwErr,
                        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                        (LPSTR)&lpMsg, 0, NULL ) )
    {
        MessageBox( hWnd, (LPSTR)lpMsg, g_CDF.achTitle, MB_ICONERROR|MB_OK
                    |((RunningOnWin95BiDiLoc() && IsBiDiLocalizedBinary(g_hInst,RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO))) ? (MB_RIGHT | MB_RTLREADING) : 0));

        LocalFree( lpMsg );
    }
    else
    {
        char szError[SMALL_BUF_LEN];

        // should never be here, if so, post the original Win32 error code
        ErrorMsg1Param( hWnd, IDS_ERR_SYSERROR, _itoa(dwErr, szError, 10) );
    }

    return;
}

void SetFontForControl(HWND hwnd, UINT uiID)
{
   if (g_hFont)
   {
      SendDlgItemMessage(hwnd, uiID, WM_SETFONT, (WPARAM)g_hFont ,0L);
   }
}

void CleanFileListWriteFlag()
{
    PMYITEM pMyItem;

    pMyItem = GetFirstItem();
    while (!LastItem( pMyItem ) )  
    {
        pMyItem->fWroteOut = FALSE;
        pMyItem = GetNextItem( pMyItem );
    }
}

BOOL MakeCabName( HWND hwnd, PSTR pszTarget, PSTR pszCab )
{
    PSTR szTemp, szTemp1, szExt;

    if ( !GetFullPathName( pszTarget, MAX_PATH, pszTarget, &szTemp1 ) )
    {
        SysErrorMsg( hwnd );
        return FALSE;
    }

    // make sure that the path exists
    if ( !MakeDirectory( hwnd, pszTarget, TRUE) ) 
        return FALSE;

    lstrcpy( pszCab, pszTarget );
    szTemp = pszCab + lstrlen(pszCab) - lstrlen(szTemp1);

    // make sure CAB file name is 8.3 format
    //
    szExt = strchr( szTemp, '.' );
    if ( szExt )
    {
        *szExt = '\0';
    }

    if ( g_CDF.uExtractOpt & CAB_FIXEDSIZE )
    {
        // possible multiple CABs, so only take first 5 characters
        //
        if ( lstrlen( szTemp ) > 8 )
        {
            *(szTemp+8) = '\0' ;
            if ( !strchr(szTemp, '*') )
                lstrcpy( (szTemp+5), "_*" );
        }
        else if ( !strchr(szTemp, '*') )
        {
            if ( lstrlen( szTemp) > 5 )
            {
                lstrcpy( (szTemp+5), "_*" );
            }
            else
                lstrcat( szTemp, "_*" );
        }
    }
    else if ( lstrlen( szTemp ) > 8 )
    {
        DisplayFieldErrorMsg( hwnd, IDC_EDIT_TARGET, IDS_ERR_CABNAME );
        return FALSE;
    }

    // add .CAB extension in
    //
    lstrcat( szTemp, ".CAB" );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\exescan\chksect.c ===
#include <windows.h>

#include "crc32.h"

#include "chksect.h"

#define CHECK_SECTION

#ifndef offsetof
#define offsetof(s,m) (size_t)&(((s *)0)->m)
#endif

#define RoundUp(n,scale) (scale * ((n + scale - 1) / scale))

#define IsMemZero(pv,cb) (!(*((char *)pv) || memcmp(pv,((char *)pv)+1,cb-1)))

#pragma intrinsic(memcpy,memcmp)

enum
{
    EX_CHECKSUM,
    EX_SECURITY,
    EX_CRC32FILE,
    EX_EOF,
    MAX_EXCLUDE
};

#define MAX_BUFFER              (256*1024)      /* must be even */

typedef struct
{
    DWORD   signature;
    DWORD   crc32File;
    DWORD   cbCabFile;
} SELFTEST_SECTION;

#define SECTION_NAME            "Ext_Cab1"

#define SECTION_SIGNATURE       (0x4D584653)


#ifdef ADD_SECTION
SELFTEST_RESULT AddSection(char *pszEXEFileName,char *pszCABFileName)
#else
#ifdef CHECK_SECTION
SELFTEST_RESULT CheckSection(char *pszEXEFileName)
#else
SELFTEST_RESULT SelfTest(char *pszEXEFileName,
        unsigned long *poffCabinet,unsigned long *pcbCabinet)
#endif
#endif
{
    HANDLE hFile;                       // handle to the file we're updating
    enum SELFTEST_RESULT result;        // our return code
    union
    {
        IMAGE_DOS_HEADER dos;
        IMAGE_NT_HEADERS nt;
        IMAGE_SECTION_HEADER section;
    } header;                           // used to examine the file
    DWORD offNTHeader;                  // file offset to NT header
    int cSections;                      // number of sections in the file
    unsigned char *pBuffer;             // general-purpose buffer
    DWORD cbActual;                     // # of bytes actual read/written
#ifndef CHECK_SECTION
    unsigned long crc32;                // computed CRC-32
    struct
    {
        DWORD offExclude;
        DWORD cbExclude;
    } excludeList[MAX_EXCLUDE];         // list of ranges to exclude from CRC
    int iExclude;                       // exclude list index
    DWORD offSelfTestSection;           // file offset of our added section
    SELFTEST_SECTION SelfTestSection;   // added section header
    DWORD cbFile;                       // number of bytes in file/region
    DWORD cbChunk;                      // number of bytes in current chunk
    DWORD offFile;                      // current file offset
#endif
#ifdef ADD_SECTION
    DWORD offSectionHeader;             // file offset of section header
    DWORD offMaxVirtualAddress;         // lowest unused virtual address
    DWORD cbAlignVirtual;               // virtual address alignment increment
    DWORD cbAlignFile;                  // file address alignment increment
    HANDLE hCABFile;                       // cabinet file handle
    DWORD cbCABFile;                    // cabinet file size
    DWORD checksum;                     // generated checksum
    WORD *pBufferW;                     // used to generate checksum
#endif
#ifdef CHECK_SECTION
    DWORD offSectionHeaderEnd;          // first unused byte after section headers
    DWORD offFirstSection;              // first used byte after that
    DWORD offImportStart;               // where the import entries start
    DWORD cbImport;                     // size of import entry data
#endif

#ifndef CHECK_SECTION
    GenerateCRC32Table();
#endif

    pBuffer = (void *) GlobalAlloc(GMEM_FIXED,MAX_BUFFER);
    if (pBuffer == NULL)
    {
        result = SELFTEST_NO_MEMORY;
        goto done_no_buffer;
    }

#ifdef ADD_SECTION
    /* get size of cabinet */

    hCABFile = CreateFile(pszCABFileName,GENERIC_READ,FILE_SHARE_READ,NULL,
            OPEN_EXISTING,FILE_FLAG_SEQUENTIAL_SCAN,NULL);
    if (hCABFile == INVALID_HANDLE_VALUE)
    {
        result = SELFTEST_FILE_NOT_FOUND;
        goto done_no_cab;
    }

    cbCABFile = GetFileSize(hCABFile,NULL);
#endif


    /* open EXE image */

#ifdef ADD_SECTION
    hFile = CreateFile(pszEXEFileName,GENERIC_READ|GENERIC_WRITE,0,NULL,
            OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
#else
    hFile = CreateFile(pszEXEFileName,GENERIC_READ,FILE_SHARE_READ,NULL,
            OPEN_EXISTING,FILE_FLAG_SEQUENTIAL_SCAN,NULL);
#endif
    if (hFile == INVALID_HANDLE_VALUE)
    {
        result = SELFTEST_FILE_NOT_FOUND;
        goto done_no_exe;
    }


    /* read MS-DOS header */

    if ((ReadFile(hFile,&header.dos,sizeof(IMAGE_DOS_HEADER),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_DOS_HEADER)))
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }

    if (header.dos.e_magic != IMAGE_DOS_SIGNATURE)
    {
        offNTHeader = 0;
    }
    else
    {
        offNTHeader = header.dos.e_lfanew;
    }


    /* read PE header */

    SetFilePointer(hFile,offNTHeader,NULL,FILE_BEGIN);

    if ((ReadFile(hFile,&header.nt,sizeof(IMAGE_NT_HEADERS),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_NT_HEADERS)))
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }

    if (header.nt.Signature != IMAGE_NT_SIGNATURE)
    {
        result = SELFTEST_NOT_PE_FILE;
        goto done;
    }

    cSections = header.nt.FileHeader.NumberOfSections;

#ifdef ADD_SECTION
    cbAlignVirtual = header.nt.OptionalHeader.SectionAlignment;
    cbAlignFile = header.nt.OptionalHeader.FileAlignment;
    offMaxVirtualAddress = 0;
#endif


#ifndef CHECK_SECTION
    /* determine current file size */

    cbFile = GetFileSize(hFile,NULL);
    if (cbFile == 0xFFFFFFFF)
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }
#endif

#ifndef CHECK_SECTION
    /* see if we've been signed */

    if (header.nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress != 0)
    {
#ifdef ADD_SECTION
        result = SELFTEST_SIGNED;
        goto done;
#else
        /* make sure certificate is at the end of the file */

        if (cbFile !=
                (header.nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress
                + header.nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size))
        {
            result = SELFTEST_FAILED;
            goto done;
        }
        else
        {
            /* ignore anything starting at the certificate */

            cbFile = header.nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress;
        }
#endif
    }
#endif

#ifdef ADD_SECTION
    /* determine lowest un-used virtual address */
#else
    /* locate our added section */
#endif

#ifndef CHECK_SECTION
    offSelfTestSection = 0;
#endif

#ifdef ADD_SECTION
    offSectionHeader = offNTHeader +
            sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) +
            header.nt.FileHeader.SizeOfOptionalHeader +
            cSections * sizeof(IMAGE_SECTION_HEADER);
#endif

    SetFilePointer(hFile,(offNTHeader + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) +
            header.nt.FileHeader.SizeOfOptionalHeader),NULL,FILE_BEGIN);

#ifdef CHECK_SECTION
    offSectionHeaderEnd = offNTHeader +
            sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) +
            header.nt.FileHeader.SizeOfOptionalHeader +
            cSections * sizeof(IMAGE_SECTION_HEADER);

    offImportStart = header.nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;
    cbImport = header.nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size;

    if ((ReadFile(hFile,&header.section,sizeof(IMAGE_SECTION_HEADER),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_SECTION_HEADER)))
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }

    offFirstSection = header.section.PointerToRawData;

    if ((offFirstSection - offSectionHeaderEnd) > 0)
    {
        SetFilePointer(hFile,offSectionHeaderEnd,NULL,FILE_BEGIN);

        if ((ReadFile(hFile,pBuffer,(offFirstSection - offSectionHeaderEnd),&cbActual,NULL) != TRUE)
                || (cbActual != (DWORD) (offFirstSection - offSectionHeaderEnd)))
        {
            result = SELFTEST_READ_ERROR;
            goto done;
        }

        if ((offImportStart >= offSectionHeaderEnd) &&
            ((offImportStart + cbImport) <= offFirstSection))
        {
            memset(pBuffer + (offImportStart - offSectionHeaderEnd),0,cbImport);
        }

        if ((*pBuffer != '\0') ||
            (((offFirstSection - offSectionHeaderEnd) > 1) &&
            (memcmp(pBuffer,pBuffer + 1,(offFirstSection - offSectionHeaderEnd - 1)) != 0)))
        {
            result = SELFTEST_DIRTY;
        }
        else
        {
            result = SELFTEST_NO_ERROR;
        }
    }
    else
    {
        result = SELFTEST_NO_ERROR;
    }
#else
    while (cSections--)
    {
        if ((ReadFile(hFile,&header.section,sizeof(IMAGE_SECTION_HEADER),&cbActual,NULL) != TRUE)
                || (cbActual != sizeof(IMAGE_SECTION_HEADER)))
        {
            result = SELFTEST_READ_ERROR;
            goto done;
        }

        if (!memcmp(header.section.Name,SECTION_NAME,sizeof(header.section.Name)))
        {
            /* found our added section */

#ifdef ADD_SECTION
            result = SELFTEST_ALREADY;
            goto done;
#else
            offSelfTestSection = header.section.PointerToRawData;

            break;
#endif
        }

#ifdef ADD_SECTION
        if (offMaxVirtualAddress <
                (header.section.VirtualAddress + header.section.Misc.VirtualSize))
        {
            offMaxVirtualAddress =
                (header.section.VirtualAddress + header.section.Misc.VirtualSize);
        }
#endif
    }

#ifdef ADD_SECTION
    /* increase number of sections in the file; whack checksum */

    SetFilePointer(hFile,offNTHeader,NULL,FILE_BEGIN);

    if ((ReadFile(hFile,&header.nt,sizeof(IMAGE_NT_HEADERS),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_NT_HEADERS)))
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }

    header.nt.FileHeader.NumberOfSections++;
    header.nt.OptionalHeader.CheckSum = 0;
    header.nt.OptionalHeader.SizeOfImage =
            RoundUp(offMaxVirtualAddress,cbAlignVirtual) +
            RoundUp((sizeof(SELFTEST_SECTION) + cbCABFile),cbAlignVirtual);

    SetFilePointer(hFile,offNTHeader,NULL,FILE_BEGIN);

    if ((WriteFile(hFile,&header.nt,sizeof(IMAGE_NT_HEADERS),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_NT_HEADERS)))
    {
        result = SELFTEST_WRITE_ERROR;
        goto done;
    }


    /* make sure there's room for another section header */

    SetFilePointer(hFile,offSectionHeader,NULL,FILE_BEGIN);

    if ((ReadFile(hFile,&header.section,sizeof(IMAGE_SECTION_HEADER),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_SECTION_HEADER)))
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }

    if (!IsMemZero(&header.section,sizeof(IMAGE_SECTION_HEADER)))
    {
        result = SELFTEST_NO_SECTION;
        goto done;
    }


    /* create the new section header */

    memcpy(header.section.Name,SECTION_NAME,sizeof(header.section.Name));
    header.section.SizeOfRawData = 
            RoundUp((sizeof(SELFTEST_SECTION) + cbCABFile),cbAlignFile);
    header.section.PointerToRawData =
            RoundUp(cbFile,cbAlignFile);
    header.section.VirtualAddress =
            RoundUp(offMaxVirtualAddress,cbAlignVirtual);
    header.section.Misc.VirtualSize =
            RoundUp((sizeof(SELFTEST_SECTION) + cbCABFile),cbAlignVirtual);
    header.section.Characteristics = (IMAGE_SCN_CNT_INITIALIZED_DATA |
            IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ);


    /* write the new section header */

    SetFilePointer(hFile,offSectionHeader,NULL,FILE_BEGIN);

    if ((WriteFile(hFile,&header.section,sizeof(IMAGE_SECTION_HEADER),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_SECTION_HEADER)))
    {
        result = SELFTEST_WRITE_ERROR;
        goto done;
    }


    /* create the new section data */

    memset(&SelfTestSection,0,sizeof(SelfTestSection));
    SelfTestSection.signature = SECTION_SIGNATURE;
    SelfTestSection.cbCabFile = cbCABFile;

    offSelfTestSection = header.section.PointerToRawData;

    SetFilePointer(hFile,offSelfTestSection,NULL,FILE_BEGIN);

    if ((WriteFile(hFile,&SelfTestSection,sizeof(SelfTestSection),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(SelfTestSection)))
    {
        result = SELFTEST_WRITE_ERROR;
        goto done;
    }


    /* copy cabinet into section */

    SetFilePointer(hCABFile,0,NULL,FILE_BEGIN);

    cbFile = cbCABFile;

    while (cbFile)
    {
        if (cbFile > MAX_BUFFER)
        {
            cbChunk = MAX_BUFFER;
        }
        else
        {
            cbChunk = cbFile;
        }

        if ((ReadFile(hCABFile,pBuffer,cbChunk,&cbActual,NULL) != TRUE)
                || (cbActual != cbChunk))
        {
            result = SELFTEST_READ_ERROR;
            goto done;
        }

        if ((WriteFile(hFile,pBuffer,cbChunk,&cbActual,NULL) != TRUE)
                || (cbActual != cbChunk))
        {
            result = SELFTEST_WRITE_ERROR;
        }

        cbFile -= cbChunk;
    }


    /* pad added section as needed */

    cbChunk = header.section.SizeOfRawData - sizeof(SelfTestSection) - cbCABFile;

    if (cbChunk != 0)
    {
        memset(pBuffer,0,cbChunk);

        if ((WriteFile(hFile,pBuffer,cbChunk,&cbActual,NULL) != TRUE)
                || (cbActual != cbChunk))
        {
            result = SELFTEST_WRITE_ERROR;
        }
    }


    /* we've now increased total size of the file */

    cbFile = offSelfTestSection + header.section.SizeOfRawData;
#else

    /* make sure our added section was found */

    if (offSelfTestSection == 0)
    {
        result = SELFTEST_NO_SECTION;
        goto done;
    }
#endif

    /* If this EXE gets signed, the checksum will be changed.       */

    excludeList[EX_CHECKSUM].offExclude = offNTHeader + 
            offsetof(IMAGE_NT_HEADERS,OptionalHeader.CheckSum);
    excludeList[EX_CHECKSUM].cbExclude =
            sizeof(header.nt.OptionalHeader.CheckSum);


    /* If this EXE gets signed, the security entry will be changed. */

    excludeList[EX_SECURITY].offExclude = offNTHeader +
        offsetof(IMAGE_NT_HEADERS,
            OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]);
    excludeList[EX_SECURITY].cbExclude = sizeof(IMAGE_DATA_DIRECTORY);


    /* Can't CRC our own CRC field.                                 */

    excludeList[EX_CRC32FILE].offExclude = offSelfTestSection +
            offsetof(SELFTEST_SECTION,crc32File);
    excludeList[EX_CRC32FILE].cbExclude = sizeof(SelfTestSection.crc32File);


    /* Stop at end of known file.                                   */

    /* Note: current code assumes that the only thing which could   */
    /* be appended to the file after this is the certificate from   */
    /* codesigning, and that it will be pointed at by the security  */
    /* entry.  If anything else appends, or padding is added before */
    /* the certificate, we'll have to store this file size in the   */
    /* added section, and retrieve it before running the CRC.       */

    excludeList[EX_EOF].offExclude = cbFile;


    /*  Compute the CRC-32 of the file, skipping excluded extents.  */
    /*  This code assumes excludeList is sorted by offExclude.      */

    crc32 = CRC32_INITIAL_VALUE;
    offFile = 0;

#ifdef ADD_SECTION
    /*  Along the way, compute the correct checksum for this new    */
    /*  image.  We know that each of the sections on the exclude    */
    /*  list just happened to be zeroed right now, so they won't    */
    /*  affect our checksum.  But we will have to add our new CRC32 */
    /*  value to the checksum, because it will be in the file when  */
    /*  we're done.  It helps that we know that all the exclusions  */
    /*  on the list are WORD aligned and have even lengths.         */

    /*  The checksum in a PE file is a 16-bit sum of 16-bit words   */
    /*  in the file, with wrap-around carry, while the checksum     */
    /*  field is filled with zero.  The file's length is added,     */
    /*  yielding a 32-bit result.                                   */

    checksum = 0;
#endif

    for (iExclude = 0; iExclude < MAX_EXCLUDE; iExclude++)
    {
        SetFilePointer(hFile,offFile,NULL,FILE_BEGIN);

        cbFile = excludeList[iExclude].offExclude - offFile;

        while (cbFile)
        {
            if (cbFile > MAX_BUFFER)
            {
                cbChunk = MAX_BUFFER;
            }
            else
            {
                cbChunk = cbFile;
            }

            if ((ReadFile(hFile,pBuffer,cbChunk,&cbActual,NULL) != TRUE)
                    || (cbActual != cbChunk))
            {
                result = SELFTEST_READ_ERROR;
                goto done;
            }

            CRC32Update(&crc32,pBuffer,cbChunk);

            offFile += cbChunk;
            cbFile -= cbChunk;

#ifdef ADD_SECTION
            /* roll buffer into checksum */

            pBufferW = (WORD *) pBuffer;

            cbChunk >>= 1;

            while (cbChunk--)
            {
                checksum += *pBufferW++;

                if (checksum > 0x0000FFFF)
                {
                    checksum -= 0x0000FFFF;
                }
            }
#endif

            /*
             *  INSERT PROGRESS GAUGE HERE:
             *  %complete = (offFile * 100.0) / excludeList[EX_EOF].offExclude
             */
        }

        offFile += excludeList[iExclude].cbExclude;
    }


#ifdef ADD_SECTION
    /* account for CRC32 value in checksum */

    checksum += (WORD) crc32;
    checksum += (crc32 >> 16);

    while (checksum > 0x0000FFFF)
    {
        checksum -= 0x0000FFFF;
    }


    /* add file length to checksum */

    checksum += excludeList[EX_EOF].offExclude;


    /* update CRC-32 value in added section */

    SetFilePointer(hFile,excludeList[EX_CRC32FILE].offExclude,NULL,FILE_BEGIN);

    if ((WriteFile(hFile,&crc32,sizeof(crc32),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(crc32)))
    {
        result = SELFTEST_WRITE_ERROR;
        goto done;
    }


    /* update checksum value in header */

    SetFilePointer(hFile,excludeList[EX_CHECKSUM].offExclude,NULL,FILE_BEGIN);

    if ((WriteFile(hFile,&checksum,sizeof(checksum),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(checksum)))
    {
        result = SELFTEST_WRITE_ERROR;
        goto done;
    }


    /* done */

    if (CloseHandle(hFile) != TRUE)
    {
        result = SELFTEST_WRITE_ERROR;
    }
    else
    {
        result = SELFTEST_NO_ERROR;
    }

    goto done_no_exe;
#else
    /* read the header from the added section */

    SetFilePointer(hFile,offSelfTestSection,NULL,FILE_BEGIN);

    if ((ReadFile(hFile,&SelfTestSection,sizeof(SelfTestSection),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(SelfTestSection)))
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }


    /* verify CRC-32 value in added section */

    if ((SelfTestSection.signature != SECTION_SIGNATURE) ||
            (crc32 != SelfTestSection.crc32File))
    {
        result = SELFTEST_FAILED;
    }
    else
    {
        *poffCabinet = offSelfTestSection + sizeof(SelfTestSection);
        *pcbCabinet = SelfTestSection.cbCabFile;

        result = SELFTEST_NO_ERROR;
    }
#endif
#endif  // CHECK_SECTION

done:
    CloseHandle(hFile);

done_no_exe:

#ifdef ADD_SECTION
    CloseHandle(hCABFile);

done_no_cab:
#endif

    GlobalFree((HGLOBAL) pBuffer);

done_no_buffer:

#ifdef ADD_SECTION
    /* destroy failed attempt */

    if (result != SELFTEST_NO_ERROR)
    {
        DeleteFile(pszEXEFileName);
    }
#endif

    return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\exescan\chksect.h ===
/* selftest.h */

typedef enum
{
    SELFTEST_NO_ERROR = 0,
    SELFTEST_NO_MEMORY,
    SELFTEST_FILE_NOT_FOUND,
    SELFTEST_READ_ERROR,
    SELFTEST_WRITE_ERROR,
    SELFTEST_NOT_PE_FILE,
    SELFTEST_NO_SECTION,
    SELFTEST_FAILED,
    SELFTEST_ALREADY,
    SELFTEST_SIGNED,
    SELFTEST_DIRTY,
    SELFTEST_MAX_RESULT
} SELFTEST_RESULT;


extern SELFTEST_RESULT AddSection(char *pszEXEFileName,char *pszCABFileName);
extern SELFTEST_RESULT SelfTest(char *pszEXEFileName,
        unsigned long *poffCabinet,unsigned long *pcbCabinet);
extern SELFTEST_RESULT CheckSection(char *pszEXEFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\common\res.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* RES.H - Resource strings shared by CABPack and WExtract                 *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* GLOBAL CONSTANTS                                                        *
//***************************************************************************
#define achResTitle         "TITLE"
#define achResLicense       "LICENSE"
#define achResShowWindow    "SHOWWINDOW"
#define achResFinishMsg     "FINISHMSG"
#define achResRunProgram    "RUNPROGRAM"
#define achResPostRunCmd    "POSTRUNPROGRAM"
#define achResCabinet       "CABINET"
#define achResUPrompt       "UPROMPT"
#define achResNone          "<None>"
#define achResNumFiles      "NUMFILES"
#define achResSize          "FILESIZES"
#define achResReboot        "REBOOT"
#define achResExtractOpt    "EXTRACTOPT"
#define achResPackInstSpace "PACKINSTSPACE"
#define achResOneInstCheck  "INSTANCECHECK"
#define achResAdminQCmd     "ADMQCMD"
#define achResUserQCmd      "USRQCMD"
#define achResVerCheck      "VERCHECK"

#define bResShowDefault         0
#define bResShowHidden          1
#define bResShowMin             2
#define bResShowMax             3

// Bits flags for extract options
//
#define EXTRACTOPT_UI_NO             0x00000001
#define EXTRACTOPT_LFN_YES           0x00000002
#define EXTRACTOPT_ADVDLL            0x00000004
#define EXTRACTOPT_COMPRESSED        0x00000008
#define EXTRACTOPT_UPDHLPDLLS        0x00000010
#define EXTRACTOPT_PLATFORM_DIR      0x00000020
#define EXTRACTOPT_INSTCHKPROMPT     0x00000040
#define EXTRACTOPT_INSTCHKBLOCK      0x00000080
#define EXTRACTOPT_CHKADMRIGHT       0x00000100
#define EXTRACTOPT_PASSINSTRET       0x00000200
#define EXTRACTOPT_CMDSDEPENDED	     0x00000400	
#define EXTRACTOPT_PASSINSTRETALWAYS 0x00000800

//
// when the Wizard is used to create CAB only, the CDF.uExtractOpt
// is used to store the CAB file options.  Pick the upper word and try
// not miss used by Extract options
//
#define CAB_FIXEDSIZE           0x00010000
#define CAB_RESVSP2K            0x00020000
#define CAB_RESVSP4K            0x00040000
#define CAB_RESVSP6K            0x00080000


#define CLUSTER_BASESIZE        512
#define MAX_NUMCLUSTERS         8

// Install EXE return code
//
#define RC_WEXTRACT_AWARE       0xAA000000  // means cabpack aware func return code
#define REBOOT_YES              0x00000001  // this bit off means no reboot
#define REBOOT_ALWAYS           0x00000002  // if REBOOT_YES is on and this bit on means always reboot
                                            //                         this bit is off means reboot if need
#define REBOOT_SILENT           0x00000004  // if REBOOT_YES is on and this bit on means not prompt user before reboot

#define KEY_ADVINF              "AdvancedINF"
#define SEC_VERSION             "Version"

// define dwFlags between wextract and advpack.dll
// The lower word is reserved for passing Quiet mode info
// defined in advpub.h
//
#define ADVFLAGS_NGCONV         0x00010000      // don't run GroupConv
#define ADVFLAGS_COMPRESSED     0x00020000      // the file to be installed is compressed
#define ADVFLAGS_UPDHLPDLLS     0x00040000      // update advpack, w95inf32 ...DLLs
#define ADVFLAGS_DELAYREBOOT 	0x00080000	// if any reboot condition there from pre, delay action
#define ADVFLAGS_DELAYPOSTCMD 	0x00100000	// if any reboot condition there from pre, delay run post setup commands

typedef struct _ADVPACKARGS {
    HWND  hWnd;
    LPSTR lpszTitle;
    LPSTR lpszInfFilename;
    LPSTR lpszSourceDir;
    LPSTR lpszInstallSection;
    WORD  wOSVer;
    DWORD dwFlags;
    DWORD dwPackInstSize;
} ADVPACKARGS, *PADVPACKARGS;

typedef struct _VER {
    DWORD dwMV;
    DWORD dwLV;
    DWORD dwBd;
} VER;

typedef struct _VERRANGE {
    VER     frVer;
    VER     toVer;
} VERRANGE, *PVERRANGE;

typedef struct _VERCHECK {
    VERRANGE    vr[2];
    DWORD       dwFlag;
    DWORD       dwstrOffs;
    DWORD       dwNameOffs;
} VERCHECK, *PVERCHECK;

typedef struct _TARGETVERINFO {
    DWORD    dwSize;
    VERCHECK ntVerCheck;
    VERCHECK win9xVerCheck;
    DWORD    dwNumFiles;
    DWORD    dwFileOffs;
    char     szBuf[1];
} TARGETVERINFO, *PTARGETVERINFO;

// define the flag field
//
#define VERCHK_OK       0x00000000
#define VERCHK_YESNO    0x00000001
#define VERCHK_OKCANCEL 0x00000002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\cabpack\version.c ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1996. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* VERSION.C - Function to overwrite the versin information from           *
//*             wextract.exe                                                *
//*                                                                         *
//***************************************************************************
//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include "pch.h"
#pragma hdrstop
#include "cabpack.h"
#include <memory.h> 

extern CDF   g_CDF;
extern TCHAR g_szOverideCDF[MAX_PATH];
extern TCHAR g_szOverideSec[SMALL_BUF_LEN];

// Function prototypes
BOOL UpdateVersionInfo(LPBYTE lpOldVersionInfo, LPBYTE *lplpNewVersionInfo, WORD *pwSize);
BOOL FindVerValue( WCHAR *lpKey, WCHAR *lpszData, WORD *pwLen);
BOOL CALLBACK MyEnumLangsFunc(HANDLE hModule, LPSTR lpType, LPSTR lpName, WORD languages, LONG lParam);

// External function and variables
DWORD MyGetPrivateProfileString( LPCTSTR lpSec, LPCTSTR lpKey, LPCTSTR lpDefault,
                                LPTSTR lpBuf, UINT uSize, LPCTSTR lpOverSec );
void MyWritePrivateProfileString( LPCTSTR lpSec, LPCTSTR lpKey, LPTSTR lpBuf, UINT uSize );

//////////////////////////////////////////////////////////////////////////////
//// Version information overwrite functions and data types
#define KEY_FROMFILE        "FromFile"
#define COMPANYNAME         "CompanyName"
#define INTERNALNAME        "InternalName"
#define ORIGINALFILENAME    "OriginalFilename"
#define PRODUCTNAME         "ProductName"
#define PRODUCTVERSION      "ProductVersion"
#define FILEVERSION         "FileVersion"
#define FILEDESCRIPTION     "FileDescription"
#define LEGALCOPYRIGHT      "LegalCopyright"

#define MAX_VALUE   256

// What language is the version information in?
WORD    wVerLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
// Structure to save the keys and values for the Version info
typedef struct _VERINFO
{
    LPSTR   lpszName;
    CHAR    szValue[MAX_VALUE];
} VERINFO;

// Array of keys and values which can be changed.
VERINFO Verinfo_Array[] = { 
                    { COMPANYNAME, ""},
                    { INTERNALNAME, ""},
                    { ORIGINALFILENAME, ""},
                    { PRODUCTNAME, ""},
                    { PRODUCTVERSION, ""},
                    { FILEVERSION, ""},
                    { FILEDESCRIPTION, ""},
                    { LEGALCOPYRIGHT, ""}
                    };

#define ARRAYSIZE(a)    (sizeof(a) / sizeof(a[0]))

UINT    VerInfoElem = ARRAYSIZE(Verinfo_Array);

//... Decrement WORD at *pw by given amount w
#define DECWORDBY( pw,w) if (pw) { *(pw) = (*(pw) > (w)) ? *(pw) - (w) : 0;}

//... Increment WORD at *pw by given amount w
#define INCWORDBY( pw,w) if (pw) { *(pw) += (w);}

#define MEMSIZE( x ) ((x) * 2) 
                // was sizeof( TCHAR))

#define STRINGFILEINFOLEN  15
#define LANGSTRINGLEN  8    //... # WCHARs in string denoting language
                            //... and code page in a Version resource.
#define VERTYPESTRING  1    //... Version data value is a string

#pragma pack(1)
typedef struct VERBLOCK
{
    WORD  wLength;          // Length of this block
    WORD  wValueLength;     // Length of the valuedata
    WORD  wType;            // Type of data (1=string, 0=binary)
    WCHAR szKey[1];         // data
} VERBLOCK ;

typedef VERBLOCK * PVERBLOCK;

typedef struct VERHEAD
{
    WORD wTotLen;
    WORD wValLen;
    WORD wType;
    TCHAR szKey[( sizeof( TEXT("VS_VERSION_INFO" )) +3 )&~03];
    VS_FIXEDFILEINFO vsf;

} VERHEAD ;
#pragma pack()


// Do the version info update
//
// szFile is the file we want to update the version info from
// hUpdate is the handle to the resource info which will be used to update all resources
//
BOOL DoVersionInfo(HWND hDlg, LPSTR szFile, HANDLE hUpdate)
{
    HINSTANCE   hModule;
    HRSRC       hrsrc;
    HGLOBAL     hgbl;
    LPBYTE      lp;
    LPBYTE      lpCopy;
    WORD        wSize;

    if (GetVersionInfoFromFile())
    {
        // Get the current version info from the file
        hModule = LoadLibraryEx(szFile, NULL,LOAD_LIBRARY_AS_DATAFILE| DONT_RESOLVE_DLL_REFERENCES);
        if (hModule == NULL)
            return FALSE;       // Should not happen, we loaded the module before

        // Determine the language of the version information
        EnumResourceLanguages(hModule, RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO), (ENUMRESLANGPROC)MyEnumLangsFunc, 0L);
        
        hrsrc = FindResourceEx (hModule, RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO), wVerLang);
        if (hrsrc == NULL)
        {
            FreeLibrary(hModule);
            return FALSE;       // Should we continue???
        }
        if ((hgbl = LoadResource(hModule, hrsrc)) == NULL)
        {
            FreeResource(hrsrc);
            FreeLibrary(hModule);
            return FALSE;       // Should we continue???
        }

        if ((lp = LockResource(hgbl)) == NULL)
        {
            FreeResource(hrsrc);
            FreeLibrary(hModule);
            return FALSE;       // Should we continue???
        }

        // UPdate the version information, If success, lpCopy has the pointer to the update info
        UpdateVersionInfo(lp, &lpCopy, &wSize);
        UnlockResource(hgbl);
        FreeResource(hrsrc);
        FreeLibrary(hModule);

        if (lpCopy != NULL)
        {
            // Now update the resource for the file
            if ( LocalUpdateResource( hUpdate, RT_VERSION,
                 MAKEINTRESOURCE(VS_VERSION_INFO), wVerLang, //MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                 lpCopy, wSize) == FALSE )
            {
                free (lpCopy);
                ErrorMsg( hDlg, IDS_ERR_UPDATE_RESOURCE );
                return FALSE;
            }
            free (lpCopy);
        }

        return TRUE;
    }
    return TRUE;
}

// Get the version information we use to overwrite from the CDF file
BOOL GetVersionInfoFromFile()
{
    char    szFilename[MAX_STRING];
    HLOCAL  hInfoBuffer;
    LPSTR   lpValueBuffer;
    char    szQuery[128];
    DWORD   dwBytes;
    DWORD   dwLangCharset;
    DWORD   dwInfoBuffer;
    DWORD   dwDummy;
    UINT    i;

    if ( MyGetPrivateProfileString(SEC_OPTIONS, KEY_VERSIONINFO, "", g_CDF.achVerInfo, sizeof(g_CDF.achVerInfo), g_szOverideSec ) > 0)
    {
        // We better zero the version info in our array.
        for (i = 0; i < VerInfoElem; i++)
        {
            Verinfo_Array[i].szValue[0] = '\0';
        }

        if ( MyGetPrivateProfileString( g_CDF.achVerInfo, KEY_FROMFILE, "", szFilename, sizeof(szFilename), g_CDF.achVerInfo) > 0)
        {
            // Fill the version info from the file version info

            // determine if the file contains version information
            // and get the size of the information if so
            dwInfoBuffer = GetFileVersionInfoSize(szFilename, &dwDummy);

            if (dwInfoBuffer != 0)
            {

                // allocate memory to hold the version information
                hInfoBuffer = LocalAlloc(LMEM_FIXED, dwInfoBuffer);

                if (hInfoBuffer != NULL)
                {

                    // read version information into our memory
                    if (GetFileVersionInfo(szFilename, 0, dwInfoBuffer, (LPVOID)hInfoBuffer) != 0)
                    {
                        // get language and character set information
                        if (VerQueryValue((LPVOID)hInfoBuffer, "\\VarFileInfo\\Translation",
                                &lpValueBuffer, &dwBytes))
                            dwLangCharset = *(LPDWORD)lpValueBuffer;
                        else
                            dwLangCharset = 0x04E40409;         // If we don't have any default to US. Should never happen

                        // Now get the version info from the file
                        for (i = 0; i < VerInfoElem; i++)
                        {
                            // get version information string
                            wsprintf(szQuery, "\\StringFileInfo\\%4.4X%4.4X\\%s",
                                    LOWORD(dwLangCharset), HIWORD(dwLangCharset), Verinfo_Array[i].lpszName);

                            if (VerQueryValue((LPVOID)hInfoBuffer, szQuery, (LPVOID)&lpValueBuffer, &dwBytes) != 0)
                                lstrcpyn(Verinfo_Array[i].szValue,lpValueBuffer, MAX_VALUE-1);        // Found one, take it
                        }
                    }
                    LocalFree(hInfoBuffer);
                }
            }
        } // Got version info from file

        // Now see if we have to overwrite some info from the batch file.
        for (i = 0; i < VerInfoElem; i++)
        {
            if (MyGetPrivateProfileString(g_CDF.achVerInfo, Verinfo_Array[i].lpszName, "", szFilename, MAX_VALUE, g_CDF.achVerInfo) > 0)
            {
                lstrcpyn(Verinfo_Array[i].szValue, szFilename, MAX_VALUE-1);
            }
        }
        return TRUE;
    }
    return FALSE;
}


// Update the lpOldVersionInfo with the overwritable data.
// lpOldVersionInfo: pointer to the old version info data block
// lplpNewVersionInfo: Will get the pointer to the updated version info data, 
//      the caller has to free the buffer if the pointer is not NULL,
// pwSize: pointer to a word which will return the size of the new version info block
//
// Note: This code assumes that there is only one language data block in the version info data.
//
BOOL UpdateVersionInfo(LPBYTE lpOldVersionInfo, LPBYTE *lplpNewVersionInfo, WORD *pwSize)
{
    WCHAR       szData[MAX_STRING]; // Will hold the data to put into the versin info
    WORD        wDataLen = 0;            //... Length of old resource data
    WORD        wVerHeadSize;            //... Sizeof of the VERHEAD struct
    int         nNewVerBlockSize = 0;   // Size of the new version info data block
    PVERBLOCK   pNewVerStamp = NULL;    // Pointer to the new version info data block
    PVERBLOCK   pNewBlk      = NULL;    // Pointer to the currently worked on data in new verblock
    VERHEAD     *pVerHdr = (VERHEAD*)lpOldVersionInfo;  // Pointer to old verinfo
    VERBLOCK    *pVerBlk;               // Pointer to the currently worked on data in old verblock
    LPBYTE      lp;                     // Pointer to the data area to copy (overwrite)
    WORD        wStringTableLen = 0;    // Bytes (left) in the language data block
    PVERBLOCK   pNewStringTblBlk;       // Pointer to the language part for the version info
    WORD        wStringInfoLen = 0;     //... # of bytes in StringFileInfo
    PVERBLOCK   pNewStringInfoBlk;      //... Start of this StringFileInfo blk
    WORD        wLen = 0;


    *lplpNewVersionInfo = NULL;
    *pwSize = 0;
    wVerHeadSize = (WORD)(3 * sizeof(WORD) + MEMSIZE(lstrlen("VS_FIXEDFILEINFO") + 1) + sizeof(VS_FIXEDFILEINFO));
    wVerHeadSize = ROUNDUP(wVerHeadSize, 4);

    // Total length of the version information
    wDataLen = pVerHdr->wTotLen;

    if ( wDataLen == 0 || wDataLen == (WORD)-1 )
    {
        return(FALSE);             //... No resource data
    }

    //... Allocate buffer to hold New Version
    //... Stamping Block (make the buffer large to
    //... account for expansion of strings 
    pVerBlk = (PVERBLOCK)((PBYTE)pVerHdr + wVerHeadSize);       // point into version block of the old info

    // we potentialy replace 8 (VerInfoElem=8) string in the version info
    // I alloc 9 * 2 * 256 + size of the current version info. This should give us plenty of space
    // I need to multiply by 2 because we work with unicode strings. One character = 2 bytes.
    nNewVerBlockSize = wDataLen + (2 * (VerInfoElem+1) * MAX_VALUE);
    pNewVerStamp = (PVERBLOCK)malloc( nNewVerBlockSize ); 
    //... Fill new memory block with zeros
    memset((void *)pNewVerStamp, 0, nNewVerBlockSize);

    //... Copy version info header into new version buffer
    memcpy((void *)pNewVerStamp, (void *)pVerHdr, wVerHeadSize);
    pNewVerStamp->wLength = wVerHeadSize;
    
    //... Move after version info header
    pNewBlk = (PVERBLOCK)((PBYTE)pNewVerStamp + wVerHeadSize);

    wDataLen -= wVerHeadSize;

    if (wDataLen > 0)
    {                           //... Start of a StringFileInfo block?
        pNewStringInfoBlk = pNewBlk;
        //... Get # of bytes in this StringFileInfo
        //... (Length of value is always 0 here)
        wStringInfoLen = pVerBlk->wLength;

        //... Move to start of first StringTable blk.
        //  -2 is for the starting WCHAR part of the VERBLOCK
        wLen = ROUNDUP(sizeof(VERBLOCK) - 2 + MEMSIZE( STRINGFILEINFOLEN),4);

        // Copy StringFileVersion header
        CopyMemory( pNewBlk, pVerBlk, wLen);
        pNewStringInfoBlk->wLength = 0;     // Set length, will be updated dynamicly

        // Go to the language ID block
        pVerBlk = (PVERBLOCK)((PBYTE)pVerBlk + wLen);
        pNewBlk = (PVERBLOCK)((PBYTE)pNewBlk + wLen);

        // Decrement byte counter
        DECWORDBY(&wDataLen,       wLen);
        DECWORDBY(&wStringInfoLen, wLen);

        // Update the size values
        INCWORDBY(&pNewVerStamp->wLength,      wLen);
        INCWORDBY(&pNewStringInfoBlk->wLength, wLen);

        // We should be now at the language codepage ID string
        if (wStringInfoLen > 0)
        {
            //... Get # of bytes in this StringTable
            wStringTableLen = pVerBlk->wLength;

            pNewStringTblBlk = pNewBlk;

            //... Move to start of first String.
            //  -2 is for the starting WCHAR part of the VERBLOCK
            wLen = ROUNDUP( sizeof(VERBLOCK) - 2 + MEMSIZE( LANGSTRINGLEN),4);
            // Copy language/codepage header
            CopyMemory( pNewBlk, pVerBlk, wLen);
            pNewStringTblBlk->wLength = 0;  // Set length, will be updated dynamicly

            // Go to the first data block
            pVerBlk = (PVERBLOCK)((PBYTE)pVerBlk + wLen);
            pNewBlk = (PVERBLOCK)((PBYTE)pNewBlk + wLen);

            DECWORDBY(&wDataLen,        wLen);
            DECWORDBY(&wStringInfoLen,  wLen);
            DECWORDBY(&wStringTableLen, wLen);

            // Update the size values
            INCWORDBY(&pNewVerStamp->wLength,      wLen);
            INCWORDBY(&pNewStringInfoBlk->wLength, wLen);
            INCWORDBY(&pNewStringTblBlk->wLength,  wLen);

            while ( wStringTableLen > 0 )
            {
                // Copy the old data
                CopyMemory( pNewBlk, pVerBlk, ROUNDUP(pVerBlk->wLength,4));

                wLen = pVerBlk->wLength;
                //... Is value a string?
                if (pVerBlk->wType == VERTYPESTRING)
                {
                    //... See if we need to replace the value for this data
                    wLen = sizeof(szData);
                    if (FindVerValue( pVerBlk->szKey, szData, &wLen)) 
                    {
                        // Update the length values
                        pNewBlk->wValueLength = wLen;
                        // Find the start of the data
                        lp = (LPBYTE) ((PBYTE)pNewBlk + ROUNDUP(pVerBlk->wLength,4) - ROUNDUP(MEMSIZE(pVerBlk->wValueLength),4));

                        // Get the size of the new data
                        wLen = ROUNDUP(MEMSIZE(pNewBlk->wValueLength),4);
                        // Overwrite the old data
                        CopyMemory(lp, szData, wLen);

                        // calculate the size of this data and set it.
                        wLen = MEMSIZE(pNewBlk->wValueLength);
                        pNewBlk->wLength += (wLen - MEMSIZE(pVerBlk->wValueLength));
                    }
                }

                // Update the size values
                wLen = ROUNDUP(pNewBlk->wLength,4);
                INCWORDBY(&pNewVerStamp->wLength, wLen);
                INCWORDBY(&pNewStringInfoBlk->wLength, wLen);
                INCWORDBY(&pNewStringTblBlk->wLength, wLen);

                // Go to the next data block in the old version info
                wLen = ROUNDUP(pVerBlk->wLength,4);
                pVerBlk = (PVERBLOCK)((PBYTE)pVerBlk + wLen);

                DECWORDBY(&wDataLen,        wLen);
                DECWORDBY(&wStringInfoLen,  wLen);
                DECWORDBY(&wStringTableLen, wLen);

                // Go to where the next data block in the new version info would be.
                pNewBlk = (PVERBLOCK)((PBYTE)pNewBlk + ROUNDUP(pNewBlk->wLength,4));

            }               //... END while wStringTableLen

            // Copy the rest of the VERBLOCK, this should be the VarFileInfo part.
            if (wDataLen > 0)
            {
                // Update the most outer length info.
                INCWORDBY(&pNewVerStamp->wLength, wDataLen);
                // Update length info
                CopyMemory(pNewBlk, pVerBlk, wDataLen);
            }
            // Set the values to return to the caller.
            *pwSize = pNewVerStamp->wLength;
            *lplpNewVersionInfo = (LPBYTE)pNewVerStamp;

        }   //... END if wStringInfoLen
    }

    // If some thing went wrong in finding the first language common part of the version info
    // we did not update the version info, therefore we have to free the buffer we allocated
    if (*pwSize == 0)
        free (pNewVerStamp);

    return(TRUE);
}

// Try to find the string in our array of version info we can overwrite
// lpKey:    is a pointer to the value string in the old versin info block (UNICODE)
// lpszData: will contain the data string (UNICODE) if we found the value
// pwLen:    pointer to a word which contains the size of the lpszData buffer on input
// if we found the value it contains the length the version info uses as ValueLength
// which is the size in single byte + zero termination
//
BOOL FindVerValue( WCHAR *lpKey, WCHAR *lpszData, WORD *pwLen)
{
    char szValue[MAX_STRING];
    UINT i = 0;

    // Make it a SB character string
    WideCharToMultiByte(CP_ACP, 0, lpKey, -1, szValue, sizeof(szValue), NULL, NULL);

    // Zero out the buffer, I use so that the caller can over write more memory then the
    // data in the string would take up. This is because the data is WORD aligned.
    memset(lpszData, 0, *pwLen);

    while (i < VerInfoElem) 
    {
        if (lstrcmpi(Verinfo_Array[i].lpszName, szValue) == 0)
        {
            if ((Verinfo_Array[i].szValue[0] != '\0') &&
                (*pwLen >= MEMSIZE(lstrlen(Verinfo_Array[i].szValue) + 1) ) )
            {
                // Convert the ANSI data string into UNICODE
                *pwLen  = (WORD)MultiByteToWideChar(CP_ACP, 0, Verinfo_Array[i].szValue, -1 ,
                                        lpszData, *pwLen);
            }
            i = VerInfoElem;    // Stop searching
        }
        i++;
    }
    // Return if we found the value and the array contained data.
    return (*lpszData != '\0');
}

BOOL CALLBACK MyEnumLangsFunc(HANDLE hModule, LPSTR lpType, LPSTR lpName, WORD languages, LONG lParam)
{
    // The first language we find is OK.
    wVerLang = languages;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\exescan\crc32.h ===
/*
 *  CRC32.H -- CRC32 computation
 */

#define CRC32_INITIAL_VALUE 0L

/*
 *  GenerateCRC32Table - Construct CRC-32 constant table
 *
 *  We construct the table on-the-fly because the code needed
 *  to do build it is much smaller than the table it creates.
 *
 *  Entry:
 *      none
 *
 *  Exit:
 *      internal table constructed
 */

void GenerateCRC32Table(void);


/*
 *  CRC32Update - Update CRC32 value from a buffer
 *
 *  Entry:
 *      GenerateCRC32Table() has been called
 *      pCRC32  pointer to CRC32 accumulator
 *      p       pointer to buffer to compute CRC on
 *      cb      count of bytes in buffer
 *
 *  Exit:
 *      *pCRC32 updated
 */

void CRC32Update(unsigned long *pCRC32,void *p,unsigned long cb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\exescan\crc32.c ===
/*
 *  CRC32.C -- CRC32 computation
 */

#include "crc32.h"

long crc32Table[256];

/*
 *  GenerateCRC32Table - Construct CRC-32 constant table
 *
 *  We construct the table on-the-fly because the code needed
 *  to do build it is much smaller than the table it creates.
 */

void GenerateCRC32Table(void)
{
    int iIndex;
    int cBit;
    long shiftIn;
    long shiftOut;

    for (iIndex = 0; iIndex < 256; iIndex++)
    {
        shiftOut = iIndex;
        shiftIn = 0;

        for (cBit = 0; cBit < 8; cBit++)
        {
            shiftIn <<= 1;
            shiftIn |= (shiftOut & 1);
            shiftOut >>= 1;
        }

        shiftIn <<= 24;

        for (cBit = 0; cBit < 8; cBit++)
        {
            if (shiftIn & 0x80000000L)
            {
                shiftIn = (shiftIn << 1) ^ 0x04C11DB7L;
            }
            else
            {
                shiftIn <<= 1;
            }
        }

        for (cBit = 0; cBit < 32; cBit++)
        {
            shiftOut <<= 1;
            shiftOut |= (shiftIn & 1);
            shiftIn >>= 1;
        }

        crc32Table[iIndex] = shiftOut;
    }
}


/*
 *  update CRC32 accumulator from contents of a buffer
 */

void CRC32Update(unsigned long *pCRC32,void *p,unsigned long cb)
{
    unsigned char *pb = p;
    unsigned long crc32;

    crc32 = (-1L - *pCRC32);

    while (cb--)
    {
        crc32 = crc32Table[(unsigned char)crc32 ^ *pb++] ^
                ((crc32 >> 8) & 0x00FFFFFFL);
    }

    *pCRC32 = (-1L - crc32);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\updfile\resource.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* RESOURCE.H                                                              *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* STRING RESOURCE IDS                                                     *
//***************************************************************************
#define IDS_SUCCESS             1000

#define IDS_ERR_INVALID_ARGS    1100
#define IDS_ERR_GET_FULL_PATH   1101
#define IDS_ERR_FILE_NOT_EXIST  1102
#define IDS_ERR_LOAD_EXE        1103
#define IDS_ERR_BEGIN_UPD_RES   1104
#define IDS_ERR_OPEN_INPUT_FILE 1105
#define IDS_ERR_NO_MEMORY       1106
#define IDS_ERR_READ_INPUT_FILE 1107
#define IDS_ERR_UPDATE_RES      1108
#define IDS_ERR_END_UPD_RES     1109
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\exescan\exescan.c ===
#include <windows.h>
#include <stdio.h>

#include "chksect.h"


#define     SYMBOL(x)       #x

static char *pszResult[] =
{
    SYMBOL(SELFTEST_NO_ERROR),
    SYMBOL(SELFTEST_NO_MEMORY),
    SYMBOL(SELFTEST_FILE_NOT_FOUND),
    SYMBOL(SELFTEST_READ_ERROR),
    SYMBOL(SELFTEST_WRITE_ERROR),
    SYMBOL(SELFTEST_NOT_PE_FILE),
    SYMBOL(SELFTEST_NO_SECTION),
    SYMBOL(SELFTEST_FAILED),
    SYMBOL(SELFTEST_ALREADY),
    SYMBOL(SELFTEST_SIGNED),
    SYMBOL(SELFTEST_DIRTY)
};


int __cdecl main(int argc,char *argv[])
{
    enum SELFTEST_RESULT result;

    if ((sizeof(pszResult) / sizeof(pszResult[0])) != SELFTEST_MAX_RESULT)
    {
        fprintf(stderr,"pszResult[] is incomplete\n");
        return(1);
    }

    if (argc != 2)
    {
        fprintf(stderr,"\n"
                "Microsoft (R) Self-Extractor Scanning Tool - Version 1.0 (07/03/97 - msliger)\n"
                "Copyright (c) Microsoft Corp 1997. All rights reserved.\n"
                "\n"
                "MICROSOFT INTERNAL USE ONLY\n"
                "\n"
                "Usage:   EXESCAN {package.exe}\n");
        return(1);
    }

    result = CheckSection(argv[1]);

    if (result != SELFTEST_NO_ERROR)
    {
        if (result >= SELFTEST_MAX_RESULT)
        {
            printf("EXESCAN: Result=%d (undefined)\n",result);
        }
        else
        {
            printf("EXESCAN: Result=%s\n",pszResult[result]);
        }
    }

    printf("[errorlevel=%d]\n",result);

    return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\setup\iexpress\updfile\updfile.c ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* UPDFILE.C                                                               *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <stdio.h>
//#include <stdlib.h>
#include <wtypes.h>
#include "resource.h"
#include "updfile.h"
#include "updres.h"


//***************************************************************************
//* GLOBAL VARIABLES                                                        *
//***************************************************************************



//***************************************************************************
//*                                                                         *
//* NAME:       main                                                        *
//*                                                                         *
//* SYNOPSIS:   Main entry point for the program.                           *
//*                                                                   