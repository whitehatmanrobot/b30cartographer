   // BUGBUG: Color Space handling
            pcmnbrush->BrushType = kBrushTypeSolid;
            pcmnbrush->dwColor = BRUSHOBJ_ulGetBrushColor(pbo); 

            XL_VERBOSE(("XLOutput::SetupBrush(RGB=0x%x)\n", pcmnbrush->dwColor));
            {
                ubyte ubyte_gray = (ubyte) DWORD2GRAY(pcmnbrush->dwColor);
                SetGrayLevel(ubyte_gray);
            }
            break;

        default:
            if (NULL == pBrush)
            {
                XL_ERR(("XLOutput:SetupBrush: invalid pBrush\n"));
                return;
            }

            XL_VERBOSE(("XLOutput::SetupBrush(PatternID=%d)\n", pBrush->dwPatternID));

            pcmnbrush->dwColor = pBrush->dwColor;
            pcmnbrush->dwPatternBrushID = pBrush->dwPatternID;
            pcmnbrush->BrushType = kBrushTypePattern;

            SetColorSpace(eGray);
            SetPaletteDepth(e8Bit);
            if (pBrush->dwCEntries)
            {
                SetPaletteData(e8Bit, pBrush->dwCEntries, pBrush->adwColor);
            }
            else
            {
                DWORD dwColorTableTmp[2] = {0x00ffffff, 0x00ffffff};
                dwColorTableTmp[1] = pBrush->dwColor;
                SetPaletteData(e8Bit, 2, dwColorTableTmp);
            }
            Send_cmd(eSetColorSpace);

            //SendPatternSelectID();
            Send_sint16((sint16)pBrush->dwPatternID);
            Send_attr_ubyte(ePatternSelectID);

        }
    }

    return;
}

HRESULT
XLOutput::
SetPenColor(
    BRUSHOBJ *pbo,
    POINTL     *pptlBrushOrg)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLOutput::SetPenColor\n"));
    XLPen *pPen = this;
    CMNBRUSH cmnbrush;

    if (S_OK == pPen->CheckCurrentBrush(pbo))
        return S_OK;

    if (NULL == pbo)
    {
        Send_ubyte(0);
        Send_attr_ubyte(eNullPen);
    }
    SetupBrush(pbo, pptlBrushOrg, &cmnbrush);
    Send_cmd(eSetPenSource);

    pPen->SetBrush(&cmnbrush);

    return S_OK;
}

HRESULT
XLOutput::
SetPen(
    LINEATTRS *plineattrs,
    XFORMOBJ   *pxo)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    LineCap linecap;
    XLLineEndCap xllinecap;
    LineJoin linejoin;
    XLLineJoin xllinejoin;
    FLOATOBJ fLineWidth;
    uint16 uint16_linewidth;

    XL_VERBOSE(("XLOutput::SetPen\n"));

    if (NULL == plineattrs)
    {
        XL_ERR(("XLOutput:SetPen: invalid parameters\n"));
        return E_UNEXPECTED;
    }

    XLGState *pGState = this;

    DWORD dwLine = pGState->GetDifferentAttribute(plineattrs);

    //
    // DCR: need to check each attribute.
    //
    if (XLLINE_NONE ==  dwLine)
        return S_OK;

    if (plineattrs->fl & LA_GEOMETRIC)
    {
        //
        // Line joint
        //
        switch(plineattrs->iJoin)
        {
            case JOIN_ROUND:
                linejoin = eRoundJoin;
                xllinejoin = kXLLineJoin_Round;
                break;
            case JOIN_BEVEL:
                linejoin = eBevelJoin;
                xllinejoin = kXLLineJoin_Bevel;
                break;
            case JOIN_MITER:
                linejoin = eMiterJoin;
                xllinejoin = kXLLineJoin_Miter;
                break;
            default:
                linejoin = eRoundJoin;
                xllinejoin = kXLLineJoin_Round;
                break;
        }

        //
        // Line endcap
        //
        switch(plineattrs->iEndCap)
        {
            case ENDCAP_ROUND:
                linecap = eRoundCap;
                xllinecap = kXLLineEndCapRound;
                break;
            case ENDCAP_SQUARE:
                linecap = eSquareCap;
                xllinecap = kXLLineEndCapSquare;
                break;
            case ENDCAP_BUTT:
                linecap = eButtCap;
                xllinecap = kXLLineEndCapButt;
                break;
            default:
                linecap = eRoundCap;
                xllinecap = kXLLineEndCapRound;
                break;
        }
        
        //
        // Line width
        //

        fLineWidth = plineattrs->elWidth.e;

    }
    else
    {
        linejoin = eRoundJoin;
        linecap = eRoundCap;
        FLOATOBJ_SetLong(&fLineWidth, plineattrs->elWidth.l);
    }

    if (dwLine & XLLINE_WIDTH)
    {
        uint16_linewidth = (uint16)FLOATOBJ_GetLong(&fLineWidth);
        SetPenWidth(uint16_linewidth);
        pGState->SetLineWidth(plineattrs->elWidth);
    }
    if (dwLine & XLLINE_ENDCAP)
    {
        SetLineCap(linecap);
        pGState->SetLineEndCap(xllinecap);
    }
    if (dwLine & XLLINE_JOIN)
    {
        SetLineJoin(linejoin);
        pGState->SetLineJoin(xllinejoin);
    }


    //
    // Line style
    //
    if (dwLine & XLLINE_STYLE)
    {
        if (plineattrs->cstyle == 0)
        {
            Send_ubyte((ubyte)0);
            Send_attr_ubyte(eSolidLine);
            Send_cmd(eSetLineDash);
        }
        else
        {
            DWORD dwI, dwSegCount;
            PFLOAT_LONG plSize;
            FLOAT_LONG lSize[2];
            FLOATOBJ fSize;
            uint16 uint16_linesize;

            if (plineattrs->fl & LA_ALTERNATE)
            {
                if (plineattrs->fl & LA_GEOMETRIC)
                {
                    FLOATOBJ_SetLong(&lSize[0].e, 1);
                    FLOATOBJ_SetLong(&lSize[1].e, 1);
                }
                else
                {
                    lSize[0].l = 1;
                    lSize[1].l = 1;
                }

                dwSegCount = 2;
                plSize     = lSize;
            }
            else
            {
                dwSegCount = plineattrs->cstyle;
                plSize = plineattrs->pstyle;
            }
            if (plSize)
            {
                Send_uint16_array_header(dwSegCount);
                for (dwI = 0; dwI < dwSegCount; dwI ++, plSize ++)
                {
                    if (plineattrs->fl & LA_GEOMETRIC)
                    {
                        fSize = plSize->e;
                    }
                    else
                    {
                        FLOATOBJ_SetLong(&fSize, plSize->l);

                        //
                        // It is necessary to scale the line pattern. The number
                        // 24 on 1200 dpi was introduced experimentally.
                        // Here is an assumption. Resolution could be 300, 600,
                        // or 1200.
                        //
                        if (m_dwResolution > 50)
                        {
                            FLOATOBJ_MulLong(&fSize, m_dwResolution / 50);
                        }
                    }
                    uint16_linesize = (uint16)FLOATOBJ_GetLong(&fSize);
                    Write((PBYTE)&uint16_linesize, sizeof(uint16_linesize));
                }
                Send_attr_ubyte(eLineDashStyle);
                Send_cmd(eSetLineDash);
            }
        }

        pGState->SetLineStyle(plineattrs->cstyle,
                              plineattrs->pstyle,
                              plineattrs->elStyleState);
    }

    if (dwLine & XLLINE_MITERLIMIT)
    {
        FLOATOBJ fMiter;
        FLOATOBJ_SetFloat(&fMiter, plineattrs->eMiterLimit);
        uint16 uint16_miter = (uint16)FLOATOBJ_GetLong(&fMiter);

        //
        // PCLXL interpreter doesn't accept miterlimiter less than 1.
        // If it is less than 1, it replaces the value with 10.
        // We'd better set 1 instead.
        //
        // Actuall less than 1 means 0 here, though.
        //
        if (uint16_miter < 1)
        {
            uint16_miter = 1;
        }
        SetMiterLimit(uint16_miter);
        pGState->SetMiterLimit(plineattrs->eMiterLimit);
    }

    pGState->SetLineType((XLLineType)plineattrs->fl);
    return S_OK;
}

HRESULT
XLOutput::
SetBrush(
    BRUSHOBJ *pbo,
    POINTL   *pptlBrushOrg)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLOutput::SetBrush\n"));
    XLBrush *pBrush = this;
    CMNBRUSH cmnbrush;

    if (S_OK == pBrush->CheckCurrentBrush(pbo))
        return S_OK;

    if (NULL == pbo)
    {
        Send_ubyte(0);
        Send_attr_ubyte(eNullBrush);
    }

    SetupBrush(pbo, pptlBrushOrg, &cmnbrush);
    Send_cmd(eSetBrushSource);

    pBrush->SetBrush(&cmnbrush);
    return S_OK;
}

HRESULT
XLOutput::
Paint(
    VOID)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XL_VERBOSE(("XLOutput::Paint\n"));
    return Send_cmd(ePaintPath);
}

HRESULT
XLOutput::
SetPaletteData(
    ColorDepth value,
    DWORD      dwPaletteNum,
    DWORD     *pdwColorTable)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    DWORD dwI;

    if (NULL == pdwColorTable)
    {
        XL_ERR(("XLOutput::SetPaletteData pdwColorTable == NULL\n"));
        return E_UNEXPECTED;
    }
    switch (value)
    {
    case e8Bit:
        WriteByte(PCLXL_ubyte_array);
        Send_uint16((uint16)dwPaletteNum);
        for (dwI = 0; dwI < dwPaletteNum; dwI ++)
            WriteByte((ubyte)DWORD2GRAY(*(pdwColorTable+dwI)));
        Send_attr_ubyte(ePaletteData);
        break;
    default:
        //
        // DCR: only supports 8bits gray scale
        //
        XL_ERR(("XLOutput::SetPaletteData: unsupported ColorDepth:%d\n", value));
    }

    return S_OK;
}

HRESULT
XLOutput::
SetFont(
    FontType fonttype,
    PBYTE    pFontName,
    DWORD    dwFontHeight,
    DWORD    dwFontWidth,
    DWORD    dwSymbolSet,
    DWORD    dwFontSimulation)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    FLOATOBJ fSize;
    LONG lvalue;

    if (NULL == pFontName)
    {
        XL_ERR(("XLOutput::SetFont: Invalie pFontName parameter\n"));
        return E_UNEXPECTED;
    }

    XLGState *pGState = this;

    if (S_OK == pGState->CheckCurrentFont(fonttype,
	          pFontName,
	          dwFontHeight,
	          dwFontWidth,
	          dwSymbolSet,
	          dwFontSimulation))
        return S_OK;

    FLOATOBJ_SetLong(&fSize, dwFontHeight);
    lvalue = FLOATOBJ_GetFloat(&fSize);

    //
    // Select font
    //
    Send_ubyte_array_header(PCLXL_FONTNAME_SIZE);
    Write(pFontName, PCLXL_FONTNAME_SIZE);
    Send_attr_ubyte(eFontName);
    Send_real32(lvalue);
    Send_attr_ubyte(eCharSize);
    Send_uint16((uint16)dwSymbolSet);
    Send_attr_ubyte(eSymbolSet);
    Send_cmd(eSetFont);

    //
    // TrueType font outline or device font
    // Font Scale
    // Font bold/italic simulaiton
    //
    if (fonttype == kFontTypeTTOutline ||
        fonttype == kFontTypeDevice     )
    {

        if (dwFontWidth != pGState->GetFontWidth() ||
            dwFontHeight != pGState->GetFontHeight()  )
        {
            //
            // Scale X and Y
            //
            if (dwFontWidth != 0 && dwFontHeight != dwFontWidth)
            {
                FLOATOBJ fTemp;
                FLOATOBJ_SetLong(&fTemp, dwFontWidth);
                FLOATOBJ_DivFloat(&fTemp, fSize);
                lvalue = FLOATOBJ_GetFloat(&fTemp);
                Send_real32_xy((real32)lvalue, (real32)real32_IEEE_1_0F);
                Send_attr_ubyte(eCharScale);
                Send_cmd(eSetCharScale);
            }
            else
            {
                Send_real32_xy((real32)real32_IEEE_1_0F, (real32)real32_IEEE_1_0F);
                Send_attr_ubyte(eCharScale);
                Send_cmd(eSetCharScale);
            }
        }

        DWORD dwCurrentFontSim = pGState->GetFontSimulation();

        //
        // Bold simulation
        //
        if ((dwFontSimulation & XLOUTPUT_FONTSIM_BOLD) !=
            (dwCurrentFontSim& XLOUTPUT_FONTSIM_BOLD))
        {
            if (dwFontSimulation & XLOUTPUT_FONTSIM_BOLD)
            {
                //
                // Hardcoded bold value 0.01500
                //
                #define XL_BOLD_VALUE 0x3c75c28f

                Send_real32((real32)XL_BOLD_VALUE);
            }
            else
                Send_real32((real32)0);

            Send_attr_ubyte(eCharBoldValue);
            Send_cmd(eSetCharBoldValue);
        }

        //
        // Italic simulation
        //
        if ((dwFontSimulation & XLOUTPUT_FONTSIM_ITALIC) !=
            (dwCurrentFontSim & XLOUTPUT_FONTSIM_ITALIC))
        {
            if (dwFontSimulation & XLOUTPUT_FONTSIM_ITALIC)
            {
                //
                // Hardcoded italic value 0.316200
                //
                #define XL_ITALIC_VALUE 0x3ea1e4f7
                Send_real32_xy((real32)XL_ITALIC_VALUE, (real32)0);
            }
            else
                Send_real32_xy((real32)0, (real32)0);

            Send_attr_ubyte(eCharShear);
            Send_cmd(eSetCharShear);
        }

        //
        // Vertical font simulation
        //
        if ((dwFontSimulation & XLOUTPUT_FONTSIM_VERTICAL) !=
            (dwCurrentFontSim & XLOUTPUT_FONTSIM_VERTICAL))
        {
            if (dwFontSimulation & XLOUTPUT_FONTSIM_VERTICAL)
            {
                Send_ubyte(eVertical);
            }
            else
            {
                Send_ubyte(eHorizontal);
            }
            Send_attr_ubyte(eWritingMode);
            Send_cmd(eSetCharAttributes);
        }
    }
    else
    {
        if (kFontTypeTTBitmap != pGState->GetFontType())
        {
            //
            // Bitmap font can't be scaled x and y. Need to set 1 : 1.
            //
            Send_real32_xy((real32)real32_IEEE_1_0F, (real32)real32_IEEE_1_0F);
            Send_attr_ubyte(eCharScale);
            Send_cmd(eSetCharScale);
        }
    }

    //
    // Change GState to set current selected font.
    //
    pGState->SetFont(fonttype,
                     pFontName,
                     dwFontHeight,
                     dwFontWidth,
                     dwSymbolSet,
                     dwFontSimulation);


    return S_OK;
}


HRESULT
XLOutput::
SetSourceTxMode(
    TxMode SrcTxMode)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XLGState *pGState = this;
    if (SrcTxMode == pGState->GetSourceTxMode())
    {
        return S_OK;
    }

    if (S_OK == SetTxMode(SrcTxMode) &&
        S_OK == Send_cmd(eSetSourceTxMode))
    {
        pGState->SetSourceTxMode(SrcTxMode);
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT
XLOutput::
SetPaintTxMode(
    TxMode PaintTxMode)
/*++

Routine Description:

Arguments:

Return Value:

Note:

--*/
{
    XLGState *pGState = this;
    if (PaintTxMode == pGState->GetPaintTxMode())
    {
        return S_OK;
    }

    if (S_OK == SetTxMode(PaintTxMode) &&
        S_OK == Send_cmd(eSetPatternTxMode))
    {
        pGState->SetPaintTxMode(PaintTxMode);
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\font.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    font.cpp

Abstract:

    PCL XL minidriver plug-in font managing header file

Environment:

    Windows Whistler

Revision History:

    08/23/99 
      Created it.

--*/

tyedef enum {
    eXLNull,
    eXLTrueType,
    eXLDevice,
    eXLSubstitution
} XLFontType;

typedef enum {
    eXLTTNull,
    eXLTTBitmap,
    eXLTTTrueType
} XLTrueTypeFontType;

class XLFont
{
public:
    XLFont:
    XLFont();

    XLFont::
    ~XLFont();

    HRESULT SetFont(FONTOBJ *pfo, STROBJ *pstro);
    HRESULT SetSubstitutionTable(TTSUBST_TABLE* pTable);
    HRESULT SetTTDownloadType(XLTrueTypeFontType TTType);
    HRESULT SetUFM(UNIFM_HDR *pUFM);
    HRESULT SetGTT(UNI_GLYPHSETDATA *pGTT);

    //
    // Functions to emit commands
    //
    HRESULT DownloadFont();
    HRESULT SelectFont();
    HRESULT SendString();

private:
    //
    // DDI parameters
    //
    STROBJ            *m_pstro;
    FONTOBJ           *m_pfo;
    IFIMETRICS        *m_pifi;

    //
    // font info
    //
    XLFontType         m_FontType;
    XLTrueTypeFontType m_TrueTypeType;
    DWORD              m_dwFlags;
    CHAR               m_ubFontName[17];
    FLOATOBJ           m_floHeight;
    FLOATOBJ           m_floWidth;
    UNIFM_HDR         *m_pUFM;
    UNI_GLYPHSETDATA  *m_pGTT;

    TTSUBST_TABLE      m_pTTSubTbl;
};


XLFont::
XLFont()
{
    m_FontType = eXLNull;
    m_TrueTypeType = eXLTTNull;
    m_dwFlags = 0;
}

XLFont::
~XLFont()
{
}

HRESULT
XLFont::
SetFont(
    FONTOBJ *pfo,
    STROBJ  *pstro)
{
    m_pstro = pstro;
    m_pfo   = pfo;
    m_pifi  = FONTOBJ_pifi(pfo);

    if (pfo->flFontType & DEVICEFONT_FONTTYPE)
    {
        m_FontType = eXLDevice;
    }
    else
    {
        // !!Need to consider font substitution.
        m_FontType = eXLTrueType;
    }
    return S_OK;
}

HRESULT
XLFont::
SetTTDownloadType(
    XLTrueTypeFontType TTType)
{
    m_TrueTypeType = TTType;
    return S_OK;
}

HRESULT
XLFont::
SetSubstitutionTable(
    TTSUBST_TABLE* pTable)
{
    m_pTTSUbTbl = pTable;
    return S_OK;
}


HRESULT
XLFont::
SetUFM(
    UNIFM_HDR *pUFM)
{
    m_pUFM = pUFM;
    return S_OK;
}

HRESULT
XLFont::
SetGTT(
    UNI_GLYPHSETDATA *pGTT)
{
    m_pGTT = pGTT;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\pclxlcmd.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pclxlcmd.cpp

Abstract:

    PCL-XL command definition

Environment:

    Windows Whistler

Revision History:

    08/23/99     
        Created it.

Note:

    Please refer to PCL XL Feature Reference Protocol Class 2.0

--*/

#include "xlpdev.h"
#include "pclxlcmd.h"

//
// Binary Stream Tag
//

const BYTE PCLXL_NULL  = 0x00;
const BYTE PCLXL_HT    = 0x09;
const BYTE PCLXL_LF    = 0x0a;
const BYTE PCLXL_VT    = 0x0b;
const BYTE PCLXL_FF    = 0x0c;
const BYTE PCLXL_CR    = 0x0d;
const BYTE PCLXL_SP    = 0x20;

const BYTE PCLXL_BeginSession = 0x41;
const BYTE PCLXL_EndSession   = 0x42;
const BYTE PCLXL_BeginPage    = 0x43;
const BYTE PCLXL_EndPage      = 0x44;

const BYTE PCLXL_Comment         = 0x47;
const BYTE PCLXL_OpenDataSource  = 0x48;
const BYTE PCLXL_CloseDataSource = 0x49;

const BYTE PCLXL_BeginFontHeader = 0x4f;
const BYTE PCLXL_ReadFontHeader  = 0x50;
const BYTE PCLXL_EndFontHeader   = 0x51;
const BYTE PCLXL_BeginChar       = 0x52;
const BYTE PCLXL_ReadChar        = 0x53;
const BYTE PCLXL_EndChar         = 0x54;
const BYTE PCLXL_RemoveFont      = 0x55;

const BYTE PCLXL_BeginStream = 0x5b;
const BYTE PCLXL_ReadStream  = 0x5c;
const BYTE PCLXL_EndStream   = 0x5d;
const BYTE PCLXL_ExecStream  = 0x5e;


const BYTE PCLXL_PopGS  = 0x60;
const BYTE PCLXL_PushGS = 0x61;

const BYTE PCLXL_SetClipReplace    = 0x62;
const BYTE PCLXL_SetBrushSource    = 0x63;
const BYTE PCLXL_SetCharAngle      = 0x64;
const BYTE PCLXL_SetCharScale      = 0x65;
const BYTE PCLXL_SetCharShear      = 0x66;
const BYTE PCLXL_SetClipIntersect  = 0x67;
const BYTE PCLXL_SetClipRectangle  = 0x68;
const BYTE PCLXL_SetClipToPage     = 0x69;
const BYTE PCLXL_SetColorSpace     = 0x6a;
const BYTE PCLXL_SetCursor         = 0x6b;
const BYTE PCLXL_SetCursorRel      = 0x6c;
const BYTE PCLXL_SetHalftoneMethod = 0x6d;
const BYTE PCLXL_SetFillMode       = 0x6e;
const BYTE PCLXL_SetFont           = 0x6f;

const BYTE PCLXL_SetLineDash       = 0x70;
const BYTE PCLXL_SetLineCap        = 0x71;
const BYTE PCLXL_SetLineJoin       = 0x72;
const BYTE PCLXL_SetMiterLimit     = 0x73;
const BYTE PCLXL_SetPageDefaultCTM = 0x74;
const BYTE PCLXL_SetPageOrigin     = 0x75;
const BYTE PCLXL_SetPageRotation   = 0x76;
const BYTE PCLXL_SetPageScale      = 0x77;
const BYTE PCLXL_SetPatternTxMode  = 0x78;
const BYTE PCLXL_SetPenSource      = 0x79;
const BYTE PCLXL_SetPenWidth       = 0x7a;
const BYTE PCLXL_SetROP            = 0x7b;
const BYTE PCLXL_SetSourceTxMode   = 0x7c;
const BYTE PCLXL_SetCharBoldValue  = 0x7d;

const BYTE PCLXL_SetClipMode       = 0x7f;
const BYTE PCLXL_SetPathToClip     = 0x80;
const BYTE PCLXL_SetCharSubMode    = 0x81;

const BYTE PCLXL_CloseSubPath      = 0x84;
const BYTE PCLXL_NewPath           = 0x85;
const BYTE PCLXL_PaintPath         = 0x86;

const BYTE PCLXL_ArcPath           = 0x91;

const BYTE PCLXL_BezierPath        = 0x93;

const BYTE PCLXL_BezierRelPath     = 0x95;
const BYTE PCLXL_Chord             = 0x96;
const BYTE PCLXL_ChordPath         = 0x97;
const BYTE PCLXL_Ellipse           = 0x98;
const BYTE PCLXL_EllipsePath       = 0x99;

const BYTE PCLXL_LinePath          = 0x9b;

const BYTE PCLXL_LineRelPath       = 0x9d;
const BYTE PCLXL_Pie               = 0x9e;
const BYTE PCLXL_PiePath           = 0x9f;

const BYTE PCLXL_Rectangle         = 0xa0;
const BYTE PCLXL_RectanglePath     = 0xa1;
const BYTE PCLXL_RoundRectangle    = 0xa2;
const BYTE PCLXL_RoundRectanglePath= 0xa3;

const BYTE PCLXL_Text     = 0xa8;
const BYTE PCLXL_TextPath = 0xa9;

const BYTE PCLXL_BeginImage       = 0xb0;
const BYTE PCLXL_ReadImage        = 0xb1;
const BYTE PCLXL_EndImage         = 0xb2;
const BYTE PCLXL_BeginRestPattern = 0xb3;
const BYTE PCLXL_ReadRastPattern  = 0xb4;
const BYTE PCLXL_EndRastPattern   = 0xb5;
const BYTE PCLXL_BeginScan        = 0xb6;

const BYTE PCLXL_EndScan     = 0xb8;
const BYTE PCLXL_ScanLineRel = 0xb9;

const BYTE PCLXL_ubyte  = 0xc0;
const BYTE PCLXL_uint16 = 0xc1;
const BYTE PCLXL_uint32 = 0xc2;
const BYTE PCLXL_sint16 = 0xc3;
const BYTE PCLXL_sint32 = 0xc4;
const BYTE PCLXL_real32 = 0xc5;

const BYTE PCLXL_ubyte_array  = 0xc8;
const BYTE PCLXL_uint16_array = 0xc9;
const BYTE PCLXL_uint32_array = 0xca;
const BYTE PCLXL_sint16_array = 0xcb;
const BYTE PCLXL_sint32_array = 0xcc;
const BYTE PCLXL_real32_array = 0xcd;

const BYTE PCLXL_ubyte_xy  = 0xd0;
const BYTE PCLXL_uint16_xy = 0xd1;
const BYTE PCLXL_uint32_xy = 0xd2;
const BYTE PCLXL_sint16_xy = 0xd3;
const BYTE PCLXL_sint32_xy = 0xd4;
const BYTE PCLXL_real32_xy = 0xd5;

const BYTE PCLXL_ubyte_box = 0xe0;
const BYTE PCLXL_uint16_box = 0xe1;
const BYTE PCLXL_uint32_box = 0xe2;
const BYTE PCLXL_sint16_box = 0xe3;
const BYTE PCLXL_sint32_box = 0xe4;
const BYTE PCLXL_real32_box = 0xe5;

const BYTE PCLXL_attr_ubyte  = 0xf8;
const BYTE PCLXL_attr_uint16 = 0xf9;

const BYTE PCLXL_dataLength = 0xfa;

const BYTE PCLXL_dataLengthByte = 0xfb;


//
// Attribute tag
//

const BYTE PCLXL_PaletteDepth =      0x02;
const BYTE PCLXL_ColorSpace =        0x03;
const BYTE PCLXL_NullBrush =         0x04;
const BYTE PCLXL_NullPen =           0x05;
const BYTE PCLXL_PaleteData =        0x06;

const BYTE PCLXL_PatternSelectID =   0x08;
const BYTE PCLXL_GrayLevel =         0x09;

const BYTE PCLXL_RGBColor =          0x0b;
const BYTE PCLXL_PatternOrigin =     0x0c;
const BYTE PCLXL_NewDestinationSize =0x0d;

const BYTE PCLXL_ColorimetricColorSpace = 0x11;

const BYTE PCLXL_DeviceMatrix =        0x21;
const BYTE PCLXL_DitherMatrixDataType =0x22;
const BYTE PCLXL_DitherOrigin =        0x23;
const BYTE PCLXL_MediaDestination =    0x24;
const BYTE PCLXL_MediaSize =           0x25;
const BYTE PCLXL_MediaSource =         0x26;
const BYTE PCLXL_MediaType =           0x27;
const BYTE PCLXL_Orientation =         0x28;
const BYTE PCLXL_PageAngle =           0x29;
const BYTE PCLXL_PageOrigin =          0x2a;
const BYTE PCLXL_PageScale =           0x2b;
const BYTE PCLXL_ROP3 =                0x2c;
const BYTE PCLXL_TxMode =              0x2d;

const BYTE PCLXL_CustomMediaSize =     0x2f;

const BYTE PCLXL_CustomMediaSizeUnits =0x30;
const BYTE PCLXL_PageCopies =          0x31;
const BYTE PCLXL_DitherMatrixSize =    0x32;
const BYTE PCLXL_DithermatrixDepth =   0x33;
const BYTE PCLXL_SimplexPageMode =     0x34;
const BYTE PCLXL_DuplexPageMode =      0x35;
const BYTE PCLXL_DuplexPageSide =      0x36;

const BYTE PCLXL_ArcDirection =    0x41;
const BYTE PCLXL_BoundingBox =     0x42;
const BYTE PCLXL_DashOffset =      0x43;
const BYTE PCLXL_EllipseDimension =0x44;
const BYTE PCLXL_EndPoint =        0x45;
const BYTE PCLXL_FillMode =        0x46;
const BYTE PCLXL_LineCap      =    0x47;
const BYTE PCLXL_LineJoin       =  0x48;
const BYTE PCLXL_MiterLength =     0x49;
const BYTE PCLXL_PenDashStyle =    0x4a;
const BYTE PCLXL_PenWidth =        0x4b;
const BYTE PCLXL_Point =           0x4c;
const BYTE PCLXL_NumberOfPoints =  0x4d;
const BYTE PCLXL_SolidLine =       0x4e;
const BYTE PCLXL_StartPoint =      0x4f;

const BYTE PCLXL_PointType =       0x50;
const BYTE PCLXL_ControlPoint1 =   0x51;
const BYTE PCLXL_ControlPoint2 =   0x52;
const BYTE PCLXL_ClipRegion =      0x53;
const BYTE PCLXL_ClipMode =        0x54;

const BYTE PCLXL_ColorDepth =        0x62;
const BYTE PCLXL_BlockHeight =       0x63;
const BYTE PCLXL_ColorMapping =      0x64;
const BYTE PCLXL_CompressMode =      0x65;
const BYTE PCLXL_DestinationBox =    0x66;
const BYTE PCLXL_DestinationSize =   0x67;
const BYTE PCLXL_PatternPersistence =0x68;
const BYTE PCLXL_PatternDefineID =   0x69;

const BYTE PCLXL_SourceHeight =      0x6b;
const BYTE PCLXL_SourceWidth =       0x6c;
const BYTE PCLXL_StartLine =         0x6d;
const BYTE PCLXL_XPairType =         0x6e;
const BYTE PCLXL_NumberOfXPairs =    0x6f;

const BYTE PCLXL_XStart =            0x70;
const BYTE PCLXL_XEnd =              0x71;
const BYTE PCLXL_NumberOfScanLines = 0x72;

const BYTE PCLXL_CommentData =     0x81;
const BYTE PCLXL_DataOrg =         0x82;

const BYTE PCLXL_Measure =         0x86;

const BYTE PCLXL_SourceType =      0x88;
const BYTE PCLXL_UnitsPerMeasure = 0x89;

const BYTE PCLXL_StreamName =      0x8b;
const BYTE PCLXL_StreamDataLength =0x8c;

const BYTE PCLXL_ErrorReport =     0x8f;

const BYTE PCLXL_CharAngle =        0xa1;
const BYTE PCLXL_CharCode =         0xa2;
const BYTE PCLXL_CharDataSize =     0xa3;
const BYTE PCLXL_CharScale =        0xa4;
const BYTE PCLXL_CharShear =        0xa5;
const BYTE PCLXL_CharSize =         0xa6;
const BYTE PCLXL_FontHeaderLength = 0xa7;
const BYTE PCLXL_FontName =         0xa8;
const BYTE PCLXL_FontFormat =       0xa9;
const BYTE PCLXL_SymbolSet =        0xaa;
const BYTE PCLXL_TextData =         0xab;
const BYTE PCLXL_CharSubModeArray = 0xac;

const BYTE PCLXL_XSpacingData =     0xaf;

const BYTE PCLXL_YSpacingData =     0xb0;
const BYTE PCLXL_CharBoldValue =    0xb1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\pclxlcmn.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     pclxlcmn.h

Abstract:

    PCL XL minidriver common utility

Environment:

    Windows Whistler

Revision History:

    08/23/99 
      Created it.

--*/

#include "xlpdev.h"
#include "xldebug.h"
#include "pclxle.h"
#include "xlgstate.h"

BYTE gubFontName[PCLXL_FONTNAME_SIZE+1] = "MS PCLXLFont    ";

PBYTE
PubGetFontName(
    ULONG ulFontID)
/*++

Routine Description:


    Create PCL XL base font name for TrueType font.
    We just know ID for the font.

Arguments:

    Font ID.

Return Value:

    Base font name string.

Note:

--*/
{
    //
    // FaceName initialization "MS PCLXLFont 123"
    // This name has to be in sync with GPD file.
    //

    gubFontName[15] = (BYTE)(ulFontID % 10 + '0');
    ulFontID = ulFontID / 10;
    gubFontName[14] = (BYTE)(ulFontID % 10 + '0');
    ulFontID = ulFontID / 10;
    gubFontName[13] = (BYTE)(ulFontID % 10 + '0');

    return &gubFontName[0];
}

ROP4
UlVectMixToRop4(
    IN MIX mix
    )

/*++

Routine Description:

    Convert a MIX parameter to a ROP4 parameter

Arguments:

    mix - Specifies the input MIX parameter

Return Value:

    ROP4 value corresponding to the input MIX value

--*/

{
    static BYTE Rop2ToRop3[] = {

        0xFF,  // R2_WHITE
        0x00,  // R2_BLACK
        0x05,  // R2_NOTMERGEPEN
        0x0A,  // R2_MASKNOTPEN
        0x0F,  // R2_NOTCOPYPEN
        0x50,  // R2_MASKPENNOT
        0x55,  // R2_NOT
        0x5A,  // R2_XORPEN
        0x5F,  // R2_NOTMASKPEN
        0xA0,  // R2_MASKPEN
        0xA5,  // R2_NOTXORPEN
        0xAA,  // R2_NOP
        0xAF,  // R2_MERGENOTPEN
        0xF0,  // R2_COPYPEN
        0xF5,  // R2_MERGEPENNOT
        0xFA,  // R2_MERGEPEN
        0xFF   // R2_WHITE
    };

    return ((ROP4) Rop2ToRop3[(mix >> 8) & 0xf] << 8) | Rop2ToRop3[mix & 0xf];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\pclxlcmn.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     pclxlcmn.h

Abstract:

    PCL XL minidriver common utility function header file

Environment:

    Windows Whistler

Revision History:

    03/23/00
      Created it.

--*/

#ifndef _PCLXLCMN_H_
#define _PCLXLCMN_H_

#define DATALENGTH_HEADER_SIZE 5

PBYTE
PubGetFontName(
    ULONG ulFontID);

HRESULT
FlushCachedText(
    PDEVOBJ pdevobj);

HRESULT
RemoveAllFonts(
    PDEVOBJ pdevobj);

ROP4
UlVectMixToRop4(
    IN MIX mix);

HRESULT
GetXForm(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    FLOATOBJ_XFORM* pxform);

HRESULT
GetFONTOBJ(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ  pUFObj,
    FONTOBJ **pFontObj);

HRESULT
GetXYScale(
    FLOATOBJ_XFORM *pxform,
    FLOATOBJ *pfoXScale,
    FLOATOBJ *pfoYScale);

HRESULT
IsXYSame(
    FLOATOBJ_XFORM *pxform);

inline
VOID
DetermineOutputFormat(
    INT          iBitmapFormat,
    OutputFormat *pOutputF,
    ULONG        *pulOutputBPP);

extern "C" BOOL
BSaveFont(
    PDEVOBJ pdevobj);
#endif // _PCLXLCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\pclxle.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     pclxle.h

Abstract:

    PCL XL attribute ID enum

Environment:

    Windows Whistler

Revision History:

    03/23/00
      Created it.

--*/

#ifndef _PCLXLE_H_
#define _PCLXLE_H_

//
// Attribute ID Nuber to Attribute Name Table
//

typedef enum
{
    eCMYColor         =  1,
    ePaletteDepth     =  2,
    eColorSpace       =  3,
    eDDColorSpace     = eColorSpace,
    eNullBrush        =  4,
    eNullPen          =  5,
    ePaletteData      =  6,
    ePaletteIndex     =  7,
    ePatternSelectID  =  8,
    eGrayLevel        =  9,
    eSRGBColor        =  10,
    eRGBColor         =  11,
    ePatternOrigin    =  12,
    eNewDestinationSize=  13,
    ePrimaryArray          =  14,
    ePrimaryDepth          =  15,
    eColorimetricColorSpace=  17,
    eXYChromaticities      =  18,
    eWhitePointReference   =  19,
    eCRGBMinMax            =  20,
    eGammaGain             =  21,
    eCIELabColorSpace      =  22,
    eMinimumL              =  23,
    eMaximumL              =  24,
    eMinimumA              =  25,
    eMaximumA              =  26,
    eMinimumB              =  27,
    eMaximumB              =  28,

    eDeviceMatrix     =  33,
    eDitherMatrixDataType =  34,
    eDitherOrigin     =  35,
    eMediaDest        =  36,
    eMediaSize        =  37,
    eMediaSource      =  38,
    eMediaType        =  39,
    eOrientation      =  40,
    ePageAngle        =  41,
    ePageOrigin       =  42,
    ePageScale        =  43,
    eROP3             =  44,
    eTxMode           =  45,
    eCustomMediaSize  =  47,
    eCustomMediaSizeUnits =  48,
    ePageCopies       =  49,
    eDitherMatrixSize =  50,
    eDitherMatrixDepth=  51,
    eSimplexPageMode  =  52,
    eDuplexPageMode   =  53,
    eDuplexPageSide   =  54,
    eArcDirection     =  65,
    eBoundingBox      =  66,
    eDashOffset       =  67,
    eEllipseDimension =  68,
    eEndPoint         =  69,
    eFillMode         =  70,
    eLineCapStyle     =  71,
    eLineJoinStyle    =  72,
    eMiterLength      =  73,
    eLineDashStyle    =  74,
    ePenWidth         =  75,
    ePoint            =  76,
    eNumberOfPoints   =  77,
    eSolidLine        =  78,
    eStartPoint       =  79,
    ePointType        =  80,
    eControlPoint1    =  81,
    eControlPoint2    =  82,
    eClipRegion       =  83,
    eClipMode         =  84,

    eColorDepthArray  =  97,
    eColorDepth       =  98,
    ePixelDepth       = eColorDepth,
    eBlockHeight      =  99,
    eColorMapping     =  100,
    ePixelEncoding    = eColorMapping,
    eCompressMode     =  101,
    eDestinationBox   =  102,
    eDestinationSize  =  103,
    ePatternPersistence=  104,
    ePatternDefineID  =  105,
    eSourceHeight     =  107,
    eSourceWidth      =  108,
    eStartLine        =  109,
    ePadBytesMultiple =  110,
    eBlockByteLength  =  111,
    eYStart           =  112,
    eXStart           =  113,
    eXEnd             =  114,
    eNumberOfScanLines=  115,

    eCommentData      =  129,
    eDataOrg          =  130,
    eMeasure          =  134,
    eSourceType       =  136,
    eUnitsPerMeasure  =  137,
    eQueryKey         =  138,
    eStreamName       =  139,
    eStreamDataLength =  140,


    eErrorReport      =  143,
    eIOReadTimeOut    =  144,


    eVUExtension      =  145,
    eVUDataLength     =  146,
    eVUAttr1          =  147,
    eVUAttr2          =  148,
    eVUAttr3          =  149,
    eVUAttr4          =  150,
    eVUAttr5          =  151,
    eVUAttr6          =  152,
    eVUAttr7          =  153,
    eVUAttr8          =  154,
    eVUAttr9          =  155,
    eVUAttr10         =  156,
    eVUAttr11         =  157,
    eVUAttr12         =  158,
    eVUTableSize         =  146,
    eVUMediaFinish       =  eVUAttr1,
    eVUMediaSource       =  147,
    eVUMediaType         =  148,
    eVUColorTableID      =  147,
    eVUTypeOfTable       =  148,
    eVUDeviceMatrix      =  147,
    eVUDeviceMatrixByID  =  148,
    eVUColorTreatment    =  147,
    eVUColorTreatmentByID=  148,
    ePassThroughCommand=  158,
    ePassThroughArray  =  159,
    eDiagnostics      =  160,
    eCharAngle        =  161,
    eCharCode         =  162,
    eCharDataSize     =  163,
    eCharScale        =  164,
    eCharShear        =  165,
    eCharSize         =  166,
    eFontHeaderLength =  167,
    eFontName         =  168,
    eFontFormat       =  169,
    eSymbolSet        =  170,
    eTextData         =  171,
    eCharSubModeArray =  172,
    eWritingMode      =  173,
    eBitmapCharScale  =  174,
    eXSpacingData     =  175,
    eYSpacingData     =  176,
    eCharBoldValue    =  177
} Attribute;

//
// Atttribute enum
//
typedef enum
{
    eClockWise = 0,
    eCounterClockWise = 1
} ArcDirection;

typedef enum
{
    eNoSubstitution = 0, 
    eVerticalSubstitution = 1
} CharSubModeArray;

typedef enum
{
    eClipNonZeroWinding = 0, 
    eClipEvenOdd = 1
} ClipMode;

typedef enum
{
    eInterior = 0, 
    eExterior = 1
} ClipRegion;

typedef enum
{
    e1Bit  = 0, 
    e4Bit  = 1, 
    e8Bit  = 2,
    e24Bit = 3
} ColorDepth;

typedef enum
{
    eCRGB = 5 
} ColorimetricColorSpace;

typedef enum
{
    eDirectPixel = 0, 
    eIndexedPixel = 1
} ColorMapping;

typedef enum
{
    eGray = 1, 
    eRGB = 2, 
    eSRGB = 6
} ColorSpace;

typedef enum
{
    eNoCompression = 0, 
    eRLECompression = 1, 
    eJPEGCompression = 2
} CompressMode;

typedef enum
{
    eBinaryHighByteFirst = 0, 
    eBinaryLowByteFirst = 1
} DataOrg;

typedef enum
{
    eDefault = 0
} DataSource;

typedef enum
{
    eUByte = 0, 
    eSByte = 1, 
    eUint16 = 2, 
    eSint16 = 3
} DataType;

typedef enum
{
    eDeviceBest = 0
} DitherMatrix;

typedef enum
{
    eDuplexHorizontalBinding = 0, 
    eDuplexVerticalBinding = 1
} DuplexPageMode;

typedef enum
{
    eFrontMediaSide = 0, 
    eBackMediaSide = 1
} DuplexPageSide;

typedef enum
{    
    eBackChannel = 1, 
    eErrorPage = 2, 
    eBackChAndErrPage = 3,
    eNWBackChannel = 4,
    eNWErrorPage = 5,
    eNWBackChAndErrPage = 6
} ErrorReport;

typedef enum
{
    eFillNonZeroWinding = 0, 
    eFillEvenOdd = 1
} FillMode;

typedef enum
{
    eButtCap = 0, 
    eRoundCap = 1, 
    eSquareCap = 2, 
    eTriangleCap = 3
} LineCap;

typedef enum
{
    eMiterJoin = 0, 
    eRoundJoin = 1, 
    eBevelJoin = 2, 
    eNoJoin = 3
} LineJoin;

typedef enum
{
    eInch = 0, 
    eMillimeter = 1, 
    eTenthsOfAMillimeter = 2
} Measure;

typedef enum
{
    eLetterPaper = 0, 
    eLegalPaper = 1, 
    eA4Paper = 2, 
    eExecPaper = 3,
    eLedgerPaper = 4,
    eA3Paper = 5,
    eCOM10Envelope = 6,
    eMonarchEnvelope = 7,
    eC5Envelope = 8,
    eDLEnvelope = 9,
    eJB4Paper = 10,
    eJB5Paper = 11,
    eB5Envelope = 12,
    eJPostcard = 13,
    eJDoublePostcard = 14,
    eA5Paper = 15,
    eA6Paper = 16,
    eJB6Paper = 17
} MediaSize;

typedef enum
{
    eDefaultSource = 0, 
    eAutoSelect = 1, 
    eManualFeed = 2, 
    eMultiPurposeTray = 3,
    eUpperCassette = 4,
    eLowerCassette = 5,
    eEnvelopeTray = 6,
    eThirdCassette = 7
} MediaSource;

// typedef enum External Trays

typedef enum
{
    eDefaultDestination = 0, 
    eFaceDownBin = 1, 
    eFaceUpBin = 2, 
    eJobOffsetBin = 3
} MediaDestination;

// typedef enum External Bins 1-251 5-255

typedef enum
{
    ePortraitOrientation = 0, 
    eLandscapeOrientation = 1, 
    eReversePortrait = 2, 
    eReverseLandscape = 3
} Orientation;

typedef enum
{
    eTempPattern = 0, 
    ePagePattern = 1, 
    eSessionPattern = 2
} PatternPersistence;


// BUGBUG!! symbol set enum.
//typedef enum SymbolSet
//{
//};

typedef enum
{
    eSimplexFrontSide = 0
} SimplexPageMode;

typedef enum
{
    eOpaque = 0, 
    eTransparent = 1,
    eNotSet = 2
} TxMode;

typedef enum
{
    eHorizontal = 0, 
    eVertical = 1
} WritingMode;

#endif // _PCLXLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\text.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    text.cpp

Abstract:

    font/text output handling functions implementation

Environment:

    Windows Whistler

Revision History:

    04/6/99     
        Created initial framework.

--*/

#include "lib.h"
#include "gpd.h"
#include "winres.h"
#include "pdev.h"
#include "common.h"
#include "..\..\font\font.h"
#include "xlpdev.h"
#include "xldebug.h"
#include <assert.h>
#include "pclxlcmd.h"
#include "pclxle.h"
#include "xlgstate.h"
#include "xloutput.h"
#include "xltext.h"
#include "xlbmpcvt.h"
#include "pclxlcmn.h"
#include "xltt.h"
#include "math.h"

//
// TrueType outline format switch
//
#define CLASS12 1

#define COMPGLYF 1

//
// Local functions prototypes
//

DWORD
DwDownloadCompositeGlyph(
    PDEVOBJ pdevobj,
    ULONG ulFontID,
    PGLYF pGlyph);

BOOL
BDownloadGlyphData(
    PDEVOBJ  pdevobj,
    ULONG    ulFontID,
    DWORD    dwGlyphID,
    HGLYPH   hGlyph,
    PBYTE    pubGlyphData,
    DWORD    dwGlyphDataSize,
    BOOL     bSpace);

extern "C" HRESULT APIENTRY
PCLXLDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult);

//
// XL Text entry point
//

extern "C" BOOL APIENTRY
PCLXLTextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
/*++

Routine Description:

    IPrintOemUni TextOutAsBitmap interface

Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLTextOutAsBitmap() entry.\r\n"));

    PDEVOBJ  pdevobj  = (PDEVOBJ)pso->dhpdev;
    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    GLYPHPOS *pGlyphPos;
    PATHOBJ   *pPathObj;
    GLYPHBITS   *pGlyphBits;
    GLYPHDATA   *pGlyphData;

    HRESULT   hResult;
    ULONG     ulJ, ulGlyphs, ulCount, ulcbBmpSize, ulcbLineAlign, ulcbLineSize;
    LONG      lI;
    BOOL      bMore;
    PBYTE     pubBitmap;
    BYTE      aubDataHdr[8];
    BYTE      aubZero[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    DWORD     adwColorTable[2];
    DWORD     dwDataHdrSize;

    if (pstro->cGlyphs == 0)
    {
        VERBOSE(("PCLXLTextOutAsBitmap: cGlyphs = 0\n"));
        return S_OK;
    }

    if (pboOpaque)
        adwColorTable[0] = BRUSHOBJ_ulGetBrushColor(pboOpaque);
    else
        adwColorTable[0] = 0x00FFFFFF;

    if (pboFore)
        adwColorTable[1] = BRUSHOBJ_ulGetBrushColor(pboFore);
    else
        adwColorTable[1] = 0x00000000;

    XLOutput *pOutput = pxlpdev->pOutput;

    //
    // UNIDRV switchs the format of font in the middle of downloading
    // character glyphs. We need to end the BeginChar sequence.
    //
    if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
    {
        pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
        pOutput->Send_cmd(eEndChar);
    }

    ROP4 rop = UlVectMixToRop4(mix);

    if ( S_OK != pOutput->SetClip(pco) ||
         S_OK != pOutput->SetPenColor(NULL, NULL) ||
         S_OK != pOutput->Flush(pdevobj))
        return S_FALSE;

    STROBJ_vEnumStart(pstro);

    do 
    {
        bMore = STROBJ_bEnum (pstro, &ulGlyphs, &pGlyphPos);

        for (ulCount = 0; ulCount < ulGlyphs; ulCount++, pGlyphPos++)
        {
            //
            // get the path of the glyph from the FONTOBJ
            //
            if (!FONTOBJ_cGetGlyphs (pfo,
	     FO_PATHOBJ,
	     1,
	     &pGlyphPos->hg, 
	     (PVOID *)&pPathObj))
            {
                ERR(("PCLXLTextOutAsBitmap: cGetGlyphs failed\n"));
                hResult = S_FALSE;
            }
            else
            {
                if (S_OK == pOutput->Send_cmd(ePushGS) &&
                    S_OK == pOutput->SetBrush(pboFore, pptlOrg) &&
                    S_OK == pOutput->SetPageOrigin((uint16)pGlyphPos->ptl.x,
	                   (uint16)pGlyphPos->ptl.x) &&
                    S_OK == pOutput->Path(pPathObj) &&
                    S_OK == pOutput->Paint() &&
                    S_OK == pOutput->Send_cmd(ePopGS))
                    hResult = S_OK;
                else
                    hResult = S_FALSE;
            }

            if (hResult == S_FALSE)
            {
                pOutput->Delete();

                //
                // get the path of the glyph from the FONTOBJ
                //
                if (!FONTOBJ_cGetGlyphs (pfo,
                                         FO_GLYPHBITS,
                                         1,
                                         &pGlyphPos->hg, 
                                         (PVOID *)&pGlyphData))
                {
                    ERR(("PCLXLTextOutAsBitmap: cGetGlyphs failed\n"));
                    return S_FALSE;
                }

                pGlyphBits = pGlyphData->gdf.pgb;
                ulcbLineSize = (pGlyphBits->sizlBitmap.cx + 7) >> 3;
                ulcbLineAlign = (sizeof(DWORD) - ulcbLineSize % sizeof(DWORD)) % sizeof(DWORD);
                ulcbBmpSize = (ulcbLineSize + ulcbLineAlign) * pGlyphBits->sizlBitmap.cy;
                if (ulcbBmpSize <= 0xff)
                {
                    aubDataHdr[0] = PCLXL_dataLengthByte;
                    aubDataHdr[1] = (BYTE)(ulcbBmpSize & 0xff);
                    dwDataHdrSize = 2;
                }
                else
                {
                    aubDataHdr[0] = PCLXL_dataLength;
                    aubDataHdr[1] = (BYTE)(ulcbBmpSize & 0xff);
                    aubDataHdr[2] = (BYTE)((ulcbBmpSize >> 8) & 0xff);
                    aubDataHdr[3] = (BYTE)((ulcbBmpSize >> 16) & 0xff);
                    aubDataHdr[4] = (BYTE)((ulcbBmpSize >> 24) & 0xff);
                    dwDataHdrSize = 5;
                }

                //
                // Hack ROP for Print As Graphics
                //
                rop = 0xFC;

                if (S_OK == pOutput->SetCursor(pGlyphPos->ptl.x + pGlyphBits->ptlOrigin.x,
	               pGlyphPos->ptl.y + pGlyphBits->ptlOrigin.y) &&
                    S_OK == pOutput->SetROP3(GET_FOREGROUND_ROP3(rop)) &&
                    S_OK == pOutput->SetPaintTxMode(eOpaque) &&
                    S_OK == pOutput->SetSourceTxMode(eTransparent) &&
                    S_OK == pOutput->SetBrush(pboFore, pptlOrg) &&
                    S_OK == pOutput->SetOutputBPP(eDirectPixel, 1) &&
                    S_OK == pOutput->SetSourceWidth((uint16)pGlyphBits->sizlBitmap.cx) &&
                    S_OK == pOutput->SetSourceHeight((uint16)pGlyphBits->sizlBitmap.cy) &&
                    S_OK == pOutput->SetDestinationSize((uint16)pGlyphBits->sizlBitmap.cx,
                                               (uint16)pGlyphBits->sizlBitmap.cy) &&
                    S_OK == pOutput->Send_cmd(eBeginImage) &&
                    S_OK == pOutput->ReadImage(pGlyphBits->sizlBitmap.cy, eNoCompression) &&
                    S_OK == pOutput->Flush(pdevobj))
                    hResult = S_OK;
                else
                    hResult = S_FALSE;

                WriteSpoolBuf((PPDEV)pdevobj, aubDataHdr, dwDataHdrSize);

                pubBitmap = pGlyphBits->aj;

                //
                // Bitmap data has to be DWORD-align.
                //
                // Invert bitmap
                //
                for (lI = 0; lI < pGlyphBits->sizlBitmap.cy; lI ++)
                {
                    for (ulJ = 0; ulJ < ulcbLineSize; ulJ++)
                    {
                        *(pubBitmap+ulJ) = ~*(pubBitmap+ulJ);
                    }
                    WriteSpoolBuf((PPDEV)pdevobj, pubBitmap, ulcbLineSize);
                    pubBitmap += ulcbLineSize;
                    WriteSpoolBuf((PPDEV)pdevobj, aubZero, ulcbLineAlign);
                }

                if (S_OK == pOutput->Send_cmd(eEndImage) &&
                    S_OK == pOutput->Flush(pdevobj))
                    hResult = S_OK;
                else
                    hResult = S_FALSE;
            }
            else
                hResult = pOutput->Flush(pdevobj);

        }
    }
    while (bMore && hResult == S_OK);

    if (S_OK == hResult)
        return S_OK;
    else
        return S_FALSE;
}


extern "C" HRESULT APIENTRY
PCLXLDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadFontHeader interface

Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLDownloadFontHeader() entry.\r\n"));

    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;

    HRESULT hResult;

    if (NULL == pxlpdev)
    {
        ERR(("PCLXL:DownloadFontHeader Invalid pdevOEM.\r\n"));
        return S_FALSE;
    }

    //
    // UNIDRV switchs the format of font in the middle of downloading
    // character glyphs. We need to end the BeginChar sequence.
    //
    if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
    {
        XLOutput *pOutput = pxlpdev->pOutput;
        pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
        pOutput->Send_cmd(eEndChar);
    }

    if (pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_BITMAP)
    {
        VERBOSE(("PCLXLDownloadFontHeader() BITMAP.\n"));

        //
        // Get current text resolution
        //
        if (pxlpdev->dwTextRes == 0)
        {
            GETINFO_STDVAR StdVar;
            DWORD dwSizeNeeded;

            StdVar.dwSize = sizeof(GETINFO_STDVAR);
            StdVar.dwNumOfVariable = 1;
            StdVar.StdVar[0].dwStdVarID = FNT_INFO_TEXTYRES;
            StdVar.StdVar[0].lStdVariable  = 0;
            pUFObj->pfnGetInfo(pUFObj,
                               UFO_GETINFO_STDVARIABLE,
                               &StdVar,
                               StdVar.dwSize,
                               &dwSizeNeeded);

            pxlpdev->dwTextRes    = StdVar.StdVar[0].lStdVariable;
        }

        //
        // PCL XL FontHeader initialization
        // Get the max character number from GPD file.
        //
        PCLXL_FONTHEADER   PCLXLFontHeader;
        PCLXLFontHeader.ubFormat           = 0;
        PCLXLFontHeader.ubOrientation      = ePortraitOrientation;
        PCLXLFontHeader.wMapping           = 0x0200;
        PCLXLFontHeader.ubFontScallingTech = eBitmap;
        PCLXLFontHeader.ubVariety          = 0;
        PCLXLFontHeader.wNumOfChars        = SWAPW(1+((PPDEV)pdevobj)->pGlobals->dwMaxGlyphID - ((PPDEV)pdevobj)->pGlobals->dwMinGlyphID);

        //
        // BR Segment initialization
        //
        PCLXL_BR_SEGMENT   PCLXLBRSegment;
        PCLXLBRSegment.wSignature         = PCLXL_BR_SIGNATURE;
        PCLXLBRSegment.wSegmentSize       = 0;
        PCLXLBRSegment.wSegmentSizeAlign  = SWAPW(PCLXL_BR_SEGMENT_SIZE);
        PCLXLBRSegment.wXResolution       = SWAPW(pxlpdev->dwTextRes);
        PCLXLBRSegment.wYResolution       = SWAPW(pxlpdev->dwTextRes);

        //
        // NULL Segment initialization
        //
        PCLXL_NULL_SEGMENT PCLXLNULLSegment;
        PCLXLNULLSegment.wSignature        = PCLXL_NULL_SIGNATURE;
        PCLXLNULLSegment.wSegmentSize      = 0;
        PCLXLNULLSegment.wSegmentSizeAlign = 0;

        {
            //
            // Output
            //
            XLOutput *pOutput = pxlpdev->pOutput;

            //
            // BeginFontHeader
            //

            pOutput->Send_ubyte(0);
            pOutput->Send_attr_ubyte(eFontFormat);
            pOutput->Send_ubyte_array_header(16);
            pOutput->Write(PubGetFontName(pUFObj->ulFontID), PCLXL_FONTNAME_SIZE);
            pOutput->Send_attr_ubyte(eFontName);
            pOutput->Send_cmd(eBeginFontHeader);

            //
            // ReadFontHeader
            //
            uint32   uint32_FontHeaderSize;
            uint32_FontHeaderSize = sizeof(PCLXLFontHeader);

            pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
            pOutput->Send_attr_ubyte(eFontHeaderLength);
            pOutput->Send_cmd(eReadFontHeader);
            pOutput->WriteByte(PCLXL_dataLengthByte);
            pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
            pOutput->Write((PBYTE)&PCLXLFontHeader, uint32_FontHeaderSize);

            uint32_FontHeaderSize = sizeof(PCLXLBRSegment);
            pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
            pOutput->Send_attr_ubyte(eFontHeaderLength);
            pOutput->Send_cmd(eReadFontHeader);
            pOutput->WriteByte(PCLXL_dataLengthByte);
            pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
            pOutput->Write((PBYTE)&PCLXLBRSegment, uint32_FontHeaderSize);

            uint32_FontHeaderSize = sizeof(PCLXLNULLSegment);
            pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
            pOutput->Send_attr_ubyte(eFontHeaderLength);
            pOutput->Send_cmd(eReadFontHeader);
            pOutput->WriteByte(PCLXL_dataLengthByte);
            pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
            pOutput->Write((PBYTE)&PCLXLNULLSegment, uint32_FontHeaderSize);

            //
            // EndFontHeader
            //
            pOutput->Send_cmd(eEndFontHeader);

            pOutput->Flush(pdevobj);
        }

        *pdwResult = sizeof(PCLXL_FONTHEADER)  +
                     sizeof(PCLXL_BR_SEGMENT)  +
                     sizeof(PCLXL_NULL_SEGMENT);
        hResult = S_OK;
    }
    else
    if (pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
    {
        VERBOSE(("PCLXLDownloadFontHeader() OUTLINE.\n"));

        //
        // Get FONTOBJ
        //
        FONTOBJ *pFontObj;
        if (S_OK != GetFONTOBJ(pdevobj, pUFObj, &pFontObj))
        {
            ERR(("PCLXL:DownloadFontHeader UFO_GETINFO_FONTOBJ failed.\r\n"));
            return E_UNEXPECTED;
        }

        //
        // ASSUMPTION: pxlpdev->pTTFile is initialized in EnablePDEV.
        //             The pointer is always available.
        //
        XLTrueType *pTTFile = pxlpdev->pTTFile;
        if (S_OK != pTTFile->SameFont(pFontObj))
        {
            if (S_OK != pTTFile->OpenTTFile(pFontObj))
            {
                ERR(("PCLXL:DownloadFontHeader XLTrueType>OpenTTFile failed.\r\n"));
                return E_UNEXPECTED;
            }
        }
        else
            pTTFile = pxlpdev->pTTFile;

        //
        // PCL XL FontHeader initialization
        // Get the max character number from GPD file.
        //
        PCLXL_FONTHEADER   PCLXLFontHeader;
        PCLXLFontHeader.ubFormat           = 0;
        PCLXLFontHeader.ubOrientation      = ePortraitOrientation;
        PCLXLFontHeader.wMapping           = 0x0200;
        PCLXLFontHeader.ubFontScallingTech = eTrueType;
        PCLXLFontHeader.ubVariety          = 0;
        PCLXLFontHeader.wNumOfChars        = SWAPW(1+((PPDEV)pdevobj)->pGlobals->dwMaxGlyphID - ((PPDEV)pdevobj)->pGlobals->dwMinGlyphID);

        //
        // PCL XL GT Table Directory
        //
        PTTDIR pTableDir;
        TTTag tag;
        DWORD dwI, dwTableOffset, dwNumTag, dwGTSegSize, dwDWAlign, dwTableSize;

        //
        // GetNumOfTag returns 11 tags including loca table.
        // Header requires
        //              head
        //              maxp
        //              gdir
        //              hhea (only for class 0)
        //              hmtx (only for class 0)
        //              vhea (only for vertical font and class 0)
        //              vmtx (only for vertical font and class 0)
        //
        // Optional
        //              cvt
        //              fpgm
        //              perp
        //
        // We need to get the number of Tag to download.
        // XLTrueType object caches available table directories includeing loca
        // table. Here we go through the cached table to see if which one of
        // above table is available.
        //
        // See truetype.h
        // TagID_first = 0. TagID_First is the number of tags which are used for
        // font header.
        //

        dwNumTag = 0;
        dwGTSegSize = 0;

        PCLXL_GT_TABLE_DIR PCLXLGTTblDir[TagID_Header];
        for (dwI = (USHORT)TagID_First; dwI < (USHORT)TagID_Header; dwI ++)
        {
            //
            // Check a table for the tag is available in the TrueType font.
            //
            tag = TTTag_INVALID;
            pTableDir = NULL;

#if CLASS12
            //
            // Support only Class 1 and Class 2
            //
            if (dwI == TagID_hhea || dwI == TagID_hmtx ||
                dwI == TagID_vhea || dwI == TagID_vmtx  )
            {
                continue;
            }
#else
            //
            // Support Class 1 and Class 2 for horizontal font.
            // Class 0 for vertical font. PCL XL interpreter doesn't work fine.
            //
            if (S_OK != pTTFile->IsVertical())
            {
                if (dwI == TagID_hhea || dwI == TagID_hmtx ||
                    dwI == TagID_vhea || dwI == TagID_vmtx  )
                {
                    continue;
                }
            }
#endif

            if (S_OK == pTTFile->TagAndID(&dwI, &tag) &&
                S_OK == pTTFile->GetTableDir(tag, (PVOID*)&pTableDir))
            {
                //
                // dwTableOffset is an offset from the top of the TrueType
                // Soft Font Directory Header to the start of the table data in
                // the PCL XL embedded data stream.
                //
                if (pTableDir)
                {
                    PCLXLGTTblDir[dwNumTag].dwTableTag      = pTableDir->ulTag;
                    //PCLXLGTTblDir[dwNumTag].dwTableCheckSum = pTableDir->ulCheckSum;
                    PCLXLGTTblDir[dwNumTag].dwTableCheckSum = 0;
                    PCLXLGTTblDir[dwNumTag].dwTableOffset   = 0;

                    //
                    // DWORD alignment
                    //
                    dwTableSize = SWAPDW(pTableDir->ulLength);
                    dwTableSize = ((dwTableSize + 3) >> 2) << 2;

                    PCLXLGTTblDir[dwNumTag].dwTableSize     = SWAPDW(dwTableSize);
                }

                dwNumTag ++;
            }
            else
            if (tag == TTTag_gdir)
            {
                //
                // 'gdir' special case.
                //
                PCLXLGTTblDir[dwNumTag].dwTableTag      = TTTag_gdir;
                PCLXLGTTblDir[dwNumTag].dwTableCheckSum = 0;
                PCLXLGTTblDir[dwNumTag].dwTableOffset   = 0;
                PCLXLGTTblDir[dwNumTag].dwTableSize     = 0;
                dwNumTag ++;
            }
        }

        dwGTSegSize = sizeof(PCLXL_GT_TABLE_DIR_HEADER) +
                      sizeof(TTDIR) * dwNumTag;
        dwTableOffset = sizeof(PCLXL_GT_TABLE_DIR_HEADER) +
                        dwNumTag * sizeof(TTDIR);

        //
        // Set dwTableOffset in PCLXLGTTblDir
        //
        for (dwI = 0; dwI < dwNumTag; dwI ++)
        {
            //
            // Skip virtual glyph data table (gdir)
            //
            if (PCLXLGTTblDir[dwI].dwTableTag != TTTag_gdir)
            {
                PCLXLGTTblDir[dwI].dwTableOffset = SWAPDW(dwTableOffset);

                dwTableSize = SWAPDW(PCLXLGTTblDir[dwI].dwTableSize);
                dwTableOffset += dwTableSize;
                dwGTSegSize   += dwTableSize;
            }
            else
            {
                //
                // Fill gdir table dir offset
                //
                PCLXLGTTblDir[dwNumTag - 1].dwTableOffset   = 0;
            }

            VERBOSE(("PCLXLDownloadFontHeader:Tag[%d]=%c%c%c%c, Size=0x%0x, Offset=0x%0x\n",
	 dwI,
	 0xff &  PCLXLGTTblDir[dwI].dwTableTag,
	 0xff & (PCLXLGTTblDir[dwI].dwTableTag >> 8),
	 0xff & (PCLXLGTTblDir[dwI].dwTableTag >> 16),
	 0xff & (PCLXLGTTblDir[dwI].dwTableTag >> 24),
	 PCLXLGTTblDir[dwI].dwTableSize,
	 PCLXLGTTblDir[dwI].dwTableOffset));
        }

        //
        // PCL XL GT Segment initialization
        //
        PTTHEADER pTTHeader;
        if (S_OK != pTTFile->GetHeader(&pTTHeader))
        {
            ERR(("PCLXL:DownloadFontHeader XLTTFile::GetHeader failed.\r\n"));
            return S_FALSE;
        }

        PCLXL_GT_SEGMENT PCLXLGTSegment;
        PCLXLGTSegment.wSignature    = PCLXL_GT_SIGNATURE;
        PCLXLGTSegment.wSegmentSize1 = HIWORD(dwGTSegSize);
        PCLXLGTSegment.wSegmentSize1 = SWAPW(PCLXLGTSegment.wSegmentSize1);
        PCLXLGTSegment.wSegmentSize2 = LOWORD(dwGTSegSize);
        PCLXLGTSegment.wSegmentSize2 = SWAPW(PCLXLGTSegment.wSegmentSize2);

        PCLXL_GT_TABLE_DIR_HEADER PCLXLDirHeader;

        //
        // N = Number of Tables
        // Search Range = (maximum power of 2 <= N) * 16
        // Entry Selector = Log2(maximum power of 2 <= N)
        // Range Shift = (N * 16) - Search Range
        //
        WORD wSearchRange, wEntrySelector, wTemp;
        wSearchRange = 2;
        for (wSearchRange = 2; wSearchRange <= dwNumTag; wSearchRange <<= 1);
        wSearchRange >>= 1;

        wTemp = wSearchRange;
        wSearchRange <<= 4;

        for (wEntrySelector = 0; wTemp > 1; wTemp >>= 1, wEntrySelector++);

        //
        // HP Monolithic driver set 'ttcf' in the SFNTVersion.
        //
        {
            HRESULT hRet;
            if (S_OK == (hRet = pTTFile->IsTTC()))
            {
                PCLXLDirHeader.dwSFNTVersion = TTTag_ttcf;
            }
            else if (S_FALSE == hRet)
            {
                PCLXLDirHeader.dwSFNTVersion = pTTHeader->dwSfntVersion;
            }
            else
            {
                ERR(("PCLXL:DownloadFontHeader XLTrueType.IsTTC failed.\r\n"));
                return E_UNEXPECTED;
            }
        }
        PCLXLDirHeader.wNumOfTables  = SWAPW((WORD)dwNumTag);
        PCLXLDirHeader.wSearchRange  = SWAPW(wSearchRange);
        PCLXLDirHeader.wEntrySelector= SWAPW(wEntrySelector);
        PCLXLDirHeader.wRangeShift   = SWAPW((dwNumTag << 4) - wSearchRange);

        //
        // GC Segment initialization
        //
        PCLXL_GC_SEGMENT PCLXLGCSegment;
        PCLXLGCSegment.wSignature        = PCLXL_GC_SIGNATURE;
        PCLXLGCSegment.wSegmentSize      = 0;
        PCLXLGCSegment.wSegmentSizeAlign = SWAPW(PCLXL_GC_SEGMENT_HEAD_SIZE);
        PCLXLGCSegment.wFormat           = 0;
        PCLXLGCSegment.wDefaultGalleyCharacter = 0xFFFF;
        PCLXLGCSegment.wNumberOfRegions  = 0;

        //
        // NULL Segment initialization
        //
        PCLXL_NULL_SEGMENT PCLXLNULLSegment;

        PCLXLNULLSegment.wSignature        = PCLXL_NULL_SIGNATURE;
        PCLXLNULLSegment.wSegmentSize      = 0;
        PCLXLNULLSegment.wSegmentSizeAlign = 0;

        //
        // Output
        //
        *pdwResult = 0;
        XLOutput *pOutput = pxlpdev->pOutput;

        //
        // BeginFontHeader
        //
        pOutput->Send_ubyte(0);
        pOutput->Send_attr_ubyte(eFontFormat);
        pOutput->Send_ubyte_array_header(PCLXL_FONTNAME_SIZE);
        pOutput->Write(PubGetFontName(pUFObj->ulFontID), PCLXL_FONTNAME_SIZE);
        pOutput->Send_attr_ubyte(eFontName);
        pOutput->Send_cmd(eBeginFontHeader);

        //
        // FontHeader
        //
        uint32   uint32_FontHeaderSize;
        uint32_FontHeaderSize = sizeof(PCLXLFontHeader);
        pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
        pOutput->Send_attr_ubyte(eFontHeaderLength);
        pOutput->Send_cmd(eReadFontHeader);
        pOutput->WriteByte(PCLXL_dataLengthByte);
        pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
        pOutput->Write((PBYTE)&PCLXLFontHeader, uint32_FontHeaderSize);

        *pdwResult +=  sizeof(PCLXLFontHeader);

        //
        // GT Header
        //
        uint32_FontHeaderSize = sizeof(PCLXL_GT_SEGMENT);
        pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
        pOutput->Send_attr_ubyte(eFontHeaderLength);
        pOutput->Send_cmd(eReadFontHeader);
        pOutput->WriteByte(PCLXL_dataLengthByte);
        pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
        pOutput->Write((PBYTE)&PCLXLGTSegment, uint32_FontHeaderSize);

        *pdwResult +=  sizeof(PCLXL_GT_SEGMENT);
        
        //
        // TrueType Softfont Directory Header
        // Table Dir
        //
        uint32_FontHeaderSize = sizeof(PCLXL_GT_TABLE_DIR_HEADER);
        pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
        pOutput->Send_attr_ubyte(eFontHeaderLength);
        pOutput->Send_cmd(eReadFontHeader);
        pOutput->WriteByte(PCLXL_dataLengthByte);
        pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
        pOutput->Write((PBYTE)&PCLXLDirHeader, sizeof(PCLXLDirHeader));

        uint32_FontHeaderSize = sizeof(PCLXL_GT_TABLE_DIR) * dwNumTag;
        pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
        pOutput->Send_attr_ubyte(eFontHeaderLength);
        pOutput->Send_cmd(eReadFontHeader);
        pOutput->WriteByte(PCLXL_dataLengthByte);
        pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
        pOutput->Write((PBYTE)PCLXLGTTblDir, sizeof(PCLXL_GT_TABLE_DIR) * dwNumTag);

        pOutput->Flush(pdevobj);
        *pdwResult +=  sizeof(PCLXL_GT_TABLE_DIR);
        
        //
        // Table data
        //

        PBYTE pubData;
        const BYTE  ubNullData[4] = {0, 0, 0, 0};
        for (dwI = (USHORT)TagID_First; dwI < (USHORT)TagID_Header; dwI ++)
        {
#if CLASS12
            //
            // Support only Class 1 and Class 2
            //
            if (dwI == TagID_hhea || dwI == TagID_hmtx ||
                dwI == TagID_vhea || dwI == TagID_vmtx  )
            {
                continue;
            }
#else
            //
            // Support Class 1 and Class 2 for horizontal font.
            // Class 0 for vertical font. PCL XL interpreter doesn't work fine.
            //
            if (S_OK != pTTFile->IsVertical())
            {
                //
                // Support only Class 1 and Class 2
                //
                if (dwI == TagID_hhea || dwI == TagID_hmtx ||
                    dwI == TagID_vhea || dwI == TagID_vmtx  )
                {
                    continue;
                }
            }
#endif
            //
            // Check a table for the tag is available in the TrueType font.
            //
            tag = TTTag_INVALID;
            if (S_OK == pTTFile->TagAndID(&dwI, &tag) &&
                S_OK == pTTFile->GetTable(tag,
	          (PVOID*)&pubData,
	          &uint32_FontHeaderSize))
            {
                VERBOSE(("PCLXLDownloadFontHeader:Tag[%d]=%c%c%c%c\n",
	             dwI,
                                             0xff &  tag,
                                             0xff & (tag >> 8),
                                             0xff & (tag >> 16),
                                             0xff & (tag >> 24)));

                //
                // DWORD alignment
                //
                dwDWAlign =  ((uint32_FontHeaderSize + 3) >> 2) << 2;

                if (dwDWAlign <= 0x2000)
                {
                    pOutput->Send_uint16((uint16)(dwDWAlign));
                    pOutput->Send_attr_ubyte(eFontHeaderLength);
                    pOutput->Send_cmd(eReadFontHeader);

                    if (dwDWAlign <= 0xFF)
                    {
                        pOutput->WriteByte(PCLXL_dataLengthByte);
                        pOutput->WriteByte((ubyte)dwDWAlign);
                    }
                    else
                    {
                        pOutput->WriteByte(PCLXL_dataLength);
                        pOutput->Write((PBYTE)&dwDWAlign, sizeof(uint32));
                    }
                    pOutput->Write(pubData, uint32_FontHeaderSize);
                    if (uint32_FontHeaderSize = dwDWAlign - uint32_FontHeaderSize)
                        pOutput->Write((PBYTE)ubNullData, uint32_FontHeaderSize);
                }
                else
                {
                    DWORD dwRemain = dwDWAlign;
                    DWORD dwx2000 = 0x2000;

                    while (dwRemain >= 0x2000)
                    {
                        pOutput->Send_uint16((uint16)0x2000);
                        pOutput->Send_attr_ubyte(eFontHeaderLength);
                        pOutput->Send_cmd(eReadFontHeader);
                        pOutput->WriteByte(PCLXL_dataLength);
                        pOutput->Write((PBYTE)&dwx2000, sizeof(uint32));
                        pOutput->Write(pubData, dwx2000);
                        dwRemain -= 0x2000;
                        uint32_FontHeaderSize -= 0x2000;
                        pubData += 0x2000;
                    }

                    if (dwRemain > 0)
                    {
                        pOutput->Send_uint16((uint16)dwRemain);
                        pOutput->Send_attr_ubyte(eFontHeaderLength);
                        pOutput->Send_cmd(eReadFontHeader);

                        if (dwRemain <= 0xFF)
                        {
                            pOutput->WriteByte(PCLXL_dataLengthByte);
                            pOutput->WriteByte((ubyte)dwRemain);
                        }
                        else
                        {
                            pOutput->WriteByte(PCLXL_dataLength);
                            pOutput->Write((PBYTE)&dwRemain, sizeof(uint32));
                        }
                        pOutput->Write(pubData, uint32_FontHeaderSize);
                        if (uint32_FontHeaderSize = dwRemain - uint32_FontHeaderSize)
                            pOutput->Write((PBYTE)ubNullData, uint32_FontHeaderSize);
                    }
                }

                *pdwResult += + dwDWAlign;
            }
        }

        //
        // GC segment
        //
        // Current there is no region.
        //
        uint32_FontHeaderSize = sizeof(PCLXLGCSegment) - sizeof(PCLXL_GC_REGION);
        pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
        pOutput->Send_attr_ubyte(eFontHeaderLength);
        pOutput->Send_cmd(eReadFontHeader);
        pOutput->WriteByte(PCLXL_dataLengthByte);
        pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
        pOutput->Write((PBYTE)&PCLXLGCSegment, uint32_FontHeaderSize);

        //
        // NULL header
        //
        uint32_FontHeaderSize = sizeof(PCLXLNULLSegment);
        pOutput->Send_uint16((uint16)uint32_FontHeaderSize);
        pOutput->Send_attr_ubyte(eFontHeaderLength);
        pOutput->Send_cmd(eReadFontHeader);
        pOutput->WriteByte(PCLXL_dataLengthByte);
        pOutput->WriteByte((ubyte)uint32_FontHeaderSize);
        pOutput->Write((PBYTE)&PCLXLNULLSegment, uint32_FontHeaderSize);

        *pdwResult += sizeof(PCLXLNULLSegment);

        //
        // EndFontHeader
        //
        pOutput->Send_cmd(eEndFontHeader);

        pOutput->Flush(pdevobj);

        //
        // Download special characters.
        //
        {
            //
            // Get glyph data
            //
            PBYTE pubGlyphData;
            DWORD dwGlyphDataSize = 0;
            DWORD dwCompositeDataSize = 0;

            if (S_OK != (hResult = pTTFile->GetGlyphData(0,
	                         &pubGlyphData,
	                         &dwGlyphDataSize)))
            {
                ERR(("PCLXL:DownloadFontHeader GetGlyphData failed.\r\n"));
                return hResult;
            }

            //
            // Composte glyph handling.
            // http://www.microsoft.com/typography/OTSPEC/glyf.htm
            // 
            // Space character can have data the size of which is ZERO!
            // We don't need to return S_FALSE here.
            //

            BOOL bSpace = FALSE;

            if (dwGlyphDataSize != 0 && NULL != pubGlyphData)
            {
                #if COMPGLYF
                if (((PGLYF)pubGlyphData)->numberOfContours == COMPONENTCTRCOUNT)
                {
                    dwCompositeDataSize = DwDownloadCompositeGlyph(
	              pdevobj,
	              pUFObj->ulFontID,
	              (PGLYF)pubGlyphData);
                }
                #endif

            }
            else
            {
                bSpace = TRUE;
            }

            //
            // Download actual 0 glyph data
            //
            if (! BDownloadGlyphData(pdevobj,
	     pUFObj->ulFontID,
	     0xFFFF,
	     0,
	     pubGlyphData,
	     dwGlyphDataSize,
	     bSpace))
            {
                ERR(("PCLXL:DownloadCharGlyph BDownloadGlyphData failed.\r\n"));
                return S_FALSE;
            }

            pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
            pOutput->Send_cmd(eEndChar);
            pOutput->Flush(pdevobj);
        }
    }
    else
        hResult = S_FALSE;

    //
    // Add 1 to TrueType font counter.
    //
    if (hResult == S_OK)
    {
        pxlpdev->dwNumOfTTFont ++;
    }
    return hResult;
}

extern "C" HRESULT APIENTRY
PCLXLDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadCharGlyph interface

Arguments:


Return Value:


Note:


--*/
{
    HRESULT hResult;
    uint32              uint32_datasize;

    VERBOSE(("PCLXLDownloadCharGlyph() entry.\r\n"));

    //
    // Initialize locals
    //
    hResult = E_UNEXPECTED;
    uint32_datasize = 0;

    //
    // Bitmap font download
    //
    if (pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_BITMAP)
    {
        VERBOSE(("PCLXLDownloadCharGlyph() BITMAP.\n"));

        hResult = S_OK;

        //
        // Get glyph data
        //
        GETINFO_GLYPHBITMAP GBmp;
        GLYPHBITS          *pgb;
        DWORD               dwBmpSize;
        WORD                wTopOffset;

        GBmp.dwSize     = sizeof(GETINFO_GLYPHBITMAP);
        GBmp.hGlyph     = hGlyph;
        GBmp.pGlyphData = NULL;

        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp, 0, NULL))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\r\n"));
            return S_FALSE;
        }

        //
        // Initalize header
        //
        PCLXL_BITMAP_CHAR BitmapChar;
        pgb = GBmp.pGlyphData->gdf.pgb;
        wTopOffset = (WORD)(- pgb->ptlOrigin.y);

        BitmapChar.ubFormat    = 0;
        BitmapChar.ubClass     = 0;
        BitmapChar.wLeftOffset = SWAPW(pgb->ptlOrigin.x);
        BitmapChar.wTopOffset  = SWAPW(wTopOffset);
        BitmapChar.wCharWidth  = SWAPW(pgb->sizlBitmap.cx);
        BitmapChar.wCharHeight = SWAPW(pgb->sizlBitmap.cy);

        dwBmpSize = pgb->sizlBitmap.cy * ((pgb->sizlBitmap.cx + 7) >> 3);
        uint32_datasize = dwBmpSize + sizeof(BitmapChar);

        //
        // Output
        //
        PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
        XLOutput *pOutput = pxlpdev->pOutput;

        //
        // BeginChar
        //
        // by GPD

        //
        // BeginChar
        //
        if (!(pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON))
        {
            pxlpdev->dwFlags |= XLPDEV_FLAGS_CHARDOWNLOAD_ON;

            pOutput->Send_ubyte_array_header(PCLXL_FONTNAME_SIZE);
            pOutput->Write(PubGetFontName(pUFObj->ulFontID), PCLXL_FONTNAME_SIZE);
            pOutput->Send_attr_ubyte(eFontName);
            pOutput->Send_cmd(eBeginChar);
        }

        //
        // ReadChar
        //
        pOutput->Send_uint16((uint16)((PPDEV)pdevobj)->dwNextGlyph);
        pOutput->Send_attr_ubyte(eCharCode);
        if (0xFFFF0000 & uint32_datasize)
        {
            pOutput->Send_uint32(uint32_datasize);
        }
        else if (0x0000FF00)
        {
            pOutput->Send_uint16((uint16)uint32_datasize);
        }
        else
        {
            pOutput->Send_ubyte((ubyte)uint32_datasize);
        }
        pOutput->Send_attr_ubyte(eCharDataSize);
        pOutput->Send_cmd(eReadChar);
        
        if (uint32_datasize <= 0xff)
        {
            pOutput->WriteByte(PCLXL_dataLengthByte);
            pOutput->WriteByte((ubyte)uint32_datasize);
        }
        else
        {
            pOutput->WriteByte(PCLXL_dataLength);
            pOutput->Write((PBYTE)&uint32_datasize, sizeof(uint32));
        }
        pOutput->Write((PBYTE)&BitmapChar, sizeof(BitmapChar));
        pOutput->Flush(pdevobj);


        //
        // Direct Write
        //
        WriteSpoolBuf((PPDEV)pdevobj, (PBYTE)pgb->aj, dwBmpSize);

        //
        // EndChar
        // Now EndChar is sent by FlushCachedText
        //pOutput->Send_cmd(eEndChar);

        pOutput->Flush(pdevobj);

        //
        // Get fixed pitch TT width
        //
        pxlpdev->dwFixedTTWidth = (GBmp.pGlyphData->ptqD.x.HighPart + 15) / 16;

        //
        // Set pdwWidth and pdwResult
        //
        *pdwWidth = (GBmp.pGlyphData->ptqD.x.HighPart + 15) >> 4;

        *pdwResult = (DWORD) uint32_datasize;
        VERBOSE(("PCLXLDownloadCharGlyph() Width=%d, DataSize=%d\n", *pdwWidth, uint32_datasize));
    }
    else
    //
    // TrueType outline font download
    //
    if (pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
    {
        VERBOSE(("PCLXLDownloadCharGlyph() OUTLINE.\n"));

        PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
        FONTOBJ *pFontObj;

        //
        // Get FONTOBJ by calling pUFObj->pfnGetInfo.
        //
        if (S_OK != GetFONTOBJ(pdevobj, pUFObj, &pFontObj))
        {
            ERR(("PCLXL:DownloadCharGlyph UFO_GETINFO_FONTOBJ failed.\r\n"));
            return E_UNEXPECTED;
        }

        //
        // Open get a pointer to memory-maped TrueType.
        //
        // ASSUMPTION: pxlpdev->pTTFile is initialized in EnablePDEV.
        //             The pointer is always available.
        //
        XLTrueType *pTTFile = pxlpdev->pTTFile;
        if (S_OK != pTTFile->SameFont(pFontObj))
        {
            pTTFile->OpenTTFile(pFontObj);
        }
        else
            pTTFile = pxlpdev->pTTFile;

        //
        // Get glyph data
        //
        PBYTE pubGlyphData;
        DWORD dwGlyphDataSize = 0;
        DWORD dwCompositeDataSize = 0;

        if (S_OK != (hResult = pTTFile->GetGlyphData(hGlyph,
                                                     &pubGlyphData,
                                                     &dwGlyphDataSize)))
        {
            ERR(("PCLXL:DownloadCharGlyph GetGlyphData failed.\r\n"));
            return hResult;
        }

        //
        // Composte glyph handling.
        // http://www.microsoft.com/typography/OTSPEC/glyf.htm
        // 
        // Space character can have data the size of which is ZERO!
        // We don't need to return S_FALSE here.
        //
        BOOL bSpace;

        if (dwGlyphDataSize != 0 && NULL != pubGlyphData)
        {
            #if COMPGLYF
            if (((PGLYF)pubGlyphData)->numberOfContours == COMPONENTCTRCOUNT)
            {
                dwCompositeDataSize = DwDownloadCompositeGlyph(
                                          pdevobj,
                                          pUFObj->ulFontID,
                                          (PGLYF)pubGlyphData);
            }
            #endif

            bSpace = FALSE;
        }
        else
        {
            //
            // For space character.
            //
            bSpace = TRUE;
        }

        //
        // Download actual hGlyph's glyph data
        //
        if (! BDownloadGlyphData(pdevobj,
	 pUFObj->ulFontID,
	 ((PDEV*)pdevobj)->dwNextGlyph,
	 hGlyph,
	 pubGlyphData,
	 dwGlyphDataSize,
	 bSpace))
        {
            ERR(("PCLXL:DownloadCharGlyph BDownloadGlyphData failed.\r\n"));
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                XLOutput *pOutput = pxlpdev->pOutput;
                pOutput->Send_cmd(eEndChar);
            }
            return S_FALSE;
        }

        //
        // It's Scalable font. We can't get the width.
        //
        *pdwWidth = 0;

        //
        // Size of memory to be used.
        // There is a case where the size is zero. Add 1 to hack UNIDRV.
        //
        if (bSpace)
        {
            dwGlyphDataSize = 1;
        }

        *pdwResult = (DWORD) dwGlyphDataSize + dwCompositeDataSize;

    }

    return hResult;
}

BOOL
BDownloadGlyphData(
    PDEVOBJ  pdevobj,
    ULONG    ulFontID,
    DWORD    dwGlyphID,
    HGLYPH   hGlyph,
    PBYTE    pubGlyphData,
    DWORD    dwGlyphDataSize,
    BOOL     bSpace)
{
    PCLXL_TRUETYPE_CHAR_C0 OutlineCharC0;
    PCLXL_TRUETYPE_CHAR_C1 OutlineCharC1;
    PCLXL_TRUETYPE_CHAR_C2 OutlineCharC2;
    uint32              uint32_datasize;

    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    XLTrueType *pTTFile = pxlpdev->pTTFile;
    XLOutput *pOutput = pxlpdev->pOutput;

    if (!(pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON))
    {
        pxlpdev->dwFlags |= XLPDEV_FLAGS_CHARDOWNLOAD_ON;
        pOutput->Send_ubyte_array_header(PCLXL_FONTNAME_SIZE);
        pOutput->Write(PubGetFontName(ulFontID), PCLXL_FONTNAME_SIZE);
        pOutput->Send_attr_ubyte(eFontName);
        pOutput->Send_cmd(eBeginChar);
    }

#if CLASS12
    //
    // Class 1 for Horizontal font
    // Class 2 for Vertical font
    //
    if (S_OK != pTTFile->IsVertical())
    {
        USHORT usAdvanceWidth;
        SHORT  sLeftSideBearing;

        if (S_OK != pTTFile->GetHMTXData(hGlyph, &usAdvanceWidth, &sLeftSideBearing))
        {
            ERR(("PCLXLDownloadFontHeader::GetHMTXData failed.\n"));
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }

        //
        // The initialization of TrueType Glyphs Format 1 Class 1.
        //
        uint32_datasize = dwGlyphDataSize +
                          sizeof(OutlineCharC1.wCharDataSize) +
                          sizeof(OutlineCharC1.wLeftSideBearing) +
                          sizeof(OutlineCharC1.wAdvanceWidth) +
                          sizeof(OutlineCharC1.wTrueTypeGlyphID);

        OutlineCharC1.ubFormat         = 1;
        OutlineCharC1.ubClass          = 1;
        OutlineCharC1.wCharDataSize    = SWAPW((WORD)uint32_datasize);
        OutlineCharC1.wLeftSideBearing = SWAPW((WORD)sLeftSideBearing);
        OutlineCharC1.wAdvanceWidth    = SWAPW((WORD)usAdvanceWidth);
        OutlineCharC1.wTrueTypeGlyphID = SWAPW((WORD)hGlyph);

        uint32_datasize += sizeof(OutlineCharC1.ubFormat) +
                           sizeof(OutlineCharC1.ubClass);

        PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
        XLOutput *pOutput = pxlpdev->pOutput;

        if (S_OK != pOutput->Send_uint16((uint16)dwGlyphID) ||
            S_OK != pOutput->Send_attr_ubyte(eCharCode) ||
            S_OK != pOutput->Send_uint16((uint16)uint32_datasize) ||
            S_OK != pOutput->Send_attr_ubyte(eCharDataSize) ||
            S_OK != pOutput->Send_cmd(eReadChar))
        {
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }
    }
    else
    {
        USHORT usAdvanceWidth;
        SHORT  sLeftSideBearing;
        SHORT  sTopSideBearing;

        if (S_OK != pTTFile->GetVMTXData(hGlyph, &usAdvanceWidth, &sTopSideBearing, &sLeftSideBearing))
        {
            ERR(("PCLXLDownloadCharGlyph::GetVMTXData failed.\n"));
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }

        //
        // The initialization of TrueType Glyphs Format 1 Class 2.
        //
        uint32_datasize = dwGlyphDataSize +
                          sizeof(OutlineCharC2.wLeftSideBearing) +
                          sizeof(OutlineCharC2.wTopSideBearing) +
                          sizeof(OutlineCharC2.wAdvanceWidth) +
                          sizeof(OutlineCharC2.wCharDataSize) +
                          sizeof(OutlineCharC2.wTrueTypeGlyphID);

        OutlineCharC2.ubFormat         = 1;
        OutlineCharC2.ubClass          = 2;
        OutlineCharC2.wCharDataSize    = SWAPW((WORD)uint32_datasize);
        OutlineCharC2.wLeftSideBearing = SWAPW((WORD)sLeftSideBearing);
        OutlineCharC2.wAdvanceWidth    = SWAPW((WORD)usAdvanceWidth);
        OutlineCharC2.wTopSideBearing  = SWAPW((WORD)sTopSideBearing);
        OutlineCharC2.wTrueTypeGlyphID = SWAPW((WORD)hGlyph);

        uint32_datasize += sizeof(OutlineCharC2.ubFormat) +
                           sizeof(OutlineCharC2.ubClass);


        if (S_OK != pOutput->Send_uint16((uint16)dwGlyphID) ||
            S_OK != pOutput->Send_attr_ubyte(eCharCode) ||
            S_OK != pOutput->Send_uint16((uint16)uint32_datasize) ||
            S_OK != pOutput->Send_attr_ubyte(eCharDataSize) ||
            S_OK != pOutput->Send_cmd(eReadChar))
        {
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }
    }
#else{
        //
        // The initialization of TrueType Glyphs Format 1 Class 0.
        //
        uint32_datasize = dwGlyphDataSize +
                          sizeof(OutlineCharC0.wCharDataSize) +
                          sizeof(OutlineCharC0.wTrueTypeGlyphID);

        OutlineCharC0.ubFormat         = 1;
        OutlineCharC0.ubClass          = 0;
        OutlineCharC0.wCharDataSize    = SWAPW((WORD)uint32_datasize);
        OutlineCharC0.wTrueTypeGlyphID = SWAPW((WORD)hGlyph);

        uint32_datasize += sizeof(OutlineCharC0.ubFormat) +
                           sizeof(OutlineCharC0.ubClass);

        PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
        XLOutput *pOutput = pxlpdev->pOutput;

        if (S_OK != pOutput->Send_uint16((uint16)dwGlyphID) ||
            S_OK != pOutput->Send_attr_ubyte(eCharCode) ||
            S_OK != pOutput->Send_uint16((uint16)uint32_datasize) ||
            S_OK != pOutput->Send_attr_ubyte(eCharDataSize) ||
            S_OK != pOutput->Send_cmd(eReadChar))
        {
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }
    }
#endif

    if (uint32_datasize <= 0xff)
    {
        if (S_OK != pOutput->WriteByte(PCLXL_dataLengthByte) ||
            S_OK != pOutput->WriteByte((ubyte)uint32_datasize))
        {
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }
    }
    else
    {
        if (S_OK != pOutput->WriteByte(PCLXL_dataLength) ||
            S_OK != pOutput->Write((PBYTE)&uint32_datasize, sizeof(uint32)))
        {
            if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
            {
                pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
                pOutput->Delete();
            }
            return FALSE;
        }
    }

#if CLASS12
    if (S_OK != pTTFile->IsVertical())
    {
        pOutput->Write((PBYTE)&OutlineCharC1, sizeof(OutlineCharC1));
    }
    else
    {
        pOutput->Write((PBYTE)&OutlineCharC2, sizeof(OutlineCharC2));
    }
#else
        pOutput->Write((PBYTE)&OutlineCharC0, sizeof(OutlineCharC0));
#endif
    if (S_OK == pOutput->Flush(pdevobj))
    {
        if (!bSpace)
        {
            //
            // Direct Write
            //
            dwGlyphDataSize = (DWORD)WriteSpoolBuf((PPDEV)pdevobj,
                                                   pubGlyphData,
                                                   dwGlyphDataSize);
        }
        return TRUE;
    }
    else
    {
        if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
        {
            pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
            pOutput->Delete();
        }
        return FALSE;
    }
}

extern "C" HRESULT APIENTRY
PCLXLTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni TTDownloadMethod interface

Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLTTDownloadMethod() entry.\r\n"));

    //
    // Error Check
    //
    if (NULL == pdevobj  ||
        NULL == pUFObj   ||
        NULL == pUFObj->pIFIMetrics   ||
        NULL == pdwResult )
    {
        ERR(("PCLXLTTDownloadMethod(): invalid parameters.\r\n"));
        return E_UNEXPECTED;
    }

    //
    // Initialize
    //
    *pdwResult = TTDOWNLOAD_GRAPHICS;

    if (((PPDEV)pdevobj)->pGlobals->fontformat == UNUSED_ITEM)
    {
        //
        // There is no font download format specified.
        // Prints as graphics.
        //
        return S_OK;
    }

    //
    // Return GRAPHICS for non-TrueType font
    //
    if ( !(pUFObj->pIFIMetrics->flInfo & FM_INFO_TECH_TRUETYPE) )
    {
        ERR(("PCLXLTTDownloadMethod(): invalid font.\r\n"));
        return S_OK;
    }

    //
    // Text As Graphics
    //
    if (((PPDEV)pdevobj)->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS)
    {
        return S_OK;
    }

    //
    // Get XForm and X and Y scaling factors.
    //
    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    FLOATOBJ_XFORM xform;
    FLOATOBJ foXScale, foYScale;

    if (S_OK != GetXForm(pdevobj, pUFObj, &xform) ||
        S_OK != GetXYScale(&xform, &foXScale, &foYScale))
    {
        ERR(("PCLXLTTDownloadMethod(): Failed to get X and Y Scale.\r\n"));
        return E_UNEXPECTED;
    }
    //
    // Scale fwdUnitsPerEm
    //
    FLOATOBJ_MulLong(&foYScale, pUFObj->pIFIMetrics->fwdUnitsPerEm);
    FLOATOBJ_MulLong(&foXScale, pUFObj->pIFIMetrics->fwdUnitsPerEm);
    pxlpdev->fwdUnitsPerEm = (FWORD)FLOATOBJ_GetLong(&foYScale);
    pxlpdev->fwdMaxCharWidth = (FWORD)FLOATOBJ_GetLong(&foXScale);


    //
    // Download as Bitmap softfont
    //
    if (((PPDEV)pdevobj)->pGlobals->fontformat == FF_HPPCL ||
        ((PPDEV)pdevobj)->pGlobals->fontformat == FF_HPPCL_RES)
    {
        *pdwResult = TTDOWNLOAD_BITMAP;
        return S_OK;
    }

    //
    // Parse TrueType font
    //
    XLTrueType *pTTFile = pxlpdev->pTTFile;
    FONTOBJ *pFontObj;

    if (S_OK == GetFONTOBJ(pdevobj, pUFObj, &pFontObj))
    {
        if (S_OK != pTTFile->OpenTTFile(pFontObj))
        {
            ERR(("PCLXL:TTDownloadMethod(): Failed to open TT file.\n"));
            return S_FALSE;
        }
    }

    //
    // Reverse width and height, if the font is a vertial font.
    //
    if (S_OK == pTTFile->IsVertical())
    {
        FWORD fwdTmp;
        fwdTmp = pxlpdev->fwdUnitsPerEm;
        pxlpdev->fwdUnitsPerEm = pxlpdev->fwdMaxCharWidth;
        pxlpdev->fwdMaxCharWidth = fwdTmp;
    }

    //
    // Always return TrueType Outline
    //
    *pdwResult = TTDOWNLOAD_TTOUTLINE;

    VERBOSE(("PCLXLTTDownloadMethod() pdwResult=%d\n", *pdwResult));
    return S_OK;
}

extern "C" HRESULT APIENTRY
PCLXLOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
/*++

Routine Description:

    IPrintOemUni OutputCharStr interface

Arguments:


Return Value:


Note:


--*/
{
    PXLPDEV    pxlpdev;

    //
    // UNIFONTOBJ callback data structures
    //
    GETINFO_GLYPHSTRING GStr;
    GETINFO_GLYPHWIDTH  GWidth;

    //
    // Device font TRANSDATA structure
    //
    PTRANSDATA pTransOrg, pTrans;

    PPOINTL pptlCharAdvance;
    PWORD pawChar;

    PLONG plWidth;
    DWORD dwGetInfo, dwI, dwcbInitSize;


    VERBOSE(("PCLXLOutputCharStr() entry.\r\n"));

    //
    // Error parameter check
    //
    if (0 == dwCount    ||
        NULL == pGlyph  ||
        NULL == pUFObj   )
    {
        ERR(("PCLXLOutptuChar: Invalid parameters\n"));
        return E_UNEXPECTED;
    }

    pxlpdev= (PXLPDEV)pdevobj->pdevOEM;

    //
    // Get current text resolution
    //
    if (pxlpdev->dwTextRes == 0)
    {
        GETINFO_STDVAR StdVar;
        DWORD dwSizeNeeded;

        StdVar.dwSize = sizeof(GETINFO_STDVAR);
        StdVar.dwNumOfVariable = 1;
        StdVar.StdVar[0].dwStdVarID = FNT_INFO_TEXTYRES;
        StdVar.StdVar[0].lStdVariable  = 0;
        pUFObj->pfnGetInfo(pUFObj,
                           UFO_GETINFO_STDVARIABLE,
                           &StdVar,
                           StdVar.dwSize,
                           &dwSizeNeeded);

        pxlpdev->dwTextRes    = StdVar.StdVar[0].lStdVariable;
    }

    //
    // Allocate memory for character cache
    //
    if (0 == pxlpdev->dwMaxCharCount ||
        pxlpdev->dwMaxCharCount < pxlpdev->dwCharCount + dwCount)
    {
        DWORD dwInitCount = INIT_CHAR_NUM;

        //
        // Calculate the initial data size
        //
        if (dwInitCount < pxlpdev->dwCharCount + dwCount)
        {
            dwInitCount = pxlpdev->dwCharCount + dwCount;
        }

        //
        // Allocate memory
        //
        if (!(pptlCharAdvance  = (PPOINTL)MemAlloc(sizeof(POINTL) * dwInitCount)) ||
            !(pawChar      = (PWORD)MemAlloc(sizeof(WORD) * dwInitCount))  )
        {
            ERR(("PCLXL:CharWidth buffer allocation failed.\n"));
            if (pptlCharAdvance)
            {
               MemFree(pptlCharAdvance);
            }
            return E_UNEXPECTED;
        }

        //
        // Copy the old buffer to new buffer
        //
        if (pxlpdev->dwCharCount > 0)
        {
            CopyMemory(pptlCharAdvance, pxlpdev->pptlCharAdvance, pxlpdev->dwCharCount * sizeof(POINTL));
            CopyMemory(pawChar, pxlpdev->pawChar, pxlpdev->dwCharCount * sizeof(WORD));
        }

        if (pxlpdev->pptlCharAdvance)
            MemFree(pxlpdev->pptlCharAdvance);
        if (pxlpdev->pawChar)
            MemFree(pxlpdev->pawChar);

        pxlpdev->pptlCharAdvance = pptlCharAdvance;
        pxlpdev->pawChar        = pawChar;
        pxlpdev->dwMaxCharCount = dwInitCount;
    }

    XLOutput *pOutput = pxlpdev->pOutput;

    //
    // Y cursor position is different from the previous OutputCharGlyph
    // Flush the string cache
    //
    if (0 == pxlpdev->dwCharCount)
    {
        pxlpdev->lStartX =
        pxlpdev->lX = ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->ptlFirstGlyph.x;
        pxlpdev->lStartY =
        pxlpdev->lY = ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->ptlFirstGlyph.y;

        if (((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->iRot)
        {
            pxlpdev->dwTextAngle = ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->iRot;
        }
    }


    //
    // Init pawChar
    //
    
    pawChar = pxlpdev->pawChar + pxlpdev->dwCharCount;

    switch(dwType)
    {
    case TYPE_GLYPHHANDLE:
        //
        // Get TRANSDATA
        //
        GStr.dwSize          = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount         = dwCount;
        GStr.dwTypeIn        = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn        = pGlyph;
        GStr.dwTypeOut       = TYPE_TRANSDATA;
        GStr.pGlyphOut       = NULL;
        GStr.dwGlyphOutSize  = 0;

        dwGetInfo = GStr.dwSize;

        //
        // Get necessary buffer size
        //
        pUFObj->pfnGetInfo(pUFObj,
                            UFO_GETINFO_GLYPHSTRING,
                            &GStr,
                            dwGetInfo,
                            &dwGetInfo);

        if (!GStr.dwGlyphOutSize)
        {
            ERR(("PCLXLOutptuChar: GetInfo( 1st GLYPHSTRING) failed\n"));
            return E_UNEXPECTED;
        }

        if (NULL == pxlpdev->pTransOrg ||
            dwCount * sizeof(TRANSDATA) > pxlpdev->dwcbTransSize ||
            GStr.dwGlyphOutSize > pxlpdev->dwcbTransSize)
        {
            dwcbInitSize = INIT_CHAR_NUM * sizeof(TRANSDATA);
            if (dwcbInitSize < GStr.dwGlyphOutSize)
            {
                dwcbInitSize = GStr.dwGlyphOutSize;
            }
            if (dwcbInitSize < dwCount * sizeof(TRANSDATA))
            {
                dwcbInitSize = dwCount * sizeof(TRANSDATA);
            }

            if ((pTransOrg = (PTRANSDATA)MemAlloc(dwcbInitSize)) == NULL)
            {
                ERR(("PCLXLOutptuChar: MemAlloc failed\n"));
                return E_UNEXPECTED;
            }
            pxlpdev->pTransOrg = pTransOrg;
            pxlpdev->dwcbTransSize = dwcbInitSize;
        }
        else
        {
            pTransOrg = pxlpdev->pTransOrg;
        }

        GStr.pGlyphOut =  (PVOID)pTransOrg;

        if (!pUFObj->pfnGetInfo(pUFObj,
                                UFO_GETINFO_GLYPHSTRING,
	&GStr,
	dwGetInfo,
	&dwGetInfo))
        {
            ERR(("PCLXLOutptuChar: GetInfo( 2nd GLYPHSTRING) failed\n"));
            return E_UNEXPECTED;
        }

        pTrans = pTransOrg;

        for (dwI = 0; dwI < dwCount; dwI++, pTrans++)
        {
            switch(pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            case MTYPE_COMPOSE:
                ERR(("PCLXL:OutputCharGlyph: Unsupported ubType\n"));
                break;
            case MTYPE_DIRECT:
                VERBOSE(("PCLXLOutputCharStr:%c\n", pTrans->uCode.ubCode));
                *pawChar++ = pTrans->uCode.ubCode;
                break;
            case MTYPE_PAIRED:
                *pawChar++ = *(PWORD)(pTrans->uCode.ubPairs);
                break;
            }
        }
        break;

    case TYPE_GLYPHID:
        for (dwI = 0; dwI < dwCount; dwI++, pawChar++)
        {
            CopyMemory(pawChar, (PDWORD)pGlyph + dwI, sizeof(WORD));
        }
        break;
    }

    //
    // Get Character width
    //

    //
    // Store char position info
    //

    pptlCharAdvance = pxlpdev->pptlCharAdvance + pxlpdev->dwCharCount;

    //
    // dwCharCount holds the number of chars in the character cache
    // dwCharCount = 0: Store start X pos
    //                  Current Y pos
    //
    if (pxlpdev->dwCharCount == 0)
    {
        //
        // UNIDRV hack
        // Get the first character position.
        //
        pxlpdev->lPrevX    =
        pxlpdev->lStartX   =
        pxlpdev->lX = ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->ptlFirstGlyph.x;
        pxlpdev->lPrevY    =
        pxlpdev->lStartY   =
        pxlpdev->lY = ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->ptlFirstGlyph.y;
        VERBOSE(("PCLXLOutputCharStr: %d",pxlpdev->lStartX));
    }

    GLYPHPOS *pgp = ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->pgp;

    if (pxlpdev->dwCharCount > 0)
    {
        if (pxlpdev->dwCharCount < ((TO_DATA*)((PFONTPDEV)pxlpdev->pPDev->pFontPDev)->ptod)->cGlyphsToPrint)
        {
            pgp += pxlpdev->dwCharCount;
        }

        (pptlCharAdvance - 1)->x = pgp->ptl.x - pxlpdev->lPrevX;
        (pptlCharAdvance - 1)->y = pgp->ptl.y - pxlpdev->lPrevY;
    }

    for (dwI = 0; dwI < dwCount - 1; dwI ++, pptlCharAdvance ++, pgp ++)
    {
        pptlCharAdvance->x = pgp[1].ptl.x - pgp->ptl.x; 
        pptlCharAdvance->y = pgp[1].ptl.y - pgp->ptl.y; 
        VERBOSE((",(%d, %d)", pptlCharAdvance->x, pptlCharAdvance->y));
    }
    VERBOSE(("\n"));

    pptlCharAdvance->x = pptlCharAdvance->y = 0;
    pxlpdev->lPrevX = pgp->ptl.x;
    pxlpdev->lPrevY = pgp->ptl.y;
    pxlpdev->dwCharCount += dwCount;

    return S_OK;
}

extern "C" HRESULT APIENTRY
PCLXLSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv)
/*++

Routine Description:

    IPrintOemUni SendFontCmd interface

Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLSendFontCmd() entry.\r\n"));

    CHAR  cSymbolSet[16];
    PBYTE pubCmd;

    if (NULL == pFInv             ||
        NULL == pFInv->pubCommand ||
        0    == pFInv->dwCount     )
    {
        VERBOSE(("PCLXLSendFontCmd: unexpected FINVOCATION\n"));
        return S_OK;
    }

    PXLPDEV pxlpdev = (PXLPDEV)pdevobj->pdevOEM;
    XLOutput *pOutput = pxlpdev->pOutput;

    if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
    {
        pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
        XLOutput *pOutput = pxlpdev->pOutput;
        pOutput->Send_cmd(eEndChar);
    }

    if (pUFObj->dwFlags & UFOFLAG_TTFONT)
    {
        if (pFInv->dwCount == sizeof(DWORD))
        {
            if (pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_BITMAP)
            {
                pOutput->SetFont(kFontTypeTTBitmap,
                     PubGetFontName(pUFObj->ulFontID),
                     pxlpdev->fwdUnitsPerEm,
                     pxlpdev->fwdMaxCharWidth,
                     0x0002,
                     (DWORD)0);
            }
            else
            {
                DWORD dwFontSimulation = pUFObj->dwFlags & (UFOFLAG_TTOUTLINE_BOLD_SIM|UFOFLAG_TTOUTLINE_ITALIC_SIM|UFOFLAG_TTOUTLINE_VERTICAL);

                //
                // UFOFLAG_TTOUTLINE_BOLD_SIM   = 0x08
                // UFOFLAG_TTOUTLINE_ITALIC_SIM = 0x10
                // UFOFLAG_TTOUTLINE_VERTICAL   = 0x20
                //
                // XLOUTPUT_FONTSIM_BOLD   = 0x01
                // XLOUTPUT_FONTSIM_ITALIC = 0x02
                // XLOUTPUT_FONTSIM_VERTICAL = 0x03
                //
                dwFontSimulation >>= 3;

                pOutput->SetFont(kFontTypeTTOutline,
                     PubGetFontName(pUFObj->ulFontID),
                     pxlpdev->fwdUnitsPerEm,
                     pxlpdev->fwdMaxCharWidth,
                     0x0002,
                     dwFontSimulation);
            }
        }
        else
        {
            VERBOSE(("PCLXLSendFontCmd: unexpected FINVOCATION\n"));
            return S_FALSE;
        }
    }
    else
    {
        DWORD dwSizeNeeded, dwSize, dwSymbolSet;

        pubCmd = pFInv->pubCommand;
        pubCmd += pFInv->dwCount;
        pubCmd --;

        //
        // Get a symbol set
        //
        // ASSUMPTION: Font selecton string is like following!!!!
        //
        // "Courier          590"
        //  12345678901234567890
        // the size of font name is 16. Plus space and symbol set number.
        //
        dwSize = 0;
        while (*pubCmd != 0x20)
        {
            pubCmd--;
            dwSize ++;
        }

        if (dwSize != 0)
        {
            pubCmd++;
            CopyMemory(cSymbolSet, pubCmd, dwSize);
        }
        cSymbolSet[dwSize] = NULL;

        dwSymbolSet = (DWORD)atoi(cSymbolSet);

        //
        // Get FONTOBJ
        //
        FONTOBJ *pFontObj;
        GetFONTOBJ(pdevobj, pUFObj, &pFontObj);


        //
        // Get XForm
        //
        FLOATOBJ foXScale, foYScale;
        FLOATOBJ_XFORM xform;

        if (S_OK != GetXForm(pdevobj, pUFObj, &xform) ||
            S_OK != GetXYScale(&xform, &foXScale, &foYScale))
        {
            return E_UNEXPECTED;
        }

        //
        // Scale Height and Width
        //
        // Is X scaled differently from Y?
        // If so, set X.
        //
        DWORD dwFontWidth;
        FLOATOBJ_MulLong(&foYScale, pUFObj->pIFIMetrics->fwdUnitsPerEm);
        FLOATOBJ_MulLong(&foXScale, pUFObj->pIFIMetrics->fwdUnitsPerEm);
        pxlpdev->dwFontHeight = (FWORD)FLOATOBJ_GetLong(&foYScale);
        pxlpdev->dwFontWidth = (FWORD)FLOATOBJ_GetLong(&foXScale);
        if (S_OK == IsXYSame(&xform))
        {
            dwFontWidth = 0;
        }
        else
        {
            dwFontWidth = pxlpdev->dwFontWidth;
        }

        pOutput->SetFont(kFontTypeDevice,
                         (PBYTE)pFInv->pubCommand,
                         pxlpdev->dwFontHeight,
                         dwFontWidth,
                         dwSymbolSet,
                         0);
    }

    pOutput->Flush(pdevobj);

    if (pxlpdev->dwFlags & XLPDEV_FLAGS_RESET_FONT)
    {
        BSaveFont(pdevobj);
    }

    return S_OK;
}


HRESULT
FlushCachedText(
    PDEVOBJ pdevobj)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    DWORD dwI;

    VERBOSE(("PCLXLFlushCachedText: Flush cached characters:%d\r\n", pxlpdev->dwCharCount));

    if (pxlpdev->dwCharCount == 0)
        return S_OK;

    XLOutput *pOutput = pxlpdev->pOutput;

    PWORD pawChar = pxlpdev->pawChar;
    PPOINTL pptlCharAdvance = pxlpdev->pptlCharAdvance;

    sint16 sint16_advance;
    ubyte  ubyte_advance;

    XLGState *pGState = pxlpdev->pOutput;

    if (pxlpdev->dwFlags & XLPDEV_FLAGS_CHARDOWNLOAD_ON)
    {
        pxlpdev->dwFlags &= ~XLPDEV_FLAGS_CHARDOWNLOAD_ON;
        pOutput->Send_cmd(eEndChar);
    }

    //
    // Flush cached char string
    //

    //
    // Reselect font
    //
    if (pxlpdev->dwFlags & XLPDEV_FLAGS_RESET_FONT)
    {
        BYTE aubFontName[PCLXL_FONTNAME_SIZE];

        VERBOSE(("PCLXLFlushCachedText: ResetFont\n"));

        pxlpdev->dwFlags &= ~XLPDEV_FLAGS_RESET_FONT;
        pxlpdev->pXLFont->GetFontName(aubFontName);
        pOutput->SetFont(pxlpdev->pXLFont->GetFontType(),
                         aubFontName,
                         pxlpdev->pXLFont->GetFontHeight(),
                         pxlpdev->pXLFont->GetFontWidth(),
                         pxlpdev->pXLFont->GetFontSymbolSet(),
                         pxlpdev->pXLFont->GetFontSimulation());
    }

    //
    // Set cursor
    //
    pOutput->SetCursor(pxlpdev->lStartX, pxlpdev->lStartY);

    //
    // Set text angle
    //
    if (pxlpdev->dwTextAngle && kFontTypeTTBitmap != pGState->GetFontType())
    {
        pOutput->Send_uint16((uint16)pxlpdev->dwTextAngle);
        pOutput->Send_attr_ubyte(eCharAngle);
        pOutput->Send_cmd(eSetCharAngle);
    }

    //
    // Characters
    //
    pOutput->Send_uint16_array_header((uint16)pxlpdev->dwCharCount);
    VERBOSE(("String = "));
    for (dwI = 0; dwI < pxlpdev->dwCharCount; dwI ++, pawChar++)
    {
        pOutput->Write((PBYTE)pawChar, sizeof(WORD));
        VERBOSE(("0x%x ", *pawChar));
    }
    VERBOSE(("\r\n"));
    pOutput->Send_attr_ubyte(eTextData);

    //
    // X advance
    //
    VERBOSE(("Advance(0x%x)(x,y) = (%d,%d),", pptlCharAdvance, pptlCharAdvance->x, pptlCharAdvance->y));

    BOOL bXUByte = TRUE;
    BOOL bYUByte = TRUE;
    BOOL bXAdvanceTrue = FALSE;
    BOOL bYAdvanceTrue = FALSE;
    for (dwI = 0; dwI < pxlpdev->dwCharCount; dwI ++, pptlCharAdvance++)
    {
        //
        // If the char advance is ubyte, set bUByte flag to optimize XSpacing
        //
        if (pptlCharAdvance->x & 0xffffff00)
            bXUByte = FALSE;
        if (pptlCharAdvance->y & 0xffffff00)
            bYUByte = FALSE;
        if (pptlCharAdvance->x != 0)
            bXAdvanceTrue = TRUE;
        if (pptlCharAdvance->y != 0)
            bYAdvanceTrue = TRUE;
    }

    //
    // X Advance
    //
    if (bXAdvanceTrue)
    {
        pptlCharAdvance = pxlpdev->pptlCharAdvance;

        VERBOSE(("X = "));
        if (bXUByte == TRUE)
        {
            //
            // ubyte XSpacing
            //
            pOutput->Send_ubyte_array_header((uint16)pxlpdev->dwCharCount);

            for (dwI = 0; dwI < pxlpdev->dwCharCount; dwI ++, pptlCharAdvance++)
            {
                ubyte_advance = (ubyte)pptlCharAdvance->x;
                pOutput->Write((PBYTE)&ubyte_advance, sizeof(ubyte));
#if DBG
                VERBOSE(("%d ", ubyte_advance));
                if (0 == ubyte_advance)
                {
                    VERBOSE(("\nXSpacing is zero!.\n"));
                }
#endif
            }
        }
        else
        {
            //
            // sint16 XSpacing
            //
            pOutput->Send_sint16_array_header((uint16)pxlpdev->dwCharCount);

            for (dwI = 0; dwI < pxlpdev->dwCharCount; dwI ++, pptlCharAdvance++)
            {
                sint16_advance = (sint16)pptlCharAdvance->x;
                pOutput->Write((PBYTE)&sint16_advance, sizeof(sint16));
#if DBG
                VERBOSE(("%d ", sint16_advance));
                if (0 == sint16_advance)
                {
                    VERBOSE(("\nXSpacing is zero!.\n"));
                }
#endif
            }
        }

        VERBOSE(("\r\n"));
        pOutput->Send_attr_ubyte(eXSpacingData);
    }
    //
    // Y Advance
    //
    if (bYAdvanceTrue)
    {
        pptlCharAdvance = pxlpdev->pptlCharAdvance;

        VERBOSE(("Y = "));
        if (bYUByte == TRUE)
        {
            //
            // ubyte YSpacing
            //
            pOutput->Send_ubyte_array_header((uint16)pxlpdev->dwCharCount);

            for (dwI = 0; dwI < pxlpdev->dwCharCount; dwI ++, pptlCharAdvance++)
            {
                ubyte_advance = (ubyte)pptlCharAdvance->y;
                pOutput->Write((PBYTE)&ubyte_advance, sizeof(ubyte));
#if DBG
                VERBOSE(("%d ", ubyte_advance));
                if (0 == ubyte_advance)
                {
                    VERBOSE(("\nYSpacing is zero!.\n"));
                }
#endif
            }
        }
        else
        {
            //
            // sint16 YSpacing
            //
            pOutput->Send_sint16_array_header((uint16)pxlpdev->dwCharCount);

            for (dwI = 0; dwI < pxlpdev->dwCharCount; dwI ++, pptlCharAdvance++)
            {
                sint16_advance = (sint16)pptlCharAdvance->y;
                pOutput->Write((PBYTE)&sint16_advance, sizeof(sint16));
#if DBG
                VERBOSE(("%d ", sint16_advance));
                if (0 == sint16_advance)
                {
                    VERBOSE(("\nYSpacing is zero!.\n"));
                }
#endif
            }
        }

        VERBOSE(("\r\n"));
        pOutput->Send_attr_ubyte(eYSpacingData);
    }

    pOutput->Send_cmd(eText);

    //
    // Reset text angle
    //
    if (pxlpdev->dwTextAngle && kFontTypeTTBitmap != pGState->GetFontType())
    {
        pOutput->Send_uint16(0);
        pOutput->Send_attr_ubyte(eCharAngle);
        pOutput->Send_cmd(eSetCharAngle);
        pxlpdev->dwTextAngle = 0;
    }

    pOutput->Flush(pdevobj);

    pxlpdev->dwCharCount = 0;

    return S_OK;
}

HRESULT
GetFONTOBJ(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    FONTOBJ   **ppFontObj)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    //
    // Error Check
    //
    if (NULL == ppFontObj                ||
        pdevobj->dwSize != sizeof(DEVOBJ) )
    {
        ERR(("PCLXL:GetFONTOBJ: invalid parameter[s].\n"));
        return E_UNEXPECTED;
    }

    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    DWORD dwGetInfo;
    GETINFO_FONTOBJ GFontObj;

    dwGetInfo = 
    GFontObj.dwSize = sizeof(GETINFO_FONTOBJ);
    GFontObj.pFontObj = NULL;

    if (!pUFObj->pfnGetInfo(pUFObj,
                            UFO_GETINFO_FONTOBJ,
                            &GFontObj,
                            dwGetInfo,
                            &dwGetInfo))
    {
        ERR(("PCLXL:GetXForm: GetInfo(FONTOBJ) failed\n"));
        return E_UNEXPECTED;
    }

    *ppFontObj = GFontObj.pFontObj;
    return S_OK;
}

HRESULT
GetXForm(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    FLOATOBJ_XFORM* pxform)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    //
    // Error Check
    //
    if (NULL == pxform ||
        NULL == pdevobj ||
        pdevobj->dwSize != sizeof(DEVOBJ) )
    {
        ERR(("PCLXL:GetXForm: invalid parameter[s].\n"));
        return E_UNEXPECTED;
    }

    FONTOBJ *pFontObj;
    if (S_OK != GetFONTOBJ(pdevobj, pUFObj, &pFontObj))
    {
        ERR(("PCLXL:GetXForm: GetFONTOBJ failed.\n"));
        return E_UNEXPECTED;
    }

    XFORMOBJ *pxo = FONTOBJ_pxoGetXform(pFontObj);
    XFORMOBJ_iGetFloatObjXform(pxo, pxform);

    return S_OK;
}

HRESULT
GetXYScale(
    FLOATOBJ_XFORM *pxform,
    FLOATOBJ *pfoXScale,
    FLOATOBJ *pfoYScale)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    //
    // Error Check
    //
    if (NULL == pxform     ||
        NULL == pfoXScale ||
        NULL == pfoYScale  )
    {
        ERR(("PCLXL:GetXYScale: invalid parameter[s].\n"));
        return E_UNEXPECTED;
    }

#if 0
    if( pxform->eM11 )
    {
        //
        // Either 0 or 180 rotation
        //
        if( pxform->eM11 > 0 )
        {
            //
            // Normal case,  0 degree rotation
            //
            *pfoXScale = pxform->eM11;
            *pfoYScale = pxform->eM22;
        }
        else
        {
            //
            // Reverse case,  180 degree rotation
            //
            *pfoXScale = -pxform->eM11;
            *pfoYScale = -pxform->eM22;
        }
    }
    else
    {
        //
        // Must be 90 or 270 degree rotation
        //
        if( pxform->eM12 < 0 )
        {
            //
            // The 90 degree case
            //
            *pfoXScale = pxform->eM21;
            *pfoYScale = -pxform->eM12;
        }
        else
        {
            //
            // The 270 degree case
            //
            *pfoXScale = -pxform->eM21;
            *pfoYScale = pxform->eM12;
        }
    }
#else
    if (pxform->eM21 == 0 && pxform->eM12 == 0)
    {
        //
        // 0 or 180 degree rotation
        //
        if( pxform->eM11 > 0 )
        {
            //
            // The 0 degree case
            //
            *pfoXScale = pxform->eM11;
            *pfoYScale = pxform->eM22;
        }
        else
        {
            //
            // The 180 degree case
            //
            *pfoXScale = -pxform->eM11;
            *pfoYScale = -pxform->eM22;
        }
    }
    else
    if (pxform->eM11 == 0 && pxform->eM22 == 0)
    {
        //
        // Must be 90 or 270 degree rotation
        //
        if( pxform->eM21 < 0 )
        {
            //
            // The 90 degree case
            //
            *pfoXScale = -pxform->eM21;
            *pfoYScale = pxform->eM12;
        }
        else
        {
            //
            // The 270 degree case
            //
            *pfoXScale = pxform->eM21;
            *pfoYScale = -pxform->eM12;
        }
    }
    else
    {
#pragma warning( disable: 4244)
        *pfoXScale = sqrt(pxform->eM11 * pxform->eM11 +
                          pxform->eM12 * pxform->eM12);
        *pfoYScale = sqrt(pxform->eM22 * pxform->eM22 +
                          pxform->eM21 * pxform->eM21);
#pragma warning( default: 4244)
    }
#endif

    return S_OK;
}


HRESULT
IsXYSame(
    FLOATOBJ_XFORM *pxform)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    BOOL     bRet;
    FLOATOBJ eM11 = pxform->eM11;

    if (FLOATOBJ_EqualLong(&eM11, 0))
    {
        return S_OK;
    }

    //
    // 0-90 or 180-270 case
    //     (eM11 > 0 & eM22 > 0)
    //     (eM12 < 0 & eM21 < 0)
    //
    // eM11 = (eM11 - eM22) / eM11;
    //
    FLOATOBJ_Sub(&(eM11), &(pxform->eM22));
    FLOATOBJ_Div(&(eM11), &(pxform->eM11));

    //
    // eM11 < 0.5%
    //
    bRet = FLOATOBJ_LessThanLong(&(eM11), FLOATL_IEEE_0_005F)
         & FLOATOBJ_GreaterThanLong(&(eM11), FLOATL_IEEE_0_005MF);

    if (!bRet)
    {
        //
        // 90-180 or 270-360 case
        //     (eM11 < 0, eM22 > 0)
        //     (eM11 > 0, eM22 < 0)
        //
        // eM11 = (eM11 + eM22) / eM11;
        //
        eM11 = pxform->eM11;
        FLOATOBJ_Add(&(eM11), &(pxform->eM22));
        FLOATOBJ_Div(&(eM11), &(pxform->eM11));

        //
        // eM11 < 0.5%
        //
        bRet = FLOATOBJ_LessThanLong(&(eM11), FLOATL_IEEE_0_005F)
             & FLOATOBJ_GreaterThanLong(&(eM11), FLOATL_IEEE_0_005MF);
    }

    if (bRet)
        return S_OK;
    else
        return S_FALSE;
}

DWORD
DwDownloadCompositeGlyph(
    PDEVOBJ pdevobj,
    ULONG ulFontID,
    PGLYF pGlyph)
/*++

Routine Description:

   Download composite glyph data.
Arguments:

    pdevobj - a pointer to PDEVOBJ
    ulFontID - font ID for this glyph.
    pGlyph - a pointer to GLYF data structure.

Return Value:


Note:


--*/
{
    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    XLTrueType *pTTFile = pxlpdev->pTTFile;

    PBYTE pubCGlyphData = (PBYTE)pGlyph;
    DWORD dwCGlyphDataSize, dwRet;

    dwRet = 0;

    if (pGlyph->numberOfContours != COMPONENTCTRCOUNT)
    {
        //
        // Error check. Make sure that this is a composite glyph.
        //
        return dwRet;
    }

    //
    // According to TrueType font spec, if numberOfContours == -1,
    // it has composite glyph data.
    //
    // When downloading special glyphs, specify the value 0xFFFF for the
    // CharCode attribute to the ReadChar operator.
    // This "special" CharCode value tells PCL XL 2.0 that
    // it is a "special" glyph.
    //
    // pCGlyf points an array of CGLYF. pCGlyf->flags says that there is
    // at least one more composite glyph available.
    // I need to go through all glyph data.
    //
    PCGLYF pCGlyf = (PCGLYF)(pubCGlyphData + sizeof(GLYF));
    SHORT sFlags;
    BOOL  bSpace;

    do
    {
        //
        // Swap bytes in any date in TrueType font, since it's Motorola-style ordering (Big Endian).
        //
        sFlags = SWAPW(pCGlyf->flags);

        //
        // Get glyph data from TrueType font object.
        //
        if (S_OK != pTTFile->GetGlyphData( SWAPW(pCGlyf->glyphIndex),
	           &pubCGlyphData,
	           &dwCGlyphDataSize))
        {
            ERR(("PCLXL:DownloadCharGlyph GetGlyphData failed.\r\n"));
            return FALSE;
        }

        if (NULL != pubCGlyphData && dwCGlyphDataSize != 0)
        {
            if (((PGLYF)pubCGlyphData)->numberOfContours == COMPONENTCTRCOUNT)
            {
                //
                // A recursive call to DwDownloadCompositeGlyph for this glyph.
                //
                dwRet += DwDownloadCompositeGlyph(pdevobj, ulFontID, (PGLYF)pubCGlyphData);
            }

            bSpace = FALSE;
        }
        else
        {
            bSpace = TRUE;
        }

        //
        // Download the actual glyph data for this glyph with 0xFFFF.
        // Special character (PCL XL 2.0)
        //
        if (!BDownloadGlyphData(pdevobj,
	ulFontID,
	0xFFFF,
	SWAPW(pCGlyf->glyphIndex),
	pubCGlyphData,
	dwCGlyphDataSize,
	bSpace))
        {
            ERR(("PCLXL:DownloadCharGlyph BDownloadGlyphData failed.\r\n"));
            return dwRet;
        }

        dwRet += dwCGlyphDataSize;

        //
        // If ARG_1_AND_2_ARE_WORDS is set, the arguments are words.
        // Otherwise, they are bytes.
        //
        PBYTE pByte = (PBYTE)pCGlyf;
        if (sFlags & ARG_1_AND_2_ARE_WORDS)
        {
            pByte += sizeof(CGLYF);
        }
        else
        {
            pByte += sizeof(CGLYF_BYTE);
        }

        pCGlyf = (PCGLYF)pByte;

    } while (sFlags & MORE_COMPONENTS);

    return dwRet;
}

inline BOOL
BSaveFont(
    PDEVOBJ pdevobj)
{
    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    pxlpdev->dwFlags |= XLPDEV_FLAGS_RESET_FONT;

    if (NULL == pxlpdev->pXLFont)
    {
        pxlpdev->pXLFont = new XLFont;
        if (NULL == pxlpdev->pXLFont)
        {
            return FALSE;
        }
    }

    XLGState *pGState = pxlpdev->pOutput;
    BYTE aubFontName[PCLXL_FONTNAME_SIZE];

    pGState->GetFontName(aubFontName);
    pxlpdev->pXLFont->SetFont(pGState->GetFontType(),
                              aubFontName,
                              pGState->GetFontHeight(),
                              pGState->GetFontWidth(),
                              pGState->GetFontSymbolSet(),
                              pGState->GetFontSimulation());

    pGState->ResetFont();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\raster.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    xlraster.cpp

Abstract:

    Implementation of PCLXL raster mode

Functions:

    PCLXLSetCursor
    PCLXLSendBitmap
    PCLXLFreeRaster
    PCLXLResetPalette


Environment:

    Windows Whistler

Revision History:

    09/22/00 
     Created it.

--*/

#include "lib.h"
#include "gpd.h"
#include "winres.h"
#include "pdev.h"
#include "common.h"
#include "xlpdev.h"
#include "pclxle.h"
#include "pclxlcmd.h"
#include "xldebug.h"
#include "xlgstate.h"
#include "xloutput.h"
#include "xlbmpcvt.h"
#include "pclxlcmn.h"
#include "xlraster.h"

//
// XLRASTER data structure
// The pointer is stored in pPDev->pVectorPDEV in case of kPCLXL_RASTER.
//
typedef struct _XLRASTER {
    XLOutput *pOutput;
    PBYTE    pubDstBuff;
    DWORD    dwDstBuffSize;
    PBYTE    pubRLEBuff;
    DWORD    dwRLEBuffSize;
    BOOL     bSentPalette;
} XLRASTER, *PXLRASTER;

//
// Functions
//
extern "C" HRESULT
PCLXLSendBitmap(
    PDEVOBJ pdevobj,
    ULONG   ulInputBPP,
    LONG    lHeight,
    LONG    lcbScanlineWidth,
    INT     iLeft,
    INT     iRight,
    PBYTE   pbData,
    PDWORD  pdwcbOut)
/*++

Routine Description:

    Send bitmap

Arguments:

pdevobj - a pointer to DEVOBJ
ulInputBPP - input bits per pixel
lHeight - height in pixel
lcbScanlineWidth - scanline with in byte
iLeft - left edge of scaline to print
iRight - right edge of scanline to print
pbData - a pointer to bitmap data
pdwcbOut - a pointer to a DWORD buffer to store the size of written data

Return Value:

    S_OK if succeeded. Otherwise S_FALSE or E_UNEXPECTED.

Note:


--*/
{
    LONG  lScanline, lWidth;
    ULONG ulOutputBPP;
    DWORD dwI, dwBufSize, dwLenNormal, dwLenRLE, dwcbLineSize, dwcbBmpSize;
    PDWORD pdwLen;
    PBYTE pubSrc, pBufNormal, pBufRLE, pBuf, pBmpSize;
    ColorMapping CMapping;
    XLOutput *pOutput;
    INT iBitmapFormat;
    OutputFormat OutputF;
    HRESULT hRet;

    //
    // Parameter varidation
    //
    if (NULL == pdevobj || NULL == pdwcbOut)
    {
        ERR(("PCLXLSendBitmap: Invalid parameters.\n"));
        return E_UNEXPECTED;
    }

    PXLRASTER pXLRaster = (PXLRASTER)(((PPDEV)pdevobj)->pVectorPDEV);

    //
    // Allocate XLRASTER
    // Will be freed in RMDisablePDEV.
    //
    if (NULL == pXLRaster)
    {
        pXLRaster = (PXLRASTER)MemAllocZ(sizeof(XLRASTER));
        ((PPDEV)pdevobj)->pVectorPDEV =  (PVOID) pXLRaster;

        if (NULL == pXLRaster)
        {
            ERR(("PCLXLSendBitmap: Memory allocation failed.\n"));
            return E_UNEXPECTED;
        }

        pXLRaster->pOutput = pOutput = new XLOutput;

        if (NULL == pOutput)
        {
            MemFree(pXLRaster);
            ERR(("PCLXLSendBitmap: Memory allocation failed.\n"));
            return E_UNEXPECTED;
        }
    }
    else
    {
        pOutput = pXLRaster->pOutput;
    }

    //
    // Set source transparent mode
    //
    pOutput->SetPaintTxMode(eOpaque);
    pOutput->SetSourceTxMode(eOpaque);

    //
    // Get Output format and input format
    //
    iBitmapFormat = (INT)NumToBPP(ulInputBPP);
    DetermineOutputFormat(iBitmapFormat, &OutputF, &ulOutputBPP);

    //
    // Set CMapping.
    // Send palette for 1BPP halftone image for B&W printers.
    // Palette is sent per page for XL Raster mode.
    //
    if (ulOutputBPP == 1)
    {
        if (!pXLRaster->bSentPalette)
        {
            ColorDepth CDepth = e8Bit;
            
            //
            // Hardcoded black and white palette for XL RASTER.
            //
            DWORD adwColorTable[2] = {0x00ffffff, 0x0};
            pOutput->SetColorSpace(eGray);
            pOutput->SetPaletteDepth(CDepth);
            pOutput->SetPaletteData(CDepth, 2, adwColorTable);
            pOutput->Send_cmd(eSetColorSpace);
            pXLRaster->bSentPalette = TRUE;

        }

        //
        // Set index pixel (palette) for black and white printer
        //
        CMapping = eIndexedPixel;
    }
    else
    {
        //
        // Initialize pixel mapping.
        //
        CMapping = eDirectPixel;
    }

    //
    // Get height, width, and scanline size.
    //
    // The number of bytes in a scaline.
    //
    dwcbLineSize = lcbScanlineWidth;

    //
    // The number of pixel in a scanline
    // lWidth = lcbScanlineWidth / (ulInputBPP / 8);
    //
    lWidth = lcbScanlineWidth * 8 / ulInputBPP;

    //
    // Buffer size
    // The size of scaline has to be DWORD align.
    //
    // height x width + header + endimage
    // width has to be DWORD-aligned.
    //
    dwBufSize = lHeight * (((lWidth * ulOutputBPP + 31) >> 5 ) << 2) +
                DATALENGTH_HEADER_SIZE + sizeof(PCLXL_EndImage);

    //
    // BeginImage
    //
    pOutput->BeginImage(
                   CMapping,
                   ulOutputBPP,
                   lWidth,
                   lHeight,
                   lWidth,
                   lHeight);

    //
    // Normal and RLE destination bitmap buffer allocation.
    //
    // Check if the normal and RLE destination buffer is available and the size
    // is larger than required size. Otherwise, we can reused the buffer.
    //
    if (NULL == pXLRaster->pubDstBuff ||
        NULL == pXLRaster->pubRLEBuff ||
        pXLRaster->dwDstBuffSize <dwBufSize ||
        pXLRaster->dwRLEBuffSize <dwBufSize)
    {
        if (NULL != pXLRaster->pubDstBuff)
        {
            MemFree(pXLRaster->pubDstBuff);
            pXLRaster->dwDstBuffSize = 0;
        }
        if (NULL != pXLRaster->pubRLEBuff)
        {
            MemFree(pXLRaster->pubRLEBuff);
            pXLRaster->dwRLEBuffSize = 0;
        }

        if (NULL == (pBufNormal = (PBYTE)MemAllocZ(dwBufSize)))
        {
            ERR(("PCLXLSendBitmap: Memory allocation failed.\n"));
            pOutput->Delete();
            return E_UNEXPECTED;
        }
        if (NULL == (pBufRLE = (PBYTE)MemAllocZ(dwBufSize)))
        {
            ERR(("PCLXLSendBitmap: Memory allocation failed.\n"));
            if (NULL != pBufNormal)
            {
                MemFree(pBufNormal);
            }
            pOutput->Delete();
            return E_UNEXPECTED;
        }

        pXLRaster->pubDstBuff = pBufNormal;
        pXLRaster->dwDstBuffSize = dwBufSize;
        pXLRaster->pubRLEBuff = pBufRLE;
        pXLRaster->dwRLEBuffSize = dwBufSize;
    }
    else
    {
        pBufNormal = pXLRaster->pubDstBuff;
        pBufRLE = pXLRaster->pubRLEBuff;
    }

    //
    // Convert src bitmap to dst bitmap
    //
    CompressMode CMode;
    BMPConv BMPC;
    PBYTE pubDst;
    DWORD dwSize;

    //
    // Setup BMPConv
    //
    BMPC.BSetInputBPP((BPP)iBitmapFormat);
    BMPC.BSetOutputBPP(NumToBPP(ulOutputBPP));
    BMPC.BSetOutputBMPFormat(OutputF);

    //
    // Conversion.
    // Take two steps. No compression and RLE compression. At the end, compare
    // the size of buffers and decide which one we take.
    //
    #define RLE_COMPRESSION 0
    #define NO_COMPRESSION 1
    for (dwI = 0; dwI < 2; dwI ++)
    {
        hRet = S_OK;

        if (NO_COMPRESSION == dwI)
        {
            VERBOSE(("PCLXLSendBitmap(): No-compres\n"));
            pBuf = pBufNormal;
            pdwLen = &dwLenNormal;
        }
        else
        {
            VERBOSE(("PCLXLSendBitmap(): RLE-compres\n"));
            pBuf = pBufRLE;
            pdwLen = &dwLenRLE;
        }

        lScanline = lHeight;

        //
        // Set pubSrc
        //
        pubSrc = pbData;

        //
        // Set dataLength tag
        //
        *pBuf = PCLXL_dataLength;

        //
        // Get the pointer to the buffer where we store the size of data.
        //
        pBmpSize = pBuf + 1;
        pBuf += DATALENGTH_HEADER_SIZE;
        *pdwLen = DATALENGTH_HEADER_SIZE;

        //
        // Set compression flag in BMPConv
        //
        BMPC.BSetRLECompress(dwI == RLE_COMPRESSION);

        dwcbBmpSize = 0;

        //
        // Scaline base conversion
        //
        while (lScanline-- > 0 && dwcbBmpSize + *pdwLen < dwBufSize)
        {
            pubDst = BMPC.PubConvertBMP(pubSrc , dwcbLineSize);
            dwSize = BMPC.DwGetDstSize();
            VERBOSE(("PCLXLSendBitmap[0x%x]: dwDstSize=0x%x\n", lScanline, dwSize));

            if ( dwcbBmpSize +
                 dwSize +
                 DATALENGTH_HEADER_SIZE +
                 sizeof(PCLXL_EndImage) > dwBufSize || NULL == pubDst)
            {
                VERBOSE(("PCLXLSendBitmap: Buffer size is too small.\n"));
                hRet = E_UNEXPECTED;
                break;
            }

            memcpy(pBuf, pubDst, dwSize);
            dwcbBmpSize += dwSize;
            pBuf += dwSize;

            pubSrc += lcbScanlineWidth;
        }

        if (hRet == S_OK && lScanline > 0)
        {
            hRet = S_FALSE;
            VERBOSE(("ComonRopBlt: Conversion failed.\n"));
        }

        if (hRet == S_OK)
        {
            if (dwI == NO_COMPRESSION)
            {
                //
                // Scanline on PCL-XL has to be DWORD align.
                //
                // count byte of scanline = lWidth * ulOutputBPP / 8
                //
                dwcbBmpSize = lHeight * (((lWidth * ulOutputBPP + 31) >> 5 ) << 2);
            }

            //
            // Set the size of bitmap
            //
            CopyMemory(pBmpSize, &dwcbBmpSize, sizeof(dwcbBmpSize));
            *pdwLen += dwcbBmpSize;

            //
            // Set endimage command
            //
            *pBuf = PCLXL_EndImage;
            (*pdwLen) ++;
        }
        else
        {
            //
            // Conversion failed!
            //
            *pdwLen = 0;
        }
    }
    #undef NO_COMPRESSION
    #undef RLE_COMPRESSION

    //
    // Compare which mode is smaller, RLE or non-compression.
    // Take smaller one.
    //
    if (hRet == S_OK)
    {
        DWORD dwBitmapSize;

        if (dwLenRLE != 0 && dwLenRLE < dwLenNormal)
        {
            VERBOSE(("PCLXLSendBitmap RLE: dwSize=0x%x\n", dwLenRLE));
            pBuf = pBufRLE;
            pdwLen = &dwLenRLE;
            CMode = eRLECompression;
        }
        else
        {
            VERBOSE(("PCLXLSendBitmap Normal: dwSize=0x%x\n", dwLenNormal));
            pBuf = pBufNormal;
            pdwLen = &dwLenNormal;
            CMode = eNoCompression;
        }

        //
        // ReadImage and send the bitmap.
        //
        pOutput->ReadImage(lHeight, CMode);
        pOutput->Flush(pdevobj);

        CopyMemory(&dwBitmapSize, pBuf + 1, sizeof(DWORD));

        if (dwBitmapSize > 0xff)
        {
            //
            // dataLength
            // size (uin32) (bitmap size)
            // DATA
            // EndImage
            //
            WriteSpoolBuf((PPDEV)pdevobj, pBuf, *pdwLen);
        }
        else
        {
            //
            // dataLength
            // size (byte) (bitmap size)
            // DATA
            // EndImage
            //
            pBuf += 3;
            *pBuf = PCLXL_dataLengthByte;
            *(pBuf + 1) = (BYTE)dwBitmapSize;
            WriteSpoolBuf((PPDEV)pdevobj, pBuf, (*pdwLen) - 3);
        }

        *pdwcbOut = *pdwLen;
    }
    else
    {
        pOutput->Delete();
    }

    return hRet;
}

extern "C" HRESULT
PCLXLSetCursor(
    PDEVOBJ pdevobj,
    ULONG   ulX,
    ULONG   ulY)
/*++

Routine Description:

    Send cursor move command

Arguments:

pdevobj - a pointer to DEVOBJ
ulX - X position
ulY - Y position

Return Value:

    S_OK if succeeded. Otherwise S_FALSE or E_UNEXPECTED.

Note:

--*/
{
    //
    // Parameter varidation
    //
    if (NULL == pdevobj)
    {
        return E_UNEXPECTED;
    }

    PXLRASTER pXLRaster = (PXLRASTER)(((PPDEV)pdevobj)->pVectorPDEV);
    XLOutput *pOutput;

    //
    // Allocate XLRASTER
    // Will be freed in RMDisablePDEV.
    //
    if (NULL == pXLRaster)
    {
        pXLRaster = (PXLRASTER)MemAllocZ(sizeof(XLRASTER));
        ((PPDEV)pdevobj)->pVectorPDEV =  (PVOID) pXLRaster;

        if (NULL == pXLRaster)
        {
            return E_UNEXPECTED;
        }

        pXLRaster->pOutput = pOutput = new XLOutput;

        if (NULL == pOutput)
        {
            MemFree(pXLRaster);
            return E_UNEXPECTED;
        }
    }
    else
    {
        pOutput = pXLRaster->pOutput;
        ASSERT(pOutput);
    }

    //
    // Send cusor move command
    //
    return pOutput->SetCursor(ulX, ulY);
}

extern "C" HRESULT
PCLXLFreeRaster(
    PDEVOBJ pdevobj)
/*++

Routine Description:

    Free XLRASTER

Arguments:

pdevobj - a pointer to DEVOBJ

Return Value:

    S_OK if succeeded. Otherwise S_FALSE or E_UNEXPECTED.

Note:

--*/
{
    //
    // Parameter varidation
    //
    if (NULL == pdevobj)
    {
        return E_UNEXPECTED;
    }

    PXLRASTER pXLRaster = (PXLRASTER)(((PPDEV)pdevobj)->pVectorPDEV);
    if (pXLRaster->pOutput)
    {
        delete pXLRaster->pOutput;
    }
    if (pXLRaster->pubRLEBuff)
    {
        MemFree(pXLRaster->pubRLEBuff);
    }
    if (pXLRaster->pubDstBuff)
    {
        MemFree(pXLRaster->pubDstBuff);
    }
    MemFree(pXLRaster);

    return S_OK;
}

extern "C" HRESULT
PCLXLResetPalette(
    PDEVOBJ pdevobj)
/*++

Routine Description:

    Reset palette flag in XLRASTER
    Palette has to be set per page.

Arguments:

pdevobj - a pointer to DEVOBJ

Return Value:

    S_OK if succeeded. Otherwise S_FALSE or E_UNEXPECTED.

Note:

--*/
{
    //
    // Parameter varidation
    //
    if (NULL == pdevobj)
    {
        return E_UNEXPECTED;
    }

    PXLRASTER pXLRaster = (PXLRASTER)(((PPDEV)pdevobj)->pVectorPDEV);

    if (pXLRaster)
    {
        pXLRaster->bSentPalette = FALSE;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlbmpcvt.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xlbmpcvt.h

Abstract:

    Bitmap conversion header

Environment:

    Windows Whistler

Revision History:

    03/23/00
        Created it.

--*/

#ifndef _XLBMPCVT_H_
#define _XLBMPCVT_H_

//
// Macros for getting color components
//

#define RED(x)            ((BYTE) ((x)      ))
#define GREEN(x)          ((BYTE) ((x) >>  8))
#define BLUE(x)           ((BYTE) ((x) >> 16))

#define CYAN(x)           ((BYTE) ((x)      ))
#define MAGENTA(x)        ((BYTE) ((x) >>  8))
#define YELLOW(x)         ((BYTE) ((x) >> 16))
#define BLACK(x)          ((BYTE) ((x) >> 24))

//
// Macro to convert from RGB to grayscale
//
// The formula we're using is: grayscale = 0.3*R + 0.59*G + 0.11*B.
// Scale it up with 256 to avoid a division operation.
//
//
#define RGB2GRAY(r, g, b) ((BYTE) (((r)*77 + (g)*151 + (b)*28) >> 8))


#define GET_COLOR_TABLE(pxlo) \
        (((pxlo)->flXlate & XO_TABLE) ? \
        ((pxlo)->pulXlate ? (pxlo)->pulXlate : XLATEOBJ_piVector(pxlo)) : NULL)

inline
BYTE DWORD2GRAY(
    DWORD dwColor)
/*++

Routine Description:

    Converts RGB 24 bit color to 8 bit gray scale.

Arguments:

    RGB 24 bit color

Return Value:

    8 bit gray scale.

Note:

--*/
{
    return RGB2GRAY(RED(dwColor), GREEN(dwColor), BLUE(dwColor));
}

typedef enum {
    e1bpp  = BMF_1BPP,
    e4bpp  = BMF_4BPP,
    e8bpp  = BMF_8BPP,
    e16bpp = BMF_16BPP,
    e24bpp = BMF_24BPP,
    e32bpp = BMF_32BPP
} BPP;

typedef enum {
    eOutputGray,
    eOutputPal,
    eOutputRGB,
    eOutputCMYK
} OutputFormat;

typedef enum {
    eOddPixelZero,
    eOddPixelOne
} OddPixel;

typedef enum {
    eBitZero,
    eBitOne,
    eBitTwo,
    eBitThree,
    eBitFour,
    eBitFive,
    eBitSize,
    eBitSeven
} FirstBit;

typedef BOOL (*PFNDIBCONV)(PBYTE, DWORD);

class BMPConv 
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'cpmb' )

public:

    BMPConv::
    BMPConv( VOID );

    BMPConv::
    ~BMPConv( VOID );

    BOOL
    BSetInputBPP(BPP InputBPP);

    BOOL
    BSetOutputBPP(BPP OutputBPP);

    BOOL
    BSetOutputBMPFormat(OutputFormat BitmapFormat);

    BOOL
    BSetRLECompress(BOOL bRLEOn);

    BOOL
    BSetXLATEOBJ(XLATEOBJ *pxlo);

    DWORD
    DwGetDstSize(VOID);

    BOOL
    BGetRLEStatus(VOID);

    PBYTE
    PubConvertBMP(PBYTE pubSrc, DWORD dwcbSrcSize);

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    //
    // Attrbutes
    //

    #define BMPCONV_SET_INPUTBPP        0x00000001
    #define BMPCONV_SET_OUTPUTBPP       0x00000002
    #define BMPCONV_SET_OUTPUTBMPFORMAT 0x00000004
    #define BMPCONV_SET_XLATEOBJ        0x00000008

    #define BMPCONV_2COLOR_24BPP        0x00000010

    #define BMPCONV_CHECKXLATEOBJ       0x00000f00
    #define BMPCONV_XLATE               0x00000100
    #define BMPCONV_BGR                 0x00000200
    #define BMPCONV_32BPP_RGB           0x00000400
    #define BMPCONV_32BPP_BGR           0x00000800

    #define BMPCONV_RLE_ON              0x80000000

    DWORD m_flags;

    BPP          m_InputBPP;        // Source bitmap bits per pixel
    BPP          m_OutputBPP;       // Destination bitmap bits per pixel
    OutputFormat m_OutputFormat;    // Destination bitmap format
    OddPixel     m_OddPixelStart; // 0 or 1, whether scanline starts on odd-pixel
    FirstBit     m_FirstBit;      // 0 to 7: starting bit of the scanline's first pixel

    XLATEOBJ *m_pxlo;

    //
    // Destination buffer
    //
    DWORD m_dwOutputBuffSize;
    PBYTE m_pubOutputBuff;
    DWORD m_dwRLEOutputBuffSize;
    DWORD m_dwRLEOutputDataSize;
    PBYTE m_pubRLEOutputBuff;

    //
    // Internal functions
    //
    BOOL
    BCopy( PBYTE       pubSrc,
           DWORD       dwSrcPixelNum);

    BOOL
    B4BPPtoCMYK(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);

    BOOL
    B4BPPtoRGB(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);

    BOOL
    B4BPPtoGray(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);

    BOOL
    B8BPPtoGray(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B8BPPtoRGB(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B8BPPtoCMYK(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B16BPPtoGray(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B16BPPtoRGB(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B24BPPtoGray(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B24BPPtoRGB(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B32BPPtoGray(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B32BPPtoRGB(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    B32BPPtoCMYK(
        IN     PBYTE       pubSrc,
        IN     DWORD       dwSrcPixelNum);

    BOOL
    BArbtoGray(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);

    BOOL
    BArbtoRGB(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);

#ifdef WINNT_40
    BOOL
    B24BPPToImageMask(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);
#endif // WINNT_40


    BOOL
    BConversionProc(
        PBYTE       pubSrc,
        DWORD       dwSrcPixelNum);

    BOOL
    BCompressRLE(VOID);

    DWORD
    DwCheckXlateObj(XLATEOBJ*, BPP);

};


BPP
NumToBPP(
    ULONG ulBPP);

ULONG
UlBPPtoNum(
    BPP Bpp);

#endif // _XLBMPCVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\truetype.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    truetype.cpp

    Abstract:

        TrueType font handlig object

    Environment:

        Windows Whistler

    Revision History:

        10/04/99     
            Created it.

--*/

#include "xlpdev.h"
#include "xldebug.h"
#include "xltext.h"
#include "xltt.h"

//
// Function to  retrieve True Type font information from the True Type file
// 
// Need to parse through and pick up the tables needed for the PCL spec. There
// are 8 tables of which 5 are required and three are optional. Tables are
// sorted in alphabetical order.   The PCL tables needed are:
// cvt -  optional
// fpgm - optional
// gdir - required (Empty table. See truetype.h)
// head - required
// hhea - required
// vhea - required (For vertical fonts)
// hmtx - required
// maxp - required
// prep - optional
//
// loca - required for glyph data
//
// The optional tables are used in hinted fonts.
//

XLTrueType::
XLTrueType(
    VOID):
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
    m_pfo(NULL),
    m_pTTFile(NULL),
    m_pTTHeader(NULL),
    m_pTTDirHead(NULL),
    m_usNumTables(0),
    m_ulFileSize(0),
    m_dwFlags(0),
    m_dwNumTag(0),
    m_dwNumGlyph(0)
{
#if DBG
    SetDbgLevel(TRUETYPEDBG);
#endif
    XL_VERBOSE(("XLTrueType::CTor. "));
    XL_VERBOSE(("m_pTTFile=0x%x. ", m_pTTFile));
    XL_VERBOSE(("m_pfo=0x%x.\n", m_pfo));
}

XLTrueType::
~XLTrueType(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::DTor.\n"));
}

HRESULT
XLTrueType::
OpenTTFile(
    FONTOBJ* pfo)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::OpenTTFile entry.(pfo=%x) ", pfo));
    XL_VERBOSE(("m_pTTFile=0x%x. ", m_pTTFile));
    XL_VERBOSE(("m_pfo=0x%x.\n", m_pfo));
    HRESULT hResult = S_FALSE;

    //
    // Make sure that pfo is no NULL.
    //
    if (NULL != pfo)
    {
        //
        // Call engine function if the pointer to TrueType font is NULL.
        //
        if (NULL == m_pTTFile)
        {
            XL_VERBOSE(("XLTrueType:Calls FONTOBJ_pvTrueTypeFontFile.\n"));
            if (m_pTTFile = FONTOBJ_pvTrueTypeFontFile(pfo, &m_ulFileSize))
            {
                XL_VERBOSE(("XLTrueType:GDI returns m_pTTFile=0x%x.\n", m_pTTFile));
                XL_VERBOSE(("m_pfo=0x%x.\n", m_pfo));
                m_pfo = pfo;
                m_dwFlags = 0;

                //
                // Check if this font is TTC.
                //
                if ((DWORD)TTTag_ttcf == *(PDWORD)m_pTTFile)
                {
                    XL_VERBOSE(("XLTrueType::OpenTTFile: TTC file.\n"));
                    m_dwFlags |= XLTT_TTC;
                }

                IFIMETRICS *pIFI = FONTOBJ_pifi(pfo);
                if (NULL != pIFI)
                {
                    if ('@' == *((PBYTE)pIFI + pIFI->dpwszFamilyName))
                    {
                        m_dwFlags |= XLTT_VERTICAL_FONT; 
                        XL_VERBOSE(("XLTrueType::OpenTTFile: Vertical Font.\n"));
                    }
                }

                if (S_OK != ParseTTDir())
                {
                    XL_ERR(("XLTrueType::OpenTTFile TrueType font parsing failed.\n"));
                    //
                    // Reset pointers
                    //
                    m_pTTFile = NULL;
                    m_pfo = NULL;
                    hResult = S_FALSE;
                }
                else
                {
                    hResult = S_OK;
                }
            }
            else
            {
                XL_ERR(("XLTrueType::OpenTTFile FONTOBJ_pvTrueTypeFontFile failed.\n"));
                hResult = S_FALSE;
            }
        }
        else
            hResult = S_OK;
    }
#if DBG
    else
        XL_ERR(("XLTrueType::OpenTTFile pfo is NULL.\n"));
#endif


    return hResult;
}

HRESULT
XLTrueType::
CloseTTFile(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::CloseTTFile entry. "));
    XL_VERBOSE(("m_pTTFile=0x%x. ", m_pTTFile));
    XL_VERBOSE(("m_pfo=0x%x.\n", m_pfo));

    m_pfo         = NULL;
    m_pTTFile     = NULL;
    m_pTTHeader   = NULL;
    m_pTTDirHead  = NULL;
    m_usNumTables = 0;
    m_ulFileSize  = 0;
    m_dwFlags     = 0;
    m_dwNumTag    = 0;
    m_dwNumGlyph  = 0;

    return S_OK;
}

HRESULT
XLTrueType::
SameFont(
    FONTOBJ* pfo)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::SameFont entry. "));
    XL_VERBOSE(("m_pTTFile=0x%x. ", m_pTTFile));
    XL_VERBOSE(("m_pfo=0x%x.\n", m_pfo));

    //
    // iTTUniq  from MSDN
    //
    // Specifies the associated TrueType file. Two separate point size
    // realizations of a TrueType font face will have FONTOBJ structures
    // that share the same iTTUniq value, but will have different iUniq values.
    // Only TrueType font types can have a nonzero iTTUniq member.
    // For more information see flFontType. 
    //
    // We compare only iTTUniq. IUniq will have different values for separate
    // point size realizations.
    //
    if ( !(pfo->flFontType & TRUETYPE_FONTTYPE) ||
         m_pfo == NULL                          ||
         pfo->iTTUniq != m_pfo->iTTUniq          )
    {
        return S_FALSE;
    }

    return S_OK;
}


HRESULT
XLTrueType::
GetHeader(
    PTTHEADER *ppHeader)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::GetHeader.\n"));

    //
    // Error check
    //
    if (NULL == m_pTTFile)
    {
        XL_ERR(("XLTrueType::GetHeader m_pTTFile is NULL.\n"));
        return E_UNEXPECTED;
    }

    //
    // Incomming parameter validation
    //
    if (NULL == ppHeader)
    {
        XL_ERR(("XLTrueType::GetHeader ppHeader is invalid.\n"));
        return E_UNEXPECTED;
    }

    if (m_pTTHeader)
        *ppHeader = m_pTTHeader;
    else
        *ppHeader = NULL;

    return S_OK;
}

DWORD
XLTrueType::
GetSizeOfTable(
    TTTag tag)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::GetSizeOfTable entry. "));
    XL_VERBOSE(("m_pTTFile=0x%x.\n", m_pTTFile));

    //
    // Error check
    //
    if (NULL == m_pTTFile)
    {
        XL_ERR(("XLTrueType::GetSizeOfTable m_pTTFile is NULL.\n"));
        return 0;
    }

    DWORD dwID = TagID_MAX;
    if (S_OK == TagAndID(&dwID, &tag))
        return SWAPDW(m_pTTDir[dwID]->ulLength);
    else
    {
        XL_ERR(("XLTrueType::GetSizeOfTable: Invalid tag.\n"));
        return 0;
    }
}

HRESULT
XLTrueType::
GetTable(
    TTTag  tag,
    PVOID  *ppTable,
    PDWORD pdwSize)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::GetTable entry. "));
    XL_VERBOSE(("m_pTTFile=0x%x.\n", m_pTTFile));
    XL_VERBOSE(("Tag=%c%c%c%c\n", 0xff &  tag,
                                  0xff & (tag >> 8),
                                  0xff & (tag >> 16),
                                  0xff & (tag >> 24)));

    //
    // Error check
    //
    if (NULL == ppTable)
    {
        XL_ERR(("XLTrueType::GetTable ppTable is invalid.\n"));
        return E_UNEXPECTED;
    }
    if (NULL == m_pTTFile)
    {
        *ppTable = NULL;
        *pdwSize = 0;
        XL_ERR(("XLTrueType::GetTable m_pTTFile is NULL.\n"));
        return E_UNEXPECTED;
    }

    DWORD dwID = TagID_MAX;
    if (S_OK == TagAndID(&dwID, &tag) &&
        NULL != m_pTTDir[dwID]         )
    {
        *ppTable = (PVOID)((PBYTE)m_pTTFile + SWAPDW(m_pTTDir[dwID]->ulOffset));
        *pdwSize = SWAPDW(m_pTTDir[dwID]->ulLength);
    }
    else
    {
        *ppTable = NULL;
        *pdwSize = 0;
        XL_VERBOSE(("XLTrueType::GetTable Invalid tag.\n"));
    }

    if (*ppTable && *pdwSize)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLTrueType::
GetTableDir(
    TTTag  tag,
    PVOID  *ppTable)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::GetTableDir entry. "));
    XL_VERBOSE(("m_pTTFile=0x%x.\n", m_pTTFile));
    XL_VERBOSE(("Tag=%c%c%c%c\n", 0xff &  tag,
                                  0xff & (tag >> 8),
                                  0xff & (tag >> 16),
                                  0xff & (tag >> 24)));

    //
    // Error check
    //
    if (NULL == m_pTTFile)
    {
        *ppTable = NULL;
        XL_ERR(("XLTrueType::GetTable m_pTTFile is NULL.\n"));
        return E_UNEXPECTED;
    }

    DWORD dwID = TagID_MAX;
    if (S_OK == TagAndID(&dwID, &tag))
        *ppTable = m_pTTDir[dwID];
    else
    {
        XL_ERR(("XLTrueType::GetTableDir Invalid tag.\n"));
        *ppTable = NULL;
    }

    if (*ppTable)
        return S_OK;
    else
        return S_FALSE;
}


HRESULT
XLTrueType::
ParseTTDir(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::ParseTTDir entry. "));
    XL_VERBOSE(("m_pTTFile=0x%x.\n", m_pTTFile));

    HRESULT hResult;

    //
    // Already parsed?
    //
    if (m_dwFlags & XLTT_DIR_PARSED)
    {
        XL_VERBOSE(("XLTrueType::ParseTTDir TTFile is already parsed.\n"));
        return S_OK;
    }

    //
    // Error check
    //
    if (NULL == m_pTTFile)
    {
        XL_ERR(("XLTrueType::ParseTTDir m_pTTFile is NULL.\n"));
        return E_UNEXPECTED;
    }

    //
    // Parse Table Directory
    //
    // Get header pointer
    //
    if (m_dwFlags & XLTT_TTC)
    {
        //
        // Get TrueType font header of TTC.
        // Stolen from PostScript driver.
        // A trick to figure out the inde xin a TTC file. Bodin suggested
        // follwoing:
        //
        // From: Bodin Dresevic <bodind@MICROSOFT.com>
        // Date: Fri, 18 Apr 1997 16:00:23 -0700
        // ...
        // If TTC file supports vertical writing (mort or gsub table are
        // present), then you can get to the index in the ttf file within TTC
        // as follows:
        //
        // iTTC = (pfo.iFace - 1) / 2; // pfo.iFace is 1 based, iTTC is zero
        // based.
        //
        // If the font does not support vertical writing (do not know of any
        // ttc's like that, but they could exist in principle) than iTTC is just
        // iTTC = pfo.iFace - 1;
        //
        // In principle, one could have a mixture of faces, some supporting 
        // vertical writing and some not, but I doubt that any such fonts
        // really exist.
        // ...
        //
        ULONG ulTTC =  (ULONG)( (m_pfo->iFace - 1) / 2 );
        ULONG ulDirCount = SWAPDW( ((PTTCHEADER)m_pTTFile)->ulDirCount );

        if (ulTTC >= ulDirCount)
        {
            XL_ERR(("XLTrueType::ParseTTDir Invalid TTC index.\n"));
            CloseTTFile();
            return E_UNEXPECTED;
        }

        //
        // TTC header
        //    dwTTCTag    = 'ttcf'
        //    dwVersion
        //    ulDirCount
        //    dwOffset[0]
        //    dwOffset[1]
        //    ..
        //
        DWORD dwOffset = *(PDWORD)((PBYTE)m_pTTFile +
                                          sizeof(TTCHEADER) +
                                          ulTTC * sizeof(DWORD));
        dwOffset = SWAPDW(dwOffset);
        m_pTTHeader = (PTTHEADER)((PBYTE)m_pTTFile + dwOffset);
    }
    else
    {
        m_pTTHeader = (PTTHEADER)m_pTTFile;
    }

    //
    // Get table directory pointer
    //
    m_pTTDirHead  = (PTTDIR)(m_pTTHeader + 1);
    m_usNumTables = SWAPW(m_pTTHeader->usNumTables);

    //
    // Parse table directory and make sure that necessary tags exist.
    //
    PTTDIR pTTDirTmp = m_pTTDirHead;
    TTTag tag;
    USHORT usI;
    DWORD  dwTagID;
    
    //
    // Initialize m_pTTDir to NULL.
    //
    for (usI = 0; usI < TagID_MAX; usI ++)
    {
        m_pTTDir[usI] = NULL;
    }

    m_dwNumTag = 0;

    //
    // Initialize m_pTTDir
    //
    for (usI = 0; usI < m_usNumTables; usI ++, pTTDirTmp++)
    {
        XL_VERBOSE(("XLTrueType::ParseTTDir Tag=%c%c%c%c\n",
                                              0xff &  pTTDirTmp->ulTag,
                                              0xff & (pTTDirTmp->ulTag >> 8),
                                              0xff & (pTTDirTmp->ulTag >> 16),
                                              0xff & (pTTDirTmp->ulTag >> 24)));
        XL_VERBOSE(("                       CheckSum=0x%x\n", pTTDirTmp->ulCheckSum));
        XL_VERBOSE(("                       Offset=0x%x\n", pTTDirTmp->ulOffset));
        XL_VERBOSE(("                       Length=0x%x\n", pTTDirTmp->ulLength));
        //
        // Get TagID for the tag.
        //
        dwTagID = TagID_MAX;
        tag = (TTTag)pTTDirTmp->ulTag;
        if (S_OK == TagAndID(&dwTagID, &tag))
        {
            //
            // The tag is in our tag table. In TrueType.h, TTTag and TagID;
            //
            m_pTTDir[dwTagID] = pTTDirTmp;
            m_dwNumTag ++;
        }
    }

    //
    // Initialize flags, etc.
    //
    // Get head table's short/long offset flag and the number of glyph.
    //
    DWORD dwSize;
    PHEAD pHead;
    if (S_OK == GetTable(TTTag_head, (PVOID*)&pHead, &dwSize))
    {
        //
        // Don't need to swap, It's a boolean flag.
        //
        if (0 == pHead->indexToLocFormat)
            m_dwFlags |= XLTT_SHORT_OFFSET_TO_LOC;
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLTrueType::ParseTTDir head table is not found.\n"));
        hResult = E_UNEXPECTED;
    }

    PMAXP pMaxp;
    if (S_OK == hResult &&
        S_OK == GetTable(TTTag_maxp, (PVOID*)&pMaxp, &dwSize))
    {
        m_dwNumGlyph = SWAPW(pMaxp->numGlyphs);
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLTrueType::ParseTTDir maxp table is not found.\n"));
        hResult = E_UNEXPECTED;
    }

    PHHEA pHhea;
    if (S_OK == hResult &&
        S_OK == GetTable(TTTag_hhea, (PVOID*)&pHhea, &dwSize))
    {
        m_dwNumOfHMetrics = SWAPW(pHhea->usNumberOfHMetrics);
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLTrueType::ParseTTDir hhea table is not found.\n"));
        hResult = E_UNEXPECTED;
    }

    PVHEA pVhea;
    //
    // Only check if the font is vertical.
    //
    if (m_dwFlags &  XLTT_VERTICAL_FONT)
    {
        if (S_OK == hResult &&
            S_OK == GetTable(TTTag_vhea, (PVOID*)&pVhea, &dwSize))
        {
            m_dwNumOfVMetrics = SWAPW(pVhea->usNumberOfVMetrics);
            hResult = S_OK;
        }
        else
        {
            XL_ERR(("XLTrueType::ParseTTDir vhea table is not found.\n"));
            hResult = E_UNEXPECTED;
        }
    }

    if (S_OK == hResult)
    {
        m_dwFlags |= XLTT_DIR_PARSED;
    }
    else
    {
        CloseTTFile();
        m_dwFlags &= ~XLTT_DIR_PARSED;
    }
    return hResult;
}

HRESULT
XLTrueType::
GetHMTXData(
    HGLYPH hGlyphID,
    PUSHORT pusAdvanceWidth,
    PSHORT  psLeftSideBearing)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT hResult;
    PHMTX pHmtx;
    DWORD dwSize;

    XL_VERBOSE(("XLTrueType::GetHMTXData entry.\n"));

    //
    // Error check
    //
    if (NULL == pusAdvanceWidth || NULL == psLeftSideBearing)
    {
        return E_UNEXPECTED;
    }

    if (hGlyphID >= m_dwNumGlyph)
    {
        return E_UNEXPECTED;
    }

    //
    // http://www.microsoft.com/typography/OTSPEC/hmtx.htm
    //
    if (S_OK == GetTable(TTTag_hmtx, (PVOID*)&pHmtx, &dwSize))
    {
        if (hGlyphID < m_dwNumOfHMetrics)
        {
            *pusAdvanceWidth = SWAPW(pHmtx[hGlyphID].usAdvanceWidth);
            *psLeftSideBearing = SWAPW(pHmtx[hGlyphID].sLeftSideBearing);
        }
        else
        {
            PSHORT pasLeftSideBearing = (PSHORT)(pHmtx+m_dwNumOfHMetrics);

            *pusAdvanceWidth = SWAPW(pHmtx[m_dwNumOfHMetrics - 1].usAdvanceWidth);
            *psLeftSideBearing = SWAPW(pasLeftSideBearing[hGlyphID - m_dwNumOfHMetrics]);
        }
        XL_VERBOSE(("XLTrueType::GetHMTXData AW=%d, LSB=%d.\n",
                                   *pusAdvanceWidth,
                                   *psLeftSideBearing));
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLTrueType::GetHMTXData failed.\n"));
        hResult = E_UNEXPECTED;
    }

    return hResult;
}

HRESULT
XLTrueType::
GetVMTXData(
    HGLYPH hGlyphID,
    PUSHORT pusAdvanceWidth,
    PSHORT psTopSideBearing,
    PSHORT psLeftSideBearing)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT hResult;
    PVMTX pVmtx;
    DWORD dwSize;

    XL_VERBOSE(("XLTrueType::GetVMTXData entry.\n"));

    //
    // Error check
    //
    if (NULL == pusAdvanceWidth ||
        NULL == psLeftSideBearing ||
        NULL == psTopSideBearing)
    {
        return E_UNEXPECTED;
    }

    if (hGlyphID >= m_dwNumGlyph)
    {
        return E_UNEXPECTED;
    }

    //
    // http://www.microsoft.com/typography/OTSPEC/Vmtx.htm
    //
    if (S_OK == GetHMTXData(hGlyphID, pusAdvanceWidth, psLeftSideBearing) &&
        S_OK == GetTable(TTTag_vmtx, (PVOID*)&pVmtx, &dwSize))
    {
        if (hGlyphID <= m_dwNumOfVMetrics)
        {
            *psTopSideBearing = SWAPW(pVmtx[hGlyphID].sTopSideBearing);
        }
        else
        {
            PSHORT pasTopSideBearing = (PSHORT)(pVmtx+m_dwNumOfVMetrics);

            *psTopSideBearing = SWAPW(pasTopSideBearing[hGlyphID - m_dwNumOfVMetrics]);
        }
        XL_VERBOSE(("XLTrueType::GetVMTXData TSB=%d\n", *psTopSideBearing));
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLTrueType::ParseTTDir maxp table is not found.\n"));
        hResult = E_UNEXPECTED;
    }

    return hResult;
}
 

HRESULT
XLTrueType::
TagAndID(
    DWORD *pdwID,
    TTTag *ptag)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD dwI;
    HRESULT hResult = S_FALSE;

    const struct {
        TagID tagID;
        TTTag tag;
    } TagIDConv[TagID_MAX] =
    {
        {TagID_cvt , TTTag_cvt },
        {TagID_fpgm, TTTag_fpgm},
        {TagID_gdir, TTTag_gdir}, // Empty table. See truetype.h.
        {TagID_head, TTTag_head},
        {TagID_maxp, TTTag_maxp},
        {TagID_perp, TTTag_perp},

        {TagID_hhea, TTTag_hhea},
        {TagID_hmtx, TTTag_hmtx},
        {TagID_vhea, TTTag_vhea},
        {TagID_vmtx, TTTag_vmtx},

        {TagID_loca, TTTag_loca},
        {TagID_glyf, TTTag_glyf}
    };

    if (NULL != pdwID && NULL != ptag)
    {

        if (*pdwID == TagID_MAX)
        {
            for (dwI = 0; dwI < TagID_MAX; dwI ++)
            {
                if (TagIDConv[dwI].tag ==  *ptag)
                {
                    hResult = S_OK;
                    *pdwID = dwI;
                    break;
                }
            }
        }
        else
        if (*ptag == TTTag_INVALID && *pdwID < TagID_MAX)
        {
            *ptag = TagIDConv[*pdwID].tag;
            hResult = S_OK;
        }
    }

    return  hResult;
}

DWORD
XLTrueType::
GetNumOfTag(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::GetNumOfTag.\n"));
    return m_dwNumTag;
}

HRESULT
XLTrueType::
GetGlyphData(
    HGLYPH hGlyph,
    PBYTE *ppubGlyphData,
    PDWORD pdwGlyphDataSize)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLTrueType::GetGlyphData.\n"));
    
    PVOID pLoca, pGlyf;
    HRESULT hResult = S_FALSE;
    DWORD dwTableSize, dwOffset;

    if (S_OK == GetTable( TTTag_loca, &pLoca, &dwTableSize) &&
        S_OK == GetTable( TTTag_glyf, &pGlyf, &dwTableSize)  )
    {
        if (m_dwFlags & XLTT_SHORT_OFFSET_TO_LOC)
        {
            USHORT *pusOffset, usI, usJ;

            pusOffset = (USHORT*) pLoca + hGlyph;
            usI = SWAPW(pusOffset[0]);
            usJ = SWAPW(pusOffset[1]);
            dwOffset = usI;

            *pdwGlyphDataSize = (USHORT) (usJ - usI) << 1;
            *ppubGlyphData = (PBYTE)pGlyf + (dwOffset << 1);
        }
        else
        {
            ULONG *pusOffset, ulI, ulJ;

            pusOffset = (ULONG*) pLoca + hGlyph;
            ulI = SWAPDW(pusOffset[0]);
            ulJ = SWAPDW(pusOffset[1]);
            dwOffset = ulI;

            *pdwGlyphDataSize = (ULONG)(ulJ - ulI);
            *ppubGlyphData = (PBYTE)pGlyf + dwOffset;
        }
        hResult = S_OK;
    }
    else
    {
        XL_ERR(("XLTrueType::GetGlyphData: GetTable failed.\n"));
    }
    return hResult;
}

HRESULT
XLTrueType::
GetTypoDescender(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{

    return S_OK;
}

HRESULT
XLTrueType::
IsTTC(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT lRet;

    if (!(m_dwFlags & XLTT_DIR_PARSED))
        lRet = E_UNEXPECTED;
    else
    if (m_dwFlags &  XLTT_TTC)
        lRet = S_OK;
    else
        lRet = S_FALSE;

    return lRet;
}

HRESULT
XLTrueType::
IsVertical(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT lRet;

    if (!(m_dwFlags & XLTT_DIR_PARSED))
        lRet = E_UNEXPECTED;
    else
    if (m_dwFlags &  XLTT_VERTICAL_FONT)
        lRet = S_OK;
    else
        lRet = S_FALSE;

    return lRet;
}

HRESULT
XLTrueType::
IsDBCSFont(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT lRet;

    if (!(m_dwFlags & XLTT_DIR_PARSED) || NULL == m_pfo)
        lRet = E_UNEXPECTED;
    else
    if (m_pfo->flFontType & FO_DBCS_FONT)
        lRet = S_OK;
    else
        lRet = S_FALSE;

    return lRet;
}

#if DBG
VOID
XLTrueType::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    m_dbglevel = dwLevel;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xldebug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     xldebug.h

Abstract:

    PCL XL debug class

Environment:

    Windows Whistler

Revision History:

    03/23/00
      Created it.

--*/

#ifndef _XLDEBUG_H_
#define  _XLDEBUG_H_

#if DBG

class XLDebug {
public:
    virtual VOID SetDbgLevel(DWORD dwLevel) = 0;

protected:
    DWORD     m_dbglevel;
};

#endif
#endif // _XLDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\pclxlcmd.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     pclxlcmd.h

Abstract:

    PCL XL commands

Environment:

    Windows Whistler

Revision History:

    03/23/00 
      Created it.

--*/

#ifndef _PCLXLCMD_H_
#define _PCLXLCMD_H_

//
// Binary Stream Tag
//

extern const BYTE PCLXL_NULL;
extern const BYTE PCLXL_HT;
extern const BYTE PCLXL_LF;
extern const BYTE PCLXL_VT;
extern const BYTE PCLXL_FF;
extern const BYTE PCLXL_CR;
extern const BYTE PCLXL_SP;

extern const BYTE PCLXL_BeginSession;
extern const BYTE PCLXL_EndSession;
extern const BYTE PCLXL_BeginPage;
extern const BYTE PCLXL_EndPage;

extern const BYTE PCLXL_Comment;
extern const BYTE PCLXL_OpenDataSource;
extern const BYTE PCLXL_CloseDataSource;

extern const BYTE PCLXL_BeginFontHeader;
extern const BYTE PCLXL_ReadFontHeader;
extern const BYTE PCLXL_EndFontHeader;
extern const BYTE PCLXL_BeginChar;
extern const BYTE PCLXL_ReadChar;
extern const BYTE PCLXL_EndChar;
extern const BYTE PCLXL_RemoveFont;

extern const BYTE PCLXL_BeginStream;
extern const BYTE PCLXL_ReadStream;
extern const BYTE PCLXL_EndStream;
extern const BYTE PCLXL_ExecStream;


extern const BYTE PCLXL_PopGS;
extern const BYTE PCLXL_PushGS;

extern const BYTE PCLXL_SetClipReplace;
extern const BYTE PCLXL_SetBrushSource;
extern const BYTE PCLXL_SetCharAngle;
extern const BYTE PCLXL_SetCharScale;
extern const BYTE PCLXL_SetCharShear;
extern const BYTE PCLXL_SetClipIntersect;
extern const BYTE PCLXL_SetClipRectangle;
extern const BYTE PCLXL_SetClipToPage;
extern const BYTE PCLXL_SetColorSpace;
extern const BYTE PCLXL_SetCursor;
extern const BYTE PCLXL_SetCursorRel;
extern const BYTE PCLXL_SetHalftoneMethod;
extern const BYTE PCLXL_SetFillMode;
extern const BYTE PCLXL_SetFont;

extern const BYTE PCLXL_SetLineDash;
extern const BYTE PCLXL_SetLineCap;
extern const BYTE PCLXL_SetLineJoin;
extern const BYTE PCLXL_SetMiterLimit;
extern const BYTE PCLXL_SetPageDefaultCTM;
extern const BYTE PCLXL_SetPageOrigin;
extern const BYTE PCLXL_SetPageRotation;
extern const BYTE PCLXL_SetPageScale;
extern const BYTE PCLXL_SetPatternTxMode;
extern const BYTE PCLXL_SetPenSource;
extern const BYTE PCLXL_SetPenWidth;
extern const BYTE PCLXL_SetROP;
extern const BYTE PCLXL_SetSourceTxMode;
extern const BYTE PCLXL_SetCharBoldValue;

extern const BYTE PCLXL_SetClipMode;
extern const BYTE PCLXL_SetPathToClip;
extern const BYTE PCLXL_SetCharSubMode;

extern const BYTE PCLXL_CloseSubPath;
extern const BYTE PCLXL_NewPath;
extern const BYTE PCLXL_PaintPath;

extern const BYTE PCLXL_ArcPath;

extern const BYTE PCLXL_BezierPath;

extern const BYTE PCLXL_BezierRelPath;
extern const BYTE PCLXL_Chord;
extern const BYTE PCLXL_ChordPath;
extern const BYTE PCLXL_Ellipse;
extern const BYTE PCLXL_EllipsePath;

extern const BYTE PCLXL_LinePath;
extern const BYTE PCLXL_Pie;
extern const BYTE PCLXL_PiePath;
extern const BYTE PCLXL_Rectangle;
extern const BYTE PCLXL_RectanglePath;

extern const BYTE PCLXL_RoundRectangle;
extern const BYTE PCLXL_RoundRectanglePath;

extern const BYTE PCLXL_Text;
extern const BYTE PCLXL_TextPath;

extern const BYTE PCLXL_BeginImage;
extern const BYTE PCLXL_ReadImage;
extern const BYTE PCLXL_EndImage;
extern const BYTE PCLXL_BeginRestPattern;
extern const BYTE PCLXL_ReadRastPattern;
extern const BYTE PCLXL_EndRastPattern;
extern const BYTE PCLXL_BeginScan;

extern const BYTE PCLXL_EndScan;
extern const BYTE PCLXL_ScanLineRel;

extern const BYTE PCLXL_ubyte;
extern const BYTE PCLXL_uint16;
extern const BYTE PCLXL_uint32;
extern const BYTE PCLXL_sint16;
extern const BYTE PCLXL_sint32;
extern const BYTE PCLXL_real32;

extern const BYTE PCLXL_ubyte_array;
extern const BYTE PCLXL_uint16_array;
extern const BYTE PCLXL_uint32_array;
extern const BYTE PCLXL_sint16_array;
extern const BYTE PCLXL_sint32_array;
extern const BYTE PCLXL_real32_array;

extern const BYTE PCLXL_ubyte_xy;
extern const BYTE PCLXL_uint16_xy;
extern const BYTE PCLXL_uint32_xy;
extern const BYTE PCLXL_sint16_xy;
extern const BYTE PCLXL_sint32_xy;
extern const BYTE PCLXL_real32_xy;

extern const BYTE PCLXL_ubyte_box;
extern const BYTE PCLXL_uint16_box;
extern const BYTE PCLXL_uint32_box;
extern const BYTE PCLXL_sint16_box;
extern const BYTE PCLXL_sint32_box;
extern const BYTE PCLXL_real32_box;

extern const BYTE PCLXL_attr_ubyte;
extern const BYTE PCLXL_attr_uint16;

extern const BYTE PCLXL_dataLength;

extern const BYTE PCLXL_dataLengthByte;


//
// Attribute tag
//

extern const BYTE PCLXL_PaletteDepth;
extern const BYTE PCLXL_ColorSpace;
extern const BYTE PCLXL_NullBrush;
extern const BYTE PCLXL_NullPen;
extern const BYTE PCLXL_PaleteData;

extern const BYTE PCLXL_PatternSelectID;
extern const BYTE PCLXL_GrayLevel;

extern const BYTE PCLXL_RGBColor;
extern const BYTE PCLXL_PatternOrigin;
extern const BYTE PCLXL_NewDestinationSize;

extern const BYTE PCLXL_ColorimetricColorSpace;

extern const BYTE PCLXL_DeviceMatrix;
extern const BYTE PCLXL_DitherMatrixDataType;
extern const BYTE PCLXL_DitherOrigin;
extern const BYTE PCLXL_MediaDestination;
extern const BYTE PCLXL_MediaSize;
extern const BYTE PCLXL_MediaSource;
extern const BYTE PCLXL_MediaType;
extern const BYTE PCLXL_Orientation;
extern const BYTE PCLXL_PageAngle;
extern const BYTE PCLXL_PageOrigin;
extern const BYTE PCLXL_PageScale;
extern const BYTE PCLXL_ROP3;
extern const BYTE PCLXL_TxMode;

extern const BYTE PCLXL_CustomMediaSize;

extern const BYTE PCLXL_CustomMediaSizeUnits;
extern const BYTE PCLXL_PageCopies;
extern const BYTE PCLXL_DitherMatrixSize;
extern const BYTE PCLXL_DithermatrixDepth;
extern const BYTE PCLXL_SimplexPageMode;
extern const BYTE PCLXL_DuplexPageMode;
extern const BYTE PCLXL_DuplexPageSide;

extern const BYTE PCLXL_ArcDirection;
extern const BYTE PCLXL_BoundingBox;
extern const BYTE PCLXL_DashOffset;
extern const BYTE PCLXL_EllipseDimension;
extern const BYTE PCLXL_EndPoint;
extern const BYTE PCLXL_FillMode;
extern const BYTE PCLXL_LineCap;
extern const BYTE PCLXL_LineJoin;
extern const BYTE PCLXL_MiterLength;
extern const BYTE PCLXL_PenDashStyle;
extern const BYTE PCLXL_PenWidth;
extern const BYTE PCLXL_Point;
extern const BYTE PCLXL_NumberOfPoints;
extern const BYTE PCLXL_SolidLine;
extern const BYTE PCLXL_StartPoint;

extern const BYTE PCLXL_PointType;
extern const BYTE PCLXL_ControlPoint1;
extern const BYTE PCLXL_ControlPoint2;
extern const BYTE PCLXL_ClipRegion;
extern const BYTE PCLXL_ClipMode;

extern const BYTE PCLXL_ColorDepth;
extern const BYTE PCLXL_BlockHeight;
extern const BYTE PCLXL_ColorMapping;
extern const BYTE PCLXL_CompressMode;
extern const BYTE PCLXL_DestinationBox;
extern const BYTE PCLXL_DestinationSize;
extern const BYTE PCLXL_PatternPersistence;
extern const BYTE PCLXL_PatternDefineID;

extern const BYTE PCLXL_SourceHeight;
extern const BYTE PCLXL_SourceWidth;
extern const BYTE PCLXL_StartLine;
extern const BYTE PCLXL_XPairType;
extern const BYTE PCLXL_NumberOfXPairs;

extern const BYTE PCLXL_XStart;
extern const BYTE PCLXL_XEnd;
extern const BYTE PCLXL_NumberOfScanLines;

extern const BYTE PCLXL_CommentData;
extern const BYTE PCLXL_DataOrg;

extern const BYTE PCLXL_Measure;

extern const BYTE PCLXL_SourceType;
extern const BYTE PCLXL_UnitsPerMeasure;

extern const BYTE PCLXL_StreamName;
extern const BYTE PCLXL_StreamDataLength;

extern const BYTE PCLXL_ErrorReport;

extern const BYTE PCLXL_CharAngle;
extern const BYTE PCLXL_CharCode;
extern const BYTE PCLXL_CharDataSize;
extern const BYTE PCLXL_CharScale;
extern const BYTE PCLXL_CharShear;
extern const BYTE PCLXL_CharSize;
extern const BYTE PCLXL_FontHeaderLength;
extern const BYTE PCLXL_FontName;
extern const BYTE PCLXL_FontFormat;
extern const BYTE PCLXL_SymbolSet;
extern const BYTE PCLXL_TextData;
extern const BYTE PCLXL_CharSubModeArray;

extern const BYTE PCLXL_XSpacingData;

extern const BYTE PCLXL_YSpacingData;
extern const BYTE PCLXL_CharBoldValue;

#endif // _PCLXLCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlddi.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    xlddi.cpp

Abstract:

    Implementation of PCLXL drawing DDI entry points

Functions:

    PCLXLBitBlt
    PCLXLStretchBlt
    PCLXLStretchBltROP
    PCLXLCopyBits
    PCLXLPlgBlt
    PCLXLAlphaBlend
    PCLXLGradientFill
    PCLXLTextOut
    PCLXLStrokePath
    PCLXLFillPath
    PCLXLStrokeAndFillPath
    PCLXLRealizeBrush
    PCLXLStartPage
    PCLXLSendPage
    PCLXLEscape
    PCLXLStartDcc
    PCLXLEndDoc


Environment:

    Windows Whistler

Revision History:

    08/23/99 
     Created it.

--*/

#include "lib.h"
#include "gpd.h"
#include "winres.h"
#include "pdev.h"
#include "common.h"
#include "xlpdev.h"
#include "pclxle.h"
#include "pclxlcmd.h"
#include "xldebug.h"
#include "xlbmpcvt.h"
#include "xlgstate.h"
#include "xloutput.h"
#include "pclxlcmd.h"
#include "pclxlcmn.h"
#include "xltt.h"

////////////////////////////////////////////////////////////////////////////////
//
// Globals
//
extern const LINEATTRS *pgLineAttrs;

////////////////////////////////////////////////////////////////////////////////
//
// Local function prototypes
//

inline
VOID
DetermineOutputFormat(
    INT          iBitmapFormat,
    OutputFormat *pOutputF,
    ULONG        *pulOutputBPP);

HRESULT
CommonRopBlt(
   IN PDEVOBJ    pdevobj,
   IN SURFOBJ    *psoSrc,
   IN CLIPOBJ    *pco,
   IN XLATEOBJ   *pxlo,
   IN BRUSHOBJ   *pbo,
   IN RECTL      *prclSrc,
   IN RECTL      *prclDst,
   IN POINTL     *pptlBrush,
   IN ROP4        rop4);



////////////////////////////////////////////////////////////////////////////////
//
// Drawing DDI entries
//

extern "C" BOOL APIENTRY
PCLXLBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4)
/*++

Routine Description:

    Implementation of DDI entry point DrvBitBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoTrg - Describes the target surface
    psoSrc - Describes the source surface
    psoMask - Describes the mask for rop4
    pco - Limits the area to be modified
    pxlo - Specifies how color indices are translated between the source
           and target surfaces
    prclTrg - Defines the area to be modified
    pptlSrc - Defines the upper left corner of the source rectangle
    pptlMask - Defines which pixel in the mask corresponds
               to the upper left corner of the source rectangle
    pbo - Defines the pattern for bitblt
    pptlBrush - Defines the origin of the brush in the Dstination surface
    rop4 - ROP code that defines how the mask, pattern, source, and
           Dstination pixels are combined to write to the Dstination surface

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVOBJ    pdevobj = (PDEVOBJ)psoTrg->dhpdev;
    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLBitBlt() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    {
        RECTL rclSrc;

        //
        // create prclSrc (source rectangle)
        //

        if (pptlSrc)
        {
            rclSrc.left   = pptlSrc->x;
            rclSrc.top    = pptlSrc->y;
            rclSrc.right  = pptlSrc->x + RECT_WIDTH(prclTrg);
            rclSrc.bottom = pptlSrc->y + RECT_HEIGHT(prclTrg);
        }
        else
        {
            rclSrc.left   = 0;
            rclSrc.top    = 0;
            rclSrc.right  = RECT_WIDTH(prclTrg);
            rclSrc.bottom = RECT_HEIGHT(prclTrg);
        }

        if (S_OK == CommonRopBlt(pdevobj, psoSrc, pco, pxlo, pbo, &rclSrc, prclTrg, pptlBrush, rop4))
            return TRUE;
        else
            return FALSE;
    }

}


extern "C" BOOL APIENTRY
PCLXLStretchBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode)
/*++

Routine Description:

    Implementation of DDI entry point DrvStretchBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst - Defines the surface on which to draw
    psoSrc - Defines the source for blt operation
    psoMask - Defines a surface that provides a mask for the source
    pco - Limits the area to be modified on the Dstination
    pxlo - Specifies how color dwIndexes are to be translated
           between the source and target surfaces
    pca - Defines color adjustment values to be applied to the source bitmap
    pptlHTOrg - Specifies the origin of the halftone brush
    prclDst - Defines the area to be modified on the Dstination surface
    prclSrc - Defines the area to be copied from the source surface
    pptlMask - Specifies which pixel in the given mask corresponds to
               the upper left pixel in the source rectangle
    iMode - Specifies how source pixels are combined to get output pixels

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLStretchBlt() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    if (S_OK == CommonRopBlt(pdevobj, psoSrc, pco, pxlo, NULL, prclSrc, prclDst, NULL, 0xCC))
        return TRUE;
    else
        return FALSE;

}


extern "C" BOOL APIENTRY
PCLXLStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4)
/*++

Routine Description:

    Implementation of DDI entry point DrvStretchBltROP.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst - Specifies the target surface
    psoSrc - Specifies the source surface
    psoMask - Specifies the mask surface
    pco - Limits the area to be modified
    pxlo - Specifies how color indices are translated
           between the source and target surfaces
    pca - Defines color adjustment values to be applied to the source bitmap
    prclHTOrg - Specifies the halftone origin
    prclDst - Area to be modified on the destination surface
    prclSrc - Rectangle area on the source surface
    prclMask - Rectangle area on the mask surface
    pptlMask - Defines which pixel in the mask corresponds to
               the upper left corner of the source rectangle
    iMode - Specifies how source pixels are combined to get output pixels
    pbo - Defines the pattern for bitblt
    rop4 - ROP code that defines how the mask, pattern, source, and
           destination pixels are combined on the destination surface

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLStretchBltROP() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    if (S_OK == CommonRopBlt(pdevobj, psoSrc, pco, pxlo, pbo, prclSrc, prclDst, NULL, rop4))
        return TRUE;
    else
        return FALSE;

}


extern "C" BOOL APIENTRY
PCLXLCopyBits(
    SURFOBJ        *psoDst,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDst,
    POINTL         *pptlSrc)
/*++

Routine Description:

    Implementation of DDI entry point DrvCopyBits.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst - Points to the Dstination surface
    psoSrc - Points to the source surface
    pxlo - XLATEOBJ provided by the engine
    pco - Defines a clipping region on the Dstination surface
    pxlo - Defines the translation of color indices
           between the source and target surfaces
    prclDst - Defines the area to be modified
    pptlSrc - Defines the upper-left corner of the source rectangle

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    PXLPDEV    pxlpdev;

    RECTL rclSrc;

    VERBOSE(("PCLXLCopyBits() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    //
    // create prclSrc (source rectangle)
    //

    rclSrc.top    = pptlSrc->y;
    rclSrc.left   = pptlSrc->x;
    rclSrc.bottom = pptlSrc->y + RECT_HEIGHT(prclDst);
    rclSrc.right  = pptlSrc->x + RECT_WIDTH(prclDst);

    if (S_OK == CommonRopBlt(pdevobj, psoSrc, pco, pxlo, NULL, &rclSrc, prclDst, NULL, 0xCC))
        return TRUE;
    else
        return FALSE;

}


extern "C" BOOL APIENTRY
PCLXLPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode)
/*++

Routine Description:

    Implementation of DDI entry point DrvPlgBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst - Defines the surface on which to draw
    psoSrc - Defines the source for blt operation
    psoMask - Defines a surface that provides a mask for the source
    pco - Limits the area to be modified on the Dstination
    pxlo - Specifies how color dwIndexes are to be translated
        between the source and target surfaces
    pca - Defines color adjustment values to be applied to the source bitmap
    pptlBrushOrg - Specifies the origin of the halftone brush
    ppfixDest - Defines the area to be modified on the Dstination surface
    prclSrc - Defines the area to be copied from the source surface
    pptlMask - Specifies which pixel in the given mask corresponds to
        the upper left pixel in the source rectangle
    iMode - Specifies how source pixels are combined to get output pixels

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    VERBOSE(("PCLXLPlgBlt() entry.\n"));

    return EngPlgBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlBrushOrg,
                 pptfixDst, prclSrc, pptlMask, iMode);
}


extern "C" BOOL APIENTRY
PCLXLAlphaBlend(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLAlphaBlend() entry.\n"));
    PDEV *pPDev = (PDEV*)psoDst->dhpdev;
    BOOL bRet;

    if (NULL == pPDev)
    {
        return FALSE;
    }

    pPDev->fMode2 |= PF2_WHITEN_SURFACE;
    bRet = EngAlphaBlend(psoDst,
                         psoSrc,
                         pco,
                         pxlo,
                         prclDst,
                         prclSrc,
                         pBlendObj);
    pPDev->fMode2 &= ~(PF2_WHITEN_SURFACE|PF2_SURFACE_WHITENED);
    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLGradientFill(
    SURFOBJ    *psoDst,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLGradientFill() entry.\n"));
    PDEV *pPDev = (PDEV*) psoDst->dhpdev;
    BOOL bRet;

    if (NULL == pPDev)
    {
        return FALSE;
    }

    if (ulMode == GRADIENT_FILL_TRIANGLE)
    {
        pPDev->fMode2 |= PF2_WHITEN_SURFACE;
    }
    bRet = EngGradientFill(psoDst,
                           pco,
                           pxlo,
                           pVertex,
                           nVertex,
                           pMesh,
                           nMesh,
                           prclExtents,
                           pptlDitherOrg,
                           ulMode);
    pPDev->fMode2 &= ~(PF2_WHITEN_SURFACE|PF2_SURFACE_WHITENED);
    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;

    VERBOSE(("PCLXLTextOut() entry.\n"));

    PXLPDEV pxlpdev= (PXLPDEV)pdevobj->pdevOEM;
    XLOutput *pOutput = pxlpdev->pOutput;

    //
    // Clip
    //
    if (!SUCCEEDED(pOutput->SetClip(pco)))
        return FALSE;

    ROP4 rop = GET_FOREGROUND_ROP3(UlVectMixToRop4(mix));

    if (!ROP3_NEED_SOURCE(rop))
        rop = 0x00fc;


    //
    // Set ROP and TxMode.
    // Send NewPath to flush memory.
    //
    pOutput->SetROP3(rop);
    pOutput->Send_cmd(eNewPath);
    pOutput->SetPaintTxMode(eOpaque);
    pOutput->SetSourceTxMode(eOpaque);

    //
    // Opaque Rectangle
    //
    if (prclOpaque)
    {
        pOutput->SetPenColor(NULL, NULL);
        pOutput->SetBrush(pboOpaque, pptlOrg);
        pOutput->Send_cmd(eNewPath);
        pOutput->RectanglePath(prclOpaque);
        pOutput->Paint();
    }

    //
    // Draw underline, strikeout, etc.
    //
    if (prclExtra)
    {
        pOutput->SetPenColor(NULL, NULL);
        pOutput->SetBrush(pboFore, pptlOrg);
        pOutput->Send_cmd(eNewPath);
        while(NULL != prclExtra) 
        {
            pOutput->RectanglePath(prclExtra++);
        }
        pOutput->Paint();
    }

    //
    // Text Color
    //
    pOutput->SetBrush(pboFore, pptlOrg);
    pOutput->Flush(pdevobj);

    //
    // Device font/TrueType download
    //
    DrvTextOut(
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlOrg,
            mix);

    //
    // Flush cached text before changing font
    //
    FlushCachedText(pdevobj);

    //
    // Reset text angle
    //
    pxlpdev->dwTextAngle = 0;

    //
    // Close TrueType font
    //
    pxlpdev->pTTFile->CloseTTFile();

    return TRUE;
}


extern "C" BOOL APIENTRY
PCLXLLineTo(
    SURFOBJ   *pso,
    CLIPOBJ   *pco,
    BRUSHOBJ  *pbo,
    LONG       x1,
    LONG       y1,
    LONG       x2,
    LONG       y2,
    RECTL     *prclBounds,
    MIX        mix)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;
    POINTFIX   Pointfix;
    LINEATTRS  lineattrs;

    VERBOSE(("PCLXLLineTo() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;
    Pointfix.x = x2 << 4;
    Pointfix.y = y2 << 4;
    lineattrs = *pgLineAttrs;
    lineattrs.elWidth.e = FLOATL_IEEE_1_0F;

    ROP4 rop = GET_FOREGROUND_ROP3(UlVectMixToRop4(mix));
    TxMode     TxModeValue;

    //
    // Quick return in the case of AA (destination).
    //
    if (rop == 0xAA)
    {
        return TRUE;
    }

    //
    // If there is any Pattern involved, set TxMode to Opaque.
    //
    if (ROP3_NEED_PATTERN(rop))
    {
        TxModeValue = eOpaque;
    }
    else
    {
        TxModeValue = eTransparent;
    }

    BOOL bRet;
    XLOutput *pOutput = pxlpdev->pOutput;

    if (S_OK == pOutput->SetClip(pco) &&
        S_OK == pOutput->SetROP3(rop) &&
        S_OK == pOutput->SetPaintTxMode(TxModeValue) &&
        S_OK == pOutput->SetSourceTxMode(TxModeValue) &&
        S_OK == pOutput->SetPen(&lineattrs, NULL) &&
        S_OK == pOutput->SetPenColor(pbo, NULL) &&
        S_OK == pOutput->SetBrush(NULL, NULL) &&
        S_OK == pOutput->Send_cmd(eNewPath) &&
        S_OK == pOutput->SetCursor(x1, y1) &&
        S_OK == pOutput->LinePath(&Pointfix, 1) &&
        S_OK == pOutput->Paint() &&
        S_OK == pOutput->Flush(pdevobj))
        bRet = TRUE;
    else
    {
        pOutput->Delete();
        bRet = FALSE;
    }


    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;
    TxMode     TxModeValue;

    VERBOSE(("PCLXLStokePath() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    BOOL bRet;
    XLOutput *pOutput = pxlpdev->pOutput;

    ROP4 rop = GET_FOREGROUND_ROP3(UlVectMixToRop4(mix));

    //
    // Quick return in the case of AA (destination).
    //
    if (rop == 0xAA)
    {
        return TRUE;
    }

    //
    // If there is any Pattern involved, set TxMode to Opaque.
    //
    if (ROP3_NEED_PATTERN(rop))
    {
        TxModeValue = eOpaque;
    }
    else
    {
        TxModeValue = eTransparent;
    }

    if (S_OK == pOutput->SetClip(pco) &&
        S_OK == pOutput->SetROP3(rop) &&
        S_OK == pOutput->SetPaintTxMode(TxModeValue) &&
        S_OK == pOutput->SetSourceTxMode(TxModeValue) &&
        S_OK == pOutput->SetPen(plineattrs, pxo) &&
        S_OK == pOutput->SetPenColor(pbo, pptlBrushOrg) &&
        S_OK == pOutput->SetBrush(NULL, NULL) &&
        S_OK == pOutput->Path(ppo) &&
        S_OK == pOutput->Paint() &&
        S_OK == pOutput->Flush(pdevobj))
        bRet = TRUE;
    else
    {
        pOutput->Delete();
        bRet = FALSE;
    }


    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLFillPath() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    BOOL bRet;
    XLOutput *pOutput = pxlpdev->pOutput;

    ROP4 rop = GET_FOREGROUND_ROP3(UlVectMixToRop4(mix));
    TxMode     TxModeValue;

    //
    // Quick return in the case of AA (destination).
    //
    if (rop == 0xAA)
    {
        return TRUE;
    }

    //
    // If there is any Pattern involved, set TxMode to Opaque.
    //
    if (ROP3_NEED_PATTERN(rop))
    {
        TxModeValue = eOpaque;
    }
    else
    {
        TxModeValue = eTransparent;
    }

    //
    // Setup fill mode
    //
    FillMode FM;
    if (flOptions == FP_ALTERNATEMODE)
    {
        FM =  eFillEvenOdd;
    }
    else if (flOptions == FP_WINDINGMODE)
    {
        FM =  eFillNonZeroWinding;
    }

    if (S_OK == pOutput->SetClip(pco) &&
        S_OK == pOutput->SetROP3(rop) &&
        S_OK == pOutput->SetPaintTxMode(TxModeValue) &&
        S_OK == pOutput->SetSourceTxMode(TxModeValue) &&
        S_OK == pOutput->SetFillMode(FM) &&
        S_OK == pOutput->SetPenColor(NULL, NULL) &&
        S_OK == pOutput->SetBrush(pbo, pptlBrushOrg) &&
        S_OK == pOutput->Path(ppo) &&
        S_OK == pOutput->Paint() &&
        S_OK == pOutput->Flush(pdevobj))
        bRet = TRUE;
    else
    {
        pOutput->Delete();
        bRet = FALSE;
    }

    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLStrokeAndFillPath() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;
    XLOutput *pOutput = pxlpdev->pOutput;
    BOOL bRet;
    ROP4 rop = GET_FOREGROUND_ROP3(UlVectMixToRop4(mixFill));
    TxMode     TxModeValue;

    //
    // Quick return in the case of AA (destination).
    //
    if (rop == 0xAA)
    {
        return TRUE;
    }

    //
    // If there is any Pattern involved, set TxMode to Opaque.
    //
    if (ROP3_NEED_PATTERN(rop))
    {
        TxModeValue = eOpaque;
    }
    else
    {
        TxModeValue = eTransparent;
    }

    //
    // Setup fill mode
    //
    FillMode FM;
    if (flOptions == FP_ALTERNATEMODE)
    {
        FM =  eFillEvenOdd;
    }
    else if (flOptions == FP_WINDINGMODE)
    {
        FM =  eFillNonZeroWinding;
    }

    if (S_OK == pOutput->SetClip(pco) &&
        S_OK == pOutput->SetROP3(rop) &&
        S_OK == pOutput->SetPaintTxMode(TxModeValue) &&
        S_OK == pOutput->SetSourceTxMode(TxModeValue) &&
        S_OK == pOutput->SetFillMode(FM) &&
        S_OK == pOutput->SetPen(plineattrs, pxo) &&
        S_OK == pOutput->SetPenColor(pboStroke, pptlBrushOrg) &&
        S_OK == pOutput->SetBrush(pboFill, pptlBrushOrg) &&
        S_OK == pOutput->Path(ppo) &&
        S_OK == pOutput->Paint() &&
        S_OK == pOutput->Flush(pdevobj))
        bRet = TRUE;
    else
    {
        pOutput->Delete();
        bRet = FALSE;
    }

    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)psoTarget->dhpdev;
    PXLPDEV    pxlpdev;
    XLBRUSH    *pBrush;
    BOOL        bRet = TRUE;
    OutputFormat OutputF;

    VERBOSE(("PCLXLRealizeBrush() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    //
    // the OEM DLL should NOT hook out this function unless it wants to draw
    // graphics directly to the device surface. In that case, it calls
    // EngRealizeBrush which causes GDI to call DrvRealizeBrush.
    // Note that it cannot call back into Unidrv since Unidrv doesn't hook it.
    //

    if (iHatch >= HS_DDI_MAX)
    {
        LONG  lHeight, lWidth, lScanline;
        ULONG ulOutputBPP, ulInputBPP;
        DWORD dwI, dwBufSize, dwLenNormal, dwLenRLE, dwcbLineSize, dwcbBmpSize;
        PDWORD pdwLen;
        PBYTE pubSrc, pBufNormal, pBufRLE, pBuf, pBmpSize;

        DetermineOutputFormat(psoPattern->iBitmapFormat, &OutputF, &ulOutputBPP);

        //
        // Get Info
        //
        ulInputBPP = UlBPPtoNum((BPP)psoPattern->iBitmapFormat);
        lHeight    = psoPattern->sizlBitmap.cy;
        lWidth     = psoPattern->sizlBitmap.cx;

        dwcbLineSize = ((lWidth * ulInputBPP) + 7) >> 3;
        dwBufSize  = lHeight * (((lWidth * ulOutputBPP + 31) >> 5 ) << 2) +
                     DATALENGTH_HEADER_SIZE + sizeof(PCLXL_EndRastPattern);

        VERBOSE(("PCLXLRealizeBrush():InBPP=%d,Width=%d,Height=%d,Line=%d,Size=%d.\n",
                ulInputBPP, lWidth, lHeight, dwcbLineSize, dwBufSize));

        //
        // Allocate output buffer
        //

        if (NULL == (pBufNormal = (PBYTE)MemAlloc(dwBufSize)) ||
            NULL == (pBufRLE = (PBYTE)MemAlloc(dwBufSize))     )
        {
            if (pBufNormal != NULL)
                MemFree(pBufNormal);
            ERR(("PCLXLRealizeBrush: MemAlloc failed.\n"));
            return FALSE;
        }

        CompressMode CMode;
        BMPConv BMPC;
        PBYTE pubDst;
        DWORD dwDstSize;
        LONG  lDelta;

        if (psoPattern->lDelta > 0)
        {
            lDelta = psoPattern->lDelta;
        }
        else
        {
            lDelta = -psoPattern->lDelta;
        }

        #if DBG
        BMPC.SetDbgLevel(BRUSHDBG);
        #endif
        BMPC.BSetInputBPP((BPP)psoPattern->iBitmapFormat);
        BMPC.BSetOutputBPP(NumToBPP(ulOutputBPP));
        BMPC.BSetOutputBMPFormat(OutputF);
        BMPC.BSetXLATEOBJ(pxlo);

        #define NO_COMPRESSION 0
        #define RLE_COMPRESSION 1
        for (dwI = 0; dwI < 2; dwI ++)
        {
            if (NO_COMPRESSION == dwI)
            {
                pBuf = pBufNormal;
                pdwLen = &dwLenNormal;
            }
            else
            {
                pBuf = pBufRLE;
                pdwLen = &dwLenRLE;
            }

            BMPC.BSetRLECompress(dwI == RLE_COMPRESSION);

            lScanline  = lHeight;
            pubSrc     = (PBYTE)psoPattern->pvScan0;

            *pBuf = PCLXL_dataLength;
            pBmpSize = pBuf + 1; // DWORD bitmap size
            pBuf += DATALENGTH_HEADER_SIZE;
            (*pdwLen) = DATALENGTH_HEADER_SIZE;

            dwcbBmpSize = 0;

            while (lScanline-- > 0 && dwcbBmpSize + *pdwLen < dwBufSize)
            {
                pubDst = BMPC.PubConvertBMP(pubSrc, dwcbLineSize);
                dwDstSize = BMPC.DwGetDstSize();
                VERBOSE(("PCLXLRealizeBrush[0x%x]: dwDstSize=0x%x\n", lScanline, dwDstSize));
                
                if ( dwcbBmpSize +
                     dwDstSize +
                     DATALENGTH_HEADER_SIZE +
                     sizeof(PCLXL_EndRastPattern) > dwBufSize || NULL == pubDst)
                {
                    ERR(("PCLXLRealizeBrush: Buffer size is too small.(%d)\n", dwI));
                    bRet = FALSE;
                    break;
                }

                memcpy(pBuf, pubDst, dwDstSize);
                dwcbBmpSize += dwDstSize;
                pBuf += dwDstSize;

                if (psoPattern->lDelta > 0)
                {
                    pubSrc += lDelta;
                }
                else
                {
                    pubSrc -= lDelta;
                }
            }

            if (lScanline > 0)
            {
                bRet = FALSE;
#if DBG
                ERR(("PCLXLRealizeBrush: Conversion failed.\n"));
#endif
            }

            if (bRet)
            {
                if (dwI == NO_COMPRESSION)
                {
                    //
                    // Scanline on PCL-XL has to be DWORD align.
                    //
                    // count byte of scanline = lWidth * ulOutputBPP / 8
                    //
                    dwcbBmpSize = lHeight * (((lWidth * ulOutputBPP + 31) >> 5 ) << 2);
                }

                CopyMemory(pBmpSize, &dwcbBmpSize, sizeof(dwcbBmpSize));
                (*pdwLen) += dwcbBmpSize;

                *pBuf = PCLXL_EndRastPattern;
                (*pdwLen) ++;
            }
            else
            {
                *pdwLen = 0; 
            }
        }
        #undef NO_COMPRESSION
        #undef RLE_COMPRESSION

        if (dwLenRLE != 0 && dwLenRLE < dwLenNormal)
        {
            pBuf = pBufRLE;
            pdwLen = &dwLenRLE;
            CMode = eRLECompression;

            MemFree(pBufNormal);
        }
        else
        if (dwLenNormal != 0)
        {
            pBuf = pBufNormal;
            pdwLen = &dwLenNormal;
            CMode = eNoCompression;

            MemFree(pBufRLE);
        }
        else
        {
            MemFree(pBufNormal);
            MemFree(pBufRLE);
            ERR(("PCLXLRealizeBrush: Conversion failed. Return FALSE.\n"));
            return FALSE;
        }


        //
        // Output
        //
        XLOutput *pOutput = pxlpdev->pOutput;
        ColorMapping CMapping;
        DWORD dwScale;

        //
        // Pattern scaling factor
        // Scale the destination size of pattern.
        // Resolution / 150 seems to be a good scaling factor.
        //
        dwScale = (pOutput->GetResolutionForBrush() + 149)/ 150;

        pOutput->SetColorSpace(eGray);
        if (OutputF == eOutputPal)
        {
            DWORD *pdwColorTable;

            if (pxlo && (pdwColorTable = GET_COLOR_TABLE(pxlo)))
            {
                CMapping = eIndexedPixel;
                pOutput->SetPalette(ulOutputBPP, e8Bit, pxlo->cEntries, pdwColorTable);
            }
            else
            {
                CMapping = eDirectPixel;
            }
        }
        else
        {
            CMapping = eDirectPixel;
        }
        pOutput->Send_cmd(eSetColorSpace);

        pOutput->SetOutputBPP(CMapping, ulOutputBPP);
        pOutput->SetSourceWidth((uint16)lWidth);
        pOutput->SetSourceHeight((uint16)lHeight);
        pOutput->SetDestinationSize((uint16)(lWidth * dwScale), (uint16)(lHeight * dwScale));
        pOutput->SetPatternDefineID((sint16)pxlpdev->dwLastBrushID);
        pOutput->SetPatternPersistence(eSessionPattern);
        pOutput->Send_cmd(eBeginRastPattern);
        pOutput->Flush(pdevobj);
        pOutput->ReadRasterPattern(lHeight, CMode);
        pOutput->Flush(pdevobj);

        DWORD dwBitmapSize;
        CopyMemory(&dwBitmapSize, pBuf + 1, sizeof(DWORD));

        if (dwBitmapSize > 0xff)
        {
            //
            // dataLength
            // size (uin32) (bitmap size)
            // DATA
            // EndImage
            //
            WriteSpoolBuf((PPDEV)pdevobj, pBuf, *pdwLen);
        }
        else
        {
            //
            // dataLength
            // size (byte) (bitmap size)
            // DATA
            // EndImage
            //
            PBYTE pTmp = pBuf;

            pBuf += 3;
            *pBuf = PCLXL_dataLengthByte;
            *(pBuf + 1) = (BYTE)dwBitmapSize;
            WriteSpoolBuf((PPDEV)pdevobj, pBuf, (*pdwLen) - 3);

            //
            // Restore the original pointer
            //
            pBuf = pTmp;
        }
        MemFree(pBuf);

    }

    DWORD dwBrushSize;
    if (pxlo->cEntries)
    {
        dwBrushSize = sizeof(XLBRUSH) + (pxlo->cEntries + 1) * sizeof(DWORD);
    }
    else
    {
        dwBrushSize = sizeof(XLBRUSH) + sizeof(DWORD);
    }

    if (pBrush = (XLBRUSH*)BRUSHOBJ_pvAllocRbrush(pbo, dwBrushSize))
    {

        pBrush->dwSig = XLBRUSH_SIG;
        pBrush->dwHatch     = iHatch;

        if (iHatch >= HS_DDI_MAX)
        {
            pBrush->dwPatternID = pxlpdev->dwLastBrushID++;
        }
        else
        {
            //
            // Set 0 for hatch brush case
            //
            pBrush->dwPatternID = 0;
        }

        DWORD *pdwColorTable;
        OutputF = eOutputGray;

        if (pxlo)
        {
            pdwColorTable = GET_COLOR_TABLE(pxlo);
        }
        else
        {
            pdwColorTable = NULL;
        }

        //
        // get color for Graphics state cache for either palette case or
        // solid color.
        //
        pBrush->dwColor = BRUSHOBJ_ulGetBrushColor(pbo);

        if (pdwColorTable && pxlo->cEntries != 0)
        {
            //
            // Copy palette table.
            //
            CopyMemory(pBrush->adwColor, pdwColorTable, pxlo->cEntries * sizeof(DWORD));
            pBrush->dwCEntries = pxlo->cEntries;
        }
        else
        {
            pBrush->dwCEntries = 0;
        }

        pBrush->dwOutputFormat = (DWORD)OutputF;

        pbo->pvRbrush = (PVOID)pBrush;
        bRet = TRUE;
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLStartPage(
    SURFOBJ    *pso)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;
    BOOL       bRet;

    VERBOSE(("PCLXLStartPage() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    XLOutput *pOutput = pxlpdev->pOutput;

    pxlpdev->dwFlags |= XLPDEV_FLAGS_STARTPAGE_CALLED;

    bRet = DrvStartPage(pso);

    //
    // Reset printing mode.
    // SourceTxMode, PaintTxMode
    // ROP
    //
    pOutput->SetPaintTxMode(eOpaque);
    pOutput->SetSourceTxMode(eOpaque);
    pOutput->SetROP3(0xCC);

    pOutput->Flush(pdevobj);

    //
    // Needs to reset attribute when EndPage and BeginPage are sent.
    //
    if (!(pxlpdev->dwFlags & XLPDEV_FLAGS_FIRSTPAGE))
    {
        BSaveFont(pdevobj);

        //
        // Reset graphcis state each page.
        //
        pOutput->ResetGState();

    }
    else
    {
        pxlpdev->dwFlags &= ~XLPDEV_FLAGS_FIRSTPAGE;
    }


    return bRet;
}


extern "C" BOOL APIENTRY
PCLXLSendPage(
    SURFOBJ    *pso)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;
    XLOutput  *pOutput;

    VERBOSE(("PCLXLEndPage() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    pxlpdev->dwFlags &= ~XLPDEV_FLAGS_STARTPAGE_CALLED;

    pOutput = pxlpdev->pOutput;
    pOutput->Flush(pdevobj);

    return DrvSendPage(pso);
}


extern "C" ULONG APIENTRY
PCLXLEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLEscape() entry.\n"));

    return DrvEscape(
            pso,
            iEsc,
            cjIn,
            pvIn,
            cjOut,
            pvOut);
}


extern "C" BOOL APIENTRY
PCLXLStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLStartDoc() entry.\n"));

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    //
    // Initialize flag
    //
    pxlpdev->dwFlags |= XLPDEV_FLAGS_FIRSTPAGE;

    return DrvStartDoc(
            pso,
            pwszDocName,
            dwJobId);
}


extern "C" BOOL APIENTRY
PCLXLEndDoc(
    SURFOBJ    *pso,
    FLONG       fl)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PDEVOBJ    pdevobj = (PDEVOBJ)pso->dhpdev;
    PXLPDEV    pxlpdev;
    BOOL       bRet;

    VERBOSE(("PCLXLEndDoc() entry.\n"));

    if (NULL == pdevobj->pdevOEM)
    {
        bRet = FALSE;
    }
    {
        pxlpdev = (PXLPDEV)pdevobj->pdevOEM;
        if (S_OK == RemoveAllFonts(pdevobj))
        {
            bRet = TRUE;
        }
        else
        {
            bRet = FALSE;
        }
    }

    pxlpdev->dwFlags |= XLPDEV_FLAGS_ENDDOC_CALLED;

    return bRet && DrvEndDoc(pso, fl);
}

////////////////////////////////////////////////////////////////////////////////
//
// Sub functions
//

HRESULT
RemoveAllFonts(
    PDEVOBJ pdevobj)
{
    PXLPDEV    pxlpdev;
    XLOutput  *pOutput;
    DWORD      dwI;
    HRESULT    hResult;

    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;
    pOutput = pxlpdev->pOutput;

    hResult = S_OK;

    for (dwI = 0; dwI < pxlpdev->dwNumOfTTFont; dwI++)
    {
        if (S_OK != pOutput->Send_ubyte_array_header(PCLXL_FONTNAME_SIZE) ||
            S_OK != pOutput->Write(PubGetFontName(dwI+1), PCLXL_FONTNAME_SIZE)||
            S_OK != pOutput->Send_attr_ubyte(eFontName) ||
            S_OK != pOutput->Send_cmd(eRemoveFont))
        {
            hResult = S_FALSE;
            break;
        }
    }

    pOutput->Flush(pdevobj);
    return hResult;
}

HRESULT
CommonRopBlt(
   IN PDEVOBJ    pdevobj,
   IN SURFOBJ    *psoSrc,
   IN CLIPOBJ    *pco,
   IN XLATEOBJ   *pxlo,
   IN BRUSHOBJ   *pbo,
   IN RECTL      *prclSrc,
   IN RECTL      *prclDst,
   IN POINTL     *pptlBrush,
   IN ROP4        rop4)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    HRESULT hRet;

    VERBOSE(("CommonRopBlt() entry.\n"));

    //
    // Error check
    //

    if (pdevobj == NULL ||
        prclDst == NULL  )
    {
        ERR(("CommonRopBlt: one of parameters is NULL.\n"));
        return E_UNEXPECTED;
    }

    PXLPDEV    pxlpdev= (PXLPDEV)pdevobj->pdevOEM;

    hRet = S_OK;

    XLOutput *pOutput = pxlpdev->pOutput;
    OutputFormat OutputF;

    //
    // Set Clip
    //
    if (!SUCCEEDED(pOutput->SetClip(pco)))
        return S_FALSE;

    //
    // Set Cursor
    //
    pOutput->SetCursor(prclDst->left, prclDst->top);

    //
    // 1. ROP conversion
    //
    // (1) Fill Dstination
    //     0x00 BLACKNESS
    //     0xFF WHITENESS
    //
    // (2) Pattern copy     -> P
    //     0xF0 PATCOPY     P
    //
    // (3) SRC/NOTSRCOPY    -> S or ~S
    //     0x11           ~( S | D)
    //     0x33             ~S
    //     0x44            ( S & ~D)
    //     0x66            ( D ^ S)
    //     0x77           ~( D & S)
    //     0x99           ~( S ^ D)
    //     0xCC              S
    //     0xDD            ( S | ~D)
    //
    // (4) Misc ROP support
    //     0xAA            D
    //     0x0F PATNOT     ~P
    //
    //
    ROP3 rop3 = GET_FOREGROUND_ROP3(rop4);
    DWORD dwCase = 0;

    #define ROP_BLACKWHITE  0x1
    #define ROP_PATTERN     0x2
    #define ROP_BITMAP      0x4
    #define ROP_DEST        0x8


    //
    // Set ROP3
    //
    pOutput->SetROP3(GET_FOREGROUND_ROP3(rop4));

    switch (rop3)
    {
    case 0x00:
    case 0xFF:
        dwCase = ROP_BLACKWHITE;
        break;

    case 0xF0:
        dwCase = ROP_PATTERN;
        break;

    case 0x11:
    case 0x33:
    case 0x44:
    case 0x66:
    case 0x77:
    case 0x99:
    case 0xCC:
    case 0xDD:
        dwCase = ROP_BITMAP;
        break;

    case 0xAA:
        dwCase = ROP_DEST;
        break;
    
    case 0x0F:
        dwCase = ROP_PATTERN;
        break;

    default:
        if (ROP3_NEED_SOURCE(rop3))
        {
            dwCase |= ROP_BITMAP;
        }
        if (ROP3_NEED_PATTERN(rop3))
        {
            dwCase |= ROP_PATTERN;
        }
        if (ROP3_NEED_DEST(rop3))
        {
            dwCase |= ROP_DEST;
        }
        break;
    }

    //
    // Black & White case
    //
    if (dwCase & ROP_BLACKWHITE)
    {
        VERBOSE(("CommonRopBlt(): BlackWhite.\n"));
        //
        // SetBrushSource
        // NewPath
        // RectanglePath
        // PaintPath
        //

        CMNBRUSH CmnBrush;
        CmnBrush.dwSig            = BRUSH_SIGNATURE;
        CmnBrush.BrushType        = kBrushTypeSolid;
        CmnBrush.ulSolidColor     = 0x00;
        CmnBrush.ulHatch          = 0xFFFFFFFF;
        CmnBrush.dwColor          = 0x00FFFFFF;
        CmnBrush.dwPatternBrushID = 0xFFFFFFFF;

        pOutput->SetSourceTxMode(eOpaque);
        pOutput->SetPaintTxMode(eOpaque);

        if(rop3 == 0x00)
        {
            pOutput->SetGrayLevel(0x00);
            CmnBrush.dwColor = 0x00;
        }
        else
        {
            pOutput->SetGrayLevel(0xff);
            CmnBrush.dwColor = 0x00ffffff;
        }

        ((XLBrush*)pOutput)->SetBrush(&CmnBrush);

        pOutput->Send_cmd(eSetBrushSource);
        pOutput->SetPenColor(NULL, NULL);
        if (!(dwCase & ROP_BITMAP))
        {
            pOutput->Send_cmd(eNewPath);
            pOutput->RectanglePath(prclDst);
            pOutput->Send_cmd(ePaintPath);
        }
        pOutput->Flush(pdevobj);
    }

    //
    // Pattern fill case
    //
    if (dwCase & (ROP_DEST|ROP_PATTERN))
    {
        VERBOSE(("CommonRopBlt(): Pattern.\n"));

        //
        // SetPaintTxMode
        // SetSourceTxMode
        // SetBrushSource
        // NewPath
        // RectanglePath
        // PaintPath
        //
        pOutput->SetSourceTxMode(eOpaque);
        pOutput->SetPaintTxMode(eOpaque);
        pOutput->SetBrush(pbo, pptlBrush);
        pOutput->SetPenColor(NULL, NULL);
        if (!(dwCase & ROP_BITMAP))
        {
            pOutput->Send_cmd(eNewPath);
            pOutput->RectanglePath(prclDst);
            pOutput->Send_cmd(ePaintPath);
        }
        pOutput->Flush(pdevobj);
    }

    //
    // Bitmap case
    //
    if (dwCase & ROP_BITMAP)
    {
        LONG  lHeight, lWidth, lScanline;
        ULONG ulOutputBPP, ulInputBPP;
        DWORD dwI, dwBufSize, dwLenNormal, dwLenRLE, dwcbLineSize, dwcbBmpSize;
        PDWORD pdwLen;
        PBYTE pubSrc, pBufNormal, pBufRLE, pBuf, pBmpSize;
        ColorMapping CMapping;

        VERBOSE(("CommonRopBlt(): Bitmap\n"));

        if (psoSrc == NULL ||
            pxlo == NULL   ||
            prclSrc == NULL )
        {
            ERR(("UNIDRV:CommonRopBlt:psoSrc, pxlo, or prclSrc == NULL.\n"));
            pOutput->Flush(pdevobj);
            return E_UNEXPECTED;
        }

        //
        // Input BPP
        //

        ulInputBPP = UlBPPtoNum((BPP)psoSrc->iBitmapFormat);

        //
        // Set source opaque mode
        // GDI bug. CopyBits is called recursively.
        //
        {
            PDEV *pPDev = (PDEV*)pdevobj;
            if (pPDev->fMode2 & PF2_SURFACE_WHITENED)
            {
                pOutput->SetSourceTxMode(eTransparent);
            }
            else
            {
                pOutput->SetSourceTxMode(eOpaque);
            }
        }
        pOutput->SetPaintTxMode(eOpaque);

        //
        // Bitmap output
        //
        DetermineOutputFormat(psoSrc->iBitmapFormat, &OutputF, &ulOutputBPP);

        pOutput->SetColorSpace(eGray);
        if (OutputF == eOutputPal)
        {
            DWORD *pdwColorTable;

            if (pxlo && (pdwColorTable = GET_COLOR_TABLE(pxlo)) &&
                S_OK == pOutput->SetPalette(ulOutputBPP, e8Bit, pxlo->cEntries, pdwColorTable))
            {
                CMapping = eIndexedPixel;
            }
            else
            {
                CMapping = eDirectPixel;
            }
        }
        else
            CMapping = eDirectPixel;
        pOutput->Send_cmd(eSetColorSpace);

        //
        // Get height, width, and scanline size.
        //
        lWidth = prclSrc->right - prclSrc->left;
        lHeight = prclSrc->bottom - prclSrc->top;
        dwcbLineSize = ((lWidth * ulInputBPP) + 7) >> 3;
        dwBufSize = lHeight * (((lWidth * ulOutputBPP + 31) >> 5 ) << 2) +
                 DATALENGTH_HEADER_SIZE + sizeof(PCLXL_EndImage);


        //
        // BeginImage
        //
        pOutput->BeginImage(
                       CMapping,
                       ulOutputBPP,
                       lWidth,
                       lHeight,
                       prclDst->right - prclDst->left,
                       prclDst->bottom - prclDst->top);


        VERBOSE(("CommonRopBlt: ulInputBPP=%d, ulOutputBPP=%d, lWidth=0x%x, lHeight=0x%x, dwcbLineSize=0x%x, dwBufSize=0x%x\n",ulInputBPP, ulOutputBPP, lWidth, lHeight, dwcbLineSize, dwBufSize));

        //
        // Allocate output buffer
        //
        if (NULL == (pBufNormal = (PBYTE)MemAlloc(dwBufSize)) ||
            NULL == (pBufRLE = (PBYTE)MemAlloc(dwBufSize))     )
        {
            if (pBufNormal != NULL)
                MemFree(pBufNormal);
            ERR(("PCLXLRealizeBrush: MemAlloc failed.\n"));
            pOutput->Delete();
            return FALSE;
        }

        CompressMode CMode;
        BMPConv BMPC;
        PBYTE pubDst;
        DWORD dwSize;
        LONG lDelta;

        if (psoSrc->lDelta > 0)
        {
            lDelta = psoSrc->lDelta;
        }
        else
        {
            lDelta = -psoSrc->lDelta;
        }

        #if DBG
        BMPC.SetDbgLevel(BITMAPDBG);
        #endif
        BMPC.BSetInputBPP((BPP)psoSrc->iBitmapFormat);
        BMPC.BSetOutputBPP(NumToBPP(ulOutputBPP));
        BMPC.BSetOutputBMPFormat(OutputF);
        BMPC.BSetXLATEOBJ(pxlo);

        #define NO_COMPRESSION 0
        #define RLE_COMPRESSION 1
        for (dwI = 0; dwI < 2; dwI ++)
        {
            if (NO_COMPRESSION == dwI)
            {
                VERBOSE(("CommonRopBlt(): No-compres\n"));
                pBuf = pBufNormal;
                pdwLen = &dwLenNormal;
            }
            else
            {
                VERBOSE(("CommonRopBlt(): RLE-compres\n"));
                pBuf = pBufRLE;
                pdwLen = &dwLenRLE;
            }

            lScanline = lHeight;

            //
            // Set pubSrc
            //
            pubSrc = (PBYTE)psoSrc->pvScan0;
            if (psoSrc->lDelta > 0)
            {
                pubSrc += prclSrc->top * lDelta + ((ulInputBPP * prclSrc->left) >> 3);
            }
            else
            {
                pubSrc = pubSrc - prclSrc->top * lDelta + ((ulInputBPP * prclSrc->left) >> 3);
            }

            *pBuf = PCLXL_dataLength;
            pBmpSize = pBuf + 1;
            pBuf += DATALENGTH_HEADER_SIZE;
            *pdwLen = DATALENGTH_HEADER_SIZE;

            BMPC.BSetRLECompress(dwI == RLE_COMPRESSION);

            dwcbBmpSize = 0;

            while (lScanline-- > 0 && dwcbBmpSize + *pdwLen < dwBufSize)
            {
                pubDst = BMPC.PubConvertBMP(pubSrc, dwcbLineSize);
                dwSize = BMPC.DwGetDstSize();
                VERBOSE(("CommonRopBlt[0x%x]: dwDstSize=0x%x\n", lScanline, dwSize));
                
                if ( dwcbBmpSize +
                     dwSize +
                     DATALENGTH_HEADER_SIZE +
                     sizeof(PCLXL_EndImage) > dwBufSize || NULL == pubDst)
                {
                    VERBOSE(("CommonRopBlt: Buffer size is too small.\n"));
                    hRet = E_UNEXPECTED;
                    break;
                }

                memcpy(pBuf, pubDst, dwSize);
                dwcbBmpSize += dwSize;
                pBuf += dwSize;

                if (psoSrc->lDelta > 0)
                {
                    pubSrc += lDelta;
                }
                else
                {
                    pubSrc -= lDelta;
                }
            }

            if (lScanline > 0)
            {
                hRet = S_FALSE;
                WARNING(("ComonRopBlt: Conversion failed.\n"));
            }

            if (hRet == S_OK)
            {
                if (dwI == NO_COMPRESSION)
                {
                    //
                    // Scanline on PCL-XL has to be DWORD align.
                    //
                    // count byte of scanline = lWidth * ulOutputBPP / 8
                    //
                    dwcbBmpSize = lHeight * (((lWidth * ulOutputBPP + 31) >> 5 ) << 2);
                }

                CopyMemory(pBmpSize, &dwcbBmpSize, sizeof(dwcbBmpSize));
                *pdwLen += dwcbBmpSize;

                *pBuf = PCLXL_EndImage;
                (*pdwLen) ++;
            }
            else
            {
                //
                // Conversion failed!
                //
                *pdwLen = 0;
            }
        }
        #undef NO_COMPRESSION
        #undef RLE_COMPRESSION

        //
        // ReadImage
        //
        if (dwLenRLE != 0 && dwLenRLE < dwLenNormal)
        {
            VERBOSE(("CommonRopBlt RLE: dwSize=0x%x\n", dwLenRLE));
            pBuf = pBufRLE;
            pdwLen = &dwLenRLE;
            CMode = eRLECompression;

            MemFree(pBufNormal);
        }
        else
        {
            VERBOSE(("CommonRopBlt Normal: dwSize=0x%x\n", dwLenRLE));
            pBuf = pBufNormal;
            pdwLen = &dwLenNormal;
            CMode = eNoCompression;

            MemFree(pBufRLE);
        }

        pOutput->ReadImage(lHeight, CMode);
        pOutput->Flush(pdevobj);

        DWORD dwBitmapSize;
        CopyMemory(&dwBitmapSize, pBuf + 1, sizeof(DWORD));

        if (dwBitmapSize > 0xff)
        {
            //
            // dataLength
            // size (uin32) (bitmap size)
            // DATA
            // EndImage
            //
            WriteSpoolBuf((PPDEV)pdevobj, pBuf, *pdwLen);
        }
        else
        {
            //
            // dataLength
            // size (byte) (bitmap size)
            // DATA
            // EndImage
            //
            PBYTE pTmp = pBuf;

            pBuf += 3;
            *pBuf = PCLXL_dataLengthByte;
            *(pBuf + 1) = (BYTE)dwBitmapSize;
            WriteSpoolBuf((PPDEV)pdevobj, pBuf, (*pdwLen) - 3);

            //
            // Restore the original pointer
            //
            pBuf = pTmp;
        }
        MemFree(pBuf);
    }

    return hRet;
}

inline
VOID
DetermineOutputFormat(
    INT          iBitmapFormat,
    OutputFormat *pOutputF,
    ULONG        *pulOutputBPP)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    switch ((BPP)iBitmapFormat)
    {
    case e1bpp:
    case e4bpp:
        *pOutputF = eOutputPal;
        break;

    case e8bpp:
    case e16bpp:
    case e24bpp:
    case e32bpp:
        *pOutputF = eOutputGray;
        break;
    }

    switch (*pOutputF)
    {
    case eOutputGray:
        *pulOutputBPP = 8;
        break;

    case eOutputPal:
        *pulOutputBPP = UlBPPtoNum((BPP)iBitmapFormat);
        break;
    case eOutputRGB:
    case eOutputCMYK:
        ERR(("eOutputRGB and eOutputCMYK are not supported yet.\n"));
        break;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlenable.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xlenable.cpp

Abstract:

    Implementation of enable/disable function for PCLXL

Environment:

    Windows Whistler

Revision History:

     08/23/99 
     Created it.

--*/


#include "xlpdev.h"
#include "xldebug.h"
#include <assert.h>
#include "pclxle.h"
#include "pclxlcmd.h"
#include "xlgstate.h"
#include "xloutput.h"
#include "xlbmpcvt.h"
#include "pclxlcmn.h"
#include "xltt.h"

////////////////////////////////////////////////////////////////////////////////
//
// Functions
//

extern "C" VOID APIENTRY
PCLXLDisableDriver(VOID)
/*++

Routine Description:

    IPrintOemUni DisableDriver interface
    Free all resources, and get prepared to be unloaded.

Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLDisaleDriver() entry.\r\n"));
}

extern "C" PDEVOEM APIENTRY
PCLXLEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
/*++

Routine Description:

    IPrintOemUni EnablePDEV interface
    Construct its own PDEV. At this time, the driver also passes a function
    table which contains its own implementation of DDI entrypoints

Arguments:

    pdevobj        - pointer to a DEVOBJ structure. pdevobj->pdevOEM is undefined.
    pPrinterName   - name of the current printer.
    Cpatterns      -
    phsurfPatterns -
    cjGdiInfo      - size of GDIINFO
    pGdiInfo       - a pointer to GDIINFO
    cjDevInfo      - size of DEVINFO
    pDevInfo       - These parameters are identical to what39s passed into DrvEnablePDEV.
    pded: points to a function table which contains the system driver39s
    implementation of DDI entrypoints.


Return Value:


--*/
{
    PXLPDEV     pxlpdev;

    VERBOSE(("PCLXLEnablePDEV() entry.\r\n"));

    //
    // Allocate the XLPDEV
    //
    if (!(pxlpdev = (PXLPDEV)MemAllocZ(sizeof(XLPDEV))))
        return NULL;

    pxlpdev->dwSig = XLPDEV_SIG;

    //
    // Save UNIDRV PDEV
    //
    pxlpdev->pPDev = (PPDEV)pdevobj;


    //
    // HS_HORIZONTAL: 0
    // HS_VERTICAL:   1
    // HS_BDIAGONAL:  2
    // HS_FDIAGONAL:  3
    // HS_CROSS:      4
    // HS_DIAGCROSS:  5
    //
    pxlpdev->dwLastBrushID = 10; // Raster pattern ID starts from 10.

    //
    // Initialize buffers
    //
    // Text string data
    //
    pxlpdev->pTransOrg = (PTRANSDATA)NULL;
    pxlpdev->dwcbTransSize = 0;
    pxlpdev->plWidth   = (PLONG)NULL;
    pxlpdev->dwcbWidthSize = 0;

    //
    // Initialize buffers
    //
    // String cache
    //
    pxlpdev->pptlCharAdvance = (PPOINTL)NULL;
    pxlpdev->pawChar = (PWORD)NULL;
    pxlpdev->dwCharCount = 
    pxlpdev->dwMaxCharCount = 0;

    //
    // Initalize XOutput
    //
    pxlpdev->pOutput = new XLOutput;

    if (NULL == pxlpdev->pOutput)
    {
       MemFree(pxlpdev);
       return NULL;
    }
    pxlpdev->pOutput->SetResolutionForBrush(((PPDEV)pdevobj)->ptGrxRes.x);

#if DBG
    pxlpdev->pOutput->SetOutputDbgLevel(OUTPUTDBG);
    pxlpdev->pOutput->SetGStateDbgLevel(GSTATEDBG);
#endif

    //
    // Initialize
    // Fixed pitch TT
    // Number of downloaded TrueType font
    //
    pxlpdev->dwFixedTTWidth = 0;
    pxlpdev->dwNumOfTTFont = 0;

    //
    // TrueType file object
    //
    pxlpdev->pTTFile = new XLTrueType;

    if (NULL == pxlpdev->pTTFile)
    {
       delete pxlpdev->pOutput;
       MemFree(pxlpdev);
       return NULL;
    }

    //
    // Text resolution and Font Height
    //
    pxlpdev->dwFontHeight = 
    pxlpdev->dwTextRes = 0;

    //
    // Text Angle
    //
    pxlpdev->dwTextAngle = 0;

    //
    // JPEG support
    //
    //pDevInfo->flGraphicsCaps2 |= GCAPS2_JPEGSRC;
    pDevInfo->flGraphicsCaps |= GCAPS_BEZIERS |
	GCAPS_BEZIERS |
	//GCAPS_GEOMETRICWIDE |
	GCAPS_ALTERNATEFILL |
	GCAPS_WINDINGFILL |
	GCAPS_NUP |
	GCAPS_OPAQUERECT |
	GCAPS_COLOR_DITHER |
	GCAPS_HORIZSTRIKE  |
	GCAPS_VERTSTRIKE   |
	GCAPS_OPAQUERECT;

    //
    // Set cursor offset.
    //
    pxlpdev->pOutput->SetCursorOffset(((PPDEV)pdevobj)->sf.ptPrintOffsetM.x,
                                      ((PPDEV)pdevobj)->sf.ptPrintOffsetM.y);

    //
    // Return the result
    //
    return (PDEVOEM)pxlpdev;
}

extern "C" BOOL APIENTRY
PCLXLResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
/*++

Routine Description:

    IPrintOemUni ResetPDEV interface
    OEMResetPDEV transfers the state of the driver from the old PDEVOBJ to the
    new PDEVOBJ when an application calls ResetDC.

Arguments:

pdevobjOld - pdevobj containing Old PDEV
pdevobjNew - pdevobj containing New PDEV

Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLResetPDEV entry.\r\n"));

    PXLPDEV pxlpdevOld = (PXLPDEV)pdevobjOld->pdevOEM;
    PXLPDEV pxlpdevNew = (PXLPDEV)pdevobjNew->pdevOEM;

    if (!(pxlpdevOld->dwFlags & XLPDEV_FLAGS_FIRSTPAGE))
    {
        RemoveAllFonts(pdevobjOld);
    }

    pxlpdevNew->dwFlags |= XLPDEV_FLAGS_RESETPDEV_CALLED;

    return TRUE;
}

extern "C" VOID APIENTRY
PCLXLDisablePDEV(
    PDEVOBJ         pdevobj)
/*++

Routine Description:

    IPrintOemUni DisablePDEV interface
    Free resources allocated for the PDEV.

Arguments:

    pdevobj -

Return Value:


Note:


--*/
{

    PXLPDEV    pxlpdev;

    VERBOSE(("PCLXLDisablePDEV() entry.\r\n"));

    //
    // Error check
    //
    if (!pdevobj)
    {
        ERR(("PCLXLDisablePDEV(): invalid pdevobj.\r\n"));
        return;
    }

    //
    // free memory for XLPDEV and any memory block that hangs off XLPDEV.
    //
    pxlpdev = (PXLPDEV)pdevobj->pdevOEM;

    if (pxlpdev)
    {

        //
        // *Trans data buffer
        // *Width data buffer
        // *String cache(string and width) buffer
        //
        if (pxlpdev->pTransOrg)
            MemFree(pxlpdev->pTransOrg);
        if (pxlpdev->plWidth)
            MemFree(pxlpdev->plWidth);
        if (pxlpdev->pptlCharAdvance)
            MemFree(pxlpdev->pptlCharAdvance);
        if (pxlpdev->pawChar)
            MemFree(pxlpdev->pawChar);

        //
        // Delete XLTrueType
        //
        delete pxlpdev->pTTFile;

        //
        // Delete XLOutput
        //
        delete pxlpdev->pOutput;

        //
        // Delete XLFont
        //
        delete pxlpdev->pXLFont;

        //
        // Free XLPDEV
        //
        MemFree(pxlpdev);
    }
}

extern "C"
BOOL
PCLXLDriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni DriverDMS interface

Arguments:


Return Value:


Note:


--*/
{
    VERBOSE(("PCLXLDriverDMS() entry.\r\n"));

    if (cbSize >= sizeof(DWORD))
    {
        *(PDWORD)pBuffer =

            HOOK_TEXTOUT    |
            HOOK_LINETO     |
            HOOK_COPYBITS   |
            HOOK_BITBLT     |
            HOOK_STRETCHBLT |
            HOOK_PAINT      |
            HOOK_PLGBLT     |
            HOOK_STRETCHBLTROP  |
            HOOK_TRANSPARENTBLT |
            HOOK_ALPHABLEND     |
            HOOK_GRADIENTFILL   |
            HOOK_STROKEPATH |
            HOOK_FILLPATH   |
            HOOK_STROKEANDFILLPATH;

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xloutput.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xloutput.cpp

Abstract:

    PCL-XL low level command output implementation

Environment:

    Windows Whistler

Revision History:

    08/23/99     
        Created it.

--*/

#include "lib.h"
#include "gpd.h"
#include "winres.h"
#include "pdev.h"
#include "common.h"
#include "xlpdev.h"
#include "pclxle.h"
#include "pclxlcmd.h"
#include "xldebug.h"
#include "xlgstate.h"
#include "xloutput.h"


//
// XLWrite
//

XLWrite::
XLWrite(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
#if DBG
    m_dbglevel = OUTPUTDBG;
#endif

    XL_VERBOSE(("XLWrite:Ctor.\n")); 

    m_pCurrentPoint = 
    m_pBuffer = (PBYTE)MemAlloc(XLWrite_INITSIZE);

    if (NULL == m_pBuffer)
    {
        XL_ERR(("XLWrite:Ctor: failed to allocate memory.\n")); 
        m_dwBufferSize = 0;
        m_dwCurrentDataSize = 0;
    }
    else
    {
        m_dwBufferSize = XLWrite_INITSIZE;
        m_dwCurrentDataSize = 0;
    }

}

XLWrite::
~XLWrite(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLWrite:Dtor.\n")); 
    if (m_pBuffer)
        MemFree(m_pBuffer);
}

HRESULT
XLWrite::
IncreaseBuffer(
    DWORD dwAdditionalDataSize)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    PBYTE pTemp;
    DWORD dwNewBufferSize;

    dwNewBufferSize = m_dwBufferSize + XLWrite_ADDSIZE;
    dwAdditionalDataSize += m_dwBufferSize;

    while (dwAdditionalDataSize > dwNewBufferSize)
        dwNewBufferSize += XLWrite_ADDSIZE;

    if (!(pTemp = (PBYTE)MemAlloc(dwNewBufferSize)))
    {
        XL_ERR(("XLWrite::IncreaseBuffer: Memory allocation failed\n"));
        return E_UNEXPECTED;
    }

    if (m_pBuffer)
    {
        if (m_dwCurrentDataSize > 0)
        {
            CopyMemory(pTemp, m_pBuffer, m_dwCurrentDataSize);
        }

        MemFree(m_pBuffer);
    }
    
    m_dwBufferSize = dwNewBufferSize;
    m_pCurrentPoint = pTemp + m_dwCurrentDataSize;
    m_pBuffer = pTemp;

    return S_OK;
}

inline
HRESULT
XLWrite::
Write(
    PBYTE pData,
    DWORD dwSize)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (m_dwBufferSize < m_dwCurrentDataSize + dwSize)
    {
        if (S_OK != IncreaseBuffer(dwSize))
        {
            XL_ERR(("XLWrite::Write: failed to increae memory\n"));
            return E_UNEXPECTED;
        }
    }

    if (NULL == m_pBuffer || NULL == pData)
    {
        XL_ERR(("XLWrite:Write failed\n"));
        return E_UNEXPECTED;
    }

    CopyMemory(m_pCurrentPoint, pData, dwSize);
    m_pCurrentPoint += dwSize;
    m_dwCurrentDataSize += dwSize;
    return S_OK;
}

inline
HRESULT
XLWrite::
WriteByte(
    BYTE ubData)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{

    if (m_dwBufferSize < m_dwCurrentDataSize + 2 * sizeof(DWORD))
    {
        //
        // 64 bit alignment
        // Increae quadword
        //
        if (S_OK != IncreaseBuffer(2 * sizeof(DWORD)))
        {
            XL_ERR(("XLWrite::WriteByte: failed to increae memory\n"));
            return E_UNEXPECTED;
        }
    }

    if (NULL == m_pBuffer)
    {
        XL_ERR(("XLWrite:WriteByte failed\n"));
        return E_UNEXPECTED;
    }

    *m_pCurrentPoint++ = ubData;
    m_dwCurrentDataSize ++;
    return S_OK;
}

inline
HRESULT
XLWrite::
WriteFloat(
    real32 real32_value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    return Write((PBYTE)&real32_value, sizeof(real32_value));
}


HRESULT
XLWrite::
Flush(
    PDEVOBJ pdevobj)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    ASSERTMSG(m_pBuffer != NULL, ("XLWrite:m_pBuffer = NULL\n"));

    if (NULL == m_pBuffer)
    {
        return E_UNEXPECTED;
    }

    WriteSpoolBuf((PPDEV)pdevobj, m_pBuffer, m_dwCurrentDataSize);
    m_dwCurrentDataSize = 0;
    m_pCurrentPoint =  m_pBuffer;
    return S_OK;
}

HRESULT
XLWrite::
Delete(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    ASSERTMSG(m_pBuffer != NULL, ("XLWrite:m_pBuffer = NULL\n"));

    if (NULL == m_pBuffer)
    {
        return E_UNEXPECTED;
    }

    m_dwCurrentDataSize = 0;
    m_pCurrentPoint =  m_pBuffer;
    return S_OK;
}


#if DBG
VOID
XLWrite::
SetDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    m_dbglevel = dwLevel;
}
#endif

//
// XLOutput
//

XLOutput::
XLOutput(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
#if DBG
    m_dbglevel = OUTPUTDBG;
#endif
    m_dwHatchBrushAvailability = 0;
}

XLOutput::
~XLOutput(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
}

#if DBG
VOID
XLOutput::
SetOutputDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    this->m_dbglevel = dwLevel;
    XLWrite *pXLWrite = this;
    pXLWrite->SetDbgLevel(dwLevel);
}

VOID
XLOutput::
SetGStateDbgLevel(
    DWORD dwLevel)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XLGState *pGState = this;

    pGState->SetAllDbgLevel(dwLevel);
}
#endif

//
// Misc. functions
//
VOID
XLOutput::
SetHatchBrushAvailability(
    DWORD dwHatchBrushAvailability)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    m_dwHatchBrushAvailability = dwHatchBrushAvailability;
}

DWORD
XLOutput::
GetHatchBrushAvailability(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    return m_dwHatchBrushAvailability;
}

DWORD
XLOutput::
GetResolutionForBrush(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    return m_dwResolution;
}

VOID
XLOutput::
SetResolutionForBrush(
    DWORD dwRes)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    m_dwResolution = dwRes;
}

HRESULT
XLOutput::
SetCursorOffset(
    ULONG ulX,
    ULONG ulY)
{

    m_ulOffsetX = ulX;
    m_ulOffsetY = ulY;
    return S_OK;
}

//
// PCL-XL basic send functions
//
HRESULT
XLOutput::
Send_cmd(XLCmd Cmd)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(Cmd);
    return S_OK;
}

HRESULT
XLOutput::
Send_attr_ubyte(
 Attribute Attr)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(Attr);
    return S_OK;
}

HRESULT
XLOutput::
Send_attr_uint16(
 Attribute Attr)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte((ubyte)PCLXL_attr_uint16);
    Send_uint16((uint16)Attr);
    return S_OK;
}

//
// single
//
HRESULT
XLOutput::
Send_ubyte(
 ubyte ubyte_data)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(ubyte_data);
    return S_OK;
}

HRESULT
XLOutput::
Send_uint16(
 uint16 uint16_data)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint16);
    Write((PBYTE)&uint16_data, sizeof(uint16));
    return S_OK;
}

HRESULT
XLOutput::
Send_uint32(
 uint32 uint32_data)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint32);
    Write((PBYTE)&uint32_data, sizeof(uint32));
    return S_OK;
}

HRESULT
XLOutput::
Send_sint16(
 sint16 sint16_data)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint16);
    Write((PBYTE)&sint16_data, sizeof(sint16));
    return S_OK;
}

HRESULT
XLOutput::
Send_sint32(
 sint32 sint32_data)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint32);
    Write((PBYTE)&sint32_data, sizeof(sint32));
    return S_OK;
}

HRESULT
XLOutput::
Send_real32(
real32 real32_data)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{

    WriteByte(PCLXL_real32);
    WriteFloat(real32_data);
    return S_OK;
}

//
// xy
//
HRESULT
XLOutput::
Send_ubyte_xy(
 ubyte ubyte_x,
 ubyte ubyte_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte_xy);
    WriteByte(ubyte_x);
    WriteByte(ubyte_y);
    return S_OK;
}

HRESULT
XLOutput::
Send_uint16_xy(
 uint16 uint16_x,
 uint16 uint16_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint16_xy);
    Write((PBYTE)&uint16_x, sizeof(uint16));
    Write((PBYTE)&uint16_y, sizeof(uint16));
    return S_OK;
}

HRESULT
XLOutput::
Send_uint32_xy(
 uint32 uint32_x,
 uint32 uint32_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint32_xy);
    Write((PBYTE)&uint32_x, sizeof(uint32));
    Write((PBYTE)&uint32_y, sizeof(uint32));
    return S_OK;
}

HRESULT
XLOutput::
Send_sint16_xy(
 sint16 sint16_x,
 sint16 sint16_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint16_xy);
    Write((PBYTE)&sint16_x, sizeof(sint16));
    Write((PBYTE)&sint16_y, sizeof(sint16));
    return S_OK;
}

HRESULT
XLOutput::
Send_sint32_xy(
 sint32 sint32_x,
 sint32 sint32_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint32_xy);
    Write((PBYTE)&sint32_x, sizeof(sint32));
    Write((PBYTE)&sint32_y, sizeof(sint32));
    return S_OK;
}


HRESULT
XLOutput::
Send_real32_xy(
real32 real32_x,
real32 real32_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{

    WriteByte(PCLXL_real32_xy);
    WriteFloat(real32_x);
    WriteFloat(real32_y);
    return S_OK;
}

//
// box
//
HRESULT
XLOutput::
Send_ubyte_box(
 ubyte ubyte_left,
 ubyte ubyte_top,
 ubyte ubyte_right,
 ubyte ubyte_bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte_box);
    WriteByte(ubyte_left);
    WriteByte(ubyte_top);
    WriteByte(ubyte_right);
    WriteByte(ubyte_bottom);
    return S_OK;
}

HRESULT
XLOutput::
Send_uint16_box(
 uint16 uint16_left,
 uint16 uint16_top,
 uint16 uint16_right,
 uint16 uint16_bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint16_box);
    Write((PBYTE)&uint16_left, sizeof(uint16));
    Write((PBYTE)&uint16_top, sizeof(uint16));
    Write((PBYTE)&uint16_right, sizeof(uint16));
    Write((PBYTE)&uint16_bottom, sizeof(uint16));
    return S_OK;
}

HRESULT
XLOutput::
Send_uint32_box(
 uint32 uint32_left,
 uint32 uint32_top,
 uint32 uint32_right,
 uint32 uint32_bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint32_box);
    Write((PBYTE)&uint32_left, sizeof(uint32));
    Write((PBYTE)&uint32_top, sizeof(uint32));
    Write((PBYTE)&uint32_right, sizeof(uint32));
    Write((PBYTE)&uint32_bottom, sizeof(uint32));
    return S_OK;
}

HRESULT
XLOutput::
Send_sint16_box(
 sint16 sint16_left,
 sint16 sint16_top,
 sint16 sint16_right,
 sint16 sint16_bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint16_box);
    Write((PBYTE)&sint16_left, sizeof(sint16));
    Write((PBYTE)&sint16_top, sizeof(sint16));
    Write((PBYTE)&sint16_right, sizeof(sint16));
    Write((PBYTE)&sint16_bottom, sizeof(sint16));
    return S_OK;
}

HRESULT
XLOutput::
Send_sint32_box(
 sint32 sint32_left,
 sint32 sint32_top,
 sint32 sint32_right,
 sint32 sint32_bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint32_box);
    Write((PBYTE)&sint32_left, sizeof(sint32));
    Write((PBYTE)&sint32_top, sizeof(sint32));
    Write((PBYTE)&sint32_right, sizeof(sint32));
    Write((PBYTE)&sint32_bottom, sizeof(sint32));
    return S_OK;
}

HRESULT
XLOutput::
Send_real32_box(
 real32 real32_left,
 real32 real32_top,
 real32 real32_right,
 real32 real32_bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{

    WriteByte(PCLXL_real32_box);

    //
    // left
    //
    WriteFloat(real32_left);

    //
    // top
    //
    WriteFloat(real32_top);

    //
    // right
    //
    WriteFloat(real32_right);

    //
    // bottom
    //
    WriteFloat(real32_bottom);
    return S_OK;
}

//
// array
//
HRESULT
XLOutput::
Send_ubyte_array_header(
 DWORD dwArrayNum)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte_array);
    Send_uint16((uint16)dwArrayNum);
    return S_OK;
}

HRESULT
XLOutput::
Send_uint16_array_header(
 DWORD dwArrayNum)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint16_array);
    Send_uint16((uint16)dwArrayNum);
    return S_OK;
}

HRESULT
XLOutput::
Send_uint32_array_header(
 DWORD dwArrayNum)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_uint32_array);
    Send_uint16((uint16)dwArrayNum);
    return S_OK;
}

HRESULT
XLOutput::
Send_sint16_array_header(
 DWORD dwArrayNum)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint16_array);
    Send_uint16((uint16)dwArrayNum);
    return S_OK;
}

HRESULT
XLOutput::
Send_sint32_array_header(
 DWORD dwArrayNum)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_sint32_array);
    Send_uint16((uint16)dwArrayNum);
    return S_OK;
}

HRESULT
XLOutput::
Send_real32_array_header(
DWORD dwArrayNum)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_real32_array);
    Send_uint16((uint16)dwArrayNum);
    return S_OK;
}

//
// Attributes
//
HRESULT
XLOutput::
SetArcDirection(
ArcDirection value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ArcDirection);
    return S_OK;
}

HRESULT
XLOutput::
SetCharSubModeArray(
CharSubModeArray value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_CharSubModeArray);
    return S_OK;
}

HRESULT
XLOutput::
SetClipMode(
ClipMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ClipMode);
    WriteByte(PCLXL_SetClipMode);
    return S_OK;
}

HRESULT
XLOutput::
SetClipRegion(
ClipRegion value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ClipRegion);
    return S_OK;
}

HRESULT
XLOutput::
SetColorDepth(
ColorDepth value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ColorDepth);
    return S_OK;
}

HRESULT
XLOutput::
SetColorimetricColorSpace(
ColorimetricColorSpace value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ColorimetricColorSpace);
    return S_OK;
}

HRESULT
XLOutput::
SetColorMapping(
ColorMapping value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ColorMapping);
    return S_OK;
}

HRESULT
XLOutput::
SetColorSpace(
ColorSpace value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ColorSpace);
    return S_OK;
}

HRESULT
XLOutput::
SetCompressMode(
CompressMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_CompressMode);
    return S_OK;
}

HRESULT
XLOutput::
SetDataOrg(
DataOrg value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_DataOrg);
    return S_OK;
}

#if 0
HRESULT
XLOutput::
SetDataSource(
DataSource value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_DataSource);
    return S_OK;
}
#endif

#if 0
HRESULT
XLOutput::
SetDataType(
DataType value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_DataType);
    return S_OK;
}
#endif

#if 0
HRESULT
XLOutput::
SetDitherMatrix(
DitherMatrix value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_DitherMatrix);
    return S_OK;
}
#endif

HRESULT
XLOutput::
SetDuplexPageMode(
DuplexPageMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_DuplexPageMode);
    return S_OK;
}

HRESULT
XLOutput::
SetDuplexPageSide(
DuplexPageSide value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_DuplexPageSide);
    return S_OK;
}

HRESULT
XLOutput::
SetErrorReport(
ErrorReport value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_ErrorReport);
    WriteByte(value);
    return S_OK;
}

HRESULT
XLOutput::
SetLineCap(
LineCap value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_LineCap);
    WriteByte(PCLXL_SetLineCap);
    return S_OK;
}

HRESULT
XLOutput::
SetLineJoin(
LineJoin value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_LineJoin);
    WriteByte(PCLXL_SetLineJoin);
    return S_OK;
}

HRESULT
XLOutput::
SetMeasure(
Measure value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_Measure);
    return S_OK;
}

HRESULT
XLOutput::
SetMediaSize(
MediaSize value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_MediaSize);
    return S_OK;
}

HRESULT
XLOutput::
SetMediaSource(
MediaSource value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_MediaSource);
    return S_OK;
}

HRESULT
XLOutput::
SetMediaDestination(
MediaDestination value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_MediaDestination);
    return S_OK;
}

HRESULT
XLOutput::
SetOrientation(
Orientation value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_Orientation);
    return S_OK;
}

HRESULT
XLOutput::
SetPatternPersistence(
PatternPersistence value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_PatternPersistence);
    return S_OK;
}

HRESULT
XLOutput::
SetSimplexPageMode(
SimplexPageMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_SimplexPageMode);
    return S_OK;
}

HRESULT
XLOutput::
SetTxMode(
TxMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_TxMode);
    return S_OK;
}

#if 0
HRESULT
XLOutput::
SetWritingMode(
WritingMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    WriteByte(PCLXL_ubyte);
    WriteByte(value);
    WriteByte(PCLXL_attr_ubyte);
    WriteByte(PCLXL_WritingMode);
    return S_OK;
}
#endif

//
// Value set function
//

HRESULT
XLOutput::
SetFillMode(
FillMode value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    Send_ubyte(value);
    Send_attr_ubyte(eFillMode);
    Send_cmd(eSetFillMode);
    return S_OK;
}


HRESULT
XLOutput::
SetSourceWidth(
uint16 srcwidth)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16(srcwidth) &&
        S_OK == Send_attr_ubyte(eSourceWidth)    )
        return S_OK;
    else
        return S_FALSE;
}


HRESULT
XLOutput::
SetSourceHeight(
uint16 srcheight)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16(srcheight) &&
        S_OK == Send_attr_ubyte(eSourceHeight)    )
        return S_OK;
    else
        return S_FALSE;
}


HRESULT
XLOutput::
SetDestinationSize(
uint16 dstwidth,
uint16 dstheight)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16_xy(dstwidth, dstheight) &&
        S_OK == Send_attr_ubyte(eDestinationSize)    )
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
SetBoundingBox(
uint16 left,
uint16 top,
uint16 right,
uint16 bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16_box(left, top, right, bottom) &&
        S_OK == Send_attr_ubyte(eBoundingBox) )
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
SetBoundingBox(
sint16 left,
sint16 top,
sint16 right,
sint16 bottom)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_sint16_box(left, top, right, bottom) &&
        S_OK == Send_attr_ubyte(eBoundingBox) )
        return S_OK;
    else
        return S_FALSE;
}


HRESULT
XLOutput::
SetROP3(
ROP3 rop3)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XLGState *pGState = this;

    if (S_OK == pGState->CheckROP3(rop3))
        return S_OK;

    if (S_OK == Send_ubyte((ubyte)rop3) &&
        S_OK == Send_attr_ubyte(eROP3) &&
        S_OK == Send_cmd(eSetROP)  &&
        S_OK == pGState->SetROP3(rop3))
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
SetPatternDefineID(
sint16 sint16_patternid)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_sint16(sint16_patternid) &&
        S_OK == Send_attr_ubyte(ePatternDefineID))
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
SetPaletteDepth(
ColorDepth value)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == WriteByte(PCLXL_ubyte) &&
        S_OK == WriteByte(value) &&
        S_OK == WriteByte(PCLXL_attr_ubyte) &&
        S_OK == WriteByte(PCLXL_PaletteDepth) )
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
SetPenWidth(
uint16 uint16_penwidth)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16(uint16_penwidth) &&
        S_OK == Send_attr_ubyte(ePenWidth) &&
        S_OK == Send_cmd(eSetPenWidth)  )
        return S_OK;
    else
        return S_FALSE;
}

HRESULT
XLOutput::
SetMiterLimit(
uint16 uint16_miter)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16(uint16_miter) &&
        S_OK == Send_attr_ubyte(eMiterLength) &&
        S_OK == Send_cmd(eSetMiterLimit))
        return S_OK;
    else
        return S_FALSE;

}

HRESULT
XLOutput::
SetPageOrigin(
uint16 uint16_x,
uint16 uint16_y)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (S_OK == Send_uint16_xy(uint16_x, uint16_y) &&
        S_OK == Send_attr_ubyte(ePageOrigin) &&
        S_OK == Send_cmd(eSetPageOrigin))
        return S_OK;
    else
        return S_FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlgstate.h ===
/*+++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xlgstate.h

Abstract:

    Header file for vector graphics state management.

Environment:

    Windows Whistler

Revision History:

    03/23/00
        Created it.

Note:

    1. Line
        Store Windows NT DDI LINEATTRS sturcture information

    2. Brush
        Brush type (pattern/solid/hatch)
            Hatch brush type
            Pattern brush ID
            Solid brush color

    3. Clip
        Tracks the type of clipping (rectangle/complex).
        Clip rectangle

    4. ROP3 or Transparent/Opaque

        if a printer supports quaternary raster operation,

---*/

#ifndef _XLGSTATE_H_
#define _XLGSTATE_H_

//
// LINE
//

#ifdef __cplusplus

typedef enum {
    kXLLineJoin_Round = JOIN_ROUND,
    kXLLineJoin_Bevel = JOIN_BEVEL,
    kXLLineJoin_Miter = JOIN_MITER
} XLLineJoin;

typedef enum {
        kXLLineType_LA_GEOMETRIC = LA_GEOMETRIC,
        kXLLineType_LA_ALTERNATE = LA_ALTERNATE,
        kXLLineType_LA_STARTGAP  = LA_STARTGAP,
        kXLLineType_LA_STYLED    = LA_STYLED
} XLLineType;

typedef enum {
    kXLLineEndCapRound  = ENDCAP_ROUND,
    kXLLineEndCapSquare = ENDCAP_SQUARE,
    kXLLineEndCapButt   = ENDCAP_BUTT
} XLLineEndCap;

class XLLine
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'line' )

public:

    //
    // Constructure/Destructure
    //
    XLLine::
    XLLine( VOID );

    XLLine::
    XLLine( IN LINEATTRS *plineattrs );

    XLLine::
    ~XLLine( VOID );
    
    // typedef struct {
    // {
    //     FLONG       fl;
    //     ULONG       iJoin;
    //     ULONG       iEndCap;
    //     FLOAT_LONG  elWidth;
    //     FLOATL      eMiterLimit;
    //     ULONG       cstyle;
    //     PFLOAT_LONG pstyle;
    //     FLOAT_LONG  elStyleState;
    // } LINEATTRS, *PLINEATTRS;

    #define XLLINE_NONE        0x00000000
    #define XLLINE_LINETYPE    0x00000001
    #define XLLINE_JOIN        0x00000002
    #define XLLINE_ENDCAP      0x00000004
    #define XLLINE_WIDTH       0x00000008
    #define XLLINE_MITERLIMIT  0x00000010
    #define XLLINE_STYLE       0x00000020

    DWORD GetDifferentAttribute( IN LINEATTRS* plineattrs );

    //
    // Reset line
    //
    VOID ResetLine(VOID);

    //
    // Attributes set functions
    //

    //
    // Line type
    //

    HRESULT SetLineType(IN XLLineType LineType );

    //
    // Line Join
    //

    HRESULT SetLineJoin( IN XLLineJoin LineJoin );

    //
    // Line Join
    //

    HRESULT SetLineEndCap( IN XLLineEndCap LineEndCap );

    //
    // Line width
    //
    HRESULT SetLineWidth( IN FLOAT_LONG elWidth );

    //
    // Line Miter Limit
    //
    HRESULT SetMiterLimit( IN FLOATL eMiterLimit );

    //
    // Line style
    //
    HRESULT SetLineStyle( IN ULONG ulCStyle,
                          IN PFLOAT_LONG pStyle,
                          IN FLOAT_LONG elStyleState );
#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:

    DWORD       m_dwGenFlags;
    LINEATTRS   m_LineAttrs;
};

#endif


//
// Brush
//
#define BRUSH_SIGNATURE 0x48425658 // XBRH

typedef enum {
    kNotInitialized,
    kNoBrush,
    kBrushTypeSolid,
    kBrushTypeHatch,
    kBrushTypePattern
} BrushType;

typedef struct {
    DWORD dwSig;                // Signature BRUSH_SIGNATURE
    BrushType BrushType;        // Brush type
    ULONG ulSolidColor;         // BRUSHOBJ.iSolidColor
    ULONG ulHatch;              // Hatch pattern ID
    DWORD dwCEntries;           // the number of palette 
    DWORD dwColor;              // RGB from BRUSHOBJ_ulGetBrushColor
    DWORD dwPatternBrushID;     // Pattern brush ID
} CMNBRUSH, *PCMNBRUSH;

#ifdef __cplusplus

class Brush
#if DBG
    : public XLDebug
#endif
{

public:
    Brush::
    Brush(VOID);

    Brush::
    ~Brush(VOID);

    //
    // Current brush interface
    //
    HRESULT
    CheckCurrentBrush( IN BRUSHOBJ *pbo);

    //
    // Reset Brush
    //
    VOID ResetBrush(VOID);

    HRESULT
    SetBrush( IN CMNBRUSH *pbrush);

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    //
    // Current selected brush
    //
    CMNBRUSH m_Brush;
};

class XLBrush : public Brush
{
    SIGNATURE( 'brsh' )

public:
    XLBrush::
    XLBrush(VOID){};

    XLBrush::
    ~XLBrush(VOID){};
};

#endif

//
// XLPen
//

#ifdef __cplusplus

class XLPen : public Brush
{
    SIGNATURE( 'pen ' )

public:
    XLPen::
    XLPen(VOID){};

    XLPen::
    ~XLPen(VOID){};
};

#endif


//
// XLClip
//

typedef enum {
    kNoClip = 0,
    kClipTypeRectangle,
    kClipTypeComplex
} ClipType;

#define CLIP_SIGNATURE 0x50494c43 // CLIP

typedef struct {
    DWORD dwSig;                // Signature CLIP_SIGNATURE
    RECTL rclClipRect;
    ULONG ulUniq;
} UNICLIP, *PUNICLIP;

#ifdef __cplusplus

class XLClip
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'clip' )

public:
    XLClip::
    XLClip(VOID);

    XLClip::
    ~XLClip(VOID);

    HRESULT ClearClip(VOID);

    HRESULT CheckClip( IN CLIPOBJ *pco );

    HRESULT SetClip( IN CLIPOBJ *pco );

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    ClipType m_ClipType;
    UNICLIP m_XLClip;

};

#endif



//
// XLRop
//

#ifdef __cplusplus

class XLRop
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'rop ' )
public:
    XLRop::
    XLRop(VOID);

    XLRop::
    ~XLRop(VOID);

    HRESULT CheckROP3( IN ROP3 rop3 );

    HRESULT SetROP3( IN ROP3 rop3 );

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    ROP3 m_rop3;
};

#endif


//
// XLFont
//

#define PCLXL_FONTNAME_SIZE 16
#ifdef __cplusplus

typedef enum _FontType {
    kFontNone,
    kFontTypeDevice,
    kFontTypeTTBitmap,
    kFontTypeTTOutline
} FontType;


class XLFont
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'font' )

public:

    //
    // Constructure/Destructure
    //
    XLFont::
    XLFont( VOID );

    XLFont::
    ~XLFont( VOID );

    //
    // font interface
    //
    HRESULT
    CheckCurrentFont(
        FontType XLFontType,
        PBYTE pPCLXLFontName,
        DWORD dwFontHeight,
        DWORD dwFontWidth,
        DWORD dwFontSymbolSet,
        DWORD dwFontSimulation);

    HRESULT
    SetFont(
        FontType XLFontType,
        PBYTE pPCLXLFontName,
        DWORD dwFontHeight,
        DWORD dwFontWidth,
        DWORD dwFontSymbolSet,
        DWORD dwFontSimulation);

    VOID
    ResetFont(VOID);

    HRESULT
    GetFontName(
        PBYTE paubFontName);

    DWORD
    GetFontHeight(VOID);

    DWORD
    GetFontWidth(VOID);

    DWORD
    GetFontSymbolSet(VOID);

    FontType
    GetFontType(VOID);

    DWORD
    GetFontSimulation(VOID);

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:

    FontType m_XLFontType;
    BYTE  m_aubFontName[PCLXL_FONTNAME_SIZE]; // PCL XL font name
    DWORD m_dwFontHeight;
    DWORD m_dwFontWidth;
    DWORD m_dwFontSymbolSet;
    DWORD m_dwFontSimulation;
};

#endif

//
// XLTxMode
//

class XLTxMode
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'txmd' )

public:

    //
    // Constructure/Destructure
    //
    XLTxMode::
    XLTxMode( VOID );

    XLTxMode::
    ~XLTxMode( VOID );

    //
    // txmode interface
    //
    HRESULT SetSourceTxMode(TxMode SrcTxMode);
    HRESULT SetPaintTxMode(TxMode SrcTxMode);

    TxMode GetSourceTxMode();
    TxMode GetPaintTxMode();

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    TxMode m_SourceTxMode;
    TxMode m_PaintTxMode;
};

//
// XLGState
//

typedef enum _PenBrush 
{
    kPen,
    kBrush
} PenBrush;

#ifdef __cplusplus

class XLGState : public XLLine,
                 public XLBrush,
                 public XLPen,
                 public XLClip,
                 public XLRop,
                 public XLFont,
                 public XLTxMode
{
    SIGNATURE( 'xlgs' )

public:

    XLGState::
    XLGState( VOID ){};

    XLGState::
    ~XLGState( VOID ){};

    VOID
    ResetGState(VOID);

#if DBG
    VOID
    SetAllDbgLevel(DWORD dwLevel);
#endif

};

#endif

#endif // _XLGSTATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlglfch.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     glfcach.h

Abstract:

    PCL XL glyph cache

Environment:

    Windows Whistler

Revision History:

    11/09/00
      Created it.

--*/

#include "xlpdev.h"
#include "xldebug.h"
#include "glyfcach.h"

XLGlyphCache::
XLGlyphCache(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::Ctor entry.\n"));
    m_ulNumberOfFonts = NULL;
    m_ulNumberOfArray = NULL;
    m_paulFontID = NULL;
    m_ppGlyphTable = NULL;
#if DBG
    m_dbglevel = GLYPHCACHE;
#endif
}

XLGlyphCache::
~XLGlyphCache(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::Dtor entry.\n"));
    FreeAll();
}

VOID
XLGlyphCache::
FreeAll(VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::FreeAll entry.\n"));

    MemFree(m_paulFontID);

    ULONG ulI;
    PGLYPHTABLE *ppGlyphTable = m_ppGlyphTable;
    PGLYPHTABLE pGlyphTable;

    for (ulI = 0; ulI < m_ulNumberOfFonts; ulI++, ppGlyphTable++)
    {
        if ((pGlyphTable = *ppGlyphTable) || pGlyphTable->pGlyphID)
        {
            MemFree(pGlyphTable->pGlyphID);
            MemFree(pGlyphTable);
        }
    }
    if (m_ppGlyphTable)
    {
        MemFree(m_ppGlyphTable);
    }
}


HRESULT
XLGlyphCache::
XLCreateFont(
    ULONG ulFontID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::CreateFont(ulFontiD=%d) entry.\n", ulFontID));

    HRESULT hResult;
    ULONG ulI;

    //
    // Search font ID
    //
    ULONG ulArrayID = UlSearchFontID(ulFontID);

    //
    // New font ID
    //
    if (ulArrayID == 0xFFFF || ulArrayID == m_ulNumberOfFonts)
    {
        //
        // Out of buffer. Increase array
        // 
        if (m_ulNumberOfArray == m_ulNumberOfFonts)
        {
            if (S_OK != (hResult = IncreaseArray()))
            {
                XL_ERR(("XLGlyphCache::CreateFont IncreaseArray failed.\n"));
                return hResult;
            }
        }

        *(m_paulFontID + m_ulNumberOfFonts) = ulFontID;

        PGLYPHTABLE pGlyphTable;
        if (!(pGlyphTable = (PGLYPHTABLE)MemAllocZ(sizeof(GLYPHTABLE))))
        {
            XL_ERR(("XLGlyphCache::CreateFont MemAllocZ failed.\n"));
            return E_UNEXPECTED;
        }

        pGlyphTable->wFontID = (WORD)ulFontID;
        pGlyphTable->wGlyphNum = 0;
        pGlyphTable->pFirstGID = NULL;
        pGlyphTable->pGlyphID = NULL;
        pGlyphTable->dwAvailableEntries = 0;

        PGLYPHID pGlyphID;
        if (!(pGlyphID = (PGLYPHID)MemAllocZ(INIT_GLYPH_ARRAY * sizeof(GLYPHID))))
        {
            XL_ERR(("XLGlyphCache::CreateFont MemAllocZ failed.\n"));
            return E_UNEXPECTED;
        }

        pGlyphTable->pGlyphID = pGlyphID;
        pGlyphTable->dwAvailableEntries = INIT_GLYPH_ARRAY;

        *(m_ppGlyphTable + m_ulNumberOfFonts) = pGlyphTable;
        m_ulNumberOfFonts ++;

        XL_VERBOSE(("XLGlyphCache::CreateFont New font ID.\n"));

    }

    return S_OK;
}

HRESULT
XLGlyphCache::
IncreaseArray(
    VOID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::IncreaseArray entry.\n"));

    if (NULL == m_paulFontID || NULL == m_ppGlyphTable)
    {
        if (NULL == m_paulFontID)
        {
            if (!(m_paulFontID = (PULONG)MemAllocZ(INIT_ARRAY * sizeof(ULONG))))
            {
                FreeAll();
                XL_ERR(("XLGlyphCache::IncreaseArray MemAllocZ failed.\n"));
                return E_UNEXPECTED;
            }
        }
        if (NULL == m_ppGlyphTable)
        {
            if (!(m_ppGlyphTable = (GLYPHTABLE**)MemAllocZ(INIT_ARRAY * sizeof(GLYPHTABLE))))
            {
                FreeAll();
                XL_ERR(("XLGlyphCache::IncreaseArray MemAllocZ failed.\n"));
                return E_UNEXPECTED;
            }
        }

        m_ulNumberOfArray = INIT_ARRAY;
        m_ulNumberOfFonts = 0;
    }
    else if (m_ulNumberOfArray == m_ulNumberOfFonts)
    {
        ULONG ulArraySize = m_ulNumberOfArray + ADD_ARRAY;
        PULONG paulTmpFontID;
        PGLYPHTABLE *ppTmpGlyphTable;

        //
        // Allocate new buffer
        //
        if (!(paulTmpFontID = (PULONG)MemAllocZ(ulArraySize)))
        {
            XL_ERR(("XLGlyphCache::IncreaseArray MemAllocZ failed.\n"));
            return E_UNEXPECTED;
        }
        if (!(ppTmpGlyphTable = (GLYPHTABLE**)MemAllocZ(ulArraySize * sizeof(GLYPHTABLE))))
        {
            MemFree(ppTmpGlyphTable);
            XL_ERR(("XLGlyphCache::IncreaseArray MemAllocZ failed.\n"));
            return E_UNEXPECTED;
        }

        //
        // Copy old one to new one
        //
        CopyMemory(paulTmpFontID,
                   m_paulFontID,
                   m_ulNumberOfArray * sizeof(ULONG));
        CopyMemory(ppTmpGlyphTable,
                   m_ppGlyphTable,
                   m_ulNumberOfArray * sizeof(GLYPHTABLE));
        //
        // Free old buffer
        //
        MemFree(m_paulFontID);
        MemFree(m_ppGlyphTable);

        //
        // Set new buffer
        //
        m_paulFontID = paulTmpFontID;
        m_ppGlyphTable = ppTmpGlyphTable;
        m_ulNumberOfArray = ulArraySize;
    }

    return S_OK;
}

ULONG
XLGlyphCache::
UlSearchFontID(
    ULONG ulFontID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::UlSearchFontID entry.\n"));

    ULONG ulReturn, ulI;
    BOOL  bFound;

    if (NULL == m_paulFontID)
    {
        //
        // Error case. Returns 0xFFFF.
        // Here is an assumption. The number of fonts in one document doesn't
        // become larger than 65535.
        //
        XL_ERR(("XLGlyphCache::UlSearchFontID failed.\n"));
        return 0xFFFF;
    }

    bFound = TRUE;

    //
    // Search font ID
    //
    ulI = m_ulNumberOfFonts / 2;
    PULONG paulFontID = m_paulFontID + ulI;

    while ( *paulFontID != ulFontID)
    {
        if (ulI == 0)
        {
            bFound = FALSE;
            break;
        }

        ulI = ulI / 2;

        if (ulI == 0)
        {
            ulI = 1;
        }

        if (*paulFontID < ulFontID)
        {
            paulFontID += ulI; 
        }
        else
        {
            paulFontID -= ulI; 
        }

        if (ulI == 1)
        {
            ulI = 0;
        }
    }

    if (!bFound)
    {
        ulReturn = m_ulNumberOfFonts;
    }
    else
    {
        ulReturn = (ULONG)(paulFontID - m_paulFontID);
    }

    XL_VERBOSE(("XLGlyphCache::UlSearchFontID(ulFontID=%d, ulArrayID=%d).\n", ulFontID, ulReturn));
    return ulReturn;
}

HRESULT
XLGlyphCache::
AddGlyphID(
    ULONG ulFontID,
    ULONG ulGlyphID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::AddGlyphID entry (ulFontiD=%d, ulGlyphID=%d).\n", ulFontID, ulGlyphID));

    ULONG ulArrayID;

    //
    // Get the pointer to GLYPYTABLE of this font.
    //
    if (0xFFFF == (ulArrayID = UlSearchFontID(ulFontID)))
    {
        XL_ERR(("XLGlyphCache::AddGlyphID UlSearchFontID failed.\n"));
        return E_UNEXPECTED;
    }

    PGLYPHTABLE pGlyphTable = *(m_ppGlyphTable+ulArrayID);
    PGLYPHID pGlyphID = pGlyphTable->pFirstGID;
    BOOL bFound;
    WORD wI, wSearchRange;

    wSearchRange = pGlyphTable->wGlyphNum / 2;
    pGlyphID = PSearchGlyph(wSearchRange, TRUE, pGlyphID);
    bFound = TRUE;

    if (pGlyphID)
    {
        while (pGlyphID->ulGlyphID != ulGlyphID)
        {
            if (wSearchRange == 0)
            {
                bFound = FALSE;
                break;
            }
            wSearchRange = wSearchRange / 2;
            if (wSearchRange == 0)
            {
                wSearchRange = 1;
            }

            if (pGlyphID->ulGlyphID > ulGlyphID)
            {
                pGlyphID = PSearchGlyph(wSearchRange, TRUE, pGlyphID);
            }
            else
            {
                pGlyphID = PSearchGlyph(wSearchRange, FALSE, pGlyphID);
            }

            if (wSearchRange == 1)
            {
                wSearchRange = 0;
            }

            if (NULL == pGlyphID)
            {
                bFound = FALSE;
                break;
            }
        }
    }
    else
    {
        //
        // PSearchGlyph failed. There is not glyph available in the cache.
        //
        bFound = FALSE;
    }

    if (bFound)
    {
        XL_VERBOSE(("XLGlyphCache::AddGlyphID FOUND glyph in the cache.\n"));
        return S_FALSE;
    }
    else if (pGlyphID)
    {
        PGLYPHID pPrevGID = pGlyphID->pPrevGID;
        PGLYPHID pNextGID = pGlyphID->pNextGID;
        PGLYPHID pNewGID;

        IncreaseGlyphArray(ulFontID);

        pNewGID = pGlyphTable->pGlyphID + pGlyphTable->wGlyphNum;

        if (pGlyphID->ulGlyphID < ulGlyphID && ulGlyphID < pNextGID->ulGlyphID)
        {
            pGlyphID->pNextGID = pNewGID;
            pNewGID->pPrevGID = pGlyphID;
            pNewGID->pNextGID = pNextGID;
            pNextGID->pPrevGID = pNewGID;
        }
        else
        if (pPrevGID->ulGlyphID < ulGlyphID && ulGlyphID < pGlyphID->ulGlyphID)
        {
            pPrevGID->pNextGID = pNewGID;
            pNewGID->pPrevGID = pPrevGID;
            pNewGID->pNextGID = pGlyphID;
            pGlyphID->pPrevGID = pNewGID;
        }

        pNewGID->ulGlyphID = ulGlyphID;
        pGlyphTable->wGlyphNum++;

        XL_VERBOSE(("XLGlyphCache::AddGlyphID ADDED glyph in the cache.\n"));
        return S_OK;
    }
    else
    {
        PGLYPHID pNewGID;

        IncreaseGlyphArray(ulFontID);

        pNewGID = pGlyphTable->pGlyphID + pGlyphTable->wGlyphNum;
        pNewGID->ulGlyphID = ulGlyphID;
        pNewGID->pPrevGID = NULL;
        pNewGID->pNextGID = NULL;
        pGlyphTable->wGlyphNum++;

        XL_VERBOSE(("XLGlyphCache::AddGlyphID ADDED glyph in the cache.\n"));
        return S_OK;
    }
}

PGLYPHID
XLGlyphCache::
PSearchGlyph(
    WORD wSearchRange,
    BOOL bForward,
    PGLYPHID pGlyphID)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    XL_VERBOSE(("XLGlyphCache::PSearchGlyph entry (wSearchRange=%d,bForward=%d).\n",wSearchRange, bForward));

    WORD wI;

    if (pGlyphID)
    {
        if (bForward)
        {
            for (wI = 0; wI < wSearchRange; wI++)
            {
                if (pGlyphID->pNextGID)
                {
                    pGlyphID = pGlyphID->pNextGID;
                }
                else
                {
                    pGlyphID = NULL;
                    break;
                }
            }
        }
        else
        {
            for (wI = 0; wI < wSearchRange; wI++)
            {
                if (pGlyphID->pNextGID)
                {
                    pGlyphID = pGlyphID->pNextGID;
                }
                else
                {
                    pGlyphID = NULL;
                    break;
                }
            }
        }
    }
    XL_VERBOSE(("XLGlyphCache::PSearchGlyph pGlyphID = %0x.\n", pGlyphID));
    return pGlyphID;
}

HRESULT
XLGlyphCache::
IncreaseGlyphArray(
    ULONG ulFontID)
{
    ULONG ulArrayID;

    //
    // Get the pointer to GLYPYTABLE of this font.
    //
    if (0xFFFF == (ulArrayID = UlSearchFontID(ulFontID)))
    {
        XL_ERR(("XLGlyphCache::AddGlyphID UlSearchFontID failed.\n"));
        return E_UNEXPECTED;
    }

    PGLYPHTABLE pGlyphTable = *(m_ppGlyphTable+ulArrayID);
    //
    // Get the pointer to GLYPYTABLE of this font.
    //
    if (0xFFFF == (ulArrayID = UlSearchFontID(ulFontID)))
    {
        XL_ERR(("XLGlyphCache::AddGlyphID UlSearchFontID failed.\n"));
        return E_UNEXPECTED;
    }

    if (pGlyphTable->wGlyphNum == pGlyphTable->dwAvailableEntries)
    {
        PGLYPHID pGlyphID;

        if (!(pGlyphID = (PGLYPHID)MemAllocZ((pGlyphTable->dwAvailableEntries + ADD_GLYPH_ARRAY) * sizeof(GLYPHID))))
        {
            XL_ERR(("XLGlyphCache::AddGlyphID MemAllocZ failed.\n"));
            return E_UNEXPECTED;
        }

        CopyMemory(pGlyphID, pGlyphTable->pGlyphID, pGlyphTable->dwAvailableEntries * sizeof(GLYPHID));
        pGlyphTable->pFirstGID = pGlyphID + (pGlyphTable->pFirstGID - pGlyphTable->pGlyphID);
        MemFree(pGlyphTable->pGlyphID);
        pGlyphTable->pGlyphID = pGlyphID;
        pGlyphTable->dwAvailableEntries += ADD_GLYPH_ARRAY;

    }
return S_OK;
}

#if DBG
VOID
XLGlyphCache::
SetDbgLevel(
DWORD dwLevel)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
m_dbglevel = dwLevel;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xloutput.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     xloutput.h

Abstract:

    PCL XL low level output

Environment:

    Windows Whistler

Revision History:

    03/23/00
      Created it.

--*/

#ifndef _XLOUTPUT_H_
#define _XLOUTPUT_H_

#define RECT_WIDTH(pRect)   ((pRect)->right - (pRect)->left)
#define RECT_HEIGHT(pRect)  ((pRect)->bottom - (pRect)->top)
#define GET_FOREGROUND_ROP3(rop4) ((rop4) & 0xFF)
#define GET_BACKGROUND_ROP3(rop4) (((rop4) >> 8) & 0xFF)
#define ROP3_NEED_PATTERN(rop3)   (((rop3 >> 4) & 0x0F) != (rop3 & 0x0F))
#define ROP3_NEED_SOURCE(rop3)    (((rop3 >> 2) & 0x33) != (rop3 & 0x33))
#define ROP3_NEED_DEST(rop3)      (((rop3 >> 1) & 0x55) != (rop3 & 0x55))


//
// PCLXL number type
//
typedef BYTE  ubyte;
typedef WORD  uint16;
typedef SHORT sint16;
typedef DWORD uint32;
typedef LONG  sint32;
typedef DWORD real32;

class XLWrite
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE( 'xlwr' )

public:
    XLWrite::
    XLWrite();

    XLWrite::
    ~XLWrite();

    inline
    HRESULT
    WriteByte(BYTE ubData);

    inline
    HRESULT
    Write(PBYTE pData, DWORD dwSize);

    inline
    HRESULT
    XLWrite::
    WriteFloat(
        real32 real32_value);

    HRESULT
    Flush(PDEVOBJ pdevobj);

    HRESULT
    Delete(VOID);

#if DBG
    VOID
    SetDbgLevel(DWORD dwLevel);
#endif

private:
    HRESULT
    IncreaseBuffer(DWORD dwAdditionalDataSize);

#define XLWrite_INITSIZE 2048
#define XLWrite_ADDSIZE  2048

    PBYTE m_pBuffer;
    PBYTE m_pCurrentPoint;
    DWORD m_dwBufferSize;
    DWORD m_dwCurrentDataSize;
};


typedef enum XLCmd {
    eBeginSession = 0x41,
    eEndSession   = 0x42,
    eBeginPage    = 0x43,
    eEndPage      = 0x44,

    eComment         = 0x47,
    eOpenDataSource  = 0x48,
    eCloseDataSource = 0x49,

    eBeginFontHeader = 0x4f,
    eReadFontHeader  = 0x50,
    eEndFontHeader   = 0x51,
    eBeginChar       = 0x52,
    eReadChar        = 0x53,
    eEndChar         = 0x54,
    eRemoveFont      = 0x55,
    eSetCharAttributes= 0x56,

    eBeginStream = 0x5b,
    eReadStream  = 0x5c,
    eEndStream   = 0x5d,
    eExecStream  = 0x5e,


    ePopGS  = 0x60,
    ePushGS = 0x61,

    eSetClipReplace    = 0x62,
    eSetBrushSource    = 0x63,
    eSetCharAngle      = 0x64,
    eSetCharScale      = 0x65,
    eSetCharShear      = 0x66,
    eSetClipIntersect  = 0x67,
    eSetClipRectangle  = 0x68,
    eSetClipToPage     = 0x69,
    eSetColorSpace     = 0x6a,
    eSetCursor         = 0x6b,
    eSetCursorRel      = 0x6c,
    eSetHalftoneMethod = 0x6d,
    eSetFillMode       = 0x6e,
    eSetFont           = 0x6f,

    eSetLineDash       = 0x70,
    eSetLineCap        = 0x71,
    eSetLineJoin       = 0x72,
    eSetMiterLimit     = 0x73,
    eSetPageDefaultCTM = 0x74,
    eSetPageOrigin     = 0x75,
    eSetPageRotation   = 0x76,
    eSetPageScale      = 0x77,
    eSetPatternTxMode  = 0x78,
    eSetPenSource      = 0x79,
    eSetPenWidth       = 0x7a,
    eSetROP            = 0x7b,
    eSetSourceTxMode   = 0x7c,
    eSetCharBoldValue  = 0x7d,

    eSetClipMode       = 0x7f,
    eSetPathToClip     = 0x80,
    eSetCharSubMode    = 0x81,

    eCloseSubPath      = 0x84,
    eNewPath           = 0x85,
    ePaintPath         = 0x86,

    eArcPath           = 0x91,

    eBezierPath        = 0x93,

    eBezierRelPath     = 0x95,
    eChord             = 0x96,
    eChordPath         = 0x97,
    eEllipse           = 0x98,
    eEllipsePath       = 0x99,

    eLinePath          = 0x9b,

    eLineRelPath       = 0x9d,
    ePie               = 0x9e,
    ePiePath           = 0x9f,

    eRectangle         = 0xa0,
    eRectanglePath     = 0xa1,
    eRoundRectangle     = 0xa2,
    eRoundRectanglePath = 0xa3,

    eText     = 0xa8,
    eTextPath = 0xa9,

    eBeginImage       = 0xb0,
    eReadImage        = 0xb1,
    eEndImage         = 0xb2,
    eBeginRastPattern = 0xb3,
    eReadRastPattern  = 0xb4,
    eEndRastPattern   = 0xb5,
    eBeginScan        = 0xb6,

    eEndScan     = 0xb8,
    eScanLineRel = 0xb9
};


//
// Note: It is necessary to initialize HatchBrushAvailability when creating
//       XLOutput.
//
// BUGBUG: Brush management object has to be implemented
//

class XLGState;
class XLOutput: public XLWrite, 
                public XLGState
{
    SIGNATURE( 'tolx' )

public:
    XLOutput::
    XLOutput(VOID);

    XLOutput::
    ~XLOutput(VOID);

    //
    // Set scaling factor
    //
    DWORD
    GetResolutionForBrush();

    VOID
    SetResolutionForBrush(DWORD dwRes);

    //
    // HatchBrushAvailability set/get functions
    //
    VOID
    SetHatchBrushAvailability(
        DWORD dwHatchBrushAvailability);

    DWORD
    GetHatchBrushAvailability(
        VOID);

    //
    // Command
    //
    HRESULT
    Send_cmd(XLCmd Cmd);

    HRESULT
    Send_attr_ubyte(Attribute Attr);

    HRESULT
    Send_attr_uint16(Attribute Attr);


    //
    // Number
    //
    HRESULT
    Send_ubyte(ubyte ubyte_data);
    HRESULT
    Send_ubyte_xy(ubyte ubyte_x, ubyte ubyte_y);
    HRESULT
    Send_ubyte_box(ubyte ubyte_left, ubyte ubyte_top, ubyte ubyte_right, ubyte ubyte_bottom);
    HRESULT
    Send_ubyte_array_header(DWORD dwArrayNum);

    HRESULT
    Send_uint16(uint16 uint16_data);
    HRESULT
    Send_uint16_xy(uint16 uint16_x, uint16 uint16_y);
    HRESULT
    Send_uint16_box(uint16 uint16_left, uint16 uint16_top, uint16 uint16_right, uint16 uint16_bottom);
    HRESULT
    Send_uint16_array_header(DWORD dwArrayNum);

    HRESULT
    Send_uint32(uint32 uint32_data);
    HRESULT
    Send_uint32_xy(uint32 uint32_x, uint32 uint32_y);
    HRESULT
    Send_uint32_box(uint32 uint32_left, uint32 uint32_top, uint32 uint32_right, uint32 uint32_bottom);
    HRESULT
    Send_uint32_array_header(DWORD dwArrayNum);

    HRESULT
    Send_sint16(sint16 sint16_data);
    HRESULT
    Send_sint16_xy(sint16 sint16_x, sint16 sint16_y);
    HRESULT
    Send_sint16_box(sint16 sint16_left, sint16 sint16_top, sint16 sint16_right, sint16 sint16_bottom);
    HRESULT
    Send_sint16_array_header(DWORD dwArrayNum);

    HRESULT
    Send_sint32(sint32 sint32_data);
    HRESULT
    Send_sint32_xy(sint32 sint32_x, sint32 sint32_y);
    HRESULT
    Send_sint32_box(sint32 sint32_left, sint32 sint32_top, sint32 sint32_right, sint32 sint32_bottom);
    HRESULT
    Send_sint32_array_header(DWORD dwArrayNum);

    HRESULT
    Send_real32(real32 real32_data);
    HRESULT
    Send_real32_xy(real32 real32_x, real32 real32_y);
    HRESULT
    Send_real32_box(real32 real32_left, real32 real32_top, real32 real32_right, real32 real32_bottom);
    HRESULT
    Send_real32_array_header(DWORD dwArrayNum);

    //
    // Attribute
    //
    HRESULT
    SetArcDirection(ArcDirection value);

    HRESULT
    SetCharSubModeArray(CharSubModeArray value);

    HRESULT
    SetClipMode(ClipMode value);

    HRESULT
    SetClipRegion(ClipRegion value);

    HRESULT
    SetColorDepth(ColorDepth value);

    HRESULT
    SetColorimetricColorSpace(ColorimetricColorSpace value);

    HRESULT
    SetColorMapping(ColorMapping value);

    HRESULT
    SetColorSpace(ColorSpace value);

    HRESULT
    SetCompressMode(CompressMode value);

    HRESULT
    SetDataOrg(DataOrg value);

    #if 0
    HRESULT
    SetDataSource(DataSource value);
    #endif

    #if 0
    HRESULT
    SetDataType(DataType value);
    #endif

    #if 0
    HRESULT
    SetDitherMatrix(DitherMatrix value);
    #endif

    HRESULT
    SetDuplexPageMode(DuplexPageMode value);

    HRESULT
    SetDuplexPageSide(DuplexPageSide value);
    
    HRESULT
    SetErrorReport(ErrorReport value);

    HRESULT
    SetFillMode(FillMode value);

    HRESULT
    SetLineCap(LineCap value);

    HRESULT
    SetLineJoin(LineJoin value);

    HRESULT
    SetMiterLimit(uint16 uint16_miter);
            
    HRESULT
    SetMeasure(Measure value);

    HRESULT
    SetMediaSize(MediaSize value);

    HRESULT
    SetMediaSource(MediaSource value);

    HRESULT
    SetMediaDestination(MediaDestination value);

    HRESULT
    SetOrientation(Orientation value);

    HRESULT
    SetPatternPersistence(PatternPersistence value);

    HRESULT
    SetSimplexPageMode(SimplexPageMode value);

    HRESULT
    SetTxMode(TxMode value);

    #if 0
    HRESULT
    SetWritingMode(WritingMode value);
    #endif

    //
    // Number/value set function
    //
    HRESULT
    XLOutput::
    SetSourceWidth(
        uint16 srcwidth);

    HRESULT
    XLOutput::
    SetSourceHeight(
        uint16 srcheight);

    HRESULT
    XLOutput::
    SetDestinationSize(
        uint16 dstwidth,
        uint16 dstheight);

    HRESULT
    SetBoundingBox(
        sint16 left,
        sint16 top,
        sint16 right,
        sint16 bottom);

    HRESULT
    SetBoundingBox(
        uint16 left,
        uint16 top,
        uint16 right,
        uint16 bottom);

    HRESULT
    SetROP3(ROP3 rop3);

    HRESULT
    SetGrayLevel(ubyte ubyte_gray);

    HRESULT
    SetPatternDefineID(
        sint16 sint16_patternid);

    HRESULT
    SetPaletteDepth(
        ColorDepth value);

    HRESULT
    SetPaletteData(
        ColorDepth value,
        DWORD      dwPaletteNum,
        DWORD     *pdwColorTable);

    HRESULT
    SetPenWidth(
       uint16 uint16_penwidth);

    HRESULT
    SetPageOrigin(
        uint16 uint16_x,
        uint16 uint16_y);

    //
    // High level function
    //
    HRESULT
    BeginImage(
        ColorMapping CMapping,
        ULONG   ulOutputBPP,
        ULONG   ulSrcWidth,
        ULONG   ulSrcHeight,
        ULONG   ulDestWidth,
        ULONG   ulDestHeight);

    HRESULT
    XLOutput::
    SetOutputBPP(
        ColorMapping CMapping,
        ULONG   ulOutputBPP);

    HRESULT
    XLOutput::
    SetPalette(
        ULONG ulOutputBPP,
        ColorDepth value,
        DWORD dwCEntries,
        DWORD *pdwColor);

    HRESULT
    SetClip(
        CLIPOBJ *pco);

    HRESULT
    RoundRectanglePath(
        RECTL  *prclBounds);

    HRESULT
    SetCursor(
        ULONG   ulX,
        ULONG   ulY);

    HRESULT
    ReadImage(
        DWORD   dwBlockHeight,
        CompressMode CMode);

    HRESULT
    ReadRasterPattern(
        DWORD   dwBlockHeight,
        CompressMode CMode);

    HRESULT
    RectanglePath(RECTL *prclRect);

    HRESULT
    BezierPath(POINTFIX *pptfx, LONG lPoints);

    HRESULT
    LinePath(POINTFIX *pptfx, LONG lPoints);

    HRESULT
    Path(PATHOBJ *ppo);

    HRESULT
    Paint(VOID);

    HRESULT
    SetBrush(BRUSHOBJ *pbo,
             POINTL *pptlBrushOrg);

    HRESULT
    SetPen(
        LINEATTRS *plineattrs,
        XFORMOBJ *pxo);

    HRESULT
    SetPenColor(
        BRUSHOBJ *pbo,
        POINTL   *pptlBrushOrg);

    inline
    VOID
    SetupBrush(
        BRUSHOBJ *pbo,
        POINTL *pptlBrushOrg,
        CMNBRUSH *pcmnbrush);

    HRESULT
    SetFont(
        FontType fonttype,
        PBYTE    pFontName,
        DWORD    dwFontHeight,
        DWORD    dwFontWidth,
        DWORD    dwSymbolSet,
        DWORD    dwSimulation);

    #define XLOUTPUT_FONTSIM_BOLD     0x00000001
    #define XLOUTPUT_FONTSIM_ITALIC   0x00000002
    #define XLOUTPUT_FONTSIM_VERTICAL 0x00000004

    HRESULT
    SetSourceTxMode(TxMode SrcTxMode);

    HRESULT
    SetPaintTxMode(TxMode PaintTxMode);

    //
    // Helper function
    //
    HRESULT
    GetCursorPos(
        PULONG pulx,
        PULONG puly);

    //
    // Set cursor offset value
    //
    HRESULT
    SetCursorOffset(
        ULONG ulX,
        ULONG ulY);

#if DBG
    VOID SetOutputDbgLevel(DWORD dwLevel);
    VOID SetGStateDbgLevel(DWORD dwLevel);
#endif

private:
    #define HORIZONTAL_AVAILABLE 0x00000001
    #define VERTICAL_AVAILABLE   0x00000002
    #define BDIAGONAL_AVAILABLE  0x00000004
    #define FDIAGONAL_AVAILABLE  0x00000008
    #define CROSS_AVAILABLE      0x00000010
    #define DIAGCROSS_AVAILABLE  0x00000020

    DWORD m_dwHatchBrushAvailability;
    DWORD m_dwResolution;
    ULONG m_ulX;
    ULONG m_ulY;
    ULONG m_ulOffsetX;
    ULONG m_ulOffsetY;
#if DBG
    DWORD m_dbglevel;
#endif
   
};


#endif // _XLOUTPUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xltext.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     xltext.h

Abstract:

    PCL XL Font related data structures

Environment:

    Windows Whistler

Revision History:

    03/23/00
      Created it.

--*/

#ifndef _XLTEXT_H_
#define _XLTEXT_H_

//
// Downloading Soft Fonts in PCL XL 2.0
//

//
// Downloading Font Headers
//

//
// The PCL XL 2.0 Format 0 Font Header
//

//
// Orientation is defined in pclxle.h
//

//
// Font Scaling Technology
//
typedef enum {
    eTrueType = 1,
    eBitmap   = 254
} FontScale;

//
// Mapping
//
typedef enum {
    eUnicode = 590,
    eWin31Latin1 = 629,
    eWin31JDBCS = 619,
    eGB2312_1980 = 579,
    eBig5 = 596,
    eKS_C5601_1987 = 616
} Mapping;

typedef struct _PCLXL_FONTHEADER {
    BYTE ubFormat;
    BYTE ubOrientation;
    WORD wMapping;
    BYTE ubFontScallingTech;
    BYTE ubVariety;
    WORD wNumOfChars;
} PCLXL_FONTHEADER, *PPCLXL_FONTHEADER;


//
// Font Data Segment
//

//
// The BR Segment (Bitmap Resolution Segment) (Bitmap Fonts Only)
//

#define PCLXL_BR_SIGNATURE        'RB'
#define PCLXL_BR_SEGMENT_SIZE       4
#define PCLXL_BR_RESOLUTION_300   300
#define PCLXL_BR_RESOLUTION_600   600
#define PCLXL_BR_RESOLUTION_1200 1200

typedef struct _PCLXL_BR_SEGMENT {
    WORD  wSignature;
    WORD  wSegmentSize;
    WORD  wSegmentSizeAlign;
    WORD  wXResolution;
    WORD  wYResolution;
} PCLXL_BR_SEGMENT, *PPCLXL_BR_SEGMENT;

//
// The GC Segment (Galley Character Segment) (TrueType Fonts Only)
//

typedef struct _PCLXL_GC_REGION {
    WORD UpperLeftCharCode;
    WORD LowerRightCharCode;
    WORD GalleyChar;
} PCLXL_GC_REGION, *PPCLXL_GC_REGION;

#define PCLXL_GC_SIGNATURE        'CG'
#define PCLXL_GC_SEGMENT_HEAD_SIZE 6

typedef struct _PCLXL_GC_SEGMENT {
    WORD  wSignature;
    WORD  wSegmentSize;
    WORD  wSegmentSizeAlign;
    WORD  wFormat;
    WORD  wDefaultGalleyCharacter;
    WORD  wNumberOfRegions;
    PCLXL_GC_REGION Region[1];
} PCLXL_GC_SEGMENT, *PPCLXL_GC_SEGMENT;


//
// The GT Segment (Global TrueType Segment) (TrueType Fonts Only)
//

typedef struct _PCLXL_GT_TABLE_DIR {
    DWORD dwTableTag;
    DWORD dwTableCheckSum;
    DWORD dwTableOffset;
    DWORD dwTableSize;
} PCLXL_GT_TABLE_DIR, PPCLXL_GT_TABLE_DIR;

#define PCLXL_GT_SIGNATURE        'TG'

typedef struct _PCLXL_GT_SEGMENT {
    WORD  wSignature;
    WORD  wSegmentSize1;
    WORD  wSegmentSize2;
} PCLXL_GT_SEGMENT, *PPCLXL_GT_SEGMENT;

typedef struct _PCLXL_GT_TABLE_DIR_HEADER {
    DWORD dwSFNTVersion;
    WORD  wNumOfTables;
    WORD  wSearchRange;
    WORD  wEntrySelector;
    WORD  wRangeShift;
} PCLXL_GT_TABLE_DIR_HEADER, *PPCLXL_GT_TABLE_DIR_HEADER;

//
// The NULL Segment
//

#define PCLXL_NULL_SIGNATURE 0xFFFF

typedef struct _PCLXL_NULL_SEGMENT {
    WORD  wSignature;
    WORD  wSegmentSize;
    WORD  wSegmentSizeAlign;
} PCLXL_NULL_SEGMENT, *PPCLXL_NULL_SEGMENT;

//
// The VE Segment (Vertical Exclude Segment) (Vertical TrueType Fonts Only)
//

typedef struct _PCLXL_VE_RANGE {
    WORD RangeFirstCode;
    WORD RangeLastCode;
} PCLXL_VE_RANGE, *PPCLXL_VE_RANGE;

#define PCLXL_VE_SIGNATURE        'EV'

typedef struct _PCLXL_VE_SEGMENT {
    WORD wSignature;
    WORD wSegmentSize;
    WORD wSegmentSizeAlign;
    WORD wFormat;
    WORD wNumberOfRanges;
    PCLXL_VE_RANGE Range[1];
} PCLXL_VE_SEGMENT, *PPCLXL_VE_SEGMENT;

//
// The VI Segment (Vendor Information Segment)
//

#define PCLXL_VI_SIGNATURE        'IV'

typedef struct _PCLXL_VI_SEGMENT {
    WORD wSignature;
    WORD wSegmentSize;
    WORD wSegmentSizeAlign;
} PCLXL_VI_SEGMENT, *PPCLXL_VI_SEGMENT;

//
// The VR Segment (Vertical Rotation Segment) (Vertical TrueType Fonts Only)
//

#define PCLXL_VR_SIGNATURE 'RV'

typedef struct _PCLXL_VR_SEGMENT {
    WORD wSignature;
    WORD wSegmentSize;
    WORD wSegmentSizeAlign;
    WORD wFormat;
    SHORT sTypoDescender;
} PCLXL_VR_SEGMENT, *PPCLXL_VR_SEGMENT;

//
// The VT Segment (Vertical Transformation Segment)
// (Vertical TrueType Fonts with Substitutes Only)
//

typedef struct _PCLXL_VT_GLYPH {
    WORD wHorizontalGlyphID;
    WORD wVerticalSubstituteGlyphID;
} PCLXL_VT_GLYPH, *PPCLXL_VT_GLYPH;

#define PCLXL_VT_SIGNATURE 'TV'

typedef struct _PCLXL_VT_SEGMENT {
    WORD wSignature;
    WORD wSegmentSize;
    WORD wSegmentSizeAlign;
    PCLXL_VT_GLYPH GlyphTable[1];
} PCLXL_VT_SEGMENT, *PPCLXL_VT_SEGMENT;

//
// Downloading Characters
//

//
// Bitmap Characters Format 0
//

typedef struct _PCLXL_BITMAP_CHAR {
    BYTE ubFormat;
    BYTE ubClass;
    WORD wLeftOffset;
    WORD wTopOffset;
    WORD wCharWidth;
    WORD wCharHeight;
} PCLXL_BITMAP_CHAR, *PPCLXL_BITMAP_CHAR;


//
// TrueType Glyphs Format 1 Class 0
//

typedef struct _PCLXL_TRUETYPE_CHAR_C0 {
    BYTE ubFormat;
    BYTE ubClass;
    WORD wCharDataSize;
    WORD wTrueTypeGlyphID;
} PCLXL_TRUETYPE_CHAR_C0, *PPCLXL_TRUETYPE_CHAR_C0;


//
// TrueType Glyphs Format 1 Class 1
//

typedef struct _PCLXL_TRUETYPE_CHAR_C1 {
    BYTE ubFormat;
    BYTE ubClass;
    WORD wCharDataSize;
    WORD wLeftSideBearing;
    WORD wAdvanceWidth;
    WORD wTrueTypeGlyphID;
} PCLXL_TRUETYPE_CHAR_C1, *PPCLXL_TRUETYPE_CHAR_C1;

//
// TrueType Glyphs Format 1 Class 2
//

typedef struct _PCLXL_TRUETYPE_CHAR_C2 {
    BYTE ubFormat;
    BYTE ubClass;
    WORD wCharDataSize;
    WORD wLeftSideBearing;
    WORD wAdvanceWidth;
    WORD wTopSideBearing;
    WORD wTrueTypeGlyphID;
} PCLXL_TRUETYPE_CHAR_C2, *PPCLXL_TRUETYPE_CHAR_C2;

#endif // _XLTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlpdev.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

     xlpdev.h

Abstract:

    PCL XL module PDEV header file    

Environment:

    Windows Whistler

Revision History:

    03/23/00
      Created it.

--*/

#ifndef _XLPDEV_H_
#define _XLPDEV_H_

#include "lib.h"
#include "winnls.h"
#include "unilib.h"
#include "prntfont.h"

#include "gpd.h"
#include "mini.h"

#include "winres.h"
#include "pdev.h"

#include "cmnhdr.h"

//
// Debug text.
//
#if DBG
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)
#define XL_DBGMSG(level, prefix, msg) { \
            if (this->m_dbglevel <= (level)) { \
                DbgPrint("%s %s (%d): ", prefix, __FILE__, __LINE__); \
                DbgPrint msg; \
            } \
        }

#define XL_DBGPRINT(level, msg) { \
            if (this->m_dbglevel <= (level)) { \
                DbgPrint msg; \
            } \
        }
#define XL_VERBOSE(msg) XL_DBGPRINT(DBG_VERBOSE, msg)
#define XL_TERSE(msg) XL_DBGPRINT(DBG_TERSE, msg)
#define XL_WARNING(msg) XL_DBGMSG(DBG_WARNING, "WRN", msg)
#define XL_ERR(msg) XL_DBGMSG(DBG_ERROR, "ERR", msg)

#else

#define XL_VERBOSE(msg)
#define XL_TERSE(msg)
#define XL_WARNING(msg)
#define XL_ERR(msg)

#endif

typedef ULONG ROP3;
typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'PCLX'      // Declaser series dll
#define DLLTEXT(s)      __TEXT("PCLXL:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L

//
// Master Unit
//
#define MASTER_UNIT 1200

//
// Device font resolution
//
#define DEVICEFONT_UNIT 600

//
// Buffer macros
//
#define INIT_CHAR_NUM 256

//
// Memory allocation
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }


//
// Others
//
#define GET_COLOR_TABLE(pxlo) \
        (((pxlo)->flXlate & XO_TABLE) ? \
           ((pxlo)->pulXlate ? (pxlo)->pulXlate : XLATEOBJ_piVector(pxlo)) : \
           NULL)

//
//      OEM UD Type Defines
////////////////////////////////////////////////////////

//
// Warning: the following enum order must match the order in OEMHookFuncs[].
//
enum {
    UD_DrvRealizeBrush,
    UD_DrvDitherColor,
    UD_DrvCopyBits,
    UD_DrvBitBlt,
    UD_DrvStretchBlt,
    UD_DrvStretchBltROP,
    UD_DrvPlgBlt,
    UD_DrvTransparentBlt,
    UD_DrvAlphaBlend,
    UD_DrvGradientFill,
    UD_DrvTextOut,
    UD_DrvStrokePath,
    UD_DrvFillPath,
    UD_DrvStrokeAndFillPath,
    UD_DrvPaint,
    UD_DrvLineTo,
    UD_DrvStartPage,
    UD_DrvSendPage,
    UD_DrvEscape,
    UD_DrvStartDoc,
    UD_DrvEndDoc,
    UD_DrvNextBand,
    UD_DrvStartBanding,
    UD_DrvQueryFont,
    UD_DrvQueryFontTree,
    UD_DrvQueryFontData,
    UD_DrvQueryAdvanceWidths,
    UD_DrvFontManagement,
    UD_DrvGetGlyphMode,

    MAX_DDI_HOOKS,
};

struct IPrintOemDriverUni;

extern const DWORD dw1BPPPal[];
extern const DWORD dw4BPPPal[];

#define XLBRUSH_SIG 'rblx'

typedef struct _XLBRUSH {
    DWORD dwSig;
    DWORD dwHatch;
    DWORD dwOutputFormat;
    DWORD dwPatternID; // Pattern ID. 0 if it's not a pattern.
    DWORD dwCEntries;
    DWORD dwColor;
    DWORD adwColor[1];
} XLBRUSH, *PXLBRUSH;

class XLOutput;
class XLTrueType;
class XLFont;

#define XLPDEV_SIG 'dplx'

typedef struct _XLPDEV {
    DWORD dwSig;

    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    // UNIDRV PDEV
    //
    PPDEV pPDev;

    //
    // General flags
    // 
    DWORD dwFlags;
#define XLPDEV_FLAGS_RESET_FONT       0x00000001
#define XLPDEV_FLAGS_FIRSTPAGE        0x00000002
#define XLPDEV_FLAGS_CHARDOWNLOAD_ON  0x00000004
#define XLPDEV_FLAGS_ENDDOC_CALLED    0x00000008
#define XLPDEV_FLAGS_RESETPDEV_CALLED 0x00000010
#define XLPDEV_FLAGS_STARTPAGE_CALLED 0x00000020

    //
    // Device font data structures
    //
    DWORD      dwcbTransSize;
    PTRANSDATA pTransOrg;
    DWORD      dwcbWidthSize;
    PLONG      plWidth;

    //
    // Device font string cache
    //
    DWORD      dwCharCount;
    DWORD      dwMaxCharCount;
    PPOINTL    pptlCharAdvance;
    PWORD      pawChar;
    LONG       lStartX;
    LONG       lStartY;
    LONG       lPrevX;
    LONG       lPrevY;

    //
    // TrueType font width
    //
    DWORD      dwFixedTTWidth;

    //
    // Cursor position cache
    //
    LONG lX;
    LONG lY;

    //
    // Scaled IFIMETRICS.fwdUnitsPerEm.
    //        IFIMETRICS.fwdMaxCharWidth
    //
    FWORD      fwdUnitsPerEm;
    FWORD      fwdMaxCharWidth;

    //
    // Text rotation
    //
    DWORD      dwTextAngle;

    //
    //
    // Brush
    //
    DWORD      dwLastBrushID;
    DWORD      dwFontHeight;
    DWORD      dwFontWidth;
    DWORD      dwTextRes;

    //
    // TrueType
    //
    DWORD      dwNumOfTTFont;
    XLTrueType *pTTFile;

    //
    // Output
    //
    XLOutput   *pOutput;

    //
    // Reset font cache
    //
    XLFont *pXLFont;
} XLPDEV, *PXLPDEV;

#endif // _XLPDEV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlvminit.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xlvminit.cpp

Abstract:

    PCLXL module initializer

Environment:

    Windows Whistler

Revision History:

    08/23/99     
        Created it.

--*/

#include "vectorc.h"
#include "xlvminit.h"

static VMPROCS PCLXLProcs =
{
    PCLXLDriverDMS,             // PCLXLDriverDMS
    NULL,                       // PCLXLCommandCallback
    NULL,                       // PCLXLImageProcessing
    NULL,                       // PCLXLFilterGraphics
    NULL,                       // PCLXLCompression
    NULL,                       // PCLXLHalftonePattern
    NULL,                       // PCLXLMemoryUsage
    NULL,                       // PCLXLTTYGetInfo
    PCLXLDownloadFontHeader,    // PCLXLDownloadFontHeader
    PCLXLDownloadCharGlyph,     // PCLXLDownloadCharGlyph
    PCLXLTTDownloadMethod,      // PCLXLTTDownloadMethod
    PCLXLOutputCharStr,         // PCLXLOutputCharStr
    PCLXLSendFontCmd,           // PCLXLSendFontCmd
    PCLXLTextOutAsBitmap,                       
    PCLXLEnablePDEV,
    PCLXLResetPDEV,
    NULL,                       // PCLXLCompletePDEV,
    PCLXLDisablePDEV,
    NULL,                       // PCLXLEnableSurface,
    NULL,                       // PCLXLDisableSurface,
    PCLXLDisableDriver,
    PCLXLStartDoc,
    PCLXLStartPage,
    PCLXLSendPage,
    PCLXLEndDoc,
    NULL,
    NULL,
    NULL,
    PCLXLBitBlt,
    PCLXLStretchBlt,
    PCLXLStretchBltROP,
    PCLXLPlgBlt,
    PCLXLCopyBits,
    NULL,
    PCLXLRealizeBrush,
    PCLXLLineTo,
    PCLXLStrokePath,
    PCLXLFillPath,
    PCLXLStrokeAndFillPath,
    PCLXLGradientFill,
    PCLXLAlphaBlend,
    NULL,
    PCLXLTextOut,
    PCLXLEscape,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
};

PVMPROCS PCLXLInitVectorProcTable (
                            PDEV    *pPDev,
                            DEVINFO *pDevInfo,
                            GDIINFO *pGDIInfo )
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    if (pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS)
        return NULL;
    else
        return &PCLXLProcs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xltt.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xltt.h

Abstract:

    TrueType font handlig object

Environment:

    Windows Whistler

Revision History:

    03/23/00
        Created it.

--*/

#ifndef _XLTT_H_
#define _XLTT_H_

//
// TrueType font 
//
// Header
//
typedef struct _TTHEADER {
    DWORD  dwSfntVersion;
    USHORT usNumTables;
    USHORT usSearchRange;
    USHORT usEntrySelector;
    USHORT usRangeShift;
} TTHEADER, *PTTHEADER;

typedef struct _TTCHEADER {
    DWORD dwTTCTag;
    DWORD dwVersion;
    ULONG ulDirCount;
} TTCHEADER, *PTTCHEADER;

//
// Directory
//
typedef struct _TTDIR {
    ULONG  ulTag;
    ULONG  ulCheckSum;
    ULONG  ulOffset;
    ULONG  ulLength;
} TTDIR, *PTTDIR;

//
// head table
// 
typedef DWORD longDateTime[2];

typedef struct _HEAD {
    DWORD Tableversionnumber;
    DWORD fontRevision;
    ULONG checkSumAdjustment;
    ULONG magicNumber;
    USHORT flags;
    USHORT unitsPerEm;
    longDateTime created;
    longDateTime modified;
    FWORD xMin;
    FWORD yMin;
    FWORD xMax;
    FWORD yMax;
    USHORT macStyle;
    USHORT lowestRecPPEM;
    SHORT fontDirectionHint;
    SHORT indexToLocFormat;
    SHORT glyphDataFormat;
} HEAD, *PHEAD;

//
// maxp table
//
typedef struct _MAXP {
    DWORD  Tableversionnumber;
    USHORT numGlyphs;
    USHORT maxPoints;
    USHORT maxContours;
    USHORT maxCompositePoints;
    USHORT maxCompositeContours;
    USHORT maxZones;
    USHORT maxTwilightPoints;
    USHORT maxStorage;
    USHORT maxFunctionDefs;
    USHORT maxInstructionDefs;
    USHORT maxStackElements;
    USHORT maxSizeOfInstructions;
    USHORT maxComponentElements;
    USHORT maxComponentDepth;
} MAXP, *PMAXP;

//
// hhea table
//
typedef struct _HHEA {
    DWORD dwVersion;
    SHORT sAscender;
    SHORT sDescender;
    SHORT sLineGap;
    USHORT usAdvanceWidthMax;
    SHORT sMinLeftSideBearing;
    SHORT sMinRightSideBearing;
    SHORT sxMaxExtent;
    SHORT sCaretSlopeRise;
    SHORT sCaretSlopeRun;
    SHORT sCaretOffset;
    SHORT sReserved1;
    SHORT sReserved2;
    SHORT sReserved3;
    SHORT sReserved4;
    SHORT sMetricDataFormat;
    USHORT usNumberOfHMetrics;
} HHEA, *PHHEA;

//
// vhea table
//
typedef struct _VHEA {
    DWORD dwVersion;
    SHORT sAscender;
    SHORT sDescender;
    SHORT sLineGap;
    USHORT usAdvanceHightMax;
    SHORT sMinTopSideBearing;
    SHORT sMinBottomSideBearing;
    SHORT syMaxExtent;
    SHORT sCaretSlopeRise;
    SHORT sCaretSlopeRun;
    SHORT sCaretOffset;
    SHORT sReserved1;
    SHORT sReserved2;
    SHORT sReserved3;
    SHORT sReserved4;
    SHORT sMetricDataFormat;
    USHORT usNumberOfVMetrics;
} VHEA, *PVHEA;

//
// hmtx table
//
typedef struct _HMTX {
    USHORT usAdvanceWidth;
    SHORT  sLeftSideBearing;
} HMTX, *PHMTX;

//
// vmtx table
//
typedef struct _VMTX {
    USHORT usAdvanceWidth;
    SHORT  sTopSideBearing;
} VMTX, *PVMTX;


//
// glyf table
//
typedef struct _GLYF {
    SHORT  numberOfContours;
    SHORT  xMin;
    SHORT  yMin;
    SHORT  xMax;
    SHORT  yMax;
} GLYF, *PGLYF;

//
// Composite glyph description
//
// SHORT -1
//
#define COMPONENTCTRCOUNT           -1

typedef struct _CGLYF {
    SHORT  flags;
    SHORT  glyphIndex;
    SHORT  argument1;
    SHORT  argument2;
} CGLYF, *PCGLYF;

typedef struct _CGLYF_BYTE {
    SHORT  flags;
    SHORT  glyphIndex;
    BYTE   argument1;
    BYTE   argument2;
} CGLYF_BYTE, *PCGLYF_BYTE;

//
// Format 1 Class 1 or 2 is used to download TrueType font.
// Now hhea, hmtx, vhea, vmtx are not necessary.
// 
typedef enum TagID {
    TagID_First = 0,
    TagID_cvt = 0,
    TagID_fpgm,
    TagID_gdir, // Empty table. This is a placeholder for the table that printer
                // will allocate to store downloaded charactres.
    TagID_head,
    TagID_maxp,
    TagID_perp,

    TagID_hhea,
    TagID_hmtx,
    TagID_vhea,
    TagID_vmtx,

    TagID_loca,
    TagID_glyf,
    TagID_os2,

    TagID_MAX,
    TagID_Header = TagID_vmtx + 1
};

typedef enum TTTag {
    TTTag_cvt  = ' tvc', //0
    TTTag_fpgm = 'mgpf', //1
    TTTag_gdir = 'ridg', //2
    TTTag_head = 'daeh', //3
    TTTag_maxp = 'pxam', //4
    TTTag_perp = 'perp', //5

    TTTag_hhea = 'aehh', //6
    TTTag_hmtx = 'xtmh', //7
    TTTag_vhea = 'aehv', //8
    TTTag_vmtx = 'xtmv', //9
    TTTag_loca = 'acol', //10

    TTTag_glyf = 'fylg', //11
    TTTag_os2  = '2/SO', //12
    TTTag_ttcf = 'fctt', //13

    TTTag_INVALID = 0xFFFFFFFF
};


class XLTrueType
#if DBG
    : public XLDebug
#endif
{
    SIGNATURE ('xltt')

public:

    XLTrueType::
    XLTrueType(VOID);

    XLTrueType::
    ~XLTrueType(VOID);

    HRESULT OpenTTFile(FONTOBJ *pfo);
    HRESULT CloseTTFile(VOID);

    HRESULT SameFont(FONTOBJ* pfo);

    HRESULT IsTTC(VOID);
    HRESULT IsVertical(VOID);
    HRESULT IsDBCSFont(VOID);
    HRESULT GetHeader(PTTHEADER *pHeader);
    DWORD   GetSizeOfTable(TTTag tag);
    HRESULT GetTableDir(TTTag tag, PVOID *pTable);
    HRESULT GetTable(TTTag tag, PVOID *pTable, PDWORD pdwSize);
    DWORD   GetNumOfTag(VOID);
    HRESULT TagAndID(DWORD *pdwID, TTTag *ptag);
    HRESULT GetGlyphData(HGLYPH hGlyph, PBYTE *ppubGlyphData, PDWORD pdwGlyphDataSize);
    HRESULT GetHMTXData(HGLYPH hGlyph, PUSHORT pusAdvanceWidth, PSHORT psLeftSideBearing);
    HRESULT GetVMTXData(HGLYPH hGlyph, PUSHORT pusAdvanceWidth, PSHORT psTopSideBearing, PSHORT psLeftSideBearing);
    HRESULT GetTypoDescender(VOID);

#if DBG
     VOID SetDbgLevel(DWORD dwLevel);
#endif

private:
    DWORD m_dwFlags;
    FONTOBJ *m_pfo;
    PVOID m_pTTFile;
    ULONG m_ulFileSize;

    PTTHEADER m_pTTHeader;
    USHORT    m_usNumTables;
    PTTDIR    m_pTTDirHead;

    DWORD     m_dwNumTag;
    DWORD     m_dwNumGlyph;
    PTTDIR    m_pTTDir[TagID_MAX];

    DWORD     m_dwNumOfHMetrics;
    DWORD     m_dwNumOfVMetrics;

    HRESULT ParseTTDir(VOID);
};

//
// XLTrueType.m_dwFlags
//
#define XLTT_TTC                 0x00000001        // Font is TTC.
#define XLTT_SHORT_OFFSET_TO_LOC 0x00000002        // Short offset to loca table
#define XLTT_VERTICAL_FONT       0x00000004        // Font is a vertial font.

#define XLTT_DIR_PARSED          0x80000000        // The table directory is
                                                   // parsed.
#endif // _XLTT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\unidrv2\vector\pclxl\xlvminit.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

        xlvminit.h

Abstract:

        Declaration of functions that this plugin supports. 
        (look in vectorif.h) 

Environment:

        Windows 2000

Revision History:

        02/29/00 -hsingh-
            Created

        03/23/00 
            Modified for PCL XL

--*/


#ifndef _XLVMINIT_H_
#define _XLVMINIT_H_

#include "vectorc.h"

// extern interface declarations
#ifdef __cplusplus
extern "C" {
#endif




    //
    // Part. 1
    // Functions listed in oemkm.h
    //
        BOOL APIENTRY
        PCLXLDriverDMS(
                PVOID   pdevobj,
                PVOID   pvBuffer,
                DWORD   cbSize,
                PDWORD  pcbNeeded
                );

        INT APIENTRY
        PCLXLCommandCallback(
                PDEVOBJ pdevobj,
                DWORD   dwCmdCbID,
                DWORD   dwCount,
                PDWORD  pdwParams
                );

        LONG APIENTRY
        PCLXLImageProcessing(
                PDEVOBJ             pdevobj,
                PBYTE               pSrcBitmap,
                PBITMAPINFOHEADER   pBitmapInfoHeader,
                PBYTE               pColorTable,
                DWORD               dwCallbackID,
                PIPPARAMS           pIPParams,
                OUT PBYTE           *ppbResult
                );

        LONG APIENTRY
        PCLXLFilterGraphics(
                PDEVOBJ     pdevobj,
                PBYTE       pBuf,
                DWORD       dwLen
                );

        
        LONG APIENTRY
        PCLXLCompression(
                PDEVOBJ     pdevobj,
                PBYTE       pInBuf,
                PBYTE       pOutBuf,
                DWORD       dwInLen,
                DWORD       dwOutLen,
                INT     *piResult
                );

        LONG APIENTRY
        PCLXLHalftonePattern(
                PDEVOBJ     pdevobj,
                PBYTE       pHTPattern,
                DWORD       dwHTPatternX,
                DWORD       dwHTPatternY,
                DWORD       dwHTNumPatterns,
                DWORD       dwCallbackID,
                PBYTE       pResource,
                DWORD       dwResourceSize
                );


        LONG APIENTRY
        PCLXLMemoryUsage(
                PDEVOBJ         pdevobj,
                POEMMEMORYUSAGE pMemoryUsage
                );

        LONG APIENTRY
        PCLXLTTYGetInfo(
                PDEVOBJ     pdevobj,
                DWORD       dwInfoIndex,
                PVOID       pOutputBuf,
                DWORD       dwSize,
                DWORD       *pcbcNeeded
                );

        LONG APIENTRY
        PCLXLDownloadFontHeader(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                OUT DWORD   *pdwResult
                );

        LONG APIENTRY
        PCLXLDownloadCharGlyph(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                HGLYPH      hGlyph,
                PDWORD      pdwWidth,
                OUT DWORD   *pdwResult
                );

        LONG APIENTRY
        PCLXLTTDownloadMethod(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                OUT DWORD   *pdwResult
                );

        LONG APIENTRY
        PCLXLOutputCharStr(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                DWORD       dwType,
                DWORD       dwCount,
                PVOID       pGlyph
                );

        
        LONG APIENTRY
        PCLXLSendFontCmd(
                PDEVOBJ      pdevobj,
                PUNIFONTOBJ  pUFObj,
                PFINVOCATION pFInv
                );

        BOOL APIENTRY
        PCLXLTextOutAsBitmap(
                SURFOBJ    *pso,
                STROBJ     *pstro,
                FONTOBJ    *pfo,
                CLIPOBJ    *pco,
                RECTL      *prclExtra,
                RECTL      *prclOpaque,
                BRUSHOBJ   *pboFore,
                BRUSHOBJ   *pboOpaque,
                POINTL     *pptlOrg,
                MIX         mix
                );

    //
    // Part 2.
    // Functions listed in enable.c
    // The order of functions listed is same as the order in 
    // static DRVFN UniDriverFuncs[]  in unidrv2\control\enable.c
    //
        PDEVOEM APIENTRY
        PCLXLEnablePDEV(
                PDEVOBJ   pdevobj,
                PWSTR     pPrinterName,
                ULONG     cPatterns,
                HSURF    *phsurfPatterns,
                ULONG     cjGdiInfo,
                GDIINFO  *pGdiInfo,
                ULONG     cjDevInfo,
                DEVINFO  *pDevInfo,
                DRVENABLEDATA  *pded
                );

        BOOL APIENTRY
        PCLXLResetPDEV(
                PDEVOBJ  pPDevOld,
                PDEVOBJ  pPDevNew
                );

        VOID APIENTRY
        PCLXLCompletePDEV(
                DHPDEV  dhpdev,
                HDEV    hdev
                );

        VOID APIENTRY
        PCLXLDisablePDEV(
                PDEVOBJ pPDev
                );

        BOOL APIENTRY
        PCLXLEnableSurface(
                PDEVOBJ pPDev
                );

        VOID APIENTRY
        PCLXLDisableSurface(
                PDEVOBJ pPDev
                );

        VOID APIENTRY
        PCLXLDisableDriver(
                VOID
                );

        BOOL APIENTRY
        PCLXLStartDoc(
                SURFOBJ *pso,
                PWSTR   pDocName,
                DWORD   jobId
                );

        BOOL APIENTRY
        PCLXLStartPage(
                SURFOBJ *pso
                );

        BOOL APIENTRY
        PCLXLSendPage(
                SURFOBJ *pso
                );

        BOOL APIENTRY
        PCLXLEndDoc(
                SURFOBJ *pso,
                FLONG   flags
                );

        BOOL APIENTRY
        PCLXLStartBanding(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL APIENTRY
        PCLXLNextBand(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL APIENTRY
        PCLXLPaint(
                SURFOBJ         *pso,
                CLIPOBJ         *pco,
                BRUSHOBJ        *pbo,
                POINTL          *pptlBrushOrg,
                MIX             mix
                );

        BOOL APIENTRY
        PCLXLBitBlt(
                SURFOBJ    *psoTrg,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclTrg,
                POINTL     *pptlSrc,
                POINTL     *pptlMask,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrush,
                ROP4        rop4
                );

        BOOL APIENTRY
        PCLXLStretchBlt(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode
                );

        BOOL APIENTRY
        PCLXLStretchBltROP(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode,
                BRUSHOBJ   *pbo,
                DWORD       rop4
                );

        BOOL APIENTRY
        PCLXLPlgBlt(
                SURFOBJ         *psoDst,
                SURFOBJ         *psoSrc,
                SURFOBJ         *psoMask,
                CLIPOBJ         *pco,
                XLATEOBJ        *pxlo,
                COLORADJUSTMENT *pca,
                POINTL          *pptlBrushOrg,
                POINTFIX        *pptfixDest,
                RECTL           *prclSrc,
                POINTL          *pptlMask,
                ULONG           iMode
                );

        BOOL APIENTRY
        PCLXLCopyBits(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDst,
                POINTL     *pptlSrc
                );

        ULONG APIENTRY
        PCLXLDitherColor(
                DHPDEV  dhpdev,
                ULONG   iMode,
                ULONG   rgbColor,
                ULONG  *pulDither
                );

        BOOL APIENTRY
        PCLXLRealizeBrush(
                BRUSHOBJ   *pbo,
                SURFOBJ    *psoTarget,
                SURFOBJ    *psoPattern,
                SURFOBJ    *psoMask,
                XLATEOBJ   *pxlo,
                ULONG       iHatch
                );

        BOOL  APIENTRY
        PCLXLLineTo(
                SURFOBJ    *pso,
                CLIPOBJ    *pco,
                BRUSHOBJ   *pbo,
                LONG        x1,
                LONG        y1,
                LONG        x2,
                LONG        y2,
                RECTL      *prclBounds,
                MIX         mix
                );
        
        BOOL APIENTRY
        PCLXLStrokePath(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                XFORMOBJ   *pxo,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrushOrg,
                LINEATTRS  *plineattrs,
                MIX         mix
                );
        
        BOOL APIENTRY
        PCLXLFillPath(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrushOrg,
                MIX         mix,
                FLONG       flOptions 
                );
        
        BOOL APIENTRY
        PCLXLStrokeAndFillPath(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                XFORMOBJ   *pxo,
                BRUSHOBJ   *pboStroke,
                LINEATTRS  *plineattrs,
                BRUSHOBJ   *pboFill,
                POINTL     *pptlBrushOrg,
                MIX         mixFill,
                FLONG       flOptions
                );
        
        BOOL APIENTRY
        PCLXLGradientFill(
                SURFOBJ    *psoDest,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                TRIVERTEX  *pVertex,
                ULONG       nVertex,
                PVOID       pMesh,
                ULONG       nMesh,
                RECTL      *prclExtents,
                POINTL     *pptlDitherOrg,
                ULONG       ulMode
                );

        BOOL APIENTRY
        PCLXLAlphaBlend(
                SURFOBJ    *psoDest,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDest,
                RECTL      *prclSrc,
                BLENDOBJ   *pBlendObj
                );

        BOOL APIENTRY
        PCLXLTransparentBlt(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                ULONG      iTransColor,
                ULONG      ulReserved
                );

        BOOL APIENTRY
        PCLXLTextOut(
                SURFOBJ    *pso,
                STROBJ     *pstro,
                FONTOBJ    *pfo,
                CLIPOBJ    *pco,
                RECTL      *prclExtra,
                RECTL      *prclOpaque,
                BRUSHOBJ   *pboFore,
                BRUSHOBJ   *pboOpaque,
                POINTL     *pptlOrg,
                MIX         mix
                );

        ULONG APIENTRY
        PCLXLEscape(
                SURFOBJ    *pso,
                ULONG       iEsc,
                ULONG       cjIn,
                PVOID       pvIn,
                ULONG       cjOut,
                PVOID       pvOut
                );

        PIFIMETRICS APIENTRY
        PCLXLQueryFont(
                DHPDEV      dhpdev,
                ULONG       iFile,
                ULONG       iFace,
                ULONG      *pid
                );

        PVOID APIENTRY
        PCLXLQueryFontTree(
                DHPDEV  dhpdev,
                ULONG   iFile,
                ULONG   iFace,
                ULONG   iMode,
                ULONG  *pid 
                );

        LONG APIENTRY
        PCLXLQueryFontData(
                DHPDEV      dhpdev,
                FONTOBJ    *pfo,
                ULONG       iMode,
                HGLYPH      hg,
                GLYPHDATA  *pgd,
                PVOID       pv,
                ULONG       cjSize
                );

        ULONG APIENTRY
        PCLXLGetGlyphMode(
                DHPDEV  dhpdev,
                FONTOBJ *pfo
                );

        ULONG APIENTRY
        PCLXLFontManagement(
                SURFOBJ *pso,
                FONTOBJ *pfo,
                ULONG   iMode,
                ULONG   cjIn,
                PVOID   pvIn,
                ULONG   cjOut,
                PVOID   pvOut
                );

        BOOL APIENTRY
        PCLXLQueryAdvanceWidths(
                DHPDEV  dhpdev,
                FONTOBJ *pfo,
                ULONG   iMode,
                HGLYPH *phg,
                PVOID  *pvWidths,
                ULONG   cGlyphs
                );


#ifdef __cplusplus
}
#endif

#endif  // !_XLVMINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgalloc.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgalloc.cxx

Abstract:

    This file contains a heap implementation that is strictly
    used for internal allocations used by this debug library.
    The concept is to not fill native NT leak detention logs with
    allocations from the debug library.  When the debug library is
    initialized we allocate a single large memory block that the
    library then sub allocated from.

Author:

    Steve Kiraly (SteveKi)  24-May-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgheap.hxx"

/*++

Title:

    DebugLibraryInitializeHeap

Routine Description:

    This routine initialize the internal debug library
    heap.  This routine must be called be for the library
    critical section has been created.

Arguments:

    None

Return Value:

    TRUE debug library heap is initialized
    FALSE debug library heap failed internalization

--*/
BOOL
DEBUG_NS::
DebugLibraryInitializeHeap(
    VOID
    )
{
    //
    // Hold the critical section while we access the heap.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Initialize the debug heap.
    //
    GlobalInternalDebugHeap.Initialize();

    //
    // Return success or failure based on the debug head state.
    //
    return GlobalInternalDebugHeap.Valid();
}

/*++

Title:

    DebugLibraryDestroyHeap

Routine Description:

    This routine releases the internal debug library
    heap.

Arguments:

    None

Return Value:

    TRUE integral debug library heap was destroyed successfully.
    FALSE error occurred releasing the internal debug library heap.

--*/
BOOL
DEBUG_NS::
DebugLibraryDestroyHeap(
    VOID
    )
{
    //
    // Hold the critical section while we access the heap.
    //
    TDebugCriticalSection::TLock CS( GlobalCriticalSection );

    //
    // Destroy the debug heap.
    //
    GlobalInternalDebugHeap.Destroy();

    //
    // Return success or failure based on the debug head state.
    //
    return !GlobalInternalDebugHeap.Valid();
}

/*++

Title:

    DebugLibraryWalkHeap

Routine Description:

    Walks all the allocated nodes in the debug library heap.

Arguments:

    None

Return Value:

    TRUE if heap was walked successfully, FALSE if error occurred.

--*/
BOOL
DEBUG_NS::
DebugLibraryWalkHeap(
    VOID
    )
{
    //
    // Hold the critical section while we access the heap.
    //
    TDebugCriticalSection::TLock CS( GlobalCriticalSection );

    return GlobalInternalDebugHeap.Walk( NULL, NULL );
}

/*++

Title:

    DebugLibraryMalloc

Routine Description:

    Allocates memory from the internal debug library heap.

Arguments:

    Size    - size in bytes of requested memory block.
    pVoid   - pointer to memory block when called by placement new.
    pszFile - file name where allocation was made.
    uLine   - line number in file where allocation was made.

Return Value:

    Pointer to newly allocated block on success,
    NULL if memory failed to be allocated.

--*/
PVOID
DEBUG_NS::
DebugLibraryMalloc(
    IN SIZE_T           Size,
    IN PVOID            pVoid,
    IN LPCTSTR          pszFile,
    IN UINT             uLine
    )
{
    //
    // If we are passed a NULL then we are called from the
    // placement new operator, just return the passed in pointer.
    //
    if (!pVoid)
    {
        //
        // Initialize the debug library, it not already initialized.
        //
        DebugLibraryInitialize();

        //
        // Hold the critical section while we access the heap.
        //
        TDebugCriticalSection::TLock CS(GlobalCriticalSection);

        //
        // Allocate data from the heap.
        //
        pVoid = GlobalInternalDebugHeap.Malloc(Size);
    }

    return pVoid;
}

/*++

Title:

    DebugLibraryFree

Routine Description:

    Release memory which was allocated from the internal debug library heap.

Arguments:

    pData   - pointer to previously allocated memory.

Return Value:

    None

--*/
VOID
DEBUG_NS::
DebugLibraryFree(
    IN PVOID            pData
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access the heap.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Release the heap data.
    //
    GlobalInternalDebugHeap.Free(pData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgcs.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgcs.cxx

Abstract:

    Critical Section class

Author:

    Steve Kiraly (SteveKi)  30-Mar-1997

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgcs.hxx"

TDebugCriticalSection::
TDebugCriticalSection(
    VOID
    ) : m_bValid( FALSE )
{
    Initialize();
}

TDebugCriticalSection::
~TDebugCriticalSection(
    VOID
    )
{
    Release();
}

BOOL
TDebugCriticalSection::
bValid(
    VOID
    ) const
{
    return m_bValid;
}

VOID
TDebugCriticalSection::
Enter(
    VOID
    )
{
    EnterCriticalSection( &m_CriticalSection );
}

VOID
TDebugCriticalSection::
Leave(
    VOID
    )
{
    LeaveCriticalSection( &m_CriticalSection );
}

VOID
TDebugCriticalSection::
Initialize(
    VOID
    )
{
    if (!m_bValid)
    {
        InitializeCriticalSection( &m_CriticalSection );
        m_bValid = TRUE;
    }
}

VOID
TDebugCriticalSection::
Release(
    VOID
    )
{
    if (m_bValid)
    {
        DeleteCriticalSection( &m_CriticalSection );
        m_bValid = FALSE;
    }
}

TDebugCriticalSection::TLock::
TLock(
    TDebugCriticalSection &CriticalSection
    ) : m_CriticalSection( CriticalSection )
{
    m_CriticalSection.Enter();
}

TDebugCriticalSection::TLock::
~TLock(
    VOID
    )
{
    m_CriticalSection.Leave();
}

TDebugCriticalSection::TUnLock::
TUnLock(
    TDebugCriticalSection &CriticalSection
    ) : m_CriticalSection( CriticalSection )
{
    m_CriticalSection.Leave();
}

TDebugCriticalSection::TUnLock::
~TUnLock(
    VOID
    )
{
    m_CriticalSection.Enter();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgcon.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgcon.cxx

Abstract:

    Debug Device Text Console

Author:

    Steve Kiraly (SteveKi)  10-Dec-1995

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgcon.hxx"

//
// Construct the console device.
//
TDebugDeviceConsole::
TDebugDeviceConsole(
    IN LPCTSTR      pszConfiguration,
    IN EDebugType   eDebugType
    ) : TDebugDevice( pszConfiguration, eDebugType ),
        _bValid( FALSE ),
        _hOutputHandle( INVALID_HANDLE_VALUE ),
        _eCharType( kAnsi )
{
    //
    // Get the current character type.
    //
    _eCharType = eGetCharType();

    //
    // If console allocated.
    //
    _bValid = AllocConsole();

    //
    // If valid console created.
    //
    _hOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
}

//
// Release the constructed console.
//
TDebugDeviceConsole::
~TDebugDeviceConsole(
    )
{
    //
    // If console was alocated.
    //
        if( _hOutputHandle )
        {
            FreeConsole();
    }
}

//
// Indicates object validity.
//
BOOL
TDebugDeviceConsole::
bValid(
    VOID
    )
{
    return _hOutputHandle != NULL;
}

//
// Output to the specified device.
//
BOOL
TDebugDeviceConsole::
bOutput (
    IN UINT     uSize,
    IN LPBYTE   pBuffer
    )
{
    BOOL bStatus = FALSE;

    //
    // Only if console was created.
    //
    if( bValid() )
    {
        //
        // Adjust passed in byte cound to a character count.
        //
        if( _eCharType == kUnicode )
        {
            uSize = uSize / sizeof( WCHAR );
        }

        //
        // Write the specified bytes to the console.
        //
        DWORD cbWritten;
        bStatus = WriteConsole( _hOutputHandle,
                                pBuffer,
                                uSize,
                                &cbWritten,
                                NULL );
        //
        // Success only of the specified bytes were written.
        //
        if( !bStatus || cbWritten != uSize )
        {
            bStatus = FALSE;
        }
    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgback.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgback.cxx

Abstract:

    Debug Backtrace Device

Author:

    Steve Kiraly (SteveKi)  16-May-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgloadl.hxx"
#include "dbgimage.hxx"
#include "dbgback.hxx"
#include "dbgreg.hxx"

//
// Construct the backtrace device.
//
TDebugDeviceBacktrace::
TDebugDeviceBacktrace(
    IN LPCTSTR      pszConfiguration,
    IN EDebugType   eDebugType
    ) : TDebugDevice( pszConfiguration, eDebugType ),
        _pDbgImagehlp( NULL ),
        _bValid( FALSE ),
        _pDbgDevice( NULL ),
        _bDisplaySymbols( FALSE )
{
    //
    // Collect andy device arguments.
    //
    CollectDeviceArguments();

    //
    // Create the debug imagehlp object.
    //
    _pDbgImagehlp = INTERNAL_NEW TDebugImagehlp;

    //
    // Set the valid flag.
    //
    _bValid = _pDbgImagehlp && _pDbgImagehlp->bValid();
}

//
// Close the backtrace device.
//
TDebugDeviceBacktrace::
~TDebugDeviceBacktrace(
    )
{
    INTERNAL_DELETE _pDbgImagehlp;
    INTERNAL_DELETE _pDbgDevice;
}

//
// Indicates the deveice object is valid.
//
BOOL
TDebugDeviceBacktrace::
bValid(
    VOID
    )
{
    return _bValid;
}

//
// Output the string to the backtrace device
//
BOOL
TDebugDeviceBacktrace::
bOutput(
    IN UINT     uSize,
    IN LPBYTE   pBuffer
    )
{
    //
    // Is the class in a good state and we have an output device.
    //
    BOOL bRetval = bValid() && _pDbgDevice;

    if( bRetval )
    {
        //
        // Send the string to the output device.
        //
        bRetval = _pDbgDevice->bOutput( uSize, pBuffer );

        if( bRetval )
        {
            PVOID   apvBacktrace[kMaxDepth];
            ULONG   uCount = 0;

            memset( apvBacktrace, 0, sizeof( apvBacktrace ) );

            //
            // Capture the current backtrace skiping the call stack of this class
            //
            bRetval = _pDbgImagehlp->bCaptureBacktrace( 3, kMaxDepth, apvBacktrace, &uCount );

            if( bRetval )
            {
                //
                // Send the backtrace to the output device.
                //
                bRetval = OutputBacktrace( uCount, apvBacktrace );
            }
        }
    }
    return bRetval;
}

//
// Send the backtrace to the output device.
//
BOOL
TDebugDeviceBacktrace::
OutputBacktrace(
    IN UINT     uCount,
    IN PVOID    *apvBacktrace
    )
{
    TCHAR   szBuffer [kMaxSymbolName];
    BOOL    bRetval = FALSE;
    LPCTSTR pszFmt  = NULL;

    for( UINT i = 0; i < uCount && apvBacktrace[i]; i++ )
    {
        if( _bDisplaySymbols )
        {
            bRetval = _pDbgImagehlp->ResolveAddressToSymbol( apvBacktrace[i],
                                                             szBuffer,
                                                             COUNTOF( szBuffer ),
                                                             TDebugImagehlp::kUnDecorateName );
        }
        else
        {
            if( i == 0 )
            {
                pszFmt = kstrBacktraceStart;
            }
            else if( !apvBacktrace[i+1] )
            {
                pszFmt = kstrBacktraceEnd;
            }
            else
            {
                pszFmt = kstrBacktraceMiddle;
            }

            bRetval = _sntprintf( szBuffer, COUNTOF(szBuffer), pszFmt, apvBacktrace[i] ) > 0;
        }

        if( bRetval )
        {
            bRetval = _pDbgDevice->bOutput( _tcslen( szBuffer ) * sizeof(TCHAR),
                                            reinterpret_cast<LPBYTE>( szBuffer ) );
        }
    }

    return bRetval;
}

//
// Initialize the specified symbol path.
//
VOID
TDebugDeviceBacktrace::
InitSympath(
    VOID
    )
{
    if( _bDisplaySymbols )
    {
        TDebugString strRegistryPath;

        //
        // Get the base registry path.
        //
        BOOL bRetval = strRegistryPath.bUpdate( kstrSympathRegistryPath );

        if( bRetval )
        {
            TDebugString strProcessName;

            //
            // Get this processes short name.
            //
            bRetval = GetProcessName( strProcessName );

            if( bRetval )
            {
                //
                // Build the registry path Path\processname
                //
                bRetval = strRegistryPath.bCat( kstrSlash ) && strRegistryPath.bCat( strProcessName );

                if( bRetval )
                {
                    //
                    // Open the registry key.
                    //
                    TDebugRegistry Registry( strRegistryPath, TDebugRegistry::kOpen|TDebugRegistry::kRead, HKEY_LOCAL_MACHINE );

                    bRetval = Registry.bValid();

                    if( bRetval )
                    {
                        //
                        // Read the symbol path if there.
                        //
                        bRetval = Registry.bRead( kstrSympathRegistryKey, _strSympath );
                    }
                }
            }
        }

        //
        // If the registry did not specifiy a symbol path then use the
        // default symbol path that imagehlp has.
        //
        if( !bRetval )
        {
            _pDbgImagehlp->GetSymbolPath( _strSympath );
        }
        else
        {
            //
            // Set the symbol path
            //
            _pDbgImagehlp->SetSymbolPath( _strSympath );
        }
    }
}

//
// If we are displaying symbols then as the first line in the output
// device indicate the symbol path.
//
VOID
TDebugDeviceBacktrace::
WriteSympathToOutputDevice(
    VOID
    )
{
    if( _bDisplaySymbols )
    {
        TDebugString strSympath;

        strSympath.bFormat(kstrSympathFormat, _strSympath);

        _pDbgDevice->bOutput(strSympath.uLen() * sizeof(TCHAR),
                             reinterpret_cast<LPBYTE>(
                             const_cast<LPTSTR>(
                             static_cast<LPCTSTR>(
                             strSympath))));
    }
}

//
// Create and the set the output device type.
//
BOOL
TDebugDeviceBacktrace::
InitializeOutputDevice(
    IN UINT     uDevice,
    IN LPCTSTR  pszConfiguration,
    IN UINT     uCharacterType
    )
{
    if( bValid() )
    {
        //
        // Get access to the debug factory.
        //
        TDebugFactory DebugFactory;

        //
        // If we failed to create the debug factory then exit.
        //
        if (DebugFactory.bValid())
        {
            //
            // Release the existing debug device.
            //
            delete _pDbgDevice;

            //
            // Create the specified debug device using the factory.
            //
            _pDbgDevice = DebugFactory.Produce( uDevice, pszConfiguration, uCharacterType );

            //
            // If the debug device was created successfully.
            //
            if( _pDbgDevice )
            {
                //
                // Initialize the sympath
                //
                InitSympath();

                //
                // Write sympath to output device.
                //
                WriteSympathToOutputDevice();
            }
        }
    }

    //
    // Indicate the debug device was created.
    //
    return _pDbgDevice != NULL;
}


//
// Get the device arguments from the configuration string.
//
BOOL
TDebugDeviceBacktrace::
CollectDeviceArguments(
    VOID
    )
{
    TDebugDevice::TIterator i( this );

    for( i.First(); !i.IsDone(); i.Next() )
    {
        switch( i.Index() )
        {
        //
        // Ignore the character type.
        //
        case 1:
            break;

        //
        // The second aregument is the symbol specifier.
        //
        case 2:
            _bDisplaySymbols = !_tcsicmp( kstrSymbols, i.Current() );
            break;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgdbg.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgdbg.cxx

Abstract:

    Debug Device Debugger device

Author:

    Steve Kiraly (SteveKi)  5-Dec-1995

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgdbg.hxx"

/*++

Routine Name:

    DebugDeviceDebugger constructor

Routine Description:

    Initializes the debug device

Arguments:

    Pointer to object defined configuration string

Return Value:

    Nothing

--*/
TDebugDeviceDebugger::
TDebugDeviceDebugger(
    IN LPCTSTR      pszConfiguration,
    IN EDebugType   eDebugType
    ) : TDebugDevice( pszConfiguration, eDebugType ),
        _bAnsi( FALSE )
{
    _bAnsi = eGetCharType() == TDebugDevice::kAnsi;
}

/*++

Routine Name:

    DebugDevice Destructor

Routine Description:

    Removes access to the debug device

Arguments:

    None

Return Value:

    Nothing

--*/
TDebugDeviceDebugger::
~TDebugDeviceDebugger(
        VOID
    )
{
}

/*++

Routine Name:

    Valid Object indicator

Routine Description:


Arguments:


Return Value:


--*/
BOOL
TDebugDeviceDebugger::
bValid(
    VOID
    ) const
{
    return TRUE;
}

/*++

Routine Name:

    DebugDevice output

Routine Description:

    Output the string to the debug device.

Arguments:

    Number of bytes to output, including the null.
    Pointer to zero terminated debug string

Return Value:

    TRUE string output out, FALSE on failure

--*/
BOOL
TDebugDeviceDebugger::
bOutput (
    IN UINT     cbSize,
    IN LPBYTE   pBuffer
    )
{
    BYTE pTemp[256];
    UINT uIndex;

    //
    // OutputDebugString cannot handle strings large then
    // 4k so we do it in chunks.
    //
    for (uIndex = 0; cbSize; cbSize = cbSize - uIndex)
    {
        //
        // The current index is the small of the two either
        // the remaining data or the size of the temp buffer,
        // less the null terminator.
        //
        uIndex = min(sizeof(pTemp) - sizeof(WCHAR), cbSize);

        //
        // Copy the memory, we know it is not overlapping.
        //
        memcpy(pTemp, pBuffer, uIndex);

        //
        // Update the buffer count, and place the null.
        //
        pBuffer = pBuffer + uIndex;
        *(pTemp + uIndex + 0) = 0;
        *(pTemp + uIndex + 1) = 0;

        if (_bAnsi)
        {
            OutputDebugStringA( (LPSTR)pTemp );
        }
        else
        {
            OutputDebugStringW( (LPWSTR)pTemp );
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgdev.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgdev.cxx

Abstract:

    Debug Device Interface class

Author:

    Steve Kiraly (SteveKi)  10-Dec-1995

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgdev.hxx"

/*++

Routine Name:

    TDebugDevice

Routine Description:

    Constructor

Arguments:

    pszConfiguration - pointer to colon separated configuration string.

Return Value:

    Nothing

--*/
TDebugDevice::
TDebugDevice(
        IN LPCTSTR      pszConfiguration,
        IN EDebugType   eDebugType
    ) : _pszConfiguration( NULL ),
        _eCharType( kUnknown ),
        _eDebugType( eDebugType ),
        TDebugNodeDouble()
{
    //
    // If configuration data was provided.
    //
    if( pszConfiguration && _tcslen( pszConfiguration ) )
    {
        _pszConfiguration = INTERNAL_NEW TCHAR [ _tcslen( pszConfiguration ) + 1];

        //
        // Copy the configuration data.
        //
        if( _pszConfiguration )
        {
            _tcscpy( _pszConfiguration, pszConfiguration );

            //
            // Get the character type.
            //
            TIterator i( this );

            for( i.First(); !i.IsDone(); i.Next() )
            {
                //
                // The first item is defined as the character type.
                //
                if( i.Index() == 1 )
                {
                    //
                    // Look for the ansi specifier.
                    //
                    _eCharType = !_tcsicmp( i.Current(), kstrAnsi ) ? kAnsi : kUnicode;
                    break;
                }
            }
        }
    }
}

/*++

Routine Name:

    TDebugDevice

Routine Description:

    Destructor releases the configuration string.

Arguments:

    None.

Return Value:

    Nothing

--*/
TDebugDevice::
~TDebugDevice(
        VOID
    )
{
    INTERNAL_DELETE [] _pszConfiguration;
}

/*++

Routine Name:

    bValid

Routine Description:

    Valid object indicator.

Arguments:

    None.

Return Value:

    Nothing

--*/
BOOL
TDebugDevice::
bValid(
    VOID
    ) const
{
    return TRUE;
}

/*++

Routine Name:

    eGetCharType

Routine Description:

    Retrives the devices character type.

Arguments:

    None.

Return Value:

    Devices character type

--*/
TDebugDevice::ECharType
TDebugDevice::
eGetCharType(
    VOID
    ) const
{
    return _eCharType;
}

/*++

Routine Name:

    eGetDeviceType

Routine Description:

    Retrives the device type.

Arguments:

    None.

Return Value:

    Debug Device Type

--*/
EDebugType
TDebugDevice::
eGetDebugType(
    VOID
    ) const
{
    return _eDebugType;
}

/*++

Routine Name:

    pszGetConfigurationString

Routine Description:

    Retrives the raw devices configuration string.

Arguments:

    None.

Return Value:

    Pointer to device configuration string.

--*/
LPCTSTR
TDebugDevice::
pszGetConfigurationString(
    VOID
    ) const
{
    return _pszConfiguration;
}

/*++

Routine Name:

    MapStringTypeToDevice

Routine Description:

    Map the device string to a device enumeration.

Arguments:

    pszDeviceString - pointer to device type string.

Return Value:

    Device type enumeration

--*/
UINT
TDebugDevice::
MapStringTypeToDevice(
    IN LPCTSTR pszDeviceString
    ) const
{
    DeviceMap aDeviceMap [] = { { kDbgNull,       kstrDeviceNull},
                                { kDbgConsole,    kstrConsole   },
                                { kDbgDebugger,   kstrDebugger  },
                                { kDbgFile,       kstrFile      },
                                { kDbgBackTrace,  kstrBacktrace } };

    for( UINT i = 0; i < COUNTOF( aDeviceMap ); i++ )
    {
        if( !_tcsicmp( aDeviceMap[i].Name, pszDeviceString ) )
        {
            return aDeviceMap[i].Id;
        }
    }

    return kDbgNull;
}

/********************************************************************

 Debug Iterator device class.

********************************************************************/


/*++

Routine Name:

    TIterator

Routine Description:

    Constructor

Arguments:

    pszConfiguration - pointer to colon separated configuration string.

Return Value:

    Nothing

--*/
TDebugDevice::TIterator::
TIterator(
    IN TDebugDevice *DbgDevice
    ) : _pStr( NULL ),
        _pCurrent( NULL ),
        _pEnd( NULL ),
        _bValid( FALSE ),
        _uIndex( 0 )
{
    //
    // Make a copy of the configuration string for iteration.
    // The configuration string is defined as a colon delimited
    // string, the iterator needs a copy because it replaces the
    // colons with nulls for isolating its pieces.
    //
    if( DbgDevice->_pszConfiguration && _tcslen( DbgDevice->_pszConfiguration ) )
    {
        _pStr = INTERNAL_NEW TCHAR [ _tcslen(DbgDevice->_pszConfiguration) + 1 ];

        if( _pStr )
        {
            _tcscpy( _pStr, DbgDevice->_pszConfiguration );
            _bValid = TRUE;
        }
    }
}

/*++

Routine Name:

    TIterator

Routine Description:

    Destructor

Arguments:

    None.

Return Value:

    Nothing

--*/
TDebugDevice::TIterator::
~TIterator(
    VOID
    )
{
    INTERNAL_DELETE [] _pStr;
}

/*++

Routine Name:

    bValid

Routine Description:

    Indicates if this class is valid.

Arguments:

    None.

Return Value:

    TRUE valid, FALSE invalid.

--*/
BOOL
TDebugDevice::TIterator::
bValid(
    VOID
    ) const
{
    return _bValid;
}

/*++

Routine Name:

    First

Routine Description:

    Starts the interator.

Arguments:

    None.

Return Value:

    Nothing

--*/
VOID
TDebugDevice::TIterator::
First(
    VOID
    )
{
    if( !_bValid )
        return;
    //
    // If running iteration was reset with a first call
    // Put back the colon.
    //
    if( _pEnd )
        *_pEnd = _T(':');

    //
    // Reset index.
    //
    _uIndex = 1;

    //
    // Skip leading colons
    //
    for( _pCurrent = _pStr; *_pCurrent && *_pCurrent == _T(':'); _pCurrent++);

    //
    // Search for next colon.
    //
    for( _pEnd = _pCurrent; *_pEnd && *_pEnd != _T(':'); _pEnd++);

    //
    // Place the null to complete the string.
    //
    if( *_pEnd )
        *_pEnd = NULL;
    else
        _pEnd = NULL;

}

/*++

Routine Name:

    Next

Routine Description:

    Advance to the next item.

Arguments:

    None.

Return Value:

    Nothing

--*/
VOID
TDebugDevice::TIterator::
Next(
    VOID
    )
{
    if( !_bValid )
        return;

    //
    // If iteration is pending put back the colon and advance
    // to the next character.
    //
    if( _pEnd )
    {
        *_pEnd = _T(':');
        _pEnd++;
    }
    else
    {
        //
        // End iteration, defined as _pCurrent == _pEnd == NULL
        //
        _pCurrent = _pEnd;
        return;
    }

    //
    // Update current.
    //
    _pCurrent = _pEnd;

    //
    // Skip leading colons
    //
    for( ; *_pCurrent && *_pCurrent == _T(':'); _pCurrent++);

    //
    // Advance to the end of the current item.
    //
    for( _pEnd = _pCurrent; *_pEnd && *_pEnd != _T(':'); _pEnd++);

    //
    // Replace colon with a null
    //
    if( *_pEnd )
        *_pEnd = NULL;
    else
        _pEnd = NULL;

    _uIndex++;
}

/*++

Routine Name:

    IsDone

Routine Description:

    Indicates if there are any more items.

Arguments:

    None.

Return Value:

    TRUE no mote items, FALSE more items availabe.

--*/
BOOL
TDebugDevice::TIterator::
IsDone(
    VOID
    ) const
{
    if( !_bValid )
        return TRUE;

    if( _pCurrent == NULL && _pEnd == NULL )
        return TRUE;

    return FALSE;

}

/*++

Routine Name:

    Current

Routine Description:

    Returns pointer to current item.

Arguments:

    None.

Return Value:

    Pointer to item.  NULL if no more items, or error.

--*/
LPCTSTR
TDebugDevice::TIterator::
Current(
    VOID
    ) const
{
    if( !_bValid )
        return NULL;

    return _pCurrent;
}

/*++

Routine Name:

    Index

Routine Description:

    Returns current item index.

Arguments:

    None.

Return Value:

    Index starting with 1 to N

--*/
UINT
TDebugDevice::TIterator::
Index(
    VOID
    ) const
{
    if( !_bValid )
        return 0;

    return _uIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgcstr.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgreg.cxx

Abstract:

    Debug Constant Strings.

Author:

    Steve Kiraly (SteveKi)  19-Jun-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgcstr.hxx"

DEBUG_NS_BEGIN

LPCTSTR kstrAnsi                    = _T("ansi");
LPCTSTR kstrUnicode                 = _T("unicode");
LPCTSTR kstrPrefix                  = _T("Debug");
LPCTSTR kstrDefault                 = _T("Debug");
LPCTSTR kstrNull                    = _T("");
LPCTSTR kstrDefaultLogFileName      = _T("debug.log");
LPCTSTR kstrNewLine                 = _T("\n");
LPCTSTR kstrSlash                   = _T("\\");
LPCTSTR kstrSeparator               = _T(":");
LPCTSTR kstrSymbols                 = _T("symbols");
LPCTSTR kstrDeviceNull              = _T("null");
LPCTSTR kstrConsole                 = _T("console");
LPCTSTR kstrDebugger                = _T("debugger");
LPCTSTR kstrFile                    = _T("file");
LPCTSTR kstrBacktrace               = _T("backtrace");
LPCTSTR kstrSympathRegistryPath     = _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options");
LPCTSTR kstrSympathRegistryKey      = _T("Sympath");
LPCTSTR kstrSympathFormat           = _T("Capture: Sympath %s\n");
LPCTSTR kstrBacktraceStart          = _T("++%x\n");
LPCTSTR kstrBacktraceEnd            = _T("--%x\n");
LPCTSTR kstrBacktraceMiddle         = _T("  %x\n");
LPCTSTR kstrFileInfoFormat          = _T(" %s %d");
LPCTSTR kstrTimeStampFormatShort    = _T(" tc=%x");
LPCTSTR kstrTimeStampFormatLong     = _T(" time=%s");
LPCTSTR kstrThreadIdFormat          = _T(" tid=%x");

DEBUG_NS_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgcap.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgcap.cxx

Abstract:

    Debug capture class

Author:

    Steve Kiraly (SteveKi)  18-Jun-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgback.hxx"
#include "dbgcap.hxx"

/*++

Title:

    TDebugCapture_Create

Routine Description:

    Creates a debug capture object, and returns the newly created
    caputure device handle.

Arguments:

    pszConfiguration    - pointe to backtrace configuration string.
    uOutputDevice       - what device to send the backtrace to.
    pszOutputDeviceConfiguration - pointer to output device configuration
                          string.

Return Value:

    Non null handle if successfull, NULL on failure.

--*/
extern "C"
HANDLE
TDebugCapture_Create(
    IN LPCTSTR  pszCaptureDeviceConfiguration,
    IN UINT     uOutputDevice,
    IN LPCTSTR  pszOutputDeviceConfiguration
    )
{
    HANDLE hHandle = NULL;

    //
    // The output device cannot be another back trace device.
    //
    if (uOutputDevice != kDbgBackTrace)
    {
        //
        // Get access to the debug factory.
        //
        TDebugFactory DebugFactory;

        //
        // If we failed to create the debug factory then exit.
        //
        if (DebugFactory.bValid())
        {
            TDebugDeviceBacktrace *pBackTrace = NULL;

            //
            // CAUTION:  We are down casting, however, we know this is
            // safe since the factory was told produce a product of a
            // particular kind.
            //
            // Create the specified debug device using the factory.
            //
            pBackTrace = reinterpret_cast<TDebugDeviceBacktrace *>(DebugFactory.Produce(kDbgBackTrace,
                                                                   pszCaptureDeviceConfiguration,
                                                                   Globals.CompiledCharType));


            //
            // If the backtrace device was create successfully.
            //
            if (pBackTrace)
            {
                //
                // Initialize the output device.
                //
                pBackTrace->InitializeOutputDevice(uOutputDevice,
                                                   pszOutputDeviceConfiguration,
                                                   Globals.CompiledCharType);

                //
                // Return a opaque handle.
                //
                hHandle = pBackTrace;
            }

        }
    }
    return hHandle;
}

/*++

Title:

    TDebugCapture_Destroy

Routine Description:

    Destroys the capture device.

Arguments:

    hHandle - opaque handle to backtrace device.

Return Value:

    NULL

--*/
extern "C"
HANDLE
TDebugCapture_Destroy(
    IN HANDLE hHandle
    )
{
    TDebugFactory::Dispose(reinterpret_cast<TDebugDevice *>(hHandle));
    return NULL;
}


/*++

Title:

    TDebugCapture_Capture

Routine Description:

    This routine output a format string to the pre configured
    output device then captures a stack back, also sending the
    output to the pre configured output device.

Arguments:

    hHandle - handle to instance of capture device.
    uFlags  - must be 0 not defined.
    pszFile - pointer to string where call was made.
    uLine   - line number in file where call was made.
    pszCapture - pointer to post formated capture string.

Return Value:

    Nothing.

--*/
extern "C"
VOID
TDebugCapture_Capture(
    IN HANDLE   hHandle,
    IN UINT     uFlags,
    IN LPCTSTR  pszFile,
    IN UINT     uLine,
    IN LPTSTR   pszCapture
    )
{
    TDebugString strCapture;

    //
    // Format the pre-capture string.
    //
    BOOL bRetval = strCapture.bFormat(_T("Capture: %s %d tc=%x tid=%x %s"),
                                      StripPathFromFileName(pszFile),
                                      uLine,
                                      GetTickCount(),
                                      GetCurrentThreadId(),
                                      pszCapture ? pszCapture : kstrNull);

    //
    // If the capture string was formated.
    //
    if (bRetval)
    {
        //
        // Hold the critical section while we capture the backtrace.
        //
        TDebugCriticalSection::TLock CS( GlobalCriticalSection );

        TDebugDeviceBacktrace *pBackTrace = reinterpret_cast<TDebugDeviceBacktrace *>(hHandle);

        LPBYTE pData = reinterpret_cast<LPBYTE>(const_cast<LPTSTR>(
                                                static_cast<LPCTSTR>(strCapture)));

        bRetval = pBackTrace->bOutput(strCapture.uLen() * sizeof(TCHAR), pData);

    }

    //
    // Release the capture string, if the passed in one was valid.
    //
    INTERNAL_DELETE [] pszCapture;
}

/*++

Title:

    TDebugCapture_pszFmt

Routine Description:

    Creates a output string from a printf style format
    string and argument list.

Arguments:

    pszFmt - pointer to printf style format string.
    ...    - variable number of arguments.

Return Value:

    Pointer to output string, caller must free.

--*/
LPTSTR
TDebugCapture_pszFmt(
    IN LPCSTR pszFmt,
    IN ...
    )
{
    va_list pArgs;

    va_start(pArgs, pszFmt);

    LPTSTR pszString = TDebugCapture_pszFmt_Helper(pszFmt, pArgs, FALSE);

    va_end(pArgs);

    return pszString;
}

/*++

Title:

    TDebugCapture_pszFmt

Routine Description:

    Creates a output string from a printf style format
    string and argument list.

Arguments:

    pszFmt - pointer to printf style format string.
    ...    - variable number of arguments.

Return Value:

    Pointer to output string, caller must free.

--*/
LPTSTR
TDebugCapture_pszFmt(
    IN LPCWSTR pszFmt,
    IN ...
    )
{
    va_list pArgs;

    va_start(pArgs, pszFmt);

    LPTSTR pszString = TDebugCapture_pszFmt_Helper(pszFmt, pArgs, TRUE);

    va_end(pArgs);

    return pszString;
}

/*++

Title:

    TDebugCapture_pszFmt

Routine Description:

    Creates a output string from a printf style format
    string and argument list.

Arguments:

    pszFmt - pointer to printf style format string.
    ...    - variable number of arguments.

Return Value:

    Pointer to output string, caller must free.

--*/
extern "C"
LPTSTR
WINAPIV
TDebugCapture_pszFmtA(
    IN LPCSTR pszFmt,
    IN ...
    )
{
    va_list pArgs;

    va_start(pArgs, pszFmt);

    LPTSTR pszString = TDebugCapture_pszFmt_Helper(pszFmt, pArgs, FALSE);

    va_end(pArgs);

    return pszString;
}

/*++

Title:

    TDebugCapture_pszFmt

Routine Description:

    Creates a output string from a printf style format
    string and argument list.

Arguments:

    pszFmt - pointer to printf style format string.
    ...    - variable number of arguments.

Return Value:

    Pointer to output string, caller must free.

--*/
extern "C"
LPTSTR
WINAPIV
TDebugCapture_pszFmtW(
    IN LPCWSTR pszFmt,
    IN ...
    )
{
    va_list pArgs;

    va_start(pArgs, pszFmt);

    LPTSTR pszString = TDebugCapture_pszFmt_Helper(pszFmt, pArgs, TRUE);

    va_end(pArgs);

    return pszString;
}


/*++

Title:

    TDebugCapture_pszFmt_Helper

Routine Description:

    Creates a output string from a printf style format
    string and pointer to argument list.

Arguments:

    pszFmt - pointer to printf style format string.
    pArgs  - pointer to variable number of arguments.
    bUnicode - Flag indicating the provided string is unicode or ansi.

Return Value:

    Pointer to output string, caller must free.

--*/
LPTSTR
TDebugCapture_pszFmt_Helper(
    IN const    VOID    *pszFmt,
    IN          va_list  pArgs,
    IN          BOOL     bUnicode
    )
{
    LPTSTR  pString     = NULL;
    PVOID   pszResult   = NULL;

    if (pszFmt)
    {
        if (bUnicode)
        {
            pszResult = vFormatW(reinterpret_cast<LPCWSTR>(pszFmt), pArgs);
        }
        else
        {
            pszResult = vFormatA(reinterpret_cast<LPCSTR>(pszFmt), pArgs);
        }

        if (pszResult)
        {
            if (bUnicode)
            {
                (VOID)StringW2T(&pString, reinterpret_cast<LPWSTR>(pszResult));
            }
            else
            {
                (VOID)StringA2T(&pString, reinterpret_cast<LPSTR>(pszResult));
            }

            INTERNAL_DELETE [] pszResult;
        }
    }
    return pString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbggbl.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbggbl.cxx

Abstract:

    Debug Library Globals

Author:

    Steve Kiraly (SteveKi)  24-May-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

DEBUG_NS_BEGIN

TDebugCriticalSection   GlobalCriticalSection;
TDebugHeap              GlobalInternalDebugHeap;
TDebugLibarayGlobals    Globals = {2, 0, 0, 0, 0, 0, kDbgCompileType};

DEBUG_NS_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgfil.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgfil.cxx

Abstract:

    Debug Device File

Author:

    Steve Kiraly (SteveKi)  10-Dec-1995

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgfil.hxx"

//
// Construct the file device.
//
// pszConfiguration - contains the file name to open.
//
TDebugDeviceFile::
TDebugDeviceFile(
    IN LPCTSTR      pszConfiguration,
    IN EDebugType   eDebugType
    ) : TDebugDevice( pszConfiguration, eDebugType ),
        _hFile( INVALID_HANDLE_VALUE )
{
    TDebugDevice::TIterator i( this );

    for( i.First(); !i.IsDone(); i.Next() )
    {
        //
        // First item always contains the character type.
        // We want the second item which is the file name.
        //
        if( i.Index() == 2 )
        {
            //
            // Look for the file specifier.
            //
            _strFile.bUpdate( i.Current() );
            break;
        }
    }
}

//
// Close the file device.
//
TDebugDeviceFile::
~TDebugDeviceFile(
    )
{
    if( _hFile && _hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( _hFile );
    }
}

//
// Indicates the file deveice object is valid.
//
BOOL
TDebugDeviceFile::
bValid(
    VOID
    )
{
    return _strFile.bValid();
}

//
// Output the string to the debug file device
//
BOOL
TDebugDeviceFile::
bOutput (
    IN UINT uSize,
    IN LPBYTE pBuffer
    )
{
    BOOL bStatus = FALSE;

    if( bValid( ) )
    {
        //
        // Is eth file currently open, we delay this to the
        // very last momemt.
        //
        if( _hFile == INVALID_HANDLE_VALUE )
        {
            _hFile = OpenOutputFile();
        }

        if( _hFile )
        {
            //
            // Write the bytes to the file.
            //
            DWORD dwBytesWritten;
            bStatus = WriteFile( _hFile,
                                 pBuffer,
                                 uSize,
                                 &dwBytesWritten,
                                 NULL );

            //
            // If the write failed or the number of bytes
            // written did not match the request.
            //
            if( !bStatus || uSize != dwBytesWritten )
            {
                bStatus = FALSE;
            }
        }
    }

    return bStatus;
}

//
// Open the output file.
//
HANDLE
TDebugDeviceFile::
OpenOutputFile(
    VOID
    )
{
    //
    // Create the file.
    //
    HANDLE hFile = CreateFile( _strFile,
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                               NULL );

    //
    // If the file was not created, invalidate the handle.
    //
    if( hFile == INVALID_HANDLE_VALUE )
    {
        hFile = NULL;
    }

    return hFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgheap.cxx ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgheap.cxx

Abstract:

    Debug heap

Author:

    Steve Kiraly (SteveKi)  6-Feb-1999

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgheap.hxx"

/*++

Title:

    Constructor

Routine Description:

    This routine only initialize class variables, you must
    call Initialize before the class is in a usable state.

Arguments:

    None.

Return Value:

    None.

--*/
TDebugHeap::
TDebugHeap(
    VOID
    )
{
}

/*++

Title:

    Destructor

Routine Description:

    Class destructor, you must call Destroy to relase this class.

Arguments:

    None

Return Value:

    None

--*/
TDebugHeap::
~TDebugHeap(
    VOID
    )
{
}

/*++

Title:

    bValid

Routine Description:

    Use this method to determin if the heap is usable.

Arguments:

    None.

Return Value:

    TRUE class is valid i.e. usable, FALSE class not usable.

--*/
BOOL
TDebugHeap::
Valid(
    VOID
    ) const
{
    return m_bValid;
}

/*++

Title:

    Initialize

Routine Description:

    Initialize the heap, the bValid method should be called
    after this method to determine if the heap is in a usable
    state.

Arguments:

    None

Return Value:

    None

--*/
VOID
TDebugHeap::
Initialize(
    VOID
    )
{
    //
    // Initalize the call members.
    //
    InitalizeClassMembers();

    //
    // Create the debug heap.
    //
    m_hHeap = HeapCreate( HEAP_NO_SERIALIZE, m_uSize, 0 );

    if (m_hHeap)
    {
        //
        // Allocation the initial heap.
        //
        m_pHeap = reinterpret_cast<BlockHeader *>( HeapAlloc( m_hHeap, 0, m_uSize ) );

        if (m_pHeap)
        {
            //
            // Initialize any needed heap variables.
            //
            m_pHeap->pNext    = NULL;
            m_pHeap->uSize    = m_uSize - sizeof( BlockHeader );
            m_pHeap->eStatus  = kFree;
            m_bValid          = TRUE;
        }
        else
        {
            //
            // Error occurred cleanup.
            //
            Destroy();
        }
    }
}

/*++

Title:

    Destroy

Routine Description:

    Release any resources for the heap.

Arguments:

    None

Return Value:

    None

--*/
VOID
TDebugHeap::
Destroy(
    VOID
    )
{
    //
    // Destroy the heap if it was allocated.
    //
    if (m_hHeap)
    {
        //
        // Destroy the heap data.
        //
        HeapDestroy( m_hHeap );
    }

    //
    // Clear the heap variables.
    //
    InitalizeClassMembers();
}


/*++

Title:

    Malloc

Routine Description:

    Allocate a new block of memory.

Arguments:

    Size - size in bytes of the requested block to allocate

Return Value:

    Pointer to newly allocated block is success, NULL on failure

--*/
PVOID
TDebugHeap::
Malloc(
    IN SIZE_T   uSize
    )
{
    BlockHeader *pBlock = NULL;

    //
    // Ignore zero size requests.
    //
    if (uSize)
    {
        //
        // Round up to some reasonable even value.
        //
        uSize = RoundUpToGranularity( uSize );

        //
        // Find first block that can hold the required size. Coalesce the
        // blocks as the chain is traversed.
        //
        for (pBlock = reinterpret_cast<BlockHeader *>( m_pHeap ); pBlock; pBlock = pBlock->pNext)
        {
            if (pBlock->eStatus == kFree)
            {
                //
                // Coalesce the blocks as we look for an appropriate block.
                //
                Coalesce( pBlock );

                //
                // Found a big enough block
                //
                if (pBlock->uSize >= uSize)
                {
                    break;
                }
            }
        }

        //
        // Check for failure
        //
        if (pBlock)
        {
            //
            // Split the block, if possible
            //
            SplitBlock( pBlock, uSize );

            //
            // Mark the block as in use.
            //
            pBlock->eStatus  = kInUse;

            //
            // Return the appropriate pointer
            //
            pBlock++;
        }
        else
        {
            ErrorText( _T("Error: Unabled to allocate memory, size %d.\n"), uSize );
        }
    }

    return pBlock;
}

/*++

Title:

    Free

Routine Description:

    Delete the block of memory.

Arguments:

    pData   - pointer to data to free

Return Value:

    None

--*/
VOID
TDebugHeap::
Free(
    IN PVOID pData
    )
{
    //
    // Ignore null pointer.
    //
    if (pData)
    {
        //
        // Back up to start of the header
        //
        BlockHeader *pBlock = reinterpret_cast<BlockHeader *>( pData ) - 1;

        //
        // Free the block if not already free.
        //
        if (pBlock >= m_pHeap && pBlock <= m_pHeap + m_uSize && pBlock->eStatus == kInUse)
        {
            //
            // Mark the block as freed.
            //
            pBlock->eStatus = kFree;
        }
        else
        {
            ErrorText( _T("Error: Invalid or free block passed to free 0x%lx.\n"), pBlock );
        }
    }
}

/********************************************************************

    Private member functions.

********************************************************************/

/*++

Title:

    SplitBlock

Routine Description:

    Take the current block and attempt to split it into two.

Arguments:

    pBlockHeader    - pointer to memory block header
    Size            - size of requested block

Return Value:

    None

--*/
VOID
TDebugHeap::
SplitBlock(
    IN BlockHeader *pBlock,
    IN SIZE_T       uSize
    )
{
    if (pBlock->uSize >= (uSize + sizeof(BlockHeader)))
    {
        BlockHeader *pNext;

        //
        // Split the block into two the size requested and the remainder.
        //
        pNext = reinterpret_cast<BlockHeader *>( (reinterpret_cast<PBYTE>( pBlock ) + uSize + sizeof(BlockHeader)) );
        pNext->pNext = pBlock->pNext;
        pNext->uSize = pBlock->uSize - uSize - sizeof(BlockHeader);

        //
        // Can only split off FREE blocks
        //
        pNext->eStatus  = kFree;
        pBlock->pNext   = pNext;
        pBlock->uSize   = uSize;
    }
}

/*++

Title:

    Coalesce

Routine Description:

    Take and collapse any adjacent blocks.

Arguments:

    pBlock  - pointer to memory block header

Return Value:

    None

--*/
VOID
TDebugHeap::
Coalesce(
    IN BlockHeader *pBlock
    )
{
    //
    // Check for null pointers
    //
    if (pBlock)
    {
        //
        // The next block can be tacked onto the end of the current
        //
        for (BlockHeader *pNext = pBlock->pNext; pNext && pNext->eStatus == kFree; pNext = pBlock->pNext)
        {
            //
            // Remove from the chain
            //
            pBlock->pNext = pNext->pNext;

            //
            // Absorb its storage
            //
            pBlock->uSize += pNext->uSize + sizeof( BlockHeader );
        }
    }
}

/*++

Title:

    WalkDebugHeap

Routine Description:

    Walk the heap list.

Arguments:

    pEnumProc       - pointer function to call at each block
    pRefDate        - caller defined reference data

Return Value:

    Always returns TRUE success.

--*/
BOOL
TDebugHeap::
Walk(
    IN pfHeapEnumProc   pEnumProc,
    IN PVOID            pRefData
    )
{
    //
    // If an enumerator was not passed then use the default.
    //
    if (!pEnumProc)
    {
        pEnumProc = DefaultHeapEnumProc;
    }

    BlockHeader *pBlock = reinterpret_cast<BlockHeader *>( m_pHeap );

    //
    // Coalesce before we walk to decrease free block spew.
    //
    Coalesce( pBlock );

    //
    // If we only have one free bock then the heap is empty
    // then just skip the walk.
    //
    if( pBlock->pNext || pBlock->eStatus != kFree )
    {
        //
        // Display the interal heap summary information
        //
        ErrorText( _T("Internal Heap Information:\n") );
        ErrorText( _T("\tHandle         : 0x%lx\n"),    m_hHeap );
        ErrorText( _T("\tStarting Block : 0x%lx\n"),    m_pHeap );
        ErrorText( _T("\tHeap Size      : %d bytes\n"), m_uSize );
        ErrorText( _T("\tGranularity    : %d bytes\n"), m_uGranularity );
        ErrorText( _T("Internal Heap Entries:\n") );

        //
        // Point to the first block in the heap.
        //
        pBlock = reinterpret_cast<BlockHeader *>( m_pHeap );

        //
        // Walk the chain, calling the enumerator at each free node.
        //
        for ( ; pBlock; pBlock = pBlock->pNext)
        {
            if( pBlock->eStatus == kFree )
            {
                if (!pEnumProc( pBlock, pRefData ))
                {
                    break;
                }
            }
        }

        //
        // Point to the first block in the heap.
        //
        pBlock = reinterpret_cast<BlockHeader *>( m_pHeap );

        //
        // Walk the chain, calling the enumerator at each busy node.
        //
        for ( ; pBlock; pBlock = pBlock->pNext)
        {
            if( pBlock->eStatus != kFree )
            {
                if (!pEnumProc( pBlock, pRefData ))
                {
                    break;
                }
            }
        }
    }

    return TRUE;
}

/*++

Title:

    DefaultHeapEnumProc

Routine Description:

    Display the heap node data.

Arguments:

    pBlockHeader    - pointer to memory block
    pRefDate        - caller defined reference data

Return Value:

    Always returns TRUE success.

--*/
BOOL
TDebugHeap::
DefaultHeapEnumProc(
    IN BlockHeader      *pBlockHeader,
    IN PVOID            pRefData
    )
{
    LPCTSTR pszStatus = pBlockHeader->eStatus == kFree ? _T("free") : _T("busy");

    ErrorText( _T("\t0x%lx : %s (%d)\n"), pBlockHeader, pszStatus, pBlockHeader->uSize );

    return TRUE;
}


/*++

Title:

    RoundUpToGranularity

Routine Description:

    Rounds up the specified value to the next granular value.

Arguments:

    uValue - Value to round up.

Return Value:

    Returns rounded up value.

--*/
SIZE_T
TDebugHeap::
RoundUpToGranularity(
    IN SIZE_T             uValue
    ) const
{
    return (uValue + m_uGranularity - 1) & ~(m_uGranularity - 1);
}

/*++

Title:

    InitalizeClassMembers

Routine Description:

    Initalizes the class members.

Arguments:

    None.

Return Value:

    Nothing.

--*/
VOID
TDebugHeap::
InitalizeClassMembers(
    VOID
    )
{
    m_bValid        = FALSE;
    m_pHeap         = NULL;
    m_hHeap         = NULL;
    m_uSize         = kDefaultHeapSize;
    m_uGranularity  = kDefaultHeapGranularity;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgfac.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgfac.cxx

Abstract:

    Debug Device Class Factory

Author:

    Steve Kiraly (SteveKi)  10-Dec-1995

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgfac.hxx"
#include "dbgdbg.hxx"
#include "dbgnul.hxx"
#include "dbgcon.hxx"
#include "dbgfil.hxx"
#include "dbgsterm.hxx"
#include "dbgback.hxx"

TDebugFactory::
TDebugFactory(
    VOID
    )
{
}

TDebugFactory::
~TDebugFactory(
    VOID
    )
{
}

BOOL
TDebugFactory::
bValid(
    VOID
    ) const
{
    return TRUE;
}

TDebugDevice *
TDebugFactory::
Produce(
    IN UINT     uDevice,
    IN LPCTSTR  pszConfiguration,
    IN BOOL     bUnicode
    )
{
    LPTSTR          pszCharacterType    = NULL;
    TDebugDevice   *pDebugDevice        = NULL;
    TDebugString    strConfig;

    //
    // Ensure the configuration string points to something valid.
    //
    if( !pszConfiguration )
    {
        pszConfiguration = const_cast<LPTSTR>( kstrNull );
    }

    //
    // Prefix the configuration string with the character type
    // directive.  The configuration string is a string of device
    // specific commands separated by colans.
    //
    pszCharacterType = bUnicode ? const_cast<LPTSTR>( kstrUnicode )
                                : const_cast<LPTSTR>( kstrAnsi );

    //
    // Update the configuration string.
    //
    if( strConfig.bUpdate( pszCharacterType )   &&
        strConfig.bCat( kstrSeparator )         &&
        strConfig.bCat( pszConfiguration ) )
    {
        //
        // Instantiate the debug device.
        //
        switch( uDevice )
        {
        case kDbgConsole:       // Text console
            pDebugDevice = INTERNAL_NEW TDebugDeviceConsole( strConfig, kDbgConsole );
            break;

        case kDbgDebugger:      // Debug console
            pDebugDevice = INTERNAL_NEW TDebugDeviceDebugger( strConfig, kDbgDebugger );
            break;

        case kDbgNull:          // Null Device to nothing
            pDebugDevice = INTERNAL_NEW TDebugDeviceNull( strConfig, kDbgNull );
            break;

        case kDbgFile:          // Log file
            pDebugDevice = INTERNAL_NEW TDebugDeviceFile( strConfig, kDbgFile );
            break;

        case kDbgSerialTerminal: // Serial Terminal
            pDebugDevice = INTERNAL_NEW TDebugDeviceSerialTerminal( strConfig, kDbgSerialTerminal );
            break;

        case kDbgBackTrace:     // Backtrace
            pDebugDevice = INTERNAL_NEW TDebugDeviceBacktrace( strConfig, kDbgBackTrace );
            break;

        default:
            pDebugDevice = NULL;
            break;
        }
    }

    //
    // If not valid release the debug device.
    //
    if( !pDebugDevice || !pDebugDevice->bValid() )
    {
        INTERNAL_DELETE pDebugDevice;
        pDebugDevice = NULL;
    }

    //
    // Return product pointer.
    //
    return pDebugDevice;

}

//
// Dispose of the product.
//
VOID
TDebugFactory::
Dispose(
    IN TDebugDevice *pDevice
    )
{
    INTERNAL_DELETE pDevice;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbglist.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbglist.cxx

Abstract:

    Debug List

Author:

    Steve Kiraly (SteveKi)  10-Dec-1995

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbglist.hxx"

/********************************************************************

 Debug node class. ( Singly linked list )

********************************************************************/

TDebugNodeSingle::
TDebugNodeSingle(
    VOID
    ) : _pNext( NULL )
{
}

TDebugNodeSingle::
~TDebugNodeSingle(
    VOID
    )
{
}

TDebugNodeSingle*
TDebugNodeSingle::
Next(
    VOID
    ) const
{
    return _pNext;
}

VOID
TDebugNodeSingle::
Insert(
    TDebugNodeSingle **pRoot
    )
{
    _pNext = *pRoot;
    *pRoot = this;
}

VOID
TDebugNodeSingle::
Remove(
    TDebugNodeSingle **pRoot
    )
{
    for( TDebugNodeSingle **ppNext = pRoot; *ppNext; ppNext = &(*ppNext)->_pNext )
    {
        if( *ppNext == this )
        {
            *ppNext = (*ppNext)->_pNext;
            break;
        }
    }
}

/********************************************************************

Debug node class. ( Doubbly linked list )

********************************************************************/

TDebugNodeDouble::
TDebugNodeDouble(
    VOID
    )
{
    Close();
}

TDebugNodeDouble::
~TDebugNodeDouble(
    VOID
    )
{
}

TDebugNodeDouble *
TDebugNodeDouble::
Next(
    VOID
    ) const
{
    return _pNext;
}

TDebugNodeDouble *
TDebugNodeDouble::
Prev(
    VOID
    ) const
{
    return _pPrev;
}

VOID
TDebugNodeDouble::
Close(
    VOID
    )
{
    _pNext = this;
    _pPrev = this;
}

BOOL
TDebugNodeDouble::
IsSingle(
    VOID
    ) const
{
    return _pNext == this;
}

VOID
TDebugNodeDouble::
Remove(
    TDebugNodeDouble **ppRoot
    )
{
    //
    // If we are removing the last element
    // clear the root of the list
    //
    if( _pNext == this )
    {
        *ppRoot = NULL;
    }
    else
    {
        //
        // If the root is pointing to the element we are
        // just about to delete, then advance the root
        // to the next element.
        //
        if( *ppRoot == this )
        {
            *ppRoot = _pNext;
        }

        //
        // unlink this node form the list.
        //
        _pNext->_pPrev = _pPrev;
        _pPrev->_pNext = _pNext;

    }

    //
    // Close this node.
    //
    Close();
}

VOID
TDebugNodeDouble::
Insert(
    TDebugNodeDouble **ppRoot
    )
{
    if( *ppRoot )
    {
        (*ppRoot)->_pPrev->_pNext = this;
        _pNext = *ppRoot;
        _pPrev = (*ppRoot)->_pPrev;
        (*ppRoot)->_pPrev = this;
    }
    else
    {
        *ppRoot = this;
    }
}

VOID
TDebugNodeDouble::
InsertBefore(
    TDebugNodeDouble **ppRoot,
    TDebugNodeDouble  *pAfter
    )
{
    pAfter->_pPrev->_pNext = this;
    _pNext = pAfter;
    _pPrev = pAfter->_pPrev;
    pAfter->_pPrev = this;
    *ppRoot = *ppRoot = pAfter ? this : pAfter;
}

VOID
TDebugNodeDouble::
InsertAfter(
    TDebugNodeDouble **ppRoot,
    TDebugNodeDouble  *pBefore
    )
{
    pBefore->_pPrev->_pNext = this;
    _pNext = pBefore->_pNext;
    _pPrev = pBefore;
    pBefore->_pNext = this;
}

VOID
TDebugNodeDouble::
Concatinate(
    TDebugNodeDouble **ppRoot1,
    TDebugNodeDouble **ppRoot2
    )
{
    if( *ppRoot2 )
    {
        if( *ppRoot1 )
        {
            (*ppRoot1)->_pPrev->_pNext = *ppRoot2;
            (*ppRoot2)->_pPrev->_pNext = *ppRoot1;
            TDebugNodeDouble *pTemp = (*ppRoot1)->_pPrev;
            (*ppRoot1)->_pPrev = (*ppRoot2)->_pPrev;
            (*ppRoot2)->_pPrev = pTemp;
        }
        else
        {
            *ppRoot1 = *ppRoot2;
        }
    }
}

TDebugNodeDouble::Iterator::
Iterator(
    TDebugNodeDouble *pRoot
    ) : _pRoot( pRoot ),
        _pCurrent( pRoot )
{
}

TDebugNodeDouble::Iterator::
~Iterator(
    VOID
    )
{
}

VOID
TDebugNodeDouble::Iterator::
First(
    VOID
    )
{
    _pCurrent = _pRoot;
}

VOID
TDebugNodeDouble::Iterator::
Next(
    VOID
    )
{
    _pCurrent = _pCurrent->Next() == _pRoot ? NULL : _pCurrent->Next();
}

BOOL
TDebugNodeDouble::Iterator::
IsDone(
    VOID
    )
{
    return _pCurrent == NULL;
}

TDebugNodeDouble *
TDebugNodeDouble::Iterator::
Current(
    VOID
    )
{
    return _pCurrent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbginit.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbginit.cxx

Abstract:

    Debug Library initialization

Author:

    Steve Kiraly (SteveKi)  24-May-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

//
// Debug library lock variable.
//
namespace
{
    LONG DebugLibraryInitLock = 0;
    BOOL IsLibraryInitialized = FALSE;
}

/*++

Title:

    DebugLibraryInitialize

Routine Description:

    Initialize the debug library.  Basically we need to have the
    library critical section initialized to prevent multiple threads
    from trying to access either the messaging initialization code
    or the internal heap initialization code.

Arguments:

    None.

Return Value:

    None.

--*/
extern "C"
VOID
DebugLibraryInitialize(
    VOID
    )
{
    //
    // Is the library initialized.
    //
    if (!IsLibraryInitialized)
    {
        //
        // Only allow one thread to do the library initialization.
        //
        while (InterlockedCompareExchange(&DebugLibraryInitLock, 1, 0))
        {
            Sleep(1);
        }

        //
        // We must re-check is, to prevent second thread from doing
        // the initialization as well.
        //
        if (!IsLibraryInitialized)
        {
            //
            // Initialize the ciritical section
            //
            GlobalCriticalSection.Initialize();

            //
            // Initalize the debug heap.
            //
            DebugLibraryInitializeHeap();

            //
            // Mark the library as initialized.
            //
            IsLibraryInitialized = TRUE;
        }

        //
        // Release the library init lock.
        //
        DebugLibraryInitLock = 0;
    }
}

/*++

Title:

    DebugLibraryRelease

Routine Description:

    Release any resorces in the debug library.  Callers should call
    this function to properly shut down the library.  Callers should
    not call any function in the library after this call.

Arguments:

    None.

Return Value:

    None.

--*/
extern "C"
VOID
DebugLibraryRelease(
    VOID
    )
{
    //
    // Relese the message instance.
    //
    TDebugMsg_Release();

    //
    // Walk the internal heap, if the Display library
    // errors flag is enabled then the heap contents
    // are dummped to the debug device.
    //
    DebugLibraryWalkHeap();

    //
    // Release the internal heap.
    //
    DebugLibraryDestroyHeap();

    //
    // Release the critical section.
    //
    GlobalCriticalSection.Release();

    //
    // Mark the library as not initialized.
    //
    IsLibraryInitialized = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgimage.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgback.cxx

Abstract:

    Debug Imagehlp

Author:

    Steve Kiraly (SteveKi)  17-May-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgloadl.hxx"
#include "dbgimage.hxx"
#include <wtypes.h>
//
// Initialize the imagehlp library.
//
TDebugImagehlp::
TDebugImagehlp(
    VOID
    ) : _ImageHlp( TEXT("ImageHlp.dll") ),
        _bValid( FALSE ),
        _pfSymGetModuleInfo( NULL ),
        _pfSymFunctionTableAccess( NULL ),
        _pfSymGetModuleBase( NULL ),
        _pfStackWalk( NULL ),
        _pfSymInitialize( NULL ),
        _pfSymSetOptions( NULL ),
        _pfSymGetSymFromAddr( NULL ),
        _pfSymUnDName( NULL )
{
    if( _ImageHlp.bValid() )
    {
        _pfSymGetModuleInfo         = (pfSymGetModuleInfo)      _ImageHlp.pfnGetProc( "SymGetModuleInfo" );
        _pfStackWalk                = (pfStackWalk)             _ImageHlp.pfnGetProc( "StackWalk" );
        _pfSymSetOptions            = (pfSymSetOptions)         _ImageHlp.pfnGetProc( "SymSetOptions" );
        _pfSymInitialize            = (pfSymInitialize)         _ImageHlp.pfnGetProc( "SymInitialize" );
        _pfSymFunctionTableAccess   = (pfSymFunctionTableAccess)_ImageHlp.pfnGetProc( "SymFunctionTableAccess" );
        _pfSymGetModuleBase         = (pfSymGetModuleBase)      _ImageHlp.pfnGetProc( "SymGetModuleBase" );
        _pfSymGetSymFromAddr        = (pfSymGetSymFromAddr)     _ImageHlp.pfnGetProc( "SymGetSymFromAddr" );
        _pfSymUnDName               = (pfSymUnDName)            _ImageHlp.pfnGetProc( "SymUnDName" );
        _pfSymGetSearchPath         = (pfSymGetSearchPath)      _ImageHlp.pfnGetProc( "SymGetSearchPath" );
        _pfSymSetSearchPath         = (pfSymSetSearchPath)      _ImageHlp.pfnGetProc( "SymSetSearchPath" );

        if( _pfSymGetModuleInfo         &&
            _pfStackWalk                &&
            _pfSymSetOptions            &&
            _pfSymInitialize            &&
            _pfSymFunctionTableAccess   &&
            _pfSymGetModuleBase         &&
            _pfSymGetSymFromAddr        &&
            _pfSymUnDName )
        {
            _pfSymSetOptions( SYMOPT_DEFERRED_LOADS );
            _pfSymInitialize( GetCurrentProcess(), NULL, TRUE );
            _bValid = TRUE;

#ifndef UNICODE
            _pszSymbolFormatSpecifier = _T("%08lx %s!%s+0x%x\n");
#else
            _pszSymbolFormatSpecifier = _T("%08lx %S!%S+0x%x\n");
#endif
        }
    }
}

//
// Destroy the imagehlp library.
//
TDebugImagehlp::
~TDebugImagehlp(
    VOID
    )
{
}

//
// Return the object state.
//
BOOL
TDebugImagehlp::
bValid(
    VOID
    )
{
    return _bValid;
}

//
// Capture the current backtrace.
//
BOOL
TDebugImagehlp::
bCaptureBacktrace(
    IN      UINT    nSkip,
    IN      ULONG   nTotal,
        OUT VOID    **apvBacktrace,
        OUT ULONG   *puCount
    )
{
    HANDLE      hThread     = NULL;
    CONTEXT     context     = {0};

    hThread = GetCurrentThread();

    context.ContextFlags = CONTEXT_FULL;

    if (GetThreadContext(hThread, &context))
    {
        STACKFRAME  stkfrm      = {0};
        DWORD       dwMachType  = 0;

        stkfrm.AddrPC.Mode      = AddrModeFlat;

#if defined(_M_IX86)
        dwMachType              = IMAGE_FILE_MACHINE_I386;
        stkfrm.AddrPC.Offset    = context.Eip;  // Program Counter
        stkfrm.AddrStack.Offset = context.Esp;  // Stack Pointer
        stkfrm.AddrStack.Mode   = AddrModeFlat; // Stack address mode
        stkfrm.AddrFrame.Offset = context.Ebp;  // Frame Pointer
        stkfrm.AddrFrame.Mode   = AddrModeFlat; // Frame address mode
#elif defined(_M_MRX000)
        dwMachType              = IMAGE_FILE_MACHINE_R4000;
        stkfrm.AddrPC.Offset    = context.Fir;  // Program Counter
#elif defined(_M_ALPHA)
        dwMachType              = IMAGE_FILE_MACHINE_ALPHA;
        stkfrm.AddrPC.Offset    = (ULONG) context.Fir;  // Program Counter
#elif defined(_M_PPC)
        dwMachType              = IMAGE_FILE_MACHINE_POWERPC;
        stkfrm.AddrPC.Offset    = context.Iar;  // Program Counter
#elif defined(_M_IA64)
        dwMachType              = IMAGE_FILE_MACHINE_IA64;
        stkfrm.AddrPC.Offset    = context.StIIP;
#else
#error("Unknown Target Machine");
#endif

        //
        // Clear the valid entry count.
        //
        *puCount = 0;

        //
        // Walk the stack saving the addresses.
        //
        for( UINT i = 0; i < nSkip + nTotal; i++ )
        {
            if( !_pfStackWalk( dwMachType,
                               GetCurrentProcess(),
                               GetCurrentProcess(),
                               &stkfrm,
                               &context,
                               NULL,
                               _pfSymFunctionTableAccess,
                               _pfSymGetModuleBase,
                               NULL ))
            {
                break;
            }

            if (i >= nSkip)
            {
                if( stkfrm.AddrPC.Offset )
                {
                    apvBacktrace[(*puCount)++] = (VOID *)stkfrm.AddrPC.Offset;
                }
            }
        }
    }
    return *puCount > 0;
}

//
// Resolve the specified address to a human readable symbol.
//
BOOL
TDebugImagehlp::
ResolveAddressToSymbol(
    IN PVOID        pvAddress,
    IN LPTSTR       pszName,
    IN UINT         cchNameLength,
    IN EDecoration  eDecorateType
    )
{
    IMAGEHLP_MODULE  mod            = {0};
    DWORD            dwDisplacement = 0;
    INT              iLen           = 0;
    UINT_PTR         Address        = (UINT_PTR)pvAddress;
    LPCSTR           pszSymbolName  = NULL;

    CHAR             szUnDDump[kMaxSymbolNameLength];
    CHAR             dump[sizeof(IMAGEHLP_SYMBOL) + kMaxSymbolNameLength];
    PIMAGEHLP_SYMBOL pSym   = (PIMAGEHLP_SYMBOL)&dump;

    //
    // Fetch the module name
    //
    mod.SizeOfStruct = sizeof(IMAGEHLP_MODULE);
    _pfSymGetModuleInfo(GetCurrentProcess(), Address, &mod);

    //
    // Have to do this because size of sym is dynamically determined
    //
    pSym->SizeOfStruct = sizeof(dump);
    pSym->MaxNameLength = kMaxSymbolNameLength;

    //
    // Fetch the symbol
    //
    if (_pfSymGetSymFromAddr(GetCurrentProcess(),
                             Address,
                             &dwDisplacement,
                             pSym))
    {
        //
        // Assume the caller wants a decorated symbol name.
        //
        pszSymbolName = pSym->Name;

        if( eDecorateType == kUnDecorateName )
        {
            //
            // Get the undecorated name for this symbol.
            //
            if( _pfSymUnDName( pSym, szUnDDump, sizeof( szUnDDump ) ) )
            {
                pszSymbolName = szUnDDump;
            }
        }
    }

    //
    // Format the symbol name.
    //
    iLen = _sntprintf( pszName,
                       cchNameLength,
                       _pszSymbolFormatSpecifier,
                       Address,
                       mod.ModuleName,
                       pszSymbolName,
                       dwDisplacement );

    return iLen > 0;
}

//
// Get the current symbol search path for this process
//
BOOL
TDebugImagehlp::
GetSymbolPath(
    IN TDebugString &strSearchPath
    ) const
{
    BOOL bRetval = FALSE;
    CHAR szNarowSearchPath[MAX_PATH];
    LPTSTR pszSearchPath;

    bRetval = _pfSymGetSearchPath( GetCurrentProcess(), szNarowSearchPath, COUNTOF( szNarowSearchPath ) );

    if( bRetval )
    {
        bRetval = StringA2T( &pszSearchPath, szNarowSearchPath );

        if( bRetval )
        {
            bRetval = strSearchPath.bUpdate( pszSearchPath );

            INTERNAL_DELETE [] pszSearchPath;
        }
    }

    return bRetval;
}

//
// Set the current symbol search path for this process
//
BOOL
TDebugImagehlp::
SetSymbolPath(
    IN LPCTSTR pszSearchPath
    )
{
    BOOL bRetval = FALSE;
    LPSTR pszNarrowSearchPath = NULL;

    bRetval = StringT2A( &pszNarrowSearchPath, pszSearchPath );

    if( bRetval )
    {
        bRetval = _pfSymSetSearchPath( GetCurrentProcess(), pszNarrowSearchPath );

        INTERNAL_DELETE [] pszNarrowSearchPath;
    }

    return bRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgloadl.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgloadl.cxx

Abstract:

    Library Loader helper class

Author:

    Steve Kiraly (SteveKi)  17-Oct-1995

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgloadl.hxx"

TDebugLibrary::
TDebugLibrary(
    IN LPCTSTR pszLibName
    )
{
    m_hInst = LoadLibrary( pszLibName );
}

TDebugLibrary::
~TDebugLibrary(
    )
{
    if( bValid() )
    {
        FreeLibrary( m_hInst );
    }
}

BOOL
TDebugLibrary::
bValid(
    VOID
    )
{
    return m_hInst != NULL;
}

FARPROC
TDebugLibrary::
pfnGetProc(
    IN LPCSTR pszProc
    )
{
    return ( bValid() ) ? GetProcAddress( m_hInst, pszProc ) : NULL;
}

FARPROC
TDebugLibrary::
pfnGetProc(
    IN UINT_PTR uOrdinal
    )
{
    return ( bValid() ) ? GetProcAddress( m_hInst, (LPCSTR)uOrdinal ) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgmsg.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgmsg.cxx

Abstract:

    Debug Library

Author:

    Steve Kiraly (SteveKi)  10-Dec-1995

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

//
// Singleton instance.
//
namespace
{
    TDebugMsg DebugMsg;
}

/*++

Title:

    TDebugMsg_Register

Routine Description:

    Registers the prefix, device, trace and break level with the
    global debug messaging library.

Arguments:

    pszPrefix - pointer to prefix string.
    uDevice   - debug device type.
    eLevel    - message trace level.
    eBreak    - debug break level.

Return Value:

    TRUE device registered, FALSE error occurred.

--*/
extern "C"
BOOL
TDebugMsg_Register(
    IN LPCTSTR      pszPrefix,
    IN UINT         uDevice,
    IN INT          eLevel,
    IN INT          eBreak
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access the heap.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Don't re-initialize the message class.
    //
    if (!DebugMsg.Valid())
    {
        //
        // Initialize the debug heap.
        //
        DebugMsg.Initialize(pszPrefix, uDevice, eLevel, eBreak);

        //
        // Expose the debug message class for the debug extension.
        //
        Globals.DebugMsgSingleton = &DebugMsg;
    }

    //
    // Return the message class status.
    //
    return DebugMsg.Valid();
}

/*++

Title:

    TDebugMsg_Release

Routine Description:


Arguments:


Return Value:


--*/
extern "C"
VOID
TDebugMsg_Release(
    VOID
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access the heap.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Destroy the message class.
    //
    DebugMsg.Destroy();

    //
    // Remote the debug message class from the debug extension.
    //
    Globals.DebugMsgSingleton = NULL;
}

/*++

Title:

    TDebugMsg_vEnable

Routine Description:

    Enabled the debug messaging class, debug device will be called
    when a message is asked to be sent.

Arguments:

    None

Return Value:

    None

--*/
extern "C"
VOID
TDebugMsg_Enable(
    VOID
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access message class.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Only do the command if the message class is enabled.
    //
    if (DebugMsg.Valid())
    {
        DebugMsg.Enable();
    }
}

/*++

Title:

    TDebugMsg_Disable

Routine Description:

    Disable the debug messaging class, debug device will not be called
    when a message is asked to be sent.

Arguments:

    None

Return Value:

    None

--*/
extern "C"
VOID
TDebugMsg_Disable(
    VOID
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access message class.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Only do the command if the message class is enabled.
    //
    if (DebugMsg.Valid())
    {
        DebugMsg.Disable();
    }
}


/*++

Title:

    TDebugMsg_Attach

Routine Description:

    Attaches the output device specified by uDevice and pszConfiguration.
    if this routing is successfull, the handle to the attached device
    is returned in phDevice.

Arguments:

    phDevice        - pointer to device handle were to return newly created
                      add attached output device.
    uDevice,        - output device type to attached, see header file for
                      an enumeration of valid output device types.
    pszConfiguration - pointer to output device specific configuration
                      string.

Return Value:

    TRUE device was attached, FALSE error occurred.

--*/
extern "C"
BOOL
TDebugMsg_Attach(
    IN HANDLE   *phDevice,
    IN UINT     uDevice,
    IN LPCTSTR  pszConfiguration
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access message class.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Is the message class valid.
    //
    BOOL bRetval = DebugMsg.Valid();

    //
    // Only do the command if the message class is enabled.
    //
    if (bRetval)
    {
        bRetval = DebugMsg.Attach(phDevice, uDevice, pszConfiguration);
    }

    return bRetval;
}

/*++

Title:

    TDebugMsg_Detach

Routine Description:

    Removes the device specified by the handle from the
    list of output devices.

Arguments:

    phDevice - Pointer to debug device handle

Return Value:

    None

--*/
extern "C"
VOID
TDebugMsg_Detach(
    IN HANDLE     *phDevice
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access message class.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Only do the command if the message class is enabled.
    //
    if (DebugMsg.Valid())
    {
        DebugMsg.Detach(phDevice);
    }
}

/*++

Title:

    TDebugMsg_MsgA

Routine Description:

    This function outputs the specified message to the list
    of output debug devices.  Not this routine is not a general
    purpose output routine, the pszMessage parameter must be
    have been allocated from the internal debug heap.

Arguments:

    uLevel          - debug trace and break level
    pszFile         - pointer to file name
    uLine           - file line number
    pszModulePrefix - pointe to module prefix, OPTIONAL
    pszMessage      - pointer to post formatted message string, that
                      was returned from a call to TDebugMsg_pszFmt,
                      if this pointer is non null then it relased
                      back to the internal debug heap before this
                      routine returns.

Return Value:

    None

--*/
extern "C"
VOID
TDebugMsg_MsgA(
    IN UINT         uLevel,
    IN LPCTSTR      pszFile,
    IN UINT         uLine,
    IN LPCTSTR      pszModulePrefix,
    IN LPSTR        pszMessage
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access message class.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Only do the command if the message class is enabled.
    //
    if (DebugMsg.Valid())
    {
        DebugMsg.Msg(uLevel, pszFile, uLine, pszModulePrefix, pszMessage);
    }
    else
    {
        //
        // Message class is not initialized, well lets do it now.
        //
        DebugMsg.Initialize(NULL, kDbgDebugger, kDbgTrace, kDbgNone);

        //
        // Only do the command if the message class is enabled.
        //
        if (DebugMsg.Valid())
        {
            DebugMsg.Msg(uLevel, pszFile, uLine, pszModulePrefix, pszMessage);
        }
        else
        {
            INTERNAL_DELETE [] pszMessage;
        }
    }
}

/*++

Title:

    TDebugMsg_Msg

Routine Description:

    This function outputs the specified message to the list
    of output debug devices.  Not this routine is not a general
    purpose output routine, the pszMessage parameter must be
    have been allocated from the internal debug heap.

Arguments:

    uLevel          - debug trace and break level
    pszFile         - pointer to file name
    uLine           - file line number
    pszModulePrefix - pointe to module prefix, OPTIONAL
    pszMessage      - pointer to post formatted message string, that
                      was returned from a call to TDebugMsg_pszFmt,
                      if this pointer is non null then it relased
                      back to the internal debug heap before this
                      routine returns.

Return Value:

    Pointer to allocated string, NULL if failure.

--*/
extern "C"
VOID
TDebugMsg_MsgW(
    IN UINT         uLevel,
    IN LPCTSTR      pszFile,
    IN UINT         uLine,
    IN LPCTSTR      pszModulePrefix,
    IN LPWSTR       pszMessage
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access message class.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Only do the command if the message class is enabled.
    //
    if (DebugMsg.Valid())
    {
        DebugMsg.Msg(uLevel, pszFile, uLine, pszModulePrefix, pszMessage);
    }
    else
    {
        //
        // Message class is not initialized, well lets do it now.
        //
        DebugMsg.Initialize(NULL, kDbgDebugger, kDbgTrace, kDbgNone);

        //
        // Only do the command if the message class is enabled.
        //
        if (DebugMsg.Valid())
        {
            DebugMsg.Msg(uLevel, pszFile, uLine, pszModulePrefix, pszMessage);
        }
        else
        {
            INTERNAL_DELETE [] pszMessage;
        }
    }
}

/*++

Title:

    TDebugMsg_Msg

Routine Description:

    This function outputs the specified message to the list
    of output debug devices.  Not this routine is not a general
    purpose output routine, the pszMessage parameter must be
    have been allocated from the internal debug heap.

Arguments:

    uLevel          - debug trace and break level
    pszFile         - pointer to file name
    uLine           - file line number
    pszModulePrefix - pointe to module prefix, OPTIONAL
    pszMessage      - pointer to post formatted message string, that
                      was returned from a call to TDebugMsg_pszFmt,
                      if this pointer is non null then it relased
                      back to the internal debug heap before this
                      routine returns.

Return Value:

    None

--*/
VOID
TDebugMsg_Msg(
    IN UINT         uLevel,
    IN LPCTSTR      pszFile,
    IN UINT         uLine,
    IN LPCTSTR      pszModulePrefix,
    IN LPSTR        pszMessage
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access message class.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Only do the command if the message class is enabled.
    //
    if (DebugMsg.Valid())
    {
        DebugMsg.Msg(uLevel, pszFile, uLine, pszModulePrefix, pszMessage);
    }
    else
    {
        //
        // Message class is not initialized, well lets do it now.
        //
        DebugMsg.Initialize(NULL, kDbgDebugger, kDbgTrace, kDbgNone);

        //
        // Only do the command if the message class is enabled.
        //
        if (DebugMsg.Valid())
        {
            DebugMsg.Msg(uLevel, pszFile, uLine, pszModulePrefix, pszMessage);
        }
        else
        {
            INTERNAL_DELETE [] pszMessage;
        }
    }
}

/*++

Title:

    TDebugMsg_Msg

Routine Description:

    This function outputs the specified message to the list
    of output debug devices.  Not this routine is not a general
    purpose output routine, the pszMessage parameter must be
    have been allocated from the internal debug heap.

Arguments:

    uLevel          - debug trace and break level
    pszFile         - pointer to file name
    uLine           - file line number
    pszModulePrefix - pointe to module prefix, OPTIONAL
    pszMessage      - pointer to post formatted message string, that
                      was returned from a call to TDebugMsg_pszFmt,
                      if this pointer is non null then it relased
                      back to the internal debug heap before this
                      routine returns.

Return Value:

    None

--*/
VOID
TDebugMsg_Msg(
    IN UINT         uLevel,
    IN LPCTSTR      pszFile,
    IN UINT         uLine,
    IN LPCTSTR      pszModulePrefix,
    IN LPWSTR       pszMessage
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access message class.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Only do the command if the message class is enabled.
    //
    if (DebugMsg.Valid())
    {
        DebugMsg.Msg(uLevel, pszFile, uLine, pszModulePrefix, pszMessage);
    }
    else
    {
        //
        // Message class is not initialized, well lets do it now.
        //
        DebugMsg.Initialize(NULL, kDbgDebugger, kDbgTrace, kDbgNone);

        //
        // Only do the command if the message class is enabled.
        //
        if (DebugMsg.Valid())
        {
            DebugMsg.Msg(uLevel, pszFile, uLine, pszModulePrefix, pszMessage);
        }
        else
        {
            INTERNAL_DELETE [] pszMessage;
        }
    }
}

/*++

Title:

    TDebugMsg_FmtA

Routine Description:

    This function takes a format string and a list of arguments
    and returns a allocated string that is formated, specified
    by the format string.

Arguments:

    pszFmt  - pointer to format string.
    ...     - varable number of arguments.

Return Value:

    Pointer to allocated string, NULL if failure.

--*/
extern "C"
LPSTR
WINAPIV
TDebugMsg_FmtA(
    IN LPCSTR       pszFmt,
    IN ...
    )
{
    va_list pArgs;

    va_start(pArgs, pszFmt);

    LPSTR pszResult = vFormatA(pszFmt, pArgs);

    va_end(pArgs);

    return pszResult;
}

/*++

Title:

    TDebugMsg_FmtW

Routine Description:

    This function takes a format string and a list of arguments
    and returns a allocated string that is formated, specified
    by the format string.

Arguments:

    pszFmt  - pointer to format string.
    ...     - varable number of arguments.

Return Value:

    Pointer to allocated string, NULL if failure.

--*/
extern "C"
LPWSTR
WINAPIV
TDebugMsg_FmtW(
    IN LPCWSTR       pszFmt,
    IN ...
    )
{
    va_list pArgs;

    va_start(pArgs, pszFmt);

    LPWSTR pszResult = vFormatW(pszFmt, pArgs);

    va_end(pArgs);

    return pszResult;
}


/*++

Title:

    TDebugMsg_Fmt

Routine Description:

    This function takes a format string and a list of arguments
    and returns a allocated string that is formated, specified
    by the format string.

Arguments:

    pszFmt  - pointer to format string.
    ...     - varable number of arguments.

Return Value:

    Pointer to allocated string, NULL if failure.

--*/
LPSTR
WINAPIV
TDebugMsg_Fmt(
    IN LPCSTR       pszFmt,
    IN ...
    )
{
    va_list pArgs;

    va_start(pArgs, pszFmt);

    LPSTR pszResult = vFormatA(pszFmt, pArgs);

    va_end(pArgs);

    return pszResult;
}

/*++

Title:

    TDebugMsg_Fmt

Routine Description:

    This function takes a format string and a list of arguments
    and returns a allocated string that is formated, specified
    by the format string.

Arguments:

    pszFmt  - pointer to format string.
    ...     - varable number of arguments.

Return Value:

    Pointer to allocated format string, NULL if failure.

--*/
LPWSTR
WINAPIV
TDebugMsg_Fmt(
    IN LPCWSTR      pszFmt,
    IN ...
    )
{
    va_list pArgs;

    va_start(pArgs, pszFmt);

    LPWSTR pszResult = vFormatW(pszFmt, pArgs);

    va_end(pArgs);

    return pszResult;
}


/*++

Title:

    TDebugMsg_SetMessageFieldFormat

Routine Description:


Arguments:

Return Value:

    None.

--*/
VOID
TDebugMsg_SetMessageFieldFormat(
    IN UINT         eField,
    IN LPTSTR       pszFormat
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access message class.
    //
    TDebugCriticalSection::TLock CS(GlobalCriticalSection);

    //
    // Only do the command if the message class is enabled.
    //
    if (DebugMsg.Valid())
    {
        DebugMsg.SetMessageFieldFormat(eField, pszFormat);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgmsgp.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgmsgp.cxx

Abstract:

    Debug Library

Author:

    Steve Kiraly (SteveKi)  10-Dec-1995

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

TDebugMsg::
TDebugMsg(
    VOID
    ) : m_eLevel(static_cast<EDebugLevel>(0)),
        m_eBreak(static_cast<EDebugLevel>(0)),
        m_pDeviceRoot(NULL),
        m_pstrPrefix(NULL),
        m_pBuiltinDeviceRoot(NULL)
{
}

TDebugMsg::
~TDebugMsg(
    VOID
    )
{
}

BOOL
TDebugMsg::
Valid(
    VOID
    ) const
{
    return !!m_pBuiltinDeviceRoot;
}

VOID
TDebugMsg::
Disable(
    VOID
    )
{
    m_eLevel = static_cast<EDebugLevel>( m_eLevel | kDbgNone );
    m_eBreak = static_cast<EDebugLevel>( m_eBreak | kDbgNone );
}

VOID
TDebugMsg::
Enable(
    VOID
    )
{
    m_eLevel = static_cast<EDebugLevel>( m_eLevel & ~kDbgNone );
    m_eBreak = static_cast<EDebugLevel>( m_eBreak & ~kDbgNone );
}

BOOL
TDebugMsg::
Type(
    IN EDebugLevel eLevel
    ) const
{
    return !(m_eLevel & kDbgNone) && ((m_eLevel & eLevel) || (eLevel & kDbgAlways));
}

BOOL
TDebugMsg::
Break(
    IN EDebugLevel eLevel
    ) const
{
    return m_eBreak & eLevel;
}

/*++

Routine Name:

    Initialize

Routine Description:


Arguments:


Return Value:

    None.

--*/
VOID
TDebugMsg::
Initialize(
    IN LPCTSTR      pszPrefix,
    IN UINT         uDevice,
    IN INT          eLevel,
    IN INT          eBreak
    )
{
    if (!m_pBuiltinDeviceRoot)
    {
        BOOL bRetval = FALSE;

        //
        // Set the debug message and break level.
        //
        m_eLevel = static_cast<EDebugLevel>(eLevel & ~kDbgPrivateMask);
        m_eBreak = static_cast<EDebugLevel>(eBreak & ~kDbgPrivateMask);

        //
        // Set the global device flags.
        //
        if (!Globals.DebugDevices)
        {
            Globals.DebugDevices = uDevice & (kDbgNull | kDbgDebugger | kDbgFile);
        }

        //
        // Set the character type to current compiled type.
        //
        m_eLevel = static_cast<EDebugLevel>(m_eLevel | Globals.CompiledCharType);

        //
        // Set the prefix string.
        //
        m_pstrPrefix = INTERNAL_NEW TDebugString(pszPrefix ? pszPrefix : kstrPrefix);

        //
        // Set the prefix string.
        //
        if (m_pstrPrefix && m_pstrPrefix->bValid() && m_pstrPrefix->bCat( _T(":")))
        {
            //
            // Set the additional format strings.
            //
            m_pstrFileInfoFormat        = INTERNAL_NEW TDebugString(kstrFileInfoFormat);
            m_pstrTimeStampFormatShort  = INTERNAL_NEW TDebugString(kstrTimeStampFormatShort);
            m_pstrTimeStampFormatLong   = INTERNAL_NEW TDebugString(kstrTimeStampFormatLong);
            m_pstrThreadIdFormat        = INTERNAL_NEW TDebugString(kstrThreadIdFormat);

            if( m_pstrFileInfoFormat && m_pstrFileInfoFormat->bValid() &&
                m_pstrTimeStampFormatShort && m_pstrTimeStampFormatShort->bValid() &&
                m_pstrTimeStampFormatLong && m_pstrTimeStampFormatLong->bValid() &&
                m_pstrThreadIdFormat && m_pstrThreadIdFormat->bValid() )
            {
                //
                // Attach the default debug devices.
                //
                if(Attach(NULL, kDbgDebugger,    NULL,                   &m_pBuiltinDeviceRoot) &&
                   Attach(NULL, kDbgFile,        kstrDefaultLogFileName, &m_pBuiltinDeviceRoot) &&
                   Attach(NULL, kDbgNull,        NULL,                   &m_pBuiltinDeviceRoot))
                {
                    bRetval = TRUE;
                }
                else
                {
                    ErrorText( _T("Error: TDebugMsg::Initialize - A default debug device failed to attach!\n") );
                }
            }
            else
            {
                ErrorText( _T("Error: TDebugMsg::Initialize - format string failed construction!\n") );
            }
        }
        else
        {
            ErrorText( _T("Error: TDebugMsg::Initialize - Debug prefix string failed allocation!\n") );
        }

        //
        // If we failed then unregister, cleanup.
        //
        if (!bRetval)
        {
            Destroy();
        }
    }
    else
    {
        ErrorText( _T("Error: TDebugMsg::Initialize already initalized!\n") );
    }
}

/*++

Routine Name:

    Destroy

Routine Description:

    Destroys the internal state of this class, this function
    does the same work the destructor would.

Arguments:

    None.

Return Value:

    None.

--*/
VOID
TDebugMsg::
Destroy(
    VOID
    )
{
    //
    // Release the debug device.
    //
    while( m_pDeviceRoot )
    {
        TDebugNodeDouble *pNode = m_pDeviceRoot;
        pNode->Remove( &m_pDeviceRoot );
        TDebugFactory::Dispose( static_cast<TDebugDevice *>( pNode ) );
    }

    //
    // Release the builtin debug device.
    //
    while( m_pBuiltinDeviceRoot )
    {
        TDebugNodeDouble *pNode = m_pBuiltinDeviceRoot;
        pNode->Remove( &m_pBuiltinDeviceRoot );
        TDebugFactory::Dispose( static_cast<TDebugDevice *>( pNode ) );
    }

    //
    // Release the string objects.
    //
    INTERNAL_DELETE m_pstrPrefix;
    INTERNAL_DELETE m_pstrFileInfoFormat;
    INTERNAL_DELETE m_pstrTimeStampFormatShort;
    INTERNAL_DELETE m_pstrTimeStampFormatLong;
    INTERNAL_DELETE m_pstrThreadIdFormat;

    //
    // Indicate we are not registered.
    //
    m_eLevel                    = static_cast<EDebugLevel>(0);
    m_eBreak                    = static_cast<EDebugLevel>(0);
    m_pDeviceRoot               = NULL;
    m_pBuiltinDeviceRoot        = NULL;
    m_pstrPrefix                = NULL;
    m_pstrFileInfoFormat        = NULL;
    m_pstrTimeStampFormatShort  = NULL;
    m_pstrTimeStampFormatLong   = NULL;
    m_pstrThreadIdFormat        = NULL;
}

/*++

Routine Name:

    Attach

Routine Description:

    Attach debug device to list of output devices.

Arguments:

    uDevice             - Type of debug device to use.
    pszConfiguration    - Pointer to configuration string.

Return Value:

    TRUE debug device attached, FALSE if error occurred.

--*/
BOOL
TDebugMsg::
Attach(
    IN HANDLE           *phDevice,
    IN UINT             uDevice,
    IN LPCTSTR          pszConfiguration,
    IN TDebugNodeDouble **ppDeviceRoot
    )
{
    BOOL bRetval = FALSE;

    //
    // Get access to the debug factory.
    //
    TDebugFactory DebugFactory;

    //
    // If we failed to create the debug factory then exit.
    //
    if (DebugFactory.bValid())
    {
        //
        // Create the specified debug device using the factory.
        //
        TDebugDevice *pDebugDevice = DebugFactory.Produce(uDevice,
                                                          pszConfiguration,
                                                          m_eLevel & kDbgUnicode);

        //
        // Check if the debug device was created ok.
        //
        if (pDebugDevice)
        {
            //
            // Place this device on the debug device list.
            //
            if (ppDeviceRoot)
            {
                pDebugDevice->Insert(ppDeviceRoot);
            }
            else
            {
                pDebugDevice->Insert(&m_pDeviceRoot);
            }

            //
            // Copy back the pointer to the debug device.
            //
            if (phDevice)
            {
                *phDevice = (HANDLE)pDebugDevice;
            }

            //
            // Successfully attached debug device.
            //
            bRetval = TRUE;
        }
        else
        {
            ErrorText( _T("Error: TDebugMsg::bAttach - Debug device creation failed!\n") );
        }
    }
    else
    {
        ErrorText( _T("Error: TDebugMsg::bAttach - Debug factory creation failed!\n") );
    }

    return bRetval;
}

/*++

Routine Name:

    Detach

Routine Description:

    Detach the debug device from the device stream.

Arguments:

    phDevice - Pointer to debug device handle.

Return Value:

    None.

--*/
VOID
TDebugMsg::
Detach(
    IN HANDLE     *phDevice
    )
{
    //
    // We silently ignore non initialized devices, or null pointers.
    //
    if (phDevice && *phDevice)
    {
        //
        // Get a usable pointer.
        //
        TDebugDevice *pDebugDevice = (TDebugDevice *)*phDevice;

        //
        // Remove this device from the debug device list.
        //
        pDebugDevice->Remove( &m_pDeviceRoot );

        //
        // Dispose of the device.
        //
        TDebugFactory::Dispose( pDebugDevice );

        //

        // Mark this device as released.
        //
        *phDevice = NULL;
    }
    else
    {
        ErrorText( _T("Error: TDebugMsg::vDetach - non initialized or null pointer!\n") );
    }
}

/*++

Routine Name:

    Msg

Routine Description:

    This function is public overloaded function for
    sending the message to the output devices.

Arguments:

    eLevel          - requested message level
    pszFile         - pointer to file name where message was called
    uLine           - line number where message was called
    pszModulePrefix - message defined module prefix, used as an override
    pszMessage      - pointer to post formated message string

Return Value:

    None.

--*/
VOID
TDebugMsg::
Msg(
    IN UINT         eLevel,
    IN LPCTSTR      pszFile,
    IN UINT         uLine,
    IN LPCTSTR      pszModulePrefix,
    IN LPSTR        pszMessage
    ) const
{
    if (pszMessage)
    {
        if (Type(static_cast<EDebugLevel>(eLevel)))
        {
            StringTrait StrMessage;

            StrMessage.pszNarrow = pszMessage;

            eLevel = eLevel & ~kDbgUnicode;

            Output(static_cast<EDebugLevel>(eLevel), pszFile, uLine, pszModulePrefix, StrMessage);

            if (Break(static_cast<EDebugLevel>(eLevel)))
            {
                DebugBreak();
            }
        }

        INTERNAL_DELETE [] pszMessage;
    }
}


/*++

Routine Name:

    Msg

Routine Description:

    This function is public overloaded function for
    sending the message to the output devices.

Arguments:

    eLevel          - requested message level
    pszFile         - pointer to file name where message was called
    uLine           - line number where message was called
    pszModulePrefix - message defined module prefix, used as an override
    pszMessage      - pointer to post formated message string

Return Value:

    None.

--*/
VOID
TDebugMsg::
Msg(
    IN UINT         eLevel,
    IN LPCTSTR      pszFile,
    IN UINT         uLine,
    IN LPCTSTR      pszModulePrefix,
    IN LPWSTR       pszMessage
    ) const
{
    if (pszMessage)
    {
        if (Type(static_cast<EDebugLevel>(eLevel)))
        {
            StringTrait StrMessage;

            StrMessage.pszWide = pszMessage;

            eLevel = eLevel | kDbgUnicode;

            Output(static_cast<EDebugLevel>(eLevel), pszFile, uLine, pszModulePrefix, StrMessage);

            if (Break(static_cast<EDebugLevel>(eLevel)))
            {
                DebugBreak();
            }
        }

        INTERNAL_DELETE [] pszMessage;
    }
}

/********************************************************************

 Private member functions.

********************************************************************/

/*++

Routine Name:

    Output

Routine Description:

    Outputs the messages to the list of registred
    debug devices.

Arguments:

    eLevel          - requested message level
    pszFile         - pointer to file name where message was called
    uLine           - line number where message was called
    pszModulePrefix - message defined module prefix, used as an override
    pszMessage      - pointer to post formated message string

Return Value:

    None.

--*/
VOID
TDebugMsg::
Output(
    IN EDebugLevel  eLevel,
    IN LPCTSTR      pszFileName,
    IN UINT         uLine,
    IN LPCTSTR      pszModulePrefix,
    IN StringTrait &strMsg
    ) const
{
    TDebugString strFinal;

    //
    // Build the final output string.
    //
    if (BuildFinalString(strFinal,
                         eLevel,
                         pszModulePrefix,
                         pszFileName,
                         uLine,
                         strMsg))
    {
        //
        // Calculate the byte count (less the null terminator) of the final string.
        //
        UINT uByteCount = (m_eLevel & kDbgUnicode)
                           ? strFinal.uLen() * sizeof(WCHAR)
                           : strFinal.uLen() * sizeof(CHAR);

        LPBYTE pByte = reinterpret_cast<LPBYTE>(const_cast<LPTSTR>(static_cast<LPCTSTR>(strFinal)));

        {
            //
            // Create interator on built in device list.
            //
            TDebugNodeDouble::Iterator Iter(m_pBuiltinDeviceRoot);

            //
            // Output this string to all the built in debug devices.
            //
            for( Iter.First(); !Iter.IsDone(); Iter.Next() )
            {
                if (static_cast<TDebugDevice *>(Iter.Current())->eGetDebugType() & Globals.DebugDevices)
                {
                    static_cast<TDebugDevice *>(Iter.Current())->bOutput(uByteCount, pByte);
                }
            }
        }

        {
            //
            // Create interator on device list.
            //
            TDebugNodeDouble::Iterator Iter(m_pDeviceRoot);

            //
            // Output this string to all the registered debug devices.
            //
            for( Iter.First(); !Iter.IsDone(); Iter.Next() )
            {
                static_cast<TDebugDevice *>(Iter.Current())->bOutput( uByteCount, pByte);
            }
        }
    }
    else
    {
        ErrorText(_T("Error: TDebugMsg::vOutput - failed to build format string.\n"));
    }
}

/*++

Routine Name:

    BuildFinalString

Routine Description:

    This routing build the actual string that will be sent to the
    debug output devices.

Arguments:

    strFinal        - string refrence where to return the finale output string.
    eLevel          - debug message level.
    pszModulePrefix - per message prefix string, can be null.
    pszFileName     - file name were the message was requested.
    uLine           - line number were message was requested.
    StrMsg          - post formated message string.

Return Value:

    TRUE final string was build successfully, FALSE error occurred.

--*/
BOOL
TDebugMsg::
BuildFinalString(
    IN      TDebugString    &strFinal,
    IN      EDebugLevel     eLevel,
    IN      LPCTSTR         pszModulePrefix,
    IN      LPCTSTR         pszFileName,
    IN      UINT            uLine,
    IN      StringTrait     &StrMsg
    ) const
{
    LPCTSTR         pszFormat;
    TDebugString    strArg0;
    TDebugString    strArg1;
    TDebugString    strArg2;
    TDebugString    strArg3;

    UINT eFlags = m_eLevel | eLevel;

    if (!(eFlags & kDbgNoPrefix))
    {
        (VOID)strArg0.bUpdate(pszModulePrefix ? pszModulePrefix : *m_pstrPrefix);
    }

    if (!(eFlags & kDbgNoFileInfo))
    {
        (VOID)GetParameter(eFlags & (kDbgFileInfo | kDbgFileInfoLong), strArg1, pszFileName, uLine);
    }

    (VOID)GetParameter(eFlags & (kDbgFileInfo | kDbgFileInfoLong), strArg1, pszFileName, uLine);

    (VOID)GetParameter(eFlags & (kDbgTimeStamp | kDbgTimeStampLong), strArg2, NULL, 0);

    (VOID)GetParameter(eFlags & kDbgThreadId, strArg3, NULL, 0);

    if ((eLevel & kDbgUnicode) == (m_eLevel & kDbgUnicode))
    {
        pszFormat = _T("%s%s%s%s %s");
    }
    else
    {
        pszFormat = _T("%s%s%s%s %S");
    }

    (VOID)strFinal.bFormat( pszFormat,
                            static_cast<LPCTSTR>(strArg0),
                            static_cast<LPCTSTR>(strArg1),
                            static_cast<LPCTSTR>(strArg2),
                            static_cast<LPCTSTR>(strArg3),
                            StrMsg.pszByte);

    return strFinal.bValid();
}


/*++

Routine Name:

    GetParameter

Routine Description:

    This function get the parameter for the additinal information
    displayed in a format string.  The flags passed to the message
    class and to the message function are used a guide.

Arguments:

    eFlags      - Flags indicating what parameter to get.
    strString   - place were to return resultant string.
    pszFileName - pointer to file name to format if requested.
    uLine       - line number for file name format.

Return Value:

    TRUE parmeter was returned in strString, FALSE error.

--*/
BOOL
TDebugMsg::
GetParameter(
    IN UINT                 eFlags,
    IN OUT  TDebugString    &strString,
    IN      LPCTSTR         pszFileName,
    IN      UINT            uLine
    ) const
{
    BOOL bRetval = TRUE;

    if (eFlags & kDbgFileInfo)
    {
        bRetval = strString.bFormat(*m_pstrFileInfoFormat, StripPathFromFileName(pszFileName), uLine);
    }

    if (eFlags & kDbgFileInfoLong)
    {
        bRetval = strString.bFormat(*m_pstrFileInfoFormat, pszFileName, uLine);
    }

    if (eFlags & kDbgTimeStamp)
    {
        bRetval = strString.bFormat(*m_pstrTimeStampFormatShort, GetTickCount());
    }

    if (eFlags & kDbgTimeStampLong)
    {
        TCHAR       szBuffer[MAX_PATH];
        SYSTEMTIME  Time;

        GetSystemTime(&Time);

        bRetval = SystemTimeToTzSpecificLocalTime(NULL, &Time, &Time) &&
                  GetTimeFormat(LOCALE_USER_DEFAULT, 0, &Time, NULL, szBuffer, COUNTOF(szBuffer)) &&
                  strString.bFormat(*m_pstrTimeStampFormatLong, szBuffer);
    }

    if (eFlags & kDbgThreadId)
    {
        bRetval = strString.bFormat(*m_pstrThreadIdFormat, GetCurrentThreadId());
    }

    return bRetval;
}


/*++

Routine Name:

    SetMessageFieldFormat

Routine Description:

    This routing allows individual parts of the format string
    to have a custom format string specifier.

Arguments:

    Field - specified which format field to change.
    pszFormat - new format string, the caller must know the correct type.

Return Value:

    None.

--*/
VOID
TDebugMsg::
SetMessageFieldFormat(
    IN UINT         eField,
    IN LPTSTR       pszFormat
    )
{
    //
    // Set the new format string.
    //
    if (eField & kDbgFileInfo)
    {
        m_pstrFileInfoFormat->bUpdate(pszFormat);
    }

    if (eField & kDbgFileInfoLong)
    {
        m_pstrFileInfoFormat->bUpdate(pszFormat);
    }

    if (eField & kDbgTimeStamp)
    {
        m_pstrTimeStampFormatShort->bUpdate(pszFormat);
    }

    if (eField & kDbgTimeStampLong)
    {
        m_pstrTimeStampFormatLong->bUpdate(pszFormat);
    }

    if (eField & kDbgThreadId)
    {
        m_pstrThreadIdFormat->bUpdate(pszFormat);
    }

    //
    // If any of the format strings were cleared then
    // reset them back to the default value.
    //
    if (m_pstrFileInfoFormat->bEmpty())
    {
        m_pstrFileInfoFormat->bUpdate(kstrFileInfoFormat);
    }

    if (m_pstrTimeStampFormatShort->bEmpty())
    {
        m_pstrTimeStampFormatShort->bUpdate(kstrTimeStampFormatShort);
    }

    if (m_pstrTimeStampFormatLong->bEmpty())
    {
        m_pstrTimeStampFormatLong->bUpdate(kstrTimeStampFormatLong);
    }

    if (m_pstrThreadIdFormat->bEmpty())
    {
        m_pstrThreadIdFormat->bUpdate(kstrThreadIdFormat);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgnew.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgnew.cxx

Abstract:

    Debug new

Author:

    Steve Kiraly (SteveKi)  23-June-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgnewp.hxx"

namespace
{
    TDebugNewAllocator  DebugNew;
    UINT                DebugNewCrtEnabled;
}

extern "C"
BOOL
TDebugNew_CrtMemoryInitalize(
    VOID
    )
{
    //
    // Indicated that debugging memory support is enabled.
    //
    return DebugNewCrtEnabled++;
}

extern "C"
BOOL
TDebugNew_IsCrtMemoryInitalized(
    VOID
    )
{
    //
    // Is debugging memory support is enabled.
    //
    return DebugNewCrtEnabled > 0;
}

extern "C"
BOOL
TDebugNew_Initalize(
    IN UINT uHeapSizeHint
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access the heap.
    //
    TDebugCriticalSection::TLock CS( GlobalCriticalSection );

    //
    // Create the debug new class.
    //
    DebugNew.Initialize( uHeapSizeHint );

    //
    // Check if the Debug new class was initialize correctly.
    //
    return DebugNew.bValid();
}

extern "C"
VOID
TDebugNew_Destroy(
    VOID
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access the heap.
    //
    TDebugCriticalSection::TLock CS( GlobalCriticalSection );

    //
    // Destroy the debug new class.
    //
    DebugNew.Destroy();
}

extern "C"
PVOID
TDebugNew_New(
    IN SIZE_T   Size,
    IN PVOID    pVoid,
    IN LPCTSTR  pszFile,
    IN UINT     uLine
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access the heap.
    //
    TDebugCriticalSection::TLock CS( GlobalCriticalSection );

    //
    // Return the allocated memory.
    //
    return DebugNew.Allocate( Size, pVoid, pszFile, uLine );
}

extern "C"
VOID
TDebugNew_Delete(
    IN PVOID    pVoid
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access the heap.
    //
    TDebugCriticalSection::TLock CS( GlobalCriticalSection );

    //
    // Return the allocated memory.
    //
    DebugNew.Release( pVoid );
}

extern "C"
VOID
TDebugNew_Report(
    VOID
    )
{
    //
    // Initialize the debug library, it not already initialized.
    //
    DebugLibraryInitialize();

    //
    // Hold the critical section while we access the heap.
    //
    TDebugCriticalSection::TLock CS( GlobalCriticalSection );

    //
    // Return the allocated memory.
    //
    DebugNew.Report( 0, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgnul.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgnul.cxx

Abstract:

    Debug Device (Null device)

Author:

    Steve Kiraly (SteveKi)  5-Dec-1995

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgnul.hxx"

TDebugDeviceNull::
TDebugDeviceNull(
    IN LPCTSTR      pszConfiguration,
    IN EDebugType   eDebugType
    ) : TDebugDevice( pszConfiguration, eDebugType )
{
}

TDebugDeviceNull::
~TDebugDeviceNull(
    VOID
    )
{
}

BOOL
TDebugDeviceNull::
bValid(
    VOID
    )
{
    return TRUE;
}

BOOL
TDebugDeviceNull::
bOutput (
    IN UINT     uSize,
    IN LPBYTE   pBuffer
    )
{
    uSize++;
    pBuffer++;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgperf.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation
All rights reserved.

Module Name:

    dbgperf.cxx

Abstract:

    Debug Library Performance counter

Author:

    Steve Kiraly (SteveKi)  22-Jun-2000

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgnewp.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgnewp.cxx

Abstract:

    Debug new private file

Author:

    Steve Kiraly (SteveKi)  23-June-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgtag.hxx"
#include "dbgnewp.hxx"

TDebugNewAllocator::
TDebugNewAllocator(
    VOID
    ) : m_bValid( FALSE ),
        m_hDataHeap( NULL ),
        m_pTag( NULL )
{
}

TDebugNewAllocator::
~TDebugNewAllocator(
    VOID
    )
{
    Destroy();
}

BOOL
TDebugNewAllocator::
bValid(
    VOID
    ) const
{
    return m_bValid;
}


VOID
TDebugNewAllocator::
Initialize(
    IN UINT uSizeHint
    )
{
    m_pTag = INTERNAL_NEW TDebugNewTag();

    m_hDataHeap = HeapCreate( 0, kDataHeapSize, 0 );

    if (m_hDataHeap && m_pTag->bInit() )
    {
        m_bValid = TRUE;
    }
}

VOID
TDebugNewAllocator::
Destroy(
    VOID
    )
{
    if (m_hDataHeap)
    {
        HeapDestroy( m_hDataHeap );
    }

    INTERNAL_DELETE m_pTag;
}


//
// Allocate a new memory block, tracking the allocation for
// leak detection.
//
PVOID
TDebugNewAllocator::
Allocate(
    IN SIZE_T   Size,
    IN PVOID    pVoid,
    IN LPCTSTR  pszFile,
    IN UINT     uLine
    )
{
    //
    // Allocate the memory block.
    //
    Header *pHeader = reinterpret_cast<Header *>( HeapAlloc( m_hDataHeap,
                                                             0,
                                                             sizeof( Header ) + Size + sizeof( Tail ) ) );
    //
    // If the block was allocated successfully.
    //
    if (pHeader)
    {
        //
        // Track this memory allocation.
        //
        if( m_pTag->Tag( &pHeader->pTag, pHeader, Size, pszFile, uLine ) )
        {
            //
            // Set the header data and tail pattern.  The tag back pointer is
            // is set for efficent release, the data area is filled with a known pattern
            // and tail is filled with a known pattern for overwrite detection.
            //
            FillHeaderDataTailPattern( pHeader, Size );

            //
            // Adjust returned pointer to client data area.
            //
            pHeader++;
        }
        else
        {
            //
            // Tag entry was not available, something horrible happened.
            // If this happens then clean up the allocation and
            // return failure for this allocation.
            //
            HeapFree( m_hDataHeap, 0, pHeader );
            pHeader = NULL;
        }
    }

    return pHeader;
}

//
// Release the memory block, checking for duplicate frees and
// tail overwrites.
//
VOID
TDebugNewAllocator::
Release(
    IN PVOID pVoid
    )
{
    //
    // Convert the client data area pointer to header pointer.
    //
    Header *pHeader = reinterpret_cast<Header *>( pVoid ) - 1;

    //
    // Validate the header and tail signatures.
    //
    ValidationErrorCode ValidationError = ValidateHeaderDataTailPattern( pVoid, pHeader );

    switch (ValidationError)
    {
    case kValidationErrorSuccess:

        //
        // Release allocation from tag list.
        //
        m_pTag->Release( pHeader->pTag );

        //
        // Release this block back to the heap.
        //
        HeapFree( m_hDataHeap, 0, pHeader );
        break;

    case kValidationErrorNullPointer:
        //
        // It is ok to attempt to free the null pointer.
        //
        break;

    //
    // We leak memory allocations that fail header, tail or tag validation.
    //
    case kValidationErrorInvalidHeader:
        ErrorText( _T("Buffer failed header validation\n") );
        break;

    case kValidationErrorInvalidTail:
        ErrorText( _T("Buffer failed tail validation\n") );
        break;

    case kValidationErrorUnknown:
    default:
        ErrorText( _T("Buffer failed validation\n") );
        break;
    }
}

VOID
TDebugNewAllocator::
Report(
    IN UINT     uDevice,
    IN LPCTSTR  pszConfiguration
    ) const
{
    m_pTag->DisplayInuseTagEntries( uDevice, pszConfiguration );
}

/********************************************************************

 Private member functions.

********************************************************************/

VOID
TDebugNewAllocator::
FillHeaderDataTailPattern(
    IN Header *pHeader,
    IN SIZE_T   Size
    )
{
    //
    // Fill the header pattern.
    //
    memset( &pHeader->pSignature, kHeaderPattern, sizeof( PVOID ) );

    //
    // Fill the Data pattern.
    //
    memset( ++pHeader, kDataAllocPattern, Size );

    //
    // Calculate the tail pointer.
    //
    Tail *pTail = reinterpret_cast<Tail *>( reinterpret_cast<PBYTE>( pHeader ) + Size );

    //
    // Write the tail pattern.
    //
    memset( &pTail->pSignature, kTailPattern, sizeof( PVOID ) );
}

TDebugNewAllocator::ValidationErrorCode
TDebugNewAllocator::
ValidateHeaderDataTailPattern(
    IN PVOID    pVoid,
    IN Header   *pHeader
    )
{
    if (!pVoid)
    {
        return kValidationErrorNullPointer;
    }

    //
    // Validate the header pointer.
    //
    if (!pHeader)
    {
        return kValidationErrorInvalidHeaderPtr;
    }

    //
    // Validate the header structure.
    //
    if (IsBadReadPtr( pHeader, sizeof( Header )))
    {
        return kValidationErrorInvalidHeader;
    }

    //
    // Validate the header signature.
    //
    PVOID pTemp;

    memset( &pTemp, kHeaderPattern, sizeof( PVOID ) );

    if (pHeader->pSignature != pTemp)
    {
        return kValidationErrorInvalidHeaderSignature;
    }

    //
    // Validate the tag entry.
    //
    switch (m_pTag->ValidateEntry( pHeader->pTag ))
    {
    case TDebugNewTag::kValidationErrorInvalidPointer:
        break;

    case TDebugNewTag::kValidationErrorInvalidHeader:
        break;

    case TDebugNewTag::kValidationErrorTagNotLinked:
        break;

    case TDebugNewTag::kValidationErrorUnknown:
    default:
        break;
    }

    //
    // Get the tail pointer.
    //
    Tail *pTail = reinterpret_cast<Tail *>( reinterpret_cast<PBYTE>(pHeader+1)+m_pTag->GetSize( pHeader->pTag ) );

    //
    // Validate the tail structure.
    //
    if (IsBadReadPtr( pTail, sizeof( Tail )))
    {
        return kValidationErrorInvalidTailPointer;
    }

    //
    // Validate the tail signature.
    //
    memset( &pTemp, kTailPattern, sizeof( PVOID ) );

    if( pTail->pSignature != pTemp )
    {
        return kValidationErrorInvalidTailSignature;
    }

    return kValidationErrorSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgreg.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgreg.cxx

Abstract:

    Debug Registry class

Author:

    Steve Kiraly (SteveKi)  18-Jun-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgloadl.hxx"
#include "dbgreg.hxx"

TDebugRegApis::
TDebugRegApis(
    VOID
    ) : m_Lib( _T("advapi32.dll") ),
        m_bValid( FALSE ),
        m_CreateKeyEx (NULL ),
        m_OpenKeyEx( NULL ),
        m_CloseKey( NULL ),
        m_QueryValueEx( NULL ),
        m_SetValueEx( NULL ),
        m_EnumKeyEx( NULL ),
        m_DeleteKey( NULL )
{
    if( m_Lib.bValid() )
    {
        m_CreateKeyEx     = reinterpret_cast<pfRegCreateKeyEx>    ( m_Lib.pfnGetProc( "RegCreateKeyEx"    SUFFIX ) );
        m_OpenKeyEx       = reinterpret_cast<pfRegOpenKeyEx>      ( m_Lib.pfnGetProc( "RegOpenKeyEx"      SUFFIX ) );
        m_CloseKey        = reinterpret_cast<pfRegCloseKey>       ( m_Lib.pfnGetProc( "RegCloseKey"       ) );
        m_QueryValueEx    = reinterpret_cast<pfRegQueryValueEx>   ( m_Lib.pfnGetProc( "RegQueryValueEx"   SUFFIX ) );
        m_SetValueEx      = reinterpret_cast<pfRegSetValueEx>     ( m_Lib.pfnGetProc( "RegSetValueEx"     SUFFIX ) );
        m_EnumKeyEx       = reinterpret_cast<pfRegEnumKeyEx>      ( m_Lib.pfnGetProc( "RegEnumKeyEx"      SUFFIX ) );
        m_DeleteKey       = reinterpret_cast<pfRegDeleteKey>      ( m_Lib.pfnGetProc( "RegDeleteKey"      SUFFIX ) );
        m_DeleteValue     = reinterpret_cast<pfRegDeleteValue>    ( m_Lib.pfnGetProc( "RegDeleteValue"    SUFFIX ) );

        if( m_CreateKeyEx     &&
            m_OpenKeyEx       &&
            m_CloseKey        &&
            m_QueryValueEx    &&
            m_SetValueEx      &&
            m_EnumKeyEx       &&
            m_DeleteKey       &&
            m_DeleteValue )
        {
            m_bValid = TRUE;
        }
    }
}

BOOL
TDebugRegApis::
bValid(
    VOID
    ) const
{
    return m_bValid;
}

TDebugRegistry::
TDebugRegistry(
    IN LPCTSTR pszSection,
    IN UINT    ioFlags,
    IN HKEY    hOpenedKey
    ) : m_strSection( pszSection ),
        m_hKey( NULL ),
        m_Status( ERROR_SUCCESS )
{
    DBG_ASSERT( pszSection );
    DBG_ASSERT( hOpenedKey );

    if( m_Reg.bValid() )
    {
        DWORD dwDisposition = 0;
        UINT  uAccessIndex  = 0;

        static DWORD adwAccess []  = { 0, KEY_READ, KEY_WRITE, KEY_ALL_ACCESS };

        uAccessIndex = ioFlags & ( kRead | kWrite );

        if( uAccessIndex )
        {
            if( ioFlags & kCreate )
            {
                m_Status = m_Reg.m_CreateKeyEx( hOpenedKey,
                                                m_strSection,
                                                0,
                                                NULL,
                                                0,
                                                adwAccess[ uAccessIndex ],
                                                NULL,
                                                &m_hKey,
                                                &dwDisposition );
            }

            if( ioFlags & kOpen )
            {
                m_Status = m_Reg.m_OpenKeyEx( hOpenedKey,
                                              m_strSection,
                                              0,
                                              adwAccess[ uAccessIndex ],
                                              &m_hKey );
            }
        }
    }
}

TDebugRegistry::
~TDebugRegistry(
    VOID
    )
{
    if( m_hKey )
    {
        m_Reg.m_CloseKey( m_hKey );
    }
}

BOOL
TDebugRegistry::
bValid(
    VOID
    ) const
{
    //
    // A valid hKey and a valid section name is the class valid check.
    //
    return m_hKey != NULL && m_strSection.bValid() && m_Reg.bValid();
}

DWORD
TDebugRegistry::
LastError(
    VOID
    ) const
{
    return m_Status;
}

BOOL
TDebugRegistry::
bRead(
    IN      LPCTSTR  pValueName,
    IN OUT  DWORD    &dwValue
    )
{
    DBG_ASSERT( bValid() );
    DBG_ASSERT( pValueName );

    DWORD dwType    = REG_DWORD;
    DWORD dwSize    = sizeof( dwValue );

    m_Status = m_Reg.m_QueryValueEx( m_hKey,
                                     pValueName,
                                     NULL,
                                     &dwType,
                                     reinterpret_cast<LPBYTE>( &dwValue ),
                                     &dwSize );

    return m_Status == ERROR_SUCCESS && dwType == REG_DWORD;
}

BOOL
TDebugRegistry::
bRead(
    IN      LPCTSTR  pValueName,
    IN OUT  BOOL     &bValue
    )
{
    DBG_ASSERT( bValid() );
    DBG_ASSERT( pValueName );

    DWORD dwType    = REG_DWORD;
    DWORD dwSize    = sizeof( bValue );

    m_Status = m_Reg.m_QueryValueEx( m_hKey,
                                     pValueName,
                                     NULL,
                                     &dwType,
                                     reinterpret_cast<LPBYTE>( &bValue ),
                                     &dwSize );

    return m_Status == ERROR_SUCCESS && dwType == REG_DWORD;
}

BOOL
TDebugRegistry::
bRead(
    IN      LPCTSTR         pValueName,
    IN OUT  TDebugString    &strValue
    )
{
    DBG_ASSERT( bValid() );
    DBG_ASSERT( pValueName );

    TCHAR szBuffer[kHint];
    DWORD dwType    = REG_SZ;
    BOOL  bStatus   = FALSE;
    DWORD dwSize    = sizeof( szBuffer );

    m_Status = m_Reg.m_QueryValueEx( m_hKey,
                                     pValueName,
                                     NULL,
                                     &dwType,
                                     reinterpret_cast<LPBYTE>( szBuffer ),
                                     &dwSize );

    if( m_Status == ERROR_MORE_DATA && dwType == REG_SZ && dwSize )
    {
        LPTSTR pszBuff = INTERNAL_NEW TCHAR[ dwSize ];

        if( pszBuff )
        {
            m_Status = m_Reg.m_QueryValueEx( m_hKey,
                                             pValueName,
                                             NULL,
                                             &dwType,
                                             reinterpret_cast<LPBYTE>( pszBuff ),
                                             &dwSize );
        }
        else
        {
            m_Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        if( m_Status == ERROR_SUCCESS )
        {
            bStatus = strValue.bUpdate( pszBuff );
        }

        INTERNAL_DELETE [] pszBuff;

    }
    else
    {
        if( m_Status == ERROR_SUCCESS && dwType == REG_SZ )
        {
            bStatus = strValue.bUpdate( szBuffer );
        }
    }

    return bStatus;
}

BOOL
TDebugRegistry::
bRead(
    IN      LPCTSTR  pValueName,
    IN OUT  PVOID    pValue,
    IN      DWORD    cbSize,
    IN      LPDWORD  pcbNeeded  OPTIONAL
    )
{
    DBG_ASSERT( bValid() );
    DBG_ASSERT( pValueName );
    DBG_ASSERT( pValue );

    DWORD dwType    = REG_BINARY;
    BOOL  bStatus   = FALSE;
    DWORD dwSize    = cbSize;

    m_Status = m_Reg.m_QueryValueEx( m_hKey,
                                     pValueName,
                                     NULL,
                                     &dwType,
                                     reinterpret_cast<LPBYTE>( pValue ),
                                     &dwSize );

    if( m_Status == ERROR_MORE_DATA && pcbNeeded )
    {
        *pcbNeeded = dwSize;
    }

    return m_Status == ERROR_SUCCESS && dwType == REG_BINARY && dwSize == cbSize;
}

BOOL
TDebugRegistry::
bWrite(
    IN       LPCTSTR  pValueName,
    IN const DWORD    dwValue
    )
{
    DBG_ASSERT( bValid() );
    DBG_ASSERT( pValueName );

    m_Status = m_Reg.m_SetValueEx( m_hKey,
                                   pValueName,
                                   0,
                                   REG_DWORD,
                                   reinterpret_cast<const BYTE *>( &dwValue ),
                                   sizeof( dwValue ) );

    return m_Status == ERROR_SUCCESS;
}

BOOL
TDebugRegistry::
bWrite(
    IN       LPCTSTR  pValueName,
    IN       LPCTSTR  pszValue
    )
{
    DBG_ASSERT( bValid() );
    DBG_ASSERT( pValueName );

    m_Status = m_Reg.m_SetValueEx( m_hKey,
                                   pValueName,
                                   0,
                                   REG_SZ,
                                   reinterpret_cast<const BYTE *>( pszValue ),
                                   _tcslen( pszValue ) * sizeof( TCHAR ) + sizeof( TCHAR ) );

    return m_Status == ERROR_SUCCESS;
}

BOOL
TDebugRegistry::
bWrite(
    IN       LPCTSTR  pValueName,
    IN const PVOID    pValue,
    IN       DWORD    cbSize
    )
{
    DBG_ASSERT( bValid() );
    DBG_ASSERT( pValueName );
    DBG_ASSERT( pValue );

    m_Status = m_Reg.m_SetValueEx( m_hKey,
                                   pValueName,
                                   0,
                                   REG_BINARY,
                                   reinterpret_cast<const BYTE *>( pValue ),
                                   cbSize );

    return m_Status == ERROR_SUCCESS;
}

BOOL
TDebugRegistry::
bRemove(
    IN LPCTSTR  pValueName
    )
{
    DBG_ASSERT( bValid() );
    DBG_ASSERT( pValueName );

    m_Status = m_Reg.m_DeleteValue( m_hKey, pValueName );

    return m_Status == ERROR_SUCCESS;
}

BOOL
TDebugRegistry::
bRemoveKey(
    IN LPCTSTR  pKeyName
    )
{
    DBG_ASSERT( bValid() );
    DBG_ASSERT( pKeyName );

    m_Status = dwRecursiveRegDeleteKey( m_hKey, pKeyName );

    return m_Status == ERROR_SUCCESS;
}

DWORD
TDebugRegistry::
dwRecursiveRegDeleteKey(
    IN HKEY     hKey,
    IN LPCTSTR  pszSubkey
    ) const
{
    HKEY hSubkey = NULL;

    DWORD dwStatus = m_Reg.m_OpenKeyEx( hKey,
                                      pszSubkey,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hSubkey );

    while ( dwStatus == ERROR_SUCCESS )
    {
        TCHAR szSubkey[ MAX_PATH ];
        DWORD cbSubkeySize = COUNTOF( szSubkey );

        dwStatus = m_Reg.m_EnumKeyEx( hSubkey,
                                    0,
                                    szSubkey,
                                    &cbSubkeySize,
                                    0,
                                    0,
                                    0,
                                    0 );

        if( dwStatus == ERROR_NO_MORE_ITEMS )
            break;

        if( dwStatus != ERROR_SUCCESS )
            return dwStatus;

        dwStatus = dwRecursiveRegDeleteKey( hSubkey, szSubkey );
    }

    if( hSubkey )
    {
        m_Reg.m_CloseKey( hSubkey );
    }

    dwStatus = m_Reg.m_DeleteKey( hKey, pszSubkey );

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgtag.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgtag.cxx

Abstract:

    Debug tag class

Author:

    Steve Kiraly (SteveKi)  27-June-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgtag.hxx"

TDebugNewTag::
TDebugNewTag(
    VOID
    ) : m_bInitialized( FALSE ),
        m_hTagHeap( NULL ),
        m_pFreeRoot( NULL ),
        m_pInuseRoot( NULL )
{
    //
    // Create the debug tag heap.
    //
    m_hTagHeap = HeapCreate( 0, kDefaultEntryCount * sizeof( TagEntry ), 0 );

    //
    // If the tag heap was allocated.
    //
    if (m_hTagHeap)
    {
        //
        // Allocate the free list.
        //
        if (AllocFreeList( kDefaultEntryCount, &m_pFreeRoot ))
        {
            m_bInitialized = TRUE;
        }
    }
}

TDebugNewTag::
~TDebugNewTag(
    VOID
    )
{
    //
    // Destroy the debug tag heap.
    //
    if (m_hTagHeap)
    {
        HeapDestroy( m_hTagHeap );
    }
}

BOOL
TDebugNewTag::
bInit(
    VOID
    )
{
    return m_bInitialized;
}

BOOL
TDebugNewTag::
Tag(
    IN VOID     **pp,
    IN PVOID    pHeader,
    IN SIZE_T   Size,
    IN LPCTSTR  pszFile,
    IN UINT     uLine
    )
{
    //
    // If the free list is empty
    //
    if (!m_pFreeRoot)
    {
        //
        // Allocate a new chuck for the free list.
        //
        AllocFreeList( kDefaultEntryCount, &m_pFreeRoot );
    }

    if (m_pFreeRoot)
    {
        //
        // Remove this entry from the tag free list.
        //
        TagEntry *pTagEntry = m_pFreeRoot;

        //
        // Remove entry from free list.
        //
        pTagEntry->Remove( reinterpret_cast<TDebugNodeDouble **>( &m_pFreeRoot ) );

        //
        // Insert the entry on in use list.
        //
        pTagEntry->Insert( reinterpret_cast<TDebugNodeDouble **>( &m_pInuseRoot ) );

        //
        // Save entry data.
        //
        pTagEntry->pHeader  = pHeader;
        pTagEntry->Size     = Size;
        pTagEntry->pszFile  = pszFile;
        pTagEntry->uLine    = uLine;

        //
        // Copy back the allocated tag entry.
        //
        *pp = pTagEntry;
    }

    return TRUE;
}

BOOL
TDebugNewTag::
Release(
    IN PVOID pTag
    )
{
    BOOL bRetval = FALSE;

    //
    // Get tag entry.
    //
    TagEntry *pTagEntry = reinterpret_cast<TagEntry *>( pTag );

    //
    // Is this node a member of the tag list.
    //
    if (pTagEntry)
    {
        //
        // Check if the entry is a member of the tag list.
        //
        if (pTagEntry->Prev() == reinterpret_cast<TDebugNodeDouble *>( this ) && pTagEntry->Next() == reinterpret_cast<TDebugNodeDouble *>( this ) )
        {
            if (pTagEntry == m_pInuseRoot)
            {
                bRetval = TRUE;
            }
        }
        else
        {
            bRetval = TRUE;
        }

        if (bRetval)
        {
            //
            // Remove this entry from the tag list.
            //
            pTagEntry->Remove( reinterpret_cast<TDebugNodeDouble **>( &m_pInuseRoot ) );

            //
            // Place the entry on the free list.
            //
            pTagEntry->Insert( reinterpret_cast<TDebugNodeDouble **>( &m_pFreeRoot ) );
        }
    }
    return bRetval;
}


VOID
TDebugNewTag::
DisplayInuseTagEntries(
    IN UINT     uDevice,
    IN LPCTSTR  pszConfiguration
    )
{
    //
    // Get access to the debug factory.
    //
    TDebugFactory DebugFactory;

    //
    // If we failed to create the debug factory then exit.
    //
    if (DebugFactory.bValid())
    {
        //
        // Create the specified debug device using the factory.
        //
        TDebugDevice *pDebugDevice = DebugFactory.Produce(uDevice, pszConfiguration, Globals.CompiledCharType);

        //
        // If a debug device was created.
        //
        if (pDebugDevice)
        {
            //
            // Dump the inuse list.
            //
            TDebugNodeDouble::Iterator Iter(m_pInuseRoot);

            for( Iter.First(); !Iter.IsDone(); Iter.Next() )
            {
                static_cast<TagEntry *>(Iter.Current() )->Dump(pDebugDevice);
            }

            //
            // Release the output device.
            //
            INTERNAL_DELETE pDebugDevice;
        }
    }
}


TDebugNewTag::EValidationError
TDebugNewTag::
ValidateEntry(
    IN PVOID    pTag
    )
{
    return kValidationErrorSuccess;
}

SIZE_T
TDebugNewTag::
GetSize(
    IN PVOID    pTag
    )
{
    TagEntry *pTagEntry = reinterpret_cast<TagEntry *>( pTag );
    return pTagEntry->Size;
}

/********************************************************************

 Private member functions.

********************************************************************/

BOOL
TDebugNewTag::
AllocFreeList(
    IN UINT     uCount,
    IN TagEntry **ppTagEntry
    )
{
    BOOL bRetval = FALSE;

    *ppTagEntry = reinterpret_cast<TagEntry *>( HeapAlloc( m_hTagHeap, 0, uCount * sizeof( TagEntry ) ) );

    if (*ppTagEntry)
    {
        TagEntry *pTagEntry = *ppTagEntry;

        for( UINT i = 0; i < uCount; i++, pTagEntry++ )
        {
            pTagEntry = INTERNAL_NEWP(pTagEntry) TagEntry;

            pTagEntry->Insert( (TDebugNodeDouble **)ppTagEntry );
        }

        bRetval = TRUE;
    }


    return bRetval;
}


TDebugNewTag::TagEntry::
TagEntry(
    VOID
    )
{
}

TDebugNewTag::TagEntry::
~TagEntry(
    VOID
    )
{
}

VOID
TDebugNewTag::TagEntry::
Dump(
    IN TDebugDevice *pDevice
    )
{
    TDebugString strOutput;

    strOutput.bFormat( _T("Leak: Size %d Address %x File %s Line %d\n"),
                       Size,
                       pHeader,
                       StripPathFromFileName( pszFile ),
                       uLine );

    pDevice->bOutput( strOutput.uLen() * sizeof( TCHAR ),
                      reinterpret_cast<LPBYTE>( const_cast<LPTSTR>( static_cast<LPCTSTR>( strOutput ) ) ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgsterm.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgsterm.cxx

Abstract:

    Debug Device Null device

Author:

    Steve Kiraly (SteveKi)  5-Dec-1995

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgsterm.hxx"

TDebugDeviceSerialTerminal::
TDebugDeviceSerialTerminal(
    IN LPCTSTR      pszConfiguration,
    IN EDebugType   eDebugType
    ) : TDebugDevice( pszConfiguration, eDebugType )
{
}

TDebugDeviceSerialTerminal::
~TDebugDeviceSerialTerminal(
    VOID
    )
{
}

BOOL
TDebugDeviceSerialTerminal::
bValid(
    VOID
    )
{
    return FALSE;
}

BOOL
TDebugDeviceSerialTerminal::
bOutput (
    IN UINT     uSize,
    IN LPBYTE   pBuffer
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgreslt.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgreslt.cxx

Abstract:

    Error result help class

Author:

    Steve Kiraly (SteveKi)  03-20-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgreslt.hxx"

TDebugResult::
TDebugResult(
    IN DWORD dwError
    ) : m_dwError( dwError ),
        m_pszError( NULL )
{
}

TDebugResult::
~TDebugResult(
    VOID
    )
{
    //
    // Release any allocated error string.
    //
    if( m_pszError && m_pszError != kstrNull )
    {
        LocalFree( const_cast<LPTSTR>( m_pszError ) );
    }
}

BOOL
TDebugResult::
bValid(
    VOID
    ) const
{
    return TRUE;
}

TDebugResult::
operator DWORD(
    VOID
    )
{
    return m_dwError;
}

LPCTSTR
TDebugResult::
GetErrorString(
    VOID
    )
{
    DWORD   cchReturn   = 0;
    DWORD   dwFlags     = 0;

    //
    // Release any allocated error string.
    //
    if( m_pszError && m_pszError != kstrNull )
    {
        LocalFree( const_cast<LPTSTR>( m_pszError ) );
    }

    //
    // Set the format message flags.
    //
    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
              FORMAT_MESSAGE_IGNORE_INSERTS  |
              FORMAT_MESSAGE_FROM_SYSTEM     |
              FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    // Format the message with the passed in last error.
    //
    cchReturn = FormatMessage( dwFlags,
                               NULL,
                               m_dwError,
                               0,
                               reinterpret_cast<LPTSTR>( &m_pszError ),
                               0,
                               NULL );

    //
    // If a format string was not returned set the string to null.
    //
    if( !cchReturn )
    {
        m_pszError = kstrNull;
    }

    return m_pszError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgstate.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgstate.cxx

Abstract:

    status support

Author:

    Steve Kiraly (SteveKi)  2-Mar-1997

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "dbgreslt.hxx"
#include "dbgstate.hxx"

#if DBG

/********************************************************************

    Debugging TStatus base members

********************************************************************/

TStatusBase::
TStatusBase(
    IN BOOL dwStatus,
    IN UINT uDbgLevel
    ) : m_dwStatus(dwStatus),
        m_uDbgLevel(uDbgLevel),
        m_dwStatusSafe1(-1),
        m_dwStatusSafe2(-1),
        m_dwStatusSafe3(-1),
        m_uLine(0),
        m_pszFile(NULL)
{
}

TStatusBase::
~TStatusBase(
    VOID
    )
{
}

TStatusBase&
TStatusBase::
pNoChk(
    VOID
    )
{
    m_pszFile    = NULL;
    m_uLine      = 0;
    return (TStatusBase&)*this;
}

TStatusBase&
TStatusBase::
pSetInfo(
    UINT uLine,
    LPCTSTR pszFile
    )
{
    m_uLine     = uLine;
    m_pszFile   = pszFile;
    return (TStatusBase&)*this;
}

VOID
TStatusBase::
pConfig(
    IN UINT     uDbgLevel,
    IN DWORD    dwStatusSafe1,
    IN DWORD    dwStatusSafe2,
    IN DWORD    dwStatusSafe3
    )
{
    m_uDbgLevel     = uDbgLevel;
    m_dwStatusSafe1 = dwStatusSafe1;
    m_dwStatusSafe2 = dwStatusSafe2;
    m_dwStatusSafe3 = dwStatusSafe3;
}

DWORD
TStatusBase::
dwGeTStatusBase(
    VOID
    ) const
{
    //
    // Assert if we are reading an UnInitalized variable.
    //
    if (m_dwStatus == kUnInitializedValue)
    {
        DBG_MSG(kDbgAlways|kDbgNoFileInfo, (_T("***Read of UnInitialized TStatus variable!***\n")));
        DBG_BREAK();
    }

    //
    // Return the error value.
    //
    return m_dwStatus;
}

DWORD
TStatusBase::
operator=(
    IN DWORD dwStatus
    )
{
    //
    // Do nothing if the file and line number are cleared.
    // This is the case when the NoChk method is used.
    //
    if (m_uLine && m_pszFile)
    {
        //
        // Get the last error value.
        //
        DWORD LastError = GetLastError();

        //
        // Check if we have an error, and it's not one of the accepted "safe" errors.
        //
        if (dwStatus != ERROR_SUCCESS &&
            dwStatus != m_dwStatusSafe1 &&
            dwStatus != m_dwStatusSafe2 &&
            dwStatus != m_dwStatusSafe3)
        {
            //
            // Convert the last error value to a string.
            //
            TDebugResult Result(dwStatus);

            DBG_MSG(m_uDbgLevel, (_T("TStatus failure, %d, %s\n%s %d\n"), dwStatus, Result.GetErrorString(), m_pszFile, m_uLine));
        }

        //
        // Restore the last error, the message call may have destoyed the last
        // error value, we don't want the caller to loose this value.
        //
        SetLastError(LastError);
    }

    return m_dwStatus = dwStatus;
}

TStatusBase::
operator DWORD(
    VOID
    ) const
{
    return dwGeTStatusBase();
}

/********************************************************************

    Debugging TStatus members

********************************************************************/

TStatus::
TStatus(
    IN DWORD dwStatus
    ) : TStatusBase(dwStatus, kDbgWarning)
{
}

TStatus::
~TStatus(
    VOID
    )
{
}

/********************************************************************

    Debugging TStatusB base members

********************************************************************/

TStatusBBase::
TStatusBBase(
    IN BOOL bStatus,
    IN UINT uDbgLevel
    ) : m_bStatus(bStatus),
        m_uDbgLevel(uDbgLevel),
        m_dwStatusSafe1(-1),
        m_dwStatusSafe2(-1),
        m_dwStatusSafe3(-1),
        m_uLine(0),
        m_pszFile(NULL)
{
}

TStatusBBase::
~TStatusBBase(
    VOID
    )
{
}

TStatusBBase&
TStatusBBase::
pNoChk(
    VOID
    )
{
    m_pszFile    = NULL;
    m_uLine      = 0;
    return (TStatusBBase&)*this;
}

TStatusBBase&
TStatusBBase::
pSetInfo(
    IN UINT     uLine,
    IN LPCTSTR  pszFile
    )
{
    m_uLine      = uLine;
    m_pszFile    = pszFile;
    return (TStatusBBase&)*this;
}

VOID
TStatusBBase::
pConfig(
    IN UINT     uDbgLevel,
    IN DWORD    dwStatusSafe1,
    IN DWORD    dwStatusSafe2,
    IN DWORD    dwStatusSafe3
    )
{
    m_uDbgLevel     = uDbgLevel;
    m_dwStatusSafe1 = dwStatusSafe1;
    m_dwStatusSafe2 = dwStatusSafe2;
    m_dwStatusSafe3 = dwStatusSafe3;
}

BOOL
TStatusBBase::
bGetStatus(
    VOID
    ) const
{
    //
    // Assert if we are reading an UnInitalized variable.
    //
    if (m_bStatus == kUnInitializedValue)
    {
        DBG_MSG(kDbgAlways|kDbgNoFileInfo, (_T("***Read of UnInitialized TStatusB variable!***\n")));
        DBG_BREAK();
    }

    //
    // Return the error value.
    //
    return m_bStatus;
}

BOOL
TStatusBBase::
operator=(
    IN BOOL bStatus
    )
{
    //
    // Do nothing if the file and line number are cleared.
    // This is the case when the NoChk method is used.
    //
    if (m_uLine && m_pszFile)
    {
        //
        // Check if we have an error, and it's not one of the two
        // accepted "safe" errors.
        //
        if (!bStatus)
        {
            //
            // Get the last error value.
            //
            DWORD LastError = GetLastError();

            //
            // If the last error is not one of the safe values then display an error message
            //
            if (LastError != m_dwStatusSafe1 &&
                LastError != m_dwStatusSafe2 &&
                LastError != m_dwStatusSafe3)
            {
                //
                // Convert the last error value to a string.
                //
                TDebugResult Result(LastError);

                DBG_MSG(m_uDbgLevel, (_T("TStatusB failure, %d, %s\n%s %d\n"), LastError, Result.GetErrorString(), m_pszFile, m_uLine));

            }

            //
            // Restore the last error, the message call may have destoyed the last
            // error value, we don't want the caller to loose this value.
            //
            SetLastError(LastError);
        }
    }

    return m_bStatus = bStatus;
}

TStatusBBase::
operator BOOL(
    VOID
    ) const
{
    return bGetStatus();
}

/********************************************************************

    Debugging TStatusB members

********************************************************************/

TStatusB::
TStatusB(
    IN BOOL bStatus
    ) : TStatusBBase(bStatus, kDbgWarning)
{
}

TStatusB::
~TStatusB(
    VOID
    )
{
}

/********************************************************************

    Debugging TStatusH base members

********************************************************************/

TStatusHBase::
TStatusHBase(
    IN HRESULT  hrStatus,
    IN UINT     uDbgLevel
    ) : m_hrStatus(hrStatus),
        m_uDbgLevel(uDbgLevel),
        m_hrStatusSafe1(-1),
        m_hrStatusSafe2(-1),
        m_hrStatusSafe3(-1),
        m_uLine(0),
        m_pszFile(NULL)

{
}

TStatusHBase::
~TStatusHBase(
    VOID
    )
{
}

TStatusHBase&
TStatusHBase::
pNoChk(
    VOID
    )
{
    m_pszFile    = NULL;
    m_uLine      = 0;
    return (TStatusHBase&)*this;
}

TStatusHBase&
TStatusHBase::
pSetInfo(
    IN UINT     uLine,
    IN LPCTSTR  pszFile
    )
{
    m_uLine      = uLine;
    m_pszFile    = pszFile;
    return (TStatusHBase&)*this;
}


VOID
TStatusHBase::
pConfig(
    IN UINT     uDbgLevel,
    IN DWORD    hrStatusSafe1,
    IN DWORD    hrStatusSafe2,
    IN DWORD    hrStatusSafe3
    )
{
    m_uDbgLevel     = uDbgLevel;
    m_hrStatusSafe1 = hrStatusSafe1;
    m_hrStatusSafe2 = hrStatusSafe2;
    m_hrStatusSafe3 = hrStatusSafe3;
}

HRESULT
TStatusHBase::
hrGetStatus(
    VOID
    ) const
{
    //
    // Assert if we are reading an UnInitalized variable.
    //
    if (m_hrStatus == kUnInitializedValue)
    {
        DBG_MSG(kDbgAlways|kDbgNoFileInfo, (_T("***Read of UnInitialized TStatusH variable!***\n")));
        DBG_BREAK();
    }

    //
    // Return the error code.
    //
    return m_hrStatus;
}

HRESULT
TStatusHBase::
operator=(
    IN HRESULT hrStatus
    )
{
    //
    // Do nothing if the file and line number are cleared.
    // This is the case when the NoChk method is used.
    //
    if (m_uLine && m_pszFile)
    {
        //
        // Check if we have an error, and it's not one of the two
        // accepted "safe" errors.
        //
        if (FAILED(hrStatus))
        {
            //
            // Get the last error value.
            //
            DWORD LastError = GetLastError();

            //
            // If the last error is not one of the safe values then display an error message
            //
            if (hrStatus != m_hrStatusSafe1 &&
                hrStatus != m_hrStatusSafe2 &&
                hrStatus != m_hrStatusSafe3)
            {
                TDebugResult Result( HRESULT_FACILITY(hrStatus) == FACILITY_WIN32 ? HRESULT_CODE(hrStatus) : hrStatus);
                DBG_MSG(m_uDbgLevel, (_T("TStatusH failure, %x, %s\n%s %d\n"), hrStatus, Result.GetErrorString(), m_pszFile, m_uLine));
            }

            //
            // Restore the last error, the message call may have destoyed the last
            // error value, we don't want the caller to loose this value.
            //
            SetLastError(LastError);
        }
    }

    return m_hrStatus = hrStatus;
}

TStatusHBase::
operator HRESULT(
    VOID
    ) const
{
    return hrGetStatus();
}

/********************************************************************

    Debugging TStatusH members

********************************************************************/

TStatusH::
TStatusH(
    IN HRESULT hrStatus
    ) : TStatusHBase(hrStatus, kDbgWarning)
{
}

TStatusH::
~TStatusH(
    VOID
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgstr.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgstr.cxx

Abstract:

    Debug string class

Author:

    Steve Kiraly (SteveKi)  23-May-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

//
// Class specific NULL state.
//
TCHAR TDebugString::gszNullState[2] = {0,0};

/*++

Title:

    TDebugString

Routine Description:

    Default construction.

Arguments:

    None.

Return Value:

    None.

--*/
TDebugString::
TDebugString(
    VOID
    ) : m_pszString( &TDebugString::gszNullState[kValid] )
{
}

/*++

Title:

    TDebugString

Routine Description:

    Construction using an existing LPCTSTR string.

Arguments:

    None.

Return Value:

    None.

Last Error:

    None.

--*/
TDebugString::
TDebugString(
    IN LPCTSTR psz
    ) : m_pszString( &TDebugString::gszNullState[kValid] )
{
    (VOID)bUpdate( psz );
}

/*++

Title:

    ~TDebugString

Routine Description:

    Destruction, ensure we don't free our NULL state.

Arguments:

    None.

Return Value:

    None.

--*/
TDebugString::
~TDebugString(
    VOID
    )
{
    vFree( m_pszString );
}

/*++

Title:

    TDebugString

Routine Description:

    Copy constructor.

Arguments:

    None.

Return Value:

    None.

--*/
TDebugString::
TDebugString(
    const TDebugString &String
    ) : m_pszString( &TDebugString::gszNullState[kValid] )
{
    (VOID)bUpdate( String.m_pszString );
}

/*++

Title:

    bEmpty

Routine Description:

    Indicates if a string has any usable data.

Arguments:

    None.

Return Value:

    None.

--*/
BOOL
TDebugString::
bEmpty(
    VOID
    ) const
{
    return *m_pszString == NULL;
}

/*++

Title:

    bValid

Routine Description:

    Indicates if a string object is valid.

Arguments:

    None.

Return Value:

    None.

--*/
BOOL
TDebugString::
bValid(
    VOID
    ) const
{
    return m_pszString != &TDebugString::gszNullState[kInValid];
}

/*++

Title:

    uLen

Routine Description:

    Return the length of the string in characters
    does not include the null terminator.

Arguments:

    None.

Return Value:

    None.

--*/
UINT
TDebugString::
uLen(
    VOID
    ) const
{
    return _tcslen( m_pszString );
}

/*++

Title:

    operator LPCTSTR

Routine Description:

    Conversion operator from string object to pointer
    to constant zero terminated string.

Arguments:

    None.

Return Value:

    None.

--*/
TDebugString::
operator LPCTSTR(
    VOID
    ) const
{
    return m_pszString;
}

/*++

Title:

    bCat

Routine Description:

    Safe concatenation of the specified string to the string
    object. If the allocation fails, return FALSE and the
    original string is not lost.

Arguments:

    psz - Input string, may be NULL.

Return Value:

    TRUE concatination was successful
    FALSE concatination failed, orginal string is not modified

--*/
BOOL
TDebugString::
bCat(
    IN LPCTSTR psz
    )
{
    BOOL bReturn;

    //
    // If a valid string was passed.
    //
    if (psz && *psz)
    {
        //
        // Allocate the new buffer consisting of the size of the orginal
        // string plus the sizeof of the new string plus the null terminator.
        //
        LPTSTR pszTemp = INTERNAL_NEW TCHAR [ _tcslen( m_pszString ) + _tcslen( psz ) + 1 ];

        //
        // If memory was not available.
        //
        if (!pszTemp)
        {
            //
            // Indicate failure, original string not modified.
            //
            bReturn = FALSE;
        }
        else
        {
            //
            // Copy the original string and tack on the provided string.
            //
            _tcscpy( pszTemp, m_pszString );
            _tcscat( pszTemp, psz );

            //
            // Release the original buffer.
            //
            vFree( m_pszString );

            //
            // Save pointer to new string.
            //
            m_pszString = pszTemp;

            //
            // Indicate success.
            //
            bReturn = TRUE;
        }
    }
    else
    {
        //
        // NULL pointers and NULL strings are silently ignored.
        //
        bReturn = TRUE;
    }

    return bReturn;
}

/*++

Title:

    bUpdate

Routine Description:

    Safe updating of string.  If the allocation fails the
    orginal string is lost and the object becomes invalid.
    A null pointer can be passed which is basically a
    request to clear the contents of the string.

Arguments:

    psz - Input string.  The input string can be the null pointer
          in this case the contents of the string cleared.

Return Value:

    TRUE update successful
    FALSE update failed

--*/
BOOL
TDebugString::
bUpdate(
    IN LPCTSTR psz OPTIONAL
    )
{
    BOOL bReturn;

    //
    // Check if the null pointer is passed.
    //
    if (!psz)
    {
        //
        // Release the original string.
        //
        vFree( m_pszString );

        //
        // Mark the object as valid.
        //
        m_pszString = &TDebugString::gszNullState[kValid];

        //
        // Indicate success.
        //
        bReturn = TRUE;
    }
    else
    {
        //
        // Create temp pointer to the previous string.
        //
        LPTSTR pszTmp = m_pszString;

        //
        // Allocate storage for the new string.
        //
        m_pszString = INTERNAL_NEW TCHAR [ _tcslen(psz) + 1 ];

        //
        // If memory was not available.
        //
        if (!m_pszString)
        {
            //
            // Mark the string object as invalid.
            //
            m_pszString = &TDebugString::gszNullState[kInValid];

            //
            // Indicate failure.
            //
            bReturn = FALSE;
        }
        else
        {
            //
            // Copy the string to the new buffer.
            //
            _tcscpy( m_pszString, psz );

            //
            // Indicate success.
            //
            bReturn = TRUE;
        }

        //
        // Release the previous string.
        //
        vFree( pszTmp );

    }

    return bReturn;
}

/*++

Title:

    vFree

Routine Description:

    Safe free, frees the string memory.  Ensures
    we do not try an free our global memory block.

Arguments:

    pszString pointer to string meory to free.

Return Value:

    Nothing.

--*/
VOID
TDebugString::
vFree(
    IN LPTSTR pszString OPTIONAL
    )
{
    //
    // If this memory was not pointing to our
    // class specific gszNullStates then release the memory.
    //
    if (pszString &&
        pszString != &TDebugString::gszNullState[kValid] &&
        pszString != &TDebugString::gszNullState[kInValid])
    {
        INTERNAL_DELETE [] pszString;
    }
}

/*++

Title:

    bFormat

Routine Description:

    Format the string opbject similar to sprintf.

Arguments:

    pszFmt pointer format string.
    .. variable number of arguments similar to sprintf.

Return Value:

    TRUE if string was format successfully. FALSE if error
    occurred creating the format string, string object will be
    invalid and the previous string lost.

--*/
BOOL
TDebugString::
bFormat(
    IN LPCTSTR pszFmt,
    IN ...
    )
{
    BOOL bReturn;

    va_list pArgs;

    va_start( pArgs, pszFmt );

    bReturn = bvFormat( pszFmt, pArgs );

    va_end( pArgs );

    return bReturn;

}

/*++

Title:

    bvFormat

Routine Description:

    Format the string opbject similar to vsprintf.

Arguments:

    pszFmt pointer format string.
    pointer to variable number of arguments similar to vsprintf.

Return Value:

    TRUE if string was format successfully. FALSE if error
    occurred creating the format string, string object will be
    left unaltered.

--*/
BOOL
TDebugString::
bvFormat(
    IN LPCTSTR pszFmt,
    IN va_list avlist
    )
{
    BOOL bReturn;

    //
    // Save previous string value.
    //
    LPTSTR pszTemp = m_pszString;

    //
    // Format the string.
    //
    m_pszString = vsntprintf( pszFmt, avlist );

    //
    // If format failed mark object as invalid and
    // set the return value.
    //
    if (!m_pszString)
    {
        //
        // Restore the orginal pointer.
        //
        m_pszString = pszTemp;

        //
        // Indicate success.
        //
        bReturn = FALSE;
    }
    else
    {
        //
        // Release the previous string.
        //
        vFree( pszTemp );

        //
        // Indicate success.
        //
        bReturn = TRUE;
    }

    return bReturn;
}

/*++

Title:

    vsntprintf

Routine Description:

    Formats a string and returns a heap allocated string with the
    formated data.  This routine can be used to for extremely
    long format strings.  Note:  If a valid pointer is returned
    the callng functions must release the data with a call to delete.

    Example:

    LPCTSTR p = vsntprintf( _T("Test %s"), pString );

    if (p)
    {
        SetTitle( p );
    }

    INTERNAL_DELETE [] p;

Arguments:

    psFmt - format string
    pArgs - pointer to a argument list.

Return Value:

    Pointer to formated string.  NULL if error.

--*/
LPTSTR
TDebugString::
vsntprintf(
    IN LPCTSTR      szFmt,
    IN va_list      pArgs
    ) const
{
    LPTSTR  pszBuff;
    INT     iSize   = 256;

    for( ; ; )
    {
        //
        // Allocate the message buffer.
        //
        pszBuff = INTERNAL_NEW TCHAR [iSize];

        //
        // Allocating the buffer failed, we are done.
        //
        if (!pszBuff)
        {
            break;
        }

        //
        // Attempt to format the string.  snprintf fails with a
        // negative number when the buffer is too small.
        //
        INT iReturn = _vsntprintf(pszBuff, iSize, szFmt, pArgs);

        //
        // If the return value positive and not equal to the buffer size
        // then the format succeeded.  _vsntprintf will not null terminate
        // the string if the resultant string is exactly the length of the
        // provided buffer.
        //
        if (iReturn > 0 && iReturn != iSize)
        {
            break;
        }

        //
        // String did not fit release the current buffer.
        //
        INTERNAL_DELETE [] pszBuff;

        //
        // Null the buffer pointer.
        //
        pszBuff = NULL;

        //
        // Double the buffer size after each failure.
        //
        iSize *= 2;

        //
        // If the size is greater than 100k exit without formatting a string.
        //
        if (iSize > kMaxFormatStringLength)
        {
            break;
        }
    }
    return pszBuff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgtrace.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgtrace.hxx

Abstract:

    Debug tracer routines.  Tracer routines are used to
    display a debugging message on entry and exit of
    a subroutine call.  Note this class relies on the
    debug message class.  A user must use and initialize
    the debug messages for tracer to work.

Author:

    Steve Kiraly (SteveKi)  4-Jun-1996

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

//
// Static indent count for indenting.
//
UINT TDebugTracer::m_uLev = 0;

/*++

Routine Name:

    TDebugTracer

Routine Description:

    Construct a trace class and emit a trace message.

Arguments:

    pszMessage - Pointer to trace message which will be displayed.

Return Value:

    Nothing.

--*/
TDebugTracer::
TDebugTracer(
    IN LPCSTR pszMessage
    )
{
    m_strMsg.pszNarrow   = pszMessage;
    m_bAnsi              = TRUE;

    TDebugMsg_Msg( kDbgTrace|kDbgNoFileInfo,
                   NULL,
                   0,
                   NULL,
                   TDebugMsg_Fmt( "%*sEnter %s\n", m_uLev * 4, m_uLev ? " " : "", m_strMsg.pszNarrow ) );
    m_uLev++;
}

/*++

Routine Name:

    TDebugTracer

Routine Description:

    Construct a trace class and emit a trace message.

Arguments:

    pszMessage - Pointer to trace message which will be displayed.

Return Value:

    Nothing.

--*/
TDebugTracer::
TDebugTracer(
    IN LPCWSTR pszMessage
    )
{
    m_strMsg.pszWide     = pszMessage;
    m_bAnsi              = FALSE;

    TDebugMsg_Msg( kDbgTrace|kDbgNoFileInfo,
                   NULL,
                   0,
                   NULL,
                   TDebugMsg_Fmt( L"%*sEnter %s\n", m_uLev * 4, m_uLev ? L" " : L"", m_strMsg.pszWide ) );
    ++m_uLev;
}

/*++

Routine Name:

    ~TDebugTracer

Routine Description:

    Emit a trace message when the trace class falls out of scope.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TDebugTracer::
~TDebugTracer(
    VOID
    )
{
    --m_uLev;

    if( m_bAnsi )
    {
        TDebugMsg_Msg( kDbgTrace|kDbgNoFileInfo,
                       NULL,
                       0,
                       NULL,
                       TDebugMsg_Fmt( "%*sLeave %s\n", m_uLev * 4, m_uLev ? " " : "", m_strMsg.pszNarrow ) );
    }
    else
    {
        TDebugMsg_Msg( kDbgTrace|kDbgNoFileInfo,
                       NULL,
                       0,
                       NULL,
                       TDebugMsg_Fmt( L"%*sLeave %s\n", m_uLev * 4, m_uLev ? L" " : L"", m_strMsg.pszWide ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\dbgutil.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation
All rights reserved.

Module Name:

    dbgutil.cxx

Abstract:

    Debug Utility functions

Author:

    Steve Kiraly (SteveKi)  24-May-1998

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

DEBUG_NS_BEGIN

/*++

Title:

    ErrorText

Routine Description:

    Function used to display an error text to the
    debugger.  Just simplifies the task of formating
    a message string with sprintf.

Arguments:

    pszFmt   - pointer to sprintf format string.
    ...      - variable number of arguments that matches format string.

Return Value:

    TRUE message displayed, FALSE error occurred.

--*/
BOOL
WINAPIV
ErrorText(
    IN LPCTSTR  pszFmt
    ...
    )
{
    BOOL bReturn;

    if (Globals.DisplayLibraryErrors)
    {
        va_list pArgs;

        va_start( pArgs, pszFmt );

        TCHAR szBuffer[4096];

        bReturn = _vsntprintf( szBuffer, COUNTOF( szBuffer ), pszFmt, pArgs ) >= 0;

        if (bReturn)
        {
            OutputDebugString( szBuffer );
        }

        va_end( pArgs );
    }
    else
    {
        bReturn = TRUE;
    }

    return bReturn;
}

/*++

Title:

    StripPathFromFileName

Routine Description:

    Function used stip the path component from a fully
    qualified file name.

Arguments:

    pszFile - pointer to full file name.

Return Value:

    Pointer to start of file name in path.

--*/
LPCTSTR
StripPathFromFileName(
    IN LPCTSTR pszFile
    )
{
    LPCTSTR pszFileName;

    if (pszFile)
    {
        pszFileName = _tcsrchr( pszFile, _T('\\') );

        if (pszFileName)
        {
            pszFileName++;
        }
        else
        {
            pszFileName = pszFile;
        }
    }
    else
    {
        pszFileName = kstrNull;
    }

    return pszFileName;
}

/*++

Title:

    GetProcessName

Routine Description:

    Gets the current process short file name.

Arguments:

    strProcessName - string reference where to return the process name.

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
GetProcessName(
    IN TDebugString &strProcessName
    )
{
    BOOL bRetval = FALSE;
    LPCTSTR pszBuffer = NULL;
    TCHAR szBuffer[MAX_PATH];

    if( GetModuleFileName( NULL, szBuffer, COUNTOF( szBuffer ) ) )
    {
        pszBuffer = StripPathFromFileName( szBuffer );

        if( pszBuffer )
        {
            bRetval = strProcessName.bUpdate( pszBuffer );
        }
    }

    return bRetval;
}

/*++

Title:

    bFormatA

Routine Description:

    Formats a string and returns a heap allocated string with the
    formated data.  This routine can be used to for extremely
    long format strings.  Note:  If a valid pointer is returned
    the callng functions must release the data with a call to delete.

    Example:

    LPSTR p = vFormatA( _T("Test %s"), pString );

    if (p)
    {
        SetTitle(p);
    }

    INTERNAL_DELETE [] p;

Arguments:

    psFmt - format string
    pArgs - pointer to a argument list.

Return Value:

    Pointer to formated string.  NULL if error.

--*/
LPSTR
vFormatA(
    IN LPCSTR       pszFmt,
    IN va_list      pArgs
    )
{
    LPSTR   pszBuff = NULL;
    INT     iSize   = 256;

    for( ; pszFmt; )
    {
        //
        // Allocate the message buffer.
        //
        pszBuff = INTERNAL_NEW CHAR [ iSize ];

        //
        // Allocating the buffer failed, we are done.
        //
        if (!pszBuff)
        {
            break;
        }

        //
        // Attempt to format the string.  snprintf fails with a
        // negative number when the buffer is too small.
        //
        INT iLen = _vsnprintf( pszBuff, iSize, pszFmt, pArgs );

        //
        // snprintf does not null terminate the string if the buffer and the
        // final string are exactly the same length.  If we detect this case
        // make the buffer larger and then call snprintf one extra time.
        //
        if (iLen > 0 && iLen != iSize)
        {
            break;
        }


        //
        // String did not fit release the current buffer.
        //
        INTERNAL_DELETE [] pszBuff;

        //
        // Null the buffer pointer.
        //
        pszBuff = NULL;

        //
        // Double the buffer size after each failure.
        //
        iSize *= 2;

        //
        // If the size is greater than 100k exit without formatting a string.
        //
        if (iSize > 100*1024)
        {
            break;
        }
    }
    return pszBuff;
}

/*++

Title:

    bFormatW

Routine Description:

    Formats a string and returns a heap allocated string with the
    formated data.  This routine can be used to for extremely
    long format strings.  Note:  If a valid pointer is returned
    the callng functions must release the data with a call to delete.

    Example:

    LPWSTR p = vFormatW( _T("Test %s"), pString );

    if (p)
    {
        SetTitle(p);
    }

    INTERNAL_DELETE [] p;

Arguments:

    psFmt - format string
    pArgs - pointer to a argument list.

Return Value:

    Pointer to formated string.  NULL if error.

--*/
LPWSTR
vFormatW(
    IN LPCWSTR      pszFmt,
    IN va_list      pArgs
    )
{
    LPWSTR   pszBuff = NULL;
    INT      iSize   = 256;

    for( ; pszFmt; )
    {
        //
        // Allocate the message buffer.
        //
        pszBuff = INTERNAL_NEW WCHAR [ iSize ];

        //
        // Allocating the buffer failed, we are done.
        //
        if (!pszBuff)
        {
            break;
        }

        //
        // Attempt to format the string.  snprintf fails with a
        // negative number when the buffer is too small.
        //
        INT iLen = _vsnwprintf( pszBuff, iSize, pszFmt, pArgs );

        //
        // snprintf does not null terminate the string if the buffer and the
        // final string are exactly the same length.  If we detect this case
        // make the buffer larger and then call snprintf one extra time.
        //
        if (iLen > 0 && iLen != iSize)
        {
            break;
        }

        //
        // String did not fit release the current buffer.
        //
        INTERNAL_DELETE [] pszBuff;

        //
        // Null the buffer pointer.
        //
        pszBuff = NULL;

        //
        // Double the buffer size after each failure.
        //
        iSize *= 2;

        //
        // If the size is greater than 100k exit without formatting a string.
        //
        if (iSize > 100*1024)
        {
            break;
        }
    }
    return pszBuff;
}

/*++

Title:

    StringConvert

Routine Description:

    Convert an ansi string to a wide string returning
    a pointer to a newly allocated string.

Arguments:

    ppResult        - pointer to where to return pointer to new wide string.
    pString         - pointer to ansi string.

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
StringConvert(
    IN  OUT LPWSTR   *ppResult,
    IN      LPCSTR   pString
    )
{
    BOOL bReturn = FALSE;

    if( ppResult && pString )
    {
        INT iLen = strlen( pString ) + 1;

        *ppResult = INTERNAL_NEW WCHAR[iLen];

        if( *ppResult )
        {
            if( MultiByteToWideChar( CP_ACP, 0, pString, -1, *ppResult, iLen ) )
            {
                bReturn = TRUE;
            }
            else
            {
                INTERNAL_DELETE [] *ppResult;
                *ppResult = NULL;
            }
        }
    }

    return bReturn;
}

/*++

Title:

    StringConvert

Routine Description:

    Convert an ansi string to a heap allocated ansi string returning
    a pointer to a newly allocated string.

Arguments:

    ppResult        - pointer to where to return pointer to new ansi string.
    pString         - pointer to ansi string.

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
StringConvert(
    IN  OUT LPSTR    *ppResult,
    IN      LPCSTR   pString
    )
{
    BOOL bReturn = FALSE;

    if( ppResult && pString )
    {
        INT iLen = strlen( pString ) + 1;

        *ppResult = INTERNAL_NEW CHAR[iLen];

        if( *ppResult )
        {
            strcpy( *ppResult, pString );
            bReturn = TRUE;
        }
    }

    return bReturn;
}

/*++

Title:

    StringConvert

Routine Description:

    Convert a wide string to and ansi string returning
    a pointer to a newly allocated string.

Arguments:

    ppResult        - pointer to where to return pointer to new ansi string.
    pString         - pointer to wide string.

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
StringConvert(
    IN  OUT LPSTR   *ppResult,
    IN      LPCWSTR pString
    )
{
    BOOL bReturn = FALSE;

    if( ppResult && pString )
    {
        INT iLen = wcslen( pString ) + 1;

        *ppResult = INTERNAL_NEW CHAR [iLen];

        if( *ppResult )
        {
            if( WideCharToMultiByte( CP_ACP, 0, pString, -1, *ppResult, iLen, NULL, NULL ) )
            {
                bReturn = TRUE;
            }
            else
            {
                INTERNAL_DELETE [] *ppResult;
                *ppResult = NULL;
            }
        }
    }

    return bReturn;
}

/*++

Title:

    StringConvert

Routine Description:

    Convert a wide string to and heap allocated wide string returning
    a pointer to a newly allocated string.

Arguments:

    ppResult        - pointer to where to return pointer to new wide string.
    pString         - pointer to wide string.

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
StringConvert(
    IN  OUT LPWSTR  *ppResult,
    IN      LPCWSTR pString
    )
{
    BOOL bReturn = FALSE;

    if( ppResult && pString )
    {
        INT iLen = wcslen( pString ) + 1;

        *ppResult = INTERNAL_NEW WCHAR [iLen];

        if( *ppResult )
        {
            wcscpy( *ppResult, pString );
            bReturn = TRUE;
        }
    }

    return bReturn;
}

BOOL
StringA2T(
    IN  OUT LPTSTR   *ppResult,
    IN      LPCSTR   pString
    )
{
    return StringConvert( ppResult, pString );
}

BOOL
StringT2A(
    IN  OUT LPSTR    *ppResult,
    IN      LPCTSTR  pString
    )
{
    return StringConvert( ppResult, pString );
}

BOOL
StringT2W(
    IN  OUT LPWSTR   *ppResult,
    IN      LPCTSTR  pString
    )
{
    return StringConvert( ppResult, pString );
}

BOOL
StringW2T(
    IN  OUT LPTSTR   *ppResult,
    IN      LPCWSTR  pString
    )
{
    return StringConvert( ppResult, pString );
}

DEBUG_NS_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\test\cexe\precomp.h ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdarg.h>

#include "dbglib.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\test\cexe\dbgtst.h ===
#ifndef DBGTST_HXX
#define DBGTST_HXX





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\exts\dbgext.h ===
/******************************Module*Header*******************************\
* Module Name: dbgext.h
*
* Created: 10-Sep-1993 08:36:42
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993 Microsoft Corporation
*
* Dependencies:
*
* common macros for debugger extensions
*
*
\**************************************************************************/


/**************************************************************************\
 *
 * GetAddress - symbol of another module
 *
\**************************************************************************/

#define GetAddress(dst, src)                                                    \
__try {                                                                         \
    char *pj = (char *)(src);                                                   \
/* if it is NTSD, don't want the trailing & */                                  \
    if ((ExtensionApis.nSize < sizeof(WINDBG_EXTENSION_APIS)) &&                \
        (*pj == '&'))                                                           \
    {                                                                           \
        pj++;                                                                   \
    }                                                                           \
    *((ULONG *) &dst) = EvalExpression(pj);                                     \
} __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?                  \
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {            \
    Print("NTSD: Access violation on \"%s\", switch to server context\n", src); \
}

#define GetValue(dst,src)                                                       \
    GetAddress(dst,src)                                                         \
    if (TRUE || ExtensionApis.nSize < sizeof(WINDBG_EXTENSION_APIS))            \
    {                                                                           \
        move(dst,dst);                                                          \
    }

/**************************************************************************\
 *
 * move(dst, src ptr)
 *
\**************************************************************************/

#define move(dst, src)                                              \
__try {                                                             \
    if (ExtensionApis.nSize >= sizeof(WINDBG_EXTENSION_APIS))       \
    {                                                               \
        (*ExtensionApis.lpReadProcessMemoryRoutine)(                \
             (ULONG_PTR) (src), &(dst), sizeof(dst), NULL);          \
    } else                                                          \
    {                                                               \
        NtReadVirtualMemory(hCurrentProcess, (LPVOID) (src), &(dst), sizeof(dst), NULL);\
    }                                                               \
                                                                    \
} __except (EXCEPTION_EXECUTE_HANDLER) {                            \
    Print("exception in move()\n");                                 \
}

/**************************************************************************\
 *
 * move2(dst ptr, src ptr, num bytes)
 *
\**************************************************************************/

#define move2(dst, src,bytes)                                       \
__try {                                                             \
    if (ExtensionApis.nSize >= sizeof(WINDBG_EXTENSION_APIS))       \
    {                                                               \
        (*ExtensionApis.lpReadProcessMemoryRoutine)(                \
             (ULONG_PTR) (src), (dst), (bytes), NULL);               \
    } else                                                          \
    {                                                               \
        NtReadVirtualMemory(hCurrentProcess, (LPVOID) (src), (dst), (bytes), NULL);\
    }                                                               \
                                                                    \
} __except (EXCEPTION_EXECUTE_HANDLER) {                            \
    Print("exception in move2()\n");                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\test\cexe\dbgtst.c ===
#include "precomp.h"
#pragma hdrstop

VOID
_cdecl
_tmain(
    IN INT      ac,
    IN TCHAR    **av
    )
{
    DBG_CAPTURE_HANDLE(Capture);
    DBG_INIT();

    _tprintf(_T("Debug Library C test file\n"));

    DBG_MSG(DBG_TRACE, (_T("C Test file Message\n")));

    DBG_CAPTURE_OPEN(Capture, _T("symbols"), DBG_DEBUGGER, NULL);
    DBG_CAPTURE(Capture, DBG_NULL, (_T("Test Backtrace Capture %s\n"), _T("dbgtst!_tmain")));
    DBG_CAPTURE_CLOSE(Capture);

    DBG_RELEASE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\test\win\dbgwin.cxx ===
#include "precomp.hxx"
#pragma hdrstop

#include "dbgdll.hxx"

VOID
Test_Function2()
{
    DBG_TRACER( "Test_Function2()" );

}

VOID
Test_Function1()
{
    DBG_TRACER( "Test_Function1()" );

    Test_Function2();
}


INT WINAPI
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpszCmdLine,
    INT         nCmdShow
   )
{
    DBG_INIT();

    DBG_OPEN( _T("DBGTST_0"), DBG_DEFAULT, DBG_TRACE, DBG_NONE );
    DBG_MSG( DBG_TRACE, ( _T("Trace unicode message.\n") ) );
    DBG_MSG( DBG_TRACE, ( "Trace ansi message.\n" ) );
    DBG_CLOSE();

    DBG_OPEN( _T("DBGTST_1"), DBG_DEFAULT, DBG_TRACE, DBG_NONE );
    DBG_MSG( DBG_TRACE, ( _T("Trace unicode message.\n") ) );
    DBG_MSG( DBG_TRACE, ( "Trace ansi message.\n" ) );
    DBG_CLOSE();

    DBG_OPEN( _T("DBGTST_2"), DBG_DEFAULT, DBG_TRACE, DBG_NONE );
    Test_Function1();
    DBG_CLOSE();

    DBG_OPEN( _T("DBGTST_3"), DBG_DEFAULT, DBG_TRACE, DBG_NONE );
    LPCTSTR psz1 = NULL;
    DBG_ASSERT_MSG( psz1, ( "Ansi message Null pointer found %p %s.\n", &psz1, "String" ) );
    DBG_ASSERT_MSG( psz1, ( _T("Unicode message Null pointer found %p %s.\n"), &psz1, _T("String") ) );
    DBG_CLOSE();

    DBG_OPEN( _T("DBGTST_4"), DBG_DEFAULT, DBG_TRACE, DBG_TRACE );
    DBG_ATTACH( DBG_CONSOLE, NULL );
    DBG_MSG( DBG_TRACE, ( _T("Trace with break message.\n") ) );
    DBG_CLOSE();

    DBG_RELEASE();
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\test\exe\dbgtst.cxx ===
#include "precomp.hxx"
#pragma hdrstop

#include "dbgdll.hxx"

VOID
TracerTest(
    IN INT      ac,
    IN TCHAR    **av
    )
{
    DBG_OPEN( _T("DBG_TRACER"), DBG_DEFAULT, DBG_TRACE, DBG_NONE );

    DBG_TRACER( _T("TestFunction Scope 1") );
    {
        DBG_TRACER( _T("TestFunction Scope 2") );
        {
            DBG_TRACER( _T("TestFunction Scope 3") );
            {
                DBG_TRACER( _T("TestFunction Scope 4") );
                {
                    DBG_TRACER( _T("TestFunction Scope 5") );
                }
            }
        }
    }

    DBG_CLOSE();
}

VOID
StatusTest(
    IN INT      ac,
    IN TCHAR    **av
    )
{
    DBG_OPEN( _T("DBG_STATUS"), DBG_DEFAULT, DBG_TRACE|DBG_WARN, DBG_NONE );

    TStatus Status;
    Status DBGCHK = ERROR_ACCESS_DENIED;
    Status DBGCHK = ERROR_INVALID_PARAMETER;

    TStatusB bStatus;
    bStatus DBGCHK = TRUE;

    SetLastError(ERROR_ACCESS_DENIED);
    bStatus DBGCHK = FALSE;

    TStatusH hStatus = S_OK;
    hStatus DBGCHK = S_OK;
    hStatus DBGCHK = E_NOTIMPL;

    //
    // Verify assert when reading an ininitalized variable.
    //
#if DBG
    TStatusH hr;

    if (FAILED(hr))
    {
        hr DBGCHK = E_FAIL;
    }
#endif

    //
    // Verify the safe values work.
    //
    TStatusB bStatus1;
    DBGCFG1(bStatus1, DBG_TRACE, ERROR_ACCESS_DENIED);
    SetLastError(ERROR_ACCESS_DENIED);
    bStatus1 DBGCHK = FALSE;
    SetLastError(ERROR_ARENA_TRASHED);
    bStatus1 DBGCHK = FALSE;

    TStatus Status1;
    DBGCFG2(Status1, DBG_TRACE, ERROR_ACCESS_DENIED, ERROR_INVALID_HANDLE);
    Status1 DBGCHK = ERROR_ACCESS_DENIED;
    Status1 DBGCHK = ERROR_INVALID_HANDLE;
    Status1 DBGCHK = ERROR_ARENA_TRASHED;

    TStatusH hStatus1;
    DBGCFG3(hStatus1, DBG_TRACE, E_FAIL, E_NOTIMPL, E_ABORT);
    hStatus1 DBGCHK = E_FAIL;
    hStatus1 DBGCHK = E_NOTIMPL;
    hStatus1 DBGCHK = E_ABORT;
    hStatus1 DBGCHK = HRESULT_FROM_WIN32(ERROR_ARENA_TRASHED);

    DBG_CLOSE();
}

VOID
MessageTestHelper(
    IN PTSTR    sString,
    IN TCHAR    cValue,
    IN SHORT    sValue,
    IN INT      iValue,
    IN LONG     lValue
    )
{
    DBG_MSG(DBG_TRACE, (_T("Trace testing\n")));
    DBG_MSG(DBG_TRACE, (_T("Trace sString   = %s\n"), sString));
    DBG_MSG(DBG_TRACE, (_T("Trace cValue    = %c\n"), cValue));
    DBG_MSG(DBG_TRACE, (_T("Trace sValue    = %d\n"), sValue));
    DBG_MSG(DBG_TRACE, (_T("Trace iValue    = %d\n"), iValue));
    DBG_MSG(DBG_TRACE, (_T("Trace lValue    = %ld\n"), lValue));

    DBG_MSG(DBG_WARN, (_T("Warning testing\n")));
    DBG_MSG(DBG_WARN, (_T("Warning sString   = %s\n"), sString));
    DBG_MSG(DBG_WARN, (_T("Warning cValue    = %c\n"), cValue));
    DBG_MSG(DBG_WARN, (_T("Warning sValue    = %d\n"), sValue));
    DBG_MSG(DBG_WARN, (_T("Warning iValue    = %d\n"), iValue));
    DBG_MSG(DBG_WARN, (_T("Warning lValue    = %ld\n"), lValue));

    DBG_MSG(DBG_ERROR, (_T("Error testing\n")));
    DBG_MSG(DBG_ERROR, (_T("Error sString   = %s\n"), sString));
    DBG_MSG(DBG_ERROR, (_T("Error cValue    = %c\n"), cValue));
    DBG_MSG(DBG_ERROR, (_T("Error sValue    = %d\n"), sValue));
    DBG_MSG(DBG_ERROR, (_T("Error iValue    = %d\n"), iValue));
    DBG_MSG(DBG_ERROR, (_T("Error lValue    = %ld\n"), lValue));

    DBG_MSG(DBG_FATAL, (_T("Fatal testing\n")));
    DBG_MSG(DBG_FATAL, (_T("Fatal sString   = %s\n"), sString));
    DBG_MSG(DBG_FATAL, (_T("Fatal cValue    = %c\n"), cValue));
    DBG_MSG(DBG_FATAL, (_T("Fatal sValue    = %d\n"), sValue));
    DBG_MSG(DBG_FATAL, (_T("Fatal iValue    = %d\n"), iValue));
    DBG_MSG(DBG_FATAL, (_T("Fatal lValue    = %ld\n"), lValue));

}

VOID
MessageTest(
    IN INT      ac,
    IN TCHAR    **av
    )
{
    TCHAR   cValue  = _T('C');
    PTSTR   sString = _T("String");
    SHORT   sValue  = 100;
    INT     iValue  = 32000;
    LONG    lValue  = 1000000;
    UINT    Trace   = 0;
    UINT    Break   = 0;

    DWORD aLevels [] =
    {
    DBG_TRACE,  DBG_NONE,
    DBG_WARN,   DBG_NONE,
    DBG_ERROR,  DBG_NONE,
    DBG_FATAL,  DBG_NONE,
    };

    for (UINT i = 0; i < sizeof(aLevels)/sizeof(*aLevels); i+=2)
    {
        DBG_OPEN(_T("DBG_MESSAGE"), DBG_DEFAULT, aLevels[i], aLevels[i+1]);

        MessageTestHelper(sString, cValue, sValue, iValue, lValue);

        DBG_DISABLE();

        MessageTestHelper(sString, cValue, sValue, iValue, lValue);

        DBG_ENABLE();

        DBG_CLOSE();
    }
}

VOID
BacktraceTest(
    IN INT      ac,
    IN TCHAR    **av
    )
{
    DBG_CAPTURE_HANDLE(Capture);
    DBG_CAPTURE_OPEN(Capture, _T("symbols"), DBG_DEBUGGER, NULL);
    DBG_CAPTURE(Capture, 0, (_T("Capture message %d.\n"), 0));
    DBG_CAPTURE_CLOSE( Capture );
}

VOID
CaptureTest0(
    IN DWORD dwThread
    )
{
    DBG_CAPTURE_HANDLE(Capture);
    DBG_CAPTURE_OPEN(Capture, _T("nosymbols"), DBG_DEBUGGER, NULL);
    DBG_CAPTURE(Capture, 0, (_T("Unicode %d Multi Thread Test.\n"), dwThread));
    DBG_CAPTURE(Capture, 0, ("Ansi %d Multi Thread Test.\n", dwThread));
    DBG_CAPTURE_CLOSE( Capture );
}

VOID
CaptureTest1(
    IN DWORD dwThread
    )
{
    DBG_CAPTURE_HANDLE(Capture);
    DBG_CAPTURE_OPEN(Capture, _T("nosymbols"), DBG_DEBUGGER, NULL);
    DBG_CAPTURE(Capture, 0, (_T("Unicode %d Multi Thread Test.\n"), dwThread));
    DBG_CAPTURE(Capture, 0, ("Ansi %d Multi Thread Test.\n", dwThread));
    DBG_CAPTURE_CLOSE( Capture );
}


DWORD
MultiThreadProc0(
    IN LPVOID lpThreadParameter
    )
{
    for ( UINT i = 10 ; i ; i-- )
    {
        DBG_OPEN(_T("DBG_MULTITHREAD 0"), DBG_DEFAULT, DBG_TRACE, DBG_NONE);
        DBG_MSG(DBG_TRACE, ("TestFunction return value\n"));
        DBG_CLOSE();
//        CaptureTest0(0);
        MessageTest(0, NULL);
    }
    return 0;
}

DWORD
MultiThreadProc1(
    IN LPVOID lpThreadParameter
    )
{
    for ( UINT i = 10 ; i ; i-- )
    {
        DBG_OPEN(_T("DBG_MULTITHREAD 1"), DBG_DEFAULT, DBG_TRACE, DBG_NONE);
        DBG_MSG(DBG_TRACE, ("TestFunction return value\n"));
        DBG_CLOSE();
//        CaptureTest1(1);
        MessageTest(0, NULL);
    }
    return 0;
}


VOID
ThreadTest(
    IN INT      ac,
    IN TCHAR    **av
    )
{
    DWORD   dwThreadId      = 0;
    HANDLE  ahThreads[2]    = {0};

    ahThreads[0] = CreateThread(NULL, 0, MultiThreadProc0, (PVOID)0, 0, &dwThreadId);
    ahThreads[1] = CreateThread(NULL, 0, MultiThreadProc1, (PVOID)1, 0, &dwThreadId);

    if (ahThreads[0] && ahThreads[1])
    {
        WaitForMultipleObjects(2, ahThreads, TRUE, INFINITE);
    }

    if (ahThreads[0])
    {
        CloseHandle(ahThreads[0]);
    }

    if (ahThreads[1])
    {
        CloseHandle(ahThreads[1]);
    }
}

VOID
DllTest(
    IN INT      ac,
    IN TCHAR    **av
    )
{
    DllFunction1(0xCAFECAFE);
}

VOID
TimestampTest(
    IN INT      ac,
    IN TCHAR    **av
    )
{
    DBG_OPEN(_T("DBG_TIME"), DBG_DEFAULT, DBG_TRACE|DBG_TIMESTAMP|DBG_THREADID, DBG_NONE);

    DBG_MSG(DBG_TRACE, ("Test Message\n"));

    DBG_CLOSE();

    DBG_OPEN(_T("DBG_TIME"), DBG_DEFAULT, DBG_TRACE|DBG_TIMESTAMP|DBG_THREADID, DBG_NONE);

    DBG_SET_FIELD_FORMAT(DBG_TIMESTAMP, _T(" Tick Count (%x)"));

    DBG_SET_FIELD_FORMAT(DBG_THREADID, _T(" Thread Id = [%d]"));

    DBG_MSG(DBG_TRACE, ("Test Message\n"));

    DBG_CLOSE();

}


VOID
MemoryLeakTest(
    IN INT      ac,
    IN TCHAR    **av
    )
{
    DBG_OPEN(_T("DBG_MEMORY"), DBG_DEFAULT, DBG_TRACE|DBG_WARN, DBG_NONE);

    DBG_MSG(DBG_TRACE, ("Test memory leak detection\n"));

    int *pInt = (int *)malloc(10);
    WCHAR *pChar = new WCHAR[10];

    DBG_CLOSE();
}

extern "C"
INT
_cdecl
_tmain(
    IN INT      ac,
    IN TCHAR    **av
    )
{
    ac--, av++;

    LPCTSTR pszName = *av ? *av : _T("");
    BOOL    bTestExecuted = FALSE;

    typedef VOID(*pfTest)(INT, TCHAR**);

    struct Test
    {
        LPCTSTR pszName;
        LPCTSTR pszDesc;
        pfTest  pFunction;
    };

    Test aTests [] =
    {
    {_T("Tracer"),          _T("Tests trace messages"),                         TracerTest},
    {_T("Status"),          _T("Test TStatus[X] functionality"),                StatusTest},
    {_T("Message"),         _T("Test message macros, trace and break levels"),  MessageTest},
    {_T("Backtrace"),       _T("Test backtrace capture code"),                  BacktraceTest},
    {_T("Thread"),          _T("Test multi thread support"),                    ThreadTest},
    {_T("Dll"),             _T("Test dll functionality"),                       DllTest},
    {_T("Time"),            _T("Test time stamp functionality"),                TimestampTest},
    {_T("Memory"),          _T("Test crt memory leak detections"),              MemoryLeakTest},
    {_T(""),                _T(""),                                             NULL},
    };

    for (Test *pTst = aTests; pTst->pFunction; pTst++)
    {
        if(!_tcsnicmp(pszName, pTst->pszName, _tcslen(pszName)))
        {
            DBG_INIT();
            DBG_MEMORY_INIT();

            pTst->pFunction(ac, av);

            bTestExecuted = TRUE;

            DBG_MEMORY_RELEASE();
            DBG_RELEASE();
        }
    }

    if (!bTestExecuted)
    {
        _tprintf(_T("Available Tests:\n"));

        for (Test *p = aTests; p->pFunction; p++)
        {
            _tprintf(_T("\t%s%*s%s\n"), p->pszName, 12-_tcslen(p->pszName), _T(""), p->pszDesc);
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\dbglib\test\dll\dbgdll.cxx ===
#include "precomp.hxx"
#pragma hdrstop

#include "dbgdll.hxx"

BOOL
DllMain(
    IN HINSTANCE    hInst,
    IN DWORD        dwReason,   
    IN LPVOID       lpRes
    )
{
    BOOL bReturn = TRUE;

    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        //
        // Print raw message for debugging the debug library.
        //
        DBG_RAW( _T("DLL_PROCESS_ATTACH") );

        //
        // The ddebug library needs initialization.
        //
        DBG_INIT();

        //
        // Open this dll's debug messages.
        //
        DBG_OPEN( _T("DBGDLL"), NULL, DBG_TRACE, DBG_NONE );

        break;

    case DLL_PROCESS_DETACH:

        //
        // Close this dll's debug messages.
        //
        DBG_CLOSE();

        //
        // Must release the debug library resources.
        //
        DBG_RELEASE();

        //
        // Print raw message for debugging the debug library.
        //
        DBG_RAW( _T("DLL_PROCESS_DETACH") );
        break;

    default:
        break;
    }

    return bReturn;
}


VOID
WINAPI
DllFunction1(
    UINT uValue
    )
{
    DBG_TRACER( _T("DllFunction1") );

    DBG_MSG( DBG_TRACE, ( _T("DllFunction1 Value %d\n"), uValue ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\exts\dumpmem.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    dumpmem.cxx

Abstract:

    Dumps a spllib heap list looking for backtraces.

Author:

    Albert Ting (AlbertT)  20-Feb-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

VOID
TDebugExt::
vDumpMem(
    LPCSTR pszFile
    )

/*++

Routine Description:

    Takes an input file of heap blocks and dumps the backtraces.

Arguments:

    pszFile - Space terminated input file name.

Return Value:

--*/

{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    CHAR szFile[MAX_PATH];
    LPSTR pcMark;
    BOOL bMore = TRUE;

    enum {
        kLineMax = 0x100
    };

    //
    // Copy & terminate file name.
    //
    lstrcpynA( szFile, pszFile, COUNTOF( szFile ));

    for( pcMark = szFile;
         *pcMark && ( *pcMark != ' ' );
         ++pcMark ){

        ;
    }

    //
    // If space found, null terminate.
    //
    if( *pcMark ){
        *pcMark = 0;
    }

    //
    // Create the file for reading.
    //
    hFile = CreateFileA( szFile,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_ALWAYS,
                         0,
                         NULL );

    if( hFile == INVALID_HANDLE_VALUE ){
        Print( "Unable to open file %s\n", szFile );
        goto Done;
    }

    //
    // Loop until EOF.
    //
    while( bMore ){

        CHAR szLine[ kLineMax ];

        if( CheckControlCRtn()){
            Print( "Aborted.\n" );
            goto Done;
        }

        INT i;

        //
        // Read a line.
        //
        for( i=0; i< COUNTOF( szLine ) - 1; ++i ){

            DWORD dwBytesRead = 0;
            BOOL bLeading = TRUE;

            ReadFile( hFile,
                      &szLine[i],
                      sizeof( szLine[i] ),
                      &dwBytesRead,
                      NULL );

            if( dwBytesRead != sizeof( szLine[i] )){
                goto Done;
            }

            if( szLine[i] == '\n' ){
                break;
            }
        }

        //
        // Null terminate.
        //
        szLine[i] = 0;

        LPSTR pszLine;

        //
        // Remove leading zeros and spaces.
        //
        for( pszLine = szLine;
             *pszLine == ' ' || *pszLine == '0';
             ++pszLine ){
            ;
        }

        //
        // Terminate at first colon if necessary.
        //
        for( pcMark = pszLine; *pcMark; ++pcMark ){

            if( *pcMark == ':' ){

                //
                // Null terminate.
                //
                *pcMark = 0;
                break;
            }
        }

        //
        // Received line, get address.
        //
        UINT_PTR Addr = TDebugExt::dwEval( pszLine );

        struct SPLLIB_HEADER {
            DWORD cbSize;
            DWORD AddrBt;
        };

        SPLLIB_HEADER SpllibHeader;
        ZeroMemory( &SpllibHeader, sizeof( SpllibHeader ));

        move( SpllibHeader, Addr+8 );

        Print( "bt= %x s= %x  %x\n\n",
               SpllibHeader.AddrBt,
               SpllibHeader.cbSize,
               Addr );

        //
        // Dump backtrace.
        //
        vDumpTrace( SpllibHeader.AddrBt );

        Print( "\n" );
    }

Done:

    if( hFile != INVALID_HANDLE_VALUE ){
        CloseHandle( hFile );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\exts\localspl.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    localspl.cxx

Abstract:

    SUR localspl structures.

Author:

    Albert Ting (AlbertT)  19-Feb-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

extern "C" {
#include "spltypes.h"
}

/********************************************************************

    Localspl structures; mostly defined in localspl\spltypes.h

********************************************************************/

BOOL
TDebugExt::
bDumpIniSpooler(
    PVOID pIniSpooler_,
    ULONG_PTR dwAddr
    )
{
    static DEBUG_FLAGS adfSpl[] = {
        { "UpdateWinIniDevices",     SPL_UPDATE_WININI_DEVICES },
        { "PrinterChanges",          SPL_PRINTER_CHANGES       },
        { "LogEvents",               SPL_LOG_EVENTS            },
        { "FormsChange",             SPL_FORMS_CHANGE          },
        { "BroadcastChange",         SPL_BROADCAST_CHANGE      },
        { "SecurityCheck",           SPL_SECURITY_CHECK        },
        { "OpenCreatePorts",         SPL_OPEN_CREATE_PORTS     },
        { "FailOpenPrintersPendDel", SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION },
        { "RemoteHandleCheck",       SPL_REMOTE_HANDLE_CHECK   },
        { "PrinterDriverEvent",      SPL_PRINTER_DRIVER_EVENT  },
        { "AlwaysCreateDriverShare", SPL_ALWAYS_CREATE_DRIVER_SHARE },
        { "NoUpdatePrinterIni",      SPL_NO_UPDATE_PRINTERINI  },
        { "NoUpdateJobShd",          SPL_NO_UPDATE_JOBSHD      },
        { "ClusterReg",              SPL_CLUSTER_REG           },
        { "Offline",                 SPL_OFFLINE               },
        { "PendingDeletion",         SPL_PENDING_DELETION      },
        { "ServerThread",            SPL_SERVER_THREAD         },
        { "Print",                   SPL_PRINT                 },
        { "TypeLocal",               SPL_TYPE_LOCAL            },
        { "TypeCluster",             SPL_TYPE_CLUSTER          },
        { NULL,                      0                         }
    };

    PINISPOOLER pIniSpooler = (PINISPOOLER)pIniSpooler_;

    if( !( pIniSpooler->signature == ISP_SIGNATURE )){
        return FALSE;
    }

    Print( "IniSpooler*\n" );

    Print( "        pIniNextSpooler %x\n", pIniSpooler->pIniNextSpooler );
    Print( "                   cRef <%d>\n", pIniSpooler->cRef );
    Print( "           pMachineName " ); vDumpStr( pIniSpooler->pMachineName );
    Print( "            cOtherNames <%d>\n", pIniSpooler->cOtherNames );
    Print( "         ppszOtherNames @@ %x\n", pIniSpooler->ppszOtherNames );
    Print( "                   pDir " ); vDumpStr( pIniSpooler->pDir );

    Print( "            pIniPrinter %x\n", pIniSpooler->pIniPrinter );
    Print( "        pIniEnvironment %x\n", pIniSpooler->pIniEnvironment );
    Print( "            pIniMonitor %x\n", pIniSpooler->pIniMonitor );
    Print( "               pIniPort %x\n", pIniSpooler->pIniPort );
    Print( "                pShared %x\n", pIniSpooler->pShared );
    Print( "           pIniNetPrint %x\n", pIniSpooler->pIniNetPrint );
    Print( "                 pSpool %x\n", pIniSpooler->pSpool );

    Print( "       pDefaultSpoolDir " ); vDumpStr( pIniSpooler->pDefaultSpoolDir );

    Print( "    pszRegistryMonitors " ); vDumpStr(  pIniSpooler->pszRegistryMonitors );
    Print( "pszRegistryEnvironments " ); vDumpStr(  pIniSpooler->pszRegistryEnvironments );
    Print( "    pszRegistryEventLog " ); vDumpStr(  pIniSpooler->pszRegistryEventLog );
    Print( "   pszRegistryProviders " ); vDumpStr(  pIniSpooler->pszRegistryProviders );
    Print( "     pszEventLogMsgFile " ); vDumpStr(  pIniSpooler->pszEventLogMsgFile );

    Print( "      pDriversShareInfo %x\n", pIniSpooler->pDriversShareInfo );
    Print( "        pszDriversShare " ); vDumpStr(  pIniSpooler->pszDriversShare );
    Print( "       pszRegistryForms " ); vDumpStr(  pIniSpooler->pszRegistryForms );

    Print( "           SpoolerFlags " );
    vDumpFlags( pIniSpooler->SpoolerFlags, adfSpl );


    Print( "     pfnReadRegistryExtra %x\n", pIniSpooler->pfnReadRegistryExtra );
    Print( "    pfnWriteRegistryExtra %x\n", pIniSpooler->pfnWriteRegistryExtra );
    Print( "      pfnFreePrinterExtra %x\n", pIniSpooler->pfnFreePrinterExtra );

    Print( "     cEnumNetworkPrinters <%d>\n", pIniSpooler->cEnumerateNetworkPrinters );
    Print( "          cAddNetPrinters <%d>\n", pIniSpooler->cAddNetPrinters );
    Print( "            cFormOrderMax <%d>\n", pIniSpooler->cFormOrderMax );
    Print( "    pNoRemotePrintDrivers " ); vDumpStr( pIniSpooler->pNoRemotePrintDrivers );
    Print( "  cchNoRemotePrintDrivers <%d>\n", pIniSpooler->cchNoRemotePrintDrivers );
    Print( "                  hckRoot %x\n", pIniSpooler->hckRoot );
    Print( "              hckPrinters %x\n", pIniSpooler->hckPrinters );
    Print( "        cFullPrintingJobs <%d>\n", pIniSpooler->cFullPrintingJobs );
    Print( "     hEventNoPrintingJobs %x\n", pIniSpooler->hEventNoPrintingJobs );
    Print( "                hJobIdMap %x\n", pIniSpooler->hJobIdMap );
    Print( "           dwEventLogging <%d>\n", pIniSpooler->dwEventLogging );
    Print( "         bEnableNetPopups <%d>\n", pIniSpooler->bEnableNetPopups );
    Print( "   dwJobCompletionTimeout <%d>\n", pIniSpooler->dwJobCompletionTimeout );
    Print( "            dwBeepEnabled <%d>\n", pIniSpooler->dwBeepEnabled );
    Print( "bEnableNetPopupToComputer <%d>\n", pIniSpooler->bEnableNetPopupToComputer );
    Print( "       bEnableRetryPopups <%d>\n", pIniSpooler->bEnableRetryPopups );
    Print( "           pszClusterGUID " ); vDumpStr(  pIniSpooler->pszClusterGUID );
    Print( "            hClusterToken <%d>\n", pIniSpooler->hClusterToken );
    Print( "dwRestartJobOnPoolTimeout <%d>\n", pIniSpooler->dwRestartJobOnPoolTimeout );
    Print( " bRestartJobOnPoolEnabled <%d>\n", pIniSpooler->bRestartJobOnPoolEnabled );
    Print( "                bImmortal <%d>\n", pIniSpooler->bImmortal );
    Print( "       pszFullMachineName " ); vDumpStr(  pIniSpooler->pszFullMachineName );

    return TRUE;
}

BOOL
TDebugExt::
bDumpIniPrintProc(
    PVOID pIniPrintProc_,
    ULONG_PTR dwAddr
    )
{
    PINIPRINTPROC pIniPrintProc = (PINIPRINTPROC)pIniPrintProc_;

    static DEBUG_FLAGS adfSpl[] = {
        { "UpdateWinIniDevices",  SPL_UPDATE_WININI_DEVICES },
        { NULL,                   0                         }
    };

    if( !( pIniPrintProc->signature == IPP_SIGNATURE )){
        return FALSE;
    }

    Print( "IniPrintProc*\n" );

    Print( "            pNext %x\n", pIniPrintProc->pNext );
    Print( "             cRef <%d>\n", pIniPrintProc->cRef );

    Print( "            pName " ); vDumpStr( pIniPrintProc->pName );
    Print( "         pDLLName " ); vDumpStr( pIniPrintProc->pDLLName );

    Print( "      cbDatatypes %x\n", pIniPrintProc->cbDatatypes );
    Print( "       cDatatypes %x\n", pIniPrintProc->cDatatypes );
    Print( "       pDatatypes %x\n", pIniPrintProc->pDatatypes );
    Print( "        hLibrary %x\n", pIniPrintProc->hLibrary );
    Print( "         Install %x\n", pIniPrintProc->Install );
    Print( "    EnumDatatypes %x\n", pIniPrintProc->EnumDatatypes );
    Print( "             Open %x\n", pIniPrintProc->Open );
    Print( "            Print %x\n", pIniPrintProc->Print );
    Print( "            Close %x\n", pIniPrintProc->Close );
    Print( "          Control %x\n", pIniPrintProc->Control );
    Print( "  CriticalSection @ %x\n", dwAddr
                                       + OFFSETOF( INIPRINTPROC, CriticalSection ));

    return TRUE;
}

BOOL
TDebugExt::
bDumpIniDriver(
    PVOID pIniDriver_,
    ULONG_PTR dwAddr
    )
{
    PINIDRIVER pIniDriver = (PINIDRIVER)pIniDriver_;

    static DEBUG_FLAGS adfSpl[] = {
        { "UpdateWinIniDevices",  SPL_UPDATE_WININI_DEVICES },
        { NULL,                   0                         }
    };

    if( !( pIniDriver->signature == ID_SIGNATURE )){
        return FALSE;
    }

    Print( "IniDriver*\n" );

    Print( "             pNext %x\n", pIniDriver->pNext );
    Print( "              cRef <%d>\n", pIniDriver->cRef );

    Print( "             pName " ); vDumpStr( pIniDriver->pName );
    Print( "       pDriverFile " ); vDumpStr( pIniDriver->pDriverFile );
    Print( "       pConfigFile " ); vDumpStr( pIniDriver->pConfigFile );
    Print( "         pDataFile " ); vDumpStr( pIniDriver->pDataFile );
    Print( "         pHelpFile " ); vDumpStr( pIniDriver->pHelpFile );

    Print( " cchDependentFiles %x\n", pIniDriver->cchDependentFiles );
    Print( "   pDependentFiles %x\n", pIniDriver->pDependentFiles );

    Print( "      pMonitorName " ); vDumpStr( pIniDriver->pMonitorName );
    Print( "  pDefaultDataType " ); vDumpStr( pIniDriver->pDefaultDataType );

    Print( "          cVersion %x\n", pIniDriver->cVersion );
    Print( "   pIniLangMonitor %x\n", pIniDriver->pIniLangMonitor );

    return TRUE;
}

BOOL
TDebugExt::
bDumpIniVersion(
    PVOID pIniVersion_,
    ULONG_PTR dwAddr
    )
{
    PINIVERSION pIniVersion = (PINIVERSION)pIniVersion_;

    if( !( pIniVersion->signature == IV_SIGNATURE )){
        return FALSE;
    }

    Print( "IniVersion*\n" );

    Print( "         pNext %x\n", pIniVersion->pNext );
    Print( "         pName " ); vDumpStr( pIniVersion->pName );
    Print( "   szDirectory " ); vDumpStr( pIniVersion->szDirectory );
    Print( " cMajorVersion %x\n", pIniVersion->cMajorVersion );
    Print( " cMinorVersion %x\n", pIniVersion->cMinorVersion );
    Print( "    pIniDriver %x\n", pIniVersion->pIniDriver );

    return TRUE;
}


BOOL
TDebugExt::
bDumpIniEnvironment(
    PVOID pIniEnvironment_,
    ULONG_PTR dwAddr
    )
{
    PINIENVIRONMENT pIniEnvironment = (PINIENVIRONMENT)pIniEnvironment_;

    if( !( pIniEnvironment->signature == IE_SIGNATURE )){
        return FALSE;
    }

    Print( "IniEnvironment*\n" );

    Print( "         pNext %x\n", pIniEnvironment->pNext );
    Print( "          cRef <%d>\n", pIniEnvironment->cRef );

    Print( "         pName " ); vDumpStr(  pIniEnvironment->pName );
    Print( "    pDirectory " ); vDumpStr(  pIniEnvironment->pDirectory );

    Print( "   pIniVersion %x\n", pIniEnvironment->pIniVersion );
    Print( " pIniPrintProc %x\n", pIniEnvironment->pIniPrintProc );
    Print( "   pIniSpooler %x\n", pIniEnvironment->pIniSpooler );

    return TRUE;
}



BOOL
TDebugExt::
bDumpIniMonitor(
    PVOID pIniMonitor_,
    ULONG_PTR dwAddr
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)pIniMonitor_;

    if( !( pIniMonitor->signature == IMO_SIGNATURE )){
        return FALSE;
    }

    Print( "IniMonitor*\n" );

    Print( "         pNext %x\n", pIniMonitor->pNext );
    Print( "          cRef <%d>\n", pIniMonitor->cRef );

    Print( "         pName " ); vDumpStr(  pIniMonitor->pName );
    Print( "   pMonitorDll " ); vDumpStr(  pIniMonitor->pMonitorDll );

    Print( "       hModule %x\n", pIniMonitor->hModule );
    Print( " ==   Monitor2 ==\n" );
    Print( "        EnumPorts %x\n", pIniMonitor->Monitor2.pfnEnumPorts );
    Print( "         OpenPort %x\n", pIniMonitor->Monitor2.pfnOpenPort );
    Print( "       OpenPortEx %x\n", pIniMonitor->Monitor2.pfnOpenPortEx );
    Print( "     StartDocPort %x\n", pIniMonitor->Monitor2.pfnStartDocPort );
    Print( "        WritePort %x\n", pIniMonitor->Monitor2.pfnWritePort );
    Print( "         ReadPort %x\n", pIniMonitor->Monitor2.pfnReadPort );
    Print( "       EndDocPort %x\n", pIniMonitor->Monitor2.pfnEndDocPort );
    Print( "        ClosePort %x\n", pIniMonitor->Monitor2.pfnClosePort );
    Print( "          AddPort %x\n", pIniMonitor->Monitor2.pfnAddPort );
    Print( "       AddPortsEx %x\n", pIniMonitor->Monitor2.pfnAddPortEx );
    Print( "    ConfigurePort %x\n", pIniMonitor->Monitor2.pfnConfigurePort );
    Print( "       DeletePort %x\n", pIniMonitor->Monitor2.pfnDeletePort );
    Print( "    GetPDFromPort %x\n", pIniMonitor->Monitor2.pfnGetPrinterDataFromPort );
    Print( "  SetPortTimeOuts %x\n", pIniMonitor->Monitor2.pfnSetPortTimeOuts );
    Print( "      XcvOpenPort %x\n", pIniMonitor->Monitor2.pfnXcvOpenPort );
    Print( "      XcvDataPort %x\n", pIniMonitor->Monitor2.pfnXcvDataPort );
    Print( "     XcvClosePort %x\n", pIniMonitor->Monitor2.pfnXcvClosePort );
    Print( "         Shutdown %x\n", pIniMonitor->Monitor2.pfnShutdown );

    Print( "     Monitor @ %x\n", dwAddr + OFFSETOF( INIMONITOR, Monitor ));
    Print( "   pIniSpooler %x\n", pIniMonitor->pIniSpooler );

    return TRUE;
}

BOOL
TDebugExt::
bDumpIniPort(
    PVOID pIniPort_,
    ULONG_PTR dwAddr
    )
{
    PINIPORT pIniPort = (PINIPORT)pIniPort_;

    if( !( pIniPort->signature == IPO_SIGNATURE )){
        return FALSE;
    }

    Print( "IniPort*\n" );

    Print( "            pNext %x\n", pIniPort->pNext );
    Print( "             cRef <%d>\n", pIniPort->cRef );

    Print( "            pName " ); vDumpStr(  pIniPort->pName );

    Print( "            hProc %x\n", pIniPort->hProc );
    Print( "           Status %x\n", pIniPort->Status );
    Print( "    PrinterStatus %x\n", pIniPort->PrinterStatus );
    Print( "        pszStatus " ); vDumpStr(  pIniPort->pszStatus );

    Print( "        Semaphore %x\n", pIniPort->Semaphore );
    Print( "          pIniJob %x\n", pIniPort->pIniJob );
    Print( "        cPrinters <%d>\n", pIniPort->cPrinters );
    Print( "     ppIniPrinter %x\n", pIniPort->ppIniPrinter );
    Print( "      pIniMonitor %x\n", pIniPort->pIniMonitor );
    Print( "  pIniLangMonitor %x\n", pIniPort->pIniLangMonitor );

    Print( "           hEvent %x\n", pIniPort->hEvent );
    Print( "            hPort %x\n", pIniPort->hPort );
    Print( "            Ready %x\n", pIniPort->Ready );
    Print( "      hPortThread %x\n", pIniPort->hPortThread );
    Print( "      pIniSpooler %x\n", pIniPort->pIniSpooler );
    Print( "InCriticalSection %x\n", pIniPort->InCriticalSection );

    return TRUE;
}

BOOL
TDebugExt::
bDumpIniJob(
    PVOID pIniJob_,
    ULONG_PTR dwAddr
    )
{
    PINIJOB pIniJob = (PINIJOB)pIniJob_;

    static DEBUG_FLAGS adfJobStatus[] = {
        { "Printing",           JOB_PRINTING            },
        { "Paused",             JOB_PAUSED              },
        { "Error",              JOB_ERROR               },
        { "Offline",            JOB_OFFLINE             },
        { "PaperOut",           JOB_PAPEROUT            },
        { "PendingDeletion",    JOB_PENDING_DELETION    },
        { "Spooling",           JOB_SPOOLING            },
        { "Despooling",         JOB_DESPOOLING          },
        { "Direct",             JOB_DIRECT              },
        { "Complete",           JOB_COMPLETE            },
        { "Printed",            JOB_PRINTED             },
        { "Restart",            JOB_RESTART             },
        { "Remote",             JOB_REMOTE              },
        { "NotificationSent",   JOB_NOTIFICATION_SENT   },
        { "PrintToFile",        JOB_PRINT_TO_FILE       },
        { "TypeAddJob",         JOB_TYPE_ADDJOB         },
        { "BlockedDevQ",        JOB_BLOCKED_DEVQ        },
        { "SchecduleJob",       JOB_SCHEDULE_JOB        },
        { "Timeout",            JOB_TIMEOUT             },
        { "Abandon",            JOB_ABANDON             },
        { "Deleted",            JOB_DELETED             },
        { "TrueEOJ",            JOB_TRUE_EOJ            },
        { "Compound/Hidden",    JOB_COMPOUND            },
        { NULL,                0                        }
    };

    if( !( pIniJob->signature == IJ_SIGNATURE )){
        return FALSE;
    }

    Print( "IniJob*\n" );

    Print( "     pIniNextJob %x\n", pIniJob->pIniNextJob );
    Print( "     pIniPrevJob %x\n", pIniJob->pIniPrevJob );
    Print( "            cRef <%d>\n", pIniJob->cRef );
    Print( "          Status " ); vDumpFlags( pIniJob->Status, adfJobStatus );
    Print( "           JobId <%d>\n", pIniJob->JobId );
    Print( "        Priority <%d>\n", pIniJob->Priority );

    Print( "         pNotify " ); vDumpStr( pIniJob->pNotify );
    Print( "           pUser " ); vDumpStr( pIniJob->pUser );
    Print( "    pMachineName " ); vDumpStr( pIniJob->pMachineName );
    Print( "       pDocument " ); vDumpStr( pIniJob->pDocument );
    Print( "     pOutputFile " ); vDumpStr( pIniJob->pOutputFile );

    Print( "     pIniPrinter %x\n", pIniJob->pIniPrinter );
    Print( "      pIniDriver %x\n", pIniJob->pIniDriver );
    Print( "        pDevMode %x\n", pIniJob->pDevMode );
    Print( "   pIniPrintProc %x\n", pIniJob->pIniPrintProc );
    Print( "       pDatatype " ); vDumpStr( pIniJob->pDatatype );
    Print( "     pParameters " ); vDumpStr( pIniJob->pParameters );

    Print( "       Submitted @ %x\n", dwAddr + OFFSETOF( INIJOB, Submitted ));
    Print( "            Time %x\n", pIniJob->Time );
    Print( "       StartTime %x\n", pIniJob->StartTime );
    Print( "       UntilTime %x\n", pIniJob->UntilTime );

    Print( "            Size %x\n", pIniJob->Size );
    Print( "      hWriteFile  %x\n", pIniJob->hWriteFile );
    Print( "         pStatus " ); vDumpStr( pIniJob->pStatus );

    Print( "         pBuffer %x\n", pIniJob->pBuffer );
    Print( "        cbBuffer %x\n", pIniJob->cbBuffer );
    Print( "     WaitForRead %x\n", pIniJob->WaitForRead );
    Print( "    WaitForWrite %x\n", pIniJob->WaitForWrite );

    Print( "StartDocComplete %x\n", pIniJob->StartDocComplete );
    Print( "   StartDocError %x\n", pIniJob->StartDocError );
    Print( "        pIniPort %x\n", pIniJob->pIniPort );
    Print( "          hToken %x\n", pIniJob->hToken );
    Print( "             pSD %x\n", pIniJob->pSecurityDescriptor );
    Print( "   cPagesPrinted %x\n", pIniJob->cPagesPrinted );
    Print( "          cPages %x\n", pIniJob->cPages );

    Print( " GenerateOnClose %x\n", pIniJob->GenerateOnClose );
    Print( "       cbPrinted %x\n", pIniJob->cbPrinted );

    Print( "       NextJobId %x\n", pIniJob->NextJobId );
    Print( "  pCurrentIniJob %x\n", pIniJob->pCurrentIniJob );

    return TRUE;
}


BOOL
TDebugExt::
bDumpSpool(
    PVOID pSpool_,
    ULONG_PTR dwAddr
    )
{
    PSPOOL pSpool = (PSPOOL)pSpool_;

    if( !( pSpool->signature == SJ_SIGNATURE )){
        return FALSE;
    }

    Print( "Spool*\n" );

    Print( "            pNext %x\n", pSpool->pNext );
    Print( "             cRef <%d>\n", pSpool->cRef );

    Print( "            pName " ); vDumpStr(  pSpool->pName );
    Print( "         pDatatpe " ); vDumpStr(  pSpool->pDatatype );


    Print( "    pIniPrintProc %x\n", pSpool->pIniPrintProc );
    Print( "         pDevMode %x\n", pSpool->pDevMode );
    Print( "      pIniPrinter %x\n", pSpool->pIniPrinter );
    Print( "         pIniPort %x\n", pSpool->pIniPort );
    Print( "          pIniJob %x\n", pSpool->pIniJob );
    Print( "     TypeofHandle %x\n", pSpool->TypeofHandle );
    Print( "      pIniNetPort %x\n", pSpool->pIniNetPort );
    Print( "            hPort %x\n", pSpool->hPort );
    Print( "           Status %x\n", pSpool->Status );
    Print( "    GrantedAccess %x\n", pSpool->GrantedAccess );
    Print( "      ChangeFlags %x\n", pSpool->ChangeFlags );
    Print( "        WaitFlags %x\n", pSpool->WaitFlags );
    Print( "     pChangeFlags %x\n", pSpool->pChangeFlags );
    Print( "      ChangeEvent %x\n", pSpool->ChangeEvent );
    Print( "    OpenPortError %x\n", pSpool->OpenPortError );
    Print( "          hNotify %x\n", pSpool->hNotify );
    Print( "          eStatus %x\n", pSpool->eStatus );
    Print( "      pIniSpooler %x\n", pSpool->pIniSpooler );

    Print( "  GenerateOnClose %x\n", pSpool->GenerateOnClose );
    Print( "            hFile %x\n", pSpool->hFile );
    Print( "adwNotifyVectors @ %x\n", dwAddr
                                      + OFFSETOF( SPOOL, adwNotifyVectors ));

    Print( "        pUserName " ); vDumpStr(  pSpool->SplClientInfo1.pUserName );
    Print( "     pMachineName " ); vDumpStr(  pSpool->SplClientInfo1.pMachineName );

    return TRUE;
}

BOOL
TDebugExt::
bDumpIniPrinter(
    PVOID pIniPrinter_,
    ULONG_PTR dwAddr
    )
{
    PINIPRINTER pIniPrinter = (PINIPRINTER)pIniPrinter_;

    static DEBUG_FLAGS adfStatus[] = {
        { "Paused",           PRINTER_PAUSED           },
        { "Error",            PRINTER_ERROR            },
        { "Offline",          PRINTER_OFFLINE          },
        { "PaperOut",         PRINTER_PAPEROUT         },
        { "PendingDeletion",  PRINTER_PENDING_DELETION },
        { "ZombieObject",     PRINTER_ZOMBIE_OBJECT    },
        { "PendingCreation",  PRINTER_PENDING_CREATION },
        { "Ok",               PRINTER_OK               },
        { "FromReg",          PRINTER_FROM_REG         },
        { "WasShared",        PRINTER_WAS_SHARED       },
        { NULL,               0                        }
    };

    static DEBUG_FLAGS adfAttributes[] = {
        { "Queued",           PRINTER_ATTRIBUTE_QUEUED       },
        { "Direct",           PRINTER_ATTRIBUTE_DIRECT       },
        { "Default",          PRINTER_ATTRIBUTE_DEFAULT      },
        { "Shared",           PRINTER_ATTRIBUTE_SHARED       },
        { "Network",          PRINTER_ATTRIBUTE_NETWORK      },
        { "Hidden",           PRINTER_ATTRIBUTE_HIDDEN       },
        { "Local",            PRINTER_ATTRIBUTE_LOCAL        },
        { "DevQ",             PRINTER_ATTRIBUTE_ENABLE_DEVQ  },
        { "KeepPrintedJobs",  PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS   },
        { "DoCompletedFirst", PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST },
        { "WorkOffline",      PRINTER_ATTRIBUTE_WORK_OFFLINE   },
        { "EnableBidi",       PRINTER_ATTRIBUTE_ENABLE_BIDI    },
        { NULL,               0                                }
    };

    if( !( pIniPrinter->signature == IP_SIGNATURE )){
        return FALSE;
    }

    Print( "IniPrinter*\n" );

    Print( "               pNext %x\n", pIniPrinter->pNext );
    Print( "                cRef %x\n", pIniPrinter->cRef );
    Print( "               pName " ); vDumpStr( pIniPrinter->pName );
    Print( "          pShareName " ); vDumpStr( pIniPrinter->pShareName );

    Print( "       pIniPrintProc %x\n", pIniPrinter->pIniPrintProc );

    Print( "           pDatatype " ); vDumpStr( pIniPrinter->pDatatype );
    Print( "         pParameters " ); vDumpStr( pIniPrinter->pParameters );
    Print( "            pComment " ); vDumpStr( pIniPrinter->pComment );

    Print( "          pIniDriver %x\n", pIniPrinter->pIniDriver );
    Print( "           cbDevMode %x\n", pIniPrinter->cbDevMode );
    Print( "            pDevMode %x\n", pIniPrinter->pDevMode );
    Print( "            Priority <%d>\n", pIniPrinter->Priority );
    Print( "     DefaultPriority <%d>\n", pIniPrinter->DefaultPriority );

    Print( "           StartTime %x\n", pIniPrinter->StartTime );
    Print( "           UntilTime %x\n", pIniPrinter->UntilTime );
    Print( "            pSepFile " ); vDumpStr( pIniPrinter->pSepFile );

    Print( "              Status " );
    vDumpFlags( pIniPrinter->Status, adfStatus );

    Print( "           pLocation " ); vDumpStr( pIniPrinter->pLocation );
    Print( "          Attributes " );
    vDumpFlags( pIniPrinter->Attributes, adfAttributes );

    Print( "               cJobs <%d>\n", pIniPrinter->cJobs );
    Print( "          AveragePPM %x\n", pIniPrinter->AveragePPM );
    Print( "     GenerateOnClose %x\n", pIniPrinter->GenerateOnClose );
    Print( "         pIniNetPort %x\n", pIniPrinter->pIniNetPort );
    Print( " ====   pIniFirstJob %x\n", pIniPrinter->pIniFirstJob );
    Print( "         pIniLastJob %x\n", pIniPrinter->pIniLastJob );
    Print( " pSecurityDescriptor %x\n", pIniPrinter->pSecurityDescriptor );
    Print( "              pSpool %x\n", pIniPrinter->pSpool );

    Print( "           pSpoolDir " ); vDumpStr( pIniPrinter->pSpoolDir );
    Print( "          cTotalJobs %x\n", pIniPrinter->cTotalJobs );
    Print( "         cTotalBytes %x\n", pIniPrinter->cTotalBytes );
    Print( "            stUpTime " ); vDumpTime( pIniPrinter->stUpTime );
    Print( "             MaxcRef %x\n", pIniPrinter->MaxcRef );
    Print( "  cTotalPagesPrinted %x\n", pIniPrinter->cTotalPagesPrinted );
    Print( "           cSpooling %x\n", pIniPrinter->cSpooling );
    Print( "        cMaxSpooling %x\n", pIniPrinter->cMaxSpooling );
    Print( "    cErrorOutOfPaper %x\n", pIniPrinter->cErrorOutOfPaper );
    Print( "      cErrorNotReady %x\n", pIniPrinter->cErrorNotReady );
    Print( "           cJobError %x\n", pIniPrinter->cJobError );
    Print( "         pIniSpooler %x\n", pIniPrinter->pIniSpooler );
    Print( "          cZombieRef %x\n", pIniPrinter->cZombieRef );
    Print( "         dwLastError %x\n", pIniPrinter->dwLastError );
    Print( "          pExtraData %x\n", pIniPrinter->pExtraData );
    Print( "           cChangeID %x\n", pIniPrinter->cChangeID );
    Print( "          dnsTimeout %x\n", pIniPrinter->dnsTimeout );
    Print( "           txTimeout %x\n", pIniPrinter->txTimeout );
    Print( "       pszObjectGUID " ); vDumpStr( pIniPrinter->pszObjectGUID );
    Print( "         DsKeyUpdate %x\n", pIniPrinter->DsKeyUpdate );
    Print( "DsKeyUpdateForeground %x\n", pIniPrinter->DsKeyUpdateForeground );
    return TRUE;
}


/********************************************************************

    Devmodes

********************************************************************/

DEBUG_FLAGS gadfDevModeFields[] = {
    { "Orientation",  DM_ORIENTATION },
    { "PaperSize",  DM_PAPERSIZE },
    { "PaperLength",  DM_PAPERLENGTH },
    { "PaperWidth",  DM_PAPERWIDTH },
    { "Scale",  DM_SCALE },
    { "Copies",  DM_COPIES },
    { "DefaultSource",  DM_DEFAULTSOURCE },
    { "PrintQuality",  DM_PRINTQUALITY },
    { "Color",  DM_COLOR },
    { "Duplex",  DM_DUPLEX },
    { "YResolution",  DM_YRESOLUTION },
    { "TTOption",  DM_TTOPTION },
    { "Collate",  DM_COLLATE },
    { "FormName",  DM_FORMNAME },
    { "LogPixels",  DM_LOGPIXELS },
    { "BitsPerPel",  DM_BITSPERPEL },
    { "PelsWidth",  DM_PELSWIDTH },
    { "PelsHeight",  DM_PELSHEIGHT },
    { "DisplayFlags",  DM_DISPLAYFLAGS },
    { "DisplayFrequency",  DM_DISPLAYFREQUENCY },
    { "ICMMethod",  DM_ICMMETHOD },
    { "ICMIntent",  DM_ICMINTENT },
    { "MediaType",  DM_MEDIATYPE },
    { "DitherType",  DM_DITHERTYPE },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeDefaultSource[] = {
    { "Upper/OnlyOne", DMBIN_UPPER },
    { "Lower", DMBIN_LOWER },
    { "Middle", DMBIN_MIDDLE },
    { "Manual", DMBIN_MANUAL },
    { "Envelope", DMBIN_ENVELOPE },
    { "EnvManual", DMBIN_ENVMANUAL },
    { "Auto", DMBIN_AUTO },
    { "Tractor", DMBIN_TRACTOR },
    { "SmallFmt", DMBIN_SMALLFMT },
    { "LargeFmt", DMBIN_LARGEFMT },
    { "LargeCapacity", DMBIN_LARGECAPACITY },
    { "Cassette", DMBIN_CASSETTE },
    { "FormSource", DMBIN_FORMSOURCE },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModePapers[] = {
    { "Letter", DMPAPER_LETTER },
    { "Legal", DMPAPER_LEGAL },
    { "A4", DMPAPER_A4 },
    { "CSheet", DMPAPER_CSHEET },
    { "DSheet", DMPAPER_DSHEET },
    { "ESheet", DMPAPER_ESHEET },
    { "LetterSmall", DMPAPER_LETTERSMALL },
    { "Tabloid", DMPAPER_TABLOID },
    { "Ledger", DMPAPER_LEDGER },
    { "Statement", DMPAPER_STATEMENT },
    { "Executive", DMPAPER_EXECUTIVE },
    { "A3", DMPAPER_A3 },
    { "A4Small", DMPAPER_A4SMALL },
    { "A5", DMPAPER_A5 },
    { "B4", DMPAPER_B4 },
    { "B5", DMPAPER_B5 },
    { "Folio", DMPAPER_FOLIO },
    { "Quarto", DMPAPER_QUARTO },
    { "10x14", DMPAPER_10X14 },
    { "11x17", DMPAPER_11X17 },
    { "Note", DMPAPER_NOTE },
    { "Env_9", DMPAPER_ENV_9 },
    { "Env_10", DMPAPER_ENV_10 },
    { "Env_11", DMPAPER_ENV_11 },
    { "Env_12", DMPAPER_ENV_12 },
    { "Env_14", DMPAPER_ENV_14 },
    { "Env_DL", DMPAPER_ENV_DL },
    { "Env_C5", DMPAPER_ENV_C6 },
    { "Env_C65", DMPAPER_ENV_C65 },
    { "Env_B4", DMPAPER_ENV_B4 },
    { "Env_B5", DMPAPER_ENV_B5 },
    { "Env_B6", DMPAPER_ENV_B6 },
    { "Env_Italy", DMPAPER_ENV_ITALY },
    { "Env_Monarch", DMPAPER_ENV_MONARCH },
    { "Env_Personal", DMPAPER_ENV_PERSONAL },
    { "Fanfold_US", DMPAPER_FANFOLD_US },
    { "Fanfold_Std_German", DMPAPER_FANFOLD_STD_GERMAN },
    { "Fanfold_Lgl_German", DMPAPER_FANFOLD_LGL_GERMAN },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModePrintQuality[] = {
    { "High", (ULONG_PTR)DMRES_HIGH },
    { "Medium", (ULONG_PTR)DMRES_MEDIUM },
    { "Low", (ULONG_PTR)DMRES_LOW },
    { "Draft", (ULONG_PTR)DMRES_DRAFT },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeColor[] = {
    { "Color", DMCOLOR_COLOR },
    { "Monochrome", DMCOLOR_MONOCHROME },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeDuplex[] = {
    { "Simplex", DMDUP_SIMPLEX },
    { "Horizontal", DMDUP_HORIZONTAL },
    { "Vertical", DMDUP_VERTICAL },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeTTOption[] = {
    { "Bitmap", DMTT_BITMAP },
    { "DownLoad", DMTT_DOWNLOAD },
    { "SubDev", DMTT_SUBDEV },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeCollate[] = {
    { "True", DMCOLLATE_TRUE },
    { "False", DMCOLLATE_FALSE },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeICMMethod[] = {
    { "None", DMICMMETHOD_NONE },
    { "System", DMICMMETHOD_SYSTEM },
    { "Driver", DMICMMETHOD_DRIVER },
    { "Device", DMICMMETHOD_DEVICE },
    { NULL, 0 }
};


DEBUG_VALUES gadvDevModeICMIntent[] = {
    { "Saturate", DMICM_SATURATE },
    { "Contrast", DMICM_CONTRAST },
    { "ColorMetric", DMICM_COLORIMETRIC },
    { NULL, 0 }
};


DEBUG_VALUES gadvDevModeMediaType[] = {
    { "Standard", DMMEDIA_STANDARD },
    { "Glossy", DMMEDIA_GLOSSY },
    { "Transparency", DMMEDIA_TRANSPARENCY },
    { NULL, 0 }
};


DEBUG_VALUES gadvDevModeDitherType[] = {
    { "None", DMDITHER_NONE },
    { "Coarse", DMDITHER_COARSE },
    { "Fine", DMDITHER_FINE },
    { "LineArt", DMDITHER_LINEART },
    { "GrayScale", DMDITHER_GRAYSCALE },
    { NULL, 0 }
};

DEBUG_VALUES gadvDevModeOrient[] = {
    { "Portrait", DMORIENT_PORTRAIT },
    { "Landscape", DMORIENT_LANDSCAPE },
    { NULL, 0 }
};

BOOL
TDebugExt::
bDumpDevMode(
    PVOID pDevMode_,
    ULONG_PTR dwAddr
    )
{
    PDEVMODE pDevMode = (PDEVMODE)pDevMode_;

    ULONG_PTR dwTotalSize = pDevMode->dmSize + pDevMode->dmDriverExtra;

    Print( "DevMode*\n" );

    Print( "       dmDeviceName %ws\n", pDevMode->dmDeviceName );
    Print( "      dmSpecVersion %x\n", pDevMode->dmSpecVersion );
    Print( "    dmDriverVersion %x\n", pDevMode->dmDriverVersion );

    Print( "====         dmSize %x <%d>   TotalSize %x <%d>\n",
           pDevMode->dmSize,
           pDevMode->dmSize,
           dwTotalSize, dwTotalSize );

    Print( "      dmDriverExtra %x <%d>\n",
           pDevMode->dmDriverExtra,
           pDevMode->dmDriverExtra );

    Print( "           dmFields " );
    vDumpFlags( pDevMode->dmFields, gadfDevModeFields );

    Print( "      dmOrientation " );
    vDumpValue( pDevMode->dmOrientation, gadvDevModeOrient );

    Print( "        dmPaperSize " );
    vDumpValue( pDevMode->dmPaperSize, gadvDevModePapers );

    Print( "      dmPaperLength %x\n", pDevMode->dmPaperLength );
    Print( "       dmPaperWidth %x\n", pDevMode->dmPaperWidth );
    Print( "            dmScale %x\n", pDevMode->dmScale );
    Print( "           dmCopies %x\n", pDevMode->dmCopies );
    Print( "    dmDefaultSource " );
    vDumpValue( pDevMode->dmDefaultSource, gadvDevModeDefaultSource );

    Print( "     dmPrintQuality " );
    vDumpValue( pDevMode->dmPrintQuality, gadvDevModePrintQuality );

    Print( "            dmColor " );
    vDumpValue( pDevMode->dmColor, gadvDevModeColor );

    Print( "           dmDuplex " );
    vDumpValue( pDevMode->dmDuplex, gadvDevModeDuplex );

    Print( "      dmYResolution %x\n", pDevMode->dmYResolution );

    Print( "         dmTTOption " );
    vDumpValue( pDevMode->dmTTOption, gadvDevModeTTOption );

    Print( "          dmCollate " );
    vDumpValue( pDevMode->dmCollate, gadvDevModeCollate );

    Print( "====     dmFormName %ws\n", pDevMode->dmFormName );
    Print( "        dmLogPixels %x\n", pDevMode->dmLogPixels );
    Print( "       dmBitsPerPel %x\n", pDevMode->dmBitsPerPel );
    Print( "        dmPelsWidth %x\n", pDevMode->dmPelsWidth );
    Print( "       dmPelsHeight %x\n", pDevMode->dmPelsHeight );

    Print( "     dmDisplayFlags %x\n", pDevMode->dmDisplayFlags );
    Print( " dmDisplayFrequency %x\n", pDevMode->dmDisplayFrequency );

    Print( "====    dmICMMethod " );
    vDumpValue( pDevMode->dmICMMethod, gadvDevModeICMMethod );

    Print( "        dmICMIntent " );
    vDumpValue( pDevMode->dmICMIntent, gadvDevModeICMIntent );

    Print( "        dmMediaType " );
    vDumpValue( pDevMode->dmMediaType, gadvDevModeMediaType );

    Print( "       dmDitherType " );
    vDumpValue( pDevMode->dmDitherType, gadvDevModeDitherType );

    Print( "====     Private at %x\n", dwAddr+pDevMode->dmSize );

    return TRUE;
}


BOOL
TDebugExt::
bDumpDevModeA(
    PVOID pDevModeA_,
    ULONG_PTR dwAddr
    )
{
    PDEVMODEA pDevMode = (PDEVMODEA)pDevModeA_;

    ULONG_PTR dwTotalSize = pDevMode->dmSize + pDevMode->dmDriverExtra;

    Print( "DevModeA*\n" );

    Print( "       dmDeviceName %hs\n", pDevMode->dmDeviceName );
    Print( "      dmSpecVersion %x\n", pDevMode->dmSpecVersion );
    Print( "    dmDriverVersion %x\n", pDevMode->dmDriverVersion );

    Print( "====         dmSize %x <%d>   TotalSize %x <%d>\n",
           pDevMode->dmSize,
           pDevMode->dmSize,
           dwTotalSize, dwTotalSize );

    Print( "      dmDriverExtra %x <%d>\n",
           pDevMode->dmDriverExtra,
           pDevMode->dmDriverExtra );

    Print( "           dmFields " );
    vDumpFlags( pDevMode->dmFields, gadfDevModeFields );

    Print( "      dmOrientation " );
    vDumpValue( pDevMode->dmOrientation, gadvDevModeOrient );

    Print( "        dmPaperSize " );
    vDumpValue( pDevMode->dmPaperSize, gadvDevModePapers );

    Print( "      dmPaperLength %x\n", pDevMode->dmPaperLength );
    Print( "       dmPaperWidth %x\n", pDevMode->dmPaperWidth );
    Print( "            dmScale %x\n", pDevMode->dmScale );
    Print( "           dmCopies %x\n", pDevMode->dmCopies );
    Print( "    dmDefaultSource " );
    vDumpValue( pDevMode->dmDefaultSource, gadvDevModeDefaultSource );

    Print( "     dmPrintQuality " );
    vDumpValue( pDevMode->dmPrintQuality, gadvDevModePrintQuality );

    Print( "            dmColor " );
    vDumpValue( pDevMode->dmColor, gadvDevModeColor );

    Print( "           dmDuplex " );
    vDumpValue( pDevMode->dmDuplex, gadvDevModeDuplex );

    Print( "      dmYResolution %x\n", pDevMode->dmYResolution );

    Print( "         dmTTOption " );
    vDumpValue( pDevMode->dmTTOption, gadvDevModeTTOption );

    Print( "          dmCollate " );
    vDumpValue( pDevMode->dmCollate, gadvDevModeCollate );

    Print( "====     dmFormName %hs\n", pDevMode->dmFormName );
    Print( "        dmLogPixels %x\n", pDevMode->dmLogPixels );
    Print( "       dmBitsPerPel %x\n", pDevMode->dmBitsPerPel );
    Print( "        dmPelsWidth %x\n", pDevMode->dmPelsWidth );
    Print( "       dmPelsHeight %x\n", pDevMode->dmPelsHeight );

    Print( "     dmDisplayFlags %x\n", pDevMode->dmDisplayFlags );
    Print( " dmDisplayFrequency %x\n", pDevMode->dmDisplayFrequency );

    Print( "====    dmICMMethod " );
    vDumpValue( pDevMode->dmICMMethod, gadvDevModeICMMethod );

    Print( "        dmICMIntent " );
    vDumpValue( pDevMode->dmICMIntent, gadvDevModeICMIntent );

    Print( "        dmMediaType " );
    vDumpValue( pDevMode->dmMediaType, gadvDevModeMediaType );

    Print( "       dmDitherType " );
    vDumpValue( pDevMode->dmDitherType, gadvDevModeDitherType );

    Print( "====     Private at %x\n", dwAddr+pDevMode->dmSize );

    return TRUE;
}


#if 0
BOOL
TDebugExt::
bDumpIniPrinter(
    PVOID pIniPrinter_,
    ULONG_PTR dwAddr
    )
{
    PIniPrinter pIniPrinter = (PIniPrinter)pIniPrinter_;

    static DEBUG_FLAGS adfSpl[] = {
        { "UpdateWinIniDevices", SPL_UPDATE_WININI_DEVICES },
        { NULL, 0  }
    };

    if( !( pIniPrinter->signature == ID_SIGNATURE )){
        return FALSE;
    }

    Print( "IniPrinter*\n" );

    return TRUE;
}

#endif



/********************************************************************

    Extension entrypoints.

********************************************************************/

DEBUG_EXT_ENTRY( ds, INISPOOLER, bDumpIniSpooler, "&localspl!pLocalIniSpooler", FALSE )

DEBUG_EXT_ENTRY( ddev, DEVMODE, bDumpDevMode, NULL, FALSE )
DEBUG_EXT_ENTRY( ddeva, DEVMODEA, bDumpDevModeA, NULL, FALSE )

DEBUG_EXT_ENTRY( dlcs,
                 MCritSec,
                 bDumpCritSec,
                 "&localspl!hcsSpoolerSection",
                 TRUE )

DEBUG_EXT_HEAD(lastlog)
{
    DEBUG_EXT_SETUP_VARS();

    ULONG_PTR dwAddress = 0;

    //
    // Read in localspl's gDbgPointers.
    //
    DBG_POINTERS DbgPointers;
    ULONG_PTR ppDbgPointers = 0;
    ULONG_PTR pDbgPointers = 0;

    ppDbgPointers = EvalExpression( "&localspl!gpDbgPointers" );

    if( !ppDbgPointers ){
        Print( "<Unable to resolve localspl!gpDbgPointers>\n" );
        return;
    }

    move( pDbgPointers, ppDbgPointers );

    if( !pDbgPointers ){
        Print( "<Unable to read valid localspl!gpDbgPointers>\n" );
        return;
    }

    move( DbgPointers, pDbgPointers );

    if( !DbgPointers.pbtTraceLog ){
        Print( "<Unable to read valid DbgPointers.pbtTraceLog>\n" );
        return;
    }

    vDumpTraceWithFlags( lpArgumentString, (ULONG_PTR)DbgPointers.pbtTraceLog );
}

/********************************************************************

    Signature matching dump function.

********************************************************************/


#define DEBUG_EXT_TRY_SETUP()                                          \
    PBYTE var = (PBYTE)EvalExpression( lpArgumentString );             \
    PVOID pvData;                                                      \
    BOOL bDone;                                                        \
    Print( "%x ", var )

#define DEBUG_EXT_TRY( struct, func )                                  \
    pvData = LocalAlloc( LPTR, sizeof( struct ));                      \
    move2( pvData, var, sizeof( struct ));                             \
    bDone = TDebugExt::func( pvData, (ULONG_PTR)var );                  \
    LocalFree( pvData );                                               \
                                                                       \
    if( bDone ){                                                       \
        return;                                                        \
    }

#define DEBUG_EXT_TRY_DONE()                                           \
    Print( "<No Match %x>\n", var )


DEBUG_EXT_HEAD( d )
{
    DEBUG_EXT_SETUP_VARS();
    DEBUG_EXT_TRY_SETUP();

    DEBUG_EXT_TRY( INISPOOLER, bDumpIniSpooler );
    DEBUG_EXT_TRY( INIPRINTER, bDumpIniPrinter );
    DEBUG_EXT_TRY( INIPRINTPROC, bDumpIniPrintProc );
    DEBUG_EXT_TRY( INIVERSION, bDumpIniVersion );
    DEBUG_EXT_TRY( INIDRIVER, bDumpIniDriver );
    DEBUG_EXT_TRY( INIENVIRONMENT, bDumpIniEnvironment );
    DEBUG_EXT_TRY( INIMONITOR, bDumpIniMonitor );
    DEBUG_EXT_TRY( INIJOB, bDumpIniJob );
    DEBUG_EXT_TRY( INIPORT, bDumpIniPort );
    DEBUG_EXT_TRY( SPOOL, bDumpSpool );

    DEBUG_EXT_TRY_DONE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\exts\spllib.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    spllib.cxx

Abstract:

    Extensions for spllib

Author:

    Albert Ting (AlbertT)  20-Feb-1995

Revision History:

--*/

#include "precomp.hxx"

/********************************************************************

    Helper routines

********************************************************************/

#if !DBG
#error "Only the debug version should be built."
#endif

BOOL
TDebugExt::
bDumpThreadM(
    PVOID pThreadM_,
    ULONG_PTR dwAddr
    )
{
    TThreadM* pThreadM = (TThreadM*)pThreadM_;

    static DEBUG_FLAGS DebugFlags[] = {
        { "DESTROYED_REQ"   , 1 },
        { "DESTROYED"       , 2 },
        { "PRIVATE_CRIT_SEC", 4 }
    };

    if( !pThreadM->bSigCheck( )){
        return FALSE;
    }

    Print( "TThreadM*\n" );

    Print( "   uMaxThreads <%d>\n", pThreadM->_uMaxThreads );
    Print( "     uIdleLife <%d>\n", pThreadM->_uIdleLife );
    Print( "uActiveThreads <%d>\n", pThreadM->_uActiveThreads );
    Print( "  iIdleThreads <%d>\n", pThreadM->_iIdleThreads );

    Print( "      hTrigger %x\n", pThreadM->_hTrigger );
    Print( "         State %x %x\n", (ULONG_PTR)pThreadM->_State, &pThreadM->_State );
    Print( "      pCritSec %x\n", pThreadM->_pCritSec );

    return TRUE;
}

BOOL
TDebugExt::
bDumpCritSec(
    PVOID pCritSec_,
    ULONG_PTR dwAddr
    )
{
    MCritSec* pCritSec = (MCritSec*)pCritSec_;

    if( !pCritSec->bSigCheck( )){
        return FALSE;
    }

    Print( "MCritSec*\n" );

    Print( "   CriticalSection @ %x\n", dwAddr + OFFSETOF( MCritSec, _CritSec ));
    Print( "     dwThreadOwner %x\n", pCritSec->_dwThreadOwner );
    Print( "      dwEntryCount <%d>  ", pCritSec->_dwEntryCount );

    if( pCritSec->_dwEntryCount ){
        Print( "Owned\n" );
    } else {
        Print( "Not Owned\n" );
    }
    Print( "dwTickCountEntered <%d>\n", pCritSec->_dwTickCountEntered );

    Print( "==== Statistics\n" );

    Print( "  dwTickCountBlockedTotal <%d>\n", pCritSec->_dwTickCountBlockedTotal );
    Print( "   dwTickCountInsideTotal <%d>\n", pCritSec->_dwTickCountInsideTotal );
    Print( "        dwEntryCountTotal <%d>\n", pCritSec->_dwEntryCountTotal );

    Print( "     CritSecHardLock_base " ); vDumpPDL( pCritSec->CritSecHardLock_pdlBase( ));

    ULONG_PTR dwAddrBt = dwAddr + OFFSETOF( MCritSec, _BackTrace )
                     - OFFSETOF_BASE( TBackTraceMem, VBackTrace );

    Print( "               VBackTrace @ %x      !splx.ddt -x     %x\n",
           dwAddrBt, dwAddrBt );

    return TRUE;
}

BOOL
TDebugExt::
bDumpBackTrace(
    ULONG_PTR dwAddr,
    COUNT Count,
    PDWORD pdwSkip,
    DWORD DebugTrace,
    DWORD DebugLevel,
    DWORD dwThreadId,
    ULONG_PTR dwMem
    )
{
#ifdef TRACE_ENABLED

    BYTE abyBackTraceBuffer[sizeof(TBackTraceMem)];   
    TBackTraceMem* pBackTraceMem = (TBackTraceMem*)abyBackTraceBuffer;

    move2( pBackTraceMem, dwAddr, sizeof( TBackTraceMem ));

    if( !pBackTraceMem->bSigCheck( )){
        return FALSE;
    }

    INT iLineStart = pBackTraceMem->_uNextFree;
    INT iLine;

    if( iLineStart < 0 ){
        iLineStart = TBackTraceMem::kMaxCall - 1;
    }

    for( iLine = iLineStart - 1; Count; --iLine, --Count ){

        if( CheckControlCRtn()){
            return TRUE;
        }

        //
        // Handle wrap around case.
        //
        if( iLine < 0 ){
            iLine = TBackTraceMem::kMaxCall - 1;
        }

        if( iLine == iLineStart ||
            !TDebugExt::bDumpDebugTrace( (ULONG_PTR)&pBackTraceMem->_pLines[iLine],
                                        1,
                                        pdwSkip,
                                        DebugTrace,
                                        DebugLevel,
                                        dwThreadId,
                                        dwMem )){
            //
            // Wrapped around yet didn't find enough.
            //
            Print( "Out of lines\n" );
            return TRUE;
        }
    }
    return TRUE;

#else   // #ifdef TRACE_ENABLED

    return FALSE;

#endif  // #ifdef TRACE_ENABLED
}


BOOL
TDebugExt::
bDumpDebugTrace(
    ULONG_PTR dwLineAddr,
    COUNT Count,
    PDWORD pdwSkip,
    DWORD DebugTrace,
    DWORD DebugLevel,
    DWORD dwThreadId,
    ULONG_PTR dwMem
    )
{
    //
    // TLine is a simple class, and can be treated as a "C" struct.
    //
    COUNTB cbTotalLine = sizeof( TBackTraceMem::TLine ) * Count;
    TBackTraceMem::TLine* pLineBase =
        (TBackTraceMem::TLine*) LocalAlloc( LPTR, cbTotalLine );
    BOOL bValidLines = TRUE;

    TBackTraceMem::TLine* pLine;

    if( !pLineBase ){

        Print( "Cannot alloc 0x%x bytes.\n", cbTotalLine );
        return FALSE;
    }

    move2( pLineBase, dwLineAddr, cbTotalLine );

    //
    // Dump out the lines.
    //
    for( pLine = pLineBase ; Count; Count--, pLine++ ){

        if( CheckControlCRtn()){
            goto Done;
        }

        //
        // If we are out of lines, quit.
        //
        if( !pLine->_TickCount ){
            bValidLines = FALSE;
            goto Done;
        }

        //
        // If we are processing DBGMSG, skip levels we don't want.
        //
        if( DebugTrace & DEBUG_TRACE_DBGMSG ){
            if( !( DebugLevel & ( pLine->_Info2 >> DBG_BREAK_SHIFT ))){
                continue;
            }
        }

        //
        // Skip thread Ids we don't want.
        //
        if( dwThreadId && dwThreadId != pLine->_ThreadId ){
            continue;
        }

        //
        // Skip mem we don't want.
        // This is used when we are dumping the memory functions in
        // spllib (gpbtAlloc and gpbtFree).
        //
        if( dwMem &&
            ( dwMem < pLine->_Info1 ||
              dwMem > pLine->_Info1 + pLine->_Info2 )){

            continue;
        }

        if( *pdwSkip ){
            --*pdwSkip;
            continue;
        }

        if( DebugTrace & DEBUG_TRACE_DBGMSG ){

            CHAR szMsg[kStringDefaultMax];

            szMsg[0] = 0;

            if( pLine->_Info1 ){

                move( szMsg, pLine->_Info1 );

                //
                // PageHeap forces all allocated blocks to be placed
                // at the end of a page, with the next page marked
                // as unreadable.  If we don't get a string here,
                // then read up chunk.
                //
                if( !szMsg[0] ){

                    move2( szMsg,
                           pLine->_Info1,
                           kStringChunk -
                               ( (DWORD)pLine->_Info1 & ( kStringChunk - 1 )));
                }

                Print( "* %s", szMsg );

                UINT cchLen = lstrlenA( szMsg );

                if( !cchLen || szMsg[cchLen-1] != '\n' ){

                    Print( "\n" );
                }
            } else {
                Print( "\n" );
            }
        }

        if( DebugTrace & DEBUG_TRACE_HEX ){
            Print( "%08x %08x %08x bt=%x threadid=%x tc=%x [%x]\n",
                   pLine->_Info1,
                   pLine->_Info2,
                   pLine->_Info3,
                   pLine->_hTrace,
                   pLine->_ThreadId,
                   pLine->_TickCount,
                   pLine->_Info1 + pLine->_Info2 );
        }

        if( DebugTrace & DEBUG_TRACE_BT ){
            vDumpTrace( (ULONG_PTR)pLine->_hTrace );
        }
    }

Done:

    LocalFree( pLineBase );
    return bValidLines;
}

BOOL
TDebugExt::
bDumpDbgPointers(
    PVOID pDbgPointers_,
    ULONG_PTR dwAddress
    )
{
    PDBG_POINTERS pDbgPointers = (PDBG_POINTERS)pDbgPointers_;

    Print( "DBG_POINTERS*\n" );

    Print( "hMemHeap     !heap -a           %x\n", pDbgPointers->hMemHeap );
    Print( "hDbgMemHeap  !heap -a           %x\n", pDbgPointers->hDbgMemHeap );
    Print( "pbtAlloc     !splx.ddt -x       %x\n", pDbgPointers->pbtAlloc );
    Print( "pbtFree      !splx.ddt -x       %x\n", pDbgPointers->pbtFree );
    Print( "pbtErrLog    !splx.ddt          %x\n", pDbgPointers->pbtErrLog );
    Print( "pbtTraceLog  !splx.ddt          %x\n", pDbgPointers->pbtTraceLog );

    return TRUE;
}

/********************************************************************

    Extension entrypoints.

********************************************************************/

DEBUG_EXT_ENTRY( dthdm, TThreadM, bDumpThreadM, NULL, FALSE )
DEBUG_EXT_ENTRY( dcs, MCritSec, bDumpCritSec, NULL, FALSE )

DEBUG_EXT_ENTRY( ddp, DBG_POINTERS, bDumpDbgPointers, "&gpDbgPointers", FALSE )

DEBUG_EXT_HEAD(dbt)
{
    DEBUG_EXT_SETUP_VARS();
    TDebugExt::vDumpTrace( TDebugExt::dwEval( lpArgumentString, FALSE ));
}

DEBUG_EXT_HEAD(ddt)
{
    DEBUG_EXT_SETUP_VARS();

    vDumpTraceWithFlags( lpArgumentString, 0 );
}

DEBUG_EXT_HEAD(dmem)
{
    DEBUG_EXT_SETUP_VARS();
    TDebugExt::vDumpMem( lpArgumentString );
}


/********************************************************************

    Helper funcs.

********************************************************************/

VOID
vDumpTraceWithFlags(
    LPSTR lpArgumentString,
    ULONG_PTR dwAddress
    )
{
    COUNT Count = 10;
    BOOL bRaw = FALSE;
    DWORD DebugTrace = DEBUG_TRACE_NONE;
    DWORD DebugLevel = (DWORD)-1;
    DWORD dwThreadId = 0;
    DWORD dwSkip = 0;
    ULONG_PTR dwMem = 0;

    for( ; *lpArgumentString; ++lpArgumentString ){

        while( *lpArgumentString == ' ' ){
            ++lpArgumentString;
        }

        if (*lpArgumentString != '-') {
            break;
        }

        ++lpArgumentString;

        switch( *lpArgumentString++ ){
        case 'T':
        case 't':

            dwThreadId = (DWORD)TDebugExt::dwEvalParam( lpArgumentString );
            break;

        case 'L':
        case 'l':

            DebugLevel = (DWORD)TDebugExt::dwEvalParam( lpArgumentString );
            break;

        case 'C':
        case 'c':

            Count = (COUNT)TDebugExt::dwEvalParam( lpArgumentString );
            break;

        case 'M':
        case 'm':

            dwMem = TDebugExt::dwEvalParam( lpArgumentString );
            break;

        case 'R':
        case 'r':

            bRaw = TRUE;
            break;

        case 'b':
        case 'B':

            DebugTrace |= DEBUG_TRACE_BT;
            break;

        case 'X':
        case 'x':

            DebugTrace |= DEBUG_TRACE_HEX;
            break;

        case 'd':
        case 'D':

            DebugTrace |= DEBUG_TRACE_DBGMSG;
            break;

        case 's':
        case 'S':

            dwSkip = (DWORD)TDebugExt::dwEvalParam( lpArgumentString );
            break;

        default:
            Print( "Unknown option %c.\n", lpArgumentString[-1] );
            return;
        }
    }

    if( !dwAddress ){
        dwAddress = TDebugExt::dwEval( lpArgumentString );
    }

    if( bRaw ){
        TDebugExt::bDumpDebugTrace( dwAddress,
                                    Count,
                                    &dwSkip,
                                    DebugTrace,
                                    DebugLevel,
                                    dwThreadId,
                                    dwMem );
        return;
    }

    //
    // If nothing is set, default to dbg msgs.
    //
    if( !DebugTrace ){
        DebugTrace |= DEBUG_TRACE_DBGMSG;
    }

    if( !TDebugExt::bDumpBackTrace( dwAddress,
                                    Count,
                                    &dwSkip,
                                    DebugTrace,
                                    DebugLevel,
                                    dwThreadId,
                                    dwMem )){
        Print( "Unknown Signature\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\exts\stktrace.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    stktrace.cxx

Abstract:

    KM Stack trace index.

Author:

    Albert Ting (AlbertT)  26-Mar-99

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#ifdef STKTRACE_HACK

DEBUG_EXT_HEAD( dbti )
{
    DEBUG_EXT_SETUP_VARS();

    UINT i;

    UINT Index = TDebugExt::dwEval( lpArgumentString, FALSE );
    UINT_PTR p = EvalExpression("&ntoskrnl!RtlpStackTraceDataBase");

    UINT_PTR stdAddr;
    move(stdAddr, p);

    Print("RtlpStackTraceDataBase: %x\n", stdAddr);

    STACK_TRACE_DATABASE std;
    move(std, stdAddr);

    UINT_PTR cBuckets = std.NumberOfBuckets;
    PSTACK_TRACE_DATABASE pstdLarge;

    pstdLarge = (PSTACK_TRACE_DATABASE)LocalAlloc(LPTR,
                                                  sizeof(STACK_TRACE_DATABASE) +
                                                  sizeof(PVOID) * cBuckets);

    Print("Checking %x buckets\n", cBuckets);

    if (!pstdLarge)
    {
        Print("Failed to alloc %x buckets\n", cBuckets);
    }
    else
    {
        move2(pstdLarge, stdAddr, sizeof(STACK_TRACE_DATABASE) + sizeof(PVOID) * cBuckets);

        for (i=0; i < cBuckets; ++i)
        {
            //
            // Walk each hash chain.
            //
            RTL_STACK_TRACE_ENTRY ste;

            for (p = (UINT_PTR)pstdLarge->Buckets[i]; p; p = (UINT_PTR)ste.HashChain)
            {
                if (CheckControlCRtn())
                    return;

                move(ste, p);

                if (ste.Index == Index)
                {
                    break;
                }
            }

            if (p)
            {
                Print("Index %x found: ste = %x, BT = %x\n",
                      Index,
                      p,
                      p + OFFSETOF(RTL_STACK_TRACE_ENTRY, BackTrace));
                break;
            }
        }
    }
}

#else

DEBUG_EXT_HEAD( dbti )
{
    DEBUG_EXT_SETUP_VARS();

    Print("Not enabled.\n");
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inc\clusrout.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusrout.h

Abstract:

    Cluster code support: entrypoints exposed by the router.

Author:

    Albert Ting (AlbertT) 1-Oct-96

Revision History:

--*/

#ifndef _CLUSROUT_H
#define _CLUSROUT_H

BOOL
ClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phSpooler,
    LPCTSTR pszName,
    LPCTSTR pszAddress
    );

BOOL
ClusterSplClose(
    HANDLE hSpooler
    );


BOOL
ClusterSplIsAlive(
    HANDLE hSpooler
    );

#endif // ifdef _CLUSROUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inc\change.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    change.h

Abstract:

    Holds change definitions for spooler system change notify.

Author:

    Albert Ting (AlbertT) 05-Mar-94

Environment:

    User Mode -Win32

Revision History:

--*/
#ifndef _CHANGE_H
#define _CHANGE_H

//
// Timeout value for WaitForPrinterChange
//
#define PRINTER_CHANGE_TIMEOUT_VALUE 600000

//
// Flags used for FFPCN
//
#define PRINTER_NOTIFY_OPTION_SIM_FFPCN         0x10000
#define PRINTER_NOTIFY_OPTION_SIM_FFPCN_ACTIVE  0x20000
#define PRINTER_NOTIFY_OPTION_SIM_FFPCN_CLOSE   0x40000
#define PRINTER_NOTIFY_OPTION_SIM_WPC           0x80000

//#define PRINTER_NOTIFY_INFO_DISCARDED         0x1
#define PRINTER_NOTIFY_INFO_DISCARDNOTED        0x010000
#define PRINTER_NOTIFY_INFO_COLORSET            0x020000
#define PRINTER_NOTIFY_INFO_COLOR               0x040000
#define PRINTER_NOTIFY_INFO_COLORMISMATCH       0x080000

//#define PRINTER_NOTIFY_OPTIONS_REFRESH        0x1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\exts\wdbgexts.h ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    wdbgexts.h

Abstract:

    This file contains the necessary prototypes and data types for a user
    to write a debugger extension DLL.  This header file is also included
    by the NT debuggers (WINDBG & KD).

    This header file must be included after "windows.h" and "dbghelp.h".

    Please see the NT DDK documentation for specific information about
    how to write your own debugger extension DLL.

Environment:

    Win32 only.

Revision History:

--*/

#ifndef _WDBGEXTS_
#define _WDBGEXTS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(WDBGAPI)
#define WDBGAPI __stdcall
#endif

#if !defined(WDBGAPIV)
#define WDBGAPIV __cdecl
#endif

#ifndef _WINDEF_
typedef CONST void *LPCVOID;
#endif

#ifndef _ULONGLONG_
typedef unsigned __int64 ULONGLONG;
typedef ULONGLONG *PULONGLONG;
#endif


typedef
VOID
(WDBGAPIV*PWINDBG_OUTPUT_ROUTINE)(
    PCSTR lpFormat,
    ...
    );

typedef
ULONG_PTR
(WDBGAPI*PWINDBG_GET_EXPRESSION)(
    PCSTR lpExpression
    );

typedef
ULONG
(WDBGAPI*PWINDBG_GET_EXPRESSION32)(
    PCSTR lpExpression
    );

typedef
ULONG64
(WDBGAPI*PWINDBG_GET_EXPRESSION64)(
    PCSTR lpExpression
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL)(
    PVOID      offset,
    PCHAR     pchBuffer,
    ULONG_PTR *pDisplacement
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL32)(
    ULONG      offset,
    PCHAR     pchBuffer,
    PULONG     pDisplacement
    );

typedef
VOID
(WDBGAPI*PWINDBG_GET_SYMBOL64)(
    ULONG64    offset,
    PCHAR     pchBuffer,
    PULONG64   pDisplacement
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM)(
    ULONG_PTR *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM32)(
    ULONG     *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_DISASM64)(
    ULONG64   *lpOffset,
    PCSTR      lpBuffer,
    ULONG      fShowEffectiveAddress
    );

typedef
ULONG
(WDBGAPI*PWINDBG_CHECK_CONTROL_C)(
    VOID
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE)(
    ULONG_PTR  offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE32)(
    ULONG      offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_READ_PROCESS_MEMORY_ROUTINE64)(
    ULONG64    offset,
    PVOID      lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesRead
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE)(
    ULONG_PTR  offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32)(
    ULONG      offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64)(
    ULONG64    offset,
    LPCVOID    lpBuffer,
    ULONG      cb,
    PULONG     lpcbBytesWritten
    );

typedef
ULONG
(WDBGAPI*PWINDBG_GET_THREAD_CONTEXT_ROUTINE)(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    );

typedef
ULONG
(WDBGAPI*PWINDBG_SET_THREAD_CONTEXT_ROUTINE)(
    ULONG       Processor,
    PCONTEXT    lpContext,
    ULONG       cbSizeOfContext
    );

typedef
ULONG
(WDBGAPI*PWINDBG_IOCTL_ROUTINE)(
    USHORT   IoctlType,
    PVOID    lpvData,
    ULONG    cbSize
    );

typedef
ULONG
(WDBGAPI*PWINDBG_OLDKD_READ_PHYSICAL_MEMORY)(
    ULONGLONG        address,
    PVOID            buffer,
    ULONG            count,
    PULONG           bytesread
    );

typedef
ULONG
(WDBGAPI*PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY)(
    ULONGLONG        address,
    PVOID            buffer,
    ULONG            length,
    PULONG           byteswritten
    );


typedef struct _EXTSTACKTRACE {
    ULONG       FramePointer;
    ULONG       ProgramCounter;
    ULONG       ReturnAddress;
    ULONG       Args[4];
} EXTSTACKTRACE, *PEXTSTACKTRACE;

typedef struct _EXTSTACKTRACE32 {
    ULONG       FramePointer;
    ULONG       ProgramCounter;
    ULONG       ReturnAddress;
    ULONG       Args[4];
} EXTSTACKTRACE32, *PEXTSTACKTRACE32;

typedef struct _EXTSTACKTRACE64 {
    ULONG64     FramePointer;
    ULONG64     ProgramCounter;
    ULONG64     ReturnAddress;
    ULONG64     Args[4];
} EXTSTACKTRACE64, *PEXTSTACKTRACE64;


typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE)(
    ULONG             FramePointer,
    ULONG             StackPointer,
    ULONG             ProgramCounter,
    PEXTSTACKTRACE    StackFrames,
    ULONG             Frames
    );

typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE32)(
    ULONG             FramePointer,
    ULONG             StackPointer,
    ULONG             ProgramCounter,
    PEXTSTACKTRACE32  StackFrames,
    ULONG             Frames
    );

typedef
ULONG
(*PWINDBG_STACKTRACE_ROUTINE64)(
    ULONG64           FramePointer,
    ULONG64           StackPointer,
    ULONG64           ProgramCounter,
    PEXTSTACKTRACE64  StackFrames,
    ULONG             Frames
    );

typedef struct _WINDBG_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION                 lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL                     lpGetSymbolRoutine;
    PWINDBG_DISASM                         lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE    lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE   lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE             lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS, *PWINDBG_EXTENSION_APIS;

typedef struct _WINDBG_EXTENSION_APIS32 {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION32               lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL32                   lpGetSymbolRoutine;
    PWINDBG_DISASM32                       lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE32  lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE32           lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS32, *PWINDBG_EXTENSION_APIS32;

typedef struct _WINDBG_EXTENSION_APIS64 {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION64               lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL64                   lpGetSymbolRoutine;
    PWINDBG_DISASM64                       lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE64  lpReadProcessMemoryRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64 lpWriteProcessMemoryRoutine;
    PWINDBG_GET_THREAD_CONTEXT_ROUTINE     lpGetThreadContextRoutine;
    PWINDBG_SET_THREAD_CONTEXT_ROUTINE     lpSetThreadContextRoutine;
    PWINDBG_IOCTL_ROUTINE                  lpIoctlRoutine;
    PWINDBG_STACKTRACE_ROUTINE64           lpStackTraceRoutine;
} WINDBG_EXTENSION_APIS64, *PWINDBG_EXTENSION_APIS64;


typedef struct _WINDBG_OLD_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION                 lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL                     lpGetSymbolRoutine;
    PWINDBG_DISASM                         lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
} WINDBG_OLD_EXTENSION_APIS, *PWINDBG_OLD_EXTENSION_APIS;

typedef struct _WINDBG_OLDKD_EXTENSION_APIS {
    ULONG                                  nSize;
    PWINDBG_OUTPUT_ROUTINE                 lpOutputRoutine;
    PWINDBG_GET_EXPRESSION32               lpGetExpressionRoutine;
    PWINDBG_GET_SYMBOL32                   lpGetSymbolRoutine;
    PWINDBG_DISASM32                       lpDisasmRoutine;
    PWINDBG_CHECK_CONTROL_C                lpCheckControlCRoutine;
    PWINDBG_READ_PROCESS_MEMORY_ROUTINE32  lpReadVirtualMemRoutine;
    PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 lpWriteVirtualMemRoutine;
    PWINDBG_OLDKD_READ_PHYSICAL_MEMORY     lpReadPhysicalMemRoutine;
    PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY    lpWritePhysicalMemRoutine;
} WINDBG_OLDKD_EXTENSION_APIS, *PWINDBG_OLDKD_EXTENSION_APIS;

typedef
VOID
(WDBGAPI*PWINDBG_OLD_EXTENSION_ROUTINE)(
    ULONG                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  lpExtensionApis,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG                   dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE32)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG                   dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_ROUTINE64)(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    ULONG64                 dwCurrentPc,
    ULONG                   dwProcessor,
    PCSTR                   lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_OLDKD_EXTENSION_ROUTINE)(
    ULONG                        dwCurrentPc,
    PWINDBG_OLDKD_EXTENSION_APIS lpExtensionApis,
    PCSTR                        lpArgumentString
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT)(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT                 MajorVersion,
    USHORT                 MinorVersion
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT32)(
    PWINDBG_EXTENSION_APIS32 lpExtensionApis,
    USHORT                   MajorVersion,
    USHORT                   MinorVersion
    );

typedef
VOID
(WDBGAPI*PWINDBG_EXTENSION_DLL_INIT64)(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT                   MajorVersion,
    USHORT                   MinorVersion
    );

typedef
ULONG
(WDBGAPI*PWINDBG_CHECK_VERSION)(
    VOID
    );

#define EXT_API_VERSION_NUMBER   5
#define EXT_API_VERSION_NUMBER32 5
#define EXT_API_VERSION_NUMBER64 6

typedef struct EXT_API_VERSION {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} EXT_API_VERSION, *LPEXT_API_VERSION;

typedef
LPEXT_API_VERSION
(WDBGAPI*PWINDBG_EXTENSION_API_VERSION)(
    VOID
    );

#define IG_KD_CONTEXT                  1
#define IG_READ_CONTROL_SPACE          2
#define IG_WRITE_CONTROL_SPACE         3
#define IG_READ_IO_SPACE               4
#define IG_WRITE_IO_SPACE              5
#define IG_READ_PHYSICAL               6
#define IG_WRITE_PHYSICAL              7
#define IG_READ_IO_SPACE_EX            8
#define IG_WRITE_IO_SPACE_EX           9
#define IG_KSTACK_HELP                10   // obsolete
#define IG_SET_THREAD                 11
#define IG_READ_MSR                   12
#define IG_WRITE_MSR                  13
#define IG_GET_DEBUGGER_DATA          14
#define IG_GET_KERNEL_VERSION         15
#define IG_RELOAD_SYMBOLS             16
#define IG_GET_SET_SYMPATH            17
#define IG_GET_EXCEPTION_RECORD       18
#define IG_IS_PTR64                   19
#define IG_GET_BUS_DATA               20
#define IG_SET_BUS_DATA               21
#define IG_DUMP_SYMBOL_INFO           22
#define IG_LOWMEM_CHECK               23
#define IG_SEARCH_MEMORY              24
#define IG_GET_CURRENT_THREAD         25
#define IG_GET_CURRENT_PROCESS        26
#define IG_GET_TYPE_SIZE              27
#define IG_GET_CURRENT_PROCESS_HANDLE 28
#define IG_GET_INPUT_LINE             29
#define IG_GET_EXPRESSION_EX          30
#define IG_TRANSLATE_VIRTUAL_TO_PHYSICAL 31

#define IG_GET_TEB_ADDRESS           128
#define IG_GET_PEB_ADDRESS           129

typedef struct _PROCESSORINFO {
    USHORT      Processor;                // current processor
    USHORT      NumberProcessors;         // total number of processors
} PROCESSORINFO, *PPROCESSORINFO;

typedef struct _READCONTROLSPACE {
    USHORT      Processor;
    ULONG       Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE, *PREADCONTROLSPACE;

typedef struct _READCONTROLSPACE32 {
    USHORT      Processor;
    ULONG       Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE32, *PREADCONTROLSPACE32;

typedef struct _READCONTROLSPACE64 {
    USHORT      Processor;
    ULONG64     Address;
    ULONG       BufLen;
    UCHAR       Buf[1];
} READCONTROLSPACE64, *PREADCONTROLSPACE64;

typedef struct _IOSPACE {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE, *PIOSPACE;

typedef struct _IOSPACE32 {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE32, *PIOSPACE32;

typedef struct _IOSPACE64 {
    ULONG64     Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
} IOSPACE64, *PIOSPACE64;

typedef struct _IOSPACE_EX {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX, *PIOSPACE_EX;

typedef struct _IOSPACE_EX32 {
    ULONG       Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX32, *PIOSPACE_EX32;

typedef struct _IOSPACE_EX64 {
    ULONG64     Address;
    ULONG       Length;                   // 1, 2, or 4 bytes
    ULONG       Data;
    ULONG       InterfaceType;
    ULONG       BusNumber;
    ULONG       AddressSpace;
} IOSPACE_EX64, *PIOSPACE_EX64;

typedef struct _GETSETBUSDATA {
    ULONG       BusDataType;
    ULONG       BusNumber;
    ULONG       SlotNumber;
    PVOID       Buffer;
    ULONG       Offset;
    ULONG       Length;
} BUSDATA, *PBUSDATA;

typedef struct _SEARCHMEMORY {
    ULONG64 SearchAddress;
    ULONG64 SearchLength;
    ULONG64 FoundAddress;
    ULONG   PatternLength;
    PVOID   Pattern;
} SEARCHMEMORY, *PSEARCHMEMORY;

typedef struct _PHYSICAL {
    ULONGLONG              Address;
    ULONG                  BufLen;
    UCHAR                  Buf[1];
} PHYSICAL, *PPHYSICAL;

typedef struct _READ_WRITE_MSR {
    ULONG       Msr;
    LONGLONG    Value;
} READ_WRITE_MSR, *PREAD_WRITE_MSR;

typedef struct _GET_SET_SYMPATH {
    PCSTR       Args;       // args to !reload command
    PSTR        Result;     // returns new path
    int         Length;     // Length of result buffer
} GET_SET_SYMPATH, *PGET_SET_SYMPATH;

typedef struct _GET_TEB_ADDRESS {
    ULONGLONG   Address;
} GET_TEB_ADDRESS, *PGET_TEB_ADDRESS;

typedef struct _GET_PEB_ADDRESS {
    ULONG64     CurrentThread;
    ULONGLONG   Address;
} GET_PEB_ADDRESS, *PGET_PEB_ADDRESS;

typedef struct _GET_CURRENT_THREAD_ADDRESS {
    ULONG       Processor;
    ULONG64     Address;
} GET_CURRENT_THREAD_ADDRESS, *PGET_CURRENT_THREAD_ADDRESS;

typedef struct _GET_CURRENT_PROCESS_ADDRESS {
    ULONG       Processor;
    ULONG64     CurrentThread;
    ULONG64     Address;
} GET_CURRENT_PROCESS_ADDRESS, *PGET_CURRENT_PROCESS_ADDRESS;

typedef struct _GET_INPUT_LINE {
    PCSTR       Prompt;
    PSTR        Buffer;
    ULONG       BufferSize;
    ULONG       InputSize;
} GET_INPUT_LINE, *PGET_INPUT_LINE;

typedef struct _GET_EXPRESSION_EX {
    PCSTR       Expression;
    PCSTR       Remainder;
    ULONG64     Value;
} GET_EXPRESSION_EX, *PGET_EXPRESSION_EX;

typedef struct _TRANSLATE_VIRTUAL_TO_PHYSICAL {
    ULONG64     Virtual;
    ULONG64     Physical;
} TRANSLATE_VIRTUAL_TO_PHYSICAL, *PTRANSLATE_VIRTUAL_TO_PHYSICAL;

//
// If DBGKD_VERS_FLAG_DATA is set in Flags, info should be retrieved from
// the KDDEBUGGER_DATA block rather than from the DBGKD_GET_VERSION
// packet.  The data will remain in the version packet for a while to
// reduce compatibility problems.
//

#define DBGKD_VERS_FLAG_MP      0x0001      // kernel is MP built
#define DBGKD_VERS_FLAG_DATA    0x0002      // DebuggerDataList is valid
#define DBGKD_VERS_FLAG_PTR64   0x0004      // native pointers are 64 bits
#define DBGKD_VERS_FLAG_NOMM    0x0008      // No MM - don't decode PTEs
#define DBGKD_VERS_FLAG_HSS     0x0010      // hardware stepping support
#define DBGKD_VERS_FLAG_USER_DEBUG 0x0020   // User debugging support

#define KDBG_TAG    'GBDK'


// **********************************************************************
// DO NOT CHANGE THESE 32 BIT STRUCTURES!
// ONLY MAKE CHAGES TO THE 64 BIT VERSION BELOW!!
// **********************************************************************

//
// The following structure has changed in more than pointer size.
//
// This is the version packet for pre-NT5 Beta 2 systems.
// For now, it is also still used on x86
//
typedef struct _DBGKD_GET_VERSION32 {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  ProtocolVersion;
    USHORT  Flags;
    ULONG   KernBase;
    ULONG   PsLoadedModuleList;

    USHORT  MachineType;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // Address of the kernel callout routine.
    //

    ULONG   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG   KeUserCallbackDispatcher;   // address in ntdll

    //
    // DbgBreakPointWithStatus is a function which takes a ULONG argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG   BreakpointWithStatus;       // address of breakpoint

    //
    // Components may register a debug data block for use by
    // debugger extensions.  This is the address of the list head.
    //

    ULONG   DebuggerDataList;

} DBGKD_GET_VERSION32, *PDBGKD_GET_VERSION32;


//
// This is the debugger data packet for pre NT5 Beta 2 systems.
// For now, it is still used on x86
//

typedef struct _DBGKD_DEBUG_DATA_HEADER32 {

    LIST_ENTRY32 List;
    ULONG           OwnerTag;
    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER32, *PDBGKD_DEBUG_DATA_HEADER32;

typedef struct _KDDEBUGGER_DATA32 {

    DBGKD_DEBUG_DATA_HEADER32 Header;
    ULONG   KernBase;
    ULONG   BreakpointWithStatus;       // address of breakpoint
    ULONG   SavedContext;
    USHORT  ThCallbackStack;            // offset in thread data
    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer
    USHORT  PaeEnabled:1;
    ULONG   KiCallUserMode;             // kernel routine
    ULONG   KeUserCallbackDispatcher;   // address in ntdll

    ULONG   PsLoadedModuleList;
    ULONG   PsActiveProcessHead;
    ULONG   PspCidTable;

    ULONG   ExpSystemResourcesList;
    ULONG   ExpPagedPoolDescriptor;
    ULONG   ExpNumberOfPagedPools;

    ULONG   KeTimeIncrement;
    ULONG   KeBugCheckCallbackListHead;
    ULONG   KiBugcheckData;

    ULONG   IopErrorLogListHead;

    ULONG   ObpRootDirectoryObject;
    ULONG   ObpTypeObjectType;

    ULONG   MmSystemCacheStart;
    ULONG   MmSystemCacheEnd;
    ULONG   MmSystemCacheWs;

    ULONG   MmPfnDatabase;
    ULONG   MmSystemPtesStart;
    ULONG   MmSystemPtesEnd;
    ULONG   MmSubsectionBase;
    ULONG   MmNumberOfPagingFiles;

    ULONG   MmLowestPhysicalPage;
    ULONG   MmHighestPhysicalPage;
    ULONG   MmNumberOfPhysicalPages;

    ULONG   MmMaximumNonPagedPoolInBytes;
    ULONG   MmNonPagedSystemStart;
    ULONG   MmNonPagedPoolStart;
    ULONG   MmNonPagedPoolEnd;

    ULONG   MmPagedPoolStart;
    ULONG   MmPagedPoolEnd;
    ULONG   MmPagedPoolInformation;
    ULONG   MmPageSize;

    ULONG   MmSizeOfPagedPoolInBytes;

    ULONG   MmTotalCommitLimit;
    ULONG   MmTotalCommittedPages;
    ULONG   MmSharedCommit;
    ULONG   MmDriverCommit;
    ULONG   MmProcessCommit;
    ULONG   MmPagedPoolCommit;
    ULONG   MmExtendedCommit;

    ULONG   MmZeroedPageListHead;
    ULONG   MmFreePageListHead;
    ULONG   MmStandbyPageListHead;
    ULONG   MmModifiedPageListHead;
    ULONG   MmModifiedNoWritePageListHead;
    ULONG   MmAvailablePages;
    ULONG   MmResidentAvailablePages;

    ULONG   PoolTrackTable;
    ULONG   NonPagedPoolDescriptor;

    ULONG   MmHighestUserAddress;
    ULONG   MmSystemRangeStart;
    ULONG   MmUserProbeAddress;

    ULONG   KdPrintCircularBuffer;
    ULONG   KdPrintCircularBufferEnd;
    ULONG   KdPrintWritePointer;
    ULONG   KdPrintRolloverCount;

    ULONG   MmLoadedUserImageList;

} KDDEBUGGER_DATA32, *PKDDEBUGGER_DATA32;

// **********************************************************************
//
// DO NOT CHANGE KDDEBUGGER_DATA32!!
// ONLY MAKE CHANGES TO KDDEBUGGER_DATA64!!!
//
// **********************************************************************


typedef struct _DBGKD_GET_VERSION64 {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  ProtocolVersion;
    USHORT  Flags;
    USHORT  MachineType;

    USHORT  Unused[3];

    ULONG64 KernBase;
    ULONG64 PsLoadedModuleList;

    //
    // Components may register a debug data block for use by
    // debugger extensions.  This is the address of the list head.
    //
    // There will always be an entry for the debugger.
    //

    ULONG64 DebuggerDataList;

} DBGKD_GET_VERSION64, *PDBGKD_GET_VERSION64;


//
// This structure is used by the debugger for all targets
// It is the same size as DBGKD_DATA_HEADER on all systems
//
typedef struct _DBGKD_DEBUG_DATA_HEADER64 {

    //
    // Link to other blocks
    //

    LIST_ENTRY64 List;

    //
    // This is a unique tag to identify the owner of the block.
    // If your component only uses one pool tag, use it for this, too.
    //

    ULONG           OwnerTag;

    //
    // This must be initialized to the size of the data block,
    // including this structure.
    //

    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER64, *PDBGKD_DEBUG_DATA_HEADER64;


//
// This structure is the same size on all systems.  The only field
// which must be translated by the debugger is Header.List.
//

//
// DO NOT ADD OR REMOVE FIELDS FROM THE MIDDLE OF THIS STRUCTURE!!!
//
// If you remove a field, replace it with an "unused" placeholder.
// Do not reuse fields until there has been enough time for old debuggers
// and extensions to age out.
//
typedef struct _KDDEBUGGER_DATA64 {

    DBGKD_DEBUG_DATA_HEADER64 Header;

    //
    // Base address of kernel image
    //

    ULONG64   KernBase;

    //
    // DbgBreakPointWithStatus is a function which takes an argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG64   BreakpointWithStatus;       // address of breakpoint

    //
    // Address of the saved context record during a bugcheck
    //
    // N.B. This is an automatic in KeBugcheckEx's frame, and
    // is only valid after a bugcheck.
    //

    ULONG64   SavedContext;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // pad to a quad boundary
    //
    USHORT  PaeEnabled:1;

    //
    // Address of the kernel callout routine.
    //

    ULONG64   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG64   KeUserCallbackDispatcher;   // address in ntdll


    //
    // Addresses of various kernel data structures and lists
    // that are of interest to the kernel debugger.
    //

    ULONG64   PsLoadedModuleList;
    ULONG64   PsActiveProcessHead;
    ULONG64   PspCidTable;

    ULONG64   ExpSystemResourcesList;
    ULONG64   ExpPagedPoolDescriptor;
    ULONG64   ExpNumberOfPagedPools;

    ULONG64   KeTimeIncrement;
    ULONG64   KeBugCheckCallbackListHead;
    ULONG64   KiBugcheckData;

    ULONG64   IopErrorLogListHead;

    ULONG64   ObpRootDirectoryObject;
    ULONG64   ObpTypeObjectType;

    ULONG64   MmSystemCacheStart;
    ULONG64   MmSystemCacheEnd;
    ULONG64   MmSystemCacheWs;

    ULONG64   MmPfnDatabase;
    ULONG64   MmSystemPtesStart;
    ULONG64   MmSystemPtesEnd;
    ULONG64   MmSubsectionBase;
    ULONG64   MmNumberOfPagingFiles;

    ULONG64   MmLowestPhysicalPage;
    ULONG64   MmHighestPhysicalPage;
    ULONG64   MmNumberOfPhysicalPages;

    ULONG64   MmMaximumNonPagedPoolInBytes;
    ULONG64   MmNonPagedSystemStart;
    ULONG64   MmNonPagedPoolStart;
    ULONG64   MmNonPagedPoolEnd;

    ULONG64   MmPagedPoolStart;
    ULONG64   MmPagedPoolEnd;
    ULONG64   MmPagedPoolInformation;
    ULONG64   MmPageSize;

    ULONG64   MmSizeOfPagedPoolInBytes;

    ULONG64   MmTotalCommitLimit;
    ULONG64   MmTotalCommittedPages;
    ULONG64   MmSharedCommit;
    ULONG64   MmDriverCommit;
    ULONG64   MmProcessCommit;
    ULONG64   MmPagedPoolCommit;
    ULONG64   MmExtendedCommit;

    ULONG64   MmZeroedPageListHead;
    ULONG64   MmFreePageListHead;
    ULONG64   MmStandbyPageListHead;
    ULONG64   MmModifiedPageListHead;
    ULONG64   MmModifiedNoWritePageListHead;
    ULONG64   MmAvailablePages;
    ULONG64   MmResidentAvailablePages;

    ULONG64   PoolTrackTable;
    ULONG64   NonPagedPoolDescriptor;

    ULONG64   MmHighestUserAddress;
    ULONG64   MmSystemRangeStart;
    ULONG64   MmUserProbeAddress;

    ULONG64   KdPrintCircularBuffer;
    ULONG64   KdPrintCircularBufferEnd;
    ULONG64   KdPrintWritePointer;
    ULONG64   KdPrintRolloverCount;

    ULONG64   MmLoadedUserImageList;

    // NT 5.1 Addition

    ULONG64   NtBuildLab;
    ULONG64   KiNormalSystemCall;

    // NT 5.0 QFE addition

    ULONG64   KiProcessorBlock;
    ULONG64   MmUnloadedDrivers;
    ULONG64   MmLastUnloadedDriver;
    ULONG64   MmTriageActionTaken;
    ULONG64   MmSpecialPoolTag;
    ULONG64   KernelVerifier;
    ULONG64   MmVerifierData;
    ULONG64   MmAllocatedNonPagedPool;
    ULONG64   MmPeakCommitment;
    ULONG64   MmTotalCommitLimitMaximum;
    ULONG64   CmNtCSDVersion;

    // NT 5.1 Addition

    ULONG64   MmPhysicalMemoryBlock;

} KDDEBUGGER_DATA64, *PKDDEBUGGER_DATA64;



/************************************

   Type Dump Ioctl

*************************************/


//
// Fields are not indented if this is set
//
#define DBG_DUMP_NO_INDENT                0x00000001
//
// Offsets are not printed if this is set
//
#define DBG_DUMP_NO_OFFSET                0x00000002
//
// Verbose output
//
#define DBG_DUMP_VERBOSE                  0x00000004
//
// Callback is done for each of fields
//
#define DBG_DUMP_CALL_FOR_EACH            0x00000008
//
// A list of type is dumped, listLink should have info about next element pointer
//
#define DBG_DUMP_LIST                     0x00000020
//
// Nothing is printed if this is set (only callbacks and data copies done)
//
#define DBG_DUMP_NO_PRINT                 0x00000040
//
// Ioctl returns the size as usual, but will not do field prints/callbacks if this is set
//
#define DBG_DUMP_GET_SIZE_ONLY            0x00000080
//
// Specifies how much deep into structs we can go
//
#define DBG_DUMP_RECUR_LEVEL(l)           ((l & 0xf) << 8)
//
// No newlines are printed after each field
//
#define DBG_DUMP_COMPACT_OUT              0x00002000
//
// An array of type is dumped, number of elements can be specified in listLink->size
//
#define DBG_DUMP_ARRAY                    0x00008000
//
// The specified addr value is actually the address of field listLink->fName
//
#define DBG_DUMP_ADDRESS_OF_FIELD         0x00010000

//
// The specified addr value is actually the adress at the end of type
//
#define DBG_DUMP_ADDRESS_AT_END           0x00020000

//
// This could be used to copy only the primitive types like ULONG, PVOID etc.
//    - will not work with structures/unions
//
#define DBG_DUMP_COPY_TYPE_DATA           0x00040000
//
// Flag to allow read directly from physical memory
//
#define DBG_DUMP_READ_PHYSICAL            0x00080000
//
// This causes a function type to be dumped in format function(arg1, arg2, ...)
//
#define DBG_DUMP_FUNCTION_FORMAT          0x00100000

//
// Obsolete defs
//
#define DBG_RETURN_TYPE                   0
#define DBG_RETURN_SUBTYPES               0
#define DBG_RETURN_TYPE_VALUES            0

//
// Dump and callback optons for fields - Options used in FIELD_INFO.fOptions
//

//
// Callback is done before printing the field if this is set
//
#define DBG_DUMP_FIELD_CALL_BEFORE_PRINT  0x00000001
//
// No callback is done
//
#define DBG_DUMP_FIELD_NO_CALLBACK_REQ    0x00000002
//
// Subfields of the fields are processesed
//
#define DBG_DUMP_FIELD_RECUR_ON_THIS      0x00000004
//
// fName must match completely for the field to be dumped instead just a prefix
//  match by default
//
#define DBG_DUMP_FIELD_FULL_NAME          0x00000008
//
// This causes array elements of an array field to be printed
//
#define DBG_DUMP_FIELD_ARRAY              0x00000010
//
// The data of the field is copied into fieldCallBack
//
#define DBG_DUMP_FIELD_COPY_FIELD_DATA    0x00000020
//
// In callback or when Ioctl returns, the FIELD_INFO.address has the address of field.
//  If no address is supplied for the type, it contains total offset of the field.
//
#define DBG_DUMP_FIELD_RETURN_ADDRESS     0x00001000
//
// Return the offset and size in bits instead of bytes is case of Bitfield
//
#define DBG_DUMP_FIELD_SIZE_IN_BITS       0x00002000
//
// Nothing is printed  for field if this is set (only callbacks and data copies done)
//
#define DBG_DUMP_FIELD_NO_PRINT           0x00004000
//
// If the field is a pointer, it is dumped as a string, ANSI, WCHAR, MULTI or GUID
// depending on following options
//
#define DBG_DUMP_FIELD_DEFAULT_STRING     0x00010000
#define DBG_DUMP_FIELD_WCHAR_STRING       0x00020000
#define DBG_DUMP_FIELD_MULTI_STRING       0x00040000
#define DBG_DUMP_FIELD_GUID_STRING        0x00080000


//
// Error status returned on TYPE DUMP Ioctl failure
//
#define MEMORY_READ_ERROR            0x01
#define SYMBOL_TYPE_INDEX_NOT_FOUND  0x02
#define SYMBOL_TYPE_INFO_NOT_FOUND   0x03
#define FIELDS_DID_NOT_MATCH         0x04
#define NULL_SYM_DUMP_PARAM          0x05
#define NULL_FIELD_NAME              0x06
#define INCORRECT_VERSION_INFO       0x07
#define EXIT_ON_CONTROLC             0x08
#define CANNOT_ALLOCATE_MEMORY       0x09
#define INSUFFICIENT_SPACE_TO_COPY   0x0a


//////////////////////////////////////////////////////////////////////////*/

typedef
ULONG
(WDBGAPI*PSYM_DUMP_FIELD_CALLBACK)(
    struct _FIELD_INFO *pField,
    PVOID UserContext
    );

typedef struct _FIELD_INFO {
   PUCHAR  fName;          // Name of the field
   PUCHAR  printName;      // Name to be printed at dump
   ULONG   size;           // Size of the field
   ULONG   fOptions;       // Dump Options for the field
   ULONG64 address;        // address of the field
   PVOID   fieldCallBack;  // Return info or callBack routine for the field
} FIELD_INFO, *PFIELD_INFO;

typedef struct _SYM_DUMP_PARAM {
   ULONG               size;          // size of this struct
   PUCHAR              sName;         // type name
   ULONG               Options;       // Dump options
   ULONG64             addr;          // Address to take data for type
   PFIELD_INFO         listLink;      // fName here would be used to do list dump
   PVOID               Context;       // Usercontext passed to CallbackRoutine
   PSYM_DUMP_FIELD_CALLBACK CallbackRoutine;
                                      // Routine called back
   ULONG               nFields;       // # elements in Fields
   PFIELD_INFO         Fields;        // Used to return information about field
} SYM_DUMP_PARAM, *PSYM_DUMP_PARAM;

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif


#ifndef NOEXTAPI

#if   defined(KDEXT_64BIT)
#define WINDBG_EXTENSION_APIS WINDBG_EXTENSION_APIS64
#define PWINDBG_EXTENSION_APIS PWINDBG_EXTENSION_APIS64
#define DECLARE_API(s) DECLARE_API64(s)
#elif defined(KDEXT_32BIT)
#define WINDBG_EXTENSION_APIS WINDBG_EXTENSION_APIS32
#define PWINDBG_EXTENSION_APIS PWINDBG_EXTENSION_APIS32
#define DECLARE_API(s) DECLARE_API32(s)
#else
#define DECLARE_API(s)                             \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG                  dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )
#endif

#define DECLARE_API32(s)                           \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG                  dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )

#define DECLARE_API64(s)                           \
    CPPMOD VOID                                    \
    s(                                             \
        HANDLE                 hCurrentProcess,    \
        HANDLE                 hCurrentThread,     \
        ULONG64                dwCurrentPc,        \
        ULONG                  dwProcessor,        \
        PCSTR                  args                \
     )


extern WINDBG_EXTENSION_APIS   ExtensionApis;


#define dprintf          (ExtensionApis.lpOutputRoutine)
#define GetExpression    (ExtensionApis.lpGetExpressionRoutine)
#define CheckControlC    (ExtensionApis.lpCheckControlCRoutine)
#define GetContext       (ExtensionApis.lpGetThreadContextRoutine)
#define SetContext       (ExtensionApis.lpSetThreadContextRoutine)
#define Ioctl            (ExtensionApis.lpIoctlRoutine)
#define Disasm           (ExtensionApis.lpDisasmRoutine)
#define GetSymbol        (ExtensionApis.lpGetSymbolRoutine)
#define ReadMemory       (ExtensionApis.lpReadProcessMemoryRoutine)
#define WriteMemory      (ExtensionApis.lpWriteProcessMemoryRoutine)
#define StackTrace       (ExtensionApis.lpStackTraceRoutine)


#define GetKdContext(ppi) \
    Ioctl( IG_KD_CONTEXT, (PVOID)ppi, sizeof(*ppi) )


//
// BOOL
// GetDebuggerData(
//     ULONG Tag,
//     PVOID Buf,
//     ULONG Size
//     )
//

#define GetDebuggerData(TAG, BUF, SIZE)                             \
      ( (((PDBGKD_DEBUG_DATA_HEADER64)(BUF))->OwnerTag = (TAG)),      \
        (((PDBGKD_DEBUG_DATA_HEADER64)(BUF))->Size = (SIZE)),         \
        Ioctl( IG_GET_DEBUGGER_DATA, (PVOID)(BUF), (SIZE) ) )

// Check if LocalAlloc is prototyped
//#ifdef _WINBASE_

__inline VOID
ReadPhysical(
    ULONG64             address,
    PVOID               buf,
    ULONG               size,
    PULONG              sizer
    )
{
    PPHYSICAL phy;
    *sizer = 0;
    phy = (PPHYSICAL)LocalAlloc(LPTR,  sizeof(*phy) + size );
    if (phy) {
        ZeroMemory( phy->Buf, size );
        phy->Address = address;
        phy->BufLen = size;
        Ioctl( IG_READ_PHYSICAL, (PVOID)phy, sizeof(*phy) + size );
        *sizer = phy->BufLen;
        CopyMemory( buf, phy->Buf, *sizer );
        LocalFree( phy );
    }
}

__inline VOID
WritePhysical(
    ULONG64             address,
    PVOID               buf,
    ULONG               size,
    PULONG              sizew
    )
{
    PPHYSICAL phy;
    *sizew = 0;
    phy = (PPHYSICAL)LocalAlloc(LPTR, sizeof(*phy) + size );
    if (phy) {
        ZeroMemory( phy->Buf, size );
        phy->Address = address;
        phy->BufLen = size;
        CopyMemory( phy->Buf, buf, size );
        Ioctl( IG_WRITE_PHYSICAL, (PVOID)phy, sizeof(*phy) + size );
        *sizew = phy->BufLen;
        LocalFree( phy );
    }
}

__inline VOID
ReadMsr(
    ULONG       MsrReg,
    ULONGLONG   *MsrValue
    )
{
    READ_WRITE_MSR msr;

    msr.Msr = MsrReg;
    Ioctl( IG_READ_MSR, (PVOID)&msr, sizeof(msr) );

    *MsrValue = msr.Value;
}

__inline VOID
WriteMsr(
    ULONG       MsrReg,
    ULONGLONG   MsrValue
    )
{
    READ_WRITE_MSR msr;

    msr.Msr = MsrReg;
    msr.Value = MsrValue;
    Ioctl( IG_WRITE_MSR, (PVOID)&msr, sizeof(msr) );
}

__inline VOID
SetThreadForOperation(
    ULONG_PTR * Thread
    )
{
    Ioctl(IG_SET_THREAD, (PVOID)Thread, sizeof(PULONG));
}

__inline VOID
SetThreadForOperation32(
    ULONG Thread
    )
{
    Ioctl(IG_SET_THREAD, (PVOID)LongToPtr(Thread), sizeof(PULONG));
}

__inline VOID
SetThreadForOperation64(
    PULONG64 Thread
    )
{
    Ioctl(IG_SET_THREAD, (PVOID)Thread, sizeof(PULONG));
}


__inline VOID
ReadControlSpace(
    USHORT  processor,
    ULONG   address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE prc;
    prc = (PREADCONTROLSPACE)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        CopyMemory( buf, prc->Buf, size );
        LocalFree( prc );
    }
}

__inline VOID
ReadControlSpace32(
    USHORT  processor,
    ULONG   address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE32 prc;
    prc = (PREADCONTROLSPACE32)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        CopyMemory( buf, prc->Buf, size );
        LocalFree( prc );
    }
}

#define ReadTypedControlSpace32( _Proc, _Addr, _Buf )  \
     ReadControlSpace64( (USHORT)(_Proc), (ULONG)(_Addr), (PVOID)&(_Buf), (ULONG)sizeof(_Buf) )

__inline VOID
ReadControlSpace64(
    USHORT  processor,
    ULONG64 address,
    PVOID   buf,
    ULONG   size
    )
{
    PREADCONTROLSPACE64 prc;
    prc = (PREADCONTROLSPACE64)LocalAlloc(LPTR, sizeof(*prc) + size );
    if (prc) {
        ZeroMemory( prc->Buf, size );
        prc->Processor = processor;
        prc->Address = address;
        prc->BufLen = size;
        Ioctl( IG_READ_CONTROL_SPACE, (PVOID)prc, sizeof(*prc) + size );
        CopyMemory( buf, prc->Buf, size );
        LocalFree( prc );
    }
}

#define ReadTypedControlSpace64( _Proc, _Addr, _Buf )  \
     ReadControlSpace64( (USHORT)(_Proc), (ULONG64)(_Addr), (PVOID)&(_Buf), (ULONG)sizeof(_Buf) )

// #endif //  _WINBASE_

__inline VOID
ReadIoSpace(
    ULONG   address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE is;
    is.Address = address;
    is.Length = *size;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    memcpy(data, &is.Data, is.Length);
    *size = is.Length;
}

__inline VOID
ReadIoSpace32(
    ULONG   address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE32 is;
    is.Address = address;
    is.Length = *size;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    memcpy(data, &is.Data, is.Length);
    *size = is.Length;
}

__inline VOID
ReadIoSpace64(
    ULONG64 address,
    PULONG  data,
    PULONG  size
    )
{
    IOSPACE64 is;
    is.Address = address;
    is.Length = *size;
    Ioctl( IG_READ_IO_SPACE, (PVOID)&is, sizeof(is) );
    memcpy(data, &is.Data, is.Length);
    *size = is.Length;
}

__inline VOID
WriteIoSpace(
    ULONG   address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpace32(
    ULONG   address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE32 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpace64(
    ULONG64 address,
    ULONG   data,
    PULONG  size
    )
{
    IOSPACE64 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    Ioctl( IG_WRITE_IO_SPACE, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx(
    ULONG   address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx32(
    ULONG   address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX32 is;
    is.Address = address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
ReadIoSpaceEx64(
    ULONG64 address,
    PULONG  data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX64 is;
    is.Address = address;
    is.Length = *size;
    is.Data = 0;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_READ_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *data = is.Data;
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx(
    ULONG   address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX is;
    is.Address = (ULONG)address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx32(
    ULONG   address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX32 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
WriteIoSpaceEx64(
    ULONG64 address,
    ULONG   data,
    PULONG  size,
    ULONG   interfacetype,
    ULONG   busnumber,
    ULONG   addressspace
    )
{
    IOSPACE_EX64 is;
    is.Address = address;
    is.Length = *size;
    is.Data = data;
    is.InterfaceType = interfacetype;
    is.BusNumber = busnumber;
    is.AddressSpace = addressspace;
    Ioctl( IG_WRITE_IO_SPACE_EX, (PVOID)&is, sizeof(is) );
    *size = is.Length;
}

__inline VOID
ReloadSymbols(
    IN PSTR Arg OPTIONAL
    )
/*++

Routine Description:

    Calls the debugger to reload symbols.

Arguments:

    Args - Supplies the tail of a !reload command string.

        !reload [flags] [module[=address]]
        flags:   /n  do not load from usermode list
                 /u  unload symbols, no reload
                 /v  verbose

        A value of NULL is equivalent to an empty string

Return Value:

    None

--*/
{
    Ioctl(IG_RELOAD_SYMBOLS, (PVOID)Arg, Arg?(strlen(Arg)+1):0);
}

__inline VOID
GetSetSympath(
    IN PSTR Arg,
    OUT PSTR Result OPTIONAL,
    IN int Length
    )
/*++

Routine Description:

    Calls the debugger to set or retrieve symbol search path.

Arguments:

    Arg - Supplies new search path.  If Arg is NULL or string is empty,
            the search path is not changed and the current setting is
            returned in Result.  When the symbol search path is changed,
            a call to ReloadSymbols is made implicitly.

    Result - OPTIONAL Returns the symbol search path setting.

    Length - Supplies the size of the buffer supplied by Result.

Return Value:

    None

--*/
{
    GET_SET_SYMPATH gss;
    gss.Args = Arg;
    gss.Result = Result;
    gss.Length = Length;
    Ioctl(IG_GET_SET_SYMPATH, (PVOID)&gss, sizeof(gss));
}

#if   defined(KDEXT_64BIT)

__inline
ULONG
IsPtr64(
    void
    )
{
    static ULONG flag = -1;
    ULONG dw;
    if (flag == -1) {
        if (Ioctl(IG_IS_PTR64, &dw, sizeof(dw))) {
            flag = ((dw != 0) ? 1 : 0);
        } else {
            flag = 0;
        }
    }
    return flag;
}

__inline
ULONG
ReadListEntry(
    ULONG64 Address,
    PLIST_ENTRY64 List
    )
{
    ULONG cb;
    if (IsPtr64()) {
        return (ReadMemory(Address, (PVOID)List, sizeof(*List), &cb) && cb == sizeof(*List));
    } else {
        LIST_ENTRY32 List32;
        ULONG Status;
        Status = ReadMemory(Address,
                            (PVOID)&List32,
                            sizeof(List32),
                            &cb);
        if (Status && cb == sizeof(List32)) {
            List->Flink = (ULONG64)(LONG64)(LONG)List32.Flink;
            List->Blink = (ULONG64)(LONG64)(LONG)List32.Blink;
            return 1;
        }
        return 0;
    }
}

__inline
ULONG
ReadPointer(
    ULONG64 Address,
    PULONG64 Pointer
    )
{
    ULONG cb;
    if (IsPtr64()) {
        return (ReadMemory(Address, (PVOID)Pointer, sizeof(*Pointer), &cb) && cb == sizeof(*Pointer));
    } else {
        ULONG Pointer32;
        ULONG Status;
        Status = ReadMemory(Address,
                            (PVOID)&Pointer32,
                            sizeof(Pointer32),
                            &cb);
        if (Status && cb == sizeof(Pointer32)) {
            *Pointer = (ULONG64)(LONG64)(LONG)Pointer32;
            return 1;
        }
        return 0;
    }
}

__inline
ULONG
WritePointer(
    ULONG64 Address,
    ULONG64 Pointer
    )
{
    ULONG cb;
    if (IsPtr64()) {
        return (WriteMemory(Address, &Pointer, sizeof(Pointer), &cb) && cb == sizeof(Pointer));
    } else {
        ULONG Pointer32 = (ULONG)Pointer;
        ULONG Status;
        Status = WriteMemory(Address,
                             &Pointer32,
                             sizeof(Pointer32),
                             &cb);
        return (Status && cb == sizeof(Pointer32)) ? 1 : 0;
    }
}

/**
   This does Ioctl call for type info and returns size of the type on success.

 **/
__inline
ULONG
GetTypeSize (
   IN LPCSTR    Type
   )
{
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), (PUCHAR)Type, DBG_DUMP_NO_PRINT | DBG_DUMP_GET_SIZE_ONLY, 0,
      NULL, NULL, NULL, 0, NULL
   };

   return Ioctl( IG_GET_TYPE_SIZE, &Sym, Sym.size );
}

/**
    GetFieldData

   Copies the value of the specified field into pOutValue assuming TypeAddress
   points to start of the type in debugee.

   If the Field is NULL and the size of Type is <= 8 Whole type value is read into
   pOutValue. This is to allow to read in primitive types suchas ULONG, PVOID etc.

   If address is zero this considers Type a global variable.

   It raises an exception if OutSize is less than size to be copied.

   Returns 0 on success, errorvalue (defined with SYM_DUMP_PARAM) otherwise.

 **/
__inline
ULONG
GetFieldData (
    IN  ULONG64 TypeAddress,
    IN  LPCSTR  Type,
    IN  LPCSTR  Field,
    IN  ULONG   OutSize,
    OUT PVOID   pOutValue
   )
{
   FIELD_INFO flds = {(PUCHAR)Field, NULL, 0, DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS, 0, pOutValue};
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), (PUCHAR)Type, DBG_DUMP_NO_PRINT, TypeAddress,
      NULL, NULL, NULL, 1, &flds
   };
   ULONG RetVal;

   if (!Field) {
       Sym.nFields =0; Sym.Options |= DBG_DUMP_COPY_TYPE_DATA;
       Sym.Context = pOutValue;
   }

   ZeroMemory(pOutValue, OutSize);
   RetVal = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

   if (OutSize < ((Field == NULL) ? 8 : flds.size)) {
       // Fail
       dprintf("Not enough space to read %s-%s\n", Type, Field);
       RaiseException(EXCEPTION_ACCESS_VIOLATION, 0, 0, NULL);
       return 0;
   }
   return RetVal;
}

//
// Typecast the buffer where value is to be read
//
#define GetFieldValue(Addr, Type, Field, OutValue)         \
     GetFieldData(Addr, Type, Field, sizeof(OutValue), (PVOID) &(OutValue))

//
// Used to read in value of a short (<= 8 bytes) fields
//
__inline
ULONG64
GetShortField (
    IN  ULONG64 TypeAddress,
    IN  LPCSTR  Name,
    IN  USHORT  StoreAddress
   )
{
    static ULONG64 SavedAddress;
    static PUCHAR  SavedName;
    static ULONG   ReadPhysical;
    FIELD_INFO flds = {(PUCHAR) Name, NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};
    SYM_DUMP_PARAM Sym = {
       sizeof (SYM_DUMP_PARAM), SavedName, DBG_DUMP_NO_PRINT | ((StoreAddress & 2) ? DBG_DUMP_READ_PHYSICAL : 0),
       SavedAddress, NULL, NULL, NULL, 1, &flds
    };
      

    if (StoreAddress) {
        Sym.sName = (PUCHAR) Name;
        Sym.nFields = 0;
        SavedName = (PUCHAR) Name;
        Sym.addr = SavedAddress = TypeAddress;
        ReadPhysical = (StoreAddress & 2);
        return SavedAddress ? Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size ) : MEMORY_READ_ERROR; // zero on success
    } else {
        Sym.Options |= ReadPhysical ? DBG_DUMP_READ_PHYSICAL : 0;
    }

    if (!Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size )) {
        return flds.address;
    }
    return 0;
}

//
// Stores the address and type name for future reads
//
#define InitTypeRead(Addr, Type)  GetShortField(Addr, #Type, 1)

//
// Stores the address and type name for future reads
//
#define InitTypeReadPhysical(Addr, Type)  GetShortField(Addr, #Type, 3)
//
// Returns the field's value as ULONG64 if size of field is <= sizeof (ULONG64)
//
#define ReadField(Field)          GetShortField(0, #Field, 0)

//
// Read in a pointer value
//
__inline
ULONG
ReadPtr(
    ULONG64 Addr,
    PULONG64 pPointer
    )
{
    return GetFieldData(Addr, "PVOID", NULL, sizeof(ULONG64), (PVOID) pPointer);
}

/*
 * ListType
 *
 *  Routine ListType gives a callback on each element in the list of Type.
 *
 *   Type  :  Name of the type to be listed
 *
 *   NextPointer : Name of field which gives address of next element in list
 *
 *   Context, CallbackRoutine :
 *            Context and the callback routine. The address field in PFIELD_INFO
 *            parameter of callback contains the address of next Type element in list.
 *
 *   Address, ListByFieldAddress :
 *      if ListByFieldAddress is 0, Adress is the address of first element of Type List.
 *
 *   Lists by LIST_ENTRY are also handled implicitly (by Ioctl). If the NextPointer
 *   is a pointer to LIST_ENTRY type, the type address is properly calculated by
 *   subtracting the offsets.
 *
 *      If ListByFieldAddress is 1, the Address is considered to be the address of field
 *   "NextPointer" of the first Type element and first element address is derived
 *   from it.
 *
 */

__inline
ULONG
ListType (
    IN LPCSTR  Type,
    IN ULONG64 Address,
    IN USHORT  ListByFieldAddress,
    IN LPCSTR  NextPointer,
    IN PVOID   Context,
    IN PSYM_DUMP_FIELD_CALLBACK CallbackRoutine
    )
{
    FIELD_INFO flds = {(PUCHAR)NextPointer, NULL, 0, 0, 0, NULL};
    SYM_DUMP_PARAM Sym = {
       sizeof (SYM_DUMP_PARAM), (PUCHAR) Type, DBG_DUMP_NO_PRINT | DBG_DUMP_LIST, Address,
       &flds, Context, CallbackRoutine, 0, NULL
    };

    if (ListByFieldAddress==1) {
        //
        // Address is the address of "NextPointer"
        //
        Sym.Options |= DBG_DUMP_ADDRESS_OF_FIELD;
    }

    return Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
}


/**

   Routine to get offset of a "Field" of "Type" on a debugee machine. This uses
   Ioctl call for type info.
   Returns 0 on success, Ioctl error value otherwise.

 **/

__inline
ULONG
GetFieldOffset (
   IN LPCSTR     Type,
   IN LPCSTR     Field,
   OUT PULONG   pOffset
   )
{
   FIELD_INFO flds = {
       (PUCHAR)Field,
       (PUCHAR)"",
       0,
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS,
       0,
       NULL};

   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM),
      (PUCHAR)Type,
      DBG_DUMP_NO_PRINT,
      0,
      NULL,
      NULL,
      NULL,
      1,
      &flds
   };

   ULONG Err;

   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   return Err;
}


#endif // defined(KDEXT_64BIT)

__inline VOID
 GetCurrentProcessHandle(
    PHANDLE hp
    )
{
    Ioctl(IG_GET_CURRENT_PROCESS_HANDLE, hp, sizeof(HANDLE));
}

__inline VOID
 GetTebAddress(
    PULONGLONG Address
    )
{
    GET_TEB_ADDRESS gpt;
    gpt.Address = 0;
    Ioctl(IG_GET_TEB_ADDRESS, (PVOID)&gpt, sizeof(gpt));
    *Address = gpt.Address;
}

__inline VOID
 GetPebAddress(
    ULONG64 CurrentThread,
    PULONGLONG Address
    )
{
    GET_PEB_ADDRESS gpt;
    gpt.CurrentThread = CurrentThread;
    gpt.Address = 0;
    Ioctl(IG_GET_PEB_ADDRESS, (PVOID)&gpt, sizeof(gpt));
    *Address = gpt.Address;
}

__inline VOID
 GetCurrentThreadAddr(
    DWORD    Processor,
    PULONG64  Address
    )
{
    GET_CURRENT_THREAD_ADDRESS ct;
    ct.Processor = Processor;
    Ioctl(IG_GET_CURRENT_THREAD, (PVOID)&ct, sizeof(ct));
    *Address = ct.Address;
}

__inline VOID
 GetCurrentProcessAddr(
    DWORD    Processor,
    ULONG64  CurrentThread,
    PULONG64 Address
    )
{
    GET_CURRENT_PROCESS_ADDRESS cp;
    cp.Processor = Processor;
    cp.CurrentThread = CurrentThread;
    Ioctl(IG_GET_CURRENT_PROCESS, (PVOID)&cp, sizeof(cp));
    *Address = cp.Address;
}

__inline VOID
SearchMemory(
    ULONG64  SearchAddress,
    ULONG64  SearchLength,
    ULONG    PatternLength,
    PVOID    Pattern,
    PULONG64 FoundAddress
    )
{
    SEARCHMEMORY sm;
    sm.SearchAddress = SearchAddress;
    sm.SearchLength  = SearchLength;
    sm.FoundAddress  = 0;
    sm.PatternLength = PatternLength;
    sm.Pattern       = Pattern;
    Ioctl(IG_SEARCH_MEMORY, (PVOID)&sm, sizeof(sm));
    *FoundAddress = sm.FoundAddress;
}

__inline ULONG
GetInputLine(
    PCSTR Prompt,
    PSTR Buffer,
    ULONG BufferSize
    )
{
    GET_INPUT_LINE InLine;
    InLine.Prompt = Prompt;
    InLine.Buffer = Buffer;
    InLine.BufferSize = BufferSize;
    if (Ioctl(IG_GET_INPUT_LINE, (PVOID)&InLine, sizeof(InLine)))
    {
        return InLine.InputSize;
    }
    else
    {
        return 0;
    }
}

__inline BOOL
GetExpressionEx(
    PCSTR Expression,
    ULONG64* Value,
    PCSTR* Remainder
    )
{
    GET_EXPRESSION_EX Expr;
    Expr.Expression = Expression;
    if (Ioctl(IG_GET_EXPRESSION_EX, (PVOID)&Expr, sizeof(Expr)))
    {
        *Value = Expr.Value;

        if (Remainder != NULL)
        {
            *Remainder = Expr.Remainder;
        }

        return TRUE;
    }

    return FALSE;
}

__inline BOOL
TranslateVirtualToPhysical(
    ULONG64 Virtual,
    ULONG64* Physical
    )
{
    TRANSLATE_VIRTUAL_TO_PHYSICAL VToP;
    VToP.Virtual = Virtual;
    if (Ioctl(IG_TRANSLATE_VIRTUAL_TO_PHYSICAL, (PVOID)&VToP, sizeof(VToP)))
    {
        *Physical = VToP.Physical;
        return TRUE;
    }

    return FALSE;
}


#endif


#ifdef __cplusplus
}
#endif

#endif // _WDBGEXTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\exts\debug.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    debug.cxx

Abstract:

    Generic debug extensions.

Author:

    Albert Ting (AlbertT)  19-Feb-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

HANDLE hCurrentProcess;
WINDBG_EXTENSION_APIS ExtensionApis;

PWINDBG_OUTPUT_ROUTINE Print;
PWINDBG_GET_EXPRESSION EvalExpression;
PWINDBG_GET_SYMBOL GetSymbolRtn;
PWINDBG_CHECK_CONTROL_C CheckControlCRtn;

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;

BOOL bWindbg = FALSE;

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ::ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bWindbg = TRUE;

    return;
}

/*++

Routine Name:

    ExtensionApiVersion

Routine Description:

    Windbg calls this function to match between the
    version of windbg and the extension. If the versions
    doesn't match, windbg will not load the extension.

Arguments:

    None.

Return Value:

    None.

--*/
extern "C"
LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    static EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
    return &ApiVersion;
}

/*++

Routine Name:

    CheckVersion

Routine Description:

    This function is called before every command. It gives
    the extension a chance to compare between the versions
    of the target and the extension.

Arguments:

    None

Return Value:

    None.

--*/
extern "C"
VOID
CheckVersion(
    VOID
    )
{
}

VOID
TDebugExt::
vDumpPDL(
    PDLINK pDLink
    )
{
    Print( "%x  %x", pDLink->FLink, pDLink->BLink );

    if( pDLink->FLink == pDLink->BLink ){
        Print( " <empty>\n" );
    } else {
        Print( "\n" );
    }
}

VOID
TDebugExt::
vDumpStr(
    LPCWSTR pszString
    )
{
    WCHAR szString[MAX_PATH];

    if( (LPCWSTR)pszString == NULL ){

        Print( "(NULL)\n" );
        return;
    }

    szString[0] = 0;

    //
    // First try reading to the end of 1k (pages are 4k on x86, but
    // most strings are < 1k ).
    //
    UINT cbShort = (UINT)(0x400 - ( (ULONG_PTR)pszString & 0x3ff ));
    BOOL bFound = FALSE;

    if( cbShort < sizeof( szString )){

        UINT i;

        move2( szString, pszString, cbShort );

        //
        // Look for a NULL.
        //
        for( i=0; i< cbShort/sizeof( pszString[0] ); ++i )
        {
            if( !szString[i] ){
                bFound = TRUE;
            }
        }

    }

    if( !bFound ){

        move( szString, pszString );
    }

    if( szString[0] == 0 ){
        Print( "\"\"\n" );
    } else {
        Print( "%ws\n", szString );
    }
}

VOID
TDebugExt::
vDumpStrA(
    LPCSTR pszString
    )
{
    CHAR szString[MAX_PATH];

    if( (LPCSTR)pszString == NULL ){

        Print( "(NULL)\n" );
        return;
    }

    szString[0] = 0;

    //
    // First try reading to the end of 1k (pages are 4k on x86, but
    // most strings are < 1k ).
    //
    UINT cbShort = 0x400 - (UINT)( (ULONG_PTR)pszString & 0x3ff );
    BOOL bFound = FALSE;

    if( cbShort < sizeof( szString )){

        UINT i;

        move2( szString, pszString, cbShort );

        //
        // Look for a NULL.
        //
        for( i=0; i< cbShort/sizeof( pszString[0] ); ++i )
        {
            if( !szString[i] ){
                bFound = TRUE;
            }
        }

    }

    if( !bFound ){

        move( szString, pszString );
    }

    if( szString[0] == 0 ){
        Print( "\"\"\n" );
    } else {
        Print( "%hs\n", szString );
    }
}

VOID
TDebugExt::
vDumpTime(
    const SYSTEMTIME& st
    )
{
    Print( "%d/%d/%d %d %d:%d:%d.%d\n",
           st.wMonth,
           st.wDay,
           st.wYear,
           st.wDayOfWeek,
           st.wHour,
           st.wMinute,
           st.wSecond,
           st.wMilliseconds );
}


VOID
TDebugExt::
vDumpFlags(
    ULONG_PTR dwFlags,
    PDEBUG_FLAGS pDebugFlags
    )
{
    ULONG_PTR dwFound = 0;

    Print( "%x [ ", dwFlags );

    for( ; pDebugFlags->dwFlag; ++pDebugFlags ){

        if( dwFlags & pDebugFlags->dwFlag ){
            Print( "%s ", pDebugFlags->pszFlag );
            dwFound |= pDebugFlags->dwFlag;
        }
    }

    Print( "]" );

    //
    // Check if there are extra bits set that we don't understand.
    //
    if( dwFound != dwFlags ){
        Print( "<ExtraBits: %x>", dwFlags & ~dwFound );
    }
    Print( "\n" );
}

VOID
TDebugExt::
vDumpValue(
    ULONG_PTR dwValue,
    PDEBUG_VALUES pDebugValues
    )
{
    Print( "%x ", dwValue );

    for( ; pDebugValues->dwValue; ++pDebugValues ){

        if( dwValue == pDebugValues->dwValue ){
            Print( "%s ", pDebugValues->pszValue );
        }
    }
    Print( "\n" );
}

VOID
TDebugExt::
vDumpTrace(
    ULONG_PTR dwAddress
    )
{
#ifdef TRACE_ENABLED

    INT i;
    CHAR szSymbol[64];
    ULONG_PTR dwDisplacement;
    ULONG_PTR adwTrace[ ( OFFSETOF( TBackTraceDB::TTrace, apvBackTrace ) +
                         sizeof( PVOID ) * VBackTrace::kMaxDepth )
                     / sizeof( ULONG_PTR )];

    if( !dwAddress ){
        return;
    }

    move( adwTrace, dwAddress );

    TBackTraceDB::TTrace *pTrace = (TBackTraceDB::TTrace*)adwTrace;

    printf( "Trace %x Hash = %x Count = %x\n",
            dwAddress,
            pTrace->_ulHash,
            pTrace->_lCount );

    for( i=0; i < VBackTrace::kMaxDepth; i++ ){

        if( !pTrace->apvBackTrace[i] ){
            break;
        }
        GetSymbolRtn( (PVOID)pTrace->apvBackTrace[i],
                      szSymbol,
                      &dwDisplacement );
        Print( "%08x %s+%x\n",
               pTrace->apvBackTrace[i], szSymbol,
               dwDisplacement );
    }

    if( i > 0 ){
        Print( "\n" );
    }
#endif
}

ULONG_PTR
TDebugExt::
dwEval(
    LPSTR& lpArgumentString,
    BOOL   bParam
    )
{
    ULONG_PTR dwReturn;
    LPSTR pSpace = NULL;

    while( *lpArgumentString == ' ' ){
        lpArgumentString++;
    }

    //
    // If it's a parameter, scan to next space and delimit.
    //
    if( bParam ){

        for( pSpace = lpArgumentString; *pSpace && *pSpace != ' '; ++pSpace )
            ;

        if( *pSpace == ' ' ){
            *pSpace = 0;
        } else {
            pSpace = NULL;
        }
    }

    dwReturn = (ULONG_PTR)EvalExpression( lpArgumentString );

    while( *lpArgumentString != ' ' && *lpArgumentString ){
        lpArgumentString++;
    }

    if( pSpace ){
        *pSpace = ' ';
    }

    return dwReturn;
}

/********************************************************************

    Generic extensions

********************************************************************/

VOID
TDebugExt::
vLookCalls(
    HANDLE hProcess,
    HANDLE hThread,
    ULONG_PTR dwStartAddr,
    ULONG_PTR dwLength,
    ULONG_PTR dwFlags
    )
{
#if i386
    struct OPCODES {
        BYTE op;
        UINT uLen;
    };

    OPCODES Opcodes[] = {
        0xe8, 5,            // rel16
        0xff, 6,            // r/m16
        0x0, 0
    };

    dwStartAddr = DWordAlign( dwStartAddr );
    dwLength = DWordAlign( dwLength );

    if( !dwStartAddr ){

        //
        // No address specified; use esp.
        //
        dwStartAddr = DWordAlign( (ULONG_PTR)EvalExpression( "ebp" ));
    }

    if( !dwLength ){

        DWORD Status;
        THREAD_BASIC_INFORMATION ThreadInformation;

        Status = NtQueryInformationThread( hThread,
                                           ThreadBasicInformation,
                                           &ThreadInformation,
                                           sizeof( ThreadInformation ),
                                           NULL
                                           );
        if( NT_SUCCESS( Status )){

            TEB Teb;
            ULONG_PTR dwBase;

            move( Teb, ThreadInformation.TebBaseAddress );

            dwBase = DWordAlign( (ULONG_PTR)Teb.NtTib.StackBase );

            if( dwBase > dwStartAddr ){
                dwLength = dwBase - dwStartAddr;
            }

        } else {

            Print( "Unable to get Teb %d\n", Status );
            return;
        }
    }

    Print( "Start %x End %x (Length %x)\n",
           dwStartAddr, dwStartAddr + dwLength, dwLength );

    if( !( dwFlags & (kLCFlagAll|kLCVerbose )))
    {
        Print( "FramePtr Arguments                   "
               "Next call (move one line up)\n" );
    }

    ULONG_PTR dwAddr;

    for( dwAddr = dwStartAddr;
         dwAddr < dwStartAddr + dwLength;
         ++dwAddr ){

        if( CheckControlCRtn()){
            Print( "Aborted.\n" );
            return;
        }

        //
        // Get a value on the stack and see if it looks like an ebp on
        // the stack.  It should be close to the current address, but
        // be greater.
        //
        ULONG_PTR dwNextFrame = 0;
        move( dwNextFrame, dwAddr );

        BOOL bLooksLikeEbp = dwNextFrame > dwAddr &&
                             dwNextFrame - dwAddr < kMaxCallFrame;
        //
        // If we are dumping all, or it looks like an ebp, dump it.
        //
        if(( dwFlags & kLCFlagAll ) || bLooksLikeEbp ){

            //
            // Check if next address looks like a valid call request.
            //
            ULONG_PTR dwRetAddr = 0;

            //
            // Get return address.
            //
            move( dwRetAddr, dwAddr + sizeof( DWORD ));

            //
            // Get 16 bytes before return address.
            //
            BYTE abyBuffer[16];
            ZeroMemory( abyBuffer, sizeof( abyBuffer ));
            move( abyBuffer, dwRetAddr - sizeof( abyBuffer ));

            //
            // Check if previous bytes look like a call instruction.
            //
            UINT i;
            for( i = 0; Opcodes[i].op; ++i ){

                if( abyBuffer[sizeof( abyBuffer )-Opcodes[i].uLen] ==
                    Opcodes[i].op ){

                    CHAR szSymbol[64];
                    ULONG_PTR dwDisplacement;
                    LPCSTR pszNull = "";
                    LPCSTR pszStar = "*** ";
                    LPCSTR pszPrefix = pszNull;

                    if(( dwFlags & kLCFlagAll ) && bLooksLikeEbp ){
                        pszPrefix = pszStar;
                    }

                    GetSymbolRtn( (PVOID)dwRetAddr,
                                  szSymbol,
                                  &dwDisplacement );

                    //
                    // Found what could be a match: dump it out.
                    //

                    DWORD dwArg[4];
                    move( dwArg, dwAddr + 2*sizeof( DWORD ));

                    if( dwFlags & kLCVerbose ){

                        Print( "%s%x %s+0x%x\n",
                               pszPrefix,
                               dwRetAddr,
                               szSymbol,
                               dwDisplacement );

                        Print( "%s%08x: %08x %08x  %08x %08x %08x %08x\n",
                               pszPrefix,
                               dwAddr,
                               dwNextFrame, dwRetAddr,
                               dwArg[0], dwArg[1], dwArg[2], dwArg[3] );

                        DWORD adwNextFrame[2];
                        ZeroMemory( adwNextFrame, sizeof( adwNextFrame ));
                        move( adwNextFrame, dwNextFrame );

                        Print( "%s%08x: %08x %08x\n\n",
                               pszPrefix,
                               dwNextFrame, adwNextFrame[0], adwNextFrame[1] );
                    } else {

                        Print( "%08x %08x %08x %08x  %08x-%s+0x%x\n",
                               dwAddr,
                               dwArg[0], dwArg[1], dwArg[2],
                               dwRetAddr, szSymbol, dwDisplacement );
                    }
                }
            }
        }
    }
#else
    Print( "Only supported on x86\n" );
#endif
}

VOID
TDebugExt::
vFindPointer(
    HANDLE hProcess,
    ULONG_PTR dwStartAddr,
    ULONG_PTR dwEndAddr,
    ULONG_PTR dwStartPtr,
    ULONG_PTR dwEndPtr
    )
{
    BYTE abyBuf[kFPGranularity];

    //
    // Read each granularity chunk then scan the buffer.
    // (Start by rounding down.)
    //
    ULONG_PTR dwCur;
    for( dwCur = dwStartAddr & ~( kFPGranularity - 1 );
         dwCur < dwEndAddr;
         dwCur += kFPGranularity ){

        ZeroMemory( abyBuf, sizeof( abyBuf ));

        move( abyBuf, dwCur );

        ULONG_PTR i;
        for( i=0; i< kFPGranularity; i += sizeof( DWORD ) ){

            ULONG_PTR dwVal = *((PDWORD)(abyBuf+i));
            if( dwVal >= dwStartPtr &&
                dwVal <= dwEndPtr &&
                dwCur + i >= dwStartAddr &&
                dwCur + i <= dwEndAddr ){

                Print( "%08x : %08x\n", dwCur + i, dwVal );
            }
        }

        if( CheckControlCRtn()){
            Print( "Aborted at %08x.\n", dwCur+i );
            return;
        }
    }
}

VOID
TDebugExt::
vCreateRemoteThread(
    HANDLE hProcess,
    ULONG_PTR dwAddr,
    ULONG_PTR dwParm
    )
{
    DWORD dwThreadId = 0;

    if( !CreateRemoteThread( hProcess,
                             NULL,
                             4*4096,
                             (LPTHREAD_START_ROUTINE)dwAddr,
                             (LPVOID)dwParm,
                             0,
                             &dwThreadId )){

        Print( "<Error: Unable to ct %x( %x ) %d.>\n",
               dwAddr, dwParm, GetLastError( ));
        return;
    }

    Print( "<ct %x( %x ) threadid=<%d>>\n", dwAddr, dwParm, dwThreadId );
}


/********************************************************************

    Extension entrypoints.

********************************************************************/

DEBUG_EXT_HEAD( help )
{
    DEBUG_EXT_SETUP_VARS();

    Print( "Spllib Extensions\n" );
    Print( "---------------------------------------------------------\n" );
    Print( "d       dump spooler structure based on signature\n" );
    Print( "ds      dump pIniSpooler\n" );
    Print( "dlcs    dump localspl's critical section (debug builds only)\n" );
    Print( "lastlog dump localspl's debug tracing (uses ddt flags)\n" );
    Print( "ddev    dump Unicode devmode\n" );
    Print( "ddeva   dump Ansi devmode\n" );
    Print( "dmem    dump spllib heap blocks\n" );
    Print( "---------------------------------------------------------\n" );
    Print( "dcs     dump spllib critical section\n" );
    Print( "ddt     dump spllib debug trace buffer\n" );
    Print( "        ** Recent lines printed first! **\n" );
    Print( "        -c Count (number of recent lines to print)\n" );
    Print( "        -l Level (DBG_*) to print\n" );
    Print( "        -b Dump backtrace (x86 only)\n" );
    Print( "        -d Print debug message (default if -x not specified)\n" );
    Print( "        -x Print hex information\n" );
    Print( "        -r Dump raw buffer: specify pointer to lines\n" );
    Print( "        -t tid: Dump specific thread $1\n" );
    Print( "        -s Skip $1 lines that would otherwise print.\n" );
    Print( "        -m Search for $1 in memory block (gpbtAlloc/gpbtFree only)\n" );
    Print( "dbt     dump raw backtrace\n" );
    Print( "dtbt    dump text backtrace\n" );
    Print( "ddp     dump debug pointers\n" );
    Print( "---------------------------------------------------------\n" );
    Print( "fl      free library $1 (hLibrary)\n" );
    Print( "ct      create thread at $1 with arg $2\n" );
    Print( "fp      find pointer from $1 to $2 range, ptr $3 to $4 range\n" );
    Print( "lc      look for calls at $1 for $2 bytes (x86 only)\n" );
    Print( "        -a Check all for return addresses\n" );
    Print( "        -v Verbose\n" );
    Print( "sleep   Sleep for $1 ms\n" );
    Print( "dbti    Dump KM backtrace index\n");
}


DEBUG_EXT_HEAD( dtbt )
{
    DEBUG_EXT_SETUP_VARS();

    for( ; *lpArgumentString; )
    {
        ULONG_PTR p;
        CHAR szSymbol[64];

        p = TDebugExt::dwEval( lpArgumentString, FALSE );

        if( !p )
        {
            break;
        }

        ULONG_PTR dwDisplacement;

        GetSymbolRtn( (PVOID)p,
                      szSymbol,
                      &dwDisplacement );

        Print( "%08x %s+%x\n", p, szSymbol, dwDisplacement );
    }
}

DEBUG_EXT_HEAD( fl )
{
    DEBUG_EXT_SETUP_VARS();

    //
    // Relies on the fact that kernel32 won't be relocated.
    //
    TDebugExt::vCreateRemoteThread( hCurrentProcess,
                                    (ULONG_PTR)&FreeLibrary,
                                    TDebugExt::dwEval( lpArgumentString, FALSE ));
}

DEBUG_EXT_HEAD( fp )
{
    DEBUG_EXT_SETUP_VARS();

    ULONG_PTR dwStartAddr = TDebugExt::dwEval( lpArgumentString, TRUE );
    ULONG_PTR dwEndAddr = TDebugExt::dwEval( lpArgumentString, TRUE );

    ULONG_PTR dwStartPtr = TDebugExt::dwEval( lpArgumentString, TRUE );
    ULONG_PTR dwEndPtr = TDebugExt::dwEval( lpArgumentString, TRUE );

    TDebugExt::vFindPointer( hCurrentProcess,
                             dwStartAddr,
                             dwEndAddr,
                             dwStartPtr,
                             dwEndPtr );
}


DEBUG_EXT_HEAD( ct )
{
    DEBUG_EXT_SETUP_VARS();

    ULONG_PTR dwStartAddr = TDebugExt::dwEval( lpArgumentString, TRUE );
    ULONG_PTR dwParm = TDebugExt::dwEval( lpArgumentString, FALSE );

    TDebugExt::vCreateRemoteThread( hCurrentProcess,
                                    dwStartAddr,
                                    dwParm );
}

DEBUG_EXT_HEAD( sleep )
{
    DEBUG_EXT_SETUP_VARS();

    const UINT_PTR kSleepInterval = 500;

    ULONG_PTR SleepMS = atoi(lpArgumentString);

    UINT_PTR i = SleepMS / kSleepInterval;

    Sleep((DWORD)(SleepMS % kSleepInterval));

    for (i = SleepMS / kSleepInterval; i; --i)
    {
        if (CheckControlCRtn())
        {
            break;
        }
        Sleep(kSleepInterval);
    }
}

DEBUG_EXT_HEAD( lc )
{
    DEBUG_EXT_SETUP_VARS();

    ULONG_PTR dwFlags = 0;

    for( ; *lpArgumentString; ++lpArgumentString ){

        while( *lpArgumentString == ' ' ){
            ++lpArgumentString;
        }

        if (*lpArgumentString != '-') {
            break;
        }

        ++lpArgumentString;

        switch( *lpArgumentString ){
        case 'A':
        case 'a':

            dwFlags |= TDebugExt::kLCFlagAll;
            break;

        case 'V':
        case 'v':

            dwFlags |= TDebugExt::kLCVerbose;
            break;

        default:
            Print( "Unknown option %c.\n", lpArgumentString[0] );
            return;
        }
    }

    ULONG_PTR dwStartAddr = TDebugExt::dwEval( lpArgumentString, TRUE );
    ULONG_PTR dwLength = TDebugExt::dwEval( lpArgumentString, FALSE );

    TDebugExt::vLookCalls( hCurrentProcess,
                           hCurrentThread,
                           dwStartAddr,
                           dwLength,
                           dwFlags );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inc\mtype.h ===
/*++

Copyright (c) 1990 - 2000  Microsoft Corporation
All rights reserved.

Module Name:

    mtype.h

Abstract:

    Marshalling code needs this information about each field in _INFO_ structures. 
    Data.h define arrays of FieldInfo structures for each _INFO_ structure
    
Author:

    AdinaTru 18 Jan 2000

Revision History:


--*/

#ifndef _MTYPE
#define _MTYPE

typedef enum _EFIELDTYPE 
{
    DATA_TYPE = 0,
    PTR_TYPE  = 1,

} EFIELDTYPE;


typedef enum Call_Route
{
    NATIVE_CALL  = 0,   // either KM call or Spooler in-proc call
    RPC_CALL     = 1,   // RPC call
   
} CALL_ROUTE;

//
// Holds information about a field in public spooler structures _INFO_
//
typedef struct _FieldInfo 
{
    DWORD32 Offset;           // Field's offset inside structure
    ULONG_PTR Size;           // Field's size in bytes
    ULONG_PTR Alignment;      // Field's alignment; Not always the same as the size!!!
    EFIELDTYPE  Type;         // Field's type;  PTR_TYPE if pointer, DATA_TYPE otherwise

} FieldInfo;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inc\data.h ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    data.h

Abstract:

    Common definitions for structure offsets for pointer based data.

Author:

Environment:

    User Mode - Win32

Revision History:

Notes: 

    FOR ADDING OR UPDATING Offset structures.

All the offsets should appear in ascending order in the struct. This is critical
for converting 32 bit structures into the corresponding 64 bit structures. Custom 
marshalling will break if this is not adhered to.

See spllib\marshall.cxx for additional information

--*/

#ifndef _DATA_H
#define _DATA_H

#include <offsets.h>
#include <winsprlp.h>

#ifdef PRINTER_OFFSETS
DWORD PrinterInfoStressOffsets[]={offsetof(PRINTER_INFO_STRESSA, pPrinterName),
                             offsetof(PRINTER_INFO_STRESSA, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo1Offsets[]={offsetof(PRINTER_INFO_1A, pDescription),
                             offsetof(PRINTER_INFO_1A, pName),
                             offsetof(PRINTER_INFO_1A, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2Offsets[]={offsetof(PRINTER_INFO_2A, pServerName),
                             offsetof(PRINTER_INFO_2A, pPrinterName),
                             offsetof(PRINTER_INFO_2A, pShareName),
                             offsetof(PRINTER_INFO_2A, pPortName),
                             offsetof(PRINTER_INFO_2A, pDriverName),
                             offsetof(PRINTER_INFO_2A, pComment),
                             offsetof(PRINTER_INFO_2A, pLocation),
                             offsetof(PRINTER_INFO_2A, pDevMode),
                             offsetof(PRINTER_INFO_2A, pSepFile),
                             offsetof(PRINTER_INFO_2A, pPrintProcessor),
                             offsetof(PRINTER_INFO_2A, pDatatype),
                             offsetof(PRINTER_INFO_2A, pParameters),
                             offsetof(PRINTER_INFO_2A, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo3Offsets[]={offsetof(PRINTER_INFO_3, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo4Offsets[]={offsetof(PRINTER_INFO_4A, pPrinterName),
                             offsetof(PRINTER_INFO_4A, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5Offsets[]={offsetof(PRINTER_INFO_5A, pPrinterName),
                             offsetof(PRINTER_INFO_5A, pPortName),
                             0xFFFFFFFF};

DWORD PrinterInfo6Offsets[]={0xFFFFFFFF};

DWORD PrinterInfo7Offsets[]={offsetof(PRINTER_INFO_7A, pszObjectGUID),
                             0xFFFFFFFF};

DWORD PrinterInfo8Offsets[]={offsetof(PRINTER_INFO_8A, pDevMode),
                             0xFFFFFFFF};

DWORD PrinterInfo9Offsets[]={offsetof(PRINTER_INFO_9A, pDevMode),
                             0xFFFFFFFF};
#endif

#ifdef PRINTER_STRINGS
DWORD PrinterInfoStressStrings[]={offsetof(PRINTER_INFO_STRESSA, pPrinterName),
                             offsetof(PRINTER_INFO_STRESSA, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo1Strings[]={offsetof(PRINTER_INFO_1A, pDescription),
                             offsetof(PRINTER_INFO_1A, pName),
                             offsetof(PRINTER_INFO_1A, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2Strings[]={offsetof(PRINTER_INFO_2A, pServerName),
                             offsetof(PRINTER_INFO_2A, pPrinterName),
                             offsetof(PRINTER_INFO_2A, pShareName),
                             offsetof(PRINTER_INFO_2A, pPortName),
                             offsetof(PRINTER_INFO_2A, pDriverName),
                             offsetof(PRINTER_INFO_2A, pComment),
                             offsetof(PRINTER_INFO_2A, pLocation),
                             offsetof(PRINTER_INFO_2A, pSepFile),
                             offsetof(PRINTER_INFO_2A, pPrintProcessor),
                             offsetof(PRINTER_INFO_2A, pDatatype),
                             offsetof(PRINTER_INFO_2A, pParameters),
                             0xFFFFFFFF};

DWORD PrinterInfo3Strings[]={0xFFFFFFFF};

DWORD PrinterInfo4Strings[]={offsetof(PRINTER_INFO_4A, pPrinterName),
                             offsetof(PRINTER_INFO_4A, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5Strings[]={offsetof(PRINTER_INFO_5A, pPrinterName),
                             offsetof(PRINTER_INFO_5A, pPortName),
                             0xFFFFFFFF};

DWORD PrinterInfo6Strings[]={0xFFFFFFFF};

DWORD PrinterInfo7Strings[]={offsetof(PRINTER_INFO_7A, pszObjectGUID),
                             0xFFFFFFFF};

DWORD PrinterInfo8Strings[]={0xFFFFFFFF};

DWORD PrinterInfo9Strings[]={0xFFFFFFFF};

#endif


#ifdef JOB_OFFSETS
DWORD JobInfo1Offsets[]={offsetof(JOB_INFO_1A, pPrinterName),
                         offsetof(JOB_INFO_1A, pMachineName),
                         offsetof(JOB_INFO_1A, pUserName),
                         offsetof(JOB_INFO_1A, pDocument),
                         offsetof(JOB_INFO_1A, pDatatype),
                         offsetof(JOB_INFO_1A, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo2Offsets[]={offsetof(JOB_INFO_2, pPrinterName),
                         offsetof(JOB_INFO_2, pMachineName),
                         offsetof(JOB_INFO_2, pUserName),
                         offsetof(JOB_INFO_2, pDocument),
                         offsetof(JOB_INFO_2, pNotifyName),
                         offsetof(JOB_INFO_2, pDatatype),
                         offsetof(JOB_INFO_2, pPrintProcessor),
                         offsetof(JOB_INFO_2, pParameters),
                         offsetof(JOB_INFO_2, pDriverName),
                         offsetof(JOB_INFO_2, pDevMode),
                         offsetof(JOB_INFO_2, pStatus),
                         offsetof(JOB_INFO_2, pSecurityDescriptor),
                         0xFFFFFFFF};

DWORD JobInfo3Offsets[]={0xFFFFFFFF};
#endif

#ifdef JOB_STRINGS
DWORD JobInfo1Strings[]={offsetof(JOB_INFO_1A, pPrinterName),
                         offsetof(JOB_INFO_1A, pMachineName),
                         offsetof(JOB_INFO_1A, pUserName),
                         offsetof(JOB_INFO_1A, pDocument),
                         offsetof(JOB_INFO_1A, pDatatype),
                         offsetof(JOB_INFO_1A, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo2Strings[]={offsetof(JOB_INFO_2, pPrinterName),
                         offsetof(JOB_INFO_2, pMachineName),
                         offsetof(JOB_INFO_2, pUserName),
                         offsetof(JOB_INFO_2, pDocument),
                         offsetof(JOB_INFO_2, pNotifyName),
                         offsetof(JOB_INFO_2, pDatatype),
                         offsetof(JOB_INFO_2, pPrintProcessor),
                         offsetof(JOB_INFO_2, pParameters),
                         offsetof(JOB_INFO_2, pDriverName),
                         offsetof(JOB_INFO_2, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo3Strings[]={0xFFFFFFFF};
#endif


#ifdef DRIVER_OFFSETS
DWORD DriverInfo1Offsets[]={offsetof(DRIVER_INFO_1A, pName),
                            0xFFFFFFFF};

DWORD DriverInfo2Offsets[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo3Offsets[]={offsetof(DRIVER_INFO_3A, pName),
                            offsetof(DRIVER_INFO_3A, pEnvironment),
                            offsetof(DRIVER_INFO_3A, pDriverPath),
                            offsetof(DRIVER_INFO_3A, pDataFile),
                            offsetof(DRIVER_INFO_3A, pConfigFile),
                            offsetof(DRIVER_INFO_3A, pHelpFile),
                            offsetof(DRIVER_INFO_3A, pDependentFiles),
                            offsetof(DRIVER_INFO_3A, pMonitorName),
                            offsetof(DRIVER_INFO_3A, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo4Offsets[]={offsetof(DRIVER_INFO_4A, pName),
                            offsetof(DRIVER_INFO_4A, pEnvironment),
                            offsetof(DRIVER_INFO_4A, pDriverPath),
                            offsetof(DRIVER_INFO_4A, pDataFile),
                            offsetof(DRIVER_INFO_4A, pConfigFile),
                            offsetof(DRIVER_INFO_4A, pHelpFile),
                            offsetof(DRIVER_INFO_4A, pDependentFiles),
                            offsetof(DRIVER_INFO_4A, pMonitorName),
                            offsetof(DRIVER_INFO_4A, pDefaultDataType),
                            offsetof(DRIVER_INFO_4A, pszzPreviousNames),
                            0xFFFFFFFF};

DWORD DriverInfo5Offsets[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo6Offsets[]={offsetof(DRIVER_INFO_6A, pName),
                            offsetof(DRIVER_INFO_6A, pEnvironment),
                            offsetof(DRIVER_INFO_6A, pDriverPath),
                            offsetof(DRIVER_INFO_6A, pDataFile),
                            offsetof(DRIVER_INFO_6A, pConfigFile),
                            offsetof(DRIVER_INFO_6A, pHelpFile),
                            offsetof(DRIVER_INFO_6A, pDependentFiles),
                            offsetof(DRIVER_INFO_6A, pMonitorName),
                            offsetof(DRIVER_INFO_6A, pDefaultDataType),
                            offsetof(DRIVER_INFO_6A, pszzPreviousNames),
                            offsetof(DRIVER_INFO_6A, pszMfgName),
                            offsetof(DRIVER_INFO_6A, pszOEMUrl),
                            offsetof(DRIVER_INFO_6A, pszHardwareID),
                            offsetof(DRIVER_INFO_6A, pszProvider),
                            0xFFFFFFFF};


#endif

#ifdef DRIVER_STRINGS
DWORD DriverInfo1Strings[]={offsetof(DRIVER_INFO_1A, pName),
                            0xFFFFFFFF};

DWORD DriverInfo2Strings[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo3Strings[]={offsetof(DRIVER_INFO_3A, pName),
                            offsetof(DRIVER_INFO_3A, pEnvironment),
                            offsetof(DRIVER_INFO_3A, pDriverPath),
                            offsetof(DRIVER_INFO_3A, pDataFile),
                            offsetof(DRIVER_INFO_3A, pConfigFile),
                            offsetof(DRIVER_INFO_3A, pHelpFile),
                            offsetof(DRIVER_INFO_3A, pMonitorName),
                            offsetof(DRIVER_INFO_3A, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo4Strings[]={offsetof(DRIVER_INFO_4A, pName),
                            offsetof(DRIVER_INFO_4A, pEnvironment),
                            offsetof(DRIVER_INFO_4A, pDriverPath),
                            offsetof(DRIVER_INFO_4A, pDataFile),
                            offsetof(DRIVER_INFO_4A, pConfigFile),
                            offsetof(DRIVER_INFO_4A, pHelpFile),
                            offsetof(DRIVER_INFO_4A, pMonitorName),
                            offsetof(DRIVER_INFO_4A, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo5Strings[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo6Strings[]={offsetof(DRIVER_INFO_6A, pName),
                            offsetof(DRIVER_INFO_6A, pEnvironment),
                            offsetof(DRIVER_INFO_6A, pDriverPath),
                            offsetof(DRIVER_INFO_6A, pDataFile),
                            offsetof(DRIVER_INFO_6A, pConfigFile),
                            offsetof(DRIVER_INFO_6A, pHelpFile),
                            offsetof(DRIVER_INFO_6A, pMonitorName),
                            offsetof(DRIVER_INFO_6A, pDefaultDataType),
                            offsetof(DRIVER_INFO_6A, pszMfgName),
                            offsetof(DRIVER_INFO_6A, pszOEMUrl),
                            offsetof(DRIVER_INFO_6A, pszHardwareID),
                            offsetof(DRIVER_INFO_6A, pszProvider),
                            0xFFFFFFFF};

DWORD DriverInfoVersionStrings[]={offsetof(DRIVER_INFO_VERSION, pName),
                                  offsetof(DRIVER_INFO_VERSION, pEnvironment),
                                  offsetof(DRIVER_INFO_VERSION, pMonitorName),
                                  offsetof(DRIVER_INFO_VERSION, pDefaultDataType),
                                  offsetof(DRIVER_INFO_VERSION, pszMfgName),
                                  offsetof(DRIVER_INFO_VERSION, pszOEMUrl),
                                  offsetof(DRIVER_INFO_VERSION, pszHardwareID),
                                  offsetof(DRIVER_INFO_VERSION, pszProvider),
                                  0xFFFFFFFF};



#endif


#ifdef ADDJOB_OFFSETS
DWORD AddJobOffsets[]={offsetof(ADDJOB_INFO_1A, Path),
                       0xFFFFFFFF};
DWORD AddJob2Offsets[]={offsetof(ADDJOB_INFO_2W, pData),
                       0xFFFFFFFF};
#endif

#ifdef ADDJOB_STRINGS
DWORD AddJobStrings[]={offsetof(ADDJOB_INFO_1A, Path),
                       0xFFFFFFFF};
DWORD AddJob2Strings[]={offsetof(ADDJOB_INFO_2W, pData),
                        0xFFFFFFFF};

#endif


#ifdef FORM_OFFSETS
DWORD FormInfo1Offsets[]={offsetof(FORM_INFO_1A, pName),
                          0xFFFFFFFF};
#endif

#ifdef FORM_STRINGS
DWORD FormInfo1Strings[]={offsetof(FORM_INFO_1A, pName),
                          0xFFFFFFFF};
#endif


#ifdef PORT_OFFSETS
DWORD PortInfo1Offsets[]={offsetof(PORT_INFO_1A, pName),
                          0xFFFFFFFF};
DWORD PortInfo2Offsets[]={offsetof(PORT_INFO_2A, pPortName),
                          offsetof(PORT_INFO_2A, pMonitorName),
                          offsetof(PORT_INFO_2A, pDescription),
                          0xFFFFFFFF};
DWORD PortInfo3Offsets[]={offsetof(PORT_INFO_3A, pszStatus),
                          0xFFFFFFFF};
#endif

#ifdef PORT_STRINGS
DWORD PortInfo1Strings[]={offsetof(PORT_INFO_1A, pName),
                          0xFFFFFFFF};
DWORD PortInfo2Strings[]={offsetof(PORT_INFO_2A, pPortName),
                          offsetof(PORT_INFO_2A, pMonitorName),
                          offsetof(PORT_INFO_2A, pDescription),
                          0xFFFFFFFF};
#endif


#ifdef PRINTPROCESSOR_OFFSETS
DWORD PrintProcessorInfo1Offsets[]={offsetof(PRINTPROCESSOR_INFO_1A, pName),
                                    0xFFFFFFFF};
#endif

#ifdef PRINTPROCESSOR_STRINGS
DWORD PrintProcessorInfo1Strings[]={offsetof(PRINTPROCESSOR_INFO_1A, pName),
                                    0xFFFFFFFF};
#endif


#ifdef MONITOR_OFFSETS
DWORD MonitorInfo1Offsets[]={offsetof(MONITOR_INFO_1A, pName),
                             0xFFFFFFFF};
DWORD MonitorInfo2Offsets[]={offsetof(MONITOR_INFO_2A, pName),
                             offsetof(MONITOR_INFO_2A, pEnvironment),
                             offsetof(MONITOR_INFO_2A, pDLLName),
                             0xFFFFFFFF};
#endif

#ifdef MONITOR_STRINGS
DWORD MonitorInfo1Strings[]={offsetof(MONITOR_INFO_1A, pName),
                             0xFFFFFFFF};

DWORD MonitorInfo2Strings[]={offsetof(MONITOR_INFO_2A, pName),
                             offsetof(MONITOR_INFO_2A, pEnvironment),
                             offsetof(MONITOR_INFO_2A, pDLLName),
                             0xFFFFFFFF};
#endif


#ifdef DOCINFO_OFFSETS
DWORD DocInfo1Offsets[]={offsetof(DOC_INFO_1A, pDocName),
                         offsetof(DOC_INFO_1A, pOutputFile),
                         offsetof(DOC_INFO_1A, pDatatype),
                         0xFFFFFFFF};
#endif

#ifdef DOCINFO_STRINGS
DWORD DocInfo1Strings[]={offsetof(DOC_INFO_1A, pDocName),
                         offsetof(DOC_INFO_1A, pOutputFile),
                         offsetof(DOC_INFO_1A, pDatatype),
                         0xFFFFFFFF};
#endif


#ifdef DATATYPE_OFFSETS
DWORD DatatypeInfo1Offsets[]={offsetof(DATATYPES_INFO_1A, pName),
                               0xFFFFFFFF};
#endif

#ifdef DATATYPE_STRINGS

DWORD DatatypeInfo1Strings[]={offsetof(DATATYPES_INFO_1A, pName),
                               0xFFFFFFFF};
#endif


#ifdef PRINTER_ENUM_VALUES_OFFSETS

DWORD PrinterEnumValuesOffsets[] = {offsetof(PRINTER_ENUM_VALUESA, pValueName),
                                    offsetof(PRINTER_ENUM_VALUESA, pData),
                                    0xFFFFFFFF};
#endif

#ifdef PROVIDOR_STRINGS
DWORD ProvidorInfo1Strings[]={offsetof(PROVIDOR_INFO_1A, pName),
                              offsetof(PROVIDOR_INFO_1A, pEnvironment),
                              offsetof(PROVIDOR_INFO_1A, pDLLName),
                              0xFFFFFFFF};

DWORD ProvidorInfo2Strings[]={0xFFFFFFFF};
#endif



#ifdef PRINTER_OFFSETS
FieldInfo PrinterInfoStressFields[]={
                             {offsetof(PRINTER_INFO_STRESSA, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },                                 
                             {offsetof(PRINTER_INFO_STRESSA, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cTotalJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cTotalBytes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, stUpTime), sizeof(SYSTEMTIME), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, MaxcRef), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cTotalPagesPrinted), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwGetVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, fFreeBuild), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cSpooling), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cRef), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cSpooling), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cErrorOutOfPaper), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cErrorNotReady), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cJobError), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwNumberOfProcessors), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwProcessorType), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwHighPartTotalBytes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cChangeID), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwLastError), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cEnumerateNetworkPrinters), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cAddNetPrinters), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, wProcessorArchitecture), sizeof(WORD), sizeof(WORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, wProcessorLevel), sizeof(WORD), sizeof(WORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cRefIC), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwReserved2), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwReserved3), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };
                             

FieldInfo PrinterInfo1Fields[]={
                                {offsetof(PRINTER_INFO_1A, Flags), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_1A, pDescription), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_1A, pComment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };
FieldInfo PrinterInfo2Fields[]={
                                {offsetof(PRINTER_INFO_2A, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pShareName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pDriverName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pComment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pLocation), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pSepFile), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pPrintProcessor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pParameters), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, DefaultPriority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, StartTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, UntilTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, cJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, AveragePPM), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo3Fields[]={
                                {offsetof(PRINTER_INFO_3, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo4Fields[]={
                                {offsetof(PRINTER_INFO_4A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_4A, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_4A, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo5Fields[]={
                                {offsetof(PRINTER_INFO_5A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_5A, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_5A, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_5A, TransmissionRetryTimeout), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_5A, TransmissionRetryTimeout), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo6Fields[]={
                                {offsetof(PRINTER_INFO_6, dwStatus), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo7Fields[]={
                                {offsetof(PRINTER_INFO_7A, pszObjectGUID), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_7A, dwAction), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo8Fields[]={
                                {offsetof(PRINTER_INFO_8A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo9Fields[]={
                                {offsetof(PRINTER_INFO_9A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

#endif


#ifdef JOB_OFFSETS

FieldInfo JobInfo1Fields[]= {
                             {offsetof(JOB_INFO_1A, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pMachineName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pUserName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pDocument), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pStatus), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, Position), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, TotalPages), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, PagesPrinted), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, Submitted), sizeof(SYSTEMTIME), sizeof(DWORD), DATA_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };


FieldInfo JobInfo2Fields[]= {
                             {offsetof(JOB_INFO_2A, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pMachineName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pUserName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDocument), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pNotifyName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pPrintProcessor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pParameters), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDriverName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pStatus), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Position), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, StartTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, UntilTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, TotalPages), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Size), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Submitted), sizeof(SYSTEMTIME), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Time), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, PagesPrinted), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };

FieldInfo JobInfo3Fields[]= {
                            {offsetof(JOB_INFO_3, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                            {offsetof(JOB_INFO_3, NextJobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                            {offsetof(JOB_INFO_3, Reserved), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                            {0xFFFFFFFF, 0, 0, DATA_TYPE}
                            };
#endif


#ifdef DRIVER_OFFSETS

FieldInfo DriverInfo1Fields[]= {
                                {offsetof(DRIVER_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo2Fields[]= {
                                {offsetof(DRIVER_INFO_2A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_2A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_2A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_2A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_2A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_2A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo3Fields[]= {
                                {offsetof(DRIVER_INFO_3A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_3A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_3A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_3A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {offsetof(DRIVER_INFO_3A, pHelpFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pDependentFiles), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo4Fields[]= {
                                {offsetof(DRIVER_INFO_4A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_4A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_4A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_4A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {offsetof(DRIVER_INFO_4A, pHelpFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pDependentFiles), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pszzPreviousNames), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo5Fields[]= {
                                {offsetof(DRIVER_INFO_5A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_5A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_5A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_5A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_5A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_5A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {offsetof(DRIVER_INFO_5A, dwDriverAttributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_5A, dwConfigVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_5A, dwDriverVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo DriverInfo6Fields[]= {
                                {offsetof(DRIVER_INFO_6A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_6A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_6A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_6A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pHelpFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pDependentFiles), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszzPreviousNames), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, ftDriverDate), sizeof(FILETIME), sizeof(DWORD), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_6A, dwlDriverVersion), sizeof(DWORDLONG), sizeof(DWORDLONG), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszMfgName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszOEMUrl), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszHardwareID), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszProvider), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo DriverInfoVersionFields[]= {
                                {offsetof(DRIVER_INFO_VERSION, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pFileInfo), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, dwFileCount), sizeof(DWORD),sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszzPreviousNames), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, ftDriverDate), sizeof(FILETIME), sizeof(DWORD), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, dwlDriverVersion), sizeof(DWORDLONG), sizeof(DWORDLONG), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszMfgName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszOEMUrl), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszHardwareID), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszProvider), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

#endif

#ifdef ADDJOB_OFFSETS
FieldInfo AddJobFields[]= {
                           {offsetof(ADDJOB_INFO_1A, Path), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                           {offsetof(ADDJOB_INFO_1A, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                           {0xFFFFFFFF, 0, 0, DATA_TYPE}
                           };
FieldInfo AddJob2Fields[]= {
                           {offsetof(ADDJOB_INFO_2W, pData), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                           {offsetof(ADDJOB_INFO_2W, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                           {0xFFFFFFFF, 0, 0, DATA_TYPE}
                           };

#endif


#ifdef FORM_OFFSETS
FieldInfo FormInfo1Fields[]= {
                              {offsetof(FORM_INFO_1A, Flags), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {offsetof(FORM_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(FORM_INFO_1A, Size), sizeof(SIZEL), sizeof(DWORD), DATA_TYPE },
                              {offsetof(FORM_INFO_1A, ImageableArea), sizeof(RECTL), sizeof(DWORD), DATA_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };
#endif

#ifdef PORT_OFFSETS
FieldInfo PortInfo1Fields[]= {
                              {offsetof(PORT_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };

FieldInfo PortInfo2Fields[]= {
                              {offsetof(PORT_INFO_2A, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_2A, pMonitorName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_2A, pDescription), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_2A, fPortType), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {offsetof(PORT_INFO_2A, Reserved), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };
                              
FieldInfo PortInfo3Fields[]= {
                              {offsetof(PORT_INFO_3A, dwStatus), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {offsetof(PORT_INFO_3A, pszStatus), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_3A, dwSeverity), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };
#endif


#ifdef PRINTPROCESSOR_OFFSETS
FieldInfo PrintProcessorInfo1Fields[]= {
                                        {offsetof(PRINTPROCESSOR_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                        {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                        };
                              
#endif


#ifdef MONITOR_OFFSETS
FieldInfo MonitorInfo1Fields[]= {
                                 {offsetof(MONITOR_INFO_2A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                 };
FieldInfo MonitorInfo2Fields[]= {
                                 {offsetof(MONITOR_INFO_2A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {offsetof(MONITOR_INFO_2A, pEnvironment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {offsetof(MONITOR_INFO_2A, pDLLName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                 };
#endif


#ifdef DOCINFO_OFFSETS
FieldInfo DocInfo1Fields[]= {
                             {offsetof(DOC_INFO_1A, pDocName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(DOC_INFO_1A, pOutputFile), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(DOC_INFO_1A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };
#endif


#ifdef DATATYPE_OFFSETS
FieldInfo DatatypeInfo1Fields[]={
                                 {offsetof(DATATYPES_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                 };
#endif

#ifdef PRINTER_ENUM_VALUES_OFFSETS
FieldInfo PrinterEnumValuesFields[]= {
                                      {offsetof(PRINTER_ENUM_VALUESA, pValueName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, cbValueName), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, dwType), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, pData), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, cbData), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                      {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                      };

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inc\ntfyjob.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved

Module Name:

    ntfyjob.h

Abstract:

    List of fields supported for printer notifications (jobs).  These
    must match JOB_NOTIFY_FIELD_* in winspool.h (order included).

Author:

    Albert Ting (AlbertT) 29-Sept-94

Environment:

    User Mode -Win32

Revision History:

--*/

//      Name,                Attributes,           Router,                   Localspl,                 Offsets

DEFINE( PRINTER_NAME       , TABLE_ATTRIB_COMPACT                     , TABLE_STRING            , TABLE_JOB_PRINTERNAME   , pIniPrinter )
DEFINE( MACHINE_NAME       , TABLE_ATTRIB_COMPACT                     , TABLE_STRING            , TABLE_STRING            , pMachineName )
DEFINE( PORT_NAME          , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_JOB_PORT          , pIniPort )
DEFINE( USER_NAME          , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pUser )
DEFINE( NOTIFY_NAME        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pNotify )
DEFINE( DATATYPE           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pDatatype )
DEFINE( PRINT_PROCESSOR    , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_PRINTPROC         , pIniPrintProc )
DEFINE( PARAMETERS         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pParameters )
DEFINE( DRIVER_NAME        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_DRIVER            , pIniDriver )
DEFINE( DEVMODE            , TABLE_ATTRIB_COMPACT                     , TABLE_DEVMODE           , TABLE_DEVMODE           , pDevMode )
DEFINE( STATUS             , 0                   |TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_JOB_STATUS        , Status )
DEFINE( STATUS_STRING      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pStatus )
DEFINE( SECURITY_DESCRIPTOR, TABLE_ATTRIB_COMPACT                     , TABLE_SECURITYDESCRIPTOR, TABLE_SECURITYDESCRIPTOR, pSecurityDescriptor )
DEFINE( DOCUMENT           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pDocument )
DEFINE( PRIORITY           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , Priority )
DEFINE( POSITION           , 0                                        , TABLE_DWORD             , TABLE_JOB_POSITION      , signature )
DEFINE( SUBMITTED          , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_TIME              , TABLE_TIME              , Submitted )
DEFINE( START_TIME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , StartTime )
DEFINE( UNTIL_TIME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , UntilTime )
DEFINE( TIME               , TABLE_ATTRIB_COMPACT                     , TABLE_DWORD             , TABLE_DWORD             , Time )
DEFINE( TOTAL_PAGES        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , cPages )
DEFINE( PAGES_PRINTED      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , cPagesPrinted )
DEFINE( TOTAL_BYTES        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , Size )
DEFINE( BYTES_PRINTED      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , cbPrinted )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inc\ntfyprn.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved

Module Name:

    ntfyprn.dat

Abstract:

    List of fields supported for printer notifications.  These
    must match PRINTER_NOTIFY_FIELD_* in winspool.h (order included).

Author:

    Albert Ting (AlbertT) 29-Sept-94

Environment:

    User Mode -Win32

Revision History:

--*/

//      Name,                Attributes,                                                     Router                    Localspl                  Offsets

DEFINE( SERVER_NAME        , TABLE_ATTRIB_COMPACT                                          , TABLE_STRING            , TABLE_PRINTER_SERVERNAME, signature )
DEFINE( PRINTER_NAME       , TABLE_ATTRIB_COMPACT                                          , TABLE_STRING            , TABLE_STRING            , pName )
DEFINE( SHARE_NAME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pShareName )
DEFINE( PORT_NAME          , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_PRINTER_PORT      , signature )
DEFINE( DRIVER_NAME        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_DRIVER            , pIniDriver )
DEFINE( COMMENT            , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pComment )
DEFINE( LOCATION           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pLocation )
DEFINE( DEVMODE            , TABLE_ATTRIB_COMPACT                                          , TABLE_DEVMODE           , TABLE_DEVMODE           , pDevMode )
DEFINE( SEPFILE            , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pSepFile )
DEFINE( PRINT_PROCESSOR    , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_PRINTPROC         , pIniPrintProc )
DEFINE( PARAMETERS         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pParameters )
DEFINE( DATATYPE           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pDatatype )
DEFINE( SECURITY_DESCRIPTOR, TABLE_ATTRIB_COMPACT                                          , TABLE_SECURITYDESCRIPTOR, TABLE_SECURITYDESCRIPTOR, pSecurityDescriptor )
DEFINE( ATTRIBUTES         , 0                                                             , TABLE_DWORD             , TABLE_DWORD             , Attributes )
DEFINE( PRIORITY           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , Priority )
DEFINE( DEFAULT_PRIORITY   , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , DefaultPriority )
DEFINE( START_TIME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , StartTime )
DEFINE( UNTIL_TIME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , UntilTime )
DEFINE( STATUS             , 0                   |TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_PRINTER_STATUS    , signature )
DEFINE( STATUS_STRING      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_NULLSTRING        , signature )
DEFINE( CJOBS              , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , cJobs )
DEFINE( AVERAGE_PPM        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , AveragePPM )
DEFINE( TOTAL_PAGES        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_ZERO              , signature )
DEFINE( PAGES_PRINTED      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , cTotalPagesPrinted )
DEFINE( TOTAL_BYTES        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_ZERO              , signature )
DEFINE( BYTES_PRINTED      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , cTotalBytes )
DEFINE( OBJECT_GUID        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pszObjectGUID )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inc\splcom.h ===
/*++

Copyright (c) 1990 - 1995  Microsoft Corporation
All rights reserved.

Module Name:

    splcom.h

Abstract:

    Header file for Common Routines in the Spooler.

    Note -- link with spoolss.lib  to find these routines

Author:

    Krishna Ganugapati (KrishnaG) 02-Feb-1994

Revision History:


--*/

#ifndef  _SPLCOM
#define _SPLCOM

#include "spllib.hxx"

//
// Include necessary for PATTRIBUTE_INFO_3, parameter in GetJobAttributes
// which was moved from prtprocs\winprint to spoolss\dll
//
#include <winddiui.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((ULONG_PTR)addr &= ~1))

#define DWORD_ALIGN_UP(size) (((size)+3)&~3)
#define DWORD_ALIGN_DOWN(size) ((size)&~3)

#define ALIGN_UP(addr, type)  ((type) ((ULONG_PTR) (addr) + (sizeof(type) - 1))&~(sizeof(type) - 1))
#define ALIGN_DOWN(addr, type) ((type) ((ULONG_PTR) (addr) & ~(sizeof(type) - 1)))

#define ALIGN_PTR_UP(addr)      ALIGN_UP(addr, ULONG_PTR)
#define ALIGN_PTR_DOWN(addr)    ALIGN_DOWN(addr, ULONG_PTR)

//
// BitMap macros, assumes map is a DWORD array
//
#define MARKUSE(map, pos) ((map)[(pos) / 32] |= (1 << ((pos) % 32) ))
#define MARKOFF(map, pos) ((map)[(pos) / 32] &= ~(1 << ((pos) % 32) ))

#define ISBITON(map, id) ((map)[id / 32] & ( 1 << ((id) % 32) ) )

#define BROADCAST_TYPE_MESSAGE        1
#define BROADCAST_TYPE_CHANGEDEFAULT  2



VOID
UpdatePrinterRegAll(
    LPWSTR pszPrinterName,
    LPWSTR pszPort,
    BOOL bDelete
    );

#define UPDATE_REG_CHANGE FALSE
#define UPDATE_REG_DELETE TRUE

#if defined(_MIPS_)
#define LOCAL_ENVIRONMENT L"Windows NT R4000"
#elif defined(_AXP64_)
#define LOCAL_ENVIRONMENT L"Windows Alpha_AXP64"
#elif defined(_ALPHA_)
#define LOCAL_ENVIRONMENT L"Windows NT Alpha_AXP"
#elif defined(_PPC_)
#define LOCAL_ENVIRONMENT L"Windows NT PowerPC"
#elif defined(_IA64_)
#define LOCAL_ENVIRONMENT L"Windows IA64"
#else
#define LOCAL_ENVIRONMENT L"Windows NT x86"
#endif

#define SPOOLER_VERSION 3
#define NOTIFICATION_VERSION 2
#define DSPRINTQUEUE_VERSION SPOOLER_VERSION

//
// Flags for ResetPrinterEx
//


#define RESET_PRINTER_DATATYPE       0x00000001
#define RESET_PRINTER_DEVMODE        0x00000002

VOID
SplShutDownRouter(
    VOID
    );

PVOID
MIDL_user_allocate1 (
    IN size_t NumBytes
    );


VOID
MIDL_user_free1 (
    IN void *MemPointer
    );


BOOL
BroadcastMessage(
    DWORD   dwType,
    DWORD   dwMessage,
    WPARAM  wParam,
    LPARAM  lParam
    );

VOID
DllSetFailCount(
    DWORD   FailCount
    );

LPVOID
DllAllocSplMem(
    DWORD cb
    );

BOOL
DllFreeSplMem(
   LPVOID pMem
   );

LPVOID
ReallocSplMem(
   LPVOID lpOldMem,
   DWORD cbOld,
   DWORD cbNew
   );


LPWSTR
AllocSplStr(
    LPCWSTR lpStr
    );


BOOL
DllFreeSplStr(
   LPWSTR lpStr
   );

BOOL
ReallocSplStr(
   LPWSTR *plpStr,
   LPCWSTR lpStr
   );

LPVOID
AlignRpcPtr (
    LPVOID  pBuffer,
    LPDWORD pcbBuf
    );

VOID
UndoAlignRpcPtr (
    LPVOID  pBuffer,
    LPVOID  pAligned,
    SIZE_T  cbSize,
    LPDWORD pcbNeeded
    );

VOID
UndoAlignKMPtr (
    LPVOID  pDestination,
    LPVOID  pSource
    );

LPVOID
AlignKMPtr (
    LPVOID  pBuffer,
    DWORD   cbBuf
    );

LPBYTE
PackStrings(
   LPWSTR *pSource,
   LPBYTE pDest,
   DWORD *DestOffsets,
   LPBYTE pEnd
   );

BOOL
IsNamedPipeRpcCall(
    VOID
    );

BOOL
IsLocalCall(
    VOID
    );

HKEY
GetClientUserHandle(
    IN REGSAM samDesired
    );

VOID
UpdatePrinterRegAll(
    LPWSTR pPrinterName,
    LPWSTR pszValue,
    BOOL   bGenerateNetId
    );

DWORD
UpdatePrinterRegUser(
    HKEY hKey,
    LPWSTR pszKey,
    LPWSTR pPrinterName,
    LPWSTR pszValue,
    BOOL   bGenerateNetId
    );

DWORD
GetNetworkId(
    HKEY hKeyUser,
    LPWSTR pDeviceName);

HANDLE
LoadDriverFiletoConvertDevmode(
    IN  LPWSTR      pDriverFile
    );

HANDLE
LoadDriver(
    LPWSTR      pDriverFile
    );

VOID
UnloadDriver(
    HANDLE      hModule
    );

VOID
UnloadDriverFile(
    IN OUT HANDLE    hDevModeChgInfo
    );

BOOL
SplIsUpgrade(
    VOID
    );

BOOL
SpoolerHasInitialized(
    VOID
    );

//
// DWORD used instead of NTSTATUS to prevent including NT headers.
// 
VOID
SplLogEventExternal(
    IN      WORD        EventType,
    IN      DWORD       EventID,
    IN      LPWSTR      pFirstString,
    ...
);

typedef
DWORD
(*PFN_QUERYREMOVE_CALLBACK)(
    LPVOID
    );

HANDLE
SplRegisterForDeviceEvents(
    HANDLE                      hDevice,
    LPVOID                      pData,
    PFN_QUERYREMOVE_CALLBACK    pfnQueryRemove
    );

BOOL
SplUnregisterForDeviceEvents(
    HANDLE  hNotify
    );

DWORD
CallDrvDevModeConversion(
    IN     HANDLE       pfnConvertDevMode,
    IN     LPWSTR       pszPrinterName,
    IN     LPBYTE       pInDevMode,
    IN OUT LPBYTE      *pOutDevMode,
    IN OUT LPDWORD      pdwOutDevModeSize,
    IN     DWORD        dwConvertMode,
    IN     BOOL         bAlloc
    );

typedef struct _pfnWinSpoolDrv {
    BOOL    (*pfnOpenPrinter)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS);
    BOOL    (*pfnClosePrinter)(HANDLE);
    BOOL    (*pfnDevQueryPrint)(HANDLE, LPDEVMODE, DWORD *, LPWSTR, DWORD);
    BOOL    (*pfnPrinterEvent)(LPWSTR, INT, DWORD, LPARAM);
    LONG    (*pfnDocumentProperties)(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODE, DWORD);
    HANDLE  (*pfnLoadPrinterDriver)(HANDLE);
    HANDLE  (*pfnRefCntLoadDriver)(LPWSTR, DWORD, DWORD, BOOL);
    BOOL    (*pfnRefCntUnloadDriver)(HANDLE, BOOL);
    BOOL    (*pfnForceUnloadDriver)(LPWSTR);
}   fnWinSpoolDrv, *pfnWinSpoolDrv;


BOOL
SplInitializeWinSpoolDrv(
    pfnWinSpoolDrv   pfnList
    );

BOOL
GetJobAttributes(
    LPWSTR            pPrinterName,
    LPDEVMODEW        pDevmode,
    PATTRIBUTE_INFO_3 pAttributeInfo
    );

#if 1
#define AllocSplMem( cb )         DllAllocSplMem( cb )
#define FreeSplMem( pMem )        DllFreeSplMem( pMem )
#define FreeSplStr( lpStr )       DllFreeSplStr( lpStr )
#else
#define AllocSplMem( cb )         LocalAlloc( LPTR, cb )
#define FreeSplMem( pMem )        (LocalFree( pMem ) ? FALSE:TRUE)
#define FreeSplStr( lpStr )       ((lpStr) ? (LocalFree(lpStr) ? FALSE:TRUE):TRUE)
#endif


// Spooler treats MAX_PATH as including NULL terminator

#define MAX_PRINTER_NAME    MAX_PATH

// Maximum size PrinterName ( including the ServerName ).
//  "\\MAX_COMPUTER_NAME_LENGTH\MAX_PRINTER_NAME" NULL Terminated
#define MAX_UNC_PRINTER_NAME    ( 2 + INTERNET_MAX_HOST_NAME_LENGTH + 1 + MAX_PRINTER_NAME )

// "\\MAX_PRINTER_NAME,DriverName,Location"
#define MAX_PRINTER_BROWSE_NAME ( MAX_UNC_PRINTER_NAME + 1 + MAX_PATH + 1 + MAX_PATH )

//
// Suffix string for hidden printers
// (e.g., ", Job 00322" or ", Port" or ", LocalOnly")
//
#define PRINTER_NAME_SUFFIX_MAX 20

#define NUMBER_OF_DRV_INFO_6_STRINGS 14

#define MAX_PRINTER_INFO1   ( (MAX_PRINTER_BROWSE_NAME + MAX_UNC_PRINTER_NAME + MAX_PATH) *sizeof(WCHAR) + sizeof( PRINTER_INFO_1) )
#define MAX_DRIVER_INFO_2   ( 5*MAX_PATH*sizeof(WCHAR) + sizeof( DRIVER_INFO_2 ) )
#define MAX_DRIVER_INFO_3   ( 8*MAX_PATH*sizeof(WCHAR) + sizeof( DRIVER_INFO_3 ) )
#define MAX_DRIVER_INFO_6   ( NUMBER_OF_DRV_INFO_6_STRINGS*MAX_PATH*sizeof(WCHAR) + sizeof( DRIVER_INFO_6 ) )
#define MAX_DRIVER_INFO_VERSION  ( NUMBER_OF_DRV_INFO_6_STRINGS*MAX_PATH*sizeof(DRIVER_FILE_INFO)*sizeof(WCHAR) + sizeof( DRIVER_INFO_VERSION ) )


// NT Server Spooler base priority
#define SPOOLSS_SERVER_BASE_PRIORITY        9
#define SPOOLSS_WORKSTATION_BASE_PRIORITY   7

#define MIN_DEVMODE_SIZEW 72
#define MIN_DEVMODE_SIZEA 40

//
// PrinterData value keys for the server handle
//
#define    SPLREG_W3SVCINSTALLED                      TEXT("W3SvcInstalled")


//
// If SPOOLER_REG_SYSTEM is not defined then setup moves the Printers data to
// HKLM\Software\Microsoft\Windows NT\CurrentVersion\Print\Printers during an
// upgrade or clean install. The spooler will then migrate the keys back to
// HKLM\System\CurrentControlSet\Control\Print\Printers when it starts up for 
// the first time.
//
#define    SPOOLER_REG_SYSTEM


//
// Event logging constants
//

#define LOG_ERROR   EVENTLOG_ERROR_TYPE
#define LOG_WARNING EVENTLOG_WARNING_TYPE
#define LOG_INFO    EVENTLOG_INFORMATION_TYPE
#define LOG_SUCCESS EVENTLOG_AUDIT_SUCCESS
#define LOG_FAILURE EVENTLOG_AUDIT_FAILURE

#define LOG_ALL_EVENTS                  ( LOG_ERROR | LOG_WARNING | LOG_INFO | LOG_SUCCESS | LOG_FAILURE )
#define LOG_DEFAULTS_WORKSTATION_EVENTS ( LOG_ERROR | LOG_WARNING | LOG_SUCCESS | LOG_FAILURE )

typedef struct _DRIVER_INFO_7A {
    DWORD   cbSize;
    DWORD   cVersion;
    LPSTR   pszDriverName;
    LPSTR   pszInfName;
    LPSTR   pszInstallSourceRoot;
} DRIVER_INFO_7A, *PDRIVER_INFO_7A, *LPDRIVER_INFO_7A;
typedef struct _DRIVER_INFO_7W {
    DWORD   cbSize;
    DWORD   cVersion;
    LPWSTR  pszDriverName;
    LPWSTR  pszInfName;
    LPWSTR  pszInstallSourceRoot;
} DRIVER_INFO_7W, *PDRIVER_INFO_7W, *LPDRIVER_INFO_7W;
#ifdef UNICODE
typedef DRIVER_INFO_7W DRIVER_INFO_7;
typedef PDRIVER_INFO_7W PDRIVER_INFO_7;
typedef LPDRIVER_INFO_7W LPDRIVER_INFO_7;
#else
typedef DRIVER_INFO_7A DRIVER_INFO_7;
typedef PDRIVER_INFO_7A PDRIVER_INFO_7;
typedef LPDRIVER_INFO_7A LPDRIVER_INFO_7;
#endif // UNICODE

//
// The initial commit for the stack is 3 pages on IA64 and 4 pages on X86
//

//
// This reserves 32KB for in-proc server stack on x86 and 48KB for IA64.
//
#ifdef _IA64_
#define INITIAL_STACK_COMMIT (6 * 0x2000)
#else
#define INITIAL_STACK_COMMIT (8 * 0x1000)
#endif

#define LARGE_INITIAL_STACK_COMMIT (64 * 1024)

#ifdef __cplusplus
}
#endif

#endif  // for #ifndef _SPLCOM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inc\ntfytab.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved

Module Name:

    ntfytab.h

Abstract:

    Table definitions for ntfy*.h.  There must not be any structure
    definitions here since this is included in winspl.idl.  The midl
    compiler generates winspl.h which would include these definions, and
    some files include both ntfytab.h and winspl.h (causing duplicate
    definitions).  This file should hold just #defines.

Author:

    Albert Ting (AlbertT) 04-Oct-94

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef _NTFYTAB_H
#define _NTFYTAB_H

#define TABLE_NULL                0x0
#define TABLE_DWORD               0x1
#define TABLE_STRING              0x2
#define TABLE_DEVMODE             0x3
#define TABLE_TIME                0x4
#define TABLE_SECURITYDESCRIPTOR  0x5
#define TABLE_PRINTPROC           0x6
#define TABLE_DRIVER              0x7

#define TABLE_ZERO                0xf0
#define TABLE_NULLSTRING          0xf1
#define TABLE_SPECIAL             0xff

#define TABLE_JOB_STATUS          0x100
#define TABLE_JOB_POSITION        0x101
#define TABLE_JOB_PRINTERNAME     0x102
#define TABLE_JOB_PORT            0x103

#define TABLE_PRINTER_STATUS      0x200
#define TABLE_PRINTER_DRIVER      0x201
#define TABLE_PRINTER_PORT        0x202
#define TABLE_PRINTER_SERVERNAME  0x203

//
// Must match above #defines (act TABLE_* acts as an index
// to the below array).
//
#define NOTIFY_DATATYPES \
{ \
    0,                     \
    0,                     \
    TABLE_ATTRIB_DATA_PTR, \
    TABLE_ATTRIB_DATA_PTR, \
    TABLE_ATTRIB_DATA_PTR, \
    TABLE_ATTRIB_DATA_PTR, \
    0                      \
}

#define TABLE_ATTRIB_DATA_PTR  0x2


#define INVALID_NOTIFY_FIELD ((WORD)-1)
#define INVALID_NOTIFY_TYPE ((WORD)-1)
//
// index = PRINTER_NOTIFY_TYPE
// value = bytes from PRINTER_NOTIFY_INFO_DATA to actual data.
// (Job has 4 bytes for JobId).
//
//#define NOTIFY_PRINTER_DATA_OFFSETS { 0, 4 }

#define NOTIFY_TYPE_MAX             0x02
#define PRINTER_NOTIFY_NEXT_INFO    0x01

//
// COMPACT   = Data is a DWORD (TABLE_ATTRIB_DATA_PTR must not be set)
//             Router will overwrite and compact old data.
// DISPLAY   = This attribute is displayable in PrintUI
//
#define TABLE_ATTRIB_COMPACT   0x1
#define TABLE_ATTRIB_DISPLAY   0x2


//
// The reply system can support different types of callbacks.
// These types are defined here and are used for RPC marshalling.
//
#define REPLY_PRINTER_CHANGE  0x0


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\clientui\configdlg.cpp ===
/*****************************************************************************\
* MODULE: configdlg.cxx
*
* The module contains routines for handling the authentication dialog
* for internet priting
*
* Copyright (C) 1996-1998 Microsoft Corporation
*
* History:
*   07/31/98 WeihaiC    Created
*   04/10/00 WeihaiC    Moved it to client side
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


TConfigDlg::TConfigDlg (
    LPCWSTR pServerName,
    HWND hWnd,
    LPCWSTR pszPortName):
    TXcvDlg (pServerName, hWnd, pszPortName)
{
}

TConfigDlg::~TConfigDlg ()
{
}

VOID 
TConfigDlg::EnableUserNamePassword (
    HWND hDlg,
    BOOL bEnable)
{
    EnableWindow( GetDlgItem( hDlg, IDC_USER_NAME ), bEnable );
    EnableWindow( GetDlgItem( hDlg, IDC_PASSWORD ), bEnable );
}
    


VOID 
TConfigDlg::DialogOnInit (
    HWND hDlg)
{
    int nIDButton;

    SetDlgItemText (hDlg, IDC_PORT_NAME, (LPTSTR) m_pszPortName);

    switch (m_ConfigurationData.dwAuthMethod) {
    case AUTH_NT:
        nIDButton = IDC_IMPERSONATION;
        break;

    case AUTH_OTHER:
        nIDButton = IDC_SPECFIEDUSER;
        break;

    case AUTH_ANONYMOUS:
        nIDButton = IDC_ANONYMOUS;
        break;

    }

    CheckDlgButton (hDlg, nIDButton, BST_CHECKED);
    EnableUserNamePassword (hDlg, m_ConfigurationData.dwAuthMethod == AUTH_OTHER);

    if (m_ConfigurationData.szUserName[0]) {

        SetDlgItemText (hDlg, IDC_USER_NAME, (LPTSTR) m_ConfigurationData.szUserName);
        SetDlgItemText (hDlg, IDC_PASSWORD, (LPTSTR) TEXT ("***********"));
    }

    SetWindowLongPtr (hDlg, GWLP_USERDATA, (UINT_PTR) this);

    // Disable all user settings for non admins
    EnableWindow( GetDlgItem( hDlg, IDC_CHECK_ALL_USER ), m_bAdmin );
    
}

VOID 
TConfigDlg::DialogOnOK (
    HWND hDlg)
{
    WCHAR szBuffer [MAX_USERNAME_LEN];
    DWORD dwRet = DLG_ERROR;
    BOOL    bChecked;
    
    if (IsDlgButtonChecked (hDlg, IDC_ANONYMOUS)) {
        m_ConfigurationData.dwAuthMethod = AUTH_ANONYMOUS;
    }
    else if (IsDlgButtonChecked (hDlg, IDC_SPECFIEDUSER)) {
        m_ConfigurationData.dwAuthMethod = AUTH_OTHER;
    }
    else
        m_ConfigurationData.dwAuthMethod = AUTH_NT;

    if (m_ConfigurationData.dwAuthMethod == AUTH_OTHER) {

        GetDlgItemText (hDlg, IDC_USER_NAME, m_ConfigurationData.szUserName, MAX_USERNAME_LEN);

        if (SendMessage (GetDlgItem (hDlg, IDC_PASSWORD), EM_GETMODIFY, 0, 0)) {

            m_ConfigurationData.bPasswordChanged = TRUE;
            GetDlgItemText (hDlg, IDC_PASSWORD, m_ConfigurationData.szPassword , MAX_PASSWORD_LEN);
        }
    }

    if (m_bAdmin && IsDlgButtonChecked (hDlg,IDC_CHECK_ALL_USER )) 
        m_ConfigurationData.bSettingForAll = TRUE;
    else
        m_ConfigurationData.bSettingForAll = FALSE;

    dwRet = DLG_OK;

    DBGMSG (DBG_TRACE, ("Call: TConfigDlg::DialogOnOK (%d, User:%ws Password:%ws)\n",
                        m_ConfigurationData.dwAuthMethod, 
                        m_ConfigurationData.szUserName,
                        m_ConfigurationData.szPassword));

    if (!SetConfiguration ()) {
        DisplayLastError (m_hWnd, IDS_CONFIG_ERR);
    }
    else
        EndDialog (hDlg, dwRet);
}


INT_PTR CALLBACK 
TConfigDlg::DialogProc(
    HWND hDlg,        // handle to dialog box
    UINT message,     // message
    WPARAM wParam,    // first message parameter
    LPARAM lParam     // second message parameter
    )
{
    BOOL bRet = FALSE;
    TConfigDlg *pConfigInfo = NULL;

    switch (message) {
    case WM_INITDIALOG:
        if (pConfigInfo = (TConfigDlg *)lParam)
            pConfigInfo->DialogOnInit(hDlg);

        bRet =  TRUE;
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            if (pConfigInfo = (TConfigDlg *) GetWindowLongPtr (hDlg, GWLP_USERDATA))
                pConfigInfo->DialogOnOK (hDlg);
            bRet = TRUE;
            break;

        case IDCANCEL:
            EndDialog (hDlg, DLG_CANCEL);
            bRet = TRUE;
            break;

        case IDC_IMPERSONATION:
        case IDC_ANONYMOUS:
            EnableUserNamePassword (hDlg, FALSE);
            bRet = TRUE;
            break;

        case IDC_SPECFIEDUSER:
            EnableUserNamePassword (hDlg, TRUE);
            bRet = TRUE;
            break;

        }
        break;
    }
    return bRet;
}


BOOL
TConfigDlg::PromptDialog (
    HINSTANCE hInst)
{
    INT_PTR     iResult;
    BOOL bRet = FALSE;;
    
    m_hInst = hInst;

    if (GetConfiguration ()) {
        
        if (m_ConfigurationData.dwAuthMethod == AUTH_ACCESS_DENIED) {
    
            iResult = DialogBoxParam( hInst,
                                      TEXT("AuthDlg"),
                                      m_hWnd,
                                      TConfigDlg::AuthDialogProc,
                                      (LPARAM) this );
    
            if (iResult == DLG_CANCEL) {
                m_dwLE = ERROR_ACCESS_DENIED;
            }
            else
                bRet = iResult == DLG_OK;
        
        }
        else {
    
            iResult = DialogBoxParam( hInst,
                                      TEXT("IDD_CONFIGURE_DLG"),
                                      m_hWnd,
                                      TConfigDlg::DialogProc,
                                      (LPARAM) this );
    
            bRet =   (iResult == DLG_OK || iResult == DLG_CANCEL);
        }
    }
    else {
        DisplayLastError (m_hWnd, IDS_CONFIG_ERR);
        bRet = TRUE;
    }

    return bRet;
}

BOOL
TConfigDlg::SetConfiguration ()
{
    static CONST WCHAR cszSetConfiguration[] = INET_XCV_SET_CONFIGURATION;
    INET_CONFIGUREPORT_RESPDATA RespData;
    DWORD dwStatus;
    DWORD dwNeeded;
    BOOL bRet = FALSE;
    PBYTE pEncryptedData;
    DWORD dwSize;

    if (EncryptData ((PBYTE) &m_ConfigurationData, 
                     sizeof (INET_XCV_CONFIGURATION),
                     (PBYTE *) &pEncryptedData,
                     &dwSize)) {

        if (XcvData (m_hXcvPort, 
                     cszSetConfiguration, 
                     pEncryptedData,
                     dwSize,
                     (PBYTE) &RespData, 
                     sizeof (INET_CONFIGUREPORT_RESPDATA),
                     &dwNeeded,
                     &dwStatus)) {
            if (dwStatus == ERROR_SUCCESS) {
                bRet = TRUE;
            }
            else
                SetLastError (dwStatus);
        }
        else {
            // 
            // The server might be running an old version of inetpp which does not support XcvData
            // We need to fail the call
            //
        }

        LocalFree (pEncryptedData);
    }

    return bRet;
}

BOOL
TConfigDlg::GetConfiguration ()
{
    static CONST WCHAR cszGetConfigration[] = INET_XCV_GET_CONFIGURATION;
    INET_XCV_GETCONFIGURATION_REQ_DATA ReqData;
    DWORD       dwStatus;
    BOOL        bRet                = FALSE;
    DWORD       dwNeeded;
    PBYTE       pEncryptedData      = NULL;
    PBYTE       pConfigData         = NULL;
    DWORD       cbConfigData;
     
    ReqData.dwVersion = 1;
    
    if (XcvData (m_hXcvPort, 
                 cszGetConfigration, 
                 (PBYTE) &ReqData,
                 sizeof (ReqData),
                 NULL,
                 0,
                 &dwNeeded,
                 &dwStatus)) {
         
        if (dwStatus == ERROR_INSUFFICIENT_BUFFER) {

            // Allocate a buffer
            pEncryptedData = new BYTE[dwNeeded];
    
            if (pEncryptedData) {
    
                if (XcvData (m_hXcvPort, 
                             cszGetConfigration, 
                             (PBYTE) &ReqData,
                             sizeof (ReqData),
                             pEncryptedData,
                             dwNeeded,
                             &dwNeeded,
                             &dwStatus) && dwStatus == ERROR_SUCCESS) {
                    //
                    // Great! We've got the encypted configuration data
                    // 
    
                    if (DecryptData (pEncryptedData, dwNeeded, &pConfigData, &cbConfigData)) {
    
                        if (cbConfigData == sizeof (m_ConfigurationData)) {
    
                            CopyMemory (&m_ConfigurationData, pConfigData, cbConfigData);
                            bRet = TRUE;
    
                        }
                        else
                            SetLastError (ERROR_INVALID_PARAMETER);
    
                        LocalFree (pConfigData);
    
                    }
                }
                else {
                    SetLastError (ERROR_INVALID_PARAMETER);
                }
    
                delete [] pEncryptedData;
    
            }
        }
        else 
            SetLastError (dwStatus);

    }
    else
        // 
        // The server might be running an old version of inetpp which does not support XcvData
        // We need to fail the call
        //
        SetLastError (ERROR_NOT_SUPPORTED);


    return bRet;
}


VOID
TConfigDlg::AuthDialogOnInit (HWND hDlg)
{
    SetDlgItemText (hDlg, IDC_PORT_NAME, (LPTSTR) m_pszPortName);

    SetWindowLongPtr (hDlg, GWLP_USERDATA, (UINT_PTR) this);
}

VOID
TConfigDlg::AuthDialogOnOK (HWND hDlg)
{
    m_ConfigurationData.dwAuthMethod = AUTH_OTHER;
    GetDlgItemText (hDlg, IDC_USER_NAME, m_ConfigurationData.szUserName, MAX_USERNAME_LEN);
    
    if (SendMessage (GetDlgItem (hDlg, IDC_PASSWORD), EM_GETMODIFY, 0, 0)) {
        m_ConfigurationData.bPasswordChanged = TRUE;
        GetDlgItemText (hDlg, IDC_PASSWORD, m_ConfigurationData.szPassword , MAX_PASSWORD_LEN);
    }

    DBGMSG (DBG_TRACE, ("Call: TConfigDlg::DialogOnOK (%d, User:%ws Password:%ws)\n",
                        m_ConfigurationData.dwAuthMethod, 
                        m_ConfigurationData.szUserName,
                        m_ConfigurationData.szPassword));


    if (SetConfiguration ()) {
        EndDialog (hDlg, DLG_OK);
    }
    else {
        DisplayLastError (m_hWnd, IDS_AUTH_ERROR);
    }
}

VOID
TConfigDlg::AuthDialogOnCancel (HWND hDlg)
{
    SetLastError (ERROR_ACCESS_DENIED);

    EndDialog (hDlg, DLG_CANCEL);
}

INT_PTR CALLBACK
TConfigDlg::AuthDialogProc(
    HWND hDlg,        // handle to dialog box
    UINT message,     // message
    WPARAM wParam,    // first message parameter
    LPARAM lParam     // second message parameter
    )
{
    TConfigDlg *pAuthInfo = NULL;

    switch (message) {
    case WM_INITDIALOG:
        if (pAuthInfo = (TConfigDlg *)lParam)
            pAuthInfo->AuthDialogOnInit(hDlg);

        return TRUE;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            if (pAuthInfo = (TConfigDlg *) GetWindowLongPtr (hDlg, GWLP_USERDATA))
                pAuthInfo->AuthDialogOnOK (hDlg);
            return TRUE;

        case IDCANCEL:
            if (pAuthInfo = (TConfigDlg *) GetWindowLongPtr (hDlg, GWLP_USERDATA))
                pAuthInfo->AuthDialogOnCancel (hDlg);

            return TRUE;

        default:
            break;
        }
        break;

    default:
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inc\offsets.h ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation
All rights reserved

Module Name:

    offsets.h

Abstract:

    Global structure declarations used by marshalling and string packing code.

Author:

Environment:

    User Mode - Spoolss

Revision History:

Notes: 

--*/

#ifndef _OFFSETS_H
#define _OFFSETS_H

#include "mType.h"

extern DWORD PrinterInfoStressOffsets[];
extern DWORD PrinterInfoStressStrings[];
extern DWORD PrinterInfo4Offsets[];
extern DWORD PrinterInfo4Strings[];
extern DWORD PrinterInfo1Offsets[];
extern DWORD PrinterInfo1Strings[];
extern DWORD PrinterInfo2Offsets[];
extern DWORD PrinterInfo2Strings[];
extern DWORD PrinterInfo3Offsets[];
extern DWORD PrinterInfo3Strings[];
extern DWORD PrinterInfo5Offsets[];
extern DWORD PrinterInfo5Strings[];
extern DWORD PrinterInfo6Offsets[];
extern DWORD PrinterInfo6Strings[];
extern DWORD PrinterInfo7Offsets[];
extern DWORD PrinterInfo7Strings[];
extern DWORD PrinterInfo8Offsets[];
extern DWORD PrinterInfo8Strings[];
extern DWORD PrinterInfo9Offsets[];
extern DWORD PrinterInfo9Strings[];
extern DWORD JobInfo1Offsets[];
extern DWORD JobInfo1Strings[];
extern DWORD JobInfo2Offsets[];
extern DWORD JobInfo2Strings[];
extern DWORD JobInfo3Offsets[];
extern DWORD JobInfo3Strings[];
extern DWORD DriverInfo1Offsets[];
extern DWORD DriverInfo1Strings[];
extern DWORD DriverInfo2Offsets[];
extern DWORD DriverInfo2Strings[];
extern DWORD DriverInfo3Offsets[];
extern DWORD DriverInfo3Strings[];
extern DWORD DriverInfo4Offsets[];
extern DWORD DriverInfo4Strings[];
extern DWORD DriverInfo5Offsets[];
extern DWORD DriverInfo5Strings[];
extern DWORD DriverInfo6Offsets[];
extern DWORD DriverInfoVersionStrings[];


extern DWORD DriverInfo6Strings[];
extern DWORD AddJobOffsets[];
extern DWORD AddJob2Offsets[];
extern DWORD AddJobStrings[];
extern DWORD AddJob2Strings[];
extern DWORD FormInfo1Offsets[];
extern DWORD FormInfo1Strings[];
extern DWORD PortInfo1Offsets[];
extern DWORD PortInfo1Strings[];
extern DWORD PortInfo2Offsets[];
extern DWORD PortInfo2Strings[];
extern DWORD PortInfo3Offsets[];
extern DWORD PrintProcessorInfo1Offsets[];
extern DWORD PrintProcessorInfo1Strings[];
extern DWORD MonitorInfo1Offsets[];
extern DWORD MonitorInfo2Offsets[];
extern DWORD MonitorInfo1Strings[];
extern DWORD MonitorInfo2Strings[];
extern DWORD DocInfo1Offsets[];
extern DWORD DocInfo1Strings[];
extern DWORD ProvidorInfo1Strings[];
extern DWORD ProvidorInfo2Strings[];
extern DWORD DatatypeInfo1Offsets[];
extern DWORD DatatypeInfo1Strings[];
extern DWORD PrinterEnumValuesOffsets[];


extern FieldInfo PrinterInfoStressFields[];
extern FieldInfo PrinterInfo4Fields[];
extern FieldInfo PrinterInfo1Fields[];
extern FieldInfo PrinterInfo2Fields[];
extern FieldInfo PrinterInfo3Fields[];
extern FieldInfo PrinterInfo5Fields[];
extern FieldInfo PrinterInfo6Fields[];
extern FieldInfo PrinterInfo7Fields[];
extern FieldInfo PrinterInfo8Fields[];
extern FieldInfo PrinterInfo9Fields[];
extern FieldInfo JobInfo1Fields[];
extern FieldInfo JobInfo2Fields[];
extern FieldInfo JobInfo3Fields[];
extern FieldInfo DriverInfo1Fields[];
extern FieldInfo DriverInfo2Fields[];
extern FieldInfo DriverInfo3Fields[];
extern FieldInfo DriverInfo4Fields[];
extern FieldInfo DriverInfo5Fields[];
extern FieldInfo DriverInfo6Fields[];
extern FieldInfo DriverInfoVersionFields[];

extern FieldInfo AddJobFields[];
extern FieldInfo AddJob2Fields[];
extern FieldInfo FormInfo1Fields[];
extern FieldInfo PortInfo1Fields[];
extern FieldInfo PortInfo2Fields[];
extern FieldInfo PortInfo3Fields[];
extern FieldInfo PrintProcessorInfo1Fields[];
extern FieldInfo MonitorInfo1Fields[];
extern FieldInfo MonitorInfo2Fields[];
extern FieldInfo DocInfo1Fields[];
extern FieldInfo DatatypeInfo1Fields[];
extern FieldInfo PrinterEnumValuesFields[];


extern FieldInfo PrinterInfoStressFields32[];
extern FieldInfo PrinterInfo4Fields32[];
extern FieldInfo PrinterInfo1Fields32[];
extern FieldInfo PrinterInfo2Fields32[];
extern FieldInfo PrinterInfo3Fields32[];
extern FieldInfo PrinterInfo5Fields32[];
extern FieldInfo PrinterInfo6Fields32[];
extern FieldInfo PrinterInfo7Fields32[];
extern FieldInfo PrinterInfo8Fields32[];
extern FieldInfo PrinterInfo9Fields32[];
extern FieldInfo JobInfo1Fields32[];
extern FieldInfo JobInfo2Fields32[];
extern FieldInfo JobInfo3Fields32[];
extern FieldInfo DriverInfo1Fields32[];
extern FieldInfo DriverInfo2Fields32[];
extern FieldInfo DriverInfo3Fields32[];
extern FieldInfo DriverInfo4Fields32[];
extern FieldInfo DriverInfo5Fields32[];
extern FieldInfo DriverInfo6Fields32[];
extern FieldInfo AddJobFields32[];
extern FieldInfo FormInfo1Fields32[];
extern FieldInfo PortInfo1Fields32[];
extern FieldInfo PortInfo2Fields32[];
extern FieldInfo PortInfo3Fields32[];
extern FieldInfo PrintProcessorInfo1Fields32[];
extern FieldInfo MonitorInfo1Fields32[];
extern FieldInfo MonitorInfo2Fields32[];
extern FieldInfo DocInfo1Fields32[];
extern FieldInfo DatatypeInfo1Fields32[];
extern FieldInfo PrinterEnumValuesFields32[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\clientui\deletedlg.h ===
#ifndef _CDELETEDLG_H
#define _CDELETEDLG_H

#include "inetxcv.h"
#include "xcvdlg.h"

class TDeletePortDlg: public TXcvDlg {

public:
    TDeletePortDlg (
        LPCTSTR pServerName,
        HWND hWnd,
        LPCTSTR pszPortName);

    ~TDeletePortDlg (void);

    virtual BOOL 
    PromptDialog (
        HINSTANCE hInst);

private:

    BOOL 
    GetString (
        LPWSTR lpszBuf, 
        DWORD dwSize,
        UINT iStringID);

    
    BOOL
    DoDeletePort ();

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\clientui\deletedlg.cpp ===
/*****************************************************************************\
* MODULE: configdlg.cxx
*
* The module contains routines for handling the authentication dialog
* for internet priting
*
* Copyright (C) 1996-1998 Microsoft Corporation
*
* History:
*   07/31/98 WeihaiC    Created
*   04/10/00 WeihaiC    Moved it to client side
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

#define MAX_BUF_SIZE 256

TDeletePortDlg::TDeletePortDlg (
    LPCWSTR pServerName,
    HWND hWnd,
    LPCWSTR pszPortName):
    TXcvDlg (pServerName, hWnd, pszPortName)
{
    if (m_bAdmin) {
        m_bValid  = TRUE;
    }
    else {
        m_dwLE = ERROR_ACCESS_DENIED;
        m_bValid = FALSE;
    }

}

TDeletePortDlg::~TDeletePortDlg ()
{
}

BOOL 
TDeletePortDlg::GetString (
    LPWSTR lpszBuf, 
    DWORD dwSize,
    UINT iStringID)
{
    return LoadString(m_hInst, iStringID, lpszBuf, dwSize);
}

BOOL 
TDeletePortDlg::PromptDialog (
    HINSTANCE hInst)
    
{
    BOOL bRet = TRUE;


    m_hInst = hInst;
    if (!DoDeletePort ()) {

        DisplayLastError (m_hWnd, IDS_DELETE_PORT);
        
        //
        // The call actually failed. Since we already displayed the error message
        // we need to disable the popup from printui.
        //
        m_dwLE = ERROR_CANCELLED;
        bRet = FALSE;

    }

    return bRet;

}

BOOL
TDeletePortDlg::DoDeletePort ()
{
    static CONST WCHAR cszDeletePort [] = INET_XCV_DELETE_PORT;
    DWORD dwStatus;
    BOOL bRet = FALSE;
    DWORD dwNeeded;
     
    if (XcvData (m_hXcvPort, 
                 cszDeletePort, 
                 (PBYTE) m_pszPortName,
                 sizeof (WCHAR) * (lstrlen (m_pszPortName) + 1),
                 NULL, 
                 0,
                 &dwNeeded,
                 &dwStatus)) {
         
        if (dwStatus == ERROR_SUCCESS) {
            // The port has been deleted.
            bRet = TRUE;
        }
        else
            SetLastError (dwStatus);
    }
    else
        // 
        // The server might be running an old version of inetpp which does not support XcvData
        // We need to fail the call
        //
        SetLastError (ERROR_NOT_SUPPORTED);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\clientui\configdlg.h ===
#ifndef _CCONFIGDLG_H
#define _CCONFIGDLG_H

#include "inetxcv.h"
#include "xcvdlg.h"

class TConfigDlg: public TXcvDlg {

public:
    TConfigDlg (
        LPCTSTR pServerName,
        HWND hWnd,
        LPCTSTR pszPortName);

    virtual ~TConfigDlg (void);

    virtual BOOL 
    PromptDialog (
        HINSTANCE hInst);

private:
    enum {
        DLG_OK, DLG_CANCEL,  DLG_ERROR
    } DLGRTCODE;

    static INT_PTR CALLBACK 
    DialogProc (
        HWND hDlg,        // handle to dialog box
        UINT message,     // message
        WPARAM wParam,    // first message parameter
        LPARAM lParam);     // second message parameter

    VOID 
    DialogOnInit (
        HWND hDlg);

    VOID 
    DialogOnOK (
        HWND hDlg);

    static INT_PTR CALLBACK 
    AuthDialogProc (
        HWND hDlg,        // handle to dialog box
        UINT message,     // message
        WPARAM wParam,    // first message parameter
        LPARAM lParam);     // second message parameter

    VOID 
    AuthDialogOnInit (
        HWND hDlg);

    VOID 
    AuthDialogOnOK (
        HWND hDlg);

    VOID
    AuthDialogOnCancel (
        HWND hDlg);

    
    BOOL 
    SetConfiguration (VOID);

    BOOL 
    GetConfiguration (VOID);

    static void 
    EnableUserNamePassword (
        HWND hDLg,
        BOOL bEnable);

    INET_XCV_CONFIGURATION m_ConfigurationData;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\clientui\precomp.h ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header file.

    Only place relatively static header files in here.

Environment:

    User Mode -Win32

Revision History:

--*/

#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <stddef.h>
#include <wininet.h>
#include <commctrl.h>

#include <spllib.hxx>
#include <inetlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\clientui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by localui.rc
//
#define DLG_PORTNAME                200
#define IDD_PN_PB_HELP              201
#define IDD_PN_EF_PORTNAME          202

#define DLG_CONFIGURE_LPT           300
#define IDD_CL_EF_TRANSMISSIONRETRY 303
#define IDD_CF_PB_HELP              304


#define IDC_USER_NAME               1000
#define IDC_PASSWORD                1002
#define IDC_EDIT4                   1006
#define IDC_ANONYMOUS               1008
#define IDC_IMPERSONATION           1009
#define IDC_SPECFIEDUSER            1011
#define IDC_CHECK_ALL_USER          1012
#define IDC_PORT_NAME               1013
#define IDS_DELETE_PORT             1014
#define IDS_CONFIG_ERR              1015
#define IDS_ACCESS_DENIED           1016
#define IDS_AUTH_ERROR              1017
#define IDS_INVALID_PRINTER_NAME    1018
#define IDS_INVALID_SETTING         1019
#define IDS_NETWORK_TIMEOUT         1020
#define IDS_INITIALIZATION_ERROR    1021
#define IDS_PORT_DELETED            1022
#define IDC_STATIC                  -1

#define IDI_SECURITY                1101
#define IDI_PRINTER                   1102

#define IDC_DIVIDER5                3573

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        306
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           305
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\clientui\priv.h ===
/*****************************************************************************\
* MODULE: priv.h
*
* Private header for the Internet Print Provider Client
*
*
* Copyright (C) 2000 Microsoft
*
* History:
*   5/12/2000   weihaic     Created
*
\*****************************************************************************/

#include "common.h"
#include "inetxcv.h"

#include "resource.h"
#include "xcvdlg.h"
#include "configdlg.h"
#include "deletedlg.h"

#define MAX_BUF_SIZE 256
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\clientui\inetppui.cpp ===
/*****************************************************************************\
* MODULE: inetppui.cxx
*
* The module contains routines for handling the authentication dialog
* for internet priting
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*   03/31/00  WeihaiC     Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

HINSTANCE ghInst = NULL;

#ifndef MODULE

#define MODULE "INETPPUI: "

#endif


#ifdef DEBUG

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING |DBG_TRACE| DBG_INFO , DBG_ERROR );

#else

MODULE_DEBUG_INIT( DBG_ERROR | DBG_WARNING, DBG_ERROR );

#endif



BOOL
AddPortUI(
    PCWSTR pszServer,
    HWND   hWnd,
    PCWSTR pszMonitorNameIn,
    PWSTR  *ppszPortNameOut
)
{

    BOOL bRet = FALSE;

    DBGMSG (DBG_TRACE, ("Enter AddPortUI\n"));

    SetLastError (ERROR_NOT_SUPPORTED);

    DBGMSG (DBG_TRACE, ("Leave AddPortUI (Ret=%d)\n", bRet));

    return bRet;
}


BOOL
DeletePortUI(
    PCWSTR pServerName,
    HWND   hWnd,
    PCWSTR pPortName
)
{
    BOOL bRet = FALSE;
    DWORD dwLE;

    DBGMSG (DBG_TRACE, ("Enter DeletePortUI\n"));

    {
        TDeletePortDlg Dlg  (pServerName, hWnd, pPortName);

        if (Dlg.bValid()) {
            bRet = Dlg.PromptDialog(ghInst);

            if (!bRet) {
                dwLE = Dlg.dwLastError ();
            }
        }
        else {
            TXcvDlg::DisplayErrorMsg (ghInst, hWnd, IDS_DELETE_PORT, ERROR_DEVICE_REINITIALIZATION_NEEDED);
            bRet = TRUE;
        }
    }

    if (!bRet) {
        SetLastError (dwLE);
    }

    DBGMSG (DBG_TRACE, ("Leave DeletePortUI (Ret=%d)\n", bRet));

    return bRet;
}

BOOL
ConfigurePortUI(
    PCWSTR pServerName,
    HWND   hWnd,
    PCWSTR pPortName
)
{

    DBGMSG (DBG_TRACE, ("Enter ConfigurePortUI\n"));


    BOOL bRet = FALSE;
    DWORD dwLE;

    {
        TConfigDlg Dlg  (pServerName, hWnd, pPortName);

        if (Dlg.bValid()) {
            bRet = Dlg.PromptDialog(ghInst);

            if (!bRet) {
                dwLE = Dlg.dwLastError ();
            }
        }
        else {
            TXcvDlg::DisplayErrorMsg (ghInst, hWnd, IDS_CONFIG_ERR, ERROR_DEVICE_REINITIALIZATION_NEEDED);
            bRet = TRUE;
        }
    }

    if (!bRet) {
        SetLastError (dwLE);
    }

    DBGMSG (DBG_TRACE, ("Leave ConfigurePortUI (Ret=%d)\n", bRet));

    return bRet;
}


//
// Common string definitions
//



DWORD LocalMonDebug;

MONITORUI MonitorUI =
{
    sizeof(MONITORUI),
    AddPortUI,
    ConfigurePortUI,
    DeletePortUI
};

extern "C" {

BOOL    WINAPI
DllMain (
    HINSTANCE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    INITCOMMONCONTROLSEX icc;

    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        ghInst = hModule;

        //
        // Initialize the common controls, needed for fusion applications
        // because standard controls were moved to comctl32.dll
        //
        InitCommonControls();

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_STANDARD_CLASSES;
        InitCommonControlsEx(&icc);

        return TRUE;

    case DLL_PROCESS_DETACH:
        return TRUE;
    }

    UNREFERENCED_PARAMETER( lpRes );
    return TRUE;
}
}



PMONITORUI
InitializePrintMonitorUI(
    VOID
)
{
    return &MonitorUI;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\clientui\xcvdlg.cpp ===
/*****************************************************************************\
* MODULE: configdlg.cxx
*
* The module contains routines for handling the authentication dialog
* for internet priting
*
* Copyright (C) 1996-1998 Microsoft Corporation
*
* History:
*   07/31/98 WeihaiC    Created
*   04/10/00 WeihaiC    Moved it to client side
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


TXcvDlg::TXcvDlg (
    LPCWSTR pServerName,
    HWND hWnd,
    LPCWSTR pszPortName):
    m_pServerName (pServerName),
    m_hWnd (hWnd),
    m_pszPortName (pszPortName),
    m_pXcvName (NULL),
    m_hXcvPort (NULL),
    m_bAdmin (FALSE),
    m_hInst (NULL),
    m_dwLE (ERROR_SUCCESS),
    m_bValid (FALSE)
{
    DWORD cbNeeded, dwStatus;
    PRINTER_DEFAULTS pd = {NULL, NULL,  SERVER_ALL_ACCESS};
    HANDLE hServer;
    BOOL bRet = FALSE;

    if (OpenPrinter (NULL, &hServer, &pd)) {
        ClosePrinter (hServer);
        m_bAdmin = TRUE;
    }

    if (m_pXcvName = ConstructXcvName (m_pServerName,  m_pszPortName, L"XcvPort")) {

        if (OpenPrinter (m_pXcvName, &m_hXcvPort, NULL)) {
            m_bValid = TRUE;
        }
    }

}

TXcvDlg::~TXcvDlg ()
{
    if (m_pXcvName) {
        LocalFree (m_pXcvName);
    }
    if (m_hXcvPort) {
        ClosePrinter (m_hXcvPort);
    }
}


PWSTR
TXcvDlg::ConstructXcvName(
    PCWSTR pServerName,
    PCWSTR pObjectName,
    PCWSTR pObjectType
)
{
    DWORD   cbOutput;
    PWSTR   pOut;

    cbOutput = pServerName ? (wcslen(pServerName) + 2)*sizeof(WCHAR) : sizeof(WCHAR);   /* "\\Server\," */
    cbOutput += (wcslen(pObjectType) + 2)*sizeof(WCHAR);                    /* "\\Server\,XcvPort _" */
    cbOutput += pObjectName ? (wcslen(pObjectName))*sizeof(WCHAR) : 0;      /* "\\Server\,XcvPort Object_" */

    //
    // For some reason, new crashes explorer, so we use LocalAlloc instead - weihaic
    //
    if (pOut = (PWSTR) LocalAlloc (LPTR, sizeof (WCHAR) * cbOutput)) { //new WCHAR [cbOutput]) {

        if (pServerName) {
            wcscpy(pOut,pServerName);
            wcscat(pOut, L"\\");
        }

        wcscat(pOut,L",");
        wcscat(pOut,pObjectType);
        wcscat(pOut,L" ");

        if (pObjectName)
            wcscat(pOut,pObjectName);
    }

    return pOut;
}

VOID
TXcvDlg::DisplayLastError (
    HWND hWnd,
    UINT iTitle)
{
    DisplayErrorMsg (m_hInst, hWnd, iTitle, GetLastError ());
}

VOID
TXcvDlg::DisplayErrorMsg (
    HINSTANCE hInst,
    HWND hWnd,
    UINT iTitle,
    DWORD dwLE)
{

    TCHAR szBuf[MAX_BUF_SIZE];
    TCHAR szMsgBuf[MAX_BUF_SIZE];
    UINT iMsg;
    LPTSTR lpMsgBuf = NULL;
    BOOL bFound = TRUE;

    switch (dwLE) {
    case ERROR_ACCESS_DENIED:
        iMsg = IDS_ACCESS_DENIED;
        break;

    case ERROR_INVALID_NAME:
    case ERROR_INVALID_PRINTER_NAME:
        iMsg = IDS_INVALID_PRINTER_NAME;
        break;

    case ERROR_INTERNET_TIMEOUT:
        iMsg = IDS_NETWORK_TIMEOUT;
        break;

    case ERROR_DEVICE_REINITIALIZATION_NEEDED:
        iMsg = IDS_INITIALIZATION_ERROR;
        break;

    case ERROR_NOT_FOUND:
        iMsg = IDS_PORT_DELETED;
        break;

    default:
        bFound = FALSE;
        break;
    }

    if (LoadString (hInst, iTitle, szBuf, MAX_BUF_SIZE)) {
        if (bFound) {
            if (LoadString (hInst, iMsg, szMsgBuf, MAX_BUF_SIZE))
                MessageBox( hWnd, szMsgBuf, szBuf, MB_OK | MB_ICONERROR);
        }
        else {
            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_FROM_SYSTEM |
                          FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          GetLastError(),
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &lpMsgBuf,
                          0,
                          NULL) && lpMsgBuf) {
                MessageBox( hWnd, (LPCTSTR)lpMsgBuf, szBuf, MB_OK | MB_ICONERROR );

                // Free the buffer.
                LocalFree( lpMsgBuf );
            }
            else {
                //
                // Most likely it is because we've got an error code from wininet, where
                // we can not locate the resource file
                //
                if (LoadString (hInst, IDS_INVALID_SETTING, szMsgBuf, MAX_BUF_SIZE))
                    MessageBox( hWnd, szMsgBuf, szBuf, MB_OK | MB_ICONERROR);

            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\inc\inetlib.h ===
#include "..\lib\encrypt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\inc\common.h ===
/*****************************************************************************\
* MODULE: inetpp.h
*
* Header file for the INETPP provider routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _INETPP_COMMON_H
#define _INETPP_COMMON_H


// Max length for  username & password
//
#define MAX_USERNAME_LEN 256
#define MAX_PASSWORD_LEN 256
#define MAX_PORTNAME_LEN 512

#define AUTH_ANONYMOUS  0
#define AUTH_BASIC      1
#define AUTH_NT         2
#define AUTH_IE         3
#define AUTH_OTHER      4
#define AUTH_ACCESS_DENIED 0x100
#define AUTH_UNKNOWN    0xffff

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\clientui\xcvdlg.h ===
#ifndef _XCVDLG_H
#define _XCVDLG_H

#include "inetxcv.h"

class TXcvDlg {

public:
    TXcvDlg (
        LPCTSTR pServerName,
        HWND hWnd,
        LPCTSTR pszPortName);

    virtual ~TXcvDlg (void);

    inline BOOL
    bValid(VOID) CONST {
        return m_bValid;
    }

    inline DWORD
    dwLastError (VOID) CONST {
        return m_dwLE;
    }
    virtual BOOL
    PromptDialog (
        HINSTANCE   hInst) = 0;

    static VOID
    DisplayErrorMsg (
        HINSTANCE   hInst,
        HWND        hWnd,
        UINT        iTitle,
        DWORD       dwLE);

protected:

    PWSTR
    ConstructXcvName(
        PCWSTR  pServerName,
        PCWSTR  pObjectName,
        PCWSTR  pObjectType);

    VOID
    DisplayLastError (
        HWND    hWnd,
        UINT    iTitle);

private:
    enum {
        DLG_OK, DLG_CANCEL,  DLG_ERROR
    } DLGRTCODE;

protected:
    LPCTSTR     m_pszPortName;
    BOOL        m_bValid;
    HWND        m_hWnd;
    LPTSTR      m_pXcvName;
    HANDLE      m_hXcvPort;
    LPCTSTR     m_pServerName;
    BOOL        m_bAdmin;
    HINSTANCE   m_hInst;
    DWORD       m_dwLE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\inc\inetxcv.h ===
#ifndef _INET_XCV_H
#define _INET_XCV_H


typedef struct INET_CONFIGUREPORT_RESPDATA {
    DWORD dwVersion;
    DWORD dwError;
    DWORD dwErrorStringLen;
    WCHAR dwErrorString[1];
} INET_CONFIGUREPORT_RESPDATA;
typedef INET_CONFIGUREPORT_RESPDATA *PINET_CONFIGUREPORT_RESPDATA;

typedef struct INET_XCV_GETCONFIGURATION_REQ_DATA {
    DWORD dwVersion;
} INET_XCV_GETCONFIGURATION_REQ_DATA;
typedef INET_XCV_GETCONFIGURATION_REQ_DATA *PINET_XCV_GETCONFIGURATION_REQ_DATA;

typedef struct INET_XCV_CONFIGURATION {
    DWORD dwVersion;
    DWORD dwAuthMethod;
    WCHAR szUserName[MAX_USERNAME_LEN];
    WCHAR szPassword[MAX_PASSWORD_LEN];
    BOOL  bIgnoreSecurityDlg;
    BOOL  bSettingForAll;
    BOOL  bPasswordChanged;
} INET_XCV_CONFIGURATION;
typedef INET_XCV_CONFIGURATION *PINET_XCV_CONFIGURATION;

#define INET_XCV_SET_CONFIGURATION  L"SetConfiguration"
#define INET_XCV_GET_CONFIGURATION  L"GetConfiguration"
#define INET_XCV_DELETE_PORT        L"DeletePort"
#define INET_XCV_ADD_PORT           L"AddPort"

#define MAX_INET_XCV_NAME_LEN 256

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\lib\encrypt.cpp ===
/*****************************************************************************\
* MODULE: encrypt.cxx
*
* The module contains routines for encryption and decryption of data
*
* Copyright (C) 1996-1998 Microsoft Corporation
*
* History:
*   05/19/00 WeihaiC    Created
*
\*****************************************************************************/

#include "precomp.h"

//
// The caller needs to call LocalFree to free the output data
//

BOOL
EncryptData (
    PBYTE pDataInput, 
    DWORD cbDataInput, 
    PBYTE *ppDataOutput, 
    PDWORD pcbDataOutput)
{
    BOOL bRet = FALSE;
    DATA_BLOB DataIn;
    DATA_BLOB DataOut;
    
    DataIn.pbData = pDataInput;    
    DataIn.cbData = cbDataInput;
    ZeroMemory (&DataOut, sizeof (DATA_BLOB));
    
    if(CryptProtectData(&DataIn,
                        L"Encrypt",       // A description sting. 
                        NULL,       // Optional entropy not used.
                        NULL,       // Reserved.
                        NULL,       // Do not pass a PromptStruct.
                        0,
                        &DataOut)) {

        bRet = TRUE;
        *ppDataOutput = DataOut.pbData;
        *pcbDataOutput = DataOut.cbData;
    }
    return bRet;
}

BOOL
DecryptData (
    PBYTE pDataInput, 
    DWORD cbDataInput, 
    PBYTE *ppDataOutput, 
    PDWORD pcbDataOutput)
{
    BOOL bRet = FALSE;
    DATA_BLOB DataIn;
    DATA_BLOB DataOut;
    LPWSTR pDataDesp;
    
    DataIn.pbData = pDataInput;    
    DataIn.cbData = cbDataInput;
    ZeroMemory (&DataOut, sizeof (DATA_BLOB));
    
    if(CryptUnprotectData(&DataIn,
                          &pDataDesp,       // A description sting. 
                          NULL,       // Optional entropy not used.
                          NULL,       // Reserved.
                          NULL,       // Do not pass a PromptStruct.
                          0,
                          &DataOut)) {

        bRet = TRUE;
        *ppDataOutput = DataOut.pbData;
        *pcbDataOutput = DataOut.cbData;
        LocalFree (pDataDesp);
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\lib\encrypt.h ===
#ifndef _ENCRYPT_H
#define _ENCRYPT_H

BOOL
EncryptData (
    PBYTE pDataInput, 
    DWORD cbDataInput, 
    PBYTE *ppDataOutput, 
    PDWORD pcbDataOutput);

BOOL
DecryptData (
    PBYTE pDataInput, 
    DWORD cbDataInput, 
    PBYTE *ppDataOutput, 
    PDWORD pcbDataOutput);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\basicsec.h ===
/*****************************************************************************\
* MODULE: basicsec.h
*
* Header file for basic-security.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   24-Aug-1997 HWP-Guys    Created.
*
\*****************************************************************************/

#ifdef NOT_IMPLEMENTED

DWORD AuthenticateUser(
    LPVOID *lppvContext,
    LPTSTR lpszServerName,
    LPTSTR lpszScheme,
    DWORD  dwFlags,
    LPSTR  lpszInBuffer,
    DWORD  dwInBufferLength,
    LPTSTR lpszUserName,
    LPTSTR lpszPassword);

VOID UnloadAuthenticateUser(
    LPVOID *lppvContext,
    LPTSTR lpszServer,
    LPTSTR lpszScheme);

DWORD PreAuthenticateUser(
    LPVOID  *lppvContext,
    LPTSTR  lpszServerName,
    LPTSTR  lpszScheme,
    DWORD   dwFlags,
    LPSTR   lpszInBuffer,
    DWORD   dwInBufferLength,
    LPSTR   lpszOutBuffer,
    LPDWORD lpdwOutBufferLength,
    LPTSTR  lpszUserName,
    LPTSTR  lpszPassword);

BOOL GetTokenHandle(
    PHANDLE phToken)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\lib\precomp.h ===
#include <windows.h>
#include <wincrypt.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\anonycon.cxx ===
/*****************************************************************************\
* MODULE: anonycon.cxx
*
* The module contains class for connections using anonymous account
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   07/31/98    Weihaic     Created
*
\*****************************************************************************/


#include "precomp.h"
#include "priv.h"

CAnonymousConnection::CAnonymousConnection (
    BOOL bSecure,
    INTERNET_PORT nServerPort,
    BOOL bIgnoreSecurityDlg):

    CAnyConnection (bSecure, nServerPort, bIgnoreSecurityDlg, AUTH_ANONYMOUS)
{
}


HINTERNET
CAnonymousConnection::OpenRequest (
    LPTSTR      lpszUrl)
{
    HINTERNET hReq = NULL;

    WIN9X_NEW_ASYNC( pacSync );

    WIN9X_IF_ASYNC ( pacSync ) 
        WIN9X_IF_ASYNC ( pacSync->bValid() ) {
            hReq = InetHttpOpenRequest(m_hConnect,
                                       g_szPOST,
                                       lpszUrl,
                                       g_szHttpVersion,
                                       NULL,
                                       NULL,
                                       INETPP_REQ_FLAGS | INTERNET_FLAG_NO_AUTH | (m_bSecure?INTERNET_FLAG_SECURE:0),
                                       WIN9X_CONTEXT_ASYNC(pacSync));
        } WIN9X_ELSE_ASYNC(delete pacSync);

    
    if ( hReq ) {
        if ( InetInternetSetOption (hReq,
                                    INTERNET_OPTION_USERNAME,
                                    TEXT (""),
                                    1) &&
             InetInternetSetOption (hReq,
                                    INTERNET_OPTION_PASSWORD,
                                    TEXT (""),
                                    1) ) {
        }
        else {
            CloseRequest (hReq); 
            hReq = NULL;
        }
    }

    return hReq;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\anycon.cxx ===
/*****************************************************************************\
* MODULE: anycon.cxx
*
* The module contains the base class for connections
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   07/31/98    Weihaic     Created
*
\*****************************************************************************/


#include "precomp.h"
#include "priv.h"

/******************************************************************************
* Class Data Static Members
*****************************************************************************/
const DWORD CAnyConnection::gm_dwConnectTimeout = 30000;   // Thirty second timeout on connect
const DWORD CAnyConnection::gm_dwSendTimeout    = 30000;   // Thirty timeout on send timeout
const DWORD CAnyConnection::gm_dwReceiveTimeout = 60000;   // Thirty seconds on receive timeout
const DWORD CAnyConnection::gm_dwSendSize       = 0x10000; // We use a 16K sections when sending
                                                           // data through WININET
extern BOOL Ping (LPTSTR pszServerName);

CAnyConnection::CAnyConnection (
    BOOL    bSecure,
    INTERNET_PORT nServerPort,
    BOOL bIgnoreSecurityDlg,
    DWORD dwAuthMethod):

    m_lpszPassword (NULL),
    m_lpszUserName (NULL),
    m_hSession (NULL),
    m_hConnect (NULL),
    m_dwAccessFlag (INTERNET_OPEN_TYPE_PRECONFIG),
    m_bSecure (bSecure),
    m_bShowSecDlg (FALSE),
    m_dwAuthMethod (dwAuthMethod),
    m_bIgnoreSecurityDlg (bIgnoreSecurityDlg),
    m_bValid (FALSE)

{
    if (!nServerPort) {
        if (bSecure) {
            m_nServerPort = INTERNET_DEFAULT_HTTPS_PORT;
        }
        else {
            m_nServerPort = INTERNET_DEFAULT_HTTP_PORT;
        }
    }
    else
        m_nServerPort = nServerPort;


    m_bValid = TRUE;
}

CAnyConnection::~CAnyConnection ()
{
    if (m_hConnect) {
        (void) CAnyConnection::Disconnect ();
    }

    if (m_hSession) {
        (void) CAnyConnection::CloseSession ();
    }
    LocalFree (m_lpszPassword);
    m_lpszPassword = NULL;
    LocalFree (m_lpszUserName);
    m_lpszUserName = NULL;
}

HINTERNET
CAnyConnection::OpenSession ()
{

    m_hSession = InetInternetOpen(g_szUserAgent,
                                  m_dwAccessFlag,
                                  NULL,
                                  NULL,
#ifndef WINNT32
                                  INTERNET_FLAG_ASYNC);
#else
                                  0);
#endif



    if (m_hSession) {  // Set up the callback function if successful


#ifndef WINNT32
        INTERNET_STATUS_CALLBACK dwISC;

        dwISC = InternetSetStatusCallback( m_hSession, CAsyncContext::InternetCallback );

        if (dwISC != NULL) {
            // We do not support chaining down to a previous callback, there should not
            // be one and if it fails it will also be non NULL, Set last error to invalid handle and
            // Clean Up
            SetLastError (ERROR_INVALID_HANDLE);
            goto Cleanup;
        }
#endif

        // Also set an internet connection timeout for the session for when we try the
        // connection, should we do this instead of a ping?
        DWORD dwTimeout = gm_dwConnectTimeout;

        if (!InetInternetSetOption( m_hSession,
                                    INTERNET_OPTION_CONNECT_TIMEOUT,
                                    (LPVOID)&dwTimeout,
                                    sizeof(dwTimeout)
                                  ))
            goto Cleanup;

        // Now set the Send and Receive Timeout values

        dwTimeout = gm_dwSendTimeout;

        if (!InetInternetSetOption( m_hSession,
                                    INTERNET_OPTION_SEND_TIMEOUT,
                                    (LPVOID)&dwTimeout,
                                    sizeof(dwTimeout)
                                  ))
            goto Cleanup;

        dwTimeout = gm_dwReceiveTimeout;

        if (!InetInternetSetOption( m_hSession,
                                    INTERNET_OPTION_RECEIVE_TIMEOUT,
                                    (LPVOID)&dwTimeout,
                                    sizeof(dwTimeout)
                                  ))
            goto Cleanup;
    }

    return m_hSession;

Cleanup:

    if (m_hSession) {
        InetInternetCloseHandle (m_hSession);
        m_hSession = NULL;
    }

    return m_hSession;
}

BOOL CAnyConnection::CloseSession ()
{
    BOOL bRet =  InetInternetCloseHandle (m_hSession);

    m_hSession = NULL;

    return bRet;
}

HINTERNET
CAnyConnection::Connect(
    LPTSTR lpszServerName)
{

    if (m_hSession) {
        // Ping the server if it is in the intranet to make sure that the server is online

        if (lpszServerName &&

            (_tcschr ( lpszServerName, TEXT ('.')) || Ping (lpszServerName) )) {

            m_hConnect = InetInternetConnect(m_hSession,
                                             lpszServerName,
                                             m_nServerPort,
                                             NULL,//m_lpszUserName,
                                             NULL, //m_lpszPassword,
                                             INTERNET_SERVICE_HTTP,
                                             0,
                                             0);
        }
    }

    return m_hConnect;
}

BOOL
CAnyConnection::Disconnect ()
{
    BOOL bRet = InetInternetCloseHandle (m_hConnect);

    m_hConnect = NULL;

    return bRet;
}


HINTERNET
CAnyConnection::OpenRequest (
    LPTSTR      lpszUrl)
{
    HINTERNET hReq = NULL;
    DWORD dwFlags;

    if (m_hConnect) {
        // We need to create an Asynchronous Context for the Rest of the operations to use,
        // passing this in of course makes this request also asynchronous

        WIN9X_NEW_ASYNC( pacSync );

        WIN9X_IF_ASYNC( pacSync )
            WIN9X_IF_ASYNC( pacSync->bValid() ) {
                hReq = InetHttpOpenRequest(m_hConnect,
                                           g_szPOST,
                                           lpszUrl,
                                           g_szHttpVersion,
                                           NULL,
                                           NULL,
                                           INETPP_REQ_FLAGS | (m_bSecure? INTERNET_FLAG_SECURE:0),
                                           WIN9X_CONTEXT_ASYNC(pacSync));

            } WIN9X_ELSE_ASYNC( delete pacSync );

    }
    return hReq;
}

BOOL
CAnyConnection::CloseRequest (HINTERNET hReq)
{   // BUG: We have to close the handle manually, since WININET seems not to be giving us
    // an INTERNET_STATUS_HANDLE_CLOSING message
    BOOL bSuccess;

    WIN9X_GET_ASYNC( pacSync, hReq );

    bSuccess = InetInternetCloseHandle (hReq); // When this handle is closed, the context will be closed

    WIN9X_IF_ASYNC(pacSync) WIN9X_OP_ASYNC(delete pacSync;)

    return bSuccess;
}



BOOL
CAnyConnection::SendRequest(
    HINTERNET      hReq,
    LPCTSTR        lpszHdr,
    DWORD          cbData,
    LPBYTE         pidi)
{
    BOOL        bRet = FALSE;
    CMemStream  *pStream;

    pStream = new CMemStream (pidi, cbData);

    if (pStream && pStream->bValid ()){

        bRet = SendRequest (hReq, lpszHdr, pStream);
    }

    if (pStream) {
        delete pStream;
    }
    return bRet;
}

BOOL CAnyConnection::SendRequest(
    HINTERNET      hReq,
    LPCTSTR        lpszHdr,
    CStream        *pStream)
{
    BOOL  bRet = FALSE;
    DWORD dwStatus;
    DWORD cbStatus = sizeof(dwStatus);
    BOOL  bRetry = FALSE;
    DWORD dwRetryCount = 0;
    BOOL  bShowUI = FALSE;

    DWORD cbData;
    PBYTE pBuf = NULL;
    DWORD cbRead;


    if (!pStream->GetTotalSize (&cbData))
        return FALSE;

    pBuf = new BYTE[gm_dwSendSize];
    if (!pBuf)
        return FALSE;

#define MAX_RETRY 3
    do {
        BOOL bSuccess = FALSE;
        BOOL bLeave;

        WIN9X_GET_ASYNC( pacSync, hReq );

        WIN9X_IF_ASYNC (!pacSync) WIN9X_BREAK_ASYNC(FALSE);

        if (cbData < gm_dwSendSize) {

            if (pStream->Reset() &&
                pStream->Read (pBuf, cbData, &cbRead) && cbRead == cbData) {

                // If what we want to send is small, we send it with HttpSendRequest and not
                // HttpSendRequestEx, this is to wotk around a problem where we get timeouts on
                // receive on very small data transactions
                bSuccess = InetHttpSendRequest(hReq,
                                               lpszHdr,
                                               (lpszHdr ? (DWORD)-1 : 0),
                                               pBuf,
                                               cbData);

                (void) WIN9X_TIMEOUT_ASYNC(pacSync, bSuccess);
            }

        } else {
            do {
                BOOL bSuccessSend;
                // The timeout value for the packets applies for an entire session, so, instead of sending in
                // one chuck, we have to send in smaller chunks
                INTERNET_BUFFERS BufferIn;

                bLeave = TRUE;

                BufferIn.dwStructSize = sizeof( INTERNET_BUFFERS );
                BufferIn.Next = NULL;
                BufferIn.lpcszHeader = lpszHdr;
                if (lpszHdr)
                    BufferIn.dwHeadersLength = sizeof(TCHAR)*lstrlen(lpszHdr);
                else
                    BufferIn.dwHeadersLength = 0;
                BufferIn.dwHeadersTotal = 1;    // There is one header to send
                BufferIn.lpvBuffer = NULL;      // We defer this to the multiple write side
                BufferIn.dwBufferLength = 0;    // The total buffer length
                BufferIn.dwBufferTotal = cbData; // This is the size of the data we are about to send
                BufferIn.dwOffsetLow = 0;       // No offset into the buffers
                BufferIn.dwOffsetHigh = 0;

                // Since we will only ever be sending one request per hReq handle, we can associate
                // the context with all of these operations

                bSuccess = InetHttpSendRequestEx (hReq,
                                                  &BufferIn,
                                                  NULL,
                                                  0,
                                                  WIN9X_CONTEXT_ASYNC(pacSync));

                (void) WIN9X_TIMEOUT_ASYNC(pacSync, bSuccess );

                if (bSuccess) {
                    bSuccess = pStream->Reset();
                }

                DWORD   dwBufPos    = 0;      // This is our current point in the buffer
                DWORD   dwRemaining = cbData;  // These are the number of bytes left to send

                bSuccessSend = bSuccess;

                while (bSuccess && dwRemaining) {  // While we have data to send and the operations are
                                                   // successful
                    DWORD dwWrite = min( dwRemaining, gm_dwSendSize); // The amount to write
                    DWORD dwWritten;               // The amount actually written

                    if (pStream->Read (pBuf, dwWrite, &cbRead) && cbRead == dwWrite) {

                        bSuccess = InetInternetWriteFile (hReq, pBuf, dwWrite, &dwWritten);

                        (void) WIN9X_TIMEOUT_ASYNC(pacSync, bSuccess );  // Wait for the operation to actually happen

                        if (bSuccess) {
                            bSuccess = dwWritten ? TRUE : FALSE;

                            dwRemaining -= dwWritten;            // Remaining amount decreases by this
                            dwBufPos += dwWritten;                // Advance through the buffer

                            if (dwWritten != dwWrite) {
                                // We need to adjust the pointer, since not all the bytes are
                                // successfully sent to the server
                                //
                                bSuccess = pStream->SetPtr (dwBufPos);
                            }
                        }
                    }
                    else
                        bSuccess = FALSE;
                }

                BOOL bEndSuccess = FALSE;

                if (bSuccessSend) {  // We started the request successfully, so we can end it successfully
                   bEndSuccess = InetHttpEndRequest (hReq,
                                                     NULL,
                                                     0,
                                                     WIN9X_CONTEXT_ASYNC(pacSync));

                   (void) WIN9X_TIMEOUT_ASYNC(pacSync, bEndSuccess );
                 }

                if (!bEndSuccess && GetLastError() == ERROR_INTERNET_FORCE_RETRY)
                        bLeave = FALSE;


                bSuccess = bSuccess  && bEndSuccess && bSuccessSend;

            }  while (!bLeave);
        }

        if (bSuccess) {

            if ( InetHttpQueryInfo(hReq,
                                   HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE,
                                   &dwStatus,
                                   &cbStatus,
                                   NULL) ) {
                switch (dwStatus) {
                case HTTP_STATUS_DENIED:
                case HTTP_STATUS_PROXY_AUTH_REQ:
                    SetLastError (ERROR_ACCESS_DENIED);
                    break;
                case HTTP_STATUS_FORBIDDEN:
                    SetLastError (HTTP_STATUS_FORBIDDEN);
                    break;
                case HTTP_STATUS_OK:
                    bRet = TRUE;
                    break;
                case HTTP_STATUS_SERVER_ERROR:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("CAnyConnection::SendRequest : HTTP_STATUS_SERVER_ERROR")));

                    SetLastError (ERROR_INVALID_PRINTER_NAME);
                    break;
                default:

                    if ((dwStatus >= HTTP_STATUS_BAD_REQUEST) &&
                        (dwStatus < HTTP_STATUS_SERVER_ERROR)) {

                        SetLastError(ERROR_INVALID_PRINTER_NAME);

                    } else {

                        // We get some other errors, but don't know how to handle it
                        //
                        DBG_MSG(DBG_LEV_ERROR, (TEXT("CAnyConnection::SendRequest : Unknown Error (%d)"), dwStatus));

                        SetLastError (ERROR_INVALID_HANDLE);
                    }
                    break;
                }
            }
        }
        else {

            if (m_bSecure) {
#if NEVER
                //
                // In the future, we need to change this part to call InternetQueryOption on
                //  INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT
                // and pass it back to the client
                //
                LPTSTR szBuf[1024];
                DWORD dwSize = 1024;

                switch (GetLastError ()) {
                case ERROR_INTERNET_INVALID_CA:
                case ERROR_INTERNET_SEC_CERT_DATE_INVALID:
                case ERROR_INTERNET_SEC_CERT_CN_INVALID:


                    if (InternetQueryOption(hReq,
                                                INTERNET_OPTION_SECURITY_CERTIFICATE,
                                                szBuf, &dwSize)) {


                        DBG_MSG(DBG_LEV_WARN, (TEXT("Cert: %ws\n"), szBuf));


                        break;
                    }
                }
#endif
                DWORD dwFlags = 0;
                DWORD dwRet;

                if (m_bShowSecDlg) {
                    bShowUI = TRUE;
                    dwRet = InetInternetErrorDlg (GetTopWindow (NULL),
                                              hReq,
                                              GetLastError(),
                                              FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS, NULL);

                    if (dwRet == ERROR_SUCCESS || dwRet == ERROR_INTERNET_FORCE_RETRY) {
                        bRetry = TRUE;
                    }
                }
                else {
                    switch (GetLastError ()) {
                    case ERROR_INTERNET_INVALID_CA:
                        dwFlags = SECURITY_FLAG_IGNORE_UNKNOWN_CA;
                        break;
                    default:
                        // All other failure, try to ignore everything and retry
                        dwFlags = SECURITY_FLAG_IGNORE_REVOCATION |
                                  SECURITY_FLAG_IGNORE_UNKNOWN_CA |
                                  SECURITY_FLAG_IGNORE_WRONG_USAGE |
                                  SECURITY_FLAG_IGNORE_CERT_CN_INVALID |
                                  SECURITY_FLAG_IGNORE_CERT_DATE_INVALID|
                                  SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTPS |
                                  SECURITY_FLAG_IGNORE_REDIRECT_TO_HTTP ;
                        break;
                    }

                    if (InetInternetSetOption(hReq,
                                           INTERNET_OPTION_SECURITY_FLAGS,
                                           &dwFlags,
                                           sizeof (DWORD))) {
                        bRetry = TRUE;
                    }
                }
            }
        }
    }
    while (bRetry && ++dwRetryCount < MAX_RETRY);

    if (!bRet && GetLastError () ==  ERROR_INTERNET_LOGIN_FAILURE)
    {
        SetLastError (ERROR_ACCESS_DENIED);
    }

    if (bShowUI) {
        // We only show the dialog once.
        m_bShowSecDlg = FALSE;
    }

    if (pBuf) {
        delete [] pBuf;
    }

    return bRet;
}

BOOL CAnyConnection::ReadFile (
    HINTERNET hReq,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbRd)
{
    BOOL bSuccess;

    bSuccess = InetInternetReadFile(hReq, lpvBuffer, cbBuffer, lpcbRd);

    return WIN9X_WAIT_ASYNC( hReq, bSuccess );
}


BOOL CAnyConnection::SetPassword (
    HINTERNET hReq,
    LPTSTR lpszUserName,
    LPTSTR lpszPassword)
{
    BOOL bRet = FALSE;
    TCHAR szNULL[] = TEXT ("");

    if (!lpszUserName) {
        lpszUserName = szNULL;
    }

    if (!lpszPassword) {
        lpszPassword = szNULL;
    }

    if ( InetInternetSetOption (hReq,
                                INTERNET_OPTION_USERNAME,
                                lpszUserName,
                                (DWORD) (lstrlen(lpszUserName) + 1)) &&
         InetInternetSetOption (hReq,
                                INTERNET_OPTION_PASSWORD,
                                lpszPassword,
                                (DWORD) (lstrlen(lpszPassword) + 1)) ) {
        bRet = TRUE;
    }

    return bRet;
}

BOOL CAnyConnection::GetAuthSchem (
    HINTERNET hReq,
    LPSTR lpszScheme,
    DWORD dwSize)
{
    DWORD dwIndex = 0;

    return InetHttpQueryInfo(hReq, HTTP_QUERY_WWW_AUTHENTICATE, (LPVOID)lpszScheme, &dwSize, &dwIndex);
}

void CAnyConnection::SetShowSecurityDlg (
    BOOL bShowSecDlg)
{
    m_bShowSecDlg = bShowSecDlg;
}


#ifndef WINNT32  // We use asynchronous code in this case
/**********************************************************************************************
** Method       - GetAsyncContext
** Description  - Get the async context from the handle
**********************************************************************************************/
CAnyConnection::CAsyncContext *CAnyConnection::GetAsyncContext( IN HINTERNET hInternet ) {
    CAsyncContext *pacContext;         // This is the context we wish to retrieve

    DWORD dwContextSize = sizeof(pacContext);

    if (InternetQueryOption( hInternet,
                             INTERNET_OPTION_CONTEXT_VALUE,
                             (LPBYTE)&pacContext,
                             &dwContextSize ))
        return pacContext;
    else
        return NULL;
}

/**********************************************************************************************
** Method       - AsynchronousWait
** Description  - This is really a wrapper for the object asynchronous wait, we simply first
**                get the object out of the context before we continue doing anything
**********************************************************************************************/
BOOL CAnyConnection::AsynchronousWait( IN HINTERNET hInternet, IN OUT BOOL &bSuccess) {
    // We get the context value from the internet handle
    CAsyncContext *pacContext;         // This is the context we wish to retrieve

    if (bSuccess) return TRUE;      // Saves having to get the context

    DWORD dwContextSize = sizeof(pacContext);

    if (InternetQueryOption( hInternet,
                             INTERNET_OPTION_CONTEXT_VALUE,
                             (LPBYTE)&pacContext,
                             &dwContextSize ))
        return pacContext->TimeoutWait (bSuccess);
    else
        return bSuccess = FALSE;
}

#endif // #ifndef WINNT32


#ifndef WINNT32
/**********************************************************************************************
** Class Implementation  - CAnyConnection::CAsyncContext
**********************************************************************************************/

/**********************************************************************************************
** Constructor   - CAsyncContext
** Description   - Create the Event Handle, set the point to the CAnyConnection and ensure
**                 that the two return values are correctly set
***********************************************************************************************/
CAnyConnection::CAsyncContext::CAsyncContext(void) :
    m_dwRet (0),
    m_dwError (ERROR_SUCCESS),
    m_hEvent (NULL) {

    // Create an event with no inheritable security, automatic reset semantics, a non-signalled
    // initial state and no name
    m_hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

}

/************************************************************************************************
** Destructor    - CAsyncContext
** Description   - Deallocate the event handle
************************************************************************************************/
CAnyConnection::CAsyncContext::~CAsyncContext() {
    if (m_hEvent) CloseHandle(m_hEvent);
}

/************************************************************************************************
** Method        - TimeoutWait
** Description   - Wait on an event callback if the call was asynchronous, clear the event, the
**                 callback routine does the hard work, this one is for a bool
************************************************************************************************/
BOOL CAnyConnection::CAsyncContext::TimeoutWait(IN OUT BOOL &bSuccess) {
    if (!bSuccess && GetLastError() == ERROR_IO_PENDING) {  // The call was asynchronously deferred
        DWORD dwRet;

        dwRet = WaitForSingleObject( m_hEvent , INFINITE );
            // This is not a real infinite wait since the timeout has been set in WININET
            // The callback will signal us back when it is all done

            // The object was signalled
            // The m_dwRet value will have been set to indicate success or failure
            // if the synchronisation was wrong it will be set to 0, so also a failure
        bSuccess = (BOOL)m_dwRet;

        if (!bSuccess) SetLastError (m_dwError);
                  else SetLastError(ERROR_SUCCESS);

    } else ResetEvent(m_hEvent);
       // Some events are synchronous, but still generate a callback, in this case the callback
       // will be in the same thread and set event, leaving the event open for next time,
       // In either case it is safe to do this, since if there is no callback, there will
       // be no data to pass back and no set event.

    return bSuccess;
}


/************************************************************************************************
** Callback    - InternetCallback
** Description - This handles the callback from the Wininet API, it is responsible for asyncronous
**               handle returns as well as other call returns, it also destructs the context
**               when it is eventually deleted
************************************************************************************************/
void CALLBACK CAnyConnection::CAsyncContext::InternetCallback(
    IN HINTERNET  hInternet,
    IN DWORD_PTR  dwContext,
    IN DWORD      dwInternetStatus,
    IN LPVOID     lpvStatusInformation,
    IN DWORD      dwStatusInformationLength) {

    CAsyncContext *pThis = (CAsyncContext *)dwContext;

    // Regardless of whether we are in a critical failure state or not, we want to delete the
    // context of this handle is closing
    switch(dwInternetStatus) {

#if 0
    // BUG: We do not get this notification from WININET, so we have to do this from outside
    // When this is resolved, this code is much neater

    case INTERNET_STATUS_HANDLE_CLOSING:
        delete pThis;
        break;
#endif // #if 0
    case INTERNET_STATUS_REQUEST_COMPLETE: // The request we sent was successful (or timed
                                           // out)
        pThis->m_dwRet = ((LPINTERNET_ASYNC_RESULT)lpvStatusInformation)->dwResult;
        pThis->m_dwError = ((LPINTERNET_ASYNC_RESULT)lpvStatusInformation)->dwError;
        SetEvent (pThis->m_hEvent);
        break;

    }
}

#endif // #ifndef WINNT32


/************************************************************************************************
** End of File (anycon.cxx)
************************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\basicsec.cxx ===
/*****************************************************************************\
* MODULE: basicsec.c
*
* Security routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifdef NOT_IMPLEMENTED

#include "precomp.h"
#include "priv.h"

// NOTE: Currently, this module is not implemented.  In the future this
//       could be functional, but it's not necessary for this particular
//       implementation.
//
//       30-Oct-1996 : ChrisWil (HWP)
//

/*****************************************************************************\
* AuthenticateUser
*
*
\*****************************************************************************/
DWORD AuthenticateUser(
    LPVOID *lppvContext,
    LPTSTR lpszServerName,
    LPTSTR lpszScheme,
    DWORD  dwFlags,
    LPSTR  lpszInBuffer,
    DWORD  dwInBufferLength,
    LPTSTR lpszUserName,
    LPTSTR lpszPassword)
{
    DBG_MSG(DBG_LEV_WARN, (TEXT("Call: AuthenticateUser: Not Implemented")));

    return ERROR_SUCCESS;
}


/*****************************************************************************\
* UnloadAuthenticateUser
*
*
\*****************************************************************************/
VOID UnloadAuthenticateUser(
    LPVOID *lppvContext,
    LPTSTR lpszServer,
    LPTSTR lpszScheme)
{
    DBG_MSG(DBG_LEV_WARN, (TEXT("Call: AuthenticateUser: Not Implemented")));

    return ERROR_SUCCESS;
}


/*****************************************************************************\
* PreAuthenticateUser
*
*
\*****************************************************************************/
DWORD PreAuthenticateUser(
    LPVOID  *lppvContext,
    LPTSTR  lpszServerName,
    LPTSTR  lpszScheme,
    DWORD   dwFlags,
    LPSTR   lpszInBuffer,
    DWORD   dwInBufferLength,
    LPSTR   lpszOutBuffer,
    LPDWORD lpdwOutBufferLength,
    LPTSTR  lpszUserName,
    LPTSTR  lpszPassword)
{
    DBG_MSG(DBG_LEV_WARN, (TEXT("Call: AuthenticateUser: Not Implemented")));

    return ERROR_SUCCESS;
}


/*****************************************************************************\
* GetTokenHandle
*
* Stolen from windows\base\username.c.  Must close the handle that is
* returned.
*
\*****************************************************************************/

#define GETTOK_FLGS (TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY)

BOOL GetTokenHandle(
    PHANDLE phToken)
{
    if (!OpenThreadToken(GetCurrentThread(), GETTOK_FLGS, TRUE, phToken)) {

        if (GetLastError() == ERROR_NO_TOKEN) {

            // This means we are not impersonating anybody.
            // Instead, lets get the token out of the process.
            //
            if (!OpenProcessToken(GetCurrentProcess(), GETTOK_FLGS, phToken)) {

                return FALSE;
            }

        } else {

            return FALSE;
        }
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\cachemgr.h ===
#ifndef _CACHEMGR_H
#define _CACHEMGR_H

BOOL
InitGetPrinterCache (
    HANDLE hPort);

void
FreeGetPrinterCache (
    HANDLE hPort);

void
InvalidateGetPrinterCache (
    HANDLE hPort);

#if (defined(WINNT32))
void
InvalidateGetPrinterCacheForUser(
    HANDLE hPort,
    HANDLE hUser);
#endif // #if (defined(WINNT32))

BOOL
BeginReadGetPrinterCache (
    HANDLE hPort,
    PPRINTER_INFO_2 *ppinfo2);

void
EndReadGetPrinterCache (
    HANDLE hPort);

BOOL
InitEnumJobsCache (
    HANDLE hPort);

void
FreeEnumJobsCache (
    HANDLE hPort);

BOOL
BeginReadEnumJobsCache (
    HANDLE hPort,
    LPPPJOB_ENUM *ppje);

void
EndReadEnumJobsCache (
    HANDLE hPort);

void
InvalidateEnumJobsCache (
    HANDLE hPort);

#if (defined(WINNT32))
void
InvalidateEnumJobsCacheForUser(
    HANDLE hPort,
    HANDLE hUser);
#endif // #if (defined(WINNT32))

#endif //#ifndef CACHEMGR_H

/**********************************************************************************
** End of File (cachemgr.h)
**********************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\cachemgr.cxx ===
/*****************************************************************************\
* MODULE: cachemgr.cxx
*
* The module contains routines to implement the caching algorithm for
* the printers provider
*
* Purpose:
*
* Description:
*
*   The Caching algorithm operates based on a state machine. There are five
*   states in the cache:
*
*       CACHE_STATE_INIT
*       CACHE_STATE_ACCESSED_VALID,
*       CACHE_STATE_DATA_VALID,
*       CACHE_STATE_ACCESSED_VALID_AGAIN,
*       CACHE_STATE_NOT_ACCESSED_VALID_AGAIN
*
*       CACHE_STATE_INIT is the initial state. Once the first cache hit
*       comes in, the cahce manager calles FetchData to fetch the data
*       and goes into CACHE_STATE_ACCESSED_VALID state.
*
*       In CACHE_STATE_ACCESSED_VALID state, the cache manager waits
*       for the minimum cache timeout and go to CACHE_STATE_DATA_VALID
*
*       In CACHE_STATE_DATA_VALID state, the cache manager waits for
*       another cache hit withing half of the last fetch time.
*
*       If there is a hit during this waiting, the cache manager will go
*       for another fetch and go to CACHE_STATE_ACCESSED_VALID state.
*
*       If there is no hit during the waiting period, the cache manager
*       waits for another timeout or another cache hit.
*
*       If there is no access during the waiting, the cache manager
*       invalidates the cache. Otherwise, the cache manager go out and
*       do anther data fetch and then go to CACHE_STATE_ACCESSED_VALID.
*
*
*
* Copyright (C) 1998-1999 Microsoft Corporation
*
* History:
*     10/16/98 weihaic    Created
*
\*****************************************************************************/
#include "precomp.h"
#include "priv.h"


extern BOOL _ppinfo_net_get_info(
                IN  PCINETMONPORT   pIniPort,
                OUT PPRINTER_INFO_2 *ppInfo,
                OUT LPDWORD         lpBufAllocated,
                IN  ALLOCATORFN     pAllocator);

extern BOOL ppjob_EnumForCache(
                IN  PCINETMONPORT   pIniPort,
                OUT LPPPJOB_ENUM    *ppje);



//  cdwMaxCacheValidTime is the maximum expire time for the current cache
//  Idealy, we should put a large number to increase the effiency of the cache
//  so we choose 30 seconds (30*1000) as the final number. For testing purpose,
//  we put 15 seconds to increase the hit of the fetch data code
//
//  weihaic 10/23/98
//
const DWORD cdwMaxCacheValidTime = 30*1000;      // The cache content will expire after 30 seconds.
const DWORD cdwMinCacheValidTime = 2*1000;       // The cache content will be valid for at least 2 seconds


CacheMgr::CacheMgr ():
    m_dwState (CACHE_STATE_INIT),
    m_pIniPort (NULL),
    m_pData (NULL),
    m_hDataReadyEvent (NULL),
    m_hHitEvent (NULL),
    m_hInvalidateCacheEvent (NULL),
    m_hThread (NULL),
    m_bCacheStopped (FALSE),
    m_bAccessed (FALSE),
    m_bInvalidateFlag (FALSE),
    m_bValid (FALSE)
{
    if ((m_hDataReadyEvent = CreateEvent (NULL, TRUE, FALSE, NULL)) &&
        (m_hHitEvent = CreateEvent (NULL, FALSE, FALSE, NULL)) &&
        (m_hInvalidateCacheEvent = CreateEvent (NULL, FALSE, FALSE, NULL)) )

        m_bValid = TRUE;
}


CacheMgr::~CacheMgr ()
{
}

VOID
CacheMgr::Shutdown ()
{
    CacheRead.Lock ();
    // No more read is possible
    
    m_bCacheStopped = TRUE;
    if (m_hThread) {
    
        SetEvent (m_hInvalidateCacheEvent);
    
        // Wait for another thread to exit
        WaitForSingleObject (m_hThread, INFINITE);
    }
    
    if (m_hDataReadyEvent) {
        CloseHandle (m_hDataReadyEvent);
    }
    
    if (m_hHitEvent) {
        CloseHandle (m_hHitEvent);
    }
    
    if (m_hInvalidateCacheEvent) {
        CloseHandle (m_hInvalidateCacheEvent);
    }
    
    m_bValid = FALSE;
    
    CacheRead.Unlock ();

    delete this;
}

BOOL
CacheMgr::SetupAsyncFetch (
    PCINETMONPORT pIniPort)
{
    BOOL    bRet = FALSE;

    PTHREADCONTEXT pThreadData = new THREADCONTEXT;

    if (pThreadData) {
        pThreadData->pIniPort = pIniPort;
        pThreadData->pCache = this;
         
#ifdef WINNT32
        pThreadData->pSidToken = new CSid;

        if (pThreadData->pSidToken && pThreadData->pSidToken->bValid()) {

            if (m_hThread = CreateThread (NULL, COMMITTED_STACK_SIZE, (LPTHREAD_START_ROUTINE)CacheMgr::WorkingThread,
                                          (PVOID) pThreadData, 0, NULL)) {
                bRet = TRUE;
            }
        }

#else
        // This parameter can not be deleted since CreateThread() in Win9X requires
        // a non-NULL pointer to a DWORD as the last parameter.

        DWORD   dwThreadId;

        if (m_hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)CacheMgr::WorkingThread,
                                      (PVOID) pThreadData, 0, &dwThreadId)) {
            bRet = TRUE;
        }

#endif

        if (!bRet) {
#ifdef WINNT32
            if (pThreadData->pSidToken) {
                delete pThreadData->pSidToken;
            }
#endif

            delete (pThreadData);
        }
    }

    return bRet;
}

VOID
CacheMgr::TransitState (
    PCINETMONPORT pIniPort)
{
    PVOID   pData = NULL;
    DWORD   dwFetchTime = 0;
    CACHESTATE dwState, dwOldState;
    BOOL    bNewData;
    HANDLE  hHandles[2];

    hHandles [0] = m_hHitEvent;
    hHandles [1] = m_hInvalidateCacheEvent;


    dwState = m_dwState;

    do {

        DBGMSGT (DBG_CACHE_TRACE, ( TEXT ("TransitState: current state %d"), m_dwState));

        dwState = m_dwState;
        bNewData = FALSE;
        m_bAccessed = FALSE;

        switch (dwState) {
        case CACHE_STATE_INIT:

            // Clean the data ready event
            ResetEvent (m_hDataReadyEvent);
            
            if (GetFetchTime (pIniPort, &dwFetchTime, &pData)) {
                bNewData = TRUE;
                dwState = CACHE_STATE_ACCESSED_VALID;
            }
            else {
                //Invalid Cache Content
                DBGMSGT (DBG_CACHE_ERROR, ( TEXT ("TransitState: FatalError %d"), GetLastError));

                // Invalidate the cache content, so that when the next get comes, it will
                // get the NULL  pointer.
                pData = NULL;
                bNewData = TRUE;
                dwState = CACHE_STATE_ACCESSED_VALID;
            }

            break;

        case CACHE_STATE_ACCESSED_VALID:

            WaitForSingleObject (m_hInvalidateCacheEvent, cdwMinCacheValidTime);
            dwState = CACHE_STATE_DATA_VALID;

            break;

        case CACHE_STATE_DATA_VALID:


            WaitForSingleObject (m_hInvalidateCacheEvent, dwFetchTime / 2);

            if (m_bAccessed) {
                // The cache has been accessed during the waiting time
                dwState = CACHE_STATE_ACCESSED_VALID_AGAIN;
            }
            else {
                // The cache has not been accessed during the waiting time
                dwState = CACHE_STATE_NOT_ACCESSED_VALID_AGAIN;
            }
            break;

        case CACHE_STATE_ACCESSED_VALID_AGAIN:
            if (GetFetchTime (pIniPort, &dwFetchTime, &pData)) {
                bNewData = TRUE;
                dwState = CACHE_STATE_ACCESSED_VALID;
            }
            else {
                //Invalid Cache Content
                DBGMSGT (DBG_CACHE_ERROR, ( TEXT ("TransitState: FatalError %d"), GetLastError));

                // Invalidate the cache content, so that when the next access to cache comes,
                // it will get a NULL  pointer.
                pData = NULL;
                bNewData = TRUE;
                dwState = CACHE_STATE_ACCESSED_VALID;
            }

            break;

        case CACHE_STATE_NOT_ACCESSED_VALID_AGAIN:

            // This has to be a long wait so that the cache will be valid for an access long after
            // the last fetch happeen


            ResetEvent (m_hHitEvent);

            switch (WaitForMultipleObjects (2, hHandles, FALSE, cdwMaxCacheValidTime ))
            {
            case WAIT_TIMEOUT:
                dwState = CACHE_STATE_INIT;
                break;
            case WAIT_OBJECT_0:
                //Accessed

                if (GetFetchTime (pIniPort, &dwFetchTime, &pData)) {
                    bNewData = TRUE;
                    dwState = CACHE_STATE_ACCESSED_VALID;
                }
                else {
                    //Invalid Cache Content
                    DBGMSGT (DBG_CACHE_ERROR, ( TEXT ("TransitState: FatalError %d"), GetLastError));

                    // Invalidate the cache content, so that when the next access to cache comes,
                    // it will get a NULL  pointer.
                    pData = NULL;
                    bNewData = TRUE;
                    dwState = CACHE_STATE_ACCESSED_VALID;
                }
                break;

            case WAIT_OBJECT_0 + 1:

                dwState = CACHE_STATE_INIT;
                break;

            default:
                // ERROR
                DBGMSGT (DBG_CACHE_ERROR, ( TEXT ("TransitState: WaitForSingleObject FatalError %d"), GetLastError));

                // Invalidate the cache
                dwState = CACHE_STATE_INIT;
                break;

            }
            break;

        default:
            DBGMSGT (DBG_CACHE_ERROR, (TEXT ("AsyncFech: wrong state %d"), m_dwState));
            // Invalidate the cache
            dwState = CACHE_STATE_INIT;
        }

        if (m_bCacheStopped) {
            // Cache is being stopped. Cleanup everything this thread generates
            if (bNewData) {
                FreeBuffer (pIniPort, pData);
            }
            // Since the caching thread is going to abort, so we need to raise 
            // this flag so that the waiting thread can go on.
            SetEvent (m_hDataReadyEvent);
            break;
        }


        dwOldState = m_dwState;
        SetState (pIniPort, dwState, bNewData, pData);

        if (dwOldState == CACHE_STATE_INIT) {
            SetEvent (m_hDataReadyEvent);
        }

        if (m_bInvalidateFlag) {
            // Another thread called invalidate thread and hope get rid of the thread
            m_dwState = CACHE_STATE_INIT;
        }

    } while ( m_dwState != CACHE_STATE_INIT );


    // Terminate the async fetch thread

    HANDLE hThread = m_hThread;
    m_hThread = NULL;
    CloseHandle (hThread);

    DBGMSGT (DBG_CACHE_TRACE, (TEXT ("CacheMgr::TransitState: Async thread quit")));


    return;

}

VOID
CacheMgr::SetState (
    PCINETMONPORT   pIniPort,
    CACHESTATE      dwState,
    BOOL            bNewData,
    PVOID           pNewData)
{
    PVOID pOldData = NULL;

    m_bAccessed = 0;
    if (bNewData) {
        CacheData.Lock ();
        pOldData = m_pData;
        m_pData = pNewData;

        CacheData.Unlock ();
    }

    // This line must be here, since otherwise, the state is updated to the new one
    // but the data are not
    //
    m_dwState = dwState;

    if (pOldData) {
        FreeBuffer (pIniPort, pOldData);
    }

}

VOID
CacheMgr::WorkingThread (
    PTHREADCONTEXT pThreadData)
{
    CacheMgr *pThis = pThreadData->pCache;
    PCINETMONPORT pIniPort = pThreadData->pIniPort;

#ifdef WINNT32

    pThreadData->pSidToken->SetCurrentSid ();
    delete pThreadData->pSidToken;
    pThreadData->pSidToken = NULL;

#endif

    delete pThreadData;

    pThis->TransitState (pIniPort);
}


BOOL
CacheMgr::GetFetchTime (
    PCINETMONPORT   pIniPort,
    LPDWORD         pdwTime,
    PVOID           *ppData)
{
    BOOL bRet = FALSE;
    DWORD dwT0, dwT1;



    dwT0 = GetTickCount();
    if (FetchData (pIniPort, ppData)) {
        bRet = TRUE;
    }
    dwT1 = GetTickCount();
    *pdwTime =  GetTimeDiff (dwT0, dwT1);


    DBGMSGT (DBG_CACHE_TRACE,
             (TEXT ("GetFetchTime: returns %d, timediff=%d ms"),
              bRet, GetTimeDiff (dwT0, dwT1)));

    return bRet;
}

PVOID
CacheMgr::BeginReadCache (
    PCINETMONPORT   pIniPort)
{

    if (m_bValid) {
        CacheRead.Lock ();
        

#ifdef WINNT32
        CUserData CurUser;

        while (TRUE) {
            if (m_dwState == CACHE_STATE_INIT) {

                m_CurUser = CurUser;

                if (!m_hThread) {
                    // If there is no thread running, we need to reset the dataready event

                    ResetEvent (m_hDataReadyEvent);
                }

                if (m_hThread // There is already a thread running
                    || SetupAsyncFetch (pIniPort)) {

                    // We must leave the critical section since it might take forever to
                    // get the information at the first time
                    CacheRead.Unlock ();

                    WaitForSingleObject (m_hDataReadyEvent, INFINITE);

                    CacheRead.Lock ();

                }

                break;
            }
            else {

                if (m_CurUser == CurUser) {
                    if (m_dwState == CACHE_STATE_NOT_ACCESSED_VALID_AGAIN) {
                        SetEvent (m_hHitEvent);
                    }
                    break;
                }
                else {
                    // We must call the internal version of InvalidateCache since
                    // we have to leave the critical section when waiting for the termination
                    // of the working thread.
                    //

                    _InvalidateCache ();
                    // Now, the state becomes CACHE_STATE_INIT
                }
            }
        }

#else

        // Win9X case, no security check

        while (TRUE) {
            if (m_dwState == CACHE_STATE_INIT) {

                if (!m_hThread) {
                    // If there is no thread running, we need to reset the dataready event

                    ResetEvent (m_hDataReadyEvent);
                }
                
                if (m_hThread // There is already a thread running
                    || SetupAsyncFetch (pIniPort)) {

                    // We must leave the critical section since it might take forever to
                    // get the information at the first time
                    CacheRead.Unlock ();

                    WaitForSingleObject (m_hDataReadyEvent, INFINITE);

                    CacheRead.Lock ();

                }

                break;
            }
            else {

                if (m_dwState == CACHE_STATE_NOT_ACCESSED_VALID_AGAIN) {
                    SetEvent (m_hHitEvent);
                }
                break;
            }
        }
#endif



        m_bAccessed = TRUE;

        BOOL bRet = CacheData.Lock ();

        DBGMSGT (DBG_CACHE_TRACE, (TEXT ("CacheData.Lock() = %d"), bRet));


        return m_pData;

    }
    else
        return NULL;
}

VOID
CacheMgr::EndReadCache (VOID)
{

    DBGMSGT (DBG_CACHE_TRACE,
         (TEXT ("CacheMgr::EndReadCache: Entered")));


    if (m_bValid) {

        BOOL bRet = CacheData.Unlock ();

        DBGMSGT (DBG_CACHE_TRACE, (TEXT ("CacheData.Unlock() = %d"), bRet));

        CacheRead.Unlock ();
    }
}

VOID
CacheMgr::_InvalidateCache ()
{

    if (!m_bInvalidateFlag) {
        
        m_bInvalidateFlag = TRUE;

        SetEvent (m_hInvalidateCacheEvent);
    }

    if (m_hThread) {

        CacheRead.Unlock ();
        // We must leave the critical section since we don't know how long it will take for thread to exit

        // Wait for another thread to exit
        WaitForSingleObject (m_hThread, INFINITE);

        CacheRead.Lock ();
        
    }
    
    // Clean up the event
    ResetEvent (m_hInvalidateCacheEvent);
    m_bInvalidateFlag = FALSE;


    DBGMSGT (DBG_CACHE_TRACE, ( TEXT ("CacheMgr::InvalidateCache dwState=%d"), m_dwState));

}

VOID
CacheMgr::InvalidateCache ()
{
    CacheRead.Lock ();

    _InvalidateCache ();

    CacheRead.Unlock ();
}

#if (defined(WINNT32))
VOID
CacheMgr::InvalidateCacheForUser( 
    CLogonUserData *pUser ) 
/*++

Routine Description:
    This routine checks to see whether the given user is currently controlling the cache
    thread. If they are, the thread is terminated.
    
Arguments:
    pUser    - A pointer to the user.
    
Return Value:
    None.

--*/
    {

    CacheRead.Lock();

    if (m_CurUser == *(CUserData *)pUser) // Comparison is valid after caste
        _InvalidateCache ();
    
    CacheRead.Unlock();
}


#endif

inline  DWORD
CacheMgr::GetTimeDiff (
    DWORD   t0,
    DWORD   t1)
{
    if (t1 > t0) {
        return t1 - t0;
    }
    else {
        return DWORD(-1) - t0 + t1;
    }
}

LPVOID CacheMgr::Allocator(
    DWORD cb) 
{
    return new CHAR[cb];
}


GetPrinterCache::GetPrinterCache(
    PCINETMONPORT   pIniPort):
    m_pIniPort (pIniPort)
{
    
}

GetPrinterCache::~GetPrinterCache (
    VOID)
{
    if (m_pData) {
        FreeBuffer (m_pIniPort, m_pData);
    }
}


BOOL
GetPrinterCache::FetchData (
    PCINETMONPORT   pIniPort,
    PVOID           *ppData)
{
    BOOL bRet = FALSE;
    PGETPRINTER_CACHEDATA pCacheData = NULL;

    DBGMSGT (DBG_CACHE_TRACE, (TEXT ("GetPrinterCache::FetchData begins")));
#ifdef DEBUG
    if (0) {
        // Simulate the hanging of the current thread
        // For debugging purpose.
        MessageBox (NULL, TEXT ("GetPrinterCache::FetchData called. Press OK to continue."), TEXT ("ALERT"), MB_OK);
    }
#endif


    if (pCacheData = new GETPRINTER_CACHEDATA) {

        semEnterCrit ();

        pCacheData->bRet = _ppinfo_net_get_info(pIniPort, 
                                                & (pCacheData->pInfo) ,
                                                & (pCacheData->cbSize),
                                                Allocator);
        semLeaveCrit ();

        pCacheData->dwLastError = GetLastError ();

        DBGMSGT (DBG_CACHE_TRACE, (TEXT ("GetPrinterCache::FetchData bRet=%d, err=%d\n"), 
                       pCacheData->bRet, pCacheData->dwLastError ));


        // 
        // We must return TRUE, otherwise PPGetPrinter won't get the correct last error
        // 

        bRet = TRUE; //pCacheData->cbSize != 0;
    }

    if (!bRet) {
        DBGMSGT (DBG_CACHE_TRACE,
                 (TEXT ("GetPrinterCache::FetchData failed, call FreeBuffer (%x, %x)"), pIniPort, pCacheData));
        FreeBuffer (pIniPort, pCacheData);
    }
    else {
        *ppData = pCacheData;
    }

    return bRet;
}

BOOL
GetPrinterCache::FreeBuffer (
    PCINETMONPORT   pIniPort,
    PVOID           pData)
{
    PGETPRINTER_CACHEDATA pCacheData = (PGETPRINTER_CACHEDATA) pData;

    DBGMSGT (DBG_CACHE_TRACE,
             (TEXT ("FreeBuffer(%x, %x)  called"), pIniPort, pCacheData));

    if (pCacheData) {
        if (pCacheData->pInfo) {
            delete [] (PCHAR)(pCacheData->pInfo);
        }
        delete pCacheData;
    }

    return TRUE;
}

BOOL
GetPrinterCache::BeginReadCache (
    PPRINTER_INFO_2 *ppInfo)
{
    BOOL bRet = FALSE;

    if (m_bValid) {

        DBGMSGT (DBG_CACHE_TRACE,
                 (TEXT ("GetPrinterCache::BeginReadCache: Entered")));

        PGETPRINTER_CACHEDATA pData = (PGETPRINTER_CACHEDATA) CacheMgr::BeginReadCache (m_pIniPort);

        if (pData) {
            if (pData->bRet) {
                *ppInfo = pData->pInfo;
                bRet = TRUE;
            }
            else {
                SetLastError (pData->dwLastError);
            }

        }

        if (!bRet && GetLastError () == ERROR_SUCCESS) {

            SetLastError (ERROR_CAN_NOT_COMPLETE);

        }

        DBGMSGT (DBG_CACHE_TRACE,
                 (TEXT ("GetPrinterCache::BeginReadCache: pData = %x, return = %d, lasterror = %d"),
                  pData, bRet, GetLastError ()));
    }
    else {
        SetLastError (ERROR_CAN_NOT_COMPLETE);
    }


    return bRet;


}

EnumJobsCache::EnumJobsCache(
    PCINETMONPORT   pIniPort):
    m_pIniPort (pIniPort)
{
}

EnumJobsCache::~EnumJobsCache (
    VOID)
{
    if (m_pData) {
        FreeBuffer (m_pIniPort, m_pData);
    }
}


BOOL
EnumJobsCache::FetchData (
    PCINETMONPORT   pIniPort,
    PVOID           *ppData)
{
    BOOL bRet = FALSE;
    HANDLE hPort = (HANDLE)pIniPort;
    PENUMJOBS_CACHEDATA pCacheData = NULL;

    DBGMSGT (DBG_CACHE_TRACE, (TEXT ("EnumJobsCache::FetchData begins")));

    if (pCacheData = new ENUMJOBS_CACHEDATA) {

        pCacheData->pje = NULL;

        semEnterCrit ();
        pCacheData->bRet = ppjob_EnumForCache(pIniPort, & (pCacheData->pje));
        pCacheData->dwLastError = GetLastError ();

        DBGMSGT (DBG_CACHE_TRACE, (TEXT ("EnumJobsCache::FetchData bRet=%d, err=%d\n"), 
                                   pCacheData->bRet, pCacheData->dwLastError ));

        if (pCacheData->bRet) {

            if (pCacheData->pje) {
                pCacheData->cbSize = pCacheData->pje->cbSize;
            }
            else {
                pCacheData->cbSize = 0;
            }
        }

        semLeaveCrit ();

        bRet = TRUE;
    }

    if (bRet) {
        *ppData = pCacheData;
    }

    return bRet;
}

BOOL
EnumJobsCache::FreeBuffer (
    PCINETMONPORT   pIniPort,
    PVOID           pData)
{
    PENUMJOBS_CACHEDATA pCacheData = (PENUMJOBS_CACHEDATA) pData;

    if (pCacheData) {
        if (pCacheData->pje) {

            // memFree has access to the global link list, so it is neccesary
            // to run it under critical secion.
            //

            semEnterCrit ();
            memFree(pCacheData->pje, memGetSize(pCacheData->pje));
            semLeaveCrit ();
        }
        delete pCacheData;
    }

    return TRUE;
}

BOOL
EnumJobsCache::BeginReadCache (
    LPPPJOB_ENUM    *ppje)
{
    BOOL bRet = FALSE;

    if (m_bValid) {

        DBGMSGT (DBG_CACHE_TRACE,
                 (TEXT ("EnumJobsCache::BeginReadCache: Entered")));

        PENUMJOBS_CACHEDATA pData = (PENUMJOBS_CACHEDATA) CacheMgr::BeginReadCache (m_pIniPort);


        if (pData) {
            if (pData->bRet) {
                *ppje = pData->pje;
                bRet = TRUE;
            }
            else {
                SetLastError (pData->dwLastError);
            }
        }

        if (!bRet && GetLastError () == ERROR_SUCCESS) {

            SetLastError (ERROR_CAN_NOT_COMPLETE);

        }

        DBGMSGT (DBG_CACHE_TRACE,
                 (TEXT ("EnumJobsCache::BeginReadCache: pData = %x, return = %d, lasterror = %d"),
                  pData, bRet, GetLastError ()));
    }
    else {
        SetLastError (ERROR_CAN_NOT_COMPLETE);
    }

    return bRet;

}

VOID
EnumJobsCache::EndReadCache (
    VOID)
{
    DBGMSGT (DBG_CACHE_TRACE,
             (TEXT ("EnumJobsCache::EndReadCache: Entered")));

    CacheMgr::EndReadCache ();
}

/*********************************************************************************
** End of File (cachemgr.cxx)
*********************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\config.cxx ===
/*****************************************************************************\
* MODULE: config.cxx
*
* The module contains class to manage connection configurations
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*   05/12/00    Weihaic     Created
*
\*****************************************************************************/
#include "precomp.h"
#include "priv.h"

#ifdef WINNT32

CPortConfigData::CPortConfigData():
    m_bValid (TRUE),
    m_pUserName (NULL),
    m_pPassword (NULL),
    m_dwAuthMethod (AUTH_UNKNOWN),
    m_bIgnoreSecurityDlg (FALSE)

{
}

CPortConfigData::CPortConfigData(
    LPCTSTR pUserName,
    LPCTSTR pPassword):
    m_bValid (FALSE),
    m_pUserName (NULL),
    m_pPassword (NULL),
    m_dwAuthMethod (AUTH_UNKNOWN),
    m_bIgnoreSecurityDlg (FALSE)
{
    if (AssignString (m_pUserName, pUserName) &&
        AssignString (m_pPassword, pPassword))
        m_bValid = TRUE;
}

CPortConfigData::~CPortConfigData()
{
    LocalFree (m_pUserName);
    LocalFree (m_pPassword);
}

BOOL
CPortConfigData::SetUserName (
    LPCTSTR pUserName)
{
    BOOL bRet = FALSE;
    if (m_bValid) {
        bRet =  AssignString(m_pUserName, pUserName);
    }
    return bRet;
}

BOOL
CPortConfigData::SetPassword (
        LPCTSTR pPassword)
{
    BOOL bRet = FALSE;
    if (m_bValid) {
        bRet =  AssignString (m_pPassword, pPassword);
    }
    return bRet;
}


BOOL
CPortConfigData::SetAuthMethod (
    DWORD dwAuthMethod)
{
    BOOL bRet = FALSE;
    if (m_bValid) {
        m_dwAuthMethod = dwAuthMethod;
        bRet = TRUE;
    }
    return bRet;
}


extern    HKEY
        GetClientUserHandle(
            IN REGSAM samDesired
    );

CPortConfigDataMgr::CPortConfigDataMgr (
    LPCTSTR pszPortName):
    m_bValid (FALSE),
    m_pszPortName (NULL)
{
    if (AssignString (m_pszPortName, pszPortName)) {
        m_bValid = TRUE;
    }
}

/*++

Routine Description:

    Delete everyone's personal setting for the http printer


Return Value:

--*/
BOOL
CPortConfigDataMgr::DeleteAllSettings (
    VOID)
{
    BOOL bRet = FALSE;
    WCHAR szKey[MAX_PATH];
    DWORD cchKey;
    DWORD i;
    FILETIME ftLastWriteTime;
    DWORD dwError;
    static LPWSTR szDotDefault = L".Default";
    HANDLE      hToken;

    if (hToken = RevertToPrinterSelf()) {


        //
        // Go through all keys and fix them up.
        //
        for (i=0; TRUE; i++) {

            cchKey = COUNTOF(szKey);

            dwError = RegEnumKeyEx(HKEY_USERS,
                                   i,
                                   szKey,
                                   &cchKey,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &ftLastWriteTime);

            if (dwError != ERROR_SUCCESS)
                break;

            if (!_wcsicmp(szKey, szDotDefault) || wcschr(szKey, L'_'))
                continue;

            DeletePerUserSettings (szKey);

        }
        DeletePerPortSettings ();

        bRet = ImpersonatePrinterClient(hToken);
    }
    return bRet;
}


BOOL
CPortConfigDataMgr::GetPortSettings (
    HKEY hkPath,
    CPortConfigData* pConfigData) CONST
{
    LONG  lStat;
    HKEY  hkPortNames;
    HKEY  hkThisPortName;
    BOOL  bRet = FALSE;
    DWORD dwType;
    DWORD dwSize;
    DWORD dwAuthMethod;
    PBYTE pbData;


    // Open registry key for Provider-Name.
    //
    bRet = FALSE;

    lStat = RegOpenKeyEx(hkPath, g_szRegPorts, 0, KEY_READ, &hkPortNames);

    if (lStat == ERROR_SUCCESS) {

        lStat = RegOpenKeyEx(hkPortNames, m_pszPortName, 0, KEY_READ, &hkThisPortName);

        if (lStat == ERROR_SUCCESS) {

            dwType = REG_DWORD;
            dwSize = sizeof (dwAuthMethod);

            lStat = RegQueryValueEx (hkThisPortName, g_szAuthMethod, 0, &dwType, (LPBYTE) &dwAuthMethod, &dwSize);

            if (lStat == ERROR_SUCCESS) {

                switch (dwAuthMethod)
                {
                case AUTH_ANONYMOUS:
                case AUTH_NT:
                case AUTH_OTHER:
                    break;

                default:
                    //
                    //  If the register is messed up because of upgrade,
                    //  we set it to anonymous by default.
                    //
                    dwAuthMethod = AUTH_ANONYMOUS;
                    break;
                }
                pConfigData->SetAuthMethod (dwAuthMethod);

                dwType = REG_SZ;
                dwSize = 0;

                lStat = RegQueryValueEx (hkThisPortName, g_szUserName, 0, &dwType, NULL, &dwSize);

                if (lStat == ERROR_SUCCESS) {
                    pbData = new BYTE [dwSize];

                    lStat = RegQueryValueEx (hkThisPortName, g_szUserName, 0, &dwType, pbData, &dwSize);

                    if (lStat == ERROR_SUCCESS) {
                        pConfigData->SetUserName ( (LPCTSTR) pbData);

                    }
                    if (pbData) {
                        delete [] pbData;
                    }
                }

                dwType = REG_BINARY;
                dwSize = 0;

                lStat = RegQueryValueEx (hkThisPortName, g_szPassword, 0, &dwType, NULL, &dwSize);

                if (lStat == ERROR_SUCCESS) {
                    pbData = new BYTE [dwSize];

                    lStat = RegQueryValueEx (hkThisPortName, g_szPassword, 0, &dwType, pbData, &dwSize);

                    if (lStat == ERROR_SUCCESS) {

                        LPTSTR pPassword;
                        DWORD dwPasswordSize;
                        //
                        // Decrypt the password
                        //

                        if (DecryptData (pbData, dwSize, (PBYTE *) &pPassword, &dwPasswordSize))

                            pConfigData->SetPassword (pPassword);

                    }
                    if (pbData) {
                        delete [] pbData;
                    }
                }

                bRet = TRUE;
            }


            RegCloseKey (hkThisPortName);

        } else {

            SetLastError(lStat);
        }

        RegCloseKey(hkPortNames);

    } else {
        SetLastError(lStat);
    }

    return bRet;

}

BOOL
CPortConfigDataMgr::SetPortSettings (
    HKEY hkPath,
    CPortConfigData &ConfigData)
{
    LONG lStat;
    HKEY hkPortNames;
    HKEY hkThisPortName;
    BOOL bRet = FALSE;

    lStat = RegCreateKeyEx(hkPath,
                           g_szRegPorts,
                           0,
                           NULL,
                           0,
                           KEY_WRITE,
                           NULL,
                           &hkPortNames,
                           NULL);

    if (lStat == ERROR_SUCCESS) {


        lStat = RegCreateKeyEx(hkPortNames,
                               m_pszPortName,
                               0,
                               NULL,
                               0,
                               KEY_WRITE,
                               NULL,
                               &hkThisPortName,
                               NULL);

        if (lStat == ERROR_SUCCESS) {

            DWORD dwAuthMethod = ConfigData.GetAuthMethod ();

            lStat = RegSetValueEx(hkThisPortName,
                                  g_szAuthMethod,
                                  0,
                                  REG_DWORD,
                                  (LPBYTE)&dwAuthMethod,
                                  sizeof (dwAuthMethod));

            bRet = (lStat == ERROR_SUCCESS ? TRUE : FALSE);


            if (lStat == ERROR_SUCCESS) {

                LPCTSTR pUserName = ConfigData.GetUserName ();
                LPCTSTR pPassword = ConfigData.GetPassword ();

                if (pUserName) {

                    lStat = RegSetValueEx(hkThisPortName,
                                          g_szUserName,
                                          0,
                                          REG_SZ,
                                          (LPBYTE) pUserName,
                                          sizeof (TCHAR) * (1 + lstrlen (pUserName)));
                } else
                    lStat = RegDeleteValue (hkThisPortName, g_szUserName);

                if (pPassword) {

                    LPBYTE pEncryptedPassword;
                    DWORD dwEncryptedSize;

                    if (EncryptData ((PBYTE) pPassword,
                                     sizeof (TCHAR) * (lstrlen (pPassword) + 1),
                                     &pEncryptedPassword,
                                     &dwEncryptedSize)) {

                        lStat = RegSetValueEx(hkThisPortName,
                                              g_szPassword,
                                              0,
                                              REG_BINARY,
                                              pEncryptedPassword,
                                              dwEncryptedSize);
                    }
                    else
                        lStat = GetLastError ();

                } else
                    lStat = RegDeleteValue (hkThisPortName, g_szPassword);

                bRet = TRUE;

            }

            RegCloseKey(hkThisPortName);
        }

        RegCloseKey(hkPortNames);

    }

    return bRet;
}

BOOL
CPortConfigDataMgr::SetPerPortSettings (
    CPortConfigData &ConfigData)
{
    LONG lStat;
    HKEY hkPath;
    BOOL bRet = FALSE;
    HANDLE      hToken;

    if (hToken = RevertToPrinterSelf()) {


        lStat = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                               g_szRegProvider,
                               0,
                               NULL,
                               0,
                               KEY_WRITE,
                               NULL,
                               &hkPath,
                               NULL);

        if (lStat == ERROR_SUCCESS) {

            bRet = SetPortSettings (hkPath, ConfigData);

            RegCloseKey (hkPath);

        }


        if (!ImpersonatePrinterClient(hToken))
            bRet = FALSE;
    }


    return bRet;
}

BOOL
CPortConfigDataMgr::SetPerUserSettings (
    CPortConfigData &ConfigData)
{
    LONG lStat;
    HKEY hkPath;
    HKEY hkPortNames;
    HKEY hkCurUser;
    BOOL bRet = FALSE;



    hkCurUser = GetClientUserHandle (KEY_WRITE);

    if (hkCurUser) {

        lStat = RegCreateKeyEx(hkCurUser,
                               g_szPerUserPath,
                               0,
                               NULL,
                               0,
                               KEY_WRITE,
                               NULL,
                               &hkPath,
                               NULL);

        if (lStat == ERROR_SUCCESS) {

            bRet = SetPortSettings (hkPath, ConfigData);

            RegCloseKey (hkPath);
        }

    }

    RegCloseKey (hkCurUser);

    return bRet;

}


BOOL
CPortConfigDataMgr::GetPerPortSettings (
    CPortConfigData* pConfigData) CONST
{
    LONG lStat;
    HKEY hkPath;
    BOOL bRet = FALSE;

    HANDLE      hToken;

    if (hToken = RevertToPrinterSelf()) {


        lStat = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegProvider, 0, KEY_READ, &hkPath);

        if (lStat == ERROR_SUCCESS) {

            bRet = GetPortSettings (hkPath, pConfigData);

            RegCloseKey (hkPath);

        }

        if (!ImpersonatePrinterClient(hToken))
            bRet = FALSE;
    }


    return bRet;
}

BOOL
CPortConfigDataMgr::GetPerUserSettings (
    CPortConfigData* pConfigData) CONST
{
    LONG lStat;
    HKEY hkPath;
    HKEY hkCurUser;
    BOOL bRet = FALSE;

    hkCurUser = GetClientUserHandle (KEY_WRITE);

    if (hkCurUser) {

        lStat = RegOpenKeyEx(hkCurUser, g_szPerUserPath, 0, KEY_READ, &hkPath);

        if (lStat == ERROR_SUCCESS) {

            bRet = GetPortSettings (hkPath, pConfigData);

            RegCloseKey (hkPath);
        }

    }

    RegCloseKey (hkCurUser);

    return bRet;

}

BOOL
CPortConfigDataMgr::GetCurrentSettings (
    CPortConfigData* pConfigData) CONST
{
    BOOL bRet = FALSE;

    bRet = GetPerUserSettings (pConfigData);

    if (!bRet) {
        bRet = GetPerPortSettings (pConfigData);
    }

    return bRet;
}



BOOL
CPortConfigDataMgr::DeleteSettings (
    HKEY hkPath)
{
    LONG lStat;
    HKEY hkPortNames;
    BOOL bRet = FALSE;

    lStat = RegOpenKeyEx(hkPath,
                         g_szRegPorts,
                         0,
                         KEY_ALL_ACCESS,
                         &hkPortNames);

    if (lStat == ERROR_SUCCESS) {

        lStat = RegDeleteKey(hkPortNames,
                             m_pszPortName);

        bRet = (lStat == ERROR_SUCCESS ? TRUE : FALSE);

    } else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("RegOpenKeyEx (%s) failed: Error = %d"), g_szRegPorts, lStat));
    }

    return bRet;
}


BOOL
CPortConfigDataMgr::DeletePerPortSettings (
    VOID)
{
    LONG lStat;
    HKEY hkPath;
    HKEY hkPortNames;
    BOOL bRet = FALSE;

    lStat = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         g_szRegProvider,
                         0,
                         KEY_ALL_ACCESS,
                         &hkPath);

    if (lStat == ERROR_SUCCESS) {

        bRet = DeleteSettings (hkPath);
        RegCloseKey(hkPath);

    } else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("RegOpenKeyEx (%s) failed: Error = %d"), g_szRegProvider, lStat));
    }

    return bRet;

}

BOOL
CPortConfigDataMgr::DeletePerUserSettings (
    LPTSTR pUser)

{
    LONG lStat;
    HKEY hkPath;
    HKEY hkCurUser;
    BOOL bRet = FALSE;

    lStat = RegOpenKeyEx( HKEY_USERS, pUser, 0,KEY_ALL_ACCESS, &hkCurUser);

    if (lStat == ERROR_SUCCESS) {

        lStat = RegOpenKeyEx(hkCurUser, g_szPerUserPath, 0, KEY_ALL_ACCESS, &hkPath);

        if (lStat == ERROR_SUCCESS) {

            bRet = DeleteSettings (hkPath);

            RegCloseKey (hkPath);
        }

        RegCloseKey (hkCurUser);
    }

    return bRet;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\debug.cxx ===
/*****************************************************************************\
* MODULE: debug.c
*
* Debugging routines.  This is only linked in on DEBUG builds.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
#include "precomp.h"
#include "priv.h"

#ifdef DEBUG

//DWORD gdwDbgLevel = DBG_LEV_ALL;

DWORD gdwDbgLevel = DBG_LEV_ERROR | DBG_LEV_FATAL | DBG_CACHE_ERROR;



VOID CDECL DbgMsgOut(
    LPCTSTR lpszMsgFormat,
    ...)
{
    TCHAR szMsgText[DBG_MAX_TEXT];

    wvsprintf(szMsgText,
              lpszMsgFormat,
              (LPSTR)(((LPSTR)(&lpszMsgFormat)) + sizeof(lpszMsgFormat)));

    lstrcat(szMsgText, g_szNewLine);

    OutputDebugString(szMsgText);
}

LPTSTR DbgGetTime (void)
{
    static TCHAR szTime[30];
    SYSTEMTIME curTime;

    GetLocalTime (&curTime);
    wsprintf (szTime, TEXT ("%02d:%02d:%02d.%03d "), curTime.wHour, curTime.wMinute,
              curTime.wSecond, curTime.wMilliseconds);

    return szTime;
}


VOID DbgMsg (LPCTSTR pszFormat, ...)
{
    TCHAR szBuf[1024];
    LPTSTR pBuf;

    va_list vargs;

    va_start( vargs, pszFormat );

    wvsprintf( szBuf, pszFormat, vargs );
    va_end( vargs );

    OutputDebugString (DbgGetTime ());
    OutputDebugString (szBuf);
    OutputDebugString (TEXT ("\n"));


}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\debug.h ===
/*****************************************************************************\
* MODULE: debug.h
*
* Header file for (debug.c).
*
* Double braces are needed for output macros.
*
*     DBGMSG(DBG_LEV_ERROR, ("Error code %d", Error));
*
* This is because we can't use variable parameter lists in macros.
* The statement gets pre-processed to a semi-colon in non-debug mode.
*
* Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
* Setting the flag in the low word causes that level to be printed;
* setting the high word causes a break into the debugger.
* E.g. setting it to 0x00040006 will print out all warning and error
* messages, and break on errors.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
#ifndef _INETPP_DEBUG_H
#define _INETPP_DEBUG_H

#ifdef DEBUG

extern DWORD gdwDbgLevel;


// Maximum size of debug string
//
#define DBG_MAX_TEXT       256


// Debug output levels.  By masking in the various levels, you can receive
// all levels of output.
//
#define DBG_LEV_INFO       0x00000001
#define DBG_LEV_CALLTREE   0x00000002
#define DBG_LEV_WARN       0x00000004
#define DBG_LEV_ERROR      0x00000008
#define DBG_LEV_FATAL      0x00000010
#define DBG_CACHE_TRACE    0x00000020
#define DBG_CACHE_ERROR    0x00000040

#define DBG_LEV_ALL        0x0000007F


// Function prototype for debug-routine (debug.c)
//
VOID CDECL DbgMsgOut(
    LPCTSTR lpszMsgFormat,
    ...);

LPTSTR DbgGetTime (void);


VOID DbgMsg (LPCTSTR pszFormat, ...);


// Handy macros for use throughout the source.
//
#define DBG_BREAKPOINT()          DebugBreak();
#define DBG_MSG(Lev, MsgArgs)     {if (Lev & gdwDbgLevel) {DbgMsgOut MsgArgs;}}
#define DBG_ASSERT(Expr, MsgArgs) {if (!Expr) {DbgMsgOut MsgArgs; DebugBreak();}}
#define DBGMSGT(dwLevel, x) {if (dwLevel & gdwDbgLevel) {DbgMsg x;}}

#else

#define DBG_BREAKPOINT()
#define DBG_MSG(Lev, MsgArgs)
#define DBG_ASSERT(Expr, MsgArgs)
#define DBGMSGT(dwLevel, x)
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\config.h ===
#ifndef INET_CONFIG_DATA_H
#define INET_CONFIG_DATA_H

class CPortConfigData {
public:
    CPortConfigData ();

    CPortConfigData (
        LPCTSTR pUserName, 
        LPCTSTR pPassword);

    ~CPortConfigData ();

    inline BOOL 
    bValid (VOID) CONST {
        return m_bValid;
    }

    inline DWORD 
    GetAuthMethod () CONST {
        return m_dwAuthMethod;
    }

    inline BOOL
    GetIgnoreSecurityDlg () CONST {
        return m_bIgnoreSecurityDlg;
    }

    inline LPCTSTR 
    GetUserName () CONST {
        return m_pUserName;
    };

    inline LPCTSTR 
    GetPassword () CONST {
        return m_pPassword;
    }

    BOOL 
    SetAuthMethod (
        DWORD dwAuthMethod);

    BOOL 
    SetUserName (
        LPCTSTR pUserName);

    BOOL 
    SetPassword (
        LPCTSTR pPassword);

    BOOL
    SetIgnoreSecurityDlg (
        BOOL bIgnoreSecurityDlg) {
        m_bIgnoreSecurityDlg = bIgnoreSecurityDlg;
        return TRUE;
    }
private:
    BOOL    m_bValid;
    LPTSTR  m_pUserName;
    LPTSTR  m_pPassword;
    DWORD   m_dwAuthMethod;
    BOOL    m_bIgnoreSecurityDlg;
};


class CPortConfigDataMgr {
public:
    CPortConfigDataMgr (LPCTSTR pszPortName);
    ~CPortConfigDataMgr ();

    BOOL bValid (VOID) CONST {
        return m_bValid;
    };
    
    BOOL 
    SetPerUserSettings (
        CPortConfigData &ConfigData);

    BOOL 
    SetPerPortSettings (
        CPortConfigData &ConfigData);

    BOOL 
    GetPerPortSettings (
        CPortConfigData* pConfigData) CONST;

    BOOL 
    GetPerUserSettings (
        CPortConfigData* pConfigData) CONST;
        
    BOOL 
    GetCurrentSettings (
        CPortConfigData* pConfigData) CONST;

    BOOL 
    DeleteAllSettings (
        VOID);

private:
    BOOL 
    SetPortSettings (
        HKEY hkPath,
        CPortConfigData &ConfigData);
    
    BOOL 
    GetPortSettings (
        HKEY hkPath,
        CPortConfigData* pConfigData) CONST;

    BOOL
    DeletePerPortSettings (
        VOID);

    BOOL
    DeletePerUserSettings (
        LPTSTR pUser);

    BOOL
    DeleteSettings (
        HKEY hkPath);


    
    BOOL    m_bValid;
    LPTSTR  m_pszPortName;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\iecon.cxx ===
/*****************************************************************************\
* MODULE: iecon.cxx
*
* The module contains class for connections using IE's default configuration
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   07/31/98    Weihaic     Created
*
\*****************************************************************************/


#include "precomp.h"
#include "priv.h"

CIEConnection::CIEConnection (
    BOOL        bSecure,
    INTERNET_PORT nServerPort):
    CAnyConnection (bSecure, nServerPort, FALSE, AUTH_IE)
{
}

BOOL
CIEConnection::SendRequest(
    HINTERNET      hReq,
    LPCTSTR        lpszHdr,
    CStream        *pStream)
{
    static const DWORD dwMaxRetry = 3;

    BOOL    bRet = FALSE;
    DWORD   dwRet;
    DWORD   dwFlags;
    DWORD   i;

    dwFlags = FLAGS_ERROR_UI_FILTER_FOR_ERRORS; //FLAGS_ERROR_UI_FLAGS_NO_UI;

    for (i = 0; i < dwMaxRetry; i++ ) {
        bRet = CAnyConnection::SendRequest (hReq,
                                            lpszHdr,
                                            pStream);

        if (bRet || GetLastError () != ERROR_ACCESS_DENIED) {
            break;
        }


        dwRet = InetInternetErrorDlg(GetDesktopWindow(),
                                     hReq,
                                     ERROR_INTERNET_INCORRECT_PASSWORD ,
                                     dwFlags,
                                     NULL);
        if (dwRet != ERROR_INTERNET_FORCE_RETRY) {

            SetLastError (ERROR_ACCESS_DENIED);
            break;

        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\inetport.cxx ===
/*****************************************************************************\
* MODULE: inetport.cxx
*
* The module contains routines for handling the INETPP functionality.  Use
* of these routines require the locking/unlocking of a critical-section
* to maninpulate the INIMONPORT list.  All internal routines assume the
* crit-sect is locked prior to executing.  CheckMonCrit() is a debugging
* call to verify the monitor-crit-sect is locked.
*
* NOTE: Each of the Inetmon*, InetMonPort calls must be protected by the
*       global-crit-sect.
*       If a new routine is added to this module which is to be called from
*       another module, be sure to include the call to (semCheckCrit), so
*       that the debug-code can catch unprotected access.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*   14-Nov-1997 ChrisWil    Added local-spooling functionality.
*   10-Jul-1998 WeihaiC     Change Authentication Dialog Code
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


CInetMonPort::CInetMonPort (
    LPCTSTR     lpszPortName,
    LPCTSTR     lpszDevDesc,
    PCPORTMGR   pPortMgr):
    m_bValid           (FALSE),
    m_pNext            (NULL),
    m_cRef             (0),
    m_cPrinterRef      (0),
    m_bDeletePending   (FALSE),
    m_lpszHost         (NULL),
    m_lpszShare        (NULL),
    m_pPortMgr         (pPortMgr),
    m_pGetPrinterCache           (NULL),
    m_pEnumJobsCache   (NULL),
    m_bCheckConnection (TRUE),
    m_hTerminateEvent  (NULL),
    m_pjmList          (NULL)

{
    PCINETMONPORT   pIniPort;
    PCINETMONPORT   pPort;
    LPTSTR          lpszHost;
    LPTSTR          lpszShare;
    INTERNET_PORT   iPort;
    BOOL            bSecure;

    // Parse out the host/share.  This call returns allocated
    // string-buffers.  It is our responsibility to free the
    // memory once we're done with it.
    //
    if (utlParseHostShare(lpszPortName, &lpszHost, &lpszShare, &iPort, &bSecure)) {

        // The (lpszDevDesc) could be NULL only if it's PP_REMOTE.
        //
        if (lpszDevDesc && *lpszDevDesc)
            m_lpszDesc = memAllocStr(lpszDevDesc);
        else
            m_lpszDesc = memAllocStr(lpszPortName);

        m_lpszName = memAllocStr (lpszPortName);

        // If succeeded, then continue to initialize the port.
        //
        if (m_lpszDesc && m_lpszName) {

            // Initialize the port-elements.
            //
            m_lpszHost         = lpszHost;
            m_lpszShare        = lpszShare;

            DBG_MSG(DBG_LEV_INFO, (TEXT("Info: _inet_create_port: Host(%s) Share(%s)"), lpszHost, lpszShare));

            m_pGetPrinterCache = new GetPrinterCache (this);
            m_pEnumJobsCache = new EnumJobsCache (this);

            if (m_pGetPrinterCache && m_pEnumJobsCache && m_pGetPrinterCache->bValid() && m_pEnumJobsCache->bValid ()) {
                m_bValid = TRUE;
            }
        }
    }
}


CInetMonPort::~CInetMonPort ()
{
    FreeGetPrinterCache ();
    FreeEnumJobsCache ();

    // Free the entry and all memory allocated on
    // behalf of the entry.
    //
    memFreeStr(m_lpszDesc);
    memFreeStr(m_lpszHost);
    memFreeStr(m_lpszShare);

    // Remove any job-entries.
    //
    pjmDelList(m_pjmList);

    m_pPortMgr->Remove ();
    delete m_pPortMgr;

    if (m_hTerminateEvent)
        CloseHandle (m_hTerminateEvent);
}


VOID
CInetMonPort::IncRef ()
{
    m_cRef++;
}

VOID
CInetMonPort::DecRef ()
{
    m_cRef--;
}

VOID
CInetMonPort::IncPrinterRef ()
{
    m_cPrinterRef++;
}

VOID
CInetMonPort::DecPrinterRef ()
{
    m_cPrinterRef--;
}

/*****************************************************************************\
* _inet_size_entry (Local Routine)
*
* Returns the size of an entry depending upon the print-level.
*
\*****************************************************************************/
DWORD
CInetMonPort::_inet_size_entry(
    DWORD       dwLevel)
{
    DWORD cb;

    switch (dwLevel) {

    case PRINT_LEVEL_1:

        cb = sizeof(PORT_INFO_1) + utlStrSize(m_lpszName);

        break;

    case PRINT_LEVEL_2:

        cb = sizeof(PORT_INFO_2)            +
             utlStrSize(m_lpszName) +
             utlStrSize(m_lpszDesc) +
             utlStrSize(g_szLocalPort);

        break;

    default:

        cb = 0;

        break;
    }

    return cb;
}


/*****************************************************************************\
* _inet_copy_entry (Local Routine)
*
* Returns a copy of the port-entry.
*
\*****************************************************************************/
LPBYTE
CInetMonPort::_inet_copy_entry(
    DWORD       dwLevel,
    LPBYTE      pPortInfo,
    LPBYTE      pEnd)
{
    LPTSTR SourceStrings[sizeof(PORT_INFO_2) / sizeof(LPTSTR)];
    LPTSTR *pSourceStrings=SourceStrings;
    DWORD  *pOffsets;


    static DWORD s_dwPortInfo1Strings[] = {
        offsetof(LPPORT_INFO_1A, pName),
        0xFFFFFFFF
    };

    static DWORD s_dwPortInfo2Strings[] = {
        offsetof(LPPORT_INFO_2A, pPortName),
        offsetof(LPPORT_INFO_2A, pMonitorName),
        offsetof(LPPORT_INFO_2A, pDescription),
        0xFFFFFFFF
    };


    //
    //
    switch (dwLevel) {
    case PORT_LEVEL_1:
        pOffsets = s_dwPortInfo1Strings;
        break;

    case PORT_LEVEL_2:
        pOffsets = s_dwPortInfo2Strings;
        break;

    default:
        return pEnd;
    }


    //
    //
    switch (dwLevel) {

    case PORT_LEVEL_1:
        *pSourceStrings++ = m_lpszName;
        pEnd = utlPackStrings(SourceStrings, pPortInfo, pOffsets, pEnd);
        break;

    case PORT_LEVEL_2:
        *pSourceStrings++ = (LPTSTR)m_lpszName;
        *pSourceStrings++ = (LPTSTR)g_szLocalPort;
        *pSourceStrings++ = (LPTSTR)m_lpszDesc;

#if 0
        ((PPORT_INFO_2)pPortInfo)->fPortType = PORT_TYPE_WRITE | PORT_TYPE_NET_ATTACHED;
#else
        ((PPORT_INFO_2)pPortInfo)->fPortType = PORT_TYPE_WRITE | PORT_TYPE_REDIRECTED;
#endif
        ((PPORT_INFO_2)pPortInfo)->Reserved  = 0;

        pEnd = utlPackStrings(SourceStrings, pPortInfo, pOffsets, pEnd);
        break;
    }

    return pEnd;
}

/*****************************************************************************\
* _inet_req_jobstart (Local Routine)
*
* Performs the job-start request.  This writes out the header info to the
* spool-job.
*
\*****************************************************************************/
BOOL
CInetMonPort::_inet_req_jobstart(
    PIPPREQ_PRTJOB ppj,
    PJOBMAP        pjmJob)
{
    LPBYTE  lpIppHdr;
    REQINFO ri;
    DWORD   cbIppHdr;
    DWORD   dwRet;
    DWORD   cbWr;
    BOOL    bRet = FALSE;


    // Convert the IPPREQ_PRTJOB to a IPP-stream-header.
    //
    ZeroMemory(&ri, sizeof(REQINFO));
    ri.cpReq = CP_UTF8;
    ri.idReq = IPP_REQ_PRINTJOB;

    ri.fReq[0] = IPP_REQALL;
    ri.fReq[1] = IPP_REQALL;

    dwRet = WebIppSndData(IPP_REQ_PRINTJOB,
                          &ri,
                          (LPBYTE)ppj,
                          ppj->cbSize,
                          &lpIppHdr,
                          &cbIppHdr);

    if (dwRet == WEBIPP_OK) {

        bRet = pjmSplWrite(pjmJob, lpIppHdr, cbIppHdr, &cbWr);

        WebIppFreeMem(lpIppHdr);
    }

    return bRet;
}


/*****************************************************************************\
* _inet_IppPrtRsp (Local Routine)
*
* Retrieves a get response from the IPP server.
*
\*****************************************************************************/
BOOL CALLBACK _inet_IppPrtRsp(
    CAnyConnection  *pConnection,
    HINTERNET       hJobReq,
    PCINETMONPORT   pIniPort,
    PJOBMAP         pjmJob)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_JOB lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen(IPP_RET_PRINTJOB)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile (pConnection, hJobReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (bRet = lpRsp->bRet) {

                        // Set the remote-job-id to the job-entry.  This
                        // entry was added at the time the spool-job-file
                        // was created.
                        //
                        semEnterCrit();
                        pjmSetJobRemote(pjmJob, lpRsp->ji.ji2.JobId, lpRsp->ji.ipp.pJobUri);
                        semLeaveCrit();

                    } else {

                        // If the job failed to open on the server, then
                        // we will set the last-error from the server
                        // response.
                        //
                        SetLastError(lpRsp->dwLastError);
                    }

                    WebIppFreeMem(lpRsp);

                    goto EndPrtRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //
                    break;

                default:
                    DBG_MSG(DBG_LEV_ERROR, (TEXT("_inet_IppPrtRsp - Err : Receive Data Error (dwRet=%d, LE=%d)"),
                                             dwRet, WebIppGetError(hIpp)));
                    SetLastError(ERROR_INVALID_DATA);

                    goto EndPrtRsp;
                }

            } else {

                goto EndPrtRsp;
            }
        }

EndPrtRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* InetmonSendReq
*
*
\*****************************************************************************/
BOOL
CInetMonPort::SendReq(
    LPBYTE     lpIpp,
    DWORD      cbIpp,
    IPPRSPPROC pfnRsp,
    LPARAM     lParam,
    BOOL       bLeaveCrit)
{
    BOOL        bRet = FALSE;

    CMemStream  *pStream;

    pStream = new CMemStream (lpIpp, cbIpp);

    if (pStream && pStream->bValid ()){

        bRet = SendReq (pStream, pfnRsp, lParam, bLeaveCrit);
    }

    if (pStream) {
        delete pStream;
    }
    return bRet;
}

BOOL
CInetMonPort::SendReq(
    CStream    *pStream,
    IPPRSPPROC pfnRsp,
    LPARAM     lParam,
    BOOL       bLeaveCrit)
{
    DWORD       dwLE = ERROR_SUCCESS;
    BOOL        bRet = FALSE;

    semCheckCrit();

    if (bLeaveCrit)
        //
        // We must increaset the port ref count to make sure the
        // port is not deleted.
        //
        semSafeLeaveCrit(this);

    bRet = m_pPortMgr->SendRequest (this, pStream, pfnRsp, lParam);

    dwLE = GetLastError();

    if (bLeaveCrit)
        semSafeEnterCrit(this);

    if (!bRet) {
        // Need to check connection next time
        m_bCheckConnection = TRUE;
    }

    if ((bRet == FALSE) && (dwLE != ERROR_SUCCESS))
        SetLastError(dwLE);

    return bRet;
}

/*****************************************************************************\
* InetmonClosePort
*
* Close the internet connection.
*
\*****************************************************************************/
BOOL
CInetMonPort::ClosePort(
    HANDLE hPrinter)
{
#ifdef WINNT32
    CLogonUserData* pUser = NULL;

#endif

    semCheckCrit();


#ifdef WINNT32
    // Now see if this is the last port handle that a user is closing
    if (hPrinter != NULL) { // This means we couldn't create the printer handle and
                            // had to close the port
        pUser = m_pPortMgr->GetUserIfLastDecRef (((LPINET_HPRINTER)hPrinter)->hUser);


        if (pUser) {
            // We need to stop the Cache Manager thread if the same user owns it
            DBG_MSG(DBG_LEV_INFO, (TEXT("Info: Last User Close Printer %p."), pUser));

            InvalidateGetPrinterCacheForUser(pUser );
            InvalidateEnumJobsCacheForUser(pUser );

            semLeaveCrit ();

            //
            // In some cases, wininet takes a long time to clean up the
            // browser session, so we have to leave the CS when making
            // InternetSetOption calls to wininet
            //

            EndBrowserSession ();

            semEnterCrit ();

            delete ( pUser );
        }

    }

#endif  // #if defined(WINNT32)

    //
    // We stop decrease the ref count since we don't increase the
    // refcount at Open
    //

    DecPrinterRef();

    return TRUE;
}

/*****************************************************************************\
* InetmonStartDocPort
*
* Start the beginning of a StartDoc call.
*
\*****************************************************************************/
BOOL
CInetMonPort::StartDocPort(
    DWORD   dwLevel,
    LPBYTE  pDocInfo,
    PJOBMAP pjmJob)
{
    LPTSTR         lpszUser;
    PIPPREQ_PRTJOB ppj;
    BOOL           bRet = FALSE;
    DWORD          dwLE;

    semCheckCrit();

    // We are going to hit the network, so leave the critical section
    // To make sure the port will not be deleted, we increase the
    // ref count
    //
    semSafeLeaveCrit(this);

    bRet = m_pPortMgr->CheckConnection();

    dwLE = GetLastError();

    semSafeEnterCrit(this);

    if (bRet) {

        // Reset the value
        bRet = FALSE;


        // Get the username.
        //
        if (lpszUser = GetUserName()) {

            // Build a IPP_PRTJOB_REQ struct.  This routine assures that
            // all strings are in Ascii format.
            //
            ppj = WebIppCreatePrtJobReq(FALSE,
                                        lpszUser,
                                        ((PDOC_INFO_2)pDocInfo)->pDocName,
                                        m_lpszName);

            if (ppj) {

                // Start the job.  This writes out header info to the
                // spool-file.
                //
                bRet = _inet_req_jobstart(ppj, pjmJob);

                WebIppFreeMem(ppj);
            }

            memFreeStr(lpszUser);
        }

    } else {

        m_bCheckConnection = FALSE;
        SetLastError (dwLE);
    }

    if (bRet == FALSE) {
        DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : InetmonStartDocPort:  Failed %d"), GetLastError()));
    }

    return bRet;
}


/*****************************************************************************\
* InetmonEndDocPort
*
* Signify the end of writing to a port.  This is called after StartDocPort.
*
\*****************************************************************************/
BOOL
CInetMonPort::EndDocPort(
    PJOBMAP pjmJob)
{
    BOOL        bRet = FALSE;
    CFileStream *pStream = NULL;

    semCheckCrit();

    if (pStream = pjmSplLock(pjmJob)) {

        bRet = SendReq(pStream, (IPPRSPPROC)_inet_IppPrtRsp, (LPARAM)pjmJob, TRUE);

        pjmSplUnlock(pjmJob);
    }

    return bRet;
}


/*****************************************************************************\
* InetmonWritePort
*
* Write bytes to the port.  This goes to the spool-file until the
* InetmonEndDocPort() is called.
*
\*****************************************************************************/
BOOL
CInetMonPort::WritePort(
    PJOBMAP pjmJob,
    LPBYTE  lpData,
    DWORD   cbData,
    LPDWORD pcbWr)
{
    BOOL bRet;

    semCheckCrit();

    bRet = pjmSplWrite(pjmJob, lpData, cbData, pcbWr);

    return bRet;
}


/*****************************************************************************\
* InetmonAbortPort
*
* Aborts our print-spooling process.
*
\*****************************************************************************/
BOOL
CInetMonPort::AbortPort(
    PJOBMAP pjmJob)
{
    semCheckCrit();

    return TRUE; //(_inet_validate_port(hPort) ? TRUE : FALSE);
}


/*****************************************************************************\
* InetmonGetPortName
*
* Return the name of the port.
*
\*****************************************************************************/
LPCTSTR
CInetMonPort::GetPortName(
    VOID)
{
    LPCTSTR     lpszName = NULL;

    semCheckCrit();

    lpszName = (LPCTSTR)m_lpszName;

    return lpszName;
}


/*****************************************************************************\
* InetmonGetPJMList
*
*
\*****************************************************************************/
PJOBMAP*
CInetMonPort::GetPJMList(
    VOID)
{
    PJOBMAP*     ppjmList = NULL;

    semCheckCrit();

    ppjmList = &m_pjmList;

    return ppjmList;
}

#ifdef WINNT32
/*****************************************************************************\
* InetmonIncUserRefCount
*
* Increases the reference count on the port for the given user
*
\*****************************************************************************/
DWORD
CInetMonPort::IncUserRefCount(
    PCLOGON_USERDATA hUser )
{

    DWORD       dwRet = (DWORD) -1;

    dwRet = m_pPortMgr->IncreaseUserRefCount (hUser);

    return dwRet;
}
#endif  // #ifdef WINNT32

VOID
CInetMonPort::FreeGetPrinterCache (
    VOID)
{
    if (m_pGetPrinterCache) {
        semLeaveCrit ();
        m_pGetPrinterCache->Shutdown ();
        semEnterCrit ();
    }
}

BOOL
CInetMonPort::BeginReadGetPrinterCache (
    PPRINTER_INFO_2 *ppInfo2)
{
    BOOL bRet = FALSE;

    if (m_pGetPrinterCache) {
        semLeaveCrit ();
        bRet = m_pGetPrinterCache->BeginReadCache (ppInfo2);
        semEnterCrit ();
    }

    return bRet;
}

VOID
CInetMonPort::EndReadGetPrinterCache (
    VOID)
{
    if (m_pGetPrinterCache) {
        m_pGetPrinterCache->EndReadCache ();
    }
}


VOID
CInetMonPort::InvalidateGetPrinterCache (
    VOID)
{
    if (m_pGetPrinterCache) {
        semLeaveCrit ();
        m_pGetPrinterCache->InvalidateCache ();
        semEnterCrit ();
    }
}

#if (defined(WINNT32))
VOID
CInetMonPort::InvalidateGetPrinterCacheForUser(
    HANDLE hUser)
/*++

Routine Description:
    Close the cache if the current user is currently controlling it.

Arguments:
    hUser    - The user for which we want to close the cache

Return Value:
    None.

--*/
    {
    CLogonUserData   *pUser  = (CLogonUserData *)hUser;

    if (m_pGetPrinterCache && pUser) {

        semLeaveCrit ();
        m_pGetPrinterCache->InvalidateCacheForUser (pUser);
        semEnterCrit ();
    }
}

#endif // #if (defined(WINNT32))

VOID
CInetMonPort::FreeEnumJobsCache (
    VOID)
{
    semLeaveCrit ();
    m_pEnumJobsCache->Shutdown ();
    semEnterCrit ();
}

BOOL
CInetMonPort::BeginReadEnumJobsCache (
    LPPPJOB_ENUM *ppje)
{
    BOOL bRet = FALSE;

    if (m_pEnumJobsCache) {
        semLeaveCrit ();
        bRet =  m_pEnumJobsCache->BeginReadCache(ppje);
        semEnterCrit ();
    }

    return bRet;

}

VOID
CInetMonPort::EndReadEnumJobsCache (
    VOID)
{
    if (m_pEnumJobsCache) {
        m_pEnumJobsCache->EndReadCache();
    }
}

VOID
CInetMonPort::InvalidateEnumJobsCache (
    VOID)
{
    if (m_pEnumJobsCache) {
        semLeaveCrit ();
        m_pEnumJobsCache->InvalidateCache ();
        semEnterCrit ();
    }
}

#if (defined(WINNT32))
VOID
CInetMonPort::InvalidateEnumJobsCacheForUser(
    HANDLE hUser)
/*++

Routine Description:
    Close the cache if the current user is currently controlling it.

Arguments:
    hUser    - The user for which we want to close the cache

Return Value:
    None.

--*/
{

    if (m_pEnumJobsCache && hUser) {

        semLeaveCrit ();
        m_pEnumJobsCache->InvalidateCacheForUser ((CLogonUserData *)hUser);
        semEnterCrit ();
    }
}

#endif // #if (defined(WINNT32))


BOOL
CInetMonPort::ReadFile (
    CAnyConnection *pConnection,
    HINTERNET hReq,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbRd)
{
    return m_pPortMgr->ReadFile (pConnection, hReq, lpvBuffer, cbBuffer, lpcbRd);
}

#if (defined(WINNT32))

BOOL
CInetMonPort::GetCurrentConfiguration (
    PINET_XCV_CONFIGURATION pXcvConfiguration)
{
    return m_pPortMgr->GetCurrentConfiguration(pXcvConfiguration);
}

BOOL
CInetMonPort::ConfigurePort (
    PINET_XCV_CONFIGURATION pXcvConfigurePortReqData,
    PINET_CONFIGUREPORT_RESPDATA pXcvAddPortRespData,
    DWORD cbSize,
    PDWORD cbSizeNeeded)
{
    return m_pPortMgr->ConfigurePort (pXcvConfigurePortReqData,
                                      pXcvAddPortRespData,
                                      cbSize,
                                      cbSizeNeeded);
}


HANDLE
CInetMonPort::CreateTerminateEvent (
    VOID)
{
    if (!m_hTerminateEvent) {
        //
        // Craete a manual reset event since multiple threads may be waiting
        //

        m_hTerminateEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
    }

    return m_hTerminateEvent;
}

BOOL
CInetMonPort::WaitForTermination (
    DWORD dwWaitTime)
{
    BOOL bTerminate = FALSE;

    semLeaveCrit();

    DWORD dwRet = WaitForSingleObject (m_hTerminateEvent, dwWaitTime);

    if (dwRet == WAIT_OBJECT_0 || dwRet == WAIT_FAILED)
        bTerminate = TRUE;

    semEnterCrit();

    return bTerminate;
}
#endif // #if (defined(WINNT32))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\globals.cxx ===
/*****************************************************************************\
* MODULE: globals.c
*
* This is the common global variable module.  Any globals used throughout the
* executable should be placed in here and the cooresponding declaration
* should be in "globals.h".
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


// Global variables which can change state.
//
HINSTANCE        g_hInst            = NULL;
DWORD            g_dwJobLimit       = 1000;        // 1000 iterations.
CRITICAL_SECTION g_csMonitorSection = {0, 0, 0, 0, 0, 0};
BOOL             g_bUpgrade         = FALSE;

CCriticalSection *g_pcsEndBrowserSessionLock = NULL;

#ifdef WINNT32
CRITICAL_SECTION g_csCreateSection  = {0, 0, 0, 0, 0, 0};
HANDLE           g_eResetConnections= INVALID_HANDLE_VALUE;
DWORD            g_dwConCount       = 0;
#endif


#ifdef DEBUG
DWORD            g_dwCritOwner      = 0;
#endif


// Holds the machine-name.
//
TCHAR g_szMachine[MAX_COMPUTERNAME_LENGTH + 1] = {0};

#ifdef WINNT32

// Holds other network names
//
LPWSTR  *g_ppszOtherNames = 0;
DWORD   g_cOtherNames = 0;

#endif

LPTSTR g_szRegProvider = NULL;
LPTSTR g_szRegPrintProviders = NULL;

TCHAR g_szDefSplDir [MAX_PATH];
TCHAR g_szDisplayStr[MAX_PATH];

// Spooler-Directory Strings.
//
CONST TCHAR g_szSplDir9X []     = TEXT("\\spool\\printers");
CONST TCHAR g_szSplPfx   []     = TEXT("IPP");


// Constant string identifiers.
//
CONST TCHAR g_szUserAgent[]     = TEXT("Internet Print Provider");
CONST TCHAR g_szLocalPort[]     = TEXT("Internet Port");
CONST TCHAR g_szDisplayName[]   = TEXT("DisplayName");
CONST TCHAR g_szLibraryName[]   = TEXT("inetpp.dll");
CONST TCHAR g_szWinInetDll[]    = TEXT("wininet.dll");
CONST TCHAR g_szUriPrinters[]   = TEXT("scripts/%s/.printer");
CONST TCHAR g_szPOST[]          = TEXT("POST");
CONST TCHAR g_szGET[]           = TEXT("GET");
CONST TCHAR g_szContentLen[]    = TEXT("Content-length: %d\r\n");
CONST TCHAR g_szContentType[]   = TEXT("Content-type: application/ipp\r\n");
CONST TCHAR g_szEmptyString[]   = TEXT("");
CONST TCHAR g_szDescription[]   = TEXT("Windows NT Internet Printing");
CONST TCHAR g_szComment[]       = TEXT("Internet URL Printers");
CONST TCHAR g_szProviderName[]  = TEXT("Windows NT Internet Provider");
CONST TCHAR g_szNewLine[]       = TEXT("\n");
CONST TCHAR g_szConfigureMsg[]  = TEXT("There is nothing to configure for this port.");
CONST TCHAR g_szRegPorts[]      = TEXT("Ports");
CONST TCHAR g_szAuthDlg[]       = TEXT("AuthDlg");
CONST TCHAR g_szDocRemote[]     = TEXT("Remote Downlevel Document");
CONST TCHAR g_szDocLocal[]      = TEXT("Local Downlevel Document");

// Registry Value
//
CONST TCHAR g_szAuthMethod[]    = TEXT("Authentication");
CONST TCHAR g_szUserName[]      = TEXT("UserName");
CONST TCHAR g_szPassword[]      = TEXT("Password");
CONST TCHAR g_szPerUserPath[]   = TEXT("Printers\\Inetnet Print Provider");



// Http Version Number
//
CONST TCHAR g_szHttpVersion[]   = TEXT("HTTP/1.1");



#ifdef WINNT32
CONST TCHAR g_szProcessName[] = TEXT("spoolsv.exe");
#else
CONST TCHAR g_szProcessName[] = TEXT("spool32.exe");
#endif


// String constants for the Internet API.  These strings are
// used exclusively by the GetProcAddress() call, which does not
// support Unicode.  Therefore, these strings should NOT be wrapped
// by the TEXT macro.
//
CONST CHAR g_szInternetCloseHandle[] = "InternetCloseHandle";
CONST CHAR g_szInternetErrorDlg[]    = "InternetErrorDlg";
CONST CHAR g_szInternetReadFile[]    = "InternetReadFile";
CONST CHAR g_szInternetWriteFile[]   = "InternetWriteFile";


#ifdef UNIMPLEMENTED

// NOTE: Currently, the release of WININET.DLL that was used (07-Aug-1996)
//       does not support the Unicode calls.  So, in order to support this
//       this correctly (Until it becomes available), this DLL will still
//       be compilable and runable in Unicode.  However, the WININET calls
//       will be dealt with as Ansi in the (inetwrap.c) module.
//
//       Change this to (#ifdef UNICODE) once WinInet is fixed
//       to support Unicode.  For now, we can rely on the wrappers
//       in "inetwrap.c"
//
//       15-Oct-1996 : ChrisWil
//

CONST CHAR g_szHttpQueryInfo[]         = "HttpQueryInfoW";
CONST CHAR g_szInternetOpenUrl[]       = "InternetOpenUrlW";
CONST CHAR g_szHttpSendRequest[]       = "HttpSendRequestW";
CONST CHAR g_szHttpSendRequestEx[]     = "HttpSendRequestExW";
CONST CHAR g_szInternetOpen[]          = "InternetOpenW";
CONST CHAR g_szInternetConnect[]       = "InternetConnectW";
CONST CHAR g_szHttpOpenRequest[]       = "HttpOpenRequestW";
CONST CHAR g_szHttpAddRequestHeaders[] = "HttpAddRequestHeadersW";
CONST CHAR g_szHttpEndRequest[]        = "HttpEndRequestW";
CONST CHAR g_szInternetSetOption[]     = "InternetSetOptionW";

#else

CONST CHAR g_szHttpQueryInfo[]         = "HttpQueryInfoA";
CONST CHAR g_szInternetOpenUrl[]       = "InternetOpenUrlA";
CONST CHAR g_szHttpSendRequest[]       = "HttpSendRequestA";
CONST CHAR g_szHttpSendRequestEx[]     = "HttpSendRequestExA";
CONST CHAR g_szInternetOpen[]          = "InternetOpenA";
CONST CHAR g_szInternetConnect[]       = "InternetConnectA";
CONST CHAR g_szHttpOpenRequest[]       = "HttpOpenRequestA";
CONST CHAR g_szHttpAddRequestHeaders[] = "HttpAddRequestHeadersA";
CONST CHAR g_szHttpEndRequest[]        = "HttpEndRequestA";
CONST CHAR g_szInternetSetOption[]     = "InternetSetOptionA";

#endif


// Internet API pointers for controling the Url output.
//
PFNHTTPQUERYINFO         g_pfnHttpQueryInfo;
PFNINTERNETOPENURL       g_pfnInternetOpenUrl;
PFNINTERNETERRORDLG      g_pfnInternetErrorDlg;
PFNHTTPSENDREQUEST       g_pfnHttpSendRequest;
PFNHTTPSENDREQUESTEX     g_pfnHttpSendRequestEx;
PFNINTERNETREADFILE      g_pfnInternetReadFile;
PFNINTERNETWRITEFILE     g_pfnInternetWriteFile;
PFNINTERNETCLOSEHANDLE   g_pfnInternetCloseHandle;
PFNINTERNETOPEN          g_pfnInternetOpen;
PFNINTERNETCONNECT       g_pfnInternetConnect;
PFNHTTPOPENREQUEST       g_pfnHttpOpenRequest;
PFNHTTPADDREQUESTHEADERS g_pfnHttpAddRequestHeaders;
PFNHTTPENDREQUEST        g_pfnHttpEndRequest;
PFNINTERNETSETOPTION     g_pfnInternetSetOption;


PCINETMON gpInetMon = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\inetwrap.cxx ===
/*****************************************************************************\
* MODULE: inetwrap.c
*
* This module contains wrapper routines to translate internet calls from
* Unicode to Ansi.  This is necessary right now since the WININET routines
* do not support Unicode for Windows NT.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*   15-Jul-1998 v-chrisw    Allow safe DelayLoad of wininet.
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* wrapInternetOpen
*
*
\*****************************************************************************/
HINTERNET wrapInternetOpen(
    LPCTSTR lpszAgent,
    DWORD   dwAccess,
    LPCTSTR lpszProxyName,
    LPCTSTR lpszProxyBypass,
    DWORD   dwFlags)
{
    HINTERNET hRet = NULL;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiAgent = NULL;
    LPSTR lpszAnsiProxyName = NULL;
    LPSTR lpszAnsiProxyBypass = NULL;
    BOOL  bRet = TRUE;


    if (lpszAgent && (uSize = WCtoMB(lpszAgent, NULL, 0))) {

        if (lpszAnsiAgent = new CHAR[uSize])
            bRet = WCtoMB(lpszAgent, lpszAnsiAgent, uSize);
        else
            bRet = FALSE;
    }


    if (bRet && lpszProxyName && (uSize = WCtoMB(lpszProxyName, NULL, 0))) {

        if (lpszAnsiProxyName = new CHAR[uSize])
            bRet = WCtoMB(lpszProxyName, lpszAnsiProxyName, uSize);
        else
            bRet = FALSE;
    }

    if (bRet && lpszProxyBypass && (uSize = WCtoMB(lpszProxyBypass, NULL, 0))) {

        if (lpszAnsiProxyBypass = new CHAR[uSize])
            bRet = WCtoMB(lpszProxyBypass, lpszAnsiProxyBypass, uSize);
        else
            bRet = FALSE;
    }

    if (bRet) {

        __try {

            hRet = g_pfnInternetOpen((LPCTSTR)lpszAnsiAgent,
                                     dwAccess,
                                     (LPCTSTR)lpszAnsiProxyName,
                                     (LPCTSTR)lpszAnsiProxyBypass,
                                     dwFlags);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetOpen exception!")));

            hRet = NULL;
        }
    }

    if (lpszAnsiAgent)
        delete [](lpszAnsiAgent);

    if (lpszAnsiProxyName)
        delete [](lpszAnsiProxyName);

    if (lpszAnsiProxyBypass)
        delete [](lpszAnsiProxyBypass);

#else

    __try {

        hRet =  g_pfnInternetOpen(lpszAgent,
                                  dwAccess,
                                  lpszProxyName,
                                  lpszProxyBypass,
                                  dwFlags);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetOpen exception!")));

        hRet = NULL;
    }

#endif

    return hRet;
}


/*****************************************************************************\
* wrapInternetOpenUrl
*
*
\*****************************************************************************/
HINTERNET wrapInternetOpenUrl(
    HINTERNET hInternet,
    LPCTSTR   lpszUrl,
    LPCTSTR   lpszHeaders,
    DWORD     dwHeaderLen,
    DWORD     dwFlags,
    DWORD_PTR dwContext)
{
    HINTERNET hRet = NULL;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiUrl = NULL;
    LPSTR lpszAnsiHeaders = NULL;
    BOOL  bRet = TRUE;


    if (lpszUrl && (uSize = WCtoMB(lpszUrl, NULL, 0))) {

        if (lpszAnsiUrl = new CHAR[uSize])
            bRet = WCtoMB(lpszUrl, lpszAnsiUrl, uSize);
        else
            bRet = FALSE;
    }

    if (bRet && lpszHeaders && (uSize = WCtoMB(lpszHeaders, NULL, 0))) {

        if (lpszAnsiHeaders = new CHAR[uSize])
            bRet = WCtoMB(lpszHeaders, lpszAnsiHeaders, uSize);
        else
            bRet = FALSE;
    }

    if (bRet) {

        __try {

            hRet = g_pfnInternetOpenUrl(hInternet,
                                        (LPCTSTR)lpszAnsiUrl,
                                        (LPCTSTR)lpszAnsiHeaders,
                                        dwHeaderLen,
                                        dwFlags,
                                        dwContext);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetOpenUrl exception!")));

            hRet = NULL;
        }
    }

    if (lpszAnsiUrl)
        delete [](lpszAnsiUrl);

    if (lpszAnsiHeaders)
        delete [](lpszAnsiHeaders);

#else

    __try {

        hRet = g_pfnInternetOpenUrl(hInternet,
                                    lpszUrl,
                                    lpszHeaders,
                                    dwHeaderLen,
                                    dwFlags,
                                    dwContext);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetOpenUrl exception!")));

        hRet = NULL;
    }

#endif

    return hRet;
}


/*****************************************************************************\
* wrapInternetConnect
*
*
\*****************************************************************************/
HINTERNET wrapInternetConnect(
    HINTERNET     hSession,
    LPCTSTR       lpszServerName,
    INTERNET_PORT nServerPort,
    LPCTSTR       lpszUserName,
    LPCTSTR       lpszPassword,
    DWORD         dwService,
    DWORD         dwFlags,
    DWORD_PTR     dwContext)
{
    HINTERNET hRet = NULL;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiServerName = NULL;
    LPSTR lpszAnsiUserName = NULL;
    LPSTR lpszAnsiPassword = NULL;
    BOOL  bRet = TRUE;


    if (lpszServerName && (uSize = WCtoMB(lpszServerName, NULL, 0))) {

        if (lpszAnsiServerName = new CHAR[uSize])
            bRet = WCtoMB(lpszServerName, lpszAnsiServerName, uSize);
        else
            bRet = FALSE;
    }

    if (bRet && lpszUserName && (uSize = WCtoMB(lpszUserName, NULL, 0))) {

        if (lpszAnsiUserName = new CHAR[uSize])
            bRet = WCtoMB(lpszUserName, lpszAnsiUserName, uSize);
        else
            bRet = FALSE;
    }

    if (bRet && lpszPassword && (uSize = WCtoMB(lpszPassword, NULL, 0))) {

        if (lpszAnsiPassword = new CHAR[uSize])
            bRet = WCtoMB(lpszPassword, lpszAnsiPassword, uSize);
        else
            bRet = FALSE;
    }

    if (bRet) {

        __try {

            hRet = g_pfnInternetConnect(hSession,
                                        (LPCTSTR)lpszAnsiServerName,
                                        nServerPort,
                                        (LPCTSTR)lpszAnsiUserName,
                                        (LPCTSTR)lpszAnsiPassword,
                                        dwService,
                                        dwFlags,
                                        dwContext);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetConnect exception!")));

            hRet = NULL;
        }
    }


    if (lpszAnsiServerName)
        delete [](lpszAnsiServerName);

    if (lpszAnsiUserName)
        delete [](lpszAnsiUserName);

    if (lpszAnsiPassword)
        delete [](lpszAnsiPassword);

#else

    __try {

        hRet = g_pfnInternetConnect(hSession,
                                    lpszServerName,
                                    nServerPort,
                                    lpszUserName,
                                    lpszPassword,
                                    dwService,
                                    dwFlags,
                                    dwContext);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetConnect exception!")));

        hRet = NULL;
    }

#endif

    return hRet;
}


/*****************************************************************************\
* wrapHttpQueryInfo
*
*
\*****************************************************************************/
BOOL wrapHttpQueryInfo(
    HINTERNET hRequest,
    DWORD     dwInfoLevel,
    LPVOID    lpvBuffer,
    LPDWORD   lpdwBufferLen,
    LPDWORD   lpdwIndex)
{
    BOOL bRet;


    __try {

        bRet = g_pfnHttpQueryInfo(hRequest,
                                  dwInfoLevel,
                                  lpvBuffer,
                                  lpdwBufferLen,
                                  lpdwIndex);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpQueryInfo exception!")));

        bRet = FALSE;
    }

    return bRet;
}


/*****************************************************************************\
* wrapHttpSendRequest
*
*
\*****************************************************************************/
BOOL wrapHttpSendRequest(
    HINTERNET hRequest,
    LPCTSTR   lpszHeaders,
    DWORD     dwHeaderLen,
    LPVOID    lpvOptional,
    DWORD     dwOptionalLen)
{
    BOOL bRet = TRUE;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiHeaders = NULL;


    if (lpszHeaders && (uSize = WCtoMB(lpszHeaders, NULL, 0))) {

        if (lpszAnsiHeaders = new CHAR[uSize])
            bRet = WCtoMB(lpszHeaders, lpszAnsiHeaders, uSize);
        else
            bRet = FALSE;
    }

    if (bRet) {

        __try {

            bRet = g_pfnHttpSendRequest(hRequest,
                                        (LPCTSTR)lpszAnsiHeaders,
                                        dwHeaderLen,
                                        lpvOptional,
                                        dwOptionalLen);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpSendRequest exception!")));

            bRet = FALSE;
        }
    }

    if (lpszAnsiHeaders)
        delete [](lpszAnsiHeaders);

#else

    __try {

        bRet = g_pfnHttpSendRequest(hRequest,
                                    lpszHeaders,
                                    dwHeaderLen,
                                    lpvOptional,
                                    dwOptionalLen);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpSendRequest exception!")));

        bRet = FALSE;
    }

#endif

    return bRet;
}


/*****************************************************************************\
* wrapHttpSendRequestEx
*
*
\*****************************************************************************/
BOOL wrapHttpSendRequestEx(
    HINTERNET          hRequest,
    LPINTERNET_BUFFERS lpBufIn,
    LPINTERNET_BUFFERS lpBufOut,
    DWORD              dwFlags,
    DWORD_PTR          dwContext)
{
    BOOL bRet = TRUE;


    // NOTE : This now works for Header values defined in lpBufIn and lpBufOut, we assume that
    // the "size" of the header in the structure is not set by the calling routine, if it is we
    // overwrite the size when we convert it....
    //
    // NOTE2: We do not support linked Buffer Strucures, only 1!!!!!
    // NOTE3: We do not support lpBufOut to return values. It must be NULL

#ifdef UNICODE
    UINT                uSize               = 0;
    LPSTR               lpszAnsiHeaders     = NULL;
    LPCWSTR             lpcszHeader;
    INTERNET_BUFFERSA   ConvertBuf;

    DBG_ASSERT((lpBufOut == NULL) , (TEXT("inetwrap : We do not support output buffers!")));
    DBG_ASSERT((lpBufIn->Next == NULL) , (TEXT("inetwrap : We do not support chained input buffers!")));
    
    lpcszHeader = lpBufIn->lpcszHeader;
    
    if (lpcszHeader && (uSize = WCtoMB(lpcszHeader, NULL, 0))) {
        if (lpszAnsiHeaders = new CHAR[uSize]) 
            bRet = WCtoMB(lpcszHeader, lpszAnsiHeaders, uSize--);
        else
            bRet = FALSE;
    }

    if (bRet) {
        ConvertBuf.dwStructSize     = sizeof(ConvertBuf);
        ConvertBuf.Next             = NULL;
        ConvertBuf.lpcszHeader      = lpszAnsiHeaders;
        ConvertBuf.dwHeadersLength  = (DWORD)uSize;
        ConvertBuf.dwHeadersTotal   = lpBufIn->dwHeadersTotal;
        ConvertBuf.lpvBuffer        = lpBufIn->lpvBuffer; 
        ConvertBuf.dwBufferLength   = lpBufIn->dwBufferLength;
        ConvertBuf.dwBufferTotal    = lpBufIn->dwBufferTotal;
        ConvertBuf.dwOffsetLow      = lpBufIn->dwOffsetLow;
        ConvertBuf.dwOffsetHigh     = lpBufIn->dwOffsetHigh;

        __try {

            bRet = g_pfnHttpSendRequestEx(hRequest,
                                          &ConvertBuf,
                                          lpBufOut,
                                          dwFlags,
                                          dwContext);  
        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpSendRequestEx exception!")));

            bRet = FALSE;
        }
    }

    if (lpszAnsiHeaders)
        delete [](lpszAnsiHeaders);

#else
    __try {

        bRet = g_pfnHttpSendRequestEx(hRequest,
                                      lpBufIn,
                                      lpBufOut,
                                      dwFlags,
                                      dwContext);  
                                      
    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpSendRequestEx exception!")));

        bRet = FALSE;
    }
#endif

    return bRet;
}


/*****************************************************************************\
* wrapHttpOpenRequest
*
*
\*****************************************************************************/
HINTERNET wrapHttpOpenRequest(
    HINTERNET hConnect,
    LPCTSTR   lpszVerb,
    LPCTSTR   lpszObjectName,
    LPCTSTR   lpszVersion,
    LPCTSTR   lpszReferer,
    LPCTSTR   *lplpszAccept,
    DWORD     dwFlags,
    DWORD_PTR dwContext)
{
    HINTERNET hRet = NULL;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiVerb = NULL;
    LPSTR lpszAnsiObjectName = NULL;
    LPSTR lpszAnsiVersion = NULL;
    LPSTR lpszAnsiReferer = NULL;
    BOOL  bRet = TRUE;


    if (lpszVerb && (uSize = WCtoMB(lpszVerb, NULL, 0))) {

        if (lpszAnsiVerb = new CHAR[uSize])
            bRet = WCtoMB(lpszVerb, lpszAnsiVerb, uSize);
    }

    if (bRet && lpszObjectName && (uSize = WCtoMB(lpszObjectName, NULL, 0))) {

        if (lpszAnsiObjectName = new CHAR[uSize])
            bRet = WCtoMB(lpszObjectName, lpszAnsiObjectName, uSize);
        else
            bRet = FALSE;
    }

    if (bRet && lpszVersion && (uSize = WCtoMB(lpszVersion, NULL, 0))) {

        if (lpszAnsiVersion = new CHAR[uSize])
            bRet = WCtoMB(lpszVersion, lpszAnsiVersion, uSize);
        else
            bRet = FALSE;
    }

    if (bRet && lpszReferer && (uSize = WCtoMB(lpszReferer, NULL, 0))) {

        if (lpszAnsiReferer = new CHAR[uSize])
            bRet = WCtoMB(lpszReferer, lpszAnsiReferer, uSize);
        else
            bRet = FALSE;
    }

    if (bRet) {

        __try {

            hRet = g_pfnHttpOpenRequest(hConnect,
                                        (LPCTSTR)lpszAnsiVerb,
                                        (LPCTSTR)lpszAnsiObjectName,
                                        (LPCTSTR)lpszAnsiVersion,
                                        (LPCTSTR)lpszAnsiReferer,
                                        (LPCTSTR *)lplpszAccept,
                                        dwFlags,
                                        dwContext);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpOpenRequest exception!")));

            hRet = NULL;
        }
    }

    if (lpszAnsiVerb)
        delete [](lpszAnsiVerb);

    if (lpszAnsiObjectName)
        delete [](lpszAnsiObjectName);

    if (lpszAnsiVersion)
        delete [](lpszAnsiVersion);

    if (lpszAnsiReferer)
        delete [](lpszAnsiReferer);

#else


    __try {

        hRet = g_pfnHttpOpenRequest(hConnect,
                                    lpszVerb,
                                    lpszObjectName,
                                    lpszVersion,
                                    lpszReferer,
                                    lplpszAccept,
                                    dwFlags,
                                    dwContext);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpOpenRequest exception!")));

        hRet = NULL;
    }

#endif

    return hRet;
}


/*****************************************************************************\
* wrapHttpAddRequestHeaders
*
*
\*****************************************************************************/
BOOL wrapHttpAddRequestHeaders(
    HINTERNET hRequest,
    LPCTSTR   lpszHeaders,
    DWORD     cbLength,
    DWORD     dwModifiers)
{
    BOOL bRet = TRUE;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiHeaders = NULL;


    if (lpszHeaders && (uSize = WCtoMB(lpszHeaders, NULL, 0))) {

        if (lpszAnsiHeaders = new CHAR[uSize])
            WCtoMB(lpszHeaders, lpszAnsiHeaders, uSize);
        else
            bRet = FALSE;
    }

    if (bRet) {

        __try {

            bRet = g_pfnHttpAddRequestHeaders(hRequest,
                                              (LPCTSTR)lpszAnsiHeaders,
                                              cbLength,
                                              dwModifiers);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpAddRequestHeaders exception!")));

            bRet = FALSE;
        }
    }

    if (lpszAnsiHeaders)
        delete [](lpszAnsiHeaders);

#else

    __try {

        bRet = g_pfnHttpAddRequestHeaders(hRequest,
                                          lpszHeaders,
                                          cbLength,
                                          dwModifiers);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpAdRequestHeaders exception!")));

        bRet = FALSE;
    }

#endif

    return bRet;
}


/*****************************************************************************\
* wrapHttpEndRequest
*
*
\*****************************************************************************/
BOOL wrapHttpEndRequest(
    HINTERNET          hRequest,
    LPINTERNET_BUFFERS lpBuf,
    DWORD              dwFlags,
    DWORD_PTR          dwContext)
{
    BOOL bRet;


    __try {

#ifdef UNICODE

        DBG_ASSERT((lpBuf == NULL), (TEXT("Assert: NULL Buffer is only support")));

        bRet = g_pfnHttpEndRequest(hRequest, lpBuf, dwFlags, dwContext); 
        
#else

        bRet = g_pfnHttpEndRequest(hRequest, lpBuf, dwFlags, dwContext);

#endif

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : HttpOpenRequest exception!")));

        bRet = FALSE;
    }

    return bRet;
}


/*****************************************************************************\
* wrapInternetSetOption
*
*
\*****************************************************************************/
BOOL wrapInternetSetOption(
    HINTERNET hRequest,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength)
{
    BOOL bRet = TRUE;

#ifdef UNICODE

    UINT  uSize;
    LPSTR lpszAnsiBuffer = NULL;


    switch (dwOption) {

    case INTERNET_OPTION_USERNAME:
    case INTERNET_OPTION_PASSWORD:
    case INTERNET_OPTION_PROXY_USERNAME:
    case INTERNET_OPTION_PROXY_PASSWORD:

        if (lpBuffer && (uSize = WCtoMB(lpBuffer, NULL, 0))) {

            if (lpszAnsiBuffer = new CHAR[uSize])
                bRet = WCtoMB(lpBuffer, lpszAnsiBuffer, uSize);
            else
                bRet = FALSE;
        }

        if (bRet) {

            __try {

                bRet = g_pfnInternetSetOption(hRequest,
                                              dwOption,
                                              lpszAnsiBuffer,
                                              dwBufferLength);

            } __except(1) {

                DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetSetOption exception!")));

                bRet = FALSE;
            }
        }

        if (lpszAnsiBuffer)
            delete [](lpszAnsiBuffer);
        break;

    default:

        __try {

            bRet = g_pfnInternetSetOption(hRequest,
                                          dwOption,
                                          lpBuffer,
                                          dwBufferLength);

        } __except(1) {

            DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetSetOption exception!")));

            bRet = FALSE;
        }
        break;
    }

#else

    __try {

        bRet = g_pfnInternetSetOption(hRequest,
                                      dwOption,
                                      lpBuffer,
                                      dwBufferLength);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetSetOption exception!")));

        bRet = FALSE;
    }

#endif

    return bRet;
}



/*****************************************************************************\
* wrapInternetCloseHandle
*
*
\*****************************************************************************/
BOOL wrapInternetCloseHandle(
    HINTERNET hHandle)
{
    BOOL bRet;


    __try {

        bRet = g_pfnInternetCloseHandle(hHandle);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetCloseHandle exception!")));

        bRet = FALSE;
    }

    return bRet;
}


/*****************************************************************************\
* wrapInternetReadFile
*
*
\*****************************************************************************/
BOOL wrapInternetReadFile(
    HINTERNET hReq,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbRd)
{
    BOOL bRet;


    __try {

        bRet = g_pfnInternetReadFile(hReq, lpvBuffer, cbBuffer, lpcbRd);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetReadFile exception!")));

        bRet = FALSE;
    }

    return bRet;
}


/*****************************************************************************\
* wrapInternetWriteFile
*
*
\*****************************************************************************/
BOOL wrapInternetWriteFile(
    HINTERNET hReq,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbWr)
{
    BOOL bRet;


    __try {

        bRet = g_pfnInternetWriteFile(hReq, lpvBuffer, cbBuffer, lpcbWr);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetWriteFile exception!")));

        bRet = FALSE;
    }

    return bRet;
}


/*****************************************************************************\
* wrapInternetErrorDlg
*
*
\*****************************************************************************/
DWORD wrapInternetErrorDlg(
    HWND      hWnd,
    HINTERNET hReq,
    DWORD     dwError,
    DWORD     dwFlags,
    LPVOID    pvParam)
{
    DWORD dwRet;


    __try {

        dwRet = g_pfnInternetErrorDlg(hWnd, hReq, dwError, dwFlags, pvParam);

    } __except(1) {

        DBG_ASSERT(FALSE, (TEXT("inetwrap : InternetErrorDlg exception!")));

        dwRet = 0;
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\inetpp.cxx ===
/*****************************************************************************\
* MODULE: inetpp.c
*
* The module contains routines for handling the INETPP functionality.  Use
* of these routines require the locking/unlocking of a critical-section
* to maninpulate the INIMONPORT list.  All internal routines assume the
* crit-sect is locked prior to executing.  CheckMonCrit() is a debugging
* call to verify the monitor-crit-sect is locked.
*
* NOTE: Each of the Inetmon* calls must be protected by the global-crit-sect.
*       If a new routine is added to this module which is to be called from
*       another module, be sure to include the call to (semCheckCrit), so
*       that the debug-code can catch unprotected access.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*   14-Nov-1997 ChrisWil    Added local-spooling functionality.
*   10-Jul-1998 WeihaiC     Change Authentication Dialog Code
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


CInetMon::CInetMon ()
{
    // Initialize the monitor-port-list.
    //
    m_pPortList = (PINIMONPORTLIST)memAlloc(sizeof(INIMONPORTLIST));

    m_bValid = (m_pPortList != NULL);
}

CInetMon::~CInetMon ()
{
}

/*****************************************************************************\
* _inet_validate_portname (Local Routine)
*
* Validate the portname.
*
* NOTE: If this check becomes more rigorous, it must account for the (%)
*       character (escape).
*
\*****************************************************************************/
BOOL 
CInetMon::_inet_validate_portname(
    LPCTSTR lpszPortName)
{
    if (lpszPortName && (*lpszPortName))
        return TRUE;

    DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : _inet_validate_portname : Invalid Name")));
    SetLastError(ERROR_INVALID_NAME);

    return FALSE;
}


/*****************************************************************************\
* _inet_find_port (Local Routine)
*
* Locates the entry in the list where the port-name resides.  Return the
* full entry-type (INIMONPORT) for the location.
*
\*****************************************************************************/
PCINETMONPORT 
CInetMon::_inet_find_port(
    LPCTSTR lpszPortName)
{
    PCINETMONPORT pIniPort;

    pIniPort = m_pPortList->pIniFirstPort;

    while (pIniPort && lstrcmpi(lpszPortName, pIniPort->m_lpszName))
        pIniPort = pIniPort->m_pNext;

    return pIniPort;
}

/*****************************************************************************\
* _inet_create_port (Local Routine)
*
* Create a new port data structure and link into the list.  This routine
* assumes that the Crit is held.
*
* This routine also assumes the pszPortName is a valid http:// format.
*
\*****************************************************************************/
PCINETMONPORT 
CInetMon::_inet_create_port(
    LPCTSTR     lpszPortName,
    PCPORTMGR   pPortMgr)
{
    PCINETMONPORT pIniPort;
    PCINETMONPORT pPort;
    BOOL bRet = FALSE;


    if ((pIniPort = new CInetMonPort (lpszPortName, g_szLocalPort, pPortMgr)) &&
        pIniPort->bValid ()) {

        // Set the link.  If this is the first port added, the
        // we set the global variable.
        //
        if (pPort = m_pPortList->pIniFirstPort) {

            while (pPort->GetNext())
                pPort = pPort->GetNext();

            pPort->SetNext (pIniPort);

        } else {

            m_pPortList->pIniFirstPort = pIniPort;
        }

        bRet = TRUE;
    }

    if (!bRet) {

        if (pIniPort) {
            delete pIniPort;
            pIniPort = NULL;
        }
    }

    return pIniPort;
}

/*****************************************************************************\
* _inet_delete_port (Local Routine)
*
* Free a port data structure that is no longer needed.
*
\*****************************************************************************/
BOOL 
CInetMon::_inet_delete_port(
    LPCTSTR lpszPortName)
{
    PCINETMONPORT pIniPort;
    PCINETMONPORT pPrvPort;
    BOOL        bRet = FALSE;


    // Keep track of our previous/current entries, so that
    // we can remove the specified port.
    //
    pIniPort = m_pPortList->pIniFirstPort;

    while (pIniPort && lstrcmpi(pIniPort->m_lpszName, lpszPortName)) {

        pPrvPort = pIniPort;
        pIniPort = pIniPort->GetNext ();
    }


    // If the PortName is found, then delete it.
    //
    if (pIniPort) {

        if (pIniPort->m_cRef > 0 && pIniPort->m_hTerminateEvent) {
            
            // To tell spooling thread to terminate
            //
            SetEvent (pIniPort->m_hTerminateEvent);

            semSafeLeaveCrit(pIniPort);
            //
            // Leave the critical section so that the spooling thread can decrease the ref count
            //

            Sleep (250);

            semSafeEnterCrit (pIniPort);

        }

        // Only allow this port to be deleted if the reference count
        // is at zero.
        //

        if (pIniPort->m_cRef == 0) {
        
            pIniPort->m_bDeletePending = TRUE;
    
            //
            // Remove the pointer from the list
            //
            // If this is our first-port then we need to handle
            // differently as we keep a global-pointer to this.
            //
            if (pIniPort == m_pPortList->pIniFirstPort) {
    
                m_pPortList->pIniFirstPort = pIniPort->GetNext();
    
            } else {
    
                pPrvPort->SetNext(pIniPort->GetNext());
            }
    
            // We only free the memeory if there are no open handles
            //
            if (pIniPort->m_cPrinterRef == 0) {
                
                DBG_MSG(DBG_LEV_INFO, (TEXT("Info: pIniPort Freed %p."), pIniPort));

                delete pIniPort;
            }
    
            bRet = TRUE;

        } else {

            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: _inet_delete_port: Port in use: Name(%s)"), lpszPortName));
            SetLastError(ERROR_BUSY);
        }

    } else {

        DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: _inet_delete_port: Unrecognized PortName: Name(%s)"), lpszPortName));
        SetLastError(ERROR_UNKNOWN_PORT);
    }

    return bRet;
}

/*****************************************************************************\
* _inet_is_xcv_open
*
* Check whether it is a XCV Open
*
\*****************************************************************************/
BOOL
CInetMon::_inet_is_xcv_open (
    LPCTSTR     lpszPortName,
    LPTSTR      *ppszServerName,
    LPTSTR      *ppszRealPortName,
    LPBOOL      pbXcv)
{
    static CONST TCHAR cchSlash = _T ('\\');
    static CONST TCHAR cszXcvPort[] = _T (",XcvPort ");
    static CONST DWORD cdwXcvPortLen = (sizeof (cszXcvPort) / sizeof (TCHAR)) - 1;
    BOOL bRet = TRUE;
    LPCTSTR pServerStart = NULL;
    LPTSTR pServerEnd = NULL;
    LPTSTR pszServerName = NULL;
    LPTSTR pszRealPortName = NULL;


    // "\\Server\,XcvPort Object_" */

    DWORD dwLen = lstrlen (lpszPortName);
    *pbXcv = FALSE;

    if (dwLen > cdwXcvPortLen + 1) {
        
        if (lpszPortName[0] == _T (',')) {
            // No Server
            pServerEnd = (LPTSTR) lpszPortName;
        }
        else if (lpszPortName[0] == cchSlash && lpszPortName[1] == cchSlash)  {

            pServerStart = lpszPortName + 2;
            if (pServerEnd = _tcschr (pServerStart, cchSlash))
                pServerEnd ++;
        }
        else {
            return bRet;
        }

        if (pServerEnd && ! _tcsncmp (pServerEnd, cszXcvPort, cdwXcvPortLen)) {

            LPCTSTR pPortStart = pServerEnd + cdwXcvPortLen;

            if (pServerStart) {
                pszServerName = new TCHAR [(pServerEnd - 1) - pServerStart + 1];
                if (!pszServerName) {
                    bRet = FALSE;
                }
                else {
                    _tcsncpy (pszServerName, pServerStart, pServerEnd - 1 - pServerStart);
                    pszServerName[pServerEnd - 1 - pServerStart] = 0;
                }
            }
            
            if (bRet) {
                pszRealPortName = new TCHAR [lstrlen (pPortStart) + 1];

                if (!pszRealPortName) 
                    bRet = FALSE;
                else {
                    lstrcpy (pszRealPortName, pPortStart);
                    *pbXcv = TRUE;
                }
            }


            if (!bRet) {
                if (pszServerName) {
                    delete [] pszServerName;
                    pszServerName = NULL;
                }
            }

            *ppszServerName = pszServerName;
            *ppszRealPortName = pszRealPortName;

        }

    }

    return bRet;
}

PCINETMONPORT 
CInetMon::InetmonOpenPort(
    LPCTSTR lpszPortName, 
    PBOOL   pbXcv)
{
    PCINETMONPORT   pIniPort = NULL;
    PCPORTMGR       pPortMgr = NULL;
    DWORD           dwLE;

    *pbXcv = FALSE;

    semCheckCrit();

    if (_inet_validate_portname(lpszPortName)) {
#ifdef WINNT32
        // Let's first look to see if it is a XCV call

        LPTSTR pszServerName = NULL;
        LPTSTR pszRealPortName = NULL;
        BOOL bXcv;

        if (_inet_is_xcv_open (lpszPortName, &pszServerName, &pszRealPortName, &bXcv) && bXcv) {

            if (pIniPort = _inet_find_port(pszRealPortName)) {
                
                if (!pIniPort->m_bDeletePending) {
                    // The refrernce to the iniport is not changed, since the client may open a XCV handle
                    // to delete the port
                    //
                    *pbXcv = TRUE;
                }
                else {
                    DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : InetmonOpenPort (XCV) : Open deleted port: Port(%s)"), lpszPortName));
                    SetLastError(ERROR_INVALID_NAME);
                }

                // This is a valid XcvOpen
                if (pszServerName) {
                    delete [] pszServerName;
                }                           
                if (pszRealPortName) {
                    delete [] pszRealPortName;
                }                          
                
                return pIniPort;
            }
        }

#endif

        // Let's first look to see if this port is already in the
        // list.  If not, then add it to the list and continue with
        // the open.
        //
        if ((pIniPort = _inet_find_port(lpszPortName)) == NULL) {

            semLeaveCrit();
            // Leave the critical section becuase the following call will hit the network
            pPortMgr = new CPortMgr;

            if (pPortMgr != NULL) { 
                if (! pPortMgr->Create (lpszPortName)) {
                    delete (pPortMgr);
                    pPortMgr = NULL;
                }
            }

            dwLE = GetLastError ();
            semEnterCrit();

            if (! (pPortMgr)) {
                // The connection is invalid

                DBG_MSG(DBG_LEV_ERROR, (TEXT("Err: InetmonOpenPort : PortMgrCreate Failed: LastError(%d)"), GetLastError()));

                if (dwLE != ERROR_ACCESS_DENIED &&
                    dwLE != ERROR_INVALID_PRINTER_NAME &&
                    dwLE != ERROR_INVALID_NAME) {

                    dwLE = ERROR_PRINTER_NOT_FOUND;
                }

#ifndef WINNT32
                // Win9X will not allow a RPC printer-name
                // to install unless the error is ERROR_INVALID_NAME.
                //
                if (dwLE == ERROR_INVALID_PRINTER_NAME)
                    dwLE = ERROR_INVALID_NAME;
#endif

                SetLastError ( dwLE );

                goto exit_openport;
            }

            if (_inet_create_port(lpszPortName, pPortMgr) == FALSE) {

                DBG_MSG(DBG_LEV_ERROR, (TEXT("Err: InetmonOpenPort : Add Port Failed: LastError(%d)"), GetLastError()));
                SetLastError(ERROR_INVALID_NAME);

                goto exit_openport;
            }
        } 


        if (pIniPort || (pIniPort = _inet_find_port(lpszPortName))) {

            if (!pIniPort->m_bDeletePending) {
                // 
                // We stop increasing the ref count since the open handles 
                // won't have affect on the port deletion, i.e. the port
                // may be deleted even when there are open handles.
                // 
                // pIniPort->m_cRef ++;

                //
                //  Increase the printer open handle ref count. This 
                //  count is used to manage the life time of the PCINETMONPORT
                //  data structure. i.e. if the port is deleted when there are
                //  open handles, PCINETMONPORT is not freed until 
                //
                //  pIniPort->m_cPrinterRef == 0
                //

                pIniPort->IncPrinterRef ();

            }
            else {
                DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : InetmonOpenPort : Open deleted port: Port(%s)"), lpszPortName));
                SetLastError(ERROR_INVALID_NAME);
            }


        } else {

            DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : InetmonOpenPort : Invalid Name: Port(%s)"), lpszPortName));
            SetLastError(ERROR_INVALID_NAME);
        }
    }

exit_openport:

    return pIniPort;
}

BOOL 
CInetMon::InetmonReleasePort(
    PCINETMONPORT   pIniPort)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: InetmonReleasePort: pIniPort(%08lX)"), pIniPort));

    semCheckCrit();
    
    // Validate the port and proceed to close the port.
    //
    pIniPort->DecPrinterRef ();

    if (pIniPort->m_bDeletePending && pIniPort->m_cPrinterRef == 0) {
        // 
        // There is no open handles, free PCINETMONPORT
        //

        DBG_MSG(DBG_LEV_INFO, (TEXT("Info: InetmonReleasePort free pIniPort  %p."), pIniPort));

        delete pIniPort;
    }

    return TRUE;
}

/*****************************************************************************\
* InetmonClosePort
*
* Close the internet connection.
*
\*****************************************************************************/
BOOL 
CInetMon::InetmonClosePort(
    PCINETMONPORT   pIniPort,
    HANDLE          hPrinter)
{

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: InetmonClosePort: pIniPort(%08lX)"), pIniPort));

    semCheckCrit();
        
    pIniPort->ClosePort (hPrinter);
    
    if (pIniPort->m_bDeletePending && pIniPort->m_cPrinterRef == 0) {
        // 
        // There is no open handles, free PCINETMONPORT
        //

        DBG_MSG(DBG_LEV_INFO, (TEXT("Info: pIniPort Freed %p."), pIniPort));
        
        delete pIniPort;
    }

    return TRUE;
}

/*****************************************************************************\
* InetmonEnumPorts
*
* Enumerate the ports registered in our list.
*
\*****************************************************************************/
BOOL 
CInetMon::InetmonEnumPorts(
    LPTSTR  lpszServerName,
    DWORD   dwLevel,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    PCINETMONPORT   pIniPort;
    DWORD           cb;
    LPBYTE          pEnd;
    DWORD           dwError = ERROR_SUCCESS;

    semCheckCrit();

    // Traverse the list to build the size of the entire list.
    //
    cb = 0;

    pIniPort = m_pPortList->pIniFirstPort;

    while (pIniPort) {

        cb += pIniPort->_inet_size_entry(dwLevel);

        pIniPort = pIniPort->m_pNext;
    }


    // Store the size of the list (This is the size needed).
    //
    *pcbNeeded = cb;


    // If the size of the list is capable of being stored in the buffer
    // passed in, then we can return the entries.
    //
    if (cb <= cbBuf) {

        pEnd = pPorts + cbBuf;

        *pcReturned = 0;

        pIniPort = m_pPortList->pIniFirstPort;

        while (pIniPort) {

            pEnd = pIniPort->_inet_copy_entry(dwLevel, pPorts, pEnd);

            switch (dwLevel) {

            case PRINT_LEVEL_1:
                pPorts += sizeof(PORT_INFO_1);
                break;

            case PRINT_LEVEL_2:
                pPorts += sizeof(PORT_INFO_2);
                break;
            }

            pIniPort = pIniPort->m_pNext;

            (*pcReturned)++;
        }

    } else {

        dwError = ERROR_INSUFFICIENT_BUFFER;
    }

    if (dwError != ERROR_SUCCESS) {
        SetLastError(dwError);
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************\
* InetmonDeletePort
*
* Deletes a port from the INIMONPORT list.
*
\*****************************************************************************/
BOOL 
CInetMon::InetmonDeletePort(
    LPCTSTR lpszPortName,
    HWND    hWnd,
    LPCTSTR lpszMonitorName)
{
    BOOL bRet = FALSE;

    semCheckCrit();

    if (_inet_validate_portname(lpszPortName)) 
        bRet = _inet_delete_port(lpszPortName);

    return bRet;
}


/*****************************************************************************\
* InetmonAddPort
*
* Adds a port to the INIMONPORT list.
*
\*****************************************************************************/
BOOL 
CInetMon::InetmonAddPort(
    LPCTSTR lpszPortName,
    LPCTSTR lpszMonitorName)
{
    BOOL bRet = FALSE;
    PCPORTMGR pPortMgr = NULL;

    semCheckCrit();

    // If the port is not-found, then we can add it.  Otherwise,
    // the port already exists.
    //
    if (_inet_validate_portname(lpszPortName)) {

        if (_inet_find_port(lpszPortName) == NULL) {

            pPortMgr = new CPortMgr;
            
            if (pPortMgr != NULL) {
                if (!pPortMgr->Init (lpszPortName)) {
                    delete pPortMgr;
                    pPortMgr = NULL;
                }

                if (pPortMgr) {
                    bRet = (_inet_create_port(lpszPortName, pPortMgr) != NULL);
                }
            }
        }
    }

    return bRet;
}


/*****************************************************************************\
* InetmonFindPort
*
* Looks for port in INIMONPORT list.
*
\*****************************************************************************/
PCINETMONPORT 
CInetMon::InetmonFindPort(
    LPCTSTR lpszPortName)
{
    PCINETMONPORT hPort = NULL;

    semCheckCrit();

    if (_inet_validate_portname(lpszPortName))
        hPort = _inet_find_port(lpszPortName) ;

    return hPort;
}

/********************************************************************************
** End of FIle (inetpp.c)
********************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\inetpp.h ===
/*****************************************************************************\
* MODULE: inetpp.h
*
* Header file for the INETPP provider routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _INETPP_H
#define _INETPP_H

// Buffer sizes/Constants.
//
#define MAX_INET_BUFFER     256
#define MIN_DISK_SPACE     8192
#define MAX_IPP_BUFFER     1024
#define MAX_INET_RETRY        3    // 3 times for internet-connect.


// Error return codes for Request-Auth-Sends.
//
#define RET_SUCESS  0
#define RET_FAILURE 1


// Return value for the customized authentication dialog
//
#define AUTHDLG_OK         1
#define AUTHDLG_CANCEL     2
#define AUTHDLG_TIMEOUT    3
#define AUTHDLG_ERROR      4

// Flags.
//
#define INETPP_REQ_FLAGS (INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_RELOAD)


// Offsets into structure.  Used for the PORT_INFO fields in obtaining
// port-information.
//
#ifdef offsetof
#undef offsetof
#endif
#define offsetof(type, identifier)  ((DWORD)(UINT_PTR)(&(((type)0)->identifier)))

// Function types for the HTTP calls in WININET.DLL.
//
typedef BOOL      (WINAPI *PFNHTTPQUERYINFO)         (HINTERNET, DWORD, LPVOID, LPDWORD, LPDWORD);
typedef HINTERNET (WINAPI *PFNINTERNETOPENURL)       (HINTERNET, LPCTSTR, LPCTSTR, DWORD, DWORD, DWORD_PTR);
typedef DWORD     (WINAPI *PFNINTERNETERRORDLG)      (HWND, HINTERNET, DWORD, DWORD, LPVOID);
typedef BOOL      (WINAPI *PFNHTTPSENDREQUEST)       (HINTERNET, LPCTSTR, DWORD, LPVOID, DWORD);
#ifdef UNIMPLEMENTED
typedef BOOL      (WINAPI *PFNHTTPSENDREQUESTEX)     (HINTERNET, LPINTERNET_BUFFERS, LPINTERNET_BUFFERS, DWORD, DWORD_PTR);
#else
typedef BOOL      (WINAPI *PFNHTTPSENDREQUESTEX)     (HINTERNET, LPINTERNET_BUFFERSA, LPINTERNET_BUFFERS, DWORD, DWORD_PTR);
#endif
typedef BOOL      (WINAPI *PFNINTERNETREADFILE)      (HINTERNET, LPVOID, DWORD, LPDWORD);
typedef BOOL      (WINAPI *PFNINTERNETWRITEFILE)     (HINTERNET, LPCVOID, DWORD, LPDWORD);
typedef BOOL      (WINAPI *PFNINTERNETCLOSEHANDLE)   (HINTERNET);
typedef HINTERNET (WINAPI *PFNINTERNETOPEN)          (LPCTSTR, DWORD, LPCTSTR, LPCTSTR, DWORD);
typedef HINTERNET (WINAPI *PFNINTERNETCONNECT)       (HINTERNET, LPCTSTR, INTERNET_PORT, LPCTSTR, LPCTSTR, DWORD, DWORD, DWORD_PTR);
typedef HINTERNET (WINAPI *PFNHTTPOPENREQUEST)       (HINTERNET, LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR *, DWORD, DWORD_PTR);
typedef BOOL      (WINAPI *PFNHTTPADDREQUESTHEADERS) (HINTERNET, LPCTSTR, DWORD, DWORD);
typedef BOOL      (WINAPI *PFNHTTPENDREQUEST)        (HINTERNET, LPINTERNET_BUFFERS, DWORD, DWORD_PTR); 
typedef BOOL      (WINAPI *PFNINTERNETSETOPTION)     (HINTERNET, DWORD, LPVOID, DWORD);


// InetmonSendReq Response callback.
//
typedef BOOL (CALLBACK *IPPRSPPROC)(CAnyConnection *pConnection, 
                                    HINTERNET hReq, 
                                    PCINETMONPORT pIniPort, 
                                    LPARAM lParam);


class CInetMon {
public:

    CInetMon ();
    ~CInetMon ();

    inline BOOL
    bValid (VOID) CONST { return m_bValid; }
    
    BOOL 
    InetmonSendReq(
        HANDLE     hPort,
        LPBYTE     lpIpp,
        DWORD      cbIpp,
        IPPRSPPROC pfnRsp,
        LPARAM     lParam,
        BOOL       bLeaveCrit);

    PCINETMONPORT 
    InetmonOpenPort(
        LPCTSTR lpszPortName, 
        PBOOL   pbXcv);

    BOOL 
    InetmonReleasePort(
        PCINETMONPORT   pIniPort);

    BOOL 
    InetmonClosePort(
        PCINETMONPORT hPort,
        HANDLE hPrinter);

    BOOL 
    InetmonEnumPorts(
        LPTSTR  lpszServerName,
        DWORD   dwLevel,
        LPBYTE  pPorts,
        DWORD   cbBuf,
        LPDWORD pcbNeeded,
        LPDWORD pcReturned);

    BOOL 
    InetmonDeletePort(
        LPCTSTR lpszPortName,
        HWND    hWnd,
        LPCTSTR lpszMonitorName);

    BOOL 
    InetmonAddPort(
        LPCTSTR lpszPortName,
        LPCTSTR lpszMonitorName);

    PCINETMONPORT 
    InetmonFindPort(
        LPCTSTR lpszPortName);

private:

    // Port-List Structure.  This defines the global-header for the
    // print-provider port-list.
    //
    typedef struct _INIMONPORTLIST {
        HINTERNET       hSession;           // Handle for session connection.
        int             cRef;               // Count of hSession opens.
        PCINETMONPORT   pIniFirstPort;      // List of port-entries.
    } INIMONPORTLIST;
    
    typedef INIMONPORTLIST *PINIMONPORTLIST;
    
    inline BOOL 
    _inet_validate_portname(
        LPCTSTR         lpszPortName);

    PCINETMONPORT 
    _inet_find_port(
        LPCTSTR         lpszPortName);

    PCINETMONPORT 
    _inet_create_port(
        LPCTSTR         lpszPortName,
        PCPORTMGR       pPortMgr);

    BOOL 
    _inet_delete_port(
        LPCTSTR         lpszPortName);

    DWORD 
    _inet_size_entry(
        PCINETMONPORT   pIniPort,
        DWORD           dwLevel);

    LPBYTE 
    _inet_copy_entry(
        PCINETMONPORT   pIniPort,
        DWORD           dwLevel,
        LPBYTE          pPortInfo,
        LPBYTE          pEnd);

    BOOL
    _inet_is_xcv_open (
        LPCTSTR         lpszPortName,
        LPTSTR          *ppszServerName,
        LPTSTR          *ppszRealPortName,
        LPBOOL          pbXcv);

    BOOL            m_bValid;
    PINIMONPORTLIST m_pPortList;

};

typedef class CInetMon* PCINETMON;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\inetport.h ===
/*****************************************************************************\
* MODULE: inetpp.h
*
* Header file for the INETPP provider routines.
*
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*   13-Sep-2000 weihaic Created
*
\*****************************************************************************/

#ifndef _INETPORT_H
#define _INETPORT_H

typedef class CInetMonPort* PCINETMONPORT;
class GetPrinterCache;
class EnumJobsCache;

class CInetMonPort {
public:
    CInetMonPort (
        LPCTSTR     lpszPortName,
        LPCTSTR     lpszDevDesc,
        PCPORTMGR   pPortMgr);

    ~CInetMonPort ();

    inline BOOL
    bValid (VOID) CONST { return m_bValid; };


    VOID
    IncRef ();
    
    VOID
    DecRef ();

    VOID
    IncPrinterRef ();

    VOID
    DecPrinterRef ();
    
    BOOL 
    SendReq(
        LPBYTE     lpIpp,
        DWORD      cbIpp,
        IPPRSPPROC pfnRsp,
        LPARAM     lParam,
        BOOL       bLeaveCrit);

    BOOL 
    SendReq(
        CStream    *pStream,
        IPPRSPPROC pfnRsp,
        LPARAM     lParam,
        BOOL       bLeaveCrit);

    BOOL 
    ClosePort(
        HANDLE hPrinter);

    BOOL 
    StartDocPort(
        DWORD   dwLevel,
        LPBYTE  pDocInfo,
        PJOBMAP pjmJob);

    BOOL 
    EndDocPort(
        PJOBMAP pjmJob);

    BOOL 
    WritePort(
        PJOBMAP pjmJob,
        LPBYTE  lpData,
        DWORD   cbData,
        LPDWORD pcbWr);
    
    BOOL 
    AbortPort(
        PJOBMAP pjmJob);

    LPCTSTR 
    GetPortName(
        VOID);

    PJOBMAP* 
    GetPJMList(
        VOID);

#if (defined(WINNT32))
    DWORD
    IncUserRefCount( 
        PCLOGON_USERDATA hUser );
#endif
    
    VOID 
    FreeGetPrinterCache (
        VOID);

    BOOL
    BeginReadGetPrinterCache (
        PPRINTER_INFO_2 *ppInfo2);

    VOID
    EndReadGetPrinterCache (
        VOID);

    VOID 
    InvalidateGetPrinterCache (
        VOID);

    void 
    FreeEnumJobsCache (
        VOID);

    BOOL
    BeginReadEnumJobsCache (
        LPPPJOB_ENUM *ppje);

    VOID
    EndReadEnumJobsCache (
        VOID);


    void 
    InvalidateEnumJobsCache (
        VOID);

    BOOL
    ReadFile (
        CAnyConnection *pConnection,
        HINTERNET hReq,
        LPVOID    lpvBuffer,
        DWORD     cbBuffer,
        LPDWORD   lpcbRd);

#if (defined(WINNT32))
    BOOL
    GetCurrentConfiguration (
        PINET_XCV_CONFIGURATION pXcvConfiguration);
    
    BOOL
    ConfigurePort (
        PINET_XCV_CONFIGURATION pXcvConfigurePortReqData,
        PINET_CONFIGUREPORT_RESPDATA pXcvAddPortRespData,
        DWORD cbSize,
        PDWORD cbSizeNeeded);

    HANDLE
    CreateTerminateEvent (
        VOID);

    BOOL
    WaitForTermination (
        DWORD dwWaitTime);

#endif // #if (defined(WINNT32))

    inline BOOL
    bDeletePending (
        VOID) CONST {return m_bDeletePending;};

    inline VOID
    SetPowerUpTime (
        time_t t) {m_dwPowerUpTime = t;};

    inline time_t
    GetPowerUpTime (
        VOID) CONST {return m_dwPowerUpTime;};
    

    friend class CInetMon;
    
protected:

    inline PCINETMONPORT
    GetNext (
        VOID) { return m_pNext;};

    inline VOID 
    SetNext (
        PCINETMONPORT pNext) { m_pNext = pNext;};
        
    DWORD 
    _inet_size_entry(
        DWORD       dwLevel);

    LPBYTE 
    _inet_copy_entry(
        DWORD       dwLevel,
        LPBYTE      pPortInfo,
        LPBYTE      pEnd);

    BOOL 
    _inet_req_jobstart(
        PIPPREQ_PRTJOB ppj,
        PJOBMAP        pjmJob);

private:

#if (defined(WINNT32))
    VOID 
    InvalidateGetPrinterCacheForUser(
        HANDLE hUser); 
    
    void 
    InvalidateEnumJobsCacheForUser(
        HANDLE hUser) ;

#endif // #if (defined(WINNT32))


    BOOL                   m_bValid;
    DWORD                  m_cb;               // Size of struct plus <portname>
    PCINETMONPORT          m_pNext;            // Pointer to next port entry
    DWORD                  m_cRef;             // Port reference count.
    DWORD                  m_cPrinterRef;      // Printer handle ref count.
    LPTSTR                 m_lpszName;         // Name of port output device
    LPTSTR                 m_lpszDesc;         // Description of output device
    LPTSTR                 m_lpszHost;         // Name of host connection
    LPTSTR                 m_lpszShare;        // Name of share (after host)
    GetPrinterCache        *m_pGetPrinterCache;          // Handle of the cache
    EnumJobsCache          *m_pEnumJobsCache;  // Handle of the cache for enumjobs
    BOOL                   m_bCheckConnection; // Need to check connection
    PJOBMAP                m_pjmList;          //
    PCPORTMGR              m_pPortMgr;         // Handle of port manager, pointer to PortMgr class
    BOOL                   m_bDeletePending;   // TRUE if the port is being deleted.
    time_t                 m_dwPowerUpTime;    // This is the time the printer was originally
                                               // powered up, relative to UCT
    HANDLE                 m_hTerminateEvent;  // Terminate event
} ;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\inetwrap.h ===
/*****************************************************************************\
* MODULE: inetwrap.h
*
* Header file for wininet wrapper routines.  Until the library can support
* Unicode, this module is necessary for NT.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*   15-Jul-1998 v-chrisw    Allow safe DelayLoad of wininet.
*
\*****************************************************************************/
#ifndef INETWRAP_H
#define INETWRAP_H

#define WCtoMB(pszUStr, pszAStr, uSize)     \
    WideCharToMultiByte(CP_ACP,             \
                        0,                  \
                        (LPWSTR)pszUStr,    \
                        -1,                 \
                        (LPSTR)pszAStr,     \
                        uSize,              \
                        NULL,               \
                        NULL)



HINTERNET wrapInternetOpen(
    LPCTSTR lpszAgent,
    DWORD   dwAccess,
    LPCTSTR lpszProxyName,
    LPCTSTR lpszProxyBypass,
    DWORD   dwFlags);

HINTERNET wrapInternetOpenUrl(
    HINTERNET hInternet,
    LPCTSTR   lpszUrl,
    LPCTSTR   lpszHeaders,
    DWORD     dwHeaderLen,
    DWORD     dwFlags,
    DWORD_PTR dwContext);

HINTERNET wrapInternetConnect(
    HINTERNET     hSession,
    LPCTSTR       lpszServerName,
    INTERNET_PORT nServerPort,
    LPCTSTR       lpszUserName,
    LPCTSTR       lpszPassword,
    DWORD         dwService,
    DWORD         dwFlags,
    DWORD_PTR     dwContext);

BOOL wrapHttpQueryInfo(
    HINTERNET hRequest,
    DWORD     dwInfoLevel,
    LPVOID    lpvBuffer,
    LPDWORD   lpdwBufferLen,
    LPDWORD   lpdwIndex);

BOOL wrapHttpSendRequest(
    HINTERNET hRequest,
    LPCTSTR   lpszHeaders,
    DWORD     dwHeaderLen,
    LPVOID    lpvOptional,
    DWORD     dwOptionalLen);

BOOL wrapHttpSendRequestEx(
    HINTERNET          hRequest,
    LPINTERNET_BUFFERS lpBufIn,
    LPINTERNET_BUFFERS lpBufOut,
    DWORD              dwFlags,
    DWORD_PTR          dwContext);

HINTERNET wrapHttpOpenRequest(
    HINTERNET hConnect,
    LPCTSTR   lpszVerb,
    LPCTSTR   lpszObjectName,
    LPCTSTR   lpszVersion,
    LPCTSTR   lpszReferer,
    LPCTSTR   *lplpszAccept,
    DWORD     dwFlags,
    DWORD_PTR dwContext);

BOOL wrapHttpAddRequestHeaders(
    HINTERNET hRequest,
    LPCTSTR   lpszHeaders,
    DWORD     cbLength,
    DWORD     dwModifiers);

BOOL wrapHttpEndRequest(
    HINTERNET          hRequest,
    LPINTERNET_BUFFERS lpBuf,
    DWORD              dwFlags,
    DWORD_PTR          dwContext);

BOOL wrapInternetSetOption(
    HINTERNET hRequest,
    IN DWORD  dwOption,
    IN LPVOID lpBuffer,
    IN DWORD  dwBufferLength);

BOOL wrapInternetCloseHandle(
    HINTERNET hHandle);

BOOL wrapInternetReadFile(
    HINTERNET hRequest,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbRd);

BOOL wrapInternetWriteFile(
    HINTERNET hRequest,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbWr);

DWORD wrapInternetErrorDlg(
    HWND      hWnd,
    HINTERNET hReq,
    DWORD     dwError,
    DWORD     dwFlags,
    LPVOID    pvParam);


#define InetInternetOpen          wrapInternetOpen
#define InetInternetOpenUrl       wrapInternetOpenUrl
#define InetInternetConnect       wrapInternetConnect
#define InetHttpQueryInfo         wrapHttpQueryInfo
#define InetHttpSendRequest       wrapHttpSendRequest
#define InetHttpSendRequestEx     wrapHttpSendRequestEx
#define InetHttpOpenRequest       wrapHttpOpenRequest
#define InetHttpAddRequestHeaders wrapHttpAddRequestHeaders
#define InetHttpEndRequest        wrapHttpEndRequest
#define InetInternetSetOption     wrapInternetSetOption
#define InetInternetCloseHandle   wrapInternetCloseHandle
#define InetInternetReadFile      wrapInternetReadFile
#define InetInternetWriteFile     wrapInternetWriteFile
#define InetInternetErrorDlg      wrapInternetErrorDlg


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\globals.h ===
/*****************************************************************************\
* MODULE: globals.h
*
* Global header file.  Any global variables should be localized to this
* location.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/


// Global variables.
//
extern HINSTANCE        g_hInst;
extern CRITICAL_SECTION g_csMonitorSection;
extern DWORD            g_dwCritOwner;
extern DWORD            g_dwJobLimit;
extern BOOL             g_bUpgrade;
#ifdef WINNT32
extern CRITICAL_SECTION g_csCreateSection;
extern HANDLE           g_eResetConnections;
extern DWORD            g_dwConCount;
#endif

extern CCriticalSection  *g_pcsEndBrowserSessionLock;

// Constant string identifiers.
//
extern TCHAR g_szMachine[];

#ifdef WINNT32

// Holds other network names
//
extern LPWSTR  *g_ppszOtherNames;
extern DWORD   g_cOtherNames;

#endif

extern LPTSTR g_szRegProvider;
extern LPTSTR g_szRegPrintProviders;
extern TCHAR g_szDefSplDir [];
extern TCHAR g_szDisplayStr[];

extern CONST TCHAR g_szSplDir9X [];
extern CONST TCHAR g_szSplPfx   [];

extern CONST TCHAR g_szUserAgent[];
extern CONST TCHAR g_szLocalPort[];
extern CONST TCHAR g_szDisplayName[];
extern CONST TCHAR g_szLibraryName[];
extern CONST TCHAR g_szWinInetDll[];
extern CONST TCHAR g_szUriPrinters[];
extern CONST TCHAR g_szPOST[];
extern CONST TCHAR g_szGET[];
extern CONST TCHAR g_szContentLen[];
extern CONST TCHAR g_szContentType[];
extern CONST TCHAR g_szEmptyString[];
extern CONST TCHAR g_szDescription[];
extern CONST TCHAR g_szComment[];
extern CONST TCHAR g_szProviderName[];
extern CONST TCHAR g_szNewLine[];
extern CONST TCHAR g_szProcessName[];
extern CONST TCHAR g_szConfigureMsg[];
extern CONST TCHAR g_szRegPorts[];
extern CONST TCHAR g_szAuthDlg[];
extern CONST TCHAR g_szDocRemote[];
extern CONST TCHAR g_szDocLocal[];

extern CONST TCHAR g_szAuthMethod[];
extern CONST TCHAR g_szAuthMethod[];
extern CONST TCHAR g_szUserName[];
extern CONST TCHAR g_szPassword[];
extern CONST TCHAR g_szPerUserPath[];


// Http Version Number
//
extern CONST TCHAR g_szHttpVersion[];

// Internet API strings.  These MUST NOT be unicode enabled.
//
extern CONST CHAR g_szInternetCloseHandle[];
extern CONST CHAR g_szInternetErrorDlg[];
extern CONST CHAR g_szInternetReadFile[];
extern CONST CHAR g_szInternetWriteFile[];
extern CONST CHAR g_szHttpQueryInfo[];
extern CONST CHAR g_szInternetOpenUrl[];
extern CONST CHAR g_szHttpSendRequest[];
extern CONST CHAR g_szHttpSendRequestEx[];
extern CONST CHAR g_szInternetOpen[];
extern CONST CHAR g_szInternetConnect[];
extern CONST CHAR g_szHttpOpenRequest[];
extern CONST CHAR g_szHttpAddRequestHeaders[];
extern CONST CHAR g_szHttpEndRequest[];
extern CONST CHAR g_szInternetSetOption[];


// Internet API for controling the Url output.
//
extern PFNHTTPQUERYINFO         g_pfnHttpQueryInfo;
extern PFNINTERNETOPENURL       g_pfnInternetOpenUrl;
extern PFNINTERNETERRORDLG      g_pfnInternetErrorDlg;
extern PFNHTTPSENDREQUEST       g_pfnHttpSendRequest;
extern PFNHTTPSENDREQUESTEX     g_pfnHttpSendRequestEx;
extern PFNINTERNETREADFILE      g_pfnInternetReadFile;
extern PFNINTERNETWRITEFILE     g_pfnInternetWriteFile;
extern PFNINTERNETCLOSEHANDLE   g_pfnInternetCloseHandle;
extern PFNINTERNETOPEN          g_pfnInternetOpen;
extern PFNINTERNETCONNECT       g_pfnInternetConnect;
extern PFNHTTPOPENREQUEST       g_pfnHttpOpenRequest;
extern PFNHTTPADDREQUESTHEADERS g_pfnHttpAddRequestHeaders;
extern PFNHTTPENDREQUEST        g_pfnHttpEndRequest;
extern PFNINTERNETSETOPTION     g_pfnInternetSetOption;


// IPP string which uses NULL-command to server.
//
#define g_szUriIPP g_szUriPrinters
#define MAXDWORD 0xffffffff

#define COMMITTED_STACK_SIZE (1024*32)

extern PCINETMON gpInetMon;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\lusrdata.cxx ===
/*****************************************************************************\
* MODULE:       lusrdata.cxx
*
* PURPOSE:      This specialises the user data class to keep track of data
*               useful for the user port reference count.
*               
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     1/11/2000  mlawrenc    Implemented
*
\*****************************************************************************/

#include "precomp.h"

#if (defined(WINNT32))

#include "priv.h"

CLogonUserData::CLogonUserData() 
/*++

Routine Description:
    Default constructor for Logon User Data, once the parent
    gets the SID, we get the session ID.   

--*/
    : CUserData() ,
      m_ulSessionId(0),
      m_dwRefCount(1) {
        
    if (m_bValid) {  // We get the user SID successfully
        m_bValid = _GetClientSessionId( );
    }
}

BOOL
CLogonUserData::_GetClientSessionId(
    VOID )
/*++

Routine Description:

    Set the session ID from the client token and set it if we can get it.

Return Value:

    TRUE if we could get the session ID, false otherwise.

--*/
{
    BOOL          bResult;
    HANDLE        hToken;
    ULONG         ulSessionId, ulReturnLength;

    //
    // We should be impersonating the client, so we will get the
    // SessionId from our token.
    //

    bResult = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_QUERY,
                 FALSE,              // Use impersonation
                 &hToken
                 );

    if( bResult ) {

        //
        // Query the SessionID from the token added by HYDRA
        //
        bResult = GetTokenInformation(
             hToken,
             (TOKEN_INFORMATION_CLASS)TokenSessionId,
             &m_ulSessionId,
             sizeof(m_ulSessionId),
             &ulReturnLength
             );

        m_ulSessionId = bResult ? m_ulSessionId : 0;

        CloseHandle( hToken );

        bResult = TRUE;
    }

    return bResult;
}


CLogonUserData &
CLogonUserData::operator=(
    const CLogonUserData &rhs) {

    this->CUserData::operator=( rhs );

    m_ulSessionId = rhs.m_ulSessionId;

    return *this;
}
    
int 
CLogonUserData::Compare( 
    const CLogonUserData *second) const 
/*++

Routine Description:

    Compare the CLogonUser with another.
    
Arguments:
    second - The CLogonUser we are comparing this with.    

Return Value:

    TRUE if they are different, FALSE if they are the same.

--*/
    {

    if (m_bValid && second->m_bValid) {
        return m_ulSessionId != second->m_ulSessionId ||
               RtlEqualSid(m_pSid, second->m_pSid) == FALSE;
    } else {
        return TRUE;
    }
}

#endif  // #if (defined(WINNT32))

/****************************************************************
** End of File (lusrdata.cxx)
****************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ntcon.cxx ===
/*****************************************************************************\
* MODULE: iecon.cxx
*
* The module contains class for connections using IE's default configuration
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   07/31/98    Weihaic     Created
*
\*****************************************************************************/


#include "precomp.h"
#include "priv.h"

CNTConnection::CNTConnection (
    BOOL bSecure,
    INTERNET_PORT nServerPort,
    BOOL bIgnoreSecurityDlg):

    CAnyConnection (bSecure, nServerPort, bIgnoreSecurityDlg, AUTH_NT)
{
}

BOOL
CNTConnection::SendRequest(
    HINTERNET      hReq,
    LPCTSTR        lpszHdr,
    CStream        *pStream)
{
    static const DWORD dwMaxRetry = 3;

    BOOL    bRet = FALSE;
    DWORD   dwRet;
    DWORD   dwFlags;
    DWORD   i;

    dwFlags = FLAGS_ERROR_UI_FLAGS_NO_UI;

    for (i = 0; i < dwMaxRetry; i++ ) {
        bRet = CAnyConnection::SendRequest (hReq,
                                            lpszHdr,
                                            pStream);

        if (bRet || GetLastError () != ERROR_ACCESS_DENIED) {
            break;
        }


        dwRet = InetInternetErrorDlg(GetDesktopWindow(),
                                     hReq,
                                     bRet ? ERROR_SUCCESS : GetLastError(),
                                     dwFlags,
                                     NULL);
        if (dwRet != ERROR_INTERNET_FORCE_RETRY) {
            break;
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\portmgr.cxx ===
/*****************************************************************************\
* MODULE: portmgr.cxx
*
* The module contains routines for handling the http port connection
* for internet priting
*
* Copyright (C) 1996-1998 Microsoft Corporation
*
* History:
*   22-Jul-1996 WeihaiC     Created
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

// This the length used to fetch the authentication scheme. I don't see any reason
// that the authentication scheme could be longer.
#define MAX_SCHEME_LEN 255

CPortMgr::CPortMgr ():
    // Put all the private member variable here
    m_hSession (NULL),
    m_hConnect (NULL),
    m_lpszPassword (NULL),
    m_lpszUserName (NULL),
    m_lpszHostName (NULL),
    m_lpszUri (NULL),
    m_lpszPortName (NULL),
    m_bPortCreate (FALSE),
#ifdef WINNT32
    m_bForceAuthSupported (TRUE),   //We set it to be TRUE so that we will always try it.
    m_pPortSettingMgr (NULL),
    m_bSecure (FALSE),
    m_nPort (0),

#else
    m_dwAuthMethod (AUTH_UNKNOWN),
    m_dwConnectCount (0),
    m_pConnection (NULL),
#endif
    m_bValid (FALSE)

{
}

CPortMgr::~CPortMgr ()
{
    LocalFree (m_lpszPassword);
    LocalFree (m_lpszUserName);
    LocalFree (m_lpszHostName);
    LocalFree (m_lpszUri);
    LocalFree (m_lpszPortName);


#ifndef WINNT32
    if (m_pConnection) {

        // There is no check on the ref count on this handle,
        // but this should be fine because the destructor gets called
        //
        delete (m_pConnection);
    }
#endif

    m_hSession = NULL;
    m_hConnect = NULL;
}

#ifdef WINNT32

HINTERNET
CPortMgr::_OpenRequest (
    CAnyConnection *pConnection)
{
    HINTERNET hReq = NULL;

    if (pConnection && pConnection->OpenSession ()) {

        if (pConnection->Connect (m_lpszHostName)) {
            hReq = pConnection->OpenRequest (m_lpszUri);
        }
    }

    return hReq;
}

BOOL
CPortMgr::_CloseRequest (
    CAnyConnection *pConnection,
    HINTERNET hReq)
{
    BOOL bRet = FALSE;

    if (pConnection->CloseRequest (hReq)) {
        if (pConnection->Disconnect ()) {
            bRet = pConnection->CloseSession();
        }
    }
    return bRet;
}

#else
//Win9x

BOOL
CPortMgr::_Connect ()
{
    BOOL bRet = FALSE;

    Lock ();

    if (m_bValid && m_pConnection) {

        if (m_hSession == NULL) {
            m_hSession = m_pConnection->OpenSession ();
        }

        if (m_hSession) {

            if (!m_hConnect) {

                // No connection, so connect to it

                m_hConnect = m_pConnection->Connect (m_lpszHostName);
            }

            if (m_hConnect) {
                // Made a connection, increase the ref count
                m_dwConnectCount++;
                bRet = TRUE;
            }
        }
    }

    Unlock ();

    return bRet;
}


BOOL
CPortMgr::_Disconnect ()
{
    BOOL bRet = FALSE;

    DBG_ASSERT((m_dwConnectCount > 0), (TEXT("Err : PrtMgr::_DIsconnect: m_dwConnectCount == 0")));

    Lock ();

    if (m_pConnection) {
        if (--m_dwConnectCount == 0) {
            if (m_pConnection->Disconnect ()) {
                m_hConnect = NULL;

                bRet = m_pConnection->CloseSession();
                m_hSession = NULL;
            }
        }
    }

    Unlock ();

    return bRet;
}

HINTERNET
CPortMgr::_OpenRequest (
    CAnyConnection *pConnection)
{
    HINTERNET hReq = NULL;

    if (m_pConnection && _Connect())
        hReq = m_pConnection->OpenRequest (m_lpszUri);

    return hReq;
}

BOOL
CPortMgr::_CloseRequest (
    CAnyConnection *pConnection,
    HINTERNET hReq)
{
    BOOL bRet = FALSE;

    if (m_pConnection) {

        if (m_pConnection->CloseRequest (hReq)) {
            bRet = _Disconnect ();
        }
    }

    return bRet;
}

#endif
/*****************************************************************************\
* Function: SendRequest
*
* This function is to send an IPP request to an established connection
*
* The intension of the function is to send the request with specified
* authentication instead of anonymous even if anonymous is enabled.
* The alogortihm is as following
* 1. If it is anonymous, just send the request and return
* 2. Otherwise,
* 3. If m_bForceAuthSupported, send ForceAuth to turn off anonymous, otherwise, goto 4
* 3.a.    Issue Force Authentication
* 3.b.    If the return value is  401 access denied, perform proper retry and return
* 3.c.    Otherwise, (We don't get 401 access denied). If we get other errors, return FALSE
* 3.d.    Check the IPP response of the Forth Authentication
* 3.e.    If the IPP response is OK, we return TRUE
* 3.f.    Otherwise, (Not Supported), we assume that the server does not
*         support Force Authentication, so we marek m_bForceAuthSupported as FALSE
*         and  move on by returning a FALSE.
*
* 4. Send the real IPP request.
*
\*****************************************************************************/

BOOL
CPortMgr::_SendRequest (
    CAnyConnection  *pConnection,
    HINTERNET       hJobReq,
    CStream         *pStream)
{
    BOOL  bRet = FALSE;

    DWORD cbData;

    // Generate the Http header and indicate the size
    // of the data we're sending.
    //
    if (pStream->GetTotalSize (&cbData) && cbData) {

#ifdef WINNT32
        DWORD dwLE = ERROR_SUCCESS;
        DWORD dwAuthMethod = pConnection->GetAuthMethod ();

        // We need to force authentication if the method is NTLM or others
        if (m_bForceAuthSupported &&
            ( dwAuthMethod == AUTH_OTHER ||  dwAuthMethod == AUTH_NT)) {

            HINTERNET hReq;
            // Open a request and send force authentication IPP request

            if (hReq = pConnection->OpenRequest (m_lpszUri)) {

                bRet = _IppForceAuth (pConnection,
                                     hReq,
                                     m_lpszPortName,
                                     &dwAuthMethod);

                if (!bRet) {
                    dwLE = GetLastError ();
                }

                pConnection->CloseRequest (hReq);
            }

            if (m_bForceAuthSupported && !bRet && dwLE == ERROR_ACCESS_DENIED) {
                // If forth authentication is supported but the server authentication fails, we return an error

                DBG_MSG(DBG_LEV_ERROR, (TEXT("CPortMgr::_SendRequest : Failed (lasterror=%d)"), dwLE));

                SetLastError (dwLE);
                return bRet;
            }
        }
#endif

        if (pConnection->SendRequest (hJobReq,
                                     g_szContentType,
                                     pStream)) {
            bRet = TRUE;
        }
        else {

            DBG_MSG(DBG_LEV_ERROR, (TEXT("CPortMgr::_SendRequest : pConnection->SendRequest Failed (lasterror=%d)"),
                                    GetLastError ()));

        }
    }

    return bRet;
}

BOOL
CPortMgr::ReadFile (
    CAnyConnection *pConnection,
    HINTERNET hReq,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbRd)
{
    BOOL bRet = FALSE;

    if (m_bValid && pConnection) {
        bRet = pConnection->ReadFile (hReq, lpvBuffer, cbBuffer, lpcbRd);
    }

    return bRet;
}

#ifdef WINNT32
/*****************************************************************************\
* _IppForceAuthRsp (Local Callback Routine)
*
* Retrieves a forth-authentication response from the IPP server
*
\*****************************************************************************/
BOOL
CPortMgr::_IppForceAuthRsp(
    CAnyConnection *pConnection,
    HINTERNET      hReq,
    LPARAM         lParam)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_PRN lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen(IPP_RET_FORCEAUTH)) {

        while (TRUE) {

            cbRd = 0;
            if (pConnection->ReadFile (hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (!lpRsp) {
                        SetLastError (ERROR_INVALID_DATA);
                    }
                    else if ((bRet = lpRsp->bRet) == TRUE)
                        // This is from our server. We have already had the authentication
                        // established
                        bRet = TRUE;

                    else
                        SetLastError(lpRsp->dwLastError);

                    WebIppFreeMem(lpRsp);

                    goto EndValRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //

                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("CPortMgr::_IppForceAuthRsp Err : Receive Data Error (dwRet=%d, LE=%d)"),
                         dwRet, WebIppGetError(hIpp)));

                    SetLastError(ERROR_INVALID_DATA);

                    goto EndValRsp;
                }

            } else {

                goto EndValRsp;
            }
        }

EndValRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


BOOL
CPortMgr::_IppForceAuth (
    CAnyConnection  *pConnection,
    HINTERNET       hReq,
    LPCTSTR         lpszPortName,
    PDWORD          pdwAuthMethod)
{
    LPIPPREQ_GETPRN pgp;
    REQINFO         ri;
    DWORD           dwRet;
    LPBYTE          lpIpp;
    DWORD           cbIpp;
    DWORD           dwLE = ERROR_SUCCESS;
    BOOL            bRet = FALSE;
    DWORD           dwAuthMethod = pConnection->GetAuthMethod ();

    if (pgp = WebIppCreateGetPrnReq(0, lpszPortName)) {

        // Convert the request to IPP, and perform the
        // post.
        //
        ZeroMemory(&ri, sizeof(REQINFO));
        ri.cpReq = CP_UTF8;
        ri.idReq = IPP_REQ_FORCEAUTH;

        ri.fReq[0] = IPP_REQALL;
        ri.fReq[1] = IPP_REQALL;

        dwRet = WebIppSndData(IPP_REQ_FORCEAUTH,
                              &ri,
                              (LPBYTE)pgp,
                              pgp->cbSize,
                              &lpIpp,
                              &cbIpp);


        // The request-structure has been converted
        // to IPP format, so it is ready to go to
        // the server.
        //
        //
        if (dwRet == WEBIPP_OK) {

            bRet = pConnection->SendRequest (hReq, g_szContentType, cbIpp, lpIpp);

            if (!bRet) {
                // Check if it is an access denied or some other error

                dwLE = GetLastError();

                if (dwLE == ERROR_ACCESS_DENIED && dwAuthMethod == AUTH_UNKNOWN) {
                    CHAR szAuthScheme[MAX_SCHEME_LEN];
                    static CHAR szNTLM[] = "NTLM";
                    static CHAR szKerbero[] = "Kerbero";
                    static CHAR szNegotiate[] = "Negotiate";

                    if (pConnection->GetAuthSchem (hReq, szAuthScheme, MAX_SCHEME_LEN)) {
                        // We've got the scheme
                        if (! (*szAuthScheme)) {
                            // It does not have authentication enabled, only Anonymous is supported
                            *pdwAuthMethod = AUTH_ANONYMOUS;
                        }
                        if (strstr (szAuthScheme, szNTLM) ||
                            strstr (szAuthScheme, szKerbero) ||
                            strstr (szAuthScheme, szNegotiate)) {

                            // We have authentication scheme that can authentication with no
                            // popup, let's use it.
                            *pdwAuthMethod = AUTH_NT;

                        }
                        else {
                            // We have an authentications scheme, but we need to popup for username
                            // and password
                            *pdwAuthMethod = AUTH_OTHER;
                        }
                        bRet = TRUE;
                    }
                }
            }
            else {
                // It means somehow, either the authentication is done,
                // or we get unsupported operation

                bRet = _IppForceAuthRsp(pConnection, hReq, 0L);

                if (!bRet) {
                    // the response from the server does not seem to be OK, so
                    // we mark m_bForceAuthSupported as FALSE so that we will not
                    // send the ForceAuth request to the server again.

                    m_bForceAuthSupported = FALSE;
                }

                if (bRet && dwAuthMethod == AUTH_UNKNOWN) {
                    // The authentication is done, so let's use NTLM authentication

                    *pdwAuthMethod = AUTH_NT;
                }
                // else degrade to old logic
            }

            WebIppFreeMem(lpIpp);

        }

        WebIppFreeMem(pgp);
    }

    if (dwLE == ERROR_INVALID_DATA) {
        dwLE = ERROR_INVALID_PRINTER_NAME;
    }

    if ((bRet == FALSE) && (dwLE != ERROR_SUCCESS))
        SetLastError(dwLE);

    return bRet;
}
BOOL
CPortMgr::_ForceAuth (
    CAnyConnection  *pConnection,
    LPCTSTR         lpszPortName,
    LPTSTR          lpszHost,
    LPTSTR          lpszUri,
    PDWORD          pdwAuthMethod)
{
    HINTERNET       hReq;
    DWORD           dwLE = ERROR_SUCCESS;
    BOOL            bRet = FALSE;

    if (pConnection->OpenSession()) {

        if (pConnection->Connect (lpszHost)) {

            // Make the request.
            //
            if (hReq = pConnection->OpenRequest (lpszUri)) {

                // If request handle is established, then all
                // is OK so far.
                //

                bRet = _IppForceAuth (pConnection,
                                      hReq,
                                      lpszPortName,
                                      pdwAuthMethod);
                dwLE = GetLastError();

                pConnection->CloseRequest (hReq);
            }

            pConnection->Disconnect ();
        }

        pConnection->CloseSession ();
    }

    if ((bRet == FALSE) && (dwLE != ERROR_SUCCESS))
        SetLastError(dwLE);

    return bRet;
}

#endif

/*****************************************************************************\
* _IppValRsp (Local Callback Routine)
*
* Retrieves a get-printer-attributes response from the IPP server
*
\*****************************************************************************/
BOOL
CPortMgr::_IppValRsp(
    CAnyConnection *pConnection,
    HINTERNET      hReq,
    LPARAM         lParam)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_PRN lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen(IPP_RET_GETPRN)) {

        while (TRUE) {

            cbRd = 0;
            if (pConnection->ReadFile (hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (!lpRsp) {
                        SetLastError (ERROR_INVALID_DATA);
                    }
                    else if ((bRet = lpRsp->bRet) == FALSE)
                        SetLastError(lpRsp->dwLastError);

                    WebIppFreeMem(lpRsp);

                    goto EndValRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //

                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("CPortMgr::_IppValRsp - Err : Receive Data Error (dwRet=%d, LE=%d)"),
                                             dwRet, WebIppGetError(hIpp)));

                    SetLastError(ERROR_INVALID_DATA);

                    goto EndValRsp;
                }

            } else {

                goto EndValRsp;
            }
        }

EndValRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}

BOOL
CPortMgr::_IppValidate (
    CAnyConnection  *pConnection,
    HINTERNET       hReq,
    LPCTSTR         lpszPortName)
{
    LPIPPREQ_GETPRN pgp;
    REQINFO         ri;
    DWORD           dwRet;
    LPBYTE          lpIpp;
    DWORD           cbIpp;
    DWORD           dwLE = ERROR_SUCCESS;
    BOOL            bRet = FALSE;

    if (pgp = WebIppCreateGetPrnReq(0, lpszPortName)) {

        // Convert the request to IPP, and perform the
        // post.
        //
        ZeroMemory(&ri, sizeof(REQINFO));
        ri.cpReq = CP_UTF8;
        ri.idReq = IPP_REQ_GETPRN;

        ri.fReq[0] = IPP_REQALL;
        ri.fReq[1] = IPP_REQALL;

        dwRet = WebIppSndData(IPP_REQ_GETPRN,
                              &ri,
                              (LPBYTE)pgp,
                              pgp->cbSize,
                              &lpIpp,
                              &cbIpp);


        // The request-structure has been converted
        // to IPP format, so it is ready to go to
        // the server.
        //
        //
        if (dwRet == WEBIPP_OK) {

            CMemStream *pStream = new CMemStream (lpIpp, cbIpp);

            if (pStream) {
                bRet = _SendRequest (pConnection, hReq, pStream);

                delete pStream;
            }

            if (bRet)
                bRet = _IppValRsp(pConnection, hReq, 0L);

            if (!bRet) {

                dwLE = GetLastError();

            }

            WebIppFreeMem(lpIpp);

        }

        WebIppFreeMem(pgp);
    }

    if (dwLE == ERROR_INVALID_DATA) {
        dwLE = ERROR_INVALID_PRINTER_NAME;
    }

    if ((bRet == FALSE) && (dwLE != ERROR_SUCCESS))
        SetLastError(dwLE);

    return bRet;
}

BOOL
CPortMgr::_CheckConnection (
    CAnyConnection  *pConnection,
    LPCTSTR         lpszPortName,
    LPTSTR          lpszHost,
    LPTSTR          lpszUri)
{
    HINTERNET       hReq;
    DWORD           dwLE = ERROR_SUCCESS;
    BOOL            bRet = FALSE;

    if (pConnection->OpenSession()) {

        if (pConnection->Connect (lpszHost)) {

            // Make the request.
            //
            if (hReq = pConnection->OpenRequest (lpszUri)) {

                // If request handle is established, then all
                // is OK so far.
                //

                bRet = _IppValidate (pConnection,
                                     hReq,
                                     lpszPortName);
                dwLE = GetLastError();

                pConnection->CloseRequest (hReq);
            }

            pConnection->Disconnect ();
        }

        pConnection->CloseSession ();
    }

    if ((bRet == FALSE) && (dwLE != ERROR_SUCCESS))
        SetLastError(dwLE);

    return bRet;
}

BOOL
CPortMgr::CheckConnection (void)
{
    HINTERNET       hReq;
    BOOL            bRet = FALSE;
    DWORD           dwLE = ERROR_SUCCESS;
    CAnyConnection *pConnection = NULL;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Enter CheckConnection")));

    if (m_bValid) {
#ifdef WINNT32
        pConnection = _GetCurrentConnection ();
#else
        pConnection = m_pConnection;
#endif

        if (hReq = _OpenRequest  (pConnection)) {
            bRet = _IppValidate (pConnection,
                                 hReq,
                                 m_lpszPortName);

            if (!bRet) {
                dwLE = GetLastError();
            }

            _CloseRequest (pConnection, hReq);
        }

#ifdef WINNT32
        if (pConnection) {
            delete pConnection;
        }

#endif
        if (!bRet && dwLE != ERROR_SUCCESS) {

            DBG_MSG(DBG_LEV_ERROR, (TEXT("CPortMgr::CheckConnection : Failed (lasterror=%d)"), dwLE));

            SetLastError (dwLE);
        }
    }
    else
        SetLastError (ERROR_INVALID_HANDLE);

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Leave CheckConnection ret=%d, lasterror=%d"), bRet, GetLastError ()));

    return bRet;
}

#ifndef WINNT32
/*****************************************************************************\
* _WriteRegistry (Private Member Function)
*
* Write the portname to the registry.  This will make the ports persistent
* across boots.  We store these names in the provider-section of the
* registry.
*
\*****************************************************************************/
BOOL
CPortMgr::_WriteRegistry (
    LPCTSTR lpszPortName)
{
    LONG lStat;
    HKEY hkPath;
    HKEY hkPortNames;
    HKEY hkThisPortName;
    BOOL bRet = FALSE;

    lStat = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           g_szRegProvider,
                           0,
                           NULL,
                           0,
                           KEY_WRITE,
                           NULL,
                           &hkPath,
                           NULL);

    if (lStat == ERROR_SUCCESS) {


        lStat = RegCreateKeyEx(hkPath,
                               g_szRegPorts,
                               0,
                               NULL,
                               0,
                               KEY_WRITE,
                               NULL,
                               &hkPortNames,
                               NULL);

        if (lStat == ERROR_SUCCESS) {


            lStat = RegCreateKeyEx(hkPortNames,
                                   lpszPortName,
                                   0,
                                   NULL,
                                   0,
                                   KEY_WRITE,
                                   NULL,
                                   &hkThisPortName,
                                   NULL);

            if (lStat == ERROR_SUCCESS) {

                lStat = RegSetValueEx(hkThisPortName,
                                      g_szAuthMethod,
                                      0,
                                      REG_DWORD,
                                      (LPBYTE)&m_dwAuthMethod,
                                      sizeof (&m_dwAuthMethod));


                bRet = (lStat == ERROR_SUCCESS ? TRUE : FALSE);

                RegCloseKey(hkThisPortName);
            }

            RegCloseKey(hkPortNames);

        }

        RegCloseKey(hkPath);

    }

    return bRet;

}

BOOL
CPortMgr::_ReadRegistry (
    LPCTSTR lpszPortName)
{
    LONG  lStat;
    HKEY  hkPath;
    HKEY  hkPortNames;
    HKEY  hkThisPortName;
    BOOL  bRet = FALSE;
    DWORD dwType;
    DWORD dwSize;


    // Open registry key for Provider-Name.
    //
    lStat = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegProvider, 0, KEY_READ, &hkPath);

    if (lStat == ERROR_SUCCESS) {

        bRet = TRUE;

        lStat = RegOpenKeyEx(hkPath, g_szRegPorts, 0, KEY_READ, &hkPortNames);

        if (lStat == ERROR_SUCCESS) {

            lStat = RegOpenKeyEx(hkPortNames, lpszPortName, 0, KEY_READ, &hkThisPortName);

            if (lStat == ERROR_SUCCESS) {

                dwType = REG_DWORD;
                dwSize = sizeof (m_dwAuthMethod);

                lStat = RegQueryValueEx (hkThisPortName, g_szAuthMethod, 0, &dwType, (LPBYTE) &m_dwAuthMethod, &dwSize);
                bRet = (lStat == ERROR_SUCCESS ? TRUE : FALSE);

                RegCloseKey (hkThisPortName);

            } else {

                DBG_MSG(DBG_LEV_INFO, (TEXT("RegOpenKeyEx(%s) failed: Error = %lu"), lpszPortName, lStat));
                SetLastError(lStat);
            }

            RegCloseKey(hkPortNames);

        } else {

            DBG_MSG(DBG_LEV_INFO, (TEXT("RegOpenKeyEx(%s) failed: Error = %lu"), g_szRegPorts, lStat));
            SetLastError(lStat);
        }

        RegCloseKey(hkPath);

    } else {

        DBG_MSG(DBG_LEV_WARN, (TEXT("RegOpenKeyEx(%s) failed: Error = %lu"), g_szRegProvider, lStat));

        SetLastError(lStat);
    }

    return bRet;

}

BOOL
CPortMgr::_RemoveRegistry (
    LPCTSTR lpszPortName)
{
    LONG lStat;
    HKEY hkPath;
    HKEY hkPortNames;
    BOOL bRet = FALSE;


    lStat = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         g_szRegProvider,
                         0,
                         KEY_ALL_ACCESS,
                         &hkPath);

    if (lStat == ERROR_SUCCESS) {

        lStat = RegOpenKeyEx(hkPath,
                             g_szRegPorts,
                             0,
                             KEY_ALL_ACCESS,
                             &hkPortNames);

        if (lStat == ERROR_SUCCESS) {

            lStat = RegDeleteKey(hkPortNames,
                                 lpszPortName);

            bRet = (lStat == ERROR_SUCCESS ? TRUE : FALSE);

            RegCloseKey(hkPortNames);

        } else {

            DBG_MSG(DBG_LEV_ERROR, (TEXT("RegOpenKeyEx (%s) failed: Error = %d"), g_szRegPorts, lStat));
        }

        RegCloseKey(hkPath);

    } else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("RegOpenKeyEx (%s) failed: Error = %d"), g_szRegProvider, lStat));
    }

    return bRet;

}
#endif

/*****************************************************************************\
* Function: Create
*
* This function is to establish the network connection with the given port name
*
* The intension of the function is to establish a network connection with
* authentication instead of anonymous. The alogortihm is as following
* 1. Try Anonymous
* 2. If anonymous connection is NOT possible, go to step 5
* 3. Try Force Authentication (Call _ForceAuth)
* 3.a.    Issue Force Authentication
* 3.b.    If the return value is  401 access denied, we start to check the
*         authentication scheme, otherwise, mark m_dwAuthMethod
*         as AUTH_ANONYMOUS and return TRUE
* 3.c.    If either NTLM, Kerbero or Negotiate is in the scheme, we mark
*         m_dwAuthMethod as AUTH_NT
*         Otherwise, we mark it as AUTH_OTHER
*         return TRUE
* 3.d.    (We don't get 401 access denied). If we get other errors, return FALSE
* 3.e.    Check the IPP response of the Forth Authentication
* 3.f.    If the IPP response is OK, we know we have established authentication
*         (This should not happen in the first time, but will happen afterward)
*         but we will mark m_dwAuthMethod as AUTH_NT anyway and return TRUE.
* 3.g.    Otherwise, (Not Supported), we assume that the server does not
*        support Force Authentication, so we move on by returning a FALSE.
*
* 4. If it returns OK, we start to use the authentication method indicated
*     in m_dwAuthMethod
* 5. Try NTLM or other no-popup authentication
* 6. Try Other popup authentications
*
* If the connection is established, the function returns TRUE.
*
\*****************************************************************************/

#ifdef WINNT32
BOOL
CPortMgr::Create (
    LPCTSTR lpszPortName)
{
    LPTSTR lpszHost = NULL;
    LPTSTR lpszShare = NULL;
    INTERNET_PORT nPort;
    CAnyConnection *pConnection = NULL;
    BOOL bRet = FALSE;
    DWORD dwLE = 0;
    BOOL    bDone;
    BOOL bSecure;
    BOOL bAnonymous = FALSE;
    DWORD dwAuthMethod;

    // Try to find out if the server can be accessed without going
    // through Proxy Server
    //
    if ( utlParseHostShare(lpszPortName,
                             &lpszHost,
                             &lpszShare,
                             &nPort,
                             &bSecure)) {

        bDone = ! (AssignString (m_lpszHostName, lpszHost) &&
                AssignString (m_lpszUri, lpszShare) &&
                AssignString (m_lpszPortName, lpszPortName));

        m_bSecure = bSecure;
        m_nPort = nPort;

        // Set the flag to indicate it is creation time.
        //

        m_bPortCreate = TRUE;

        // Try connect and the get the proxy
        if (!bDone) {

            // We don't care about if the reset succeeded or not
            EndBrowserSession ();
        }

        // Try anonymous with/without proxy

        if (!bDone && (pConnection = new CAnonymousConnection (bSecure, nPort, FALSE))
             && pConnection->IsValid ()) {

            bDone = TRUE;

            if (_CheckConnection(pConnection, lpszPortName, lpszHost, lpszShare)) {
                bAnonymous = TRUE;
            }
            else {
                dwLE = GetLastError ();

                if (dwLE == ERROR_INTERNET_NAME_NOT_RESOLVED) {

                    // The server name is wrong, reset tht last error
                    // to invalid printer name
                    //

                    SetLastError (ERROR_INVALID_PRINTER_NAME);
                }
                else if (dwLE == HTTP_STATUS_FORBIDDEN) {
                    SetLastError (ERROR_ACCESS_DENIED);
                }
                else if (dwLE != ERROR_INVALID_PRINTER_NAME)
                    bDone = FALSE; // Cont to the next mode
            }

            if (bAnonymous) {

                // We've got an anonymous authentication
                if (_ForceAuth(pConnection, lpszPortName, lpszHost, lpszShare, &dwAuthMethod)) {

                    // We've got an authentication method
                    if (dwAuthMethod != AUTH_ANONYMOUS) {
                        bDone = FALSE;
                        SetLastError (ERROR_ACCESS_DENIED);

                        if (dwAuthMethod == AUTH_OTHER) {
                            bDone = TRUE;
                            //weihaic goto TryOther;
                        }
                    }
                    else
                        bRet = TRUE;
                }
                else {
                    // We've got anonymous, and the serve does not support FORCE_AUTH
                    // so let us use it.
                    dwAuthMethod = AUTH_ANONYMOUS;
                    bRet = TRUE;
                }
            }
        }

        // You must have got access denied in this case

        // Let's try again without any password, it will work if the server has NTLM/Kerbero enabled.
        //
        if (!bDone && GetLastError () == ERROR_ACCESS_DENIED) {

            if (pConnection) {
                delete (pConnection);
                pConnection = NULL;
            }
            bDone = TRUE;

            if ( (pConnection = new CNTConnection (bSecure, nPort, FALSE) )
                 && pConnection->IsValid ()) {

                if (_CheckConnection(pConnection, lpszPortName, lpszHost, lpszShare)) {
                    dwAuthMethod = AUTH_NT;
                    bRet = TRUE;
                }
                else {
                    dwLE = GetLastError ();

                    if (dwLE != ERROR_INVALID_PRINTER_NAME)
                        bDone = FALSE; // Cont to the next mode
                }
            }
        }


        if (!bDone && GetLastError () == ERROR_ACCESS_DENIED && bAnonymous) {
            // We know that anonymous is enabled, so let us degrade the connection to anonymous
            if (pConnection) {
                delete (pConnection);
                pConnection = NULL;
            }

            // We must reset m_dwAuthMethod since when we try other authentication
            // m_dwAuthMethod is set to AUTH_OTHER, if we do not reset the value
            // when we try to send request to the server, it will fail with access
            // denied.
            //

            dwAuthMethod = AUTH_UNKNOWN;

            if (!bDone && (pConnection = new CAnonymousConnection (bSecure, nPort, FALSE))
                 && pConnection->IsValid ()) {

                bDone = TRUE;

                if (_CheckConnection(pConnection, lpszPortName, lpszHost, lpszShare)) {
                    bRet = TRUE;
                    dwAuthMethod = AUTH_ANONYMOUS;
                }
            }
        }
    }
    // Exit point

    //
    // We need to create the port at first if we get access denied
    // then users can configure the port using a different user name
    // and password
    //

    if (!bRet && GetLastError () == ERROR_ACCESS_DENIED) {
        //
        // Force anonymous connection. This will fail anyway.
        //
        dwAuthMethod = AUTH_ACCESS_DENIED;
        bRet = TRUE;
    }

    if (bRet) {
        m_bValid = TRUE;

        m_pPortSettingMgr = new CPortConfigDataMgr (lpszPortName);

        if (m_pPortSettingMgr && m_pPortSettingMgr->bValid ()) {

            CPortConfigData ConfigData;

            ConfigData.SetAuthMethod (dwAuthMethod);

            bRet = m_pPortSettingMgr->SetPerPortSettings (ConfigData);
        }
        else
            bRet = FALSE;
    }

    if (lpszHost) {
        memFreeStr (lpszHost);
    }

    if (lpszShare) {
        memFreeStr (lpszShare);
    }

    if (!bRet) {
        // Clean up the connection class
        if (pConnection) {
            delete (pConnection);
            pConnection = NULL;
        }

        if (GetLastError () != ERROR_ACCESS_DENIED) {
            // Invalid Printer Name

            // The NT router expects inetpp to returen ERROR_INVALID_NAME,
            // if we return ERROR_INVALID_PRINTER_NAME, the router will return
            // this error back to the user
            //
            SetLastError (ERROR_INVALID_NAME);
        }

    }

    m_bPortCreate = FALSE;

    return bRet;

}
#else


BOOL
CPortMgr::Create (
    LPCTSTR lpszPortName)
{
    LPTSTR lpszHost = NULL;
    LPTSTR lpszShare = NULL;
    INTERNET_PORT nPort;
    CAnyConnection *pConnection = NULL;
    COtherConnection *pOtherCon = NULL;
    BOOL bRet = FALSE;
    DWORD dwLE = 0;
    BOOL    bDone;
    BOOL bSecure;
    BOOL bAnonymous = FALSE;

    // Try to find out if the server can be accessed without going
    // through Proxy Server
    //
    if ( utlParseHostShare(lpszPortName,
                             &lpszHost,
                             &lpszShare,
                             &nPort,
                             &bSecure)) {

        bDone = ! (AssignString (m_lpszHostName, lpszHost) &&
                AssignString (m_lpszUri, lpszShare) &&
                AssignString (m_lpszPortName, lpszPortName));



        // Here is the code for win9x

        if (!bDone && (pConnection = new CIEConnection (bSecure, nPort))
             && pConnection->IsValid ()) {

            if (bSecure) {
                pConnection->SetShowSecurityDlg (TRUE);
            }

            if (_CheckConnection(pConnection, lpszPortName, lpszHost, lpszShare)) {
                bRet = TRUE;
                m_dwAuthMethod = AUTH_IE;
            }
            else {
                dwLE = GetLastError ();

                if (dwLE == HTTP_STATUS_FORBIDDEN) {
                    SetLastError (ERROR_ACCESS_DENIED);
                }
                if (dwLE != ERROR_INVALID_PRINTER_NAME)
                    bDone = FALSE; // Cont to the next mode
            }
        }
    }
    // Exit point

    if (bRet) {
        m_bValid = TRUE;
        m_pConnection = pConnection;

        bRet = _WriteRegistry (lpszPortName);

    }

    if (lpszHost) {
        memFreeStr (lpszHost);
    }

    if (lpszShare) {
        memFreeStr (lpszShare);
    }

    if (!bRet) {
        // Clean up the connection class
        if (pConnection) {
            delete (pConnection);
            m_pConnection = pConnection = NULL;
        }

        if (GetLastError () != ERROR_ACCESS_DENIED) {
            // Invalid Printer Name

            // The NT router expects inetpp to returen ERROR_INVALID_NAME,
            // if we return ERROR_INVALID_PRINTER_NAME, the router will return
            // this error back to the user
            //
            SetLastError (ERROR_INVALID_NAME);
        }

    }

    m_bPortCreate = FALSE;

    return bRet;

}

#endif

#ifdef WINNT32

#if 0
BOOL
CPortMgr::AddPort (
    PINET_ADDPORT_REQDATA pXcvAddPortReqData,
    PINET_ADDPORT_RESPDATA *ppXcvAddPortRespData)
{
    LPTSTR lpszHost = NULL;
    LPTSTR lpszShare = NULL;
    INTERNET_PORT nPort;
    CAnyConnection *pConnection = NULL;
    BOOL bRet = FALSE;
    DWORD dwLE = 0;
    BOOL    bDone;
    BOOL bSecure;
    BOOL bAnonymous = FALSE;

    if ( utlParseHostShare(pXcvAddPortReqData->szPortName,
                             &lpszHost,
                             &lpszShare,
                             &nPort,
                             &bSecure)) {

        bDone = ! (AssignString (m_lpszHostName, lpszHost) &&
                AssignString (m_lpszUri, lpszShare) &&
                AssignString (m_lpszPortName, lpszPortName));


        // Set the flag to indicate it is creation time.
        //

        m_bPortCreate = TRUE;

        // Try connect and the get the proxy
        if (!bDone) {

            // We don't care about if the reset succeeded or not
            EndBrowserSession ();
        }

        BOOL bIgnoreSecurityDlg = pXcvAddPortReqData->bIgnoreSecurityDlg;

        switch (dwAuthMethod) {
        case AUTH_ANONYMOUS:
            pConnection = new CAnonymousConnection (bSecure, nPort, bIgnoreSecurityDlg);
            break;
        case AUTH_NT:
            pConnection = new CNTConnection (bSecure, nPort, bIgnoreSecurityDlg);
            break;
        case AUTH_OTHER:
            pConnection = new COtherConnection (lpszPortName, bSecure, nPort,  TRUE,
                                                lpszUserName, lpszPassword, bIgnoreSecurityDlg);
        default:
            break;
        }

        if (pConnection && pConnect->IsValid()) {

            if (_CheckConnection(pConnection, pXcvAddPortReqData->szPortName, lpszHost, lpszShare)) {

                bRet = TRUE;
            }
            else {
                dwLE = GetLastError ();

                if (dwLE == ERROR_INTERNET_NAME_NOT_RESOLVED) {

                    // The server name is wrong, reset tht last error
                    // to invalid printer name
                    //

                    SetLastError (ERROR_INVALID_PRINTER_NAME);
                }
                else if (dwLE == HTTP_STATUS_FORBIDDEN) {
                    SetLastError (ERROR_ACCESS_DENIED);
                }
                else if (dwLE != ERROR_INVALID_PRINTER_NAME)
                    SetLastError (dwLE);
            }
        }
    }
    // Exit point

    if (bRet) {
        m_bValid = TRUE;
        m_pConnection = pConnection;

        bRet = _WriteRegistry (lpszPortName);

    }
    return bRet;

}
#endif

BOOL
CPortMgr::ConfigurePort (
    PINET_XCV_CONFIGURATION pXcvConfigurePortReqData,
    PINET_CONFIGUREPORT_RESPDATA pXcvAddPortRespData,
    DWORD cbSize,
    PDWORD cbSizeNeeded)
{
    LPTSTR lpszHost = NULL;
    LPTSTR lpszShare = NULL;
    INTERNET_PORT nPort;
    CAnyConnection *pConnection = NULL;
    BOOL bRet = FALSE;
    DWORD dwLE = 0;
    BOOL    bDone;
    BOOL bSecure;
    BOOL bAnonymous = FALSE;
    CPortConfigData OldConfigData;
    LPCTSTR pPassword = NULL;


    // Reset everything
    EndBrowserSession ();

    //
    // We must retry force authentication when configuration changes
    //
    m_bForceAuthSupported = TRUE;


    BOOL bIgnoreSecurityDlg = pXcvConfigurePortReqData->bIgnoreSecurityDlg;
    DWORD dwAuthMethod = pXcvConfigurePortReqData->dwAuthMethod;

    switch (dwAuthMethod) {
    case AUTH_ANONYMOUS:
        pConnection = new CAnonymousConnection (m_bSecure, m_nPort, bIgnoreSecurityDlg);
        break;
    case AUTH_NT:
        pConnection = new CNTConnection (m_bSecure, m_nPort, bIgnoreSecurityDlg);
        break;
    case AUTH_OTHER:

        if (m_pPortSettingMgr->GetCurrentSettings  (&OldConfigData))
            pPassword = OldConfigData.GetPassword();

        pPassword = (pXcvConfigurePortReqData->bPasswordChanged)?pXcvConfigurePortReqData->szPassword:pPassword;

        pConnection = new COtherConnection (m_bSecure, m_nPort,
                                            pXcvConfigurePortReqData->szUserName,
                                            pPassword,
                                            bIgnoreSecurityDlg);
    default:
        break;
    }

    if (pConnection && pConnection->IsValid()) {

        if (_CheckConnection(pConnection, m_lpszPortName, m_lpszHostName, m_lpszUri)) {

            bRet = TRUE;
        }
        else {
            dwLE = GetLastError ();

            if (dwLE == ERROR_INTERNET_NAME_NOT_RESOLVED) {

                // The server name is wrong, reset tht last error
                // to invalid printer name
                //

                SetLastError (ERROR_INVALID_PRINTER_NAME);
            }
            else if (dwLE == HTTP_STATUS_FORBIDDEN) {
                SetLastError (ERROR_ACCESS_DENIED);
            }
            else if (dwLE != ERROR_INVALID_PRINTER_NAME)
                SetLastError (dwLE);
        }
    }
    // Exit point

    if (bRet) {
        m_bValid = TRUE;

        CPortConfigData ConfigData;

        bRet = ConfigData.SetAuthMethod (dwAuthMethod);

        if (bRet) {

            if (dwAuthMethod == AUTH_OTHER) {
                bRet = ConfigData.SetUserName (pXcvConfigurePortReqData->szUserName) &&
                    ConfigData.SetPassword (pPassword);
            }
            else
                bRet = ConfigData.SetUserName(NULL) && ConfigData.SetPassword(NULL);

            if (bRet) {
                bRet = m_pPortSettingMgr->SetPerUserSettings  (ConfigData);
            }

            if (bRet && pXcvConfigurePortReqData->bSettingForAll)
                bRet = m_pPortSettingMgr->SetPerPortSettings  (ConfigData);
        }
    }
    return bRet;

}

BOOL
CPortMgr::GetCurrentConfiguration (
    PINET_XCV_CONFIGURATION pXcvConfiguration)
{
    CPortConfigData ConfigData;

    ZeroMemory (pXcvConfiguration, sizeof (INET_XCV_CONFIGURATION));

    m_pPortSettingMgr->GetCurrentSettings (&ConfigData);

    pXcvConfiguration->dwVersion = 1;
    pXcvConfiguration->dwAuthMethod = ConfigData.GetAuthMethod ();
    if (pXcvConfiguration->dwAuthMethod == AUTH_OTHER) {
        if (ConfigData.GetUserName()) {
            lstrcpy (pXcvConfiguration->szUserName, ConfigData.GetUserName());
        }
    }
    pXcvConfiguration->bIgnoreSecurityDlg = ConfigData.GetIgnoreSecurityDlg();

    return TRUE;

}
#endif


#ifdef WINNT32
BOOL
CPortMgr::Init (
    LPCTSTR lpszPortName)
{
    LPTSTR lpszHost = NULL;
    LPTSTR lpszShare = NULL;
    INTERNET_PORT nPort;
    BOOL bRet = FALSE;
    BOOL bSecure = FALSE;

    if ( utlParseHostShare(lpszPortName,
                         &lpszHost,
                         &lpszShare,
                         &nPort,
                         &bSecure)) {

        m_pPortSettingMgr = new CPortConfigDataMgr (lpszPortName);

        if (m_pPortSettingMgr && m_pPortSettingMgr->bValid ()) {
            bRet = TRUE;
        }
    }

    if (bRet) {

        m_bValid = TRUE;

        m_bSecure = bSecure;
        m_nPort = nPort;

        bRet = AssignString (m_lpszHostName, lpszHost) &&
               AssignString (m_lpszUri, lpszShare) &&
               AssignString (m_lpszPortName, lpszPortName);
    }

    if (lpszHost) {
        memFreeStr (lpszHost);
    }

    if (lpszShare) {
        memFreeStr (lpszShare);
    }

    return bRet;

}
#else

BOOL
CPortMgr::Init (
    LPCTSTR lpszPortName)
{
    LPTSTR lpszHost = NULL;
    LPTSTR lpszShare = NULL;
    INTERNET_PORT nPort;
    BOOL bRet = FALSE;
    BOOL bSecure = FALSE;

    if ( utlParseHostShare(lpszPortName,
                         &lpszHost,
                         &lpszShare,
                         &nPort,
                         &bSecure)) {

        if (_ReadRegistry (lpszPortName)) {
            switch (m_dwAuthMethod) {
            case AUTH_IE:
                m_pConnection = new CIEConnection (bSecure, nPort);
                break;
            default:
                break;
            }
            if (m_pConnection) {
                bRet = TRUE;
            }
        }
    }

    if (bRet) {

        m_bValid = TRUE;

        bRet = AssignString (m_lpszHostName, lpszHost) &&
               AssignString (m_lpszUri, lpszShare) &&
               AssignString (m_lpszPortName, lpszPortName);
    }

    if (lpszHost) {
        memFreeStr (lpszHost);
    }

    if (lpszShare) {
        memFreeStr (lpszShare);
    }

    return bRet;

}
#endif


#ifdef WINNT32
BOOL
CPortMgr::Remove (void)
{
    if (m_pPortSettingMgr) {
        m_pPortSettingMgr->DeleteAllSettings ();

    }
    return TRUE;
}
#else

BOOL
CPortMgr::Remove (void)
{
    return _RemoveRegistry (m_lpszPortName);
}
#endif


#ifdef WINNT32
CAnyConnection *
CPortMgr::_GetCurrentConnection ()
{
    CPortConfigData ConfigData;
    CAnyConnection *pConnection = NULL;

    if (m_pPortSettingMgr->GetCurrentSettings (&ConfigData)) {

        switch (ConfigData.GetAuthMethod ()) {
        case AUTH_ANONYMOUS:

            pConnection = new CAnonymousConnection (m_bSecure, m_nPort, ConfigData.GetIgnoreSecurityDlg());
            break;

        case AUTH_NT:
            pConnection = new CNTConnection (m_bSecure, m_nPort, ConfigData.GetIgnoreSecurityDlg());
            break;

        case AUTH_OTHER:
            pConnection = new COtherConnection (m_bSecure, m_nPort,
                                                ConfigData.GetUserName(), ConfigData.GetPassword(),
                                                ConfigData.GetIgnoreSecurityDlg());

            break;
        case AUTH_ACCESS_DENIED:
            SetLastError (ERROR_ACCESS_DENIED);
            break;
        default:
            SetLastError (ERROR_INVALID_HANDLE);
            break;
        }
    }
    else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("_GetCurrentConnection - Err  GetCurrentSettings failed (LE=%d)"), GetLastError ()));

        SetLastError (ERROR_INVALID_HANDLE);
    }
    return pConnection;

}
#endif

BOOL
CPortMgr::SendRequest(
    PCINETMONPORT   pIniPort,
    LPBYTE          lpIpp,
    DWORD           cbIpp,
    IPPRSPPROC      pfnRsp,
    LPARAM          lParam)
{
    BOOL        bRet = FALSE;
    CMemStream  *pStream;

    pStream = new CMemStream (lpIpp, cbIpp);

    if (pStream && pStream->bValid ()){
        bRet = SendRequest (pIniPort, pStream, pfnRsp, lParam);
    }

    if (pStream) {
        delete pStream;
    }
    return bRet;

}

BOOL
CPortMgr::SendRequest(
    PCINETMONPORT   pIniPort,
    CStream         *pStream,
    IPPRSPPROC      pfnRsp,
    LPARAM          lParam)
{
    HINTERNET   hReq;
    DWORD       dwLE = ERROR_SUCCESS;
    BOOL        bRet = FALSE;

    if (m_bValid) {

        CAnyConnection * pConnection;

#ifdef WINNT32
        pConnection = _GetCurrentConnection ();
#else
        pConnection = m_pConnection;
#endif

        if (pConnection) {

            hReq = _OpenRequest  (pConnection);

            // If succeeded, then build the content-length-header.
            //
            if (hReq) {

                bRet = _SendRequest (pConnection, hReq, pStream);

                if (bRet)
                    bRet = (pfnRsp ? (*pfnRsp)(pConnection, hReq, pIniPort, lParam) : TRUE);

                dwLE = GetLastError();

                _CloseRequest (pConnection, hReq);
            }

#ifdef WINNT32
            if (pConnection) {
                delete pConnection;
            }
#endif

        }
        else
            dwLE = GetLastError ();

        if ((bRet == FALSE) && (dwLE != ERROR_SUCCESS)) {

            if (dwLE == HTTP_STATUS_FORBIDDEN) {
                SetLastError (ERROR_ACCESS_DENIED);
            }
            else
                SetLastError(dwLE);

        }
    }
    else {
        SetLastError (ERROR_INVALID_HANDLE);
    }

    return bRet;

}

#ifdef WINNT32

DWORD
CPortMgr::IncreaseUserRefCount(
    CLogonUserData *pUser)
/*++

Routine Description:
    Increase the Ref Count for the current user in the Port Manager.

Arguments:
    pUser  -  The user that we want to increment the RefCount for.

Return Value:
    The current refcount for the user, or MAXDWORD if the user could not be found.

--*/
    {
    CLogonUserData *pPortUser = NULL;
    CLogonUserData *pNewUser  = NULL;
    DWORD          dwRefCount = MAXDWORD;

    DBG_ASSERT( pUser          , (TEXT("CPortMgr::IncreaseUserRefCount - pUser is NULL.")) );
    DBG_ASSERT( pUser->bValid(), (TEXT("CPortMgr::IncreaseUserRefCount - pUser is invalid.")) );

    m_UserList.Lock(); // We need to be sure only one CurUser is considered per port per time.

    if (pPortUser = m_UserList.Find( pUser )) {

        // We have found the port user, increment their refcount.
        dwRefCount = pPortUser->IncRefCount();

        DBG_MSG(DBG_LEV_INFO,
                (TEXT("Info: IncRef to (%d), User (%p)"), dwRefCount, pPortUser ) );
    } else {

        pNewUser = new CLogonUserData;  // A new user automatically has a ref-count of 1.

        if (pNewUser != NULL) {

            *pNewUser = *pUser;             // Assign data across

            if (!pNewUser->bValid() ||
                !m_UserList.Insert( pNewUser )) {
                delete pNewUser;
                pNewUser = NULL;

                SetLastError( ERROR_INVALID_PARAMETER );
            } else
            dwRefCount = 1;
        }
    }

    m_UserList.Unlock();

    return dwRefCount;
}

CLogonUserData*
CPortMgr::GetUserIfLastDecRef(
    CLogonUserData *pUser)
/*++

Routine Description:
    This routine finds the reference count for the current user. If the reference count is
    zero we return a pointer to the user, otherwise we return NULL. This will be used by
    the Cache Manager to invalid the cache for the particular user.

    NOTE: Caller must Free the pUser.

Arguments:
    None

Return Value:
    A pointer to the user if their RefCount has gone to Zero, NULL otherwise.

--*/
    {
    CLogonUserData *pPortUser = NULL;
    CLogonUserData *pNewUser  = NULL;
    DWORD          dwRefCount;

    DBG_ASSERT( pUser         , (TEXT("CPortMgr::GetUserIfLastDecRef - pUser is NULL.")) );
    DBG_ASSERT( pUser->bValid(), (TEXT("CPortMgr::GetUserIfLastDecRef - pUser is invalid.")) );

    m_UserList.Lock();

    if (pPortUser = m_UserList.Find( pUser )) {
        // We have found the port user, increment their refcount.

        // Make sure that two threads aren't handling the RefCount at the same
        // time
        dwRefCount = pPortUser->DecRefCount();

        DBG_MSG(DBG_LEV_INFO,
                (TEXT("Info: DecRef to (%d), User (%p)"), dwRefCount, pPortUser ) );

        if (dwRefCount == 0) {
            pNewUser = new CLogonUserData;

            if (pNewUser != NULL) {
                *pNewUser = *pPortUser;
            }

        m_UserList.Delete( pPortUser );     // We don't need him in the list anymore

        }
    }

    m_UserList.Unlock();

    return pNewUser;
}

#endif // #ifdef WINNT32

/************************************************************************************
** End of File (portmgr.cxx)
************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ping.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ping.c

Abstract:

    Packet INternet Groper utility for TCP/IP.

Author:

    Numerous TCP/IP folks.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    WeihaiC     5-Dec-98.   Moved from \nt\private\net\sockets\tcpcmd\ping
    MohsinA,    21-Oct-96.  INADDR_NONE check to avoid broadcast.
    MohsinA,    13-Nov-96.  Max packet size < 64K.

Notes:

--*/

//:ts=4
typedef unsigned long   ULONG;
typedef unsigned short  ushort;
typedef unsigned int    UINT;
typedef unsigned char   UCHAR;

#include "precomp.h"
#include "icmpapi.h"

#define NOGDI
#define NOMINMAX


#define MAX_BUFFER_SIZE       (sizeof(ICMP_ECHO_REPLY) + 0xfff7 + MAX_OPT_SIZE)
#define DEFAULT_BUFFER_SIZE         (0x2000 - 8)
#define DEFAULT_SEND_SIZE           32
#define DEFAULT_COUNT               4
#define DEFAULT_TTL                 32
#define DEFAULT_TOS                 0
#define DEFAULT_TIMEOUT             5000L
#define MIN_INTERVAL                1000L
#define TRUE                        1
#define FALSE                       0
#define STDOUT                      1

#define net_long(x) (((((ULONG)(x))&0xffL)<<24) | \
                     ((((ULONG)(x))&0xff00L)<<8) | \
                     ((((ULONG)(x))&0xff0000L)>>8) | \
                     ((((ULONG)(x))&0xff000000L)>>24))

#ifdef VXD

#define FAR _far

#endif // VXD


WSADATA WsaData;


// ========================================================================
// Caveat: return 0 for invalid, else internet address.
//         I would prefer -1 for error. - MohsinA, 21-Nov-96.

unsigned long
get_pingee(char *ahstr, char **hstr, int *was_inaddr, int dnsreq)
{
        struct hostent *hostp = NULL;
        long            inaddr;

        if( strcmp( ahstr, "255.255.255.255" ) == 0 ){
            return 0L;
        }

        if ((inaddr = inet_addr(ahstr)) == -1L) {
            hostp = gethostbyname(ahstr);
            if (hostp) {
                /*
                 * If we find a host entry, set up the internet address
                 */
                inaddr = *(long *)hostp->h_addr;
                *was_inaddr = 0;
            } else {
                // Neither dotted, not name.
                return(0L);
            }

        } else {
            // Is dotted.
            *was_inaddr = 1;
            if (dnsreq == 1) {
                hostp = gethostbyaddr((char *)&inaddr,sizeof(inaddr),AF_INET);
            }
        }

        *hstr = hostp ? hostp->h_name : (char *)NULL;
        return(inaddr);
}




// ========================================================================

BOOL Ping (LPTSTR pszServerName) 
{
    UINT    i;
    UINT    j;
    int     found_addr = 0;
    int     dnsreq = 0;
    char    *hostname = NULL;
    int     was_inaddr;
    DWORD   numberOfReplies;
    UINT    Count = DEFAULT_COUNT;
    UCHAR   TTL = DEFAULT_TTL;
    UCHAR FAR  *Opt = (UCHAR FAR *)0;         // Pointer to send options
    UINT    OptLength = 0;
    int     OptIndex = 0;               // Current index into SendOptions
    int     SRIndex = -1;               // Where to put address, if source routing
    UCHAR   TOS = DEFAULT_TOS;
    UCHAR   Flags = 0;
    ULONG   Timeout = DEFAULT_TIMEOUT;
    IP_OPTION_INFORMATION SendOpts;
    int     EndOffset;
    ULONG   TempAddr;
    UCHAR   TempCount;
    DWORD   errorCode;
    HANDLE  IcmpHandle = NULL;
    int     err;
    struct in_addr addr;
    BOOL    result;
    PICMP_ECHO_REPLY  reply;
    BOOL    sourceRouting = FALSE;
    char    *SendBuffer = NULL;
    char    *RcvBuffer = NULL;
    UINT    RcvSize;
    UINT    SendSize = DEFAULT_SEND_SIZE;
    BOOL    bRet = FALSE;
    IPAddr  address = 0;   // was local to main earlier.
    char    *arg;

    // ====================================================================

#ifdef UNICODE

    LPSTR pszAnsiServerName = NULL;
    DWORD uSize;

    if (pszServerName && (uSize = WideCharToMultiByte(CP_ACP,
                                                      0,
                                                      pszServerName, 
                                                      -1,
                                                      NULL, 
                                                      0,
                                                      NULL,
                                                      NULL))) {
    
        if (pszAnsiServerName = (LPSTR) LocalAlloc(LPTR, uSize)) {
            if (!WideCharToMultiByte (CP_ACP,
                                      0,
                                      pszServerName, 
                                      -1,
                                      pszAnsiServerName, 
                                      uSize,
                                      NULL,
                                      NULL))
                
                goto CleanUp;

        }
        else
            goto CleanUp;

    }

    arg = pszAnsiServerName;

#else
    arg = pszServerName;
#endif


    if (WSAStartup( 0x0101, &WsaData))
        goto CleanUp;

    // Added check for INADDR_NONE, MohsinA, 21-Oct-96.

    address = get_pingee(arg, &hostname, &was_inaddr, dnsreq);
    if(!address || (address == INADDR_NONE) ){
        SetLastError (DNS_ERROR_INVALID_IP_ADDRESS);
        goto CleanUp;
    }

    IcmpHandle = IcmpCreateFile();

    if (IcmpHandle == INVALID_HANDLE_VALUE) {
        goto CleanUp;
    }

    if (! (SendBuffer = (char *) LocalAlloc(LMEM_FIXED, SendSize))) {
        goto CleanUp;
    }

    //
    // Calculate receive buffer size and try to allocate it.
    //
    if (SendSize <= DEFAULT_SEND_SIZE) {
        RcvSize = DEFAULT_BUFFER_SIZE;
    }
    else {
        RcvSize = MAX_BUFFER_SIZE;
    }

    if (! (RcvBuffer = (char *)LocalAlloc(LMEM_FIXED, RcvSize))) {
        goto CleanUp;
    }
    
    //
    // Initialize the send buffer pattern.
    //
    for (i = 0; i < SendSize; i++) {
        SendBuffer[i] = 'a' + (i % 23);
    }

    //
    // Initialize the send options
    //
    SendOpts.OptionsData = Opt;
    SendOpts.OptionsSize = (UCHAR)OptLength;
    SendOpts.Ttl = TTL;
    SendOpts.Tos = TOS;
    SendOpts.Flags = Flags;

    addr.s_addr = address;

#if 0
    if (hostname) {
        NlsPutMsg(
            STDOUT,
            PING_HEADER1,
            hostname,
            inet_ntoa(addr),
            SendSize
        );
        // printf("Pinging Host %s [%s]\n", hostname, inet_ntoa(addr));
    } else {
        NlsPutMsg(
            STDOUT,
            PING_HEADER2,
            inet_ntoa(addr),
            SendSize
        );
        // printf("Pinging Host [%s]\n", inet_ntoa(addr));
    }
#endif

//    for (i = 0; i < Count; i++) {
    numberOfReplies = IcmpSendEcho(
        IcmpHandle,
        address,
        SendBuffer,
        (unsigned short) SendSize,
        &SendOpts,
        RcvBuffer,
        RcvSize,
        Timeout
    );

    if (numberOfReplies == 0) {

        errorCode = GetLastError();

        goto CleanUp;
        // Need to try again? - weihaic
    }
    else {

        reply = (PICMP_ECHO_REPLY) RcvBuffer;

        while (numberOfReplies--) {
            struct in_addr addr;

            addr.S_un.S_addr = reply->Address;

            // printf(
            //     "Reply from %s:",
            //     inet_ntoa(addr),
            //         );

            if (reply->Status == IP_SUCCESS) {
                
                // printf(
                //     "Echo size=%d ",
                //         reply->DataSize
                //         );

                bRet = TRUE;
                break;


                // printf("\n time rt=%dms min %d, max %d, total %d\n",
                //        reply->RoundTripTime,
                //        time_min, time_max, time_total );

                // printf("TTL=%u\n", (UINT)reply->Options.Ttl);

                //
                // Ignore Option fields
                // if (reply->Options.OptionsSize) {
                //    ProcessOptions(reply, (BOOLEAN) dnsreq);
                //}
            }
/*                else {
                for (j=0; ErrorTable[j].Error != IP_GENERAL_FAILURE; j++) {
                    if (ErrorTable[j].Error == reply->Status) {
                        break;
                    }
                }

            }    */

            reply++;
        }

    }
//    }

CleanUp:

#ifdef UNICODE
    if (pszAnsiServerName) {
        LocalFree(pszAnsiServerName);
    }
#endif
    
    if (IcmpHandle) {
        IcmpCloseHandle(IcmpHandle);
    }

    if (SendBuffer) {
        LocalFree(SendBuffer);
    }

    if (RcvBuffer) {
        LocalFree(RcvBuffer);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ppchange.cxx ===
/*****************************************************************************\
* MODULE: ppchange.h
*
* This module contains functions that handle notification
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*   28-Apr-1998     Weihai Chen (weihaic)
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"


typedef struct INET_HPRINTER_LIST {
   LPINET_HPRINTER hPrinter;
   struct INET_HPRINTER_LIST *next;
} INET_HPRINTER_LIST;

typedef INET_HPRINTER_LIST *PINET_HPRINTER_LIST;
typedef INET_HPRINTER_LIST *NPINET_HPRINTER_LIST;
typedef INET_HPRINTER_LIST *LPINET_HPRINTER_LIST;


static INET_HPRINTER_LIST g_pHandleList = {NULL, NULL};

/*****************************************************************************\
* AddHandleToList
*
* Add the printer handle to a global link list
*
\*****************************************************************************/
BOOL
AddHandleToList (
   LPINET_HPRINTER hPrinter
   )
{
   LPINET_HPRINTER_LIST pPrt;

   if (pPrt = (LPINET_HPRINTER_LIST)memAlloc(sizeof(INET_HPRINTER_LIST))) {
      pPrt->next = g_pHandleList.next;
      pPrt->hPrinter =  hPrinter;
      g_pHandleList.next = pPrt;

      return TRUE;
   }
   else
      return FALSE;
}

/*****************************************************************************\
* DeleteHandleFromList
*
* Remove a printer handle from the global link list
*
\*****************************************************************************/
BOOL
DeleteHandleFromList (
   LPINET_HPRINTER hPrinter
   )
{
   LPINET_HPRINTER_LIST pPrt = &g_pHandleList;
   LPINET_HPRINTER_LIST pTmp;

   while (pPrt->next) {
      if (pPrt->next->hPrinter == hPrinter) {
         pTmp = pPrt->next;
         pPrt->next = pTmp->next;
         memFree (pTmp, sizeof(INET_HPRINTER_LIST));
         return TRUE;
      }
      pPrt = pPrt->next;
   }

   return FALSE;
}

/*****************************************************************************\
* RefreshNotificationPort
*
* Go through the handle list and call the refresh if the notify handle is not
* null
*
\*****************************************************************************/
void
RefreshNotificationPort (
   HANDLE hPort
   )
{
    LPINET_HPRINTER_LIST pPrt = g_pHandleList.next;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: RefreshNotificationPort: Port(%08lX)"), hPort));
    
    while (pPrt) {
        if (utlValidatePrinterHandle (pPrt->hPrinter) == hPort) { 
            if (pPrt->hPrinter->hNotify) {
                
                DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: ReplyPrinterChangeNotification: hNotify(%08lX)"),
                                            pPrt->hPrinter->hNotify));
                
                ReplyPrinterChangeNotification (pPrt->hPrinter->hNotify,
                                                PRINTER_CHANGE_ALL,
                                                NULL,
                                                NULL);
            }

        }
        pPrt = pPrt->next;
    }
}


/*****************************************************************************\
* RefreshNotification
*
* Go through the handle list and call the refresh if the notify handle is not
* null
*
\*****************************************************************************/
void
RefreshNotification (
   LPINET_HPRINTER hPrinter
   )
{

    RefreshNotificationPort (hPrinter->hPort);
}

/*****************************************************************************\
* PPFindFirstPrinterChangeNotification
*
* Handle the notification request
*
\*****************************************************************************/
BOOL
PPFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PDWORD pfdwStatus,
    PVOID pPrinterNotifyOptions,
    PVOID pPrinterNotifyInit
    )
{
    static PRINTER_NOTIFY_INIT PPNotify = {
        sizeof (PRINTER_NOTIFY_INIT),
        0,
        30000
    };

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPFindFirstPrinterChangeNotification: Printer(%08lX)"), hPrinter));

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: hNotify(%08lX)"),hNotify));

    semEnterCrit();

    if (utlValidatePrinterHandle(hPrinter)) {

        ((LPINET_HPRINTER )hPrinter) ->hNotify = hNotify;
        fdwFlags = PRINTER_CHANGE_ALL;
        *pfdwStatus = PRINTER_NOTIFY_STATUS_POLL | PRINTER_NOTIFY_STATUS_ENDPOINT;
        * ((LPPRINTER_NOTIFY_INIT *) pPrinterNotifyInit) = &PPNotify;
    }

    semLeaveCrit ();

    return TRUE;
}

BOOL
PPFindClosePrinterChangeNotification(
    HANDLE hPrinter
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\mem.cxx ===
/*****************************************************************************\
* MODULE: mem.c
*
* Memory management routines.  These routines provide head/tail checking
* to verify memory corruption problems.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*********************************************************** local routine ***\
* mem_HeadPtr
*
*   Returns the pointer to the head-block.  This needs to decrement enough
*   to account for the extra information stored at the head.
*
\*****************************************************************************/
_inline PMEMHEAD mem_HeadPtr(
    PVOID pvMem)
{
    return (PMEMHEAD)(pvMem ? (((PBYTE)pvMem) - MEM_HEADSIZE) : NULL);
}


/*********************************************************** local routine ***\
* mem_TailPtr
*
*   Returns the pointer to the tail-block.  This requires the aligned-size
*   to retrieve the offset.
*
\*****************************************************************************/
_inline PMEMTAIL mem_TailPtr(
    PMEMHEAD pmh,
    DWORD    cbAlign)
{
    return (PMEMTAIL)((PBYTE)pmh + cbAlign - MEM_TAILSIZE);
}

#ifdef DEBUG

PMEMHEAD g_pmHead = NULL;

/*********************************************************** local routine ***\
* mem_InsPtr
*
*   Inserts the pointer into our list for tracking allocations.
*
\*****************************************************************************/
_inline VOID mem_InsPtr(
    PMEMHEAD pmHead)
{
    if (g_pmHead) {

        g_pmHead->pmPrev = pmHead;
        pmHead->pmNext   = g_pmHead;

    } else {

        pmHead->pmNext = NULL;
    }

    g_pmHead = pmHead;
}


/*********************************************************** local routine ***\
* mem_DelPtr
*
*   Removes the pointer from our list of tracked allocations.
|
\*****************************************************************************/
_inline VOID mem_DelPtr(
    PMEMHEAD pmHead)
{
    PMEMHEAD pmPtr;


    if (pmHead->pmNext) {

        pmPtr         = pmHead->pmNext;
        pmPtr->pmPrev = pmHead->pmPrev;
    }

    if (pmHead->pmPrev) {

        pmPtr         = pmHead->pmPrev;
        pmPtr->pmNext = pmHead->pmNext;

    } else {

        g_pmHead = pmHead->pmNext;
    }
}


/*****************************************************************************\
* _mem_validate (Local Routine)
*
* Checks memory blocks allocated by memAlloc. These blocks contain
* debugging information that helps to check for pointer overruns and
* underruns.
*
* Returns a pointer to the memory header.  Otherwise, we return NULL.
*
\*****************************************************************************/
PVOID _mem_validate(
    PVOID pvMem,
    UINT  cbSize)
{
    DWORD    cbAlign;
    PMEMHEAD pmHead;
    PMEMTAIL pmTail;
    PMEMHEAD pmRet = NULL;


    // Retrieve the head-pointer.
    //
    if (pmHead = mem_HeadPtr(pvMem)) {

        // Calculate the "real" size of our allocated block and round it
        // up to an even number of DWORD blocks.
        //
        cbAlign = memAlignSize(cbSize + MEM_SIZE);


        // Get the tail location.
        //
        pmTail = mem_TailPtr(pmHead, cbAlign);


        // Compare the values that memAlloc stored at the beginning
        // and end of the block
        //
        if ((pmHead->cbSize == cbSize) && (pmTail->dwSignature == DEADBEEF))
            pmRet = pmHead;


        // Assert if errors.
        //
        DBG_ASSERT((pmHead->cbSize == cbSize), (TEXT("Err : _mem_validate: Bad Size at %08lX"), pvMem));
        DBG_ASSERT((pmTail->dwSignature == DEADBEEF), (TEXT("Err : _mem_validate: Block Corruption at %08lX"), pvMem));

    } else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : _mem_validate: Bad Pointer")));
    }

    return pmRet;
}

#else

/*********************************************************** local routine ***\
* Non-Debug Mappings.
*
*   On non-debug builds, we will just return the most efficient values.
*
\*****************************************************************************/
#define mem_InsPtr(pmHead)           {}
#define mem_DelPtr(pmHead)           {}
#define _mem_validate(pvMem, cbSize)  mem_HeadPtr(pvMem)

#endif

/*****************************************************************************\
* memAlloc
*
*
\*****************************************************************************/
PVOID memAlloc(
    UINT cbSize)
{
    PMEMHEAD pmHead;
    PMEMTAIL pmTail;
    DWORD    cbAlign;


    // The size of this memory-block will include header-information.  So,
    // we will add the header-size and align our memory on DWORD boundries.
    //
    cbAlign = memAlignSize(cbSize + MEM_SIZE);


    // Attempt to allocate the memory.  Proceed to setup
    // the memory block.
    //
    if (pmHead = (PMEMHEAD)GlobalAlloc(GPTR, cbAlign)) {

        pmTail = mem_TailPtr(pmHead, cbAlign);


        // Zero the memory-block so that we're dealing with
        // a clean contiguous array.
        //
        ZeroMemory((PVOID)pmHead, cbAlign);


        // Set up header/tail-information.  This contains the requested
        // size of the memory-block.  Increment the block so we return
        // the next available memory for the caller to use.
        //
        pmTail->dwSignature = DEADBEEF;
        pmHead->dwTag       = 0;
        pmHead->cbSize      = cbSize;
        pmHead->pmPrev      = NULL;
        pmHead->pmNext      = NULL;

        mem_InsPtr(pmHead);

    } else {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return (pmHead ? pmHead->pvMem : NULL);
}


/*****************************************************************************\
* memFree
*
*
\*****************************************************************************/
BOOL memFree(
    PVOID pvMem,
    UINT  cbSize)
{
    PMEMHEAD pmHead;
    BOOL     bRet = FALSE;


    // Try to at least make sure it's our memory and that no pointers have
    // gone astray in it.
    //
    if (pmHead = (PMEMHEAD) _mem_validate(pvMem, cbSize)) {

        mem_DelPtr(pmHead);

        bRet = (GlobalFree((PVOID)pmHead) == NULL);
    }

    return bRet;
}


/*****************************************************************************\
* memCopy
*
* Copies a block of memory into a Win32 format buffer -- a structure at the
* front of the buffer and strings packed into the end.
*
* On entry, *buf should point to the last available byte in the buffer.
*
\*****************************************************************************/
VOID memCopy(
    PSTR *ppDst,
    PSTR pSrc,
    UINT cbSize,
    PSTR *ppBuf)
{

    if (pSrc != NULL) {

        // Place bytes at end of buffer.
        //
        (*ppBuf) -= cbSize + 1;

        memcpy(*ppBuf, pSrc, cbSize);


        // Place buffer address in structure and save pointer to new
        // last available byte.
        //
        *ppDst = *ppBuf;

        (*ppBuf)--;

    } else {

        *ppDst = NULL;
    }
}


/*****************************************************************************\
* memGetSize
*
* Returns the size of a block of memory that was allocated with memAlloc().
*
\*****************************************************************************/
UINT memGetSize(
    PVOID pvMem)
{
    PMEMHEAD pmHead;

    return ((pmHead = mem_HeadPtr(pvMem)) ? pmHead->cbSize : 0);
}


/*****************************************************************************\
* memAllocStr
*
* Allocates local memory to store the specified string.  This takes in a
* (lpszStr) which is copied to the new memory.
*
\*****************************************************************************/
PTSTR memAllocStr(
    LPCTSTR lpszStr)
{
   PTSTR pMem;

   if (lpszStr == NULL)
      return NULL;

   if (pMem = (PTSTR) memAlloc(utlStrSize(lpszStr)))
      if (!lstrcpy((LPTSTR)pMem, lpszStr)) {
          memFreeStr (pMem);
          pMem = NULL;
      }

   return pMem;
}


/*****************************************************************************\
* memFreeStr
*
* Frees the memory allocated by memAllocStr.
*
\*****************************************************************************/
BOOL memFreeStr(
   PTSTR pszStr)
{
   return memFree(pszStr, memGetSize(pszStr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ppchange.h ===
/*****************************************************************************\
* MODULE: ppchange.h
*
* Prototypes for private funcions in ppchange.c.  These functions handle
* notification support
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*   28-Apr-1998     Weihai Chen (weihaic)
*
\*****************************************************************************/

#ifndef _PPCHANGE_H
#define _PPCHANGE_H

#ifdef WINNT32
BOOL
AddHandleToList (
    LPINET_HPRINTER hPrinter);

BOOL
DeleteHandleFromList (
    LPINET_HPRINTER hPrinter);

void
RefreshNotificationPort (
   HANDLE hPort
   );

void
RefreshNotification (
   LPINET_HPRINTER hPrinter);

BOOL
PPFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PDWORD pfdwStatus,
    PVOID pPrinterNotifyOptions,
    PVOID pPrinterNotifyInit);

BOOL
PPFindClosePrinterChangeNotification(
    HANDLE hPrinter
    );

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\mem.h ===
/*****************************************************************************\
* MODULE: mem.h
*
* Header file for memory handling routines (mem.c).
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _INETPPMEM_H
#define _INETPPMEM_H

/*-----------------------------------*\
| Constants
\*-----------------------------------*/
#define DEADBEEF      0xdeadbeef                    // Tail Marker.
#define MAPMEM        ((HANDLE)-1)                  // File-Map-Memory.


/*-----------------------------------*\
| MEMHEAD Structure
\*-----------------------------------*/
typedef struct _MEMHEAD {

    struct _MEMHEAD *pmPrev;    // Reference to previous mem-block (dbg-only).
    struct _MEMHEAD *pmNext;    // Reference to next mem-block     (dbg-only).
    DWORD           dwTag;      // Memory Tag.
    DWORD           cbSize;     // size of block allocated (non-aligned size).
    PVOID           pvMem[1];   // Start of user-addressable memory.

} MEMHEAD;
typedef MEMHEAD      *PMEMHEAD;
typedef MEMHEAD NEAR *NPMEMHEAD;
typedef MEMHEAD FAR  *LPMEMHEAD;


/*-----------------------------------*\
| MEMTAIL Structure
\*-----------------------------------*/
typedef struct _MEMTAIL {

    DWORD dwSignature;

} MEMTAIL;
typedef MEMTAIL      *PMEMTAIL;
typedef MEMTAIL NEAR *NPMEMTAIL;
typedef MEMTAIL FAR  *LPMEMTAIL;

#define MEM_HEADSIZE  (FIELD_OFFSET(MEMHEAD, pvMem))     //
#define MEM_TAILSIZE  (1 * sizeof(DWORD))           //
#define MEM_SIZE      (MEM_HEADSIZE + MEM_TAILSIZE) //

/*-----------------------------------*\
| memAlignSize
\*-----------------------------------*/
_inline BOOL memAlignSize(
    DWORD cbSize)
{
    return ((cbSize & 3) ? (cbSize + (sizeof(DWORD) - (cbSize & 3))) : cbSize);
}

PVOID memAlloc(
    UINT cbSize);

BOOL memFree(
    PVOID  pMem,
    UINT   cbSize);

UINT memGetSize(
    PVOID pMem);

VOID memCopy(
    PSTR *ppDst,
    PSTR pSrc,
    UINT cbSize,
    PSTR *ppBuf);

PTSTR memAllocStr(
    LPCTSTR lpszStr);

BOOL memFreeStr(
   PTSTR lpszStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\othercon.cxx ===
/*****************************************************************************\
* MODULE: iecon.cxx
*
* The module contains class for connections using IE's default configuration
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   07/31/98    Weihaic     Created
*
\*****************************************************************************/
#include "precomp.h"

#ifdef WINNT32
#include "priv.h"

const DWORD cdwDialogTimeout = 4000000;


COtherConnection::COtherConnection (
    BOOL bSecure,
    INTERNET_PORT nServerPort,
    LPCTSTR lpszUserName,
    LPCTSTR lpszPassword,
    BOOL bIgnoreSecurityDlg):
    CAnyConnection (bSecure, nServerPort, bIgnoreSecurityDlg, AUTH_OTHER)
{
    m_bValid = AssignString (m_lpszUserName, lpszUserName) &&
               AssignString (m_lpszPassword, lpszPassword);
}

COtherConnection::~COtherConnection ()
{
}

HINTERNET
COtherConnection::OpenRequest (
    LPTSTR lpszUrl)
{
    return CAnyConnection::OpenRequest (lpszUrl);
    
#if 0
    // This is not necessary since we have force auth. For those IPP servers that do not support
    // force authentication. Although it is possible to submit a job with anonymous user even if the 
    // connection is established with a credential, it does not prevent the user from 
    // performing any actions that requires the credential since any denied access will be resolved
    // in SendRequest() using the correct credential. 
    //

    HINTERNET hReq = CAnyConnection::OpenRequest (lpszUrl);

    if (hReq  && _FindAndSetPassword (hReq, FALSE)) {
        return hReq;
    }

    return NULL;
#endif
}

BOOL
COtherConnection::SendRequest(
    HINTERNET      hReq,
    LPCTSTR        lpszHdr,
    DWORD          cbHdr,
    LPBYTE         pidi)
{
    static const DWORD dwMaxRetry = 2;

    BOOL    bRet = FALSE;
    DWORD   i;

    HANDLE hToken;


    //
    //  We have to revert to the local system account to prevent wininet from sending 
    //  the logon user credential automatically to the remote machine.
    //

    if (hToken = RevertToPrinterSelf()) {

        for (i = 0; i < dwMaxRetry; i++ ) {
    
            if (SetPassword (hReq, m_lpszUserName, m_lpszPassword)) {
    
                bRet = CAnyConnection:: SendRequest (hReq,
                                                    lpszHdr,
                                                    cbHdr,
                                                    pidi);
    
                if (bRet || GetLastError () != ERROR_ACCESS_DENIED) {
                    break;
                }
            }
        }

        if (!ImpersonatePrinterClient(hToken)) {
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL
COtherConnection::SendRequest(
    HINTERNET      hReq,
    LPCTSTR        lpszHdr,
    CStream        *pStream)
{
    static const DWORD dwMaxRetry = 2;

    BOOL    bRet = FALSE;
    DWORD   i;

    HANDLE hToken;


    //
    //  We have to revert to the local system account to prevent wininet from sending 
    //  the logon user credential automatically to the remote machine.
    //

    if (hToken = RevertToPrinterSelf()) {

        for (i = 0; i < dwMaxRetry; i++ ) {
    
            if (SetPassword (hReq, m_lpszUserName, m_lpszPassword)) {
    
                bRet = CAnyConnection:: SendRequest (hReq,
                                                     lpszHdr,
                                                     pStream);
                                                    
                if (bRet || GetLastError () != ERROR_ACCESS_DENIED) {
                    break;
                }
            }
        }

        if (!ImpersonatePrinterClient(hToken)) {
            bRet = FALSE;
        }
    }

    return bRet;
}



BOOL 
COtherConnection::ReadFile (
    HINTERNET hReq,
    LPVOID    lpvBuffer,
    DWORD     cbBuffer,
    LPDWORD   lpcbRd)
{
    BOOL bRet = FALSE;
    HANDLE hToken;

    if (hToken = RevertToPrinterSelf()) {
        
        bRet = CAnyConnection::ReadFile (hReq, lpvBuffer, cbBuffer, lpcbRd);

        if (!ImpersonatePrinterClient(hToken)) {
            bRet = FALSE;
        }
    }

    return bRet;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ppport.h ===
/*****************************************************************************\
* MODULE: ppport.h
*
* Prototypes for private funcions in ppport.c.  These functions handle port
* related calls.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   18-Nov-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _PPPORT_H
#define _PPPORT_H

BOOL PPEnumPorts(
    LPTSTR  lpszServerName,
    DWORD   dwLevel,
    LPBYTE  pbPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeed,
    LPDWORD pcbRet);

BOOL PPDeletePort(
    LPTSTR lpszServerName,
    HWND   hWnd,
    LPTSTR lpszPortName);

BOOL PPAddPort(
    LPTSTR lpszPortName,
    HWND   hWnd,
    LPTSTR lpszMonitorName);

BOOL PPConfigurePort(
    LPTSTR lpszServerName,
    HWND   hWnd,
    LPTSTR lpszPortName);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ppinfo.h ===
/*****************************************************************************\
* MODULE: ppinfo.h
*
* Prototypes for print-job information routines.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _PPINFO_H
#define _PPINFO_H

// Mask of printer enum type flags for EnumPrinter requests that our
// provider doesn't handle.
//
#define PRINTER_ENUM_NOTFORUS  (PRINTER_ENUM_DEFAULT  | \
                                PRINTER_ENUM_LOCAL    | \
                                PRINTER_ENUM_FAVORITE | \
                                PRINTER_ENUM_SHARED     \
                               )

// This macro returns a pointer to the location specified by length.  This
// assumes calculations in BYTES.  We cast it to the LPTSTR to assure the
// pointer reference will support UNICODE.
//
#define ENDOFBUFFER(buf, length)  (LPTSTR)((((LPSTR)buf) + (length - sizeof(TCHAR))))


// PrintProcessor information routines.
//
BOOL PPEnumPrinters(
    DWORD   dwType,
    LPTSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned);

BOOL PPGetPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  lpbPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ppjobs.cxx ===
/*****************************************************************************\
* MODULE: ppjobs.c
*
* This module contains the print-job manipulating routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

#ifdef WINNT32
BOOL
_ppprn_end_docprinter_async (
    PCINETMONPORT       pIniPort,
    PJOBMAP             pjmJob);
#endif

typedef struct _ADDJOB_INFO_2W {
    LPWSTR    pData;
    DWORD     JobId;
} ADDJOB_INFO_2W, *PADDJOB_INFO_2W, *LPADDJOB_INFO_2W;


DWORD
ppjob_GetOneSize (
    DWORD dwLevel)
{
    DWORD cbIdx;

    switch (dwLevel) {
    case PRINT_LEVEL_1:
        cbIdx = sizeof(JOB_INFO_1);
        break;
    case PRINT_LEVEL_2:
        cbIdx = sizeof(JOB_INFO_2);
        break;
    case PRINT_LEVEL_3:
        cbIdx = sizeof(JOB_INFO_3);
        break;
    }
    return cbIdx;
}
/*****************************************************************************\
* ppjob_IppPrtRsp (Local Routine)
*
* Retrieves a get response from the IPP server.  Our (pjmJob) in the
* parameter list references a job-entry.
*
\*****************************************************************************/
BOOL CALLBACK ppjob_IppPrtRsp(
    CAnyConnection  *pConnection,
    HINTERNET       hJobReq,
    PCINETMONPORT   pIniPort,
    PJOBMAP         pjmJob)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_JOB lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen(IPP_RET_PRINTJOB)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile ( pConnection, hJobReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (bRet = lpRsp->bRet) {

                        // Set the remote-job-id to the job-entry.  This
                        // entry was added at the time the spool-job-file
                        // was created.
                        //
                        semEnterCrit();
                        pjmSetJobRemote(pjmJob, lpRsp->ji.ji2.JobId, lpRsp->ji.ipp.pJobUri);
                        semLeaveCrit();

                    } else {

                        // If the job failed to open on the server, then
                        // we will set the last-error from the server
                        // response.
                        //
                        SetLastError(lpRsp->dwLastError);
                    }

                    WebIppFreeMem(lpRsp);

                    goto EndPrtRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //
                    break;

                default:
                    DBG_MSG(DBG_LEV_ERROR, (TEXT("ppjob_IppPrtRsp : Receive Data Error")));
                    SetLastError(ERROR_INVALID_DATA);

                    goto EndPrtRsp;
                }

            } else {

                goto EndPrtRsp;
            }
        }

EndPrtRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}



/*****************************************************************************\
* ppjob_GetJobSize (Local Routine)
*
* Returns the size necessary to hold the jobinfo.
*
\*****************************************************************************/
DWORD ppjob_GetJobSize(
    LPJOB_INFO_2 pji2,
    DWORD        dwLevel)
{
    DWORD cbSize;


    switch (dwLevel) {

    case PRINT_LEVEL_1:

        cbSize = sizeof(JOB_INFO_1)             +
                 utlStrSize(pji2->pPrinterName) +
                 utlStrSize(pji2->pMachineName) +
                 utlStrSize(pji2->pUserName)    +
                 utlStrSize(pji2->pDocument)    +
                 utlStrSize(pji2->pDatatype)    +
                 utlStrSize(pji2->pStatus);
        break;

    case PRINT_LEVEL_2:

        cbSize = sizeof(JOB_INFO_2)                +
                 utlStrSize(pji2->pPrinterName)    +
                 utlStrSize(pji2->pMachineName)    +
                 utlStrSize(pji2->pUserName)       +
                 utlStrSize(pji2->pDocument)       +
                 utlStrSize(pji2->pNotifyName)     +
                 utlStrSize(pji2->pDatatype)       +
                 utlStrSize(pji2->pPrintProcessor) +
                 utlStrSize(pji2->pParameters)     +
                 utlStrSize(pji2->pDriverName)     +
                 utlStrSize(pji2->pStatus);

        if (pji2->pDevMode)
            cbSize += (pji2->pDevMode->dmSize + pji2->pDevMode->dmDriverExtra);

        cbSize = (cbSize + sizeof(DWORD)-1) & ~(sizeof(DWORD)-1);

        break;

    case PRINT_LEVEL_3:
        cbSize = sizeof(JOB_INFO_3);
        break;

    default:
        cbSize = 0;
        break;
    }

    return cbSize;
}


/*****************************************************************************\
* ppjob_CopyJob (Local Routine)
*
* Copies a job-info structure to another.
*
\*****************************************************************************/
LPBYTE ppjob_CopyJob(
    LPBYTE       pbJobDst,
    DWORD        dwLevel,
    LPJOB_INFO_2 pji2Src,
    LPBYTE       pbEnd)
{
    LPJOB_INFO_1 pji1Dst;
    LPJOB_INFO_2 pji2Dst;
    LPJOB_INFO_3 pji3Dst;
    LPJOBMAP     pjm;
    LPDWORD      pOffsets;
    DWORD        cbDM;
    LPTSTR*      lpszSrc;
    LPTSTR       aszSrc[(sizeof(JOB_INFO_2) / sizeof(LPTSTR))];


    static DWORD s_JI1Offsets[] = {

        offsetof(LPJOB_INFO_1, pPrinterName),
        offsetof(LPJOB_INFO_1, pMachineName),
        offsetof(LPJOB_INFO_1, pUserName),
        offsetof(LPJOB_INFO_1, pDocument),
        offsetof(LPJOB_INFO_1, pDatatype),
        offsetof(LPJOB_INFO_1, pStatus),
        0xFFFFFFFF
    };

    static DWORD s_JI2Offsets[] = {

        offsetof(LPJOB_INFO_2, pPrinterName),
        offsetof(LPJOB_INFO_2, pMachineName),
        offsetof(LPJOB_INFO_2, pUserName),
        offsetof(LPJOB_INFO_2, pDocument),
        offsetof(LPJOB_INFO_2, pNotifyName),
        offsetof(LPJOB_INFO_2, pDatatype),
        offsetof(LPJOB_INFO_2, pPrintProcessor),
        offsetof(LPJOB_INFO_2, pParameters),
        offsetof(LPJOB_INFO_2, pDriverName),
        offsetof(LPJOB_INFO_2, pDevMode),
        offsetof(LPJOB_INFO_2, pStatus),
        offsetof(LPJOB_INFO_2, pSecurityDescriptor),
        0xFFFFFFFF
    };

    static DWORD s_JI3Offsets[]={0xFFFFFFFF};


    // Set the start of the string-buffer.
    //
    ZeroMemory((PVOID)aszSrc, sizeof(aszSrc));
    lpszSrc = aszSrc;


    // Process the appropriate structure.
    //
    switch (dwLevel) {

    case PRINT_LEVEL_1:

        pji1Dst  = (LPJOB_INFO_1)pbJobDst;
        pOffsets = s_JI1Offsets;


        // Copy fixed values.
        //
        pji1Dst->JobId        = pji2Src->JobId;
        pji1Dst->Status       = pji2Src->Status;
        pji1Dst->Priority     = pji2Src->Priority;
        pji1Dst->Position     = pji2Src->Position;
        pji1Dst->TotalPages   = pji2Src->TotalPages;
        pji1Dst->PagesPrinted = pji2Src->PagesPrinted;
        pji1Dst->Submitted    = pji2Src->Submitted;


        // Copy strings.
        //
        *lpszSrc++ = pji2Src->pPrinterName;
        *lpszSrc++ = pji2Src->pMachineName;
        *lpszSrc++ = pji2Src->pUserName;
        *lpszSrc++ = pji2Src->pDocument;
        *lpszSrc++ = pji2Src->pDatatype;
        *lpszSrc++ = pji2Src->pStatus;

        break;

    case PRINT_LEVEL_2:

        pji2Dst  = (LPJOB_INFO_2)pbJobDst;
        pOffsets = s_JI2Offsets;


        // Copy fixed values.
        //
        pji2Dst->JobId               = pji2Src->JobId;
        pji2Dst->Status              = pji2Src->Status;
        pji2Dst->Priority            = pji2Src->Priority;
        pji2Dst->Position            = pji2Src->Position;
        pji2Dst->StartTime           = pji2Src->StartTime;
        pji2Dst->UntilTime           = pji2Src->UntilTime;
        pji2Dst->TotalPages          = pji2Src->TotalPages;
        pji2Dst->Size                = pji2Src->Size;
        pji2Dst->Submitted           = pji2Src->Submitted;
        pji2Dst->Time                = pji2Src->Time;
        pji2Dst->PagesPrinted        = pji2Src->PagesPrinted;
        pji2Dst->pSecurityDescriptor = NULL;
        pji2Dst->pDevMode            = NULL;


        // Copy strings.
        //
        *lpszSrc++ = pji2Src->pPrinterName;
        *lpszSrc++ = pji2Src->pMachineName;
        *lpszSrc++ = pji2Src->pUserName;
        *lpszSrc++ = pji2Src->pDocument;
        *lpszSrc++ = pji2Src->pNotifyName;
        *lpszSrc++ = pji2Src->pDatatype;
        *lpszSrc++ = pji2Src->pPrintProcessor;
        *lpszSrc++ = pji2Src->pParameters;
        *lpszSrc++ = pji2Src->pDriverName;
        *lpszSrc++ = NULL;
        *lpszSrc++ = pji2Src->pStatus;
        *lpszSrc++ = NULL;


        if (pji2Src->pDevMode) {

            cbDM = pji2Src->pDevMode->dmSize + pji2Src->pDevMode->dmDriverExtra;

            pbEnd -= cbDM;
            pbEnd  = (LPBYTE)((UINT_PTR)pbEnd & ~((UINT_PTR)sizeof(UINT_PTR) - 1));

            pji2Dst->pDevMode = (LPDEVMODE)pbEnd;

            CopyMemory(pji2Dst->pDevMode, pji2Src->pDevMode, cbDM);
        }

        break;

    case PRINT_LEVEL_3:

        pji3Dst  = (LPJOB_INFO_3)pbJobDst;
        pOffsets = s_JI3Offsets;

        pji3Dst->JobId = pji2Src->JobId;
        break;
    }


    return utlPackStrings(aszSrc, (LPBYTE)pbJobDst, pOffsets, pbEnd);
}

BOOL ppjob_CalcAndCopyJob(
    LPBYTE          pbJob,
    DWORD           cbJob,
    PDWORD          pcbNeed,
    PJOB_INFO_2     pji2,
    DWORD           dwLevel)
{

    BOOL bRet = FALSE;
    LPBYTE  pbEnd;

    // Fill in what we need.
    //
    *pcbNeed = ppjob_GetJobSize(pji2, dwLevel);

    // If our buffer is big-enough, then
    // proceed to fill in the info.
    //
    if (cbJob >= *pcbNeed) {

        pbEnd = pbJob + cbJob;

        ppjob_CopyJob(pbJob, dwLevel, pji2, pbEnd);

        bRet = TRUE;

    } else {

        SetLastError (ERROR_INSUFFICIENT_BUFFER);
    }

    return bRet;
}


/*****************************************************************************\
* ppjob_IppEnuRsp (Local Callback Routine)
*
* Retrieves a get response from the IPP server.  Our (lParam) in the
* parameter list references a LPPPJOB_ENUM pointer which we are to fill
* in from the enumeration.
*
\*****************************************************************************/
BOOL CALLBACK ppjob_IppEnuRsp(
    CAnyConnection  *pConnection,
    HINTERNET       hReq,
    PCINETMONPORT   pIniPort,
    LPARAM          lParam)
{
    HANDLE          hIpp;
    DWORD           dwRet;
    DWORD           cbRd;
    LPBYTE          pbEnd;
    DWORD           idx;
    DWORD           idx2;
    LPBYTE          lpDta;
    DWORD           cbDta;
    LPIPPRET_ENUJOB lpRsp;
    DWORD           cbRsp;
    LPPPJOB_ENUM    pje;
    LPIPPJI2        pji2;
    LPJOBMAP        pjm;
    PDWORD          pidJob;
    DWORD           cbSize;
    PJOBMAP*        pjmList;
    BYTE            bBuf[MAX_IPP_BUFFER];
    BOOL            bRet = FALSE;
    time_t          dwPrinterT0;



    if (hIpp = WebIppRcvOpen(IPP_RET_ENUJOB)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile ( pConnection, hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (bRet = lpRsp->bRet) {


                        if (lpRsp->cItems && lpRsp->cbItems) {

                            semEnterCrit();
                            pjmList = pIniPort->GetPJMList();

                            pjmCleanRemoteFlag(pjmList);

                            pji2  = lpRsp->pItems;

                            // We go over the IPP response and put them into PJM list
                            // At the mean time, we convert the remote job ID to
                            // local job id and store them into the IPP response
                            // data structure.
                            //

                            for (idx = 0; idx < lpRsp->cItems; idx++) {

                                // Fixup the job-id to the local id we
                                // can deal with.
                                //
                                pidJob = & (pji2[idx].ji2.JobId);

                                if (pjm = pjmFind(pjmList, PJM_REMOTEID, *pidJob)) {

                                    *pidJob = pjmJobId(pjm, PJM_LOCALID);

                                } else {

                                    if (pjm = pjmAdd(pjmList, pIniPort, NULL, NULL))
                                        pjmSetJobRemote(pjm, *pidJob, pji2[idx].ipp.pJobUri);

                                    *pidJob = pjmJobId(pjm, PJM_LOCALID);
                                }
                            }

                            // Call our routine to clean our client-list
                            // of jobs.  This will remove any entries
                            // that no longer exist on the server.
                            //
                            cbSize = sizeof(PPJOB_ENUM) + lpRsp->cbItems;

                            // Allocate storage for enumeration.
                            //
                            if (pje = (LPPPJOB_ENUM)memAlloc(cbSize)) {
                                dwPrinterT0 = pIniPort->GetPowerUpTime();
                                // This now containts the powerup time for the printer in
                                // our time


                                pje->cItems = lpRsp->cItems;
                                pje->cbSize = lpRsp->cbItems;


                                pji2  = lpRsp->pItems;
                                pbEnd = ((LPBYTE)pje->ji2) + pje->cbSize;

                                for (idx = 0; idx < lpRsp->cItems; idx++) {


                                    pbEnd = ppjob_CopyJob((LPBYTE)&pje->ji2[idx],
                                                          2,
                                                          &pji2[idx].ji2,
                                                          pbEnd);

                                    WebIppConvertSystemTime(&pje->ji2[idx].ji2.Submitted, dwPrinterT0);

                                }


                                pjmRemoveOldEntries(pjmList);

                                semLeaveCrit();

                                *((LPPPJOB_ENUM *)lParam) = pje;

                            } else {

                                SetLastError(ERROR_OUTOFMEMORY);
                            }
                        }
                        else {

                            //
                            // This is the case where the job count is 0 on the server
                            // We still need to allocate the structure so that the client
                            // enum-job function can merge the localjobs.
                            //

                            cbSize = sizeof(PPJOB_ENUM);

                            // Allocate storage for enumeration.
                            //
                            if (pje = (LPPPJOB_ENUM)memAlloc(cbSize)) {

                                pje->cItems = 0;
                                pje->cbSize = 0;

                                *((LPPPJOB_ENUM *)lParam) = pje;

                            } else {

                                SetLastError(ERROR_OUTOFMEMORY);
                            }
                        }


                    } else {

                        SetLastError(lpRsp->dwLastError);
                    }

                    WebIppFreeMem(lpRsp);

                    goto EndEnuRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //
                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("ppjob_IppEnuRsp : Receive Data Error")));
                    SetLastError(ERROR_INVALID_DATA);

                    goto EndEnuRsp;
                }

            } else {

                goto EndEnuRsp;
            }
        }

EndEnuRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* ppjob_IppSetRsp (Local Callback Routine)
*
* Retrieves a SetJob response from the IPP server
*
\*****************************************************************************/
BOOL CALLBACK ppjob_IppSetRsp(
    CAnyConnection  *pConnection,
    HINTERNET       hReq,
    PCINETMONPORT   pIniPort,
    LPARAM          lParam)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_JOB lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen((WORD)(LPARAM)lParam)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile (pConnection, hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if ((bRet = lpRsp->bRet) == FALSE)
                        SetLastError(lpRsp->dwLastError);

                    WebIppFreeMem(lpRsp);

                    goto EndSetRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //

                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("ppjob_IppSetRsp : Receive Data Error")));
                    SetLastError(ERROR_INVALID_DATA);

                    goto EndSetRsp;
                }

            } else {

                goto EndSetRsp;
            }
        }

EndSetRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* ppjob_IppGetRsp (Local Callback Routine)
*
* Retrieves a get response from the IPP server.  Our (lParam) in the
* parameter list references a JOB_INFO_2 pointer which we are to fill
* in from the call.
*
\*****************************************************************************/
BOOL CALLBACK ppjob_IppGetRsp(
    CAnyConnection  *pConnection,
    HINTERNET       hReq,
    PCINETMONPORT   pIniPort,
    LPARAM          lParam)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       pbEnd;
    DWORD        idx;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_JOB lpRsp;
    DWORD        cbRsp;
    LPJOB_INFO_2 pji2;
    LPJOBMAP     pjm;
    DWORD        cbSize;
    BYTE         bBuf[MAX_IPP_BUFFER];
    PJOBMAP*     pjmList;
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen(IPP_RET_GETJOB)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile ( pConnection, hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (bRet = lpRsp->bRet) {

                        cbSize = ppjob_GetJobSize(&lpRsp->ji.ji2, 2);

                        // Allocate storage for enumeration.
                        //
                        if (pji2 = (LPJOB_INFO_2)memAlloc(cbSize)) {

                            pbEnd = ((LPBYTE)pji2) + cbSize;

                            ppjob_CopyJob((LPBYTE)pji2, 2, &lpRsp->ji.ji2, pbEnd);


                            semEnterCrit();

                            pjmList = pIniPort->GetPJMList();


                            // Fixup the job-id to the local id we
                            // can deal with.
                            //
                            if (pjm = pjmFind(pjmList, PJM_REMOTEID, pji2->JobId)) {

                                pji2->JobId = pjmJobId(pjm, PJM_LOCALID);

                            } else {

                                if (pjm = pjmAdd(pjmList, pIniPort, NULL, NULL))
                                    pjmSetJobRemote(pjm, pji2->JobId, lpRsp->ji.ipp.pJobUri);

                                pji2->JobId = pjmJobId(pjm, PJM_LOCALID);
                            }

                            semLeaveCrit();


                            *((LPJOB_INFO_2 *)lParam) = pji2;

                        } else {

                            SetLastError(ERROR_OUTOFMEMORY);
                        }


                    } else {

                        SetLastError(lpRsp->dwLastError);
                    }

                    WebIppFreeMem(lpRsp);

                    goto EndGetRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //
                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("ppjob_IppGetRsp - Err : Receive Data Error (dwRet=%d, LE=%d)"),
                         dwRet, WebIppGetError(hIpp)));

                    SetLastError(ERROR_INVALID_DATA);

                    goto EndGetRsp;
                }

            } else {

                goto EndGetRsp;
            }
        }

EndGetRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* ppjob_Set (Local Routine)
*
* Sets a job command in the queue.
*
\*****************************************************************************/
BOOL ppjob_Set(
    PCINETMONPORT   pIniPort,
    DWORD           idJob,
    DWORD           dwCmd)
{
    PIPPREQ_SETJOB psj;
    PJOBMAP        pjm;
    WORD           wReq;
    REQINFO        ri;
    DWORD          dwRet;
    LPBYTE         lpIpp;
    DWORD          cbIpp;
    PJOBMAP*       pjmList;
    BOOL           bRet = FALSE;



    // Make sure we have a JobMap entry which we can
    // obtain the remote information.
    //
    pjmList = pIniPort->GetPJMList();

    if (pjm = pjmFind(pjmList, PJM_LOCALID, idJob)) {

        // If we're still spooling, then we haven't yet
        // hit the server.  Otherwise, we've performed the EndDoc()
        // and the job is being processed remotely.
        //
        if (pjmChkState(pjm, PJM_SPOOLING)) {

            switch (dwCmd) {
            case JOB_CONTROL_CANCEL:
            case JOB_CONTROL_DELETE:
                pjmSetState(pjm, PJM_CANCEL);
#ifdef WINNT32
                //
                //  If the async thread is on, we let that thread to clean the job queue
                //
                if (!pjmChkState(pjm, PJM_ASYNCON))
                {
                    //
                    // Otherwise, we delete the job here.
                    //
                    pjmClrState (pjm, PJM_SPOOLING);
                }
#endif
                break;

            case JOB_CONTROL_PAUSE:
                pjmSetState(pjm, PJM_PAUSE);
                break;

            case JOB_CONTROL_RESUME:
                pjmClrState(pjm, PJM_PAUSE);
                break;

            case JOB_CONTROL_RESTART:
#ifdef WINNT32
                pjmUpdateLocalJobStatus (pjm, JOB_STATUS_RESTART);

                if (!pjmChkState(pjm, PJM_ASYNCON))
                {
                    _ppprn_end_docprinter_async (pIniPort, pjm);
                }
#else
                pjmClrState(pjm, PJM_PAUSE);
#endif
                break;
            }

            bRet = TRUE;

        } else {

            // Look through list to get local/remote job mappings.
            //
            psj = WebIppCreateSetJobReq(pjmJobId(pjm, PJM_REMOTEID),
                                        dwCmd,
                                        pIniPort->GetPortName());

            if (psj) {

                switch (dwCmd) {
                case JOB_CONTROL_CANCEL:
                case JOB_CONTROL_DELETE:
                    wReq = IPP_REQ_CANCELJOB;
                    break;

                case JOB_CONTROL_PAUSE:
                    wReq = IPP_REQ_PAUSEJOB;
                    break;

                case JOB_CONTROL_RESUME:
                    wReq = IPP_REQ_RESUMEJOB;
                    break;

                case JOB_CONTROL_RESTART:
                    wReq = IPP_REQ_RESTARTJOB;
                    break;

                default:
                    wReq = 0;
                    break;
                }


                // Convert the reqest to IPP, and perform the
                // post.
                //
                ZeroMemory(&ri, sizeof(REQINFO));
                ri.cpReq = CP_UTF8;
                ri.idReq = wReq;

                ri.fReq[0] = IPP_REQALL;
                ri.fReq[1] = IPP_REQALL;

                dwRet = WebIppSndData(wReq,
                                      &ri,
                                      (LPBYTE)psj,
                                      psj->cbSize,
                                      &lpIpp,
                                      &cbIpp);


                // The request-structure has been converted to IPP format,
                // so it is ready to go to the server.
                //
                if (dwRet == WEBIPP_OK) {

                    bRet = pIniPort->SendReq(lpIpp,
                                             cbIpp,
                                             ppjob_IppSetRsp,
                                             (LPARAM)(wReq | IPP_RESPONSE),
                                             TRUE);

                    WebIppFreeMem(lpIpp);

                } else {

                    SetLastError(ERROR_OUTOFMEMORY);
                }

                // Once we've verified the request for cancel, then
                // we should remove the job from our list.
                //
                // NOTE: Should this be deleted always?  Or should
                //       we make this dependent on the success of
                //       the server-call?
                //
                //       06-Jan-1998 <chriswil> Will Revisit.
                //
                if (dwCmd == JOB_CONTROL_CANCEL)
                    pjmDel(pjmList, pjm);

                WebIppFreeMem(psj);

            } else {

                SetLastError(ERROR_OUTOFMEMORY);
            }
        }

    } else {

        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return bRet;
}


/*****************************************************************************\
* ppjob_Enum (Local Routine)
*
* Enumerates jobs.  IPP has the ENUJOB request which can be used for both
* specific jobs, or enumerated-jobs.  We will distinguish whether we're
* enumerating by a (IPP_GETJOB_ALL) job-id.
*
\*****************************************************************************/
BOOL ppjob_Enum(
    PCINETMONPORT   pIniPort,
    DWORD           nJobStart,
    DWORD           cJobs,
    DWORD           dwLevel,
    LPBYTE          pbJob,
    DWORD           cbJob,
    LPDWORD         pcbNeed,
    LPDWORD         pcItems)
{
    PIPPREQ_ENUJOB pgj;
    REQINFO        ri;
    DWORD          dwRet;
    LPBYTE         lpIpp;
    DWORD          cbIpp;
    DWORD          idx;
    DWORD          cbSize;
    DWORD          cbIdx;
    DWORD          dwLastError = ERROR_INVALID_DATA;
    LPBYTE         pbEnd;
    LPPPJOB_ENUM   pje = NULL;
    BOOL           bRet = FALSE;
    DWORD          curIdx = 0;
    DWORD          dwLocalJobCount = 0;
    DWORD          cbLocalJobSize = 0;
    PJOBMAP*       pjmList;
    PJOBMAP        pjmTmpList;
    JOB_INFO_2     JobInfo2;
    BOOL           bFound;


    // Specifying (IPP_GETJOB_ALL) will enumerate all jobs.
    //

    pjmList = pIniPort->GetPJMList ();
    pbEnd = pbJob + cbJob;
    cbIdx = ppjob_GetOneSize (dwLevel);

    if (pIniPort->BeginReadEnumJobsCache (&pje)) {

        bRet        = TRUE;
        dwLastError = GetLastError();

        // Upon return, our (pje) pointer contains an
        // enumeration structure of JOB_INFO_2 items.
        //
        // Based upon the level passed in, we need to either
        // return these items or a converted JOB_INFO_1.
        //
        if (pje) {

            // Calculate the size we'll need to store the
            // enumerated items.
            //
            for (idx = 0, cbSize = 0; idx < pje->cItems; idx++)
                cbSize += ppjob_GetJobSize(&pje->ji2[idx].ji2, dwLevel);

            dwLocalJobCount = pjmGetLocalJobCount(pjmList, &cbLocalJobSize);

            if (dwLocalJobCount > 0) {

                cbSize += cbLocalJobSize;
            }

            // Fill in the return-value indicating
            // the buffer necessary to hold the items.
            //
            *pcbNeed = cbSize;


            // If the user buffer is of sufficient size,
            // then copy/convert the items.
            //
            if (cbJob >= cbSize) {

                *pcItems = pje->cItems + dwLocalJobCount;


                for (idx = 0; idx < pje->cItems && cJobs; idx++) {

                    if ((idx >= nJobStart)) {

                        pbEnd = ppjob_CopyJob(pbJob,
                                              dwLevel,
                                              &pje->ji2[idx].ji2,
                                              pbEnd);


                        pbJob += cbIdx;

                        cJobs--;
                    }
                }

                curIdx = idx;
            } else {
                bRet        = FALSE;
                dwLastError = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    }
    else {

        dwLocalJobCount = pjmGetLocalJobCount(pjmList, &cbLocalJobSize);

        if (dwLocalJobCount > 0) {

            cbSize = cbLocalJobSize;

            // Fill in the return-value indicating
            // the buffer necessary to hold the items.
            //
            *pcbNeed = cbSize;

            // If the user buffer is of sufficient size,
            // then copy/convert the items.
            //
            if (cbJob >= cbSize) {

                *pcItems = dwLocalJobCount;
                bRet = TRUE;

            } else {
                bRet        = FALSE;
                dwLastError = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else {
            dwLastError = GetLastError();
        }

    }

    if (bRet) {

        pjmTmpList = *pjmList;

        for (idx = curIdx; idx < curIdx + dwLocalJobCount && cJobs; idx++) {

            pjmTmpList = pjmNextLocalJob (&pjmTmpList, &JobInfo2, &bFound);

            if ((idx >= nJobStart)) {

                if (bFound) {

                    DBG_ASSERT( ((pbJob < pbEnd)?TRUE:FALSE),
                                (TEXT("ppjob_Enum: idx = %d, cbIdx = %d, cJobs = %d dwLocalJobCount = %d dwLocalSize=%d, pjd=%p\n"),
                                idx, cbIdx, cJobs, dwLocalJobCount, dwLocalJobCount, pje));

                    pbEnd = ppjob_CopyJob(pbJob,
                                          dwLevel,
                                          &JobInfo2,
                                          pbEnd);



                    pbJob += cbIdx;

                    cJobs--;
                }
                else {
                    bRet = FALSE;
                    dwLastError = ERROR_INVALID_PARAMETER;
                    break;
                }

            }
        }
    }

    // This function has to be called to release the critical section
    //
    pIniPort->EndReadEnumJobsCache ();

    if (!bRet) {

        SetLastError(dwLastError);
    }

    return bRet;
}

/*****************************************************************************\
* ppjob_EnumForCache (Local Routine)
*
* Enumerates jobs.  IPP has the ENUJOB request which can be used for both
* specific jobs, or enumerated-jobs.  We will distinguish whether we're
* enumerating by a (IPP_GETJOB_ALL) job-id.
*
* Upon return,  ppbJob stores a pointer to the cache
*
\*****************************************************************************/
BOOL ppjob_EnumForCache(
    PCINETMONPORT   pIniPort,
    LPPPJOB_ENUM    *ppje)
{
    PIPPREQ_ENUJOB pgj;
    REQINFO        ri;
    DWORD          dwRet;
    LPBYTE         lpIpp;
    DWORD          cbIpp;
    DWORD          idx;
    DWORD          cbSize;
    DWORD          cbIdx;
    DWORD          dwLastError = ERROR_INVALID_DATA;
    LPBYTE         pbEnd;
    LPPPJOB_ENUM   pje = NULL;
    BOOL           bRet = FALSE;



    // Specifying (IPP_GETJOB_ALL) will enumerate all jobs.
    //
    pgj = WebIppCreateEnuJobReq(IPP_GETJOB_ALL, pIniPort->GetPortName());

    if (pgj) {

        // Convert the reqest to IPP, and perform the
        // post.
        //
        ZeroMemory(&ri, sizeof(REQINFO));
        ri.cpReq = CP_UTF8;
        ri.idReq = IPP_REQ_ENUJOB;

        ri.fReq[0] = IPP_REQALL;
        ri.fReq[1] = IPP_REQALL;

        dwRet = WebIppSndData(IPP_REQ_ENUJOB,
                              &ri,
                              (LPBYTE)pgj,
                              pgj->cbSize,
                              &lpIpp,
                              &cbIpp);


        // The request-structure has been converted to IPP format,
        // so it is ready to go to the server.
        //
        if (dwRet == WEBIPP_OK) {

            // This routine returns with a LastError set to that
            // which the response-routine sets.
            //
            if (pIniPort->SendReq(lpIpp,
                                  cbIpp,
                                  ppjob_IppEnuRsp,
                                  (LPARAM)&pje,
                                  TRUE)) {

                dwLastError = GetLastError();
                bRet        = TRUE;
                *ppje       = pje;

            } else {

                dwLastError = GetLastError();
            }

            WebIppFreeMem(lpIpp);

        } else {

            dwLastError = ERROR_OUTOFMEMORY;
        }

        WebIppFreeMem(pgj);

    } else {

        dwLastError = ERROR_OUTOFMEMORY;
    }

    if (!bRet) {

        SetLastError(dwLastError);
    }

    return bRet;
}

/*****************************************************************************\
* ppjob_Get (Local Routine)
*
* Returns information regarding a job.
*
\*****************************************************************************/
BOOL ppjob_Get(
    PCINETMONPORT   pIniPort,
    DWORD           idJob,
    DWORD           dwLevel,
    LPBYTE          pbJob,
    DWORD           cbJob,
    LPDWORD         pcbNeed)
{
    PJOBMAP        pjm;
    PIPPREQ_GETJOB pgj;
    REQINFO        ri;
    LPBYTE         lpIpp;
    DWORD          cbIpp;
    DWORD          dwRet;
    LPBYTE         pbEnd;
    PJOBMAP*       pjmList;
    LPJOB_INFO_2   pji2 = NULL;
    BOOL           bRet = FALSE;
    DWORD          dwLastError = ERROR_INVALID_DATA;


    // Look in our JobMap list for the local-job-id.  If we see
    // one, the we can get the job-information.
    //
    pjmList = pIniPort->GetPJMList();

    if (pjm = pjmFind(pjmList, PJM_LOCALID, idJob)) {

        if (pjm->bRemoteJob) {

            // Build a request-structure that we will pass into
            // the IPP layer for processing.
            //
            pgj = WebIppCreateGetJobReq(pjmJobId(pjm, PJM_REMOTEID), pIniPort->GetPortName());

            if (pgj) {

                // Convert the reqest to IPP that is suitible for
                // our post.
                //
                ZeroMemory(&ri, sizeof(REQINFO));
                ri.cpReq = CP_UTF8;
                ri.idReq = IPP_REQ_GETJOB;

                ri.fReq[0] = IPP_REQALL;
                ri.fReq[1] = IPP_REQALL;

                dwRet = WebIppSndData(IPP_REQ_GETJOB,
                                      &ri,
                                      (LPBYTE)pgj,
                                      pgj->cbSize,
                                      &lpIpp,
                                      &cbIpp);


                // The request-structure has been converted to IPP format,
                // so it is ready to go to the server.  We set a callback
                // to the function that will receive our data.
                //
                if (dwRet == WEBIPP_OK) {

                    pIniPort->SendReq(lpIpp,
                                      cbIpp,
                                      ppjob_IppGetRsp,
                                      (LPARAM)&pji2,
                                      TRUE);


                    // Upon return, our (pji2) contains the JOB_INFO_2
                    // structure.
                    //
                    if (pji2) {

                        bRet = ppjob_CalcAndCopyJob(pbJob, cbJob, pcbNeed, pji2, dwLevel);

                        if (!bRet) {
                            dwLastError = GetLastError ();
                        }

                        memFree(pji2, memGetSize(pji2));
                    }

                    WebIppFreeMem(lpIpp);

                } else {

                    dwLastError = ERROR_OUTOFMEMORY;
                }

                WebIppFreeMem(pgj);

            } else {

                dwLastError = ERROR_OUTOFMEMORY;
            }
        }
        else {

            //
            // This is a local job
            //

            if (pjm = pjmFind(pjmList, PJM_LOCALID, idJob)) {

                JOB_INFO_2 JobInfo2;
                BOOL bFound;

                pjmNextLocalJob(&pjm, &JobInfo2, &bFound);

                if (bFound) {

                    bRet = ppjob_CalcAndCopyJob(pbJob, cbJob, pcbNeed, &JobInfo2, dwLevel);

                    if (!bRet) {
                        dwLastError = GetLastError ();
                    }
                }
                else
                    dwLastError = ERROR_INVALID_PARAMETER;

            } else {
                dwLastError = ERROR_INVALID_PARAMETER;
            }

        }

    } else {

        dwLastError = ERROR_INVALID_PARAMETER;
    }


    // Set the lasterror if failure.
    //
    if (!bRet) {

        SetLastError(dwLastError);
    }

    return bRet;
}

#ifdef WINNT32
/*****************************************************************************\
* ppjob_Add (Local Routine)
*
* Returns information for an addjob call.
*
\*****************************************************************************/
BOOL ppjob_Add(
    HANDLE          hPrinter,
    PCINETMONPORT   pIniPort,
    DWORD           dwLevel,
    LPCTSTR         lpszName,
    LPBYTE          pbData,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded)
{
    PJOBMAP  pjm;
    LPCTSTR  lpszSplFile;
    LPTSTR*  lpszSrc;
    LPBYTE   pbEnd;
    PJOBMAP* pjmList;
    LPTSTR   aszSrc[(sizeof(ADDJOB_INFO_1) / sizeof(LPTSTR))];
    BOOL     bRet = FALSE;

    static DWORD s_AJI1Offsets[] = {
        offsetof(LPADDJOB_INFO_1, Path),
        0xFFFFFFFF
    };


    // Create a spool-file and job that we will use
    // for this AddJob() call.
    //
    pjmList = pIniPort->GetPJMList();

    if (pjm = pjmAdd(pjmList, pIniPort, lpszName, NULL)) {

        // Set the job into spooling-state.  This internally
        // creates the spool-file.  By specifying PJM_NOOPEN,
        // we indicate that no open-handles are to be maintained
        // on the spool-file.
        //
        if (pjmSetState(pjm, PJM_SPOOLING | PJM_NOOPEN)) {

            // Get the spool-file.
            //
            lpszSplFile = pjmSplFile(pjm);


            // If a return-size is provided, then set it.
            //
            if (pcbNeeded)
                *pcbNeeded = sizeof(ADDJOB_INFO_1) + utlStrSize(lpszSplFile);


            // If the buffer is capable of holding the
            // return-structure, then proceed.
            //
            if (pbData && (cbBuf >= *pcbNeeded)) {

                // Clean out the string-array and setup
                // for building the structure.
                //
                ZeroMemory((PVOID)aszSrc, sizeof(aszSrc));
                lpszSrc = aszSrc;


                // Initialize fixed values.
                //
                ((LPADDJOB_INFO_1)pbData)->JobId = pjmJobId(pjm, PJM_LOCALID);


                // Pack the file-name into the return-structure.
                //
                pbEnd = pbData + cbBuf;
                *lpszSrc++ = (LPTSTR)lpszSplFile;
                utlPackStrings(aszSrc, pbData, s_AJI1Offsets, pbEnd);


                // Mark this printer to indicate it's in a
                // addjob.
                //
                // NOTE: do we really need to consume the printer
                //       for an AddJob().  LocalSpl does this and
                //       sets the job into the printer.  I don't
                //       see why this is necessary.
                //
                PP_SetStatus(hPrinter, PP_ADDJOB);

                bRet = TRUE;

            } else {

                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }

        } else {

            SetLastError(ERROR_FILE_NOT_FOUND);
        }

    } else {

        SetLastError(ERROR_INVALID_HANDLE);
    }

    return bRet;
}
#endif


#ifdef WINNT32
/*****************************************************************************\
* ppjob_Schedule (Local Routine)
*
* Prints the scheduled job.
*
\*****************************************************************************/
BOOL ppjob_Schedule(
    HANDLE          hPrinter,
    PCINETMONPORT   pIniPort,
    PJOBMAP         pjm)
{
    HANDLE         hOut;
    BOOL           bRemote;
    LPCTSTR        lpszUser;
    PIPPREQ_PRTJOB ppj;
    REQINFO        ri;
    LPBYTE         pbOut;
    LPBYTE         pbIpp;
    LPBYTE         pbSpl;
    DWORD          cbOut;
    DWORD          cbIpp;
    DWORD          cbSpl;
    DWORD          dwRet;
    DWORD          cbWr;
    PJOBMAP*       pjmList;
    DWORD          dwLE     = ERROR_INVALID_HANDLE;
    CFileStream    *pStream = NULL;
    CFileStream    *pSplStream = NULL;
    BOOL           bRet     = FALSE;


    // Lock the file so we can obtain the spool-data.
    //
    pjmList = pIniPort->GetPJMList();

    if (pSplStream = pjmSplLock(pjm)) {

        // Check to determine if this is a remote-call.
        //
        bRemote = TRUE;


        // Get the user-name if one was specified in AddJob().
        //
        lpszUser = pjmSplUser(pjm);


        // Create the print-job-request that we'll be using.
        //
        ppj = WebIppCreatePrtJobReq(FALSE,
                                    (lpszUser ? lpszUser : TEXT("Unknown")),
                                    (bRemote ? g_szDocRemote: g_szDocLocal),
                                    pIniPort->GetPortName());

        if (ppj) {

            ZeroMemory(&ri, sizeof(REQINFO));
            ri.cpReq = CP_UTF8;
            ri.idReq = IPP_REQ_PRINTJOB;

            ri.fReq[0] = IPP_REQALL;
            ri.fReq[1] = IPP_REQALL;

            dwRet = WebIppSndData(IPP_REQ_PRINTJOB,
                                  &ri,
                                  (LPBYTE)ppj,
                                  ppj->cbSize,
                                  &pbIpp,
                                  &cbIpp);

            // Make sure we were able to get the ipp-header.
            //
            if (dwRet == WEBIPP_OK) {

                // Create the outputfile that will be used to
                // contain both the ipp-header as well as the
                // spool-data.
                //
                if (hOut = SplCreate(pjmJobId(pjm, PJM_LOCALID), SPLFILE_SPL)) {

                    // Output the header and data.
                    //
                    if (SplWrite(hOut, pbIpp, cbIpp, &cbWr) &&
                        SplWrite(hOut, pSplStream) &&

                        // Output the request.
                        //
                        (pStream = SplLock(hOut))) {

                        bRet = pIniPort->SendReq(pStream,
                                                 (IPPRSPPROC)ppjob_IppPrtRsp,
                                                 (LPARAM)pjm,
                                                 TRUE);

                        if (bRet == FALSE)
                            dwLE = GetLastError();

                        SplUnlock(hOut);

                    } else {

                        dwLE = GetLastError();
                    }


                    // Free up the spool-output-file.
                    //
                    SplFree(hOut);

                } else {

                    dwLE = GetLastError();
                }

                WebIppFreeMem(pbIpp);

            } else {

                dwLE = ERROR_OUTOFMEMORY;
            }

            WebIppFreeMem(ppj);

        } else {

            dwLE = ERROR_OUTOFMEMORY;
        }

        pjmSplUnlock(pjm);

    } else {

        dwLE = GetLastError();
    }


    // Clear out our spooling-status.  This will close
    // and delete the spool-file as the job is now in the
    // hands of spooler.
    //
    pjmClrState(pjm, PJM_SPOOLING);


    // If a cancel was set on this job, then delete it's entry from
    // our list.
    //
    if (pjmChkState(pjm, PJM_CANCEL) && pjmList != NULL)
        pjmDel(pjmList, pjm);


    // Set lasterror if problem occured.
    //
    if (bRet == FALSE)
        SetLastError(dwLE);

    return bRet;
}
#endif


/*****************************************************************************\
* PPEnumJobs
*
* Retrives the information about a specified set of print jobs for a
* specified printer.  Returns TRUE if successful.  Otherwise, it returns
* FALSE.
*
\*****************************************************************************/
BOOL PPEnumJobs(
    HANDLE  hPrinter,
    DWORD   nJobStart,
    DWORD   cJobs,
    DWORD   dwLevel,
    LPBYTE  pbJob,
    DWORD   cbJob,
    LPDWORD pcbNeeded,
    LPDWORD pcItems)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPEnumJobs: Printer(%08lX) dwLevel(%d)"), hPrinter, dwLevel));

    semEnterCrit();

    *pcbNeeded = 0;
    *pcItems   = 0;


    // Make sure we have a valid printer handle.
    //
    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        // Attempt to get a list of jobs from the ipp print spooler.
        // Format the job information to the requested information level.
        //
        switch (dwLevel) {

        case PRINT_LEVEL_1:
        case PRINT_LEVEL_2:

            bRet = ppjob_Enum(pIniPort,
                              nJobStart,
                              cJobs,
                              dwLevel,
                              pbJob,
                              cbJob,
                              pcbNeeded,
                              pcItems);
            break;

        default:
            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPEnumJobs: Invalid Level (%d)"), dwLevel));
            SetLastError(ERROR_INVALID_LEVEL);
            break;
        }
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPGetJob
*
* Retrieves information about a print job on a specified printer.  Returns
* TRUE if successful.  Otherwise, it returns FASLSE.
*
\*****************************************************************************/
BOOL PPGetJob(
    HANDLE  hPrinter,
    DWORD   idJob,
    DWORD   dwLevel,
    LPBYTE  pbJob,
    DWORD   cbJob,
    LPDWORD pcbNeed)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPGetJob: Printer(%08lX) dwLevel(%d)"), hPrinter, dwLevel));

    semEnterCrit();

    *pcbNeed = 0;

    // Make sure we're looking at a valid printer handle.
    //
    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        // Switch on print-level.
        //
        switch (dwLevel) {

        case PRINT_LEVEL_1:
        case PRINT_LEVEL_2:

            bRet = ppjob_Get(pIniPort, idJob, dwLevel, pbJob, cbJob, pcbNeed);
            break;

        default:
            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPGetJob: Invalid Level (%d)"), dwLevel));
            SetLastError(ERROR_INVALID_LEVEL);
            break;
        }
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPSetJob
*
* Sets information for and issues commands to a print job.  Returns TRUE
* if successful.  Otherwise, it returns FALSE.
*
\*****************************************************************************/
BOOL PPSetJob(
    HANDLE hPrinter,
    DWORD  dwJobId,
    DWORD  dwLevel,
    LPBYTE pbJob,
    DWORD  dwCmd)
{
    PCINETMONPORT pIniPort;
    BOOL   bResult = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPSetJob: Printer(%08lX) dwLevel(%d)"), hPrinter, dwLevel));

    semEnterCrit();

    // Make sure we've got a valid printer handle.
    //
    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

#ifdef WINNT32

        // Set job parameters.
        //
        switch (dwLevel) {

        case PRINT_LEVEL_0:

            // Do not set parameters. (0) represents "no-command".
            //
            switch (dwCmd) {

            case JOB_CONTROL_CANCEL:
            case JOB_CONTROL_DELETE:
            case JOB_CONTROL_PAUSE:
            case JOB_CONTROL_RESUME:
            case JOB_CONTROL_RESTART:
                bResult = ppjob_Set(pIniPort, dwJobId, dwCmd);
                if (bResult) {
                    // Invalidate has to occur before notfication refresh, otherwise, you
                    // get an outdated result
                    //
                    pIniPort->InvalidateEnumJobsCache ();
                    pIniPort->InvalidateGetPrinterCache ();

                    RefreshNotification((LPINET_HPRINTER)hPrinter);
                }
                break;

            case 0:
                bResult = TRUE;
                break;
            }
            break;

        default:
            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPSetJob: Invalid Level (%d)"), dwLevel));
            SetLastError(ERROR_INVALID_LEVEL);
            break;
        }
#else

        if (dwCmd) {

            // Do not set parameters. (0) represents "no-command".
            //
            switch (dwCmd) {

            case JOB_CONTROL_CANCEL:
            case JOB_CONTROL_DELETE:
            case JOB_CONTROL_PAUSE:
            case JOB_CONTROL_RESUME:
            case JOB_CONTROL_RESTART:
                bResult = ppjob_Set(pIniPort, dwJobId, dwCmd);
                break;
            }

        } else {

            switch (dwLevel) {

            case PRINT_LEVEL_1:
            case PRINT_LEVEL_2:


            case PRINT_LEVEL_0:
            default:
                DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPSetJob: Invalid Level (%d)"), dwLevel));
                SetLastError(ERROR_INVALID_LEVEL);
                break;
            }
        }
#endif

    }

    semLeaveCrit();

    return bResult;
}


/*****************************************************************************\
* PPAddJob
*
* Sets up for a local-spooled job.  Since we are truly a remote-printer, we
* need to fail this call and signify the correct error-code.
*
\*****************************************************************************/
BOOL PPAddJob(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{

#ifdef WINNT32

    PCINETMONPORT pIniPort;
    LPTSTR lpszName;
    BOOL   bRet = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPAddJob: Printer(%08lX) dwLevel(%d)"), hPrinter, dwLevel));


    // Zero out the return-parameters.
    //
    *pcbNeeded = 0;


    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        if (pbData && pcbNeeded) {

            switch (dwLevel) {

            case PRINT_LEVEL_2:

                lpszName = (LPTSTR)(pbData + (ULONG_PTR)((LPADDJOB_INFO_2W)pbData)->pData);


                // Make sure this string-address does not extend past the
                // end of available buffer specified.
                //
                if (lpszName > (LPTSTR)(pbData + cbBuf)) {

                    SetLastError(ERROR_INVALID_LEVEL);

                    goto EndAdd;
                }


                // Ensure NULL termination.
                //
                *(PTCHAR)(((ULONG_PTR)(pbData + cbBuf - sizeof(TCHAR))&~1)) = 0;
                break;

            case PRINT_LEVEL_1:
                lpszName = NULL;
                break;

            default:
                SetLastError(ERROR_INVALID_LEVEL);
                goto EndAdd;
            }


            // Do the add.
            //
            bRet = ppjob_Add(hPrinter,
                             pIniPort,
                             dwLevel,
                             lpszName,
                             pbData,
                             cbBuf,
                             pcbNeeded);

        } else {

            SetLastError(ERROR_INVALID_PARAMETER);
        }
    }

EndAdd:

    semLeaveCrit();

    return bRet;

#else

    DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : PPAddJob: Not Supported")));

    SetLastError(ERROR_INVALID_NAME);

    return FALSE;

#endif

}


/*****************************************************************************\
* PPScheduleJob
*
* This schedules the job.  Since we don't support the PPAddJob(), this call
* must fail.
*
\*****************************************************************************/
BOOL PPScheduleJob(
    HANDLE hPrinter,
    DWORD  idJob)
{

#ifdef WINNT32

    PCINETMONPORT   pIniPort;
    PJOBMAP         pjm;
    PJOBMAP*        pjmList;
    BOOL            bRet = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPScheduleJob: Printer(%08lX) idJob(%d)"), hPrinter, idJob));

    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        pjmList = pIniPort->GetPJMList();

        if (pjm = pjmFind(pjmList, PJM_LOCALID, idJob)) {

            if (pjmChkState(pjm, PJM_SPOOLING)) {

                bRet = ppjob_Schedule(hPrinter, pIniPort, pjm);

            } else {

                SetLastError(ERROR_SPL_NO_ADDJOB);
            }

        } else {

            SetLastError(ERROR_INVALID_PARAMETER);
        }

        PP_ClrStatus(hPrinter, PP_ADDJOB);
    }

    semLeaveCrit();

    return bRet;

#else

    DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : PPScheduleJob: Not Supported")));

    SetLastError(ERROR_SPL_NO_ADDJOB);

    return FALSE;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ppport.cxx ===
/*****************************************************************************\
* MODULE: ppport.c
*
* This module contains the routines which handle port related calls.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   18-Nov-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* _ppport_validate_enumport (Local Routine)
*
* Validate the servername and level of EnumPorts.
*
\*****************************************************************************/
_inline BOOL _ppport_validate_enumport(
    LPCTSTR lpszServerName,
    DWORD   dwLevel)
{
#ifdef WINNT32
    if (MyName (lpszServerName) ) {
#else
    if (lpszServerName == NULL) {
#endif

        if (dwLevel <= PRINT_LEVEL_2) {

            return TRUE;

        } else {

            SetLastError(ERROR_INVALID_LEVEL);
        }

    } else {

        SetLastError(ERROR_INVALID_NAME);
    }

    return FALSE;
}


/*****************************************************************************\
* _ppport_validate_portname (Local Routine)
*
* Validates the portname string.
*
\*****************************************************************************/
_inline BOOL _ppport_validate_portname(
    LPCTSTR lpszPortName)
{
    if (lpszPortName == NULL) {

        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    return TRUE;
}


/*****************************************************************************\
* PPEnumPorts
*
* Enumerates the ports available through the print-provider.
*
*
\*****************************************************************************/
BOOL PPEnumPorts(
    LPTSTR  lpszServerName,
    DWORD   dwLevel,
    LPBYTE  pbPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeed,
    LPDWORD pcbRet)
{
    BOOL bRet = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPEnumPorts")));

#ifdef WINNT32

    semEnterCrit();

    if (_ppport_validate_enumport(lpszServerName, dwLevel))
        bRet = gpInetMon->InetmonEnumPorts(lpszServerName, dwLevel, pbPorts, cbBuf, pcbNeed, pcbRet);

    semLeaveCrit();

#else

    SetLastError(ERROR_INVALID_NAME);

#endif

    return bRet;
}


/*****************************************************************************\
* PPDeletePort
*
* Deletes a port from the list.
*
* The following is not true anymore -- weihaic
*
* For internal use only. THIS IS NOT EXPORTED to the spooler.
* HTTP Provider cannot remotely delete a port on the server.
*
\*****************************************************************************/
BOOL PPDeletePort(
    LPTSTR lpszServerName,
    HWND   hWnd,
    LPTSTR lpszPortName)
{
    BOOL bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPDeletePort")));

    semEnterCrit();

    if (_ppport_validate_portname(lpszPortName)) {
#ifdef WINNT32  

        DWORD dwReturned;
        DWORD dwNeeded;
        DWORD i;
        PPRINTER_INFO_5 pPrinters = NULL;
        BOOL bFound = FALSE;

        // Leave critical section to call enum printers
        semLeaveCrit();
        
        if (!EnumPrinters( PRINTER_ENUM_LOCAL, NULL, 5, NULL, 0, &dwNeeded, &dwReturned) &&
            GetLastError () == ERROR_INSUFFICIENT_BUFFER) {


            pPrinters = ( PPRINTER_INFO_5) LocalAlloc (LPTR, dwNeeded);

            if (pPrinters) {
                
                if (EnumPrinters( PRINTER_ENUM_LOCAL, NULL, 5, (PBYTE) pPrinters, 
                                  dwNeeded, &dwNeeded, &dwReturned)) {


                    for (i = 0; i< dwReturned; i++) {
                        if (!lstrcmpi (pPrinters[i].pPortName, lpszPortName)) {
                            bFound = TRUE;
                            break;
                        }
                    }

                    if (bFound) {
                        SetLastError (ERROR_BUSY);
                    }
                        
                }

                LocalFree (pPrinters);
            }
        }

        semEnterCrit();

        if (!bFound && _ppport_validate_portname(lpszPortName)) {
            bRet = gpInetMon->InetmonDeletePort(lpszPortName, hWnd, NULL);
        }

#else
        bRet = gpInetMon->InetmonDeletePort(lpszPortName, hWnd, NULL);
#endif
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPAddPort
*
* Adds a port to the list.
*
* For internal use only. THIS IS NOT EXPORTED to the spooler.
* HTTP Provider cannot remotely add a port to the server.
*
\*****************************************************************************/
BOOL PPAddPort(
    LPTSTR lpszPortName,
    HWND   hWnd,
    LPTSTR lpszMonitorName)
{
    BOOL bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPAddPort")));

    semEnterCrit();

    if (_ppport_validate_portname(lpszPortName))
        bRet = gpInetMon->InetmonAddPort(lpszPortName, lpszMonitorName);

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPConfigurePort
*
*
\*****************************************************************************/
BOOL PPConfigurePort(
    LPTSTR lpszServerName,
    HWND   hWnd,
    LPTSTR lpszPortName)
{
    return stubConfigurePort(lpszServerName, hWnd, lpszPortName);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ppprn.cxx ===
/*****************************************************************************\
* MODULE: ppprn.c
*
* This module contains the routines which control the printer during the
* course of a single job.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   09-Jun-1993 JonMarb     Created
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* _ppprn_free_hprinter (Local Routine)
*
* Free up the hPrinter  handle.
*
\*****************************************************************************/
_inline VOID _ppprn_free_hprinter(
    HANDLE hPrinter)
{
    LPINET_HPRINTER pPrt;


    if (pPrt = (LPINET_HPRINTER)hPrinter) {

#ifdef WINNT32
        DeleteHandleFromList (pPrt);
#endif

        if (pPrt->lpszName)
            memFreeStr(pPrt->lpszName);

#ifdef WINNT32

        if (pPrt->hUser)
            delete ( pPrt->hUser );

#endif

        memFree(pPrt, sizeof(INET_HPRINTER));

    }
}

/*****************************************************************************\
* _ppprn_inc_user_refcount (Local Routine)
*
* Increment the reference count for the Port on the current printer
*
\*****************************************************************************/
#ifdef WINNT32
_inline DWORD __ppprn_inc_user_refcout(
    HANDLE hPrinter ) {

    LPINET_HPRINTER pPrt;
    DWORD           dwRet = MAXDWORD;

    if (pPrt = (LPINET_HPRINTER)hPrinter) {
        dwRet = (PCINETMONPORT (pPrt->hPort))->IncUserRefCount(pPrt->hUser );

    } else
        SetLastError( ERROR_INVALID_PARAMETER );

    return dwRet;
}

#endif

/*****************************************************************************\
* _ppprn_make_hprinter (Local Routine)
*
* Returns a printer handle.
*
\*****************************************************************************/
HANDLE _ppprn_make_hprinter(
    HANDLE  hPort,
    LPCTSTR lpszPrnName)
{
    LPINET_HPRINTER pPrt;


    if (pPrt = (LPINET_HPRINTER)memAlloc(sizeof(INET_HPRINTER))) {

        pPrt->dwSignature = IPO_SIGNATURE;
        pPrt->lpszName    = memAllocStr(lpszPrnName);
        pPrt->hPort       = hPort;
        pPrt->dwStatus    = 0;
        pPrt->pjmJob      = NULL;
#ifdef WINNT32
        pPrt->hUser       = new CLogonUserData;


#endif

        if (
            pPrt->lpszName
#ifdef WINNT32
            && pPrt->hUser
            && pPrt->hUser->bValid ()
            && AddHandleToList (pPrt)
#endif
            ) {

            return (HANDLE)pPrt;

        } else {

            if (pPrt->lpszName)
                memFreeStr (pPrt->lpszName);

#ifdef WINNT32
            if (pPrt->hUser) {
                delete ( pPrt->hUser );
            }
#endif
            memFree (pPrt, sizeof(INET_HPRINTER));
        }
    }

    return NULL;
}

#ifdef WINNT32

/*****************************************************************************\
* _ppprn_free_xcv_hprinter (Local Routine)
*
* Free a xcv printer handle.
*
\*****************************************************************************/
_inline VOID _ppprn_free_xcv_hprinter(
    HANDLE hPrinter)
{
    LPINET_XCV_HPRINTER pPrt;


    if (pPrt = (LPINET_XCV_HPRINTER)hPrinter) {

        memFreeStr (pPrt->lpszName);
        memFree(pPrt, sizeof(INET_XCV_HPRINTER));

    }
}

/*****************************************************************************\
* _ppprn_make_xcv_hprinter (Local Routine)
*
* Returns a xcv printer handle.
*
\*****************************************************************************/
HANDLE _ppprn_make_xcv_hprinter(
    PCINETMONPORT  pIniPort)
{
    LPINET_XCV_HPRINTER pPrt;


    if (pPrt = (LPINET_XCV_HPRINTER)memAlloc(sizeof(INET_XCV_HPRINTER))) {

        pPrt->dwSignature = IPO_XCV_SIGNATURE;
        pPrt->lpszName    = memAllocStr(pIniPort->GetPortName());
    }

    return pPrt;
}

#endif

/*****************************************************************************\
* ppprn_IppSetRsp (Local Callback Routine)
*
* Retrieves a SetPrinter response from the IPP server
*
\*****************************************************************************/
BOOL CALLBACK ppprn_IppSetRsp(
    CAnyConnection  *pConnection,
    HINTERNET       hReq,
    PCINETMONPORT   pIniPort,
    LPARAM          lParam)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_PRN lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;

    if (hIpp = WebIppRcvOpen((WORD)(LPARAM)lParam)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile (pConnection, hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if ((bRet = lpRsp->bRet) == FALSE)
                        SetLastError(lpRsp->dwLastError);

                    WebIppFreeMem(lpRsp);

                    goto EndSetRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //

                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("ppprn_IppSetRsp - Err : Receive Data Error (dwRet=%d, LE=%d)"),
                                            dwRet, WebIppGetError(hIpp)));

                    SetLastError(ERROR_INVALID_DATA);

                    goto EndSetRsp;
                }

            } else {

                goto EndSetRsp;
            }
        }

EndSetRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* ppprn_Set (Local Routine)
*
* Sets a printer command.
*
\*****************************************************************************/
BOOL ppprn_Set(
    PCINETMONPORT   pIniPort,
    DWORD           dwCmd)
{
    PIPPREQ_SETPRN psp;
    REQINFO        ri;
    DWORD          dwRet;
    LPBYTE         lpIpp;
    DWORD          cbIpp;
    WORD           wReq;
    LPTSTR         lpszUsrName;
    BOOL           bRet = FALSE;


    // Create our ipp-reqest-structure.
    //
    if (lpszUsrName = GetUserName()) {

        psp = WebIppCreateSetPrnReq(dwCmd,
                                    lpszUsrName,
                                    pIniPort->GetPortName());


        memFreeStr(lpszUsrName);

        if (psp) {

            switch (dwCmd) {
            case PRINTER_CONTROL_PAUSE:
                wReq = IPP_REQ_PAUSEPRN;
                break;

            case PRINTER_CONTROL_RESUME:
                wReq = IPP_REQ_RESUMEPRN;
                break;

            case PRINTER_CONTROL_PURGE:
                wReq = IPP_REQ_CANCELPRN;
                break;

            default:
                wReq = 0;
                break;
            }


            // Convert the reqest to IPP, and perform the
            // post.
            //
            ZeroMemory(&ri, sizeof(REQINFO));
            ri.cpReq = CP_UTF8;
            ri.idReq = wReq;

            ri.fReq[0] = IPP_REQALL;
            ri.fReq[1] = IPP_REQALL;

            dwRet = WebIppSndData(wReq,
                                  &ri,
                                  (LPBYTE)psp,
                                  psp->cbSize,
                                  &lpIpp,
                                  &cbIpp);


            // The request-structure has been converted to IPP format,
            // so it is ready to go to the server.
            //
            if (dwRet == WEBIPP_OK) {

                bRet = pIniPort->SendReq(lpIpp,
                                                cbIpp,
                                                ppprn_IppSetRsp,
                                                (LPARAM)(wReq | IPP_RESPONSE),
                                                TRUE);

                WebIppFreeMem(lpIpp);

            } else {

                SetLastError(ERROR_OUTOFMEMORY);
            }

            WebIppFreeMem(psp);

        } else {

            SetLastError(ERROR_OUTOFMEMORY);
        }
    }

    return bRet;
}


#ifdef WINNT32

void
_ppprn_working_thread (
    PENDDOCTHREADCONTEXT pThreadData)
{
    BOOL            bRet            = FALSE;
    PJOBMAP         pjm             = pThreadData->pjmJob;
    PCINETMONPORT   pIniPort        = pThreadData->pIniPort;
    static DWORD    cdwWaitTime     = 15000;

    DBGMSGT (DBG_LEV_CALLTREE, ("Enter  _ppprn_working_thread (%p)\n", pThreadData));

    pThreadData->pSidToken->SetCurrentSid ();
    delete pThreadData->pSidToken;
    pThreadData->pSidToken = NULL;

    semEnterCrit();

    pjmUpdateLocalJobStatus (pjm, JOB_STATUS_PRINTING);

    //
    // The document is cancelled
    //
    if (pjmChkState(pThreadData->pjmJob, PJM_CANCEL)) {

        bRet = TRUE;
    }
    else {

        // Refresh the notification handle
        //
        RefreshNotificationPort (pIniPort);


        bRet = pIniPort->EndDocPort(pjm);

#if 0
        bRet = FALSE;
        //
        // This is for testing
        //
        semLeaveCrit();
        Sleep (3000);
        semEnterCrit();
#endif

    }

    //
    // Check this flags again, since we left CriticalSection during file transfer
    //
    if (pjmChkState(pThreadData->pjmJob, PJM_CANCEL)) {

        bRet = TRUE;
    }

    if (bRet) {
        //
        // Clear our spooling-state.  This will free up any spool-job-resources.
        //
        pjmClrState(pjm, PJM_SPOOLING);

        //
        // Invalidate both job and printer caches
        //
        pIniPort->InvalidateGetPrinterCache ();
        pIniPort->InvalidateEnumJobsCache ();
    }
    else {
        pjmUpdateLocalJobStatus (pjm, JOB_STATUS_ERROR);

    }

    // Refresh the notification handle
    //
    RefreshNotificationPort (pIniPort);

    //
    //  Clean the async thread flag
    //
    pjmClrState(pjm, PJM_ASYNCON);

    pIniPort->DecRef();

    semLeaveCrit();

    delete pThreadData;

    DBGMSGT (DBG_LEV_CALLTREE, ("Leave  _ppprn_working_thread (ret = %d)\n", bRet));
}


BOOL
_ppprn_end_docprinter_async (
    PCINETMONPORT       pIniPort,
    PJOBMAP             pjmJob)

{
    BOOL    bRet = FALSE;

    PENDDOCTHREADCONTEXT pThreadData = new ENDDOCTHREADCONTEXT;


    if (pThreadData) {
        pThreadData->pIniPort = pIniPort;
        pThreadData->pjmJob = pjmJob;
        pThreadData->pSidToken = new CSid;


        if (pThreadData->pSidToken && pThreadData->pSidToken->bValid ()) {
            HANDLE hThread;

            pjmSetState(pjmJob, PJM_ASYNCON);

            //
            // Increase the ref count of the port to make sure it is not deleted
            //

            pIniPort->IncRef();

            if (pIniPort->CreateTerminateEvent() &&
                (hThread = CreateThread (NULL,
                                         COMMITTED_STACK_SIZE,
                                         (LPTHREAD_START_ROUTINE)_ppprn_working_thread,
                                         (PVOID) pThreadData, 0, NULL))) {
                CloseHandle (hThread);
                bRet = TRUE;
            }
            else {

                //
                // Fail to create the thread
                //
                pIniPort->DecRef ();

                pjmClrState(pjmJob, PJM_ASYNCON);
            }
        }

        if (!bRet) {
            if (pThreadData->pSidToken) {
                delete (pThreadData->pSidToken);
                pThreadData->pSidToken = NULL;
            }

            delete (pThreadData);
        }
    }

    return bRet;
}

#endif
/*****************************************************************************\
* PP_OpenJobInfo
*
* Opens a job-information.  This is called at StartDoc timeframe when we
* need to start a spool-job.
*
\*****************************************************************************/
PJOBMAP PP_OpenJobInfo(
    HANDLE          hPrinter,
    PCINETMONPORT   pIniPort,
    LPTSTR          pDocName)
{
    PJOBMAP*        pjmList;
    LPINET_HPRINTER lpPrt = (LPINET_HPRINTER)hPrinter;
    LPTSTR          pUserName = GetUserName();


    pjmList = pIniPort->GetPJMList();

    if (lpPrt->pjmJob = pjmAdd(pjmList, pIniPort, pUserName, pDocName)) {

        // Set the state to spooling for our job-entry.  This wil
        // create the spool-file object.
        //
        pjmSetState(lpPrt->pjmJob, PJM_SPOOLING);

    }

    memFreeStr (pUserName);

    return lpPrt->pjmJob;
}


/*****************************************************************************\
* PP_CloseJobInfo
*
* Close our spool-job and clear out the information regarding a printjob from
* the printer.
*
\*****************************************************************************/
VOID PP_CloseJobInfo(
    HANDLE hPrinter)
{
    PJOBMAP*        pjmList;
    LPINET_HPRINTER lpPrt = (LPINET_HPRINTER)hPrinter;


    // Clear our spooling-state.  This will free up any spool-job-resources.
    //
    pjmClrState(lpPrt->pjmJob, PJM_SPOOLING);


    // If we had cancelled our print-job, then we can remove the
    // entry.
    //
    if (pjmChkState(lpPrt->pjmJob, PJM_CANCEL)) {

        pjmList = ((PCINETMONPORT)(lpPrt->hPort))->GetPJMList();

        pjmDel(pjmList, lpPrt->pjmJob);
    }


    // Clear out or spool-status.
    //
    lpPrt->pjmJob = NULL;
}

VOID PP_CloseJobInfo2(
    HANDLE hPrinter)
{
    PJOBMAP*        pjmList;
    LPINET_HPRINTER lpPrt = (LPINET_HPRINTER)hPrinter;

    // Clear out or spool-status.
    //
    lpPrt->pjmJob = NULL;
}


/*****************************************************************************\
* PPAbortPrinter
*
* Deletes a printer's spool file if the printer is configured for spooling.
* Returns TRUE if successful, FALSE if an error occurs.
*
\*****************************************************************************/
BOOL PPAbortPrinter(
    HANDLE hPrinter)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPAbortPrinter(%08lX)"), hPrinter));


    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        if ( PP_ChkStatus(hPrinter, PP_STARTDOC) &&
            !PP_ChkStatus(hPrinter, PP_ENDDOC)) {

            if (bRet = pIniPort->AbortPort(PP_GetJobInfo(hPrinter))) {

                // If this call was successful, the job-info
                // will have been freed.  Therefore, it is OK
                // to set the printer-jobreq to NULL.
                //
                PP_SetStatus(hPrinter, PP_CANCELLED);
                PP_ClrStatus(hPrinter, PP_STARTDOC);
                PP_CloseJobInfo(hPrinter);
            }

        } else {

            if (PP_ChkStatus(hPrinter, PP_CANCELLED))
                SetLastError(ERROR_PRINT_CANCELLED);
            else
                SetLastError(ERROR_SPL_NO_STARTDOC);

            bRet = TRUE;
        }
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPClosePrinter
*
* Closes a printer that was previously opened with PPOpenPrinter.  Returns
* TRUE if successful, FALSE if an error occurs.
*
\*****************************************************************************/
BOOL PPClosePrinter(
    HANDLE hPrinter)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;
    BOOL   bDeletePending = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPClosePrinter: Printer(%08lX)"), hPrinter));

    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandleForClose(hPrinter, &bDeletePending) ) {

        if (bDeletePending) {

            bRet = gpInetMon->InetmonReleasePort(pIniPort);
            _ppprn_free_hprinter(hPrinter);

        }
        else {


            if ( PP_ChkStatus(hPrinter, PP_STARTDOC) &&
                !PP_ChkStatus(hPrinter, PP_ENDDOC)) {

                PP_SetStatus(hPrinter, PP_ENDDOC);

                pIniPort->EndDocPort(PP_GetJobInfo(hPrinter));

                PP_ClrStatus(hPrinter, (PP_STARTDOC | PP_ENDDOC));
                PP_CloseJobInfo(hPrinter);
            }


            // Our write-port does leave the crit-sect.  If this
            // routine is called while we're still in an end-doc, then
            // we will set a zombie-flag and let the End-Doc clean up
            // the handle for us.
            //
            if (PP_ChkStatus(hPrinter, PP_ENDDOC)) {

                bRet = TRUE;

                PP_SetStatus(hPrinter, PP_ZOMBIE);

            } else {

                bRet = gpInetMon->InetmonClosePort(pIniPort, hPrinter );
                _ppprn_free_hprinter(hPrinter);
            }
        }
    }
#ifdef WINNT32
    else if (utlValidateXcvPrinterHandle(hPrinter) ) {

        //
        // We don't need to dec-ref on the http port for XCV handle
        //

        //
        // Free memory
        //
        _ppprn_free_xcv_hprinter(hPrinter);
    }
#endif

    semLeaveCrit();

    return bRet;
}

/*****************************************************************************\
* PPEndDocPrinter
*
* Ends a print job on the specified printer.  Returns TRUE if successful,
* FALSE otherwise.
*
\*****************************************************************************/

BOOL PPEndDocPrinter(
    HANDLE hPrinter)
{
    PCINETMONPORT  pIniPort;
    PJOBMAP pjmJob;
    DWORD   dwLE;
    BOOL    bRet = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPEndDocPrinter: Printer(%08lX)"), hPrinter));

    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        // Verify that we are in a StartDoc.
        //
        if ( PP_ChkStatus(hPrinter, PP_STARTDOC) &&
            !PP_ChkStatus(hPrinter, PP_ENDDOC)) {

            PP_SetStatus(hPrinter, PP_ENDDOC);


            // Get the job we're dealing with.
            //
            pjmJob = PP_GetJobInfo(hPrinter);


            // End the job.  This closes our spooling
            // and submits it to the server.  If our job was
            // cancelled at anytime prior to EndDoc(), then we should
            // only remove the local-spool-job and not hit the server.
            //
            if (pjmChkState(pjmJob, PJM_CANCEL)) {

                bRet = TRUE;

            } else {

#ifdef WINNT32
                if ((bRet = _ppprn_end_docprinter_async(pIniPort, pjmJob)) == FALSE)
                    dwLE = ERROR_CAN_NOT_COMPLETE;
#else
                if ((bRet = pIniPort->EndDocPort(pjmJob)) == FALSE)
                    dwLE = ERROR_CAN_NOT_COMPLETE;
#endif

            }

            // Clear our flags so others can use the
            // printer.
            //
            PP_ClrStatus(hPrinter, (PP_STARTDOC | PP_ENDDOC));

#ifdef WINNT32
            PP_CloseJobInfo2(hPrinter);
#else
            PP_CloseJobInfo(hPrinter);

            // Invalidate both job and printer caches
            //
            pIniPort->InvalidateGetPrinterCache ();
            pIniPort->InvalidateEnumJobsCache ();
#endif

            // Since the end-doc-port leaves the crit-sect, there's
            // the possibility that the printer-handle has been
            // closed.  If so, check for zombie-status and delete
            // the printer-handle accordingly.
            //
            if (PP_ChkStatus(hPrinter, PP_ZOMBIE)) {

                gpInetMon->InetmonClosePort(pIniPort, hPrinter);

                _ppprn_free_hprinter(hPrinter);
            }

        } else {

            if (PP_ChkStatus(hPrinter, PP_CANCELLED))
                dwLE = ERROR_PRINT_CANCELLED;
            else
                dwLE = ERROR_SPL_NO_STARTDOC;
        }

    } else {

        dwLE = ERROR_INVALID_HANDLE;
    }

    semLeaveCrit();

    if (bRet == FALSE)
        SetLastError(dwLE);

    return bRet;
}

/*****************************************************************************\
* PPEndPagePrinter
*
* Informs the printer that the data sent with WritePrinter since the last
* BeginPage functions, constitutes a page.  Returns TRUE if successful.
* Otherwise, it returns FALSE.
*
\*****************************************************************************/
BOOL PPEndPagePrinter(
    HANDLE hPrinter)
{
    BOOL bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPEndPagePrinter: hPrinter(%08lX)"), hPrinter));

    semEnterCrit();

    if (utlValidatePrinterHandle(hPrinter) != NULL) {

        if (PP_ChkStatus(hPrinter, PP_CANCELLED))
            SetLastError(ERROR_PRINT_CANCELLED);
        else
            bRet = TRUE;
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPOpenPrinter
*
* Obtains a handle for the specified printer (queue).
*
* NOTE: We're going to delay the validation of the printer-port-name until
*       later (StartDoc), as to handle cases where the server is down.  If
*       this is not done, we appear to hang at the UI as we attempt to
*       send a request to the server.
*
* Return Value:
*
*   We have to return the correct router code to the spooler
*
*       ROUTER_* status code:
*
*    ROUTER_SUCCESS, phPrinter holds return handle, name cached
*    ROUTER_UNKNOWN, printer not recognized, error updated
*    ROUTER_STOP_ROUTING, printer recognized, but failure, error updated
*
*
\*****************************************************************************/
#ifdef WINNT32

BOOL PPOpenPrinter(
    LPTSTR             lpszPrnName,
    LPHANDLE           phPrinter,
    LPPRINTER_DEFAULTS pDefaults)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;
    DWORD  dwRet = ROUTER_UNKNOWN;
    DWORD  dwLE;
    BOOL   bXcv = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPOpenPrinter: Name(%s)"), lpszPrnName));

    semEnterCrit();

    // Open the port for the printer, and create the true
    // printer handle.
    //

    if (pIniPort = gpInetMon->InetmonOpenPort(lpszPrnName, &bXcv)) {

        if (!bXcv) {
            // Not an XcvOpen call

            if (*phPrinter = _ppprn_make_hprinter(pIniPort, lpszPrnName)) {

                if (__ppprn_inc_user_refcout( *phPrinter ) != MAXDWORD ) {
                    dwRet = ROUTER_SUCCESS;
                } else {
                    _ppprn_free_hprinter( *phPrinter );
                    // This will also free the hUser
                    *phPrinter = NULL;
                    // Make sure we don't return anything and the router stops.
                    dwRet = ROUTER_STOP_ROUTING;
                }

            } else {

                SetLastError(ERROR_OUTOFMEMORY);

                gpInetMon->InetmonClosePort(pIniPort, NULL );
                dwRet = ROUTER_STOP_ROUTING;
            }
        }
        else {
            // XcvOpen call

            if (*phPrinter = _ppprn_make_xcv_hprinter(pIniPort)) {
                    dwRet = ROUTER_SUCCESS;
            }
            else {
                SetLastError(ERROR_OUTOFMEMORY);

                //
                // We don't need to dec-ref port since we never add-ref in XCV Open
                //

                dwRet = ROUTER_STOP_ROUTING;
            }
        }
    }

    semLeaveCrit();

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPOpenPrinter : Return Value(%d), LastError(%d)"), dwRet, GetLastError()));

    return dwRet;
}

#else
// Win9X Code

BOOL PPOpenPrinter(
    LPTSTR             lpszPrnName,
    LPHANDLE           phPrinter,
    LPPRINTER_DEFAULTS pDefaults)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;
    DWORD  dwRet = ROUTER_UNKNOWN;
    DWORD  dwLE;
    BOOL   bXcv = FALSE;


    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPOpenPrinter: Name(%s)"), lpszPrnName));

    semEnterCrit();

    // Open the port for the printer, and create the true
    // printer handle.
    //
    if ((pIniPort = gpInetMon->InetmonOpenPort(lpszPrnName, &bXcv)) && !bXcv) {

        if (*phPrinter = _ppprn_make_hprinter(pIniPort, lpszPrnName)) {

            dwRet = ROUTER_SUCCESS;

        } else {

            SetLastError(ERROR_OUTOFMEMORY);

            gpInetMon->InetmonClosePort(pIniPort, NULL );
        }
    }

    semLeaveCrit();

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPOpenPrinter : Return Value(%d), LastError(%d)"), dwRet, GetLastError()));

    return dwRet;
}

#endif

/*****************************************************************************\
* PPStartDocPrinter
*
* Ends a print job on the specified printer.  Returns a print job ID if
* successful.  Otherwise, it returns zero.
*
\*****************************************************************************/
DWORD PPStartDocPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE pDocInfo)
{
    PCINETMONPORT pIniPort = NULL;
    PJOBMAP pjmJob;
    DWORD   idJob = 0;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPStartDocPrinter: Printer(%08lX) dwLevel(%d)"), hPrinter, dwLevel));


    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        // Look at the support levels, then do the StartDocPrinter on
        // the port.
        //
        switch (dwLevel) {

        case PRINT_LEVEL_1:

            // Serialize access to the port.  Don't allow startdoc on
            // the printer if one is already in progress.
            //
            if (PP_ChkStatus(hPrinter, PP_STARTDOC)) {

                SetLastError(ERROR_BUSY);

            } else {

                if (pjmJob = PP_OpenJobInfo(hPrinter, pIniPort, ((PDOC_INFO_1) pDocInfo)->pDocName)) {

                    // Get the JobId for the start-doc, then set the info
                    // into the printer-handle.
                    //
                    if (pIniPort->StartDocPort(dwLevel, pDocInfo, pjmJob)) {

                        idJob = pjmJobId(pjmJob, PJM_LOCALID);

                        PP_ClrStatus(hPrinter, PP_CANCELLED);
                        PP_SetStatus(hPrinter, (PP_STARTDOC | PP_FIRSTWRITE));

                    } else {

                        PP_CloseJobInfo(hPrinter);
                    }

                } else {

                    SetLastError(ERROR_OUTOFMEMORY);
                }
            }
            break;

        default:
            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPStartDocPrinter: Invalid Level (%d)"), dwLevel));
            SetLastError(ERROR_INVALID_LEVEL);
            break;
        }
    }

    semLeaveCrit();

    return idJob;
}


/*****************************************************************************\
* PPStartPagePrinter
*
* Informs the spool subsystem that a page is about to be started on this
* printer.  Returns TRUE if successful.  Otherwise, FALSE if an error occurs.
*
\*****************************************************************************/
BOOL PPStartPagePrinter(
    HANDLE hPrinter)
{
    BOOL bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPStartPagePrinter: hPrinter(%08lX)"), hPrinter));

    semEnterCrit();

    if (utlValidatePrinterHandle(hPrinter) != NULL) {

        if (PP_ChkStatus(hPrinter, PP_CANCELLED))
            SetLastError(ERROR_PRINT_CANCELLED);
        else
            bRet = TRUE;
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPWritePrinter
*
* Sends the data pointed to by pBuf to the specified printer.  Returns TRUE
* if successful.  Otherwise, it returns FALSE.
*
\*****************************************************************************/
BOOL PPWritePrinter(
    HANDLE  hPrinter,
    LPVOID  lpvBuf,
    DWORD   cbBuf,
    LPDWORD pcbWr)
{
    PCINETMONPORT  pIniPort;
    PJOBMAP pjmJob;
    BOOL    bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPWritePrinter: Printer(%08lX)"), hPrinter));


    semEnterCrit();

    *pcbWr = 0;

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        // If we're in a start-doc, and end-doc hasn't been
        // called, then we can still write to the port.
        //
        if ( PP_ChkStatus(hPrinter, PP_STARTDOC) &&
            !PP_ChkStatus(hPrinter, PP_ENDDOC)) {


            pjmJob = PP_GetJobInfo(hPrinter);


            // If we received a SetJob(CANCEL), during the print-spooling
            // process, then we need to mark our job as done.
            //
            if (!pjmChkState(pjmJob, PJM_CANCEL)) {

                bRet = pIniPort->WritePort(pjmJob, (LPBYTE) lpvBuf, cbBuf, pcbWr);

#ifdef WINNT32
                pjmAddJobSize (pjmJob, *pcbWr);

                // We do not need to update the cache since the job info is stored locally
                //
                RefreshNotificationPort (pIniPort);
#endif

            } else {

                bRet = TRUE;

                if (pIniPort->AbortPort(pjmJob)) {

                    // If this call was successful, the job-info
                    // will have been freed.  Therefore, it is OK
                    // to set the printer-jobreq to NULL.
                    //
                    PP_SetStatus(hPrinter, PP_CANCELLED);
                    PP_ClrStatus(hPrinter, PP_STARTDOC);
                    PP_CloseJobInfo(hPrinter);
                }
            }

        } else {

            if (PP_ChkStatus(hPrinter, PP_CANCELLED))
                SetLastError(ERROR_PRINT_CANCELLED);
            else
                SetLastError(ERROR_SPL_NO_STARTDOC);
        }
    }

    semLeaveCrit();

    return bRet;
}


/*****************************************************************************\
* PPSetPrinter
*
* Set printer command.
*
\*****************************************************************************/
BOOL PPSetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE pbPrinter,
    DWORD  dwCmd)
{
    PCINETMONPORT pIniPort;
    BOOL   bRet = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPSetPrinter: Printer(%08lX)"), hPrinter));


    semEnterCrit();

    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

#ifdef WINNT32

        // Set printer parameters.
        //
        switch (dwLevel) {

        case PRINT_LEVEL_0:

            // Do not set parameters. (0) represents "no-command".
            //
            switch (dwCmd) {

            case PRINTER_CONTROL_PAUSE:
            case PRINTER_CONTROL_RESUME:
            case PRINTER_CONTROL_PURGE:
                bRet = ppprn_Set(pIniPort, dwCmd);

                if (bRet) {
                    pIniPort->InvalidateGetPrinterCache ();

                    if (dwCmd == PRINTER_CONTROL_PURGE) {
                        //
                        //  Clean job cache if the command is to cancel all documents
                        //
                        pIniPort->InvalidateEnumJobsCache ();
                    }

                    RefreshNotification((LPINET_HPRINTER)hPrinter);
                }

                break;

            case 0:
                bRet = TRUE;
                break;
            }
            break;

        default:
            DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPSetPrinter: Invalid Level (%d)"), dwLevel));
            SetLastError(ERROR_INVALID_LEVEL);
            break;
        }
#else

        if (dwCmd) {

            // Do not set parameters. (0) represents "no-command".
            //
            switch (dwCmd) {

            case PRINTER_CONTROL_PAUSE:
            case PRINTER_CONTROL_RESUME:
            case PRINTER_CONTROL_PURGE:
                bRet = ppprn_Set(pIniPort, dwCmd);
                break;
            }

        } else {

            switch (dwLevel) {

            case PRINT_LEVEL_1:
            case PRINT_LEVEL_2:

            case PRINT_LEVEL_0:
            default:
                DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPSetPrinter: Invalid Level (%d)"), dwLevel));
                SetLastError(ERROR_INVALID_LEVEL);
                break;
            }
        }
#endif

    }

    semLeaveCrit();

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ppjobs.h ===
/*****************************************************************************\
* MODULE: ppjobs.h
*
* Header file for print-job routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _PPJOBS_H
#define _PPJOBS_H


BOOL PPEnumJobs(
    HANDLE  hPrinter,
    DWORD   nJobStart,
    DWORD   cJobs,
    DWORD   dwLevel,
    LPBYTE  pbJob,
    DWORD   cbJob,
    LPDWORD pcbNeeded,
    LPDWORD pcItems);

BOOL PPGetJob(
    HANDLE  hPrinter,
    DWORD   idJob,
    DWORD   dwLevel,
    LPBYTE  pbJob,
    DWORD   cbJob,
    LPDWORD pcbNeed);

BOOL PPSetJob(
    HANDLE hPrinter,
    DWORD  dwJobId,
    DWORD  dwLevel,
    LPBYTE pbJob,
    DWORD  dwCommand);

BOOL PPAddJob(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded);

BOOL PPScheduleJob(
    HANDLE hPrinter,
    DWORD  idJob);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ppinfo.cxx ===
/*****************************************************************************\
* MODULE: ppinfo.c
*
* This module contains the print-information routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   09-Jun-1993 JonMarb     Created
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/


#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* ppprn_IppGetRsp (Local Callback Routine)
*
* Retrieves a GetPrinter response from the IPP server
*
\*****************************************************************************/
BOOL CALLBACK ppinfo_IppGetRsp(
    CAnyConnection *pConnection,
    HINTERNET hReq,
    PCINETMONPORT   pIniPort,
    LPARAM    lParam)
{
    HANDLE       hIpp;
    DWORD        dwRet;
    DWORD        cbRd;
    LPBYTE       lpDta;
    DWORD        cbDta;
    LPIPPRET_PRN lpRsp;
    DWORD        cbRsp;
    BYTE         bBuf[MAX_IPP_BUFFER];
    BOOL         bRet = FALSE;


    if (hIpp = WebIppRcvOpen(IPP_RET_GETPRN)) {

        while (TRUE) {

            cbRd = 0;
            if (pIniPort->ReadFile (pConnection, hReq, (LPVOID)bBuf, sizeof(bBuf), &cbRd) && cbRd) {

                dwRet = WebIppRcvData(hIpp, bBuf, cbRd, (LPBYTE*)&lpRsp, &cbRsp, &lpDta, &cbDta);

                switch (dwRet) {

                case WEBIPP_OK:

                    if (!lpRsp) {
                        SetLastError (ERROR_INVALID_DATA);
                    }
                    else if ((bRet = lpRsp->bRet) == FALSE)
                        SetLastError(lpRsp->dwLastError);
                    else {

                        pIniPort->SetPowerUpTime (lpRsp->pi.ipp.dwPowerUpTime);
                        ((LPPRINTER_INFO_2)lParam)->Status       = lpRsp->pi.pi2.Status;
                        ((LPPRINTER_INFO_2)lParam)->cJobs        = lpRsp->pi.pi2.cJobs;
                        ((LPPRINTER_INFO_2)lParam)->pPrinterName = memAllocStr(lpRsp->pi.pi2.pPrinterName);
                        ((LPPRINTER_INFO_2)lParam)->pDriverName  = memAllocStr(lpRsp->pi.pi2.pDriverName);
                    }

                    WebIppFreeMem(lpRsp);

                    goto EndGetRsp;

                case WEBIPP_MOREDATA:

                    // Need to do another read to fullfill our header-response.
                    //

                    break;

                default:

                    DBG_MSG(DBG_LEV_ERROR, (TEXT("ppinfo_IppGetRsp - Err : Receive Data Error (dwRet=%d, LE=%d)"),
                         dwRet, WebIppGetError(hIpp)));

                    SetLastError(ERROR_INVALID_DATA);

                    goto EndGetRsp;
                }

            } else {

                goto EndGetRsp;
            }
        }

EndGetRsp:

        WebIppRcvClose(hIpp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* ppinfo_Get (Local Routine)
*
* Gets printer info from server.
*
\*****************************************************************************/
BOOL ppinfo_Get(
    PCINETMONPORT           pIniPort,
    LPPRINTER_INFO_2 ppi2)
{
    PIPPREQ_GETPRN pgp;
    REQINFO        ri;
    DWORD          dwRet;
    LPBYTE         lpIpp;
    DWORD          cbIpp;
    LPCTSTR        lpszUri;
    BOOL           bRet = FALSE;

    lpszUri = pIniPort->GetPortName();


    // Create our ipp-reqest-structure.
    //
    if (pgp = WebIppCreateGetPrnReq(0, lpszUri)) {

        // Convert the reqest to IPP, and perform the
        // post.
        //
        ZeroMemory(&ri, sizeof(REQINFO));
        ri.cpReq = CP_UTF8;
        ri.idReq = IPP_REQ_GETPRN;

        ri.fReq[0] = IPP_REQALL;
        ri.fReq[1] = IPP_REQALL;

        dwRet = WebIppSndData(IPP_REQ_GETPRN,
                              &ri,
                              (LPBYTE)pgp,
                              pgp->cbSize,
                              &lpIpp,
                              &cbIpp);


        // The request-structure has been converted to IPP format,
        // so it is ready to go to the server.
        //
        if (dwRet == WEBIPP_OK) {

            bRet = pIniPort->SendReq(lpIpp,
                                     cbIpp,
                                     ppinfo_IppGetRsp,
                                     (LPARAM)ppi2,
                                     TRUE);

            WebIppFreeMem(lpIpp);

        } else {

            SetLastError(ERROR_OUTOFMEMORY);
        }

        WebIppFreeMem(pgp);

    } else {

        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}


/*****************************************************************************\
* _ppinfo_set_str (Local Routine)
*
* Copies strings into a Win32 format buffer -- a structure at the front of
* the buffer and strings packed into the end.
*
* On entry, *buf should point to the last available byte in the buffer.
*
\*****************************************************************************/
VOID _ppinfo_set_str(
    LPTSTR  *dest,
    LPCTSTR src,
    LPTSTR  *buf)
{
    if (src != NULL) {

        // Place string at end of buffer.  This performs pointer
        // arithmatic, so the offsets are TCHAR in size.
        //
        (*buf) -= lstrlen(src);

        DBG_ASSERT( ((DWORD_PTR)dest < (DWORD_PTR)*buf) ,
                    (TEXT("String fill overrun in _ppinfo_set_str"))
                  );

        lstrcpy(*buf, src);


        // Place string address in structure and save pointer to new
        // last available byte.
        //
        *dest = *buf;
        (*buf)--;

    } else {

        *dest = TEXT('\0');
    }
}


/*****************************************************************************\
* _ppinfo_describe_provider (Local Routine)
*
* Fills a PRINTER_INFO_1 structure with information about the print provider.
* Returns TRUE if successful.  Otherwise, it returns FALSE.  Extended error
* information is available from GetLastError.
*
\*****************************************************************************/
BOOL _ppinfo_describe_provider(
    LPPRINTER_INFO_1 pInfo,
    DWORD            cbSize,
    LPDWORD          pcbNeeded,
    LPDWORD          pcbReturned)
{
    LPTSTR pszString;


    // Calculate the space needed (in bytes) that is necessary to
    // store the information for the print-processor.
    //
    *pcbNeeded = sizeof(PRINTER_INFO_1)       +
                 utlStrSize(g_szDescription)  +
                 utlStrSize(g_szProviderName) +
                 utlStrSize(g_szComment);

    if (*pcbNeeded > cbSize) {

        *pcbReturned = 0;

        DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: _describe_provider: Not enough memory")));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }


    // Initialize the fields which do not need to copy strings.
    //
    pInfo->Flags = (PRINTER_ENUM_ICON1 | PRINTER_ENUM_CONTAINER);

    //
    // Hide this provider from the UI, there is nothing underneath to enumerate.
    //
#if WINNT32
    pInfo->Flags |= PRINTER_ENUM_HIDE;
#endif

    // Set the string information.  First set the (pszString) pointer
    // to the first location at the end of the buffer which will store
    // the string.
    //
    pszString = ENDOFBUFFER(pInfo, cbSize);

    _ppinfo_set_str(&pInfo->pDescription, g_szDescription , &pszString);
    _ppinfo_set_str(&pInfo->pName       , g_szProviderName, &pszString);
    _ppinfo_set_str(&pInfo->pComment    , g_szComment     , &pszString);


    // Return the number of structures copied.
    //
    *pcbReturned = 1;

    return TRUE;
}


/*****************************************************************************\
* _ppinfo_net_get_info (Local Routine)
*
* Fills a supplied PRINTER_INFO_2 structure with all the information
* we can dig up on the specified IPP1 print server.
*
* Takes a pointer to PPRINTER_INFO_2 which is allocated to be the correct size
*
* Returns TRUE if successful, FALSE if otherwise.
*
\*****************************************************************************/
BOOL _ppinfo_net_get_info(
    IN  PCINETMONPORT   pIniPort,
    OUT PPRINTER_INFO_2 *ppInfo,
    OUT LPDWORD         lpBufAllocated,
    IN  ALLOCATORFN     pAllocator)
{
    PRINTER_INFO_2  pi2;
    PPRINTER_INFO_2 pInfo;
    LPTSTR          pszString;
    LPCTSTR          pszPortName;
    DWORD           dwAllocSize;
    BOOL            bRet = FALSE;


    // Make a server-call to get the printer-information.
    //
    DBG_ASSERT( ppInfo,         (TEXT("_ppinfo_net_get_info passed in NULL LPPI2 *")) );
    DBG_ASSERT( pAllocator,     (TEXT("_ppinfo_net_get_info passed in NULL Allocator")) );
    DBG_ASSERT( lpBufAllocated, (TEXT("_ppinfo_net_get_info passed in NULL buffer allocated return size")) );

    *ppInfo = NULL;             // NULL out ppInfo, just in case
    *lpBufAllocated = 0;        // Set allocated size to zero

    ZeroMemory(&pi2, sizeof(PRINTER_INFO_2));

    if (!ppinfo_Get(pIniPort, &pi2))
        goto BailOut;

    pszPortName = pIniPort->GetPortName();

    dwAllocSize = ( ( pi2.pPrinterName ? lstrlen( pi2.pPrinterName) + 1 : 0) +
                    ( pszPortName      ? lstrlen( pszPortName )     + 1 : 0) +
                    ( pi2.pDriverName  ? lstrlen( pi2.pDriverName ) + 1 : 0) +
                      7 * 1 ) * sizeof(TCHAR) + sizeof(PRINTER_INFO_2);

    pInfo = (PPRINTER_INFO_2)pAllocator( dwAllocSize );

    if (NULL == pInfo)
        goto Cleanup;

    pszString = ENDOFBUFFER( pInfo, dwAllocSize );

    // Set non-string entries.
    //
    pInfo->cJobs               = pi2.cJobs;
    pInfo->Status              = pi2.Status;
    pInfo->pDevMode            = NULL;
    pInfo->pSecurityDescriptor = NULL;
#if 0
    pInfo->Attributes          = PRINTER_ATTRIBUTE_SHARED;
#else
    pInfo->Attributes          = PRINTER_ATTRIBUTE_NETWORK;
#endif
    pInfo->Priority            = pi2.Priority;
    pInfo->StartTime           = pi2.StartTime;
    pInfo->UntilTime           = pi2.UntilTime;
    pInfo->AveragePPM          = pi2.AveragePPM;


    // Set any remaining fields that we can't fill to reasonable values.
    //
    _ppinfo_set_str(&pInfo->pPrinterName   , pi2.pPrinterName         , &pszString);
    _ppinfo_set_str(&pInfo->pShareName     , g_szEmptyString          , &pszString);
    _ppinfo_set_str(&pInfo->pPortName      , pszPortName              , &pszString);
    _ppinfo_set_str(&pInfo->pDriverName    , pi2.pDriverName          , &pszString);
    _ppinfo_set_str(&pInfo->pComment       , g_szEmptyString          , &pszString);
    _ppinfo_set_str(&pInfo->pLocation      , g_szEmptyString          , &pszString);
    _ppinfo_set_str(&pInfo->pSepFile       , g_szEmptyString          , &pszString);
    _ppinfo_set_str(&pInfo->pPrintProcessor, g_szEmptyString          , &pszString);
    _ppinfo_set_str(&pInfo->pDatatype      , g_szEmptyString          , &pszString);
    _ppinfo_set_str(&pInfo->pParameters    , g_szEmptyString          , &pszString);

    *lpBufAllocated = dwAllocSize;  // Set the size to what we have allocated
    *ppInfo = pInfo;                // Return the allocated structure
    // Since we've allocated our strings in ppinfo_get, we will need
    // to explicitly free them.
    //

    bRet = TRUE;

Cleanup:

    if (pi2.pPrinterName) memFreeStr(pi2.pPrinterName);
    if (pi2.pDriverName) memFreeStr(pi2.pDriverName);

BailOut:

    return bRet;
}


/*****************************************************************************\
* _ppinfo_calc_level1 (Local Routine)
*
* Calculates the amount of buffer space needed to store a single level 1
* GetPrinter() result buffer.
*
\*****************************************************************************/
DWORD _ppinfo_calc_level1(
    PPRINTER_INFO_2 pSrcInfo)
{
    DWORD cbSize;

    //
    // Figure out how many bytes of buffer space we're going to need.
    //
    cbSize = sizeof(PRINTER_INFO_1)             +
             utlStrSize(g_szEmptyString)        +  // description
             utlStrSize(pSrcInfo->pPrinterName) +  // name
             utlStrSize(pSrcInfo->pComment);       // comment

    return cbSize;
}


/*****************************************************************************\
* _ppinfo_calc_level2 (Local Routine)
*
* Calculates the amount of buffer space needed to
* store a single level 2 GetPrinter() result buffer.
*
\*****************************************************************************/
DWORD _ppinfo_calc_level2(
    LPCTSTR         pszServerName,
    PPRINTER_INFO_2 pSrcInfo)
{
    DWORD     cbSize;
    LPDEVMODE pDevmode;

    //
    // Figure out how many bytes of buffer space we're going to need.
    //
    cbSize = sizeof(PRINTER_INFO_2)                +
             utlStrSize(pszServerName)             +  // Server Name
             utlStrSize(pSrcInfo->pPrinterName)    +  // Printer Name
             utlStrSize(pSrcInfo->pShareName)      +  // Share Name
             utlStrSize(pSrcInfo->pPortName)       +  // Port Name
             utlStrSize(pSrcInfo->pDriverName)     +  // Driver Name
             utlStrSize(pSrcInfo->pComment)        +  // Comment
             utlStrSize(pSrcInfo->pLocation)       +  // Location
             utlStrSize(pSrcInfo->pSepFile)        +  // Separator file
             utlStrSize(pSrcInfo->pPrintProcessor) +  // Print processor
             utlStrSize(pSrcInfo->pDatatype)       +  // Data type
             utlStrSize(pSrcInfo->pParameters);       // Parameters

    if (pSrcInfo->pDevMode != NULL) {
        pDevmode = pSrcInfo->pDevMode;
        cbSize  += pDevmode->dmSize + pDevmode->dmDriverExtra;
    }

    return cbSize;
}


#if WINNT32
/*****************************************************************************\
* _ppinfo_calc_level4 (Local Routine)
*
* Calculates the amount of buffer space needed to
* store a single level 4 GetPrinter() result buffer.
*
\*****************************************************************************/
DWORD _ppinfo_calc_level4(
    PPRINTER_INFO_2 pSrcInfo)
{
    DWORD cbSize;

    //
    // Figure out how many bytes of buffer space we're going to need.
    //
    cbSize = sizeof(PRINTER_INFO_4)                +
             utlStrSize(pSrcInfo->pPrinterName)    +  // Printer Name
             utlStrSize(pSrcInfo->pServerName);


    return cbSize;
}
#endif


/*****************************************************************************\
* _ppinfo_calc_level2 (Local Routine)
*
* Calculates the amount of buffer space needed to
* store a single level 5 GetPrinter() result buffer.
*
\*****************************************************************************/
DWORD _ppinfo_calc_level5(
    PPRINTER_INFO_2 pSrcInfo)
{
    DWORD cbSize;


    //
    // Figure out how many bytes of buffer space we're going to need.
    //
    cbSize = sizeof(PRINTER_INFO_5)                +
             utlStrSize(pSrcInfo->pPrinterName)    +  // Printer Name
             utlStrSize(pSrcInfo->pPortName);


    return cbSize;
}


/*****************************************************************************\
* _ppinfo_build_level1 (Local Routine)
*
* Given a pointer to a source PRINTER_INFO_2 structure, a
* destination PRINTER_INFO_1 structure and a pointer to the
* start of string storage space, fills the PRINTER_INFO_1 structure.
*
* Called by GetPrinter and EnumPrinters, level 1.  Returns an
* LPSTR pointer to the last available data byte remaining in the
* buffer.
*
\*****************************************************************************/
LPTSTR _ppinfo_build_level1(
    PPRINTER_INFO_2 pSrcInfo,
    PPRINTER_INFO_1 pDstInfo,
    LPTSTR          pszString)
{
    // Flags.
    //
    pDstInfo->Flags = PRINTER_ENUM_CONTAINER;

#if WINNT32
    pDstInfo->Flags |= PRINTER_ENUM_HIDE;
#endif

    // Description
    //
    // CODEWORK - The Win32 structure has a field for "description" that has
    // no equivalent in the network printer info structure.  What do we
    // really want here?  For now, I'm copying in an empty string as a
    // placeholder.
    //
    _ppinfo_set_str(&pDstInfo->pDescription, g_szEmptyString       , &pszString);
    _ppinfo_set_str(&pDstInfo->pName       , pSrcInfo->pPrinterName, &pszString);
    _ppinfo_set_str(&pDstInfo->pComment    , pSrcInfo->pComment    , &pszString);

    return pszString;
}


/*****************************************************************************\
* _ppinfo_build_level2 (Local Routine)
*
* Given a server name, a pointer to a source PRINTER_INFO_2
* structure, a destination PRINTER_INFO_2 structure and a pointer to
* the start of string storage space, fills the PRINTER_INFO_2 structure.
*
* Called by GetPrinter and EnumPrinters, level 2.  Returns an
* LPTSTR pointer to the last available data char in the data buffer.
*
\*****************************************************************************/
LPTSTR _ppinfo_build_level2(
    LPCTSTR         pszServerName,
    PPRINTER_INFO_2 pSrcInfo,
    PPRINTER_INFO_2 pDstInfo,
    LPTSTR          pszString)
{

    // Set non-string entries.
    //
    pDstInfo->pSecurityDescriptor = NULL;
    pDstInfo->Attributes          = pSrcInfo->Attributes;
    pDstInfo->Priority            = pSrcInfo->Priority;
    pDstInfo->DefaultPriority     = pSrcInfo->Priority;
    pDstInfo->StartTime           = pSrcInfo->StartTime;
    pDstInfo->UntilTime           = pSrcInfo->UntilTime;
    pDstInfo->Status              = pSrcInfo->Status;
    pDstInfo->cJobs               = pSrcInfo->cJobs;
    pDstInfo->AveragePPM          = pSrcInfo->AveragePPM;


    // Copy the required data to the Win 32 PRINTER_INFO_2 structure.
    //
    // SPECWORK - several of these fields are filled with "" placeholders.
    // We probably need to put real information  in some of them.
    // The current inetpp protocol does not supply this information to us.
    //
    _ppinfo_set_str(&pDstInfo->pServerName    , pszServerName            , &pszString);
    _ppinfo_set_str(&pDstInfo->pPrinterName   , pSrcInfo->pPrinterName   , &pszString);
    _ppinfo_set_str(&pDstInfo->pShareName     , pSrcInfo->pShareName     , &pszString);
    _ppinfo_set_str(&pDstInfo->pPortName      , pSrcInfo->pPortName      , &pszString);
    _ppinfo_set_str(&pDstInfo->pDriverName    , pSrcInfo->pDriverName    , &pszString);
    _ppinfo_set_str(&pDstInfo->pComment       , pSrcInfo->pComment       , &pszString);
    _ppinfo_set_str(&pDstInfo->pLocation      , pSrcInfo->pLocation      , &pszString);
    _ppinfo_set_str(&pDstInfo->pSepFile       , pSrcInfo->pSepFile       , &pszString);
    _ppinfo_set_str(&pDstInfo->pPrintProcessor, pSrcInfo->pPrintProcessor, &pszString);
    _ppinfo_set_str(&pDstInfo->pDatatype      , pSrcInfo->pDatatype      , &pszString);
    _ppinfo_set_str(&pDstInfo->pParameters    , pSrcInfo->pParameters    , &pszString);

    // If a devmode exist, then it will need to be copied as well.
    //
    if (pSrcInfo->pDevMode != NULL) {

        memCopy((LPSTR *)&pDstInfo->pDevMode,
                (LPSTR)pSrcInfo->pDevMode,
                pSrcInfo->pDevMode->dmSize + pSrcInfo->pDevMode->dmDriverExtra,
                (LPSTR *)&pszString);

    } else {

        pDstInfo->pDevMode = NULL;
    }

    return pszString;
}


#if WINNT32
/*****************************************************************************\
* _ppinfo_build_level4 (Local Routine)
*
* Given a server name, a pointer to a source PRINTER_INFO_2
* structure, a destination PRINTER_INFO_5 structure and a pointer to
* the start of string storage space, fills the PRINTER_INFO_4 structure.
*
* Called by GetPrinter and EnumPrinters, level 2.  Returns an
* LPTSTR pointer to the last available data char in the data buffer.
*
\*****************************************************************************/
LPTSTR _ppinfo_build_level4(
    PPRINTER_INFO_2 pSrcInfo,
    PPRINTER_INFO_4 pDstInfo,
    LPTSTR          pszString)
{
    // Set non-string entries.
    //
    pDstInfo->Attributes = pSrcInfo->Attributes;


    // Copy the required data to the Win 32 PRINTER_INFO_4 structure.
    //
    _ppinfo_set_str(&pDstInfo->pPrinterName, pSrcInfo->pPrinterName, &pszString);
    _ppinfo_set_str(&pDstInfo->pServerName , pSrcInfo->pServerName , &pszString);

    return pszString;
}
#endif


/*****************************************************************************\
* _ppinfo_build_level5 (Local Routine)
*
* Given a server name, a pointer to a source PRINTER_INFO_2
* structure, a destination PRINTER_INFO_5 structure and a pointer to
* the start of string storage space, fills the PRINTER_INFO_5 structure.
*
* Called by GetPrinter and EnumPrinters, level 2.  Returns an
* LPTSTR pointer to the last available data char in the data buffer.
*
\*****************************************************************************/
LPTSTR _ppinfo_build_level5(
    PPRINTER_INFO_2 pSrcInfo,
    PPRINTER_INFO_5 pDstInfo,
    LPTSTR          pszString)
{
    // Set non-string entries.
    //
    pDstInfo->Attributes               = pSrcInfo->Attributes;
    pDstInfo->DeviceNotSelectedTimeout = 0;
    pDstInfo->TransmissionRetryTimeout = 0;


    // Copy the required data to the Win 32 PRINTER_INFO_5 structure.
    //
    _ppinfo_set_str(&pDstInfo->pPrinterName, pSrcInfo->pPrinterName, &pszString);
    _ppinfo_set_str(&pDstInfo->pPortName   , pSrcInfo->pPortName   , &pszString);

    return pszString;
}


/*****************************************************************************\
* _ppinfo_get_level1 (Local Routine)
*
* Given pInfo, a block of information on a printer returned by a
* DosPrintQGetInfo call, fill a PRINTER_INFO_1 structure.  Returns
* TRUE if successful, FALSE otherwise.  Places the number of bytes
* of (lpbBuffer) used in the DWORD pointed to by (pcbNeeded).
*
\*****************************************************************************/
BOOL _ppinfo_get_level1(
    PPRINTER_INFO_2 pSrcInfo,
    LPBYTE          lpbBuffer,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded)
{
    // Figure out how many bytes of buffer space we're going to need.
    // Set error code and return failure if we don't have enough.
    //
    *pcbNeeded = _ppinfo_calc_level1(pSrcInfo);

    if (*pcbNeeded > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }


    // Copy the required data from the structure to the Win32
    // structure.
    //
    _ppinfo_build_level1(pSrcInfo,
                         (PPRINTER_INFO_1)lpbBuffer,
                         ENDOFBUFFER(lpbBuffer, cbBuf));

    return TRUE;

}


/*****************************************************************************\
* _ppinfo_get_level2 (Local Routine)
*
* Given pInfo, a block of information on a printer returned by a
* PrintQGetInfo call, fill a PRINTER_INFO_2 structure.  Returns
* TRUE if successful, FALSE otherwise. Places the number of bytes of
* (lpbBuffer) used in the DWORD pointed to by (pcbNeeded).
*
\*****************************************************************************/
BOOL _ppinfo_get_level2(
    PPRINTER_INFO_2 pSrcInfo,
    LPBYTE          lpbBuffer,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded)
{
    // Figure out how many bytes of buffer space we're going to need.
    // Set error code and return failure if we don't have enough.
    //
    *pcbNeeded = _ppinfo_calc_level2(g_szEmptyString, pSrcInfo);

    if (*pcbNeeded > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Copy the required data to the Win 32 PRINTER_INFO_2 structure.
    //
    _ppinfo_build_level2(g_szEmptyString,
                         pSrcInfo,
                         (PPRINTER_INFO_2)lpbBuffer,
                         ENDOFBUFFER(lpbBuffer, cbBuf));

    return TRUE;
}


#if WINNT32
/*****************************************************************************\
* _ppinfo_get_level4 (Local Routine)
*
* Given pInfo, a block of information on a printer returned by a
* PrintQGetInfo call, fill a PRINTER_INFO_4 structure.  Returns
* TRUE if successful, FALSE otherwise. Places the number of bytes of
* (lpbBuffer) used in the DWORD pointed to by (pcbNeeded).
*
\*****************************************************************************/
BOOL _ppinfo_get_level4(
    PPRINTER_INFO_2 pSrcInfo,
    LPBYTE          lpbBuffer,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded)
{
    // Figure out how many bytes of buffer space we're going to need.
    // Set error code and return failure if we don't have enough.
    //
    *pcbNeeded = _ppinfo_calc_level4(pSrcInfo);

    if (*pcbNeeded > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Copy the required data to the Win 32 PRINTER_INFO_2 structure.
    //
    _ppinfo_build_level4(pSrcInfo,
                         (PPRINTER_INFO_4)lpbBuffer,
                         ENDOFBUFFER(lpbBuffer, cbBuf));

    return TRUE;
}
#endif


/*****************************************************************************\
* _ppinfo_get_level5 (Local Routine)
*
* Given pInfo, a block of information on a printer returned by a
* PrintQGetInfo call, fill a PRINTER_INFO_5 structure.  Returns
* TRUE if successful, FALSE otherwise. Places the number of bytes of
* (lpbBuffer) used in the DWORD pointed to by (pcbNeeded).
*
\*****************************************************************************/
BOOL _ppinfo_get_level5(
    PPRINTER_INFO_2 pSrcInfo,
    LPBYTE          lpbBuffer,
    DWORD           cbBuf,
    LPDWORD         pcbNeeded)
{
    // Figure out how many bytes of buffer space we're going to need.
    // Set error code and return failure if we don't have enough.
    //
    *pcbNeeded = _ppinfo_calc_level5(pSrcInfo);

    if (*pcbNeeded > cbBuf) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Copy the required data to the Win 32 PRINTER_INFO_2 structure.
    //
    _ppinfo_build_level5(pSrcInfo,
                         (PPRINTER_INFO_5)lpbBuffer,
                         ENDOFBUFFER(lpbBuffer, cbBuf));

    return TRUE;
}


#if WINNT32
/*****************************************************************************\
* _ppinfo_enumprinters_NT (Local Routine)
*
* This is the WinNT specific routine for EnumPrinters.
*
*
\*****************************************************************************/
BOOL _ppinfo_enumprinters(
    DWORD   dwType,
    LPTSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned)
{
    BOOL bReturn = FALSE;


    // Throw back enumeration requests that we don't handle. The routing
    // layer above us is specifically looking for the ERROR_INVALID_NAME.
    //
    if (dwType & PRINTER_ENUM_NOTFORUS)
        goto enum_name_failure;


    // If the request is one that we handle, but the caller didn't supply
    // a printer name, we'll fail. Again, to keep things going as the
    // router expects, we must return an ERROR_INVALID_NAME condition.
    //
    if (utlStrSize(pszName) == 0) {

        if ((dwLevel == PRINT_LEVEL_1) && (dwType & PRINTER_ENUM_NAME)) {

            return _ppinfo_describe_provider((LPPRINTER_INFO_1)pPrinterEnum,
                                             cbBuf,
                                             pcbNeeded,
                                             pcbReturned);

        } else {

            goto enum_name_failure;
        }

    } else {

        if ((dwLevel == PRINT_LEVEL_1) && (dwType & PRINTER_ENUM_NAME)) {

            // In this case, the user has asked us to enumerate the
            // printers in some domain. Until we decide what we really want
            // to do.  We'll simply return success with an empty enumeration.
            //

            goto enum_empty_success;
        }
    }


    // Check Remote enumeration.  Remote enumeration valid only if
    // it's a level-1 printer.
    //
    if (dwType & PRINTER_ENUM_REMOTE) {

        if (dwLevel != PRINT_LEVEL_1) {

            goto enum_level_failure;

        } else {

            // In this case, the user has asked us to enumerate the
            // printers in our domain. Until we decide what we really
            // want to do, we'll simply return success with an empty
            // enumeration.
            //
            goto enum_empty_success;
        }

    } else if (dwType & PRINTER_ENUM_CONNECTIONS) {

        // In this case, the user has asked us to enumerate our favorite
        // connections.
        //

enum_empty_success:

        *pcbNeeded   = 0;
        *pcbReturned = 0;

        return TRUE;
    }


    DBG_MSG(DBG_LEV_INFO, (TEXT("Info: PPEnumPrinters: Type(%ld)  Name(%s)  Level(%ld)"), dwType, pszName, dwLevel));


    // Check print-levels.  These are error cases.  We should
    // really have performed the enumeration above.
    //
    switch (dwLevel) {

    case PRINT_LEVEL_1:
    case PRINT_LEVEL_2:

enum_name_failure:

        DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPEnumPrinters: Invalid Name")));
        SetLastError(ERROR_INVALID_NAME);
        break;

    default:

enum_level_failure:

        DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPEnumPrinters: Invalid Level: %d"), dwLevel));
        SetLastError(ERROR_INVALID_LEVEL);
        break;
    }

    return FALSE;
}

#else

/*****************************************************************************\
* _ppinfo_enumprinters_95 (Local Routine)
*
* This is the Win95 specific routine for EnumPrinters.
*
*
\*****************************************************************************/
BOOL _ppinfo_enumprinters(
    DWORD   dwType,
    LPTSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned)
{
    BOOL bReturn = FALSE;

    // Throw back enumeration requests that we don't handle. The routing
    // layer above us is specifically looking for the ERROR_INVALID_NAME.
    //
    if (dwType & PRINTER_ENUM_NOTFORUS)
        goto enum_name_failure;


    // If the request is one that we handle, but the caller didn't supply
    // a printer name, we'll fail. Again, to keep things going as the
    // router expects, we must return an ERROR_INVALID_NAME condition.
    //
    if (utlStrSize(pszName) == 0) {

        if ((dwLevel == PRINT_LEVEL_1) && (dwType & PRINTER_ENUM_NAME)) {

            return _ppinfo_describe_provider((LPPRINTER_INFO_1)pPrinterEnum,
                                             cbBuf,
                                             pcbNeeded,
                                             pcbReturned);

        } else if (dwType & PRINTER_ENUM_REMOTE) {

            // In this case, the user has asked us to enumerate the printers
            // in our domain. Until we decide what we really want to do, we'll
            // simply return success with an empty enumeration.
            //
            *pcbNeeded   = 0;
            *pcbReturned = 0;

            return TRUE;

        } else {

            goto enum_name_failure;
        }
    }

    DBG_MSG(DBG_LEV_INFO, (TEXT("Info: PPEnumPrinters: Type(%ld)  Name(%s)  Level(%ld)"), dwType, pszName, dwLevel));


    // One last special case to test for -- did they ask us to
    // enumerate ourselves (the provider) by name?
    //
    if ((dwLevel == PRINT_LEVEL_1) && (dwType & PRINTER_ENUM_NAME)) {

        if (lstrcmp(pszName, g_szProviderName) == 0) {

            return _ppinfo_describe_provider((LPPRINTER_INFO_1)pPrinterEnum,
                                             cbBuf,
                                             pcbNeeded,
                                             pcbReturned);
        }
    }


    // Check print-levels.  These are error cases.  We should
    // really have performed the enumeration above.
    //
    switch (dwLevel) {

    case PRINT_LEVEL_1:
    case PRINT_LEVEL_2:

enum_name_failure:

        DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPEnumPrinters: Invalid Name")));
        SetLastError(ERROR_INVALID_NAME);
        break;

    default:

        DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPEnumPrinters: Invalid Level: %d"), dwLevel));
        SetLastError(ERROR_INVALID_LEVEL);
        break;
    }

    return FALSE;
}

#endif


/*****************************************************************************\
* PPEnumPrinters
*
* Enumerates the available printers.  Returns TRUE if successful.  Otherwise,
* it returns FALSE.
*
* NOTE: Supports level 2 PRINTER_INFO to provide Point-and-Print
*       functionality.
*
\*****************************************************************************/
BOOL PPEnumPrinters(
    DWORD   dwType,
    LPTSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPEnumPrinters: Type(%d) Level(%d) Name(%s)"), dwType, dwLevel, (pszName ? pszName : TEXT("<NULL>"))));

    return _ppinfo_enumprinters(dwType,
                                pszName,
                                dwLevel,
                                pPrinterEnum,
                                cbBuf,
                                pcbNeeded,
                                pcbReturned);
}


/*****************************************************************************\
* PPGetPrinter
*
* Retrieves information about a printer. Returns TRUE if successful, FALSE
* if an error occurred. NOTE: Supports level 2 Printer_INFO to provide
* Point and Print functionality for Chicago.
*
\*****************************************************************************/
BOOL PPGetPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  lpbPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    PCINETMONPORT   pIniPort;
    PPRINTER_INFO_2 pSrcInfo;
    DWORD           cbSrcSize;
    DWORD           dwTemp;
    BOOL            bResult = FALSE;

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPGetPrinter: Printer(%08lX) Level(%ld)"), hPrinter, dwLevel));

    if (pcbNeeded)
        *pcbNeeded = 0;

    semEnterCrit();

    // Make sure we have a valid printer handle.
    //
    if (pIniPort = utlValidatePrinterHandle(hPrinter)) {

        if (pIniPort->BeginReadGetPrinterCache (&pSrcInfo)) {

            // Reformat the data according to the requested info Level.
            //
            switch (dwLevel) {

            case PRINT_LEVEL_1:
                bResult = _ppinfo_get_level1(pSrcInfo, lpbPrinter, cbBuf, pcbNeeded);
                break;

            case PRINT_LEVEL_2:
                bResult = _ppinfo_get_level2(pSrcInfo, lpbPrinter, cbBuf, pcbNeeded);
                break;

#if WINNT32
            case PRINT_LEVEL_4:
                bResult = _ppinfo_get_level4(pSrcInfo, lpbPrinter, cbBuf, pcbNeeded);
                break;
#endif

            case PRINT_LEVEL_5:
                bResult = _ppinfo_get_level5(pSrcInfo, lpbPrinter, cbBuf, pcbNeeded);
                break;

            default:
                DBG_MSG(DBG_LEV_WARN, (TEXT("Warn: PPGetPrinter: Invalid Level")));
                SetLastError(ERROR_INVALID_LEVEL);
                bResult = FALSE;
                break;
            }


        }

        pIniPort->EndReadGetPrinterCache ();

        if (GetLastError() == ERROR_ACCESS_DENIED) {
            pIniPort->InvalidateGetPrinterCache ();
        }
    }

    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        pcbNeeded &&
        *pcbNeeded == 0) {
        // We can't set ERROR_INSUFFICIENT_BUFFER here since it was an internal error
        // and we are not reporting a size
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }


    semLeaveCrit();

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ppinit.cxx ===
/*****************************************************************************\
* MODULE: ppinit.c
*
* This module contains the initialization routines for the Print-Provider.
* The spooler calls InitializePrintProvider() to retreive the list of
* calls that the Print-Processor supports.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

#ifdef WINNT32

extern "C" {

BOOL
BuildOtherNamesFromMachineName(
    LPWSTR **ppszMyOtherNames,
    DWORD   *cOtherNames
    );
}

#endif

/*****************************************************************************\
* _init_provider_worker (Local Routine)
*
*
\*****************************************************************************/
void _init_provider_worker ()
{
    // Get the default spool directory

    HANDLE  hServer = NULL;
    DWORD   dwType = REG_SZ;
    DWORD   cbSize = MAX_PATH * sizeof (TCHAR);


    g_szDefSplDir[0] = 0;

    semEnterCrit ();

#ifdef WINNT32
    if (OpenPrinter (NULL, &hServer, NULL)) {

        if (ERROR_SUCCESS != GetPrinterData (hServer,
                                             SPLREG_DEFAULT_SPOOL_DIRECTORY,
                                             &dwType,
                                             (LPBYTE) g_szDefSplDir,
                                             cbSize,
                                             &cbSize)) {
        }

        ClosePrinter (hServer);

    }
#endif

    SplClean ();

    semLeaveCrit ();
}

/*****************************************************************************\
* _init_write_displayname (Local Routine)
*
*
\*****************************************************************************/
BOOL _init_write_displayname(VOID)
{
    LONG  lRet;
    HKEY  hkPath;
    DWORD dwType;
    DWORD cbSize;

    if (!LoadString (g_hInst,
                     IDS_DISPLAY_NAME,
                     g_szDisplayStr,
                     MAX_PATH)) {
        g_szDisplayStr[0] = 0;
    }

    // Open the key to the Print-Providor.
    //
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        g_szRegProvider,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkPath);

    if (lRet == ERROR_SUCCESS) {

        // Look for the "displayname".  If it doesn't exist, then write it.
        //
        dwType = REG_SZ;
        cbSize = 0;

        lRet = RegQueryValueEx(hkPath,
                               g_szDisplayName,
                               NULL,
                               &dwType,
                               (LPBYTE)NULL,
                               &cbSize);

        // Write the string.
        //
        if ((lRet != ERROR_SUCCESS) || (cbSize == 0)) {

            dwType = REG_SZ;
            cbSize = (lstrlen(g_szDisplayStr) + 1) * sizeof(TCHAR);

            lRet = RegSetValueEx(hkPath,
                                 g_szDisplayName,
                                 0,
                                 dwType,
                                 (LPBYTE)g_szDisplayStr,
                                 cbSize);
        }

        RegCloseKey(hkPath);
    }

    if (lRet != ERROR_SUCCESS) {
        SetLastError (lRet);
        return FALSE;
    }
    else
        return TRUE;
}


/*****************************************************************************\
* _init_find_filename (Local Routine)
*
*
\*****************************************************************************/
LPTSTR _init_find_filename(
   LPCTSTR lpszPathName)
{
   LPTSTR lpszFileName;

   if (lpszPathName == NULL)
      return NULL;


   // Look for the filename in the path, by starting at the end
   // and looking for the ('\') char.
   //
   if (!(lpszFileName = utlStrChrR(lpszPathName, TEXT('\\'))))
      lpszFileName = (LPTSTR)lpszPathName;
   else
      lpszFileName++;

   return lpszFileName;
}


/*****************************************************************************\
* _init_load_netapi (Local Routine)
*
* Initialize INET API pointers.
*
\*****************************************************************************/
BOOL _init_load_netapi(VOID)
{
    g_pfnHttpQueryInfo         = (PFNHTTPQUERYINFO)        HttpQueryInfoA;
    g_pfnInternetOpenUrl       = (PFNINTERNETOPENURL)      InternetOpenUrlA;
    g_pfnInternetErrorDlg      = (PFNINTERNETERRORDLG)     InternetErrorDlg;
    g_pfnHttpSendRequest       = (PFNHTTPSENDREQUEST)      HttpSendRequestA;
    g_pfnHttpSendRequestEx     = (PFNHTTPSENDREQUESTEX)    HttpSendRequestExA;
    g_pfnInternetReadFile      = (PFNINTERNETREADFILE)     InternetReadFile;
    g_pfnInternetWriteFile     = (PFNINTERNETWRITEFILE)    InternetWriteFile;
    g_pfnInternetCloseHandle   = (PFNINTERNETCLOSEHANDLE)  InternetCloseHandle;
    g_pfnInternetOpen          = (PFNINTERNETOPEN)         InternetOpenA;
    g_pfnInternetConnect       = (PFNINTERNETCONNECT)      InternetConnectA;
    g_pfnHttpOpenRequest       = (PFNHTTPOPENREQUEST)      HttpOpenRequestA;
    g_pfnHttpAddRequestHeaders = (PFNHTTPADDREQUESTHEADERS)HttpAddRequestHeadersA;
    g_pfnHttpEndRequest        = (PFNHTTPENDREQUEST)       HttpEndRequestA;
    g_pfnInternetSetOption     = (PFNINTERNETSETOPTION)    InternetSetOptionA;
    return TRUE;

#if 0
    HINSTANCE hWinInet;

    // Initialize the WinInet API function-ptrs.
    //
    if (hWinInet = LoadLibrary(g_szWinInetDll)) {

        g_pfnHttpQueryInfo         = (PFNHTTPQUERYINFO)        GetProcAddress(hWinInet, g_szHttpQueryInfo);
        g_pfnInternetOpenUrl       = (PFNINTERNETOPENURL)      GetProcAddress(hWinInet, g_szInternetOpenUrl);
        g_pfnInternetErrorDlg      = (PFNINTERNETERRORDLG)     GetProcAddress(hWinInet, g_szInternetErrorDlg);
        g_pfnHttpSendRequest       = (PFNHTTPSENDREQUEST)      GetProcAddress(hWinInet, g_szHttpSendRequest);
        g_pfnHttpSendRequestEx     = (PFNHTTPSENDREQUESTEX)    GetProcAddress(hWinInet, g_szHttpSendRequestEx);
        g_pfnInternetReadFile      = (PFNINTERNETREADFILE)     GetProcAddress(hWinInet, g_szInternetReadFile);
        g_pfnInternetWriteFile     = (PFNINTERNETWRITEFILE)    GetProcAddress(hWinInet, g_szInternetWriteFile);
        g_pfnInternetCloseHandle   = (PFNINTERNETCLOSEHANDLE)  GetProcAddress(hWinInet, g_szInternetCloseHandle);
        g_pfnInternetOpen          = (PFNINTERNETOPEN)         GetProcAddress(hWinInet, g_szInternetOpen);
        g_pfnInternetConnect       = (PFNINTERNETCONNECT)      GetProcAddress(hWinInet, g_szInternetConnect);
        g_pfnHttpOpenRequest       = (PFNHTTPOPENREQUEST)      GetProcAddress(hWinInet, g_szHttpOpenRequest);
        g_pfnHttpAddRequestHeaders = (PFNHTTPADDREQUESTHEADERS)GetProcAddress(hWinInet, g_szHttpAddRequestHeaders);
        g_pfnHttpEndRequest        = (PFNHTTPENDREQUEST)       GetProcAddress(hWinInet, g_szHttpEndRequest);
        g_pfnInternetSetOption     = (PFNINTERNETSETOPTION)    GetProcAddress(hWinInet, g_szInternetSetOption);


        // Check for any failures.
        //
        if (g_pfnHttpQueryInfo         &&
            g_pfnInternetOpenUrl       &&
            g_pfnInternetErrorDlg      &&
            g_pfnHttpSendRequest       &&
            g_pfnHttpSendRequestEx     &&
            g_pfnInternetReadFile      &&
            g_pfnInternetWriteFile     &&
            g_pfnInternetCloseHandle   &&
            g_pfnInternetOpen          &&
            g_pfnInternetConnect       &&
            g_pfnHttpOpenRequest       &&
            g_pfnHttpAddRequestHeaders &&
            g_pfnHttpEndRequest        &&
            g_pfnInternetSetOption) {

            return TRUE;
        }

        FreeLibrary(hWinInet);
    }

    return FALSE;
#endif
}


/*****************************************************************************\
* _init_load_provider (Local Routine)
*
* This performs the startup initialization for the print-provider.
*
\*****************************************************************************/
BOOL _init_load_provider()
{
    LPTSTR lpszFileName;
    TCHAR  szBuf[MAX_PATH];
    DWORD  i = MAX_COMPUTERNAME_LENGTH + 1;


    // Get the module name for this process.
    //
    if (!GetModuleFileName(NULL, szBuf, MAX_PATH))
        goto exit_load;


    // Get the filename from the full module-name. and check that
    // it's the spooler.
    //
    if (lpszFileName = _init_find_filename(szBuf)) {

        if (lstrcmpi(lpszFileName, g_szProcessName) == 0) {

            // Initialize the computer name.
            //
            if (!GetComputerName(g_szMachine, &i))
                goto exit_load;

            // Initialize the internet API pointers.
            //
            if (_init_load_netapi() == FALSE)
                goto exit_load;

            // !!!
            // Load spoolss here if we need to call spooler functions
            // from the print provider.
            //


            // Initialize the crit-sect for synchronizing port access.
            //
            semInitCrit();


            return TRUE;
        }
    }

exit_load:

    return FALSE;
}


/*****************************************************************************\
* _init_unload_provider (Local Routine)
*
* This performs the unloading/freeing of resources allocated by the
* provider.
*
\*****************************************************************************/
#if 0
// This piece of code is not needed since the dll is never get reloaded by spooler twice.
// -weihaic

BOOL _init_unload_provider(VOID)
{

    // Free the critical-section.
    //
    semFreeCrit();

    // Free the Registry
    //
    memFree (g_szRegProvider, sizeof (TCHAR) * (lstrlen (g_szRegProvider) + 1));

#ifdef WINNT32
    memFree (g_szRegPrintProviders, sizeof (TCHAR) * (lstrlen (g_szRegPrintProviders) + 1));
#endif

    // Free the monitor-port-list
    //
    memFree(g_pPortList, sizeof(INIMONPORTLIST));


    // !!!
    // Unload spoolss here if it's been loaded.
    //

    return TRUE;
}
#endif


/*****************************************************************************\
* _init_load_ports (Local Routine)
*
* This performs the port initialization for the print-provider.
*
\*****************************************************************************/
BOOL _init_load_ports(
    LPTSTR lpszRegPath)
{
    LONG  lStat;
    HKEY  hkPath;
    HKEY  hkPortNames;
    TCHAR szPortName[MAX_PATH];
    BOOL  bRet = FALSE;
    LPTSTR pEnd = NULL;

    // Make sure there is a registry-path pointing to the
    // INET provider entry.
    //
    if (lpszRegPath == NULL)
        return FALSE;


    // Copy the string to global-memory.  We will need this if we require
    // the need to write to the registry when creating new ports.
    //
    if (! (g_szRegProvider = (LPTSTR) memAlloc ((1 + lstrlen (lpszRegPath)) * sizeof (TCHAR)))) {
        return FALSE;
    }
    lstrcpy(g_szRegProvider, lpszRegPath);

#ifdef WINNT32

    // Copy the registry key of all the printer providers

    if (! (g_szRegPrintProviders = (LPTSTR) memAlloc ((1 + lstrlen (lpszRegPath)) * sizeof (TCHAR)))) {
        return FALSE;
    }
    lstrcpy(g_szRegPrintProviders, lpszRegPath);
    pEnd = wcsrchr (g_szRegPrintProviders, L'\\');

    if ( pEnd )
    {
        *pEnd = 0;
    }

#endif



    // Open registry key for Provider-Name.
    //
    lStat = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszRegPath, 0, KEY_READ, &hkPath);

    if (lStat == ERROR_SUCCESS) {

        bRet = TRUE;

        // Open the "ports" key for enumeration of the ports. We need to
        // build up this list at the provider initialization time so that
        // we can return the list of ports if called to EnumPorts().
        //
        lStat = RegOpenKeyEx(hkPath, g_szRegPorts, 0, KEY_READ, &hkPortNames);

        if (lStat == ERROR_SUCCESS) {

            DWORD dwSize;
            DWORD i = 0;

            while (lStat == ERROR_SUCCESS) {

                dwSize = sizeof(szPortName) / sizeof (TCHAR);

                lStat = RegEnumKey (hkPortNames,
                                    i,
                                    szPortName,
                                    dwSize);

                if (lStat == ERROR_SUCCESS) {

                    // Do not short-cut this call to InetmonAddPort(),
                    // as this will leave the crit-sect unprotected.
                    //
                    PPAddPort(szPortName, NULL, NULL);
                }

                i++;
            }

            RegCloseKey(hkPortNames);

        } else {

            DBG_MSG(DBG_LEV_INFO, (TEXT("RegOpenKeyEx(%s) failed: Error = %lu"), g_szRegPorts, lStat));
            SetLastError(lStat);
        }

        RegCloseKey(hkPath);

    } else {

        DBG_MSG(DBG_LEV_WARN, (TEXT("RegOpenKeyEx(%s) failed: Error = %lu"), lpszRegPath, lStat));
        SetLastError(lStat);
    }

    return bRet;
}

/*****************************************************************************\
* _init_create_sync (Local Routine)
*
* This creates the events and Critical Section needed for handling the synchronisation
* in the monitor.
*
\*****************************************************************************/
_inline BOOL _init_create_sync(VOID) {
#ifdef WINNT32
    BOOL bRet = TRUE;

    g_dwConCount  = 0;

    __try {
        InitializeCriticalSection(&g_csCreateSection);
    }
    __except (1) {
        bRet = FALSE;
        SetLastError (ERROR_INVALID_HANDLE);
    }

    if (bRet) {

        g_eResetConnections = CreateEvent( NULL, TRUE, TRUE, NULL );

        if (g_eResetConnections == NULL)
            bRet = FALSE;
    }

    return bRet;
#else
    return TRUE;
#endif
}


/*****************************************************************************\
* InitializePrintProvider (API)
*
* The spooler calls this routine to initialize the Print-Provider.  The list
* of functions in the table are passed back to the spooler for it to use
* when interfacing with the provider.
*
* NOTE: The (pszFullRegistryPath) is really a LPTSTR as far as Win9X is
*       concerned.
*
\*****************************************************************************/
#ifdef WINNT32

static PRINTPROVIDOR pfnPPList[] = {
#else

static  LPCVOID pfnPPList[] = {
#endif

    PPOpenPrinter,
    PPSetJob,
    PPGetJob,
    PPEnumJobs,
    stubAddPrinter,
    stubDeletePrinter,
    PPSetPrinter,
    PPGetPrinter,
    PPEnumPrinters,
    stubAddPrinterDriver,
    stubEnumPrinterDrivers,
    stubGetPrinterDriver,
    stubGetPrinterDriverDirectory,
    stubDeletePrinterDriver,
    stubAddPrintProcessor,
    stubEnumPrintProcessors,
    stubGetPrintProcessorDirectory,
    stubDeletePrintProcessor,
    stubEnumPrintProcessorDatatypes,
    PPStartDocPrinter,
    PPStartPagePrinter,
    PPWritePrinter,
    PPEndPagePrinter,
    PPAbortPrinter,
    stubReadPrinter,
    PPEndDocPrinter,
    PPAddJob,
    PPScheduleJob,
    stubGetPrinterData,
    stubSetPrinterData,
    stubWaitForPrinterChange,
    PPClosePrinter,
    stubAddForm,
    stubDeleteForm,
    stubGetForm,
    stubSetForm,
    stubEnumForms,
    stubEnumMonitors,
    PPEnumPorts,
    stubAddPort,
#ifdef WINNT32
    NULL,
    NULL,
#else
    stubConfigurePort,
    PPDeletePort,
#endif
    stubCreatePrinterIC,
    stubPlayGdiScriptOnPrinterIC,
    stubDeletePrinterIC,
    stubAddPrinterConnection,
    stubDeletePrinterConnection,
    stubPrinterMessageBox,
    stubAddMonitor,
    stubDeleteMonitor

#ifndef WIN9X
    ,
    NULL,   // stubResetPrinter,
    NULL,   // stubGetPrinterDriverEx should not be called as specified in spoolss\dll\nullpp.c
    PPFindFirstPrinterChangeNotification,
    PPFindClosePrinterChangeNotification,

    NULL,   // stubAddPortEx,
    NULL,   // stubShutDown,
    NULL,   // stubRefreshPrinterChangeNotification,
    NULL,   // stubOpenPrinterEx,
    NULL,   // stubAddPrinterEx,
    NULL,   // stubSetPort,
    NULL,   // stubEnumPrinterData,
    NULL,   // stubDeletePrinterData,

    NULL,   // fpClusterSplOpen
    NULL,   // fpClusterSplClose
    NULL,   // fpClusterSplIsAlive
    NULL,   // fpSetPrinterDataEx
    NULL,   // fpGetPrinterDataEx
    NULL,   // fpEnumPrinterDataEx
    NULL,   // fpEnumPrinterKey
    NULL,   // fpDeletePrinterDataEx
    NULL,   // fpDeletePrinterKey
    NULL,   // fpSeekPrinter
    NULL,   // fpDeletePrinterDriverEx
    NULL,   // fpAddPerMachineConnection
    NULL,   // fpDeletePerMachineConnection
    NULL,   // fpEnumPerMachineConnections
    PPXcvData,   // fpXcvData
    NULL,   // fpAddPrinterDriverEx
    NULL,   // fpSplReadPrinter
    NULL,   // fpDriverUnloadComplete
    NULL,   // fpGetSpoolFileInfo
    NULL,   // fpCommitSpoolData
    NULL,   // fpCloseSpoolFileHandle
    NULL,   // fpFlushPrinter
    NULL,   // fpSendRecvBidiData
    NULL,   // fpAddDriverCatalog
#endif

};

BOOL WINAPI InitializePrintProvidor(
    LPPRINTPROVIDOR pPP,
    DWORD           cEntries,
    LPWSTR          pszFullRegistryPath)
{
    HANDLE hThread;
    DWORD dwThreadId;

    g_pcsEndBrowserSessionLock = new CCriticalSection ();

    if (!g_pcsEndBrowserSessionLock || g_pcsEndBrowserSessionLock->bValid () == FALSE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (_init_load_provider() == FALSE) {
        DBG_ASSERT(FALSE, (TEXT("Assert: Failed module initialization")));
        return FALSE;
    }

    if (!pszFullRegistryPath || !*pszFullRegistryPath) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    gpInetMon = new CInetMon;

    if (!gpInetMon || gpInetMon->bValid() == FALSE) {

        if (gpInetMon) {
            delete gpInetMon;
        }

        return FALSE;
    }

    if (gpInetMon && !gpInetMon->bValid ()) {
        delete gpInetMon;

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: InitializePrintProvidor")));

    memcpy(pPP, pfnPPList, min(sizeof(pfnPPList), (int)cEntries));

#ifdef WINNT32
    // Initialise synchronisation objects

    if (!_init_create_sync())
        return FALSE;

    // Initialize other names

    if (!BuildOtherNamesFromMachineName(&g_ppszOtherNames, &g_cOtherNames))
        return FALSE;
    g_bUpgrade = SplIsUpgrade();

#endif

    if (_init_load_ports((LPTSTR)pszFullRegistryPath) == FALSE) {
        DBG_ASSERT(FALSE, (TEXT("Assert: Failed port initialization")));
        return FALSE;
    }


    if (!_init_write_displayname())
        return FALSE;


    if (hThread = CreateThread (NULL,
                                0,
                                (LPTHREAD_START_ROUTINE) _init_provider_worker,
                                NULL,
                                0,
                                &dwThreadId)) {
        CloseHandle (hThread);
        return TRUE;
    }
    else
        return FALSE;
}


/*****************************************************************************\
* DllEntryPoint
*
* This is the main entry-point for the library.
*
\*****************************************************************************/
extern "C" {

BOOL WINAPI DllEntryPoint(
    HINSTANCE hInstDll,
    DWORD     dwAttach,
    LPVOID    lpcReserved)
{
    static BOOL s_bIsSpoolerProcess = FALSE;
    BOOL   bRet = TRUE;


    switch (dwAttach) {

    case DLL_PROCESS_ATTACH:


        // Set the global-instance variable.
        //
        g_hInst = hInstDll;

        s_bIsSpoolerProcess = TRUE;

        break;

    case DLL_PROCESS_DETACH:

#if 0
        // This code is not needed since the dll is never get loaded twice by spooler
        // -weihaic
        //
        if (s_bIsSpoolerProcess)
            _init_unload_provider();
#endif

#ifdef WINNT32
        DeleteCriticalSection( &g_csCreateSection );
        CloseHandle( g_eResetConnections );
#endif

        if (g_pcsEndBrowserSessionLock)
        {
            delete g_pcsEndBrowserSessionLock;
        }
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return bRet;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved

Module Name:

    precomp.h

Abstract:

    Precompiled header for client.

Author:

    Weihai Chen (WeihaiC)  30-Mar-2000

Environment:

    User Mode -Win32

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <winspool.h>

#include <wininet.h>
#include <tchar.h>
#include <mdcommsg.h>

#include <stdlib.h>
#include <winsock.h>
#include <minmax.h>

#include <ipexport.h>


#include <lmcons.h>
#include <lmapibuf.h>

#include <splcom.h>

#include <winsplp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\resource.h ===
#define IDS_DISPLAY_NAME            1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\sem.h ===
/*****************************************************************************\
* MODULE: sem.h
*
* Header file for the semaphore/crit-sect handling.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   24-Aug-1997 HWP-Guys    Created.
*
\*****************************************************************************/
#ifndef _INETPPSEM_H
#define _INETPPSEM_H

#ifdef DEBUG

/*****************************************************************************\
* _sem_dbg_EnterCrit
*
\*****************************************************************************/
_inline VOID _sem_dbg_EnterCrit(VOID)
{
    EnterCriticalSection(&g_csMonitorSection);

    g_dwCritOwner = GetCurrentThreadId();
}

/*****************************************************************************\
* _sem_dbg_LeaveCrit
*
\*****************************************************************************/
_inline VOID _sem_dbg_LeaveCrit(VOID)
{
    g_dwCritOwner = 0;

    LeaveCriticalSection(&g_csMonitorSection);
}

/*****************************************************************************\
* _sem_dbg_CheckCrit
*
\*****************************************************************************/
_inline VOID _sem_dbg_CheckCrit(VOID)
{
    DWORD dwCurrent = GetCurrentThreadId();

    DBG_ASSERT((dwCurrent == g_dwCritOwner), (TEXT("Assert: _sem_dbg_CheckCrit: Thread(%d), Owner(%d)"), dwCurrent, g_dwCritOwner));
}

#define semEnterCrit() _sem_dbg_EnterCrit()
#define semLeaveCrit() _sem_dbg_LeaveCrit()
#define semCheckCrit() _sem_dbg_CheckCrit()

#else

#define semEnterCrit() EnterCriticalSection(&g_csMonitorSection)
#define semLeaveCrit() LeaveCriticalSection(&g_csMonitorSection)
#define semCheckCrit() {}

#endif


#define semInitCrit()  InitializeCriticalSection(&g_csMonitorSection)
#define semFreeCrit()  DeleteCriticalSection(&g_csMonitorSection)

_inline VOID semSafeLeaveCrit(PCINETMONPORT pIniPort)
{
    pIniPort->IncRef ();
    semLeaveCrit();
}

_inline VOID semSafeEnterCrit(PCINETMONPORT pIniPort)
{

    pIniPort->DecRef ();
    semEnterCrit();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\ppprn.h ===
/*****************************************************************************\
* MODULE: ppprn.h
*
* Prototypes for private funcions in ppprn.c.  These functions control the
* printer during the course of a single job.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
#ifndef _PPPRN_H
#define _PPPRN_H

#define IPO_SIGNATURE     0x5152     // 'RQ' is the signature value
#define IPO_XCV_SIGNATURE 0x5153     // 'SQ' is the signature value

// Mask styles.
//
#define PP_STARTDOC       0x00000001 // To serialize access to the port
#define PP_ENDDOC         0x00000002 // To serialize access to job.
#define PP_FIRSTWRITE     0x00000004 //
#define PP_ZOMBIE         0x00000008 //
#define PP_CANCELLED      0x00000010 //
#define PP_ADDJOB         0x00000020

#if 0
#define PP_LPT            0x00000002 //
#define PP_COM            0x00000004 //
#define PP_FILE           0x00000008 //
#define PP_HARDWARE       0x00000020 //
#define PP_REMOTE         0x00000040 //
#define PP_CURRENT        0x00000080 //
#endif

// hPrinter Structure.
//
typedef struct _INET_HPRINTER {

    DWORD               dwSignature;
    LPTSTR              lpszName;
    HANDLE              hPort;
    DWORD               dwStatus;
    HANDLE              hNotify;
#ifdef WINNT32
    PCLOGON_USERDATA    hUser;  // This is used to keep track of the current user logon   
#endif
    PJOBMAP pjmJob;

} INET_HPRINTER;
typedef INET_HPRINTER *PINET_HPRINTER;
typedef INET_HPRINTER *NPINET_HPRINTER;
typedef INET_HPRINTER *LPINET_HPRINTER;

#ifdef WINNT32
typedef struct _INET_XCV_HPRINTER {

    DWORD   dwSignature;
    LPTSTR  lpszName;
} INET_XCV_HPRINTER;
typedef INET_XCV_HPRINTER *PINET_XCV_HPRINTER;
typedef INET_XCV_HPRINTER *NPINET_XCV_HPRINTER;
typedef INET_XCV_HPRINTER *LPINET_XCV_HPRINTER;


typedef struct {
    PCINETMONPORT   pIniPort;
    PJOBMAP         pjmJob;
    CSid*           pSidToken;
} ENDDOCTHREADCONTEXT;

typedef ENDDOCTHREADCONTEXT *PENDDOCTHREADCONTEXT;

#endif


_inline VOID PP_SetStatus(
    HANDLE hPrinter,
    DWORD  dwStatus)
{
    ((LPINET_HPRINTER)hPrinter)->dwStatus |= dwStatus;
}

_inline VOID PP_ClrStatus(
    HANDLE hPrinter,
    DWORD  dwStatus)
{
    ((LPINET_HPRINTER)hPrinter)->dwStatus &= ~dwStatus;
}

_inline BOOL PP_ChkStatus(
    HANDLE hPrinter,
    DWORD  dwStatus)
{
    return (((LPINET_HPRINTER)hPrinter)->dwStatus & dwStatus);
}

_inline PJOBMAP PP_GetJobInfo(
    HANDLE hPrinter)
{
    return ((LPINET_HPRINTER)hPrinter)->pjmJob;
}



PJOBMAP PP_OpenJobInfo(HANDLE, HANDLE);
VOID    PP_CloseJobInfo(HANDLE);



BOOL PPAbortPrinter(
    HANDLE hPrinter);

BOOL PPClosePrinter(
    HANDLE hPrinter);

BOOL PPEndDocPrinter(
    HANDLE hPrinter);

BOOL PPEndPagePrinter(
    HANDLE hPrinter);

BOOL PPOpenPrinter(
    LPTSTR            lpszPrnName,
    LPHANDLE           phPrinter,
    LPPRINTER_DEFAULTS pDefaults);

DWORD PPStartDocPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE pDocInfo);

BOOL PPStartPagePrinter(
    HANDLE hPrinter);

BOOL PPWritePrinter(
    HANDLE  hPrinter,
    LPVOID  lpvBuf,
    DWORD   cbBuf,
    LPDWORD pcbWr);


BOOL PPSetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE pbPrinter,
    DWORD  dwCmd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\pusrdata.cxx ===
/*****************************************************************************\
* MODULE:       pusrdata.hxx
*
* PURPOSE:      This specialises the user data class to keep track of data
*               useful to a basic connection port.
*               
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*
*     1/11/2000  mlawrenc    Implemented
*
\*****************************************************************************/


#include "precomp.h"

#if (defined(WINNT32))

#include "priv.h"

CPortUserData::CPortUserData() 
/*++

Constructor:

    Default constructor for Port User Information.
    
--*/
  : CUserData(),
    m_lpszUserName (NULL),
    m_lpszPassword (NULL),
    m_bNeverPopup (FALSE) {

    if (m_bValid) 
        m_bValid = _GetLogonSession(m_lastLogonTime);
}

CPortUserData::CPortUserData (
    LPTSTR lpszUserName,
    LPTSTR lpszPassword,
    BOOL   bNeverPopup)
/*++

Constructor:

    Constructor for the CPortUserData used for dialogue control
    
Arguments:
    lpszUserName    - User name that this user has authenticated as on this port.
    lpszPassword    - Password that the user authenticated under
    bNeverPopup     - Whether user pushed cancel or not.
        
--*/
  : CUserData(),
    m_lpszUserName (NULL),
    m_lpszPassword (NULL),
    m_bNeverPopup (bNeverPopup) {

    if (m_bValid) {
        m_bValid = _GetLogonSession (m_lastLogonTime) &&
                   AssignString (m_lpszUserName, lpszUserName) &&
                   AssignString (m_lpszPassword, lpszPassword);
    }
}

CPortUserData::~CPortUserData()
/*++

Destructor:

    Destructor for Port User Data.
    
--*/
    {
    LocalFree (m_lpszUserName);
    LocalFree (m_lpszPassword);
}


BOOL
CPortUserData::SetPassword (
    LPTSTR lpszPassword)
{
    if (m_bValid) {
        m_bValid = AssignString (m_lpszPassword, lpszPassword);
    }
    return m_bValid;
}

BOOL
CPortUserData::SetUserName (
    LPTSTR lpszUserName)
{
    if (m_bValid) {
        m_bValid = AssignString (m_lpszUserName, lpszUserName);
    }
    return m_bValid;
}

BOOL
CPortUserData::SetPopupFlag (
    BOOL bNeverPopup)
/*++

Routine Description:

    Set the fact that we should not pop up the dialogue box again,
    Record the logon time when we made the decision, if the logon time
    advances, we will disregard this flag.
    
Arguments:
    bNeverPopup - TRUE if the user pushed Cancel.

Return Value:

    TRUE if we could get the logon time.

--*/
    {
    if (m_bNeverPopup = bNeverPopup) {
        m_bValid = _GetLogonSession (m_lastLogonTime);
    }

    return m_bValid;
}


BOOL
CPortUserData::GetPopupFlag (void)
{
    FILETIME    LogonTime;

    if (m_bNeverPopup) {

        if (_GetLogonSession (LogonTime)) {

            if (CompareFileTime (&LogonTime, &m_lastLogonTime)) { // New logon session
                  m_bNeverPopup = FALSE;
            }
        }
    }

    return m_bNeverPopup;
}

BOOL
CPortUserData::_GetLogonSession (FILETIME &LogonTime)
{
    // Read the registry and check if it is a new logon session

    BOOL        bRet             = FALSE;
    HKEY        hProvidersKey    = NULL;
    DWORD       dwType           = REG_BINARY;
    DWORD       dwSize           = sizeof (FILETIME);

    LPTSTR      szPrintProviders = g_szRegPrintProviders;
    LPTSTR      szLogonTime      = TEXT ("LogonTime");
    HANDLE      hToken;

    if (hToken = RevertToPrinterSelf()) {


        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          szPrintProviders,
                                          0,
                                          KEY_QUERY_VALUE,
                                          &hProvidersKey) &&
    
            ERROR_SUCCESS == RegQueryValueEx (hProvidersKey,
                                              szLogonTime,
                                              0,
                                              &dwType,
                                              (LPBYTE) &LogonTime,
                                              &dwSize)) {
            bRet = TRUE;
    
            RegCloseKey (hProvidersKey);
        }

        if (!ImpersonatePrinterClient(hToken))
            bRet = FALSE;
    }

    return bRet;
}


CPortUserData &
CPortUserData::operator=(const CPortUserData &rhs) {
    LocalFree (m_lpszUserName);
    LocalFree (m_lpszPassword);

    m_lpszUserName = NULL;
    m_lpszPassword = NULL;
    m_bNeverPopup = FALSE;

    this->CUserData::operator= ( rhs );

    if (m_bValid) {
        m_bNeverPopup = rhs.m_bNeverPopup;
        m_bValid = AssignString (m_lpszUserName, rhs.m_lpszUserName) &&
                   AssignString (m_lpszPassword, rhs.m_lpszPassword);
    }

    return *this;
}

#endif // #if (defined(WINNT32))

/*****************************************************************
** End of File (pusrdata.cxx)
******************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\sid.cxx ===
#include "precomp.h"

#ifdef WINNT32

#include "priv.h"

CSid::CSid ():
    m_hToken (NULL)
{
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_IMPERSONATE,
                         TRUE,
                         &m_hToken)) {

        DBG_MSG (DBG_LEV_CALLTREE, (_T ("OpenThreadToken failed: %d\n"), GetLastError()));
        m_bValid = FALSE;

    } else

        m_bValid =  TRUE;
}

CSid::~CSid()
{
    if (m_hToken) {
        CloseHandle (m_hToken);
    }
}



BOOL
CSid::SetCurrentSid ()
{
#ifdef DEBUG
    WCHAR UserName[256];
    DWORD cbUserName=256;

    GetUserName(UserName, &cbUserName);

    DBG_MSG (DBG_LEV_CALLTREE, (_T ("SetCurrentSid BEFORE: user name is %ws\n"), UserName));
#endif

    NtSetInformationThread(NtCurrentThread(), ThreadImpersonationToken,
                           &m_hToken, sizeof(m_hToken));

#ifdef DEBUG
    cbUserName = 256;

    GetUserName(UserName, &cbUserName);

    DBG_MSG (DBG_LEV_CALLTREE, (_T ("SetCurrentSid AFTER: user name is %ws\n"), UserName));
#endif

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\sid.h ===
#ifndef _CSID_H
#define _CSID_H

class CSid
{
public:
    CSid ();
    ~CSid();

    inline BOOL 
    bValid () CONST {
        return m_bValid;
    }

    BOOL         
    SetCurrentSid ();

private:
    HANDLE m_hToken;
    BOOL m_bValid;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\priv.h ===
/*****************************************************************************\
* MODULE: priv.h
*
* Private header for the Print-Processor library.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "spllib.hxx"
#include "inetlib.h"

#include "common.h"
#include "inetxcv.h"

#include "sid.h"
#include "anonycon.hxx"
#include "anycon.hxx"
#include "cachemgr.hxx"
#include "iecon.hxx"
#include "lusrdata.hxx"
#include "ntcon.hxx"
#include "othercon.hxx"
#include "portmgr.hxx"
#include "pusrdata.hxx"
#include "userdata.hxx"

#include "spljob.h"
#include "splpjm.h"
#include "ppjobs.h"
#include "inetport.h"
#include "inetpp.h"
#include "globals.h"
#include "debug.h"
#include "basicsec.h"
#include "mem.h"
#include "sem.h"
#include "util.h"
#include "stubs.h"
#include "inetwrap.h"
#include "ppinfo.h"
#include "ppport.h"
#include "ppprn.h"
#include "xcv.h"
#include "ppchange.h"
#include "stream.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\stream.h ===
#ifndef _STREAM_H
#define _STREAM_H

class CStream
{
public:
    CStream ();

    virtual ~CStream (){};
    
    virtual inline BOOL
    bValid (VOID) CONST {
        return m_bValid;
    }
    
    virtual BOOL
    Reset (
        VOID);
    
    virtual BOOL
    GetTotalSize (
        PDWORD  pdwSize) CONST;
    
    virtual BOOL
    SetPtr (
        DWORD   dwPos) = 0;
    
    virtual BOOL
    Read (
        PBYTE   pBuf,
        DWORD   dwBufSize,
        PDWORD  pdwSizeRead) = 0;

protected:
    BOOL    m_bValid;
    DWORD   m_dwTotalSize;
    DWORD   m_dwCurPos;
};


class CMemStream: public CStream
{
public:
    CMemStream (
        PBYTE pMem,
        DWORD dwTotalSize);

    
    virtual BOOL
    SetPtr (
        DWORD   dwPos);
    
    virtual BOOL
    Read (
        PBYTE   pBuf,
        DWORD   dwBufSize,
        PDWORD  pdwSizeRead);

private:
    PBYTE   m_pMem;
};

class CFileStream: public CStream
{
public:
    CFileStream (
        HANDLE hFile);

    virtual BOOL
    SetPtr (
        DWORD   dwPos);
    
    virtual BOOL
    Read (
        PBYTE   pBuf,
        DWORD   dwBufSize,
        PDWORD  pdwSizeRead);

private:
    HANDLE  m_hFile;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\spljob.h ===
/*****************************************************************************\
* MODULE: spljob.h
*
* Header file for the local-jobfile-spooling.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
#ifndef _SPLJOB_H
#define _SPLJOB_H

#define SPLFILE_SPL 0   // Specifies a file extension of .spl.
#define SPLFILE_TMP 1   // Specifies a file extension of .tmp.

class CFileStream;
    
typedef struct _SPLFILE {

    LPTSTR      lpszFile;    // Name of file.
    HANDLE      hFile;       // Handle to file.
    CFileStream *pStream;    // Stream interface

} SPLFILE;
typedef SPLFILE *PSPLFILE;
typedef SPLFILE *NPSPLFILE;
typedef SPLFILE *LPSPLFILE;

HANDLE SplCreate(DWORD, DWORD);
BOOL   SplFree(HANDLE);
BOOL   SplWrite(HANDLE, LPBYTE, DWORD, LPDWORD);
BOOL   SplWrite(HANDLE  hSpl, CStream *pStream);

CFileStream* SplLock(HANDLE hSpl);
BOOL   SplUnlock(HANDLE);
BOOL   SplClose(HANDLE);
BOOL   SplOpen(HANDLE);
VOID   SplClean(VOID);


/*****************************************************************************\
* SplFileName
*
\*****************************************************************************/
_inline LPCTSTR SplFileName(
    HANDLE hSpl)
{
    return (hSpl ? ((PSPLFILE)hSpl)->lpszFile : NULL);
}


/*****************************************************************************\
* SplFileSize
*
\*****************************************************************************/
_inline DWORD SplFileSize(
    HANDLE hSpl)
{
    return (hSpl ? GetFileSize(((PSPLFILE)hSpl)->hFile, NULL) : 0);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\stream.cxx ===
/*****************************************************************************\
* MODULE: stream.cxx
*
* The module contains the stream interface for file and memory access
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   09/20/00    Weihaic     Created
*
\*****************************************************************************/


#include "precomp.h"
#include "priv.h"

CStream::CStream ():
   m_dwCurPos (0),
   m_bValid(FALSE)
{
}

BOOL
CStream::Reset (
    VOID) 
{
    return SetPtr(0);
}
    
BOOL
CStream::GetTotalSize (
    PDWORD  pdwSize) CONST
{
    BOOL bRet = FALSE;

    if (m_bValid && pdwSize) {
        *pdwSize = m_dwTotalSize;

        bRet = TRUE;
    }

    return bRet;
}
    
CMemStream::CMemStream (
    PBYTE pMem,
    DWORD dwTotalSize):
    m_pMem (pMem)
{
    m_dwTotalSize = dwTotalSize;
    m_bValid = TRUE;
}
    
        
BOOL
CMemStream::SetPtr (
    DWORD dwPos)
{
    BOOL bRet = FALSE;

    if (m_dwCurPos < m_dwTotalSize)
    {
        m_dwCurPos = dwPos;
        bRet = TRUE;
    }

    return bRet;
}
        
BOOL
CMemStream::Read (
    PBYTE   pBuf,
    DWORD   dwBufSize,
    PDWORD  pdwSizeRead)
{
    DWORD dwSizeLeft = m_dwTotalSize - m_dwCurPos;

    *pdwSizeRead = (dwSizeLeft > dwBufSize)?dwBufSize:dwSizeLeft;

    CopyMemory (pBuf, m_pMem + m_dwCurPos, *pdwSizeRead);

    return TRUE;
}



CFileStream::CFileStream (
    HANDLE hFile):
    m_hFile (hFile)
{
    BOOL bRet = FALSE;
    LARGE_INTEGER LargeSize; 

    if (GetFileSizeEx (m_hFile, &LargeSize) && LargeSize.HighPart == 0) {
        m_dwTotalSize = LargeSize.LowPart;
        bRet = TRUE;
    }
    
    m_bValid = bRet;
}
    
BOOL
CFileStream::SetPtr (
    DWORD dwPos)
{
    BOOL bRet = FALSE;
    LARGE_INTEGER LargePos; 

    LargePos.LowPart = dwPos;
    LargePos.HighPart = 0;

    if (m_bValid) {
        
        if (SetFilePointerEx (m_hFile, LargePos, NULL, FILE_BEGIN)) {
            m_dwCurPos = dwPos;
            bRet = TRUE;
        }
    }
    return bRet;
}
        
BOOL
CFileStream::Read (
    PBYTE   pBuf,
    DWORD   dwBufSize,
    PDWORD  pdwSizeRead)
{
    BOOL bRet = FALSE;
    
    if (m_bValid) {

        if (ReadFile (m_hFile, pBuf, dwBufSize, pdwSizeRead, NULL)) {
            m_dwCurPos+= *pdwSizeRead;
            bRet = TRUE;
        }

    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\splpjm.cxx ===
/*****************************************************************************\
* MODULE: splpjm.c
*
* This module contains the routines to deal with job-mapping list.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   13-Jan-1997 ChrisWil    Created.
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* pjm_OldEntry (Local Routine)
*
*
\*****************************************************************************/
_inline BOOL pjm_IsOldEntry(
    PJOBMAP      pjm)
{
    return !pjm->bRemoteJob && !pjmChkState(pjm, PJM_SPOOLING);
}

/*****************************************************************************\
* pjm_IsLocalJob (Local Routine)
*
*
\*****************************************************************************/
_inline BOOL pjm_IsLocalJob(
    PJOBMAP      pjm)
{
    return !pjm->bRemoteJob && pjmChkState(pjm, PJM_SPOOLING);
}

    


/*****************************************************************************\
* pjm_DelEntry (Local Routine)
*
*
\*****************************************************************************/
_inline VOID pjm_DelEntry(
    PJOBMAP     pjm)
{
    if (pjm->hSplFile)
        SplFree(pjm->hSplFile);

    if (pjm->lpszUri)
        memFreeStr(pjm->lpszUri);

    if (pjm->lpszUser)
        memFreeStr(pjm->lpszUser);

    memFree(pjm, sizeof(JOBMAP));
}


/*****************************************************************************\
* pjmAdd
*
* Add a job-mapping to the list.  Access to this list needs ownership of the
* crit-sect.
*
\*****************************************************************************/
PJOBMAP pjmAdd(
    PJOBMAP         *pjmList,
    PCINETMONPORT   pIniPort,
    LPCTSTR         lpszUser,
    LPCTSTR         lpszDocName)
{
    PJOBMAP pjm = NULL;

    static DWORD s_idJobLocal = 0;

    semCheckCrit();

    if (pjmList) {

        
        // Add the new job-entry to the list.
        //
        if (pjm = (PJOBMAP)memAlloc(sizeof(JOBMAP))) {
    
            // Initialize our job-entry.
            //
            GetSystemTime (&pjm->SubmitTime);

            pjm->dwState        = 0;
            pjm->pIniPort       = pIniPort;
            pjm->idJobLocal     = ++s_idJobLocal;
            pjm->idJobRemote    = 0;
            pjm->lpszUri        = NULL;
            pjm->lpszUser       = memAllocStr(lpszUser);
            pjm->lpszDocName    = memAllocStr(lpszDocName);
            pjm->hSplFile       = NULL;
            pjm->dwLocalJobSize = 0;
            pjm->dwStatus       = JOB_STATUS_SPOOLING;
            pjm->pNext          = NULL;
    
    
            // Place it at the end of the list.
            //

            if (! *pjmList) {
                *pjmList = pjm;
            }
            else {

                for (PJOBMAP pjPtr = *pjmList; pjPtr->pNext; pjPtr = pjPtr->pNext);
                pjPtr->pNext = pjm;
            }
        }
    }

    return pjm;
}


/*****************************************************************************\
* pjmDel
*
* Delete a job-mapping from the list.  Access to this list needs owenership
* of the crit-sect.
*
\*****************************************************************************/
VOID pjmDel(
    PJOBMAP* pjmList,
    PJOBMAP  pjm)
{
    PJOBMAP pjPtr;
    PJOBMAP pjPrv;
    DWORD   idx;

    semCheckCrit();

    if (pjmList) {

        for (pjPtr = *pjmList, idx = 0; pjPtr && (pjm != pjPtr); ) {
    
            // Reposition.
            //
            pjPrv = pjPtr;
            pjPtr = pjPtr->pNext;
    
    
            // If we've iterated 1000 jobs in this list, then we've
            // either got a very heavily taxed print-system, or we
            // may have an infinite loop.
            //
            if (idx++ >= g_dwJobLimit) {
    
                DBG_MSG(DBG_LEV_ERROR, (TEXT("Error: pjmDel : Looped 1000 jobs, possible infinite loop")));
    
                return;
            }
        }
    
    
        // If we found the entry, then delete it.
        //
        if (pjPtr) {
    
            if (pjPtr == *pjmList) {
    
                *pjmList = pjPtr->pNext;
    
            } else {
    
                pjPrv->pNext = pjPtr->pNext;
            }
    
            pjm_DelEntry(pjPtr);
        }
    }
}

/*****************************************************************************\
* pjmCleanRemoteFlag
*
* Cleanup remote jobid from list.  Access to this list needs ownership of the
* crit-sect. 
*
\*****************************************************************************/
VOID pjmCleanRemoteFlag(
    PJOBMAP* pjmList)
{
    PJOBMAP pjPtr = NULL;

    semCheckCrit();

    if (pjmList) {
    
        for (pjPtr = *pjmList; pjPtr; ) {

            pjPtr->bRemoteJob = FALSE;
    
            // Next item.
            //
            pjPtr = pjPtr->pNext;
    
        }
    }
    
}

/*****************************************************************************\
* pjmGetLocalJobCount
*
* Locate number of job-entries from list.  Access to this list needs ownership of the
* crit-sect. 
*
\*****************************************************************************/
DWORD pjmGetLocalJobCount(
    PJOBMAP* pjmList,
    DWORD*   pcbItems)
{
    PJOBMAP pjPtr = NULL;
    DWORD   idx = 0;

    semCheckCrit();

    *pcbItems = 0;
    if (pjmList) {
    
        for (pjPtr = *pjmList; pjPtr; ) {

            if (pjm_IsLocalJob (pjPtr)) {

                idx++;

                *pcbItems += sizeof (JOB_INFO_2) +
                             utlStrSize (pjPtr->lpszDocName) +
                             utlStrSize (pjPtr->lpszUser);
            }

            // Next item.
            //
            pjPtr = pjPtr->pNext;

        }
    }

    return idx;
}

/*****************************************************************************\
* pjmFind
*
* Locate job-entry from list.  Access to this list needs ownership of the
* crit-sect.  This will lookup either Local/Remote id's and return its
* position.
*
\*****************************************************************************/
PJOBMAP pjmFind(
    PJOBMAP* pjmList,
    DWORD    fType,
    DWORD    idJob)
{
    PJOBMAP pjPtr = NULL;
    DWORD   idx;

    semCheckCrit();

    if (pjmList) {
    
        // Search.
        //
        for (pjPtr = *pjmList, idx = 0; pjPtr && (pjmJobId(pjPtr, fType) != idJob); ) {
    
            // Next item.
            //
            pjPtr = pjPtr->pNext;
    
    
            // If we've iterated 1000 jobs in this list, then we've
            // either got a very heavily taxed print-system, or we
            // may have an infinite loop.
            //
            if (idx++ >= g_dwJobLimit) {
    
                DBG_MSG(DBG_LEV_ERROR, (TEXT("Error: pjmFind : Looped 1000 jobs, possible infinite loop")));
    
                return NULL;
            }
        }

        if (pjPtr && fType == PJM_REMOTEID) {
            pjPtr->bRemoteJob = TRUE;
        }

    }

    return pjPtr;
}

/*****************************************************************************\
* pjmNextLocalJob
*
* Walk the list and look for any expired entries.  Access to this list needs
* ownership of the crit-sect.
*
\*****************************************************************************/
PJOBMAP pjmNextLocalJob(
    PJOBMAP*    pjmList,
    PJOB_INFO_2 pJobInfo2,
    PBOOL       pbFound)
{
    PJOBMAP pjPtr = NULL;
    DWORD   idx;
    BOOL    bFound = FALSE;

    semCheckCrit();

    if (pjmList) {
    
        for (pjPtr = *pjmList, idx = 0; pjPtr && !bFound; ) {
    
            // If we're spooling, then we can't be an old-job.
            //
            if (pjm_IsLocalJob (pjPtr)) {

                // It is a new entry
                //
                ZeroMemory (pJobInfo2, sizeof (JOB_INFO_2));
                pJobInfo2->JobId        = pjPtr->idJobLocal;
                pJobInfo2->pDocument    = pjPtr->lpszDocName;
                pJobInfo2->pUserName    = pjPtr->lpszUser;
                pJobInfo2->Size         = pjPtr->dwLocalJobSize;
                pJobInfo2->Submitted    = pjPtr->SubmitTime;
                pJobInfo2->Status       = pjPtr->dwStatus;

                if (pjmChkState (pjPtr, PJM_CANCEL)) {
                    pJobInfo2->Status |= JOB_STATUS_DELETING;
                }

                bFound = TRUE;
            }
            
            // Next item.
            //
            pjPtr = pjPtr->pNext;
    
        }
    }

    *pbFound = bFound;
    return pjPtr;
}

/*****************************************************************************\
* pjmRmoveOldEntries
*
* Walk the list and look for any expired entries.  Access to this list needs
* ownership of the crit-sect.
*
\*****************************************************************************/
VOID pjmRemoveOldEntries(
    PJOBMAP      *pjmList)
{
    PJOBMAP pjPtr;
    PJOBMAP pjDel;
    PJOBMAP pjPrv;
    DWORD   idx;

    semCheckCrit();


    for (pjPtr = *pjmList, pjPrv = *pjmList, idx = 0; pjPtr; ) {

        // If we're an old entry, then delete it.
        //
        if (pjm_IsOldEntry (pjPtr)) {

            // No remote job ID and the state is not spooling
            // It is an old entry, delete it

            pjDel = pjPtr;

            if (pjPtr == *pjmList) {

                *pjmList = pjPtr->pNext;
                pjPtr    = *pjmList;
                pjPrv    = *pjmList;

            } else {

                pjPrv->pNext = pjPtr->pNext;
                pjPtr        = pjPrv->pNext;
            }

            pjm_DelEntry(pjDel);


        } else {

            pjPrv = pjPtr;
            pjPtr = pjPtr->pNext;
        }


        // If we've iterated 1000 jobs in this list, then we've
        // either got a very heavily taxed print-system, or we
        // may have an infinite loop.
        //
        if (idx++ >= g_dwJobLimit) {

            DBG_MSG(DBG_LEV_ERROR, (TEXT("Warn : pjmWalk : Looped 1000 jobs, possible infinite loop")));

            return;
        }
    }
}




/*****************************************************************************\
* pjmDelList
*
*
\*****************************************************************************/
VOID pjmDelList(
    PJOBMAP pjmList)
{
    PJOBMAP pjPtr;

    semCheckCrit();


    for (pjPtr = pjmList; pjPtr; ) {

        pjmList = pjPtr->pNext;

        pjm_DelEntry(pjPtr);

        pjPtr = pjmList;
    }
}


/*****************************************************************************\
* pjmSetState
*
* Set the state of the job-entry.  If we're setting this to spooling-state,
* then we go through the extra-trouble of setting up a spool-file entry as
* well.
*
\*****************************************************************************/
BOOL pjmSetState(
    PJOBMAP pjm,
    DWORD   dwState)
{
    DWORD fType;
    BOOL  bSet = FALSE;

    semCheckCrit();


    if (pjm) {

        // If the caller is setting the job into spooling-state, then
        // we need to create a spool-file.  If this state is already
        // set, then ignore this particular call.
        //
        if ((dwState & PJM_SPOOLING) && !pjmChkState(pjm, PJM_SPOOLING)) {

            // Determine the type of spl-file to open.  If PJM_NOOPEN
            // is specified, then we will close the file-handle so that
            // other processes can obtain exclusive access (i.e. AddJob,
            // and ScheduleJob require this).
            //
            fType = (dwState & PJM_NOOPEN ? SPLFILE_TMP : SPLFILE_SPL);


            // Allocate the spool-file, and close if necessary.
            //
            if (pjm->hSplFile = SplCreate(pjm->idJobLocal, fType)) {

                if (dwState & PJM_NOOPEN)
                    SplClose(pjm->hSplFile);

                bSet = TRUE;

            } else {

                goto EndSet;
            }

        } else {

            bSet = TRUE;
        }


        // Set the state.
        //
        pjm->dwState |= dwState;
    }

EndSet:

    return bSet;
}


/*****************************************************************************\
* pjmClrState
*
* Clear the state specified in the job-entry.  If we're turning of spooling,
* then we need to free up the spool-file-object.
*
\*****************************************************************************/
VOID pjmClrState(
    PJOBMAP pjm,
    DWORD   dwState)
{
    semCheckCrit();


    if (pjm) {

        // If the caller is turning off spooling, then we need to
        // clean our spool-file resources.  If there is no spooling
        // going on, then ignore.
        //
        if ((dwState & PJM_SPOOLING) && pjmChkState(pjm, PJM_SPOOLING)) {

            // Clean our spooling-file resources.
            //
            SplFree(pjm->hSplFile);
            pjm->hSplFile = NULL;
        }


        // Clear the state.
        //
        pjm->dwState &= ~dwState;
    }
}


/*****************************************************************************\
* pjmSetJobRemote
*
* Set the remote-job-id into the job-entry.  This is usually called once
* the job-id is obtained from the print-server.  We will maintain this for
* local/remote job-mapping.
*
\*****************************************************************************/
VOID pjmSetJobRemote(
    PJOBMAP pjm,
    DWORD   idJobRemote,
    LPCTSTR lpszUri)
{
    semCheckCrit();

    if (pjm) {

        // If we had a previous job-url, then we need to free it
        // before reseting it with the new.
        //
        if (pjm->lpszUri)
            memFreeStr(pjm->lpszUri);


        // Store remote-job information.
        //
        pjm->idJobRemote = idJobRemote;
        pjm->lpszUri     = memAllocStr(lpszUri);
        pjm->bRemoteJob  = TRUE;
    }
}

/*****************************************************************************\
* pjmAddJobSize
*
* Add the job size to the local job info. This is usually called by
* PPWritePrinter 
*
\*****************************************************************************/
VOID pjmAddJobSize(
    PJOBMAP pjm,
    DWORD   dwSize)
{
    semCheckCrit();

    if (pjm) {

        pjm->dwLocalJobSize += dwSize;
    }
}



/*****************************************************************************\
* pjmSplLock
*
* Lock the spool-file for reading.  This returns a file-map pointer to the
* caller.
*
\*****************************************************************************/
CFileStream* pjmSplLock(
    PJOBMAP pjm)
{
    CFileStream *pStream = NULL;

    semCheckCrit();

    if (pjm) {

        // If the state of our spool-object requires that we not
        // keep open-handles on the file, then we need to open
        // it here.  This is closed at pjmSplUnlock().
        //
        if (pjmChkState(pjm, PJM_NOOPEN))
            SplOpen(pjm->hSplFile);

        pStream = SplLock(pjm->hSplFile);
    }

    return pStream;
}


/*****************************************************************************\
* pjmSplUnlock
*
* This unlocks our file-mapped-pointer on the spool-file.
*
\*****************************************************************************/
BOOL pjmSplUnlock(
    PJOBMAP pjm)
{
    BOOL bRet = FALSE;

    semCheckCrit();


    // The spool-file must have already been locked in order to proceed
    // with this call.
    //
    if (pjm) {

        // Unlock the spool-file.
        //
        bRet = SplUnlock(pjm->hSplFile);


        // If the state of our spool-object requires that
        // we keep no open-handles, then we need to close
        // the spool-handle.
        //
        if (pjmChkState(pjm, PJM_NOOPEN))
            SplClose(pjm->hSplFile);
    }

    return bRet;
}


/*****************************************************************************\
* pjmSplWrite
*
* Write out data to the spool-file.
*
\*****************************************************************************/
BOOL pjmSplWrite(
    PJOBMAP pjm,
    LPVOID  lpMem,
    DWORD   cbMem,
    LPDWORD lpcbWr)
{
    BOOL bRet = FALSE;

    semCheckCrit();


    if (pjm) {

        if (pjmChkState(pjm, PJM_NOOPEN))
            SplOpen(pjm->hSplFile);

        bRet = SplWrite(pjm->hSplFile, (LPBYTE) lpMem, cbMem, lpcbWr);

        if (pjmChkState(pjm, PJM_NOOPEN))
            SplClose(pjm->hSplFile);
    }

    return bRet;
}

/*****************************************************************************\
* pjmSetState
*
* Set the status of the local job-entry. 
*
\*****************************************************************************/
VOID pjmUpdateLocalJobStatus(
    PJOBMAP pjm,
    DWORD   dwStatus)
{
    semCheckCrit();


    if (pjm) {

        pjm->dwStatus = dwStatus;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\sources.inc ===
!IF 0
/*****************************************************************************\
* SOURCES FILE
*
* This file is used by the BUILD executable for constructing the INETPP
* dynalink.  This file is only used for NT 32bit systems.
*
* Currently, there are a few #ifdef's defined within the source.  These
* are listed as follows:
*
*   NOT_IMPLEMENTED - brackets code which is not functional or implemented.
*   NOT_CALLED      - ported routines that aren't used.
*   DEBUG           - enables extra debugging code.
*   UNICODE         - enables Unicode wrappers.
*
* To enable this for WIN9X, just remove the UNICODE and WINNT32 defines.  This
* will compile the library as ANSI and remove any WINNT specific code.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
!ENDIF

MAJORCOMP=windows
MINORCOMP=inetpp

TARGETNAME=inetpp

TARGETPATH=obj

TARGETTYPE=DYNLINK

! if "$(DELAYLOAD)" != ""
DELAYLOAD= $(DELAYLOAD);wininet.dll
! else
DELAYLOAD=wininet.dll
! endif
DLOAD_ERROR_HANDLER=inetpp.dll

TARGETLIBS= \
         $(SDK_LIB_PATH)\version.lib              \
         $(SDK_LIB_PATH)\wininet.lib              \
         $(NET_LIB_PATH)\icmp.lib                 \
         $(LIB_PLATFORM_PATH)\*\gdi32.lib         \
         $(LIB_PLATFORM_PATH)\*\user32.lib        \
         $(LIB_PLATFORM_PATH)\*\kernel32.lib      \
         $(LIB_PLATFORM_PATH)\*\advapi32.lib      \
         $(LIB_PLATFORM_PATH)\*\shell32.lib       \
         $(LIB_PLATFORM_PATH)\*\winspool.lib      \
         $(PROJECT_ROOT)\lib\*\spoolss.lib        \
!if "$(PLATFORM)" == "WINNT"
         $(SDK_LIB_PATH)\crypt32.lib              \
         $(SDK_LIB_PATH)\ws2_32.lib               \
         $(PROJECT_ROOT)\lib\*\spllib.lib         \
         $(PROJECT_ROOT)\lib\*\inetlib.lib
!else
         $(SDK_LIB_PATH)\wsock32.lib              \
         $(PROJECT_ROOT)\lib\*\splliba.lib
!endif

DLLENTRY=_DllMainCRTStartup

USE_MSVCRT=1

INCLUDES=.;..;..\..\inc;$(PROJECT_ROOT)\print\spooler\inc;$(BASEDIR)\public\sdk\inc;$(BASEDIR)\public\sdk\inc\crt

DLLDEF = ..\inetpp.def

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=                \
        ..\cachemgr.cxx \
        ..\debug.cxx    \
        ..\mem.cxx      \
        ..\globals.cxx  \
        ..\inetport.cxx \
        ..\inetpp.cxx   \
        ..\ppinfo.cxx   \
        ..\ppinit.cxx   \
        ..\ppjobs.cxx   \
        ..\ppport.cxx   \
        ..\ppprn.cxx    \
        ..\spljob.cxx   \
        ..\splpjm.cxx   \
        ..\stubs.cxx    \
        ..\util.cxx     \
        ..\inetwrap.cxx \
        ..\portmgr.cxx  \
        ..\anycon.cxx   \
        ..\ping.cxx     \
        ..\stream.cxx   \
        ..\inetpp.rc

!if "$(PLATFORM)" == "WINNT"
SOURCES= $(SOURCES)     \
        ..\ppchange.cxx \
        ..\ntcon.cxx    \
        ..\othercon.cxx \
        ..\userdata.cxx \
        ..\pusrdata.cxx \
        ..\lusrdata.cxx \
        ..\config.cxx   \
        ..\anonycon.cxx \
        ..\iecon.cxx    \
        ..\sid.cxx      \
        ..\xcv.cxx
!endif

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\stubs.cxx ===
/*****************************************************************************\
* MODULE: stubs.c
*
* This module contains the stub routines for unimplemented (non-required)
* Print-Provider functions.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* _stub_routine (Local Routine)
*
* Common code for stubbed PP routines.  Sets last error to the specified
* number, then returns FALSE.
*
\*****************************************************************************/
BOOL _stub_routine(VOID)
{
    SetLastError(ERROR_INVALID_NAME);

    return FALSE;
}


/*****************************************************************************\
* stubAddPrinter
*
*
\*****************************************************************************/
HANDLE stubAddPrinter(
    LPTSTR pszName,
    DWORD  dwLevel,
    LPBYTE pbPrinter)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPrinter")));
    return (HANDLE)IntToPtr(_stub_routine());
}


/*****************************************************************************\
* stubDeletePrinter
*
*
\*****************************************************************************/
BOOL stubDeletePrinter(
    HANDLE hPrinter)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePrinter")));
    return _stub_routine();
}


/*****************************************************************************\
* stubReadPrinter
*
*
\*****************************************************************************/
BOOL stubReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubReadPrinter")));
    return _stub_routine();
}


/*****************************************************************************\
* stubGetPrinterData
*
*
\*****************************************************************************/
DWORD stubGetPrinterData(
    HANDLE  hPrinter,
    LPTSTR  pszValueName,
    LPDWORD pType,
    LPBYTE  pbData,
    DWORD   dwSize,
    LPDWORD pcbNeeded)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubGetPrinterData")));
    return _stub_routine();
}


/*****************************************************************************\
* stubSetPrinterData
*
*
\*****************************************************************************/
DWORD stubSetPrinterData(
    HANDLE hPrinter,
    LPTSTR pszValueName,
    DWORD  dwType,
    LPBYTE pbData,
    DWORD  cbData)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubSetPrinterData")));
    return _stub_routine();
}


/*****************************************************************************\
* stubWaitForPrinterChange
*
*
\*****************************************************************************/
DWORD stubWaitForPrinterChange(
    HANDLE hPrinter,
    DWORD  dwFlags)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubWaitForPrinterChange")));
    return _stub_routine();
}


/*****************************************************************************\
* stubAddPrinterConnection
*
*
\*****************************************************************************/
BOOL stubAddPrinterConnection(
    LPTSTR pszName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPrinterConnection")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeletePrinterConnection
*
*
\*****************************************************************************/
BOOL stubDeletePrinterConnection(
    LPTSTR pszName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePrinterConnection")));
    return _stub_routine();
}


/*****************************************************************************\
* stubPrinterMessageBox
*
*
\*****************************************************************************/
DWORD stubPrinterMessageBox(
    HANDLE hPrinter,
    DWORD  dwError,
    HWND   hWnd,
    LPTSTR pszText,
    LPTSTR pszCaption,
    DWORD  dwType)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubPrinterMessageBox")));
    return _stub_routine();
}


/*****************************************************************************\
* stubAddPrinterDriver
*
*
\*****************************************************************************/
BOOL stubAddPrinterDriver(
    LPTSTR pszName,
    DWORD  dwLevel,
    LPBYTE pbDriverInfo)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPrinterDriver")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeletePrinterDriver
*
*
\*****************************************************************************/
BOOL stubDeletePrinterDriver(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszDriverName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePrinterDriver")));
    return _stub_routine();
}


/*****************************************************************************\
* stubGetPrinterDriver
*
*
\*****************************************************************************/
BOOL stubGetPrinterDriver(
    HANDLE  hPrinter,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubGetPrinterDriver")));
    return _stub_routine();
}


/*****************************************************************************\
* stubEnumPrinterDrivers
*
*
\*****************************************************************************/
BOOL stubEnumPrinterDrivers(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubEnumPrinterDrivers")));
    return _stub_routine();
}


/*****************************************************************************\
* stubGetPrinterDriverDirectory
*
*
\*****************************************************************************/
BOOL stubGetPrinterDriverDirectory(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubGetPrinterDriverDirectory")));
    return _stub_routine();
}

/*****************************************************************************\
* stubAddPrintProcessor
*
*
\*****************************************************************************/
BOOL stubAddPrintProcessor(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszPathName,
    LPTSTR pszPrintProcessorName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPrintProcessor")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeletePrintProcessor
*
*
\*****************************************************************************/
BOOL stubDeletePrintProcessor(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszPrintProcessorName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePrintProcessor")));
    return _stub_routine();
}


/*****************************************************************************\
* stubEnumPrintProcessors
*
*
\*****************************************************************************/
BOOL stubEnumPrintProcessors(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubEnumPrintProcessors")));
    return _stub_routine();
}


/*****************************************************************************\
* stubGetPrintProcessorDirectory
*
*
\*****************************************************************************/
BOOL stubGetPrintProcessorDirectory(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubGetPrintProcessorDirectory")));
    return _stub_routine();
}


/*****************************************************************************\
* stubEnumPrintProcessorDatatypes
*
*
\*****************************************************************************/
BOOL stubEnumPrintProcessorDatatypes(
    LPTSTR  pszName,
    LPTSTR  pszPrintProcessorName,
    DWORD   dwLevel,
    LPBYTE  pbDataypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubEnumPrintProcessorDatatypes")));
    return _stub_routine();
}


/*****************************************************************************\
* stubAddForm
*
*
\*****************************************************************************/
BOOL stubAddForm(
    HANDLE hPrinter,
    DWORD  Level,
    LPBYTE pForm)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddForm")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeleteForm
*
*
\*****************************************************************************/
BOOL stubDeleteForm(
    HANDLE hPrinter,
    LPTSTR pFormName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeleteForm")));
    return _stub_routine();
}


/*****************************************************************************\
* stubGetForm
*
*
\*****************************************************************************/
BOOL stubGetForm(
    HANDLE  hPrinter,
    LPTSTR  pszFormName,
    DWORD   dwLevel,
    LPBYTE  pbForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubGetForm")));
    return _stub_routine();
}


/*****************************************************************************\
* stubSetForm
*
*
\*****************************************************************************/
BOOL stubSetForm(
    HANDLE hPrinter,
    LPTSTR pszFormName,
    DWORD  dwLevel,
    LPBYTE pbForm)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubSetForm")));
    return _stub_routine();
}


/*****************************************************************************\
* stubEnumForms
*
*
\*****************************************************************************/
BOOL stubEnumForms(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubEnumForms")));
    return _stub_routine();
}


/*****************************************************************************\
* stubAddMonitor
*
*
\*****************************************************************************/
BOOL stubAddMonitor(
    LPTSTR pszName,
    DWORD  dwLevel,
    LPBYTE pbMonitorInfo)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddMonitor")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeleteMonitor
*
*
\*****************************************************************************/
BOOL stubDeleteMonitor(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszMonitorName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeleteMonitor")));
    return _stub_routine();
}

/*****************************************************************************\
* stubEnumMonitors
*
*
\*****************************************************************************/
BOOL stubEnumMonitors(
    LPTSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pbMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubEnumMonitors")));
    return _stub_routine();
}


/*****************************************************************************\
* stubAddPort
*
*
\*****************************************************************************/
BOOL stubAddPort(

    LPTSTR  pName,
    HWND    hWnd,
    LPTSTR  pMonitorName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPort")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeletePort
*
*
\*****************************************************************************/
BOOL stubDeletePort(

    LPTSTR  pName,
    HWND    hWnd,
    LPTSTR  pPortName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePort")));
    return _stub_routine();
}


/*****************************************************************************\
* stubConfigurePort
*
*
\*****************************************************************************/
BOOL stubConfigurePort(
    LPTSTR lpszServerName,
    HWND   hWnd,
    LPTSTR lpszPortName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubConfigurePort")));
    return _stub_routine();
}


/*****************************************************************************\
* stubCreatePrinterIC
*
*
\*****************************************************************************/
HANDLE stubCreatePrinterIC(
    HANDLE     hPrinter,
    LPDEVMODEW pDevMode)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubCreatePrinterIC")));
    return (HANDLE)IntToPtr(_stub_routine());
}


/*****************************************************************************\
* stubPlayGdiScriptOnPrinterIC
*
*
\*****************************************************************************/
BOOL stubPlayGdiScriptOnPrinterIC(
    HANDLE hPrinterIC,
    LPBYTE pbIn,
    DWORD  cIn,
    LPBYTE pbOut,
    DWORD  cOut,
    DWORD  ul)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubPlayGdiScriptOnPrinter")));
    return _stub_routine();
}


/*****************************************************************************\
* stubDeletePrinterIC
*
*
\*****************************************************************************/
BOOL stubDeletePrinterIC(
    HANDLE hPrinterIC)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePrinterIC")));
    return _stub_routine();
}



/*****************************************************************************\
* stubResetPrinter
*
*
\*****************************************************************************/
BOOL stubResetPrinter(
    LPPRINTER_DEFAULTS lpDefault)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubResetPrinter")));
    SetLastError(ERROR_NOT_SUPPORTED);

    return FALSE;
}


/*****************************************************************************\
* stubGetPrinterDriverEx
*
*
\*****************************************************************************/
BOOL stubGetPrinterDriverEx(
    LPTSTR  lpEnvironment,
    DWORD   dwLevel,
    LPBYTE  lpbDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVer,
    DWORD   dwClientMinorVer,
    PDWORD  pdwServerMajorVer,
    PDWORD  pdwServerMinorVer)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubGetPrinterDriverEx")));
    return _stub_routine();
}


/*****************************************************************************\
* stubFindFirstPrinterChangeNotification
*
*
\*****************************************************************************/
BOOL stubFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD  dwFlags,
    DWORD  dwOptions,
    HANDLE hNotify,
    PDWORD pdwStatus,
    PVOID  pPrinterNofityOptions,
    PVOID  pPrinterNotifyInit)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubFindFirstPrinterChangeNotification")));
    return _stub_routine();
}


/*****************************************************************************\
* stubFindClosePrinterChangeNotification
*
*
\*****************************************************************************/
BOOL stubFindClosePrinterChangeNotification(
    HANDLE hPrinter)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubFindClosePrinterChangeNotification")));
    return _stub_routine();
}

/*****************************************************************************\
* stubAddPortEx
*
*
\*****************************************************************************/
BOOL stubAddPortEx(
    LPTSTR lpszName,
    DWORD  dwLevel,
    LPBYTE lpbBuffer,
    LPTSTR lpszMonitorName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPortEx")));
    return _stub_routine();
}


/*****************************************************************************\
* stubShutDown
*
*
\*****************************************************************************/
BOOL stubShutDown(
    LPVOID lpvReserved)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubShutDown")));
    return _stub_routine();
}

/*****************************************************************************\
* stubRefreshPrinterChangeNotification
*
*
\*****************************************************************************/
BOOL stubRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD  dwReserved,
    PVOID  pvReserved,
    PVOID  pvPrinterNotifyInfo)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubRefreshPrinterChangeNotification")));
    return _stub_routine();
}


/*****************************************************************************\
* stubOpenPrinterEx
*
*
\*****************************************************************************/
BOOL stubOpenPrinterEx(
    LPTSTR             lpszPrinterName,
    LPHANDLE           phPrinter,
    LPPRINTER_DEFAULTS pDefault,
    LPBYTE             lpbClientInfo,
    DWORD              dwLevel)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubOpenPrinterEx")));
    return _stub_routine();
}


/*****************************************************************************\
* stubAddPrinterEx
*
*
\*****************************************************************************/
HANDLE stubAddPrinterEx(
    LPTSTR lpszName,
    DWORD  dwLevel,
    LPBYTE lpbPrinter,
    LPBYTE lpbClientInfo,
    DWORD  dwClientInfoLevel)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubAddPrinterEx")));
    return (HANDLE)IntToPtr(_stub_routine());
}


/*****************************************************************************\
* stubSetPort
*
*
\*****************************************************************************/
BOOL stubSetPort(
    LPTSTR lpszName,
    LPTSTR lpszPortName,
    DWORD  dwLevel,
    LPBYTE lpbPortInfo)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubSetPort")));
    return _stub_routine();
}


/*****************************************************************************\
* stubEnumPrinterData
*
*
\*****************************************************************************/
DWORD stubEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,
    LPTSTR  lpszValueName,
    DWORD   cbValueName,
    LPDWORD pcbValueName,
    LPDWORD pdwType,
    LPBYTE  lpbData,
    DWORD   cbData,
    LPDWORD lpcbData)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubEnumPrinterData")));
    return (DWORD)_stub_routine();
}

/*****************************************************************************\
* stubDeletePrinterData
*
*
\*****************************************************************************/
DWORD stubDeletePrinterData(
    HANDLE  hPrinter,
    LPTSTR  lpszValueName)
{
    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: stubDeletePrinterData")));
    return (DWORD)_stub_routine();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\spljob.cxx ===
/*****************************************************************************\
* MODULE: spljob.c
*
* This module contains the routines to deal with spooling a job to file.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*   14-Nov-1997 ChrisWil    Added local-spooling functionality.
*
\*****************************************************************************/

#include "precomp.h"
#include "priv.h"

/*****************************************************************************\
* Spl_GetCurDir
*
* Returns string indicating current-directory.
*
\*****************************************************************************/
LPTSTR Spl_GetCurDir(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszDir = NULL;


    cbSize = GetCurrentDirectory(0, NULL);

    if (cbSize && (lpszDir = (LPTSTR)memAlloc((cbSize * sizeof(TCHAR)))))
        GetCurrentDirectory(cbSize, lpszDir);

    return lpszDir;
}


/*****************************************************************************\
* Spl_GetDir
*
* Returns the spooler-directory where print-jobs are processed.
*
\*****************************************************************************/
LPTSTR Spl_GetDir(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszDir = NULL;

#ifdef WINNT32


    if (*g_szDefSplDir &&
        (lpszDir = (LPTSTR) memAlloc(sizeof (TCHAR) * (lstrlen (g_szDefSplDir) + 1)))) {

        lstrcpy (lpszDir, g_szDefSplDir);
    }

#else

    cbSize = GetWindowsDirectory(NULL, 0);

    if (cbSize && (lpszDir = (LPTSTR)memAlloc( cbSize + lstrlen(g_szSplDir9X) ))) {

        if (GetWindowsDirectory(lpszDir, cbSize))
            lstrcat(lpszDir, g_szSplDir9X);
    }

#endif

    return lpszDir;
}


/*****************************************************************************\
* Spl_MemCheck  (Local Routine)
*
* This routine checks for out-of-disk-space and out-of-memory conditions.
*
\*****************************************************************************/
VOID Spl_MemCheck(
    LPCTSTR lpszDir)
{
#ifdef WINNT32
    ULARGE_INTEGER i64FreeBytesToCaller;
    ULARGE_INTEGER i64TotalBytes;
#else
    DWORD  dwSpC;
    DWORD  dwBpS;
    DWORD  dwNoF;
    DWORD  dwNoC;
#endif
    LPTSTR lpszRoot;
    LPTSTR lpszPtr;


    // Look for out-of-diskspace
    //
    if (lpszRoot = memAllocStr(lpszDir)) {

        // Set the path to be only a root-drive-path.
        //
        if (lpszPtr = utlStrChr(lpszRoot, TEXT('\\'))) {

            lpszPtr++;

            if (*lpszPtr != TEXT('\0'))
                *lpszPtr = TEXT('\0');
        }

#ifdef WINNT32


        // Get the drive-space information.
        //
        if (GetDiskFreeSpaceEx (lpszRoot, &i64FreeBytesToCaller, &i64TotalBytes, NULL)) {

            // We'll assume out-of-disk-space for anything less
            // then MIN_DISK_SPACE.
            //
            if (i64FreeBytesToCaller.QuadPart <= MIN_DISK_SPACE) {

                DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : _inet_MemCheck : Out of disk space.")));

                SetLastError(ERROR_DISK_FULL);
            }
        }

#else
        // Get the drive-space information.
        //
        if (GetDiskFreeSpace(lpszRoot, &dwSpC, &dwBpS, &dwNoF, &dwNoC)) {

            // We'll assume out-of-disk-space for anything less
            // then MIN_DISK_SPACE.
            //
            if (((dwSpC * dwBpS) * dwNoF) <= MIN_DISK_SPACE) {

                DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : _inet_MemCheck : Out of disk space.")));

                SetLastError(ERROR_DISK_FULL);
            }
        }
#endif

        memFreeStr(lpszRoot);

    } else {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : _inet_MemCheck : Out of memory.")));

        SetLastError(ERROR_OUTOFMEMORY);
    }
}


/*****************************************************************************\
* Spl_OpnFile  (Local Routine)
*
* This routine creates/opens a spool-file.
*
\*****************************************************************************/
HANDLE spl_OpnFile(
    LPCTSTR lpszFile)
{
    HANDLE hFile;


    hFile = CreateFile(lpszFile,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);


    return ((hFile && (hFile != INVALID_HANDLE_VALUE)) ? hFile : NULL);
}


/*****************************************************************************\
* Spl_BldFile  (Local Routine)
*
* This routine builds a spool-file-name.
*
\*****************************************************************************/
LPTSTR spl_BldFile(
    DWORD idJob,
    DWORD dwType)
{
    DWORD  cbSize;
    LPTSTR lpszDir;
    LPTSTR lpszFile = NULL;

    static CONST TCHAR s_szFmt[] = TEXT("%s\\%s%05X.%s");
    static CONST TCHAR s_szSpl[] = TEXT("spl");
    static CONST TCHAR s_szTmp[] = TEXT("tmp");


    if (lpszDir = Spl_GetDir()) {


        cbSize = utlStrSize(lpszDir)    +
                 utlStrSize(g_szSplPfx) +
                 utlStrSize(s_szFmt)    +
                 80;

        if (lpszFile = (LPTSTR)memAlloc(cbSize)) {

            wsprintf(lpszFile,
                     s_szFmt,
                     lpszDir,
                     g_szSplPfx,
                     idJob,
                     (dwType == SPLFILE_TMP ? s_szTmp : s_szSpl));
        }

        memFreeStr(lpszDir);
    }

    return lpszFile;
}


/*****************************************************************************\
* SplLock
*
* Open a stream interface to the spool file
*
\*****************************************************************************/
CFileStream* SplLock(
    HANDLE hSpl)
{
    PSPLFILE pSpl;
    CFileStream *pStream = NULL;

    if (pSpl = (PSPLFILE)hSpl) {
        pStream = new CFileStream (pSpl->hFile);
        pSpl->pStream = pStream;
    }

    return pStream;
}


/*****************************************************************************\
* SplUnlock
*
* Close our file-mapping.
*
\*****************************************************************************/
BOOL SplUnlock(
    HANDLE hSpl)
{
    PSPLFILE pSpl;
    BOOL     bRet = FALSE;

    if (pSpl = (PSPLFILE)hSpl) {

        if (pSpl->pStream) {
            delete pSpl->pStream;

            pSpl->pStream = NULL;
        }
    }

    return bRet;
}


/*****************************************************************************\
* SplWrite
*
* Write data to our spool-file.
*
\*****************************************************************************/
BOOL SplWrite(
    HANDLE  hSpl,
    LPBYTE  lpData,
    DWORD   cbData,
    LPDWORD lpcbWr)
{
    PSPLFILE pSpl;
    BOOL     bRet = FALSE;
#ifdef WINNT32
    HANDLE   hToken = RevertToPrinterSelf();

    if (hToken) {
#endif

        if (pSpl = (PSPLFILE)hSpl) {

            // Write the data to our spool-file.
            //
            bRet = WriteFile(pSpl->hFile, lpData, cbData, lpcbWr, NULL);


            // If we failed, or our bytes written aren't what we
            // expected, then we need to check for out-of-memory.
            //
            if (!bRet || (cbData != *lpcbWr))
                Spl_MemCheck(pSpl->lpszFile);
        }

#ifdef WINNT32
        if (!ImpersonatePrinterClient(hToken))
        {
            bRet = FALSE;
        }
    }
#endif

    return bRet;
}

/*****************************************************************************\
* SplWrite
*
* Write data to our spool-file.
*
\*****************************************************************************/
BOOL SplWrite(
    HANDLE  hSpl,
    CStream *pStream)
{
    PSPLFILE pSpl;
    BOOL     bRet = FALSE;
    static   DWORD cbBufSize = 32 * 1024;    //Copy size is 32K
    PBYTE    pBuf;
    DWORD    cbTotal;

#ifdef WINNT32
    HANDLE   hToken = RevertToPrinterSelf();

    if (hToken) {
#endif

        if (pSpl = (PSPLFILE)hSpl) {

            pBuf = new BYTE[cbBufSize];

            if (pBuf && pStream->GetTotalSize (&cbTotal)) {

                DWORD cbRemain = cbTotal;

                while (cbRemain > 0 && bRet) {

                    DWORD cbToRead = cbRemain > cbBufSize? cbBufSize:cbRemain;
                    DWORD cbRead, cbWritten;

                    if (pStream->Read (pBuf, cbToRead, &cbRead) && cbToRead == cbRead) {

                        // Write the data to our spool-file.
                        //
                        bRet = WriteFile(pSpl->hFile, pBuf, cbRead, &cbWritten, NULL)
                               && cbWritten == cbRead;

                        if (bRet) {
                            cbRemain -= cbToRead;
                        }

                    }
                    else
                        bRet = FALSE;
                }

                // If we failed, or our bytes written aren't what we
                // expected, then we need to check for out-of-memory.
                //
                if (!bRet)
                    Spl_MemCheck(pSpl->lpszFile);

            }

            if (pBuf) {
                delete [] pBuf;
            }

        }

#ifdef WINNT32
        if (!ImpersonatePrinterClient(hToken))
        {
            bRet = FALSE;
        }
    }
#endif

    return bRet;
}

BOOL PrivateSplFree(
    HANDLE hSpl)
{
    BOOL     bRet = FALSE;
    PSPLFILE pSpl;

    if (pSpl = (PSPLFILE)hSpl) {

        if (pSpl->pStream)
            delete pSpl->pStream;

        if (pSpl->hFile)
            CloseHandle(pSpl->hFile);

        bRet = DeleteFile(pSpl->lpszFile);

        if (pSpl->lpszFile)
            memFreeStr(pSpl->lpszFile);

        memFree(pSpl, sizeof(SPLFILE));
    }
    return bRet;
}

/*****************************************************************************\
* SplFree  (Local Routine)
*
* Free our spool-file.  This will delete all information regarding the
* file.
*
\*****************************************************************************/
BOOL SplFree(
    HANDLE hSpl)
{
    PSPLFILE pSpl;
    BOOL     bRet = FALSE;
#ifdef WINNT32
    HANDLE   hToken = RevertToPrinterSelf();

    if (hToken) {
#endif
        bRet = PrivateSplFree (hSpl);

#ifdef WINNT32
        if (!ImpersonatePrinterClient(hToken))
        {
            bRet = FALSE;
        }
    }
#endif

    return bRet;
}

/*****************************************************************************\
* SplCreate (Local Routine)
*
* Create a unique file for processing our spool-file.
*
\*****************************************************************************/
HANDLE SplCreate(
    DWORD idJob,
    DWORD dwType)
{
    PSPLFILE pSpl = NULL;
#ifdef WINNT32
    HANDLE   hToken = RevertToPrinterSelf();

    if (hToken) {
#endif

        if (pSpl = (PSPLFILE) memAlloc(sizeof(SPLFILE))) {

            if (pSpl->lpszFile = spl_BldFile(idJob, dwType)) {

                if (pSpl->hFile = spl_OpnFile(pSpl->lpszFile)) {

                    pSpl->pStream = NULL;

                } else {

                    memFreeStr(pSpl->lpszFile);

                    goto SplFail;
                }

            } else {

    SplFail:
                memFree(pSpl, sizeof(SPLFILE));
                pSpl = NULL;
            }
        }

#ifdef WINNT32
        if (!ImpersonatePrinterClient(hToken))
        {
            (VOID)PrivateSplFree (pSpl);
            pSpl = NULL;
        }
    }
#endif

    return (HANDLE)pSpl;
}


/*****************************************************************************\
* SplOpen  (Local Routine)
*
* Open the handle to our spool-file.
*
\*****************************************************************************/
BOOL SplOpen(
    HANDLE hSpl)
{
    PSPLFILE pSpl;
    BOOL     bRet = FALSE;
#ifdef WINNT32
    HANDLE   hToken = RevertToPrinterSelf();

    if (hToken) {
#endif

        if (pSpl = (PSPLFILE)hSpl) {

            if (pSpl->hFile == NULL) {

                // Open the file and store it in the object.
                //
                pSpl->hFile = CreateFile(pSpl->lpszFile,
                                        GENERIC_READ | GENERIC_WRITE,
                                        0,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);

                if (!pSpl->hFile || (pSpl->hFile == INVALID_HANDLE_VALUE))
                    pSpl->hFile = NULL;
                else
                    bRet = TRUE;

            } else {

                // Already open.
                //
                bRet = TRUE;
            }
        }

#ifdef WINNT32
        if (!ImpersonatePrinterClient(hToken))
        {
            bRet = FALSE;
        }
    }
#endif

    return bRet;
}


/*****************************************************************************\
* SplClose
*
* Close the spool-file.
*
\*****************************************************************************/
BOOL SplClose(
    HANDLE hSpl)
{
    PSPLFILE pSpl;
    BOOL     bRet = FALSE;
#ifdef WINNT32
    HANDLE   hToken = RevertToPrinterSelf();

    if (hToken) {
#endif

        if (pSpl = (PSPLFILE)hSpl) {

            if (pSpl->hFile) {

                bRet = CloseHandle(pSpl->hFile);
                pSpl->hFile = NULL;

            } else {

                // Already closed.
                //
                bRet = TRUE;
            }
        }

#ifdef WINNT32
        if (!ImpersonatePrinterClient(hToken))
        {
            bRet = FALSE;
        }
    }
#endif

    return bRet;
}


/*****************************************************************************\
* SplClean
*
* Cleans out all spool-files in the spool-directory.
*
\*****************************************************************************/
VOID SplClean(VOID)
{
    LPTSTR          lpszDir;
    LPTSTR          lpszCur;
    LPTSTR          lpszFiles;
    HANDLE          hFind;
    DWORD           cbSize;
    WIN32_FIND_DATA wfd;

    static CONST TCHAR s_szFmt[] = TEXT("%s\\%s*.*");

    // Get the spool-directory where our splipp files reside.
    //
    if (lpszDir = Spl_GetDir()) {

        if (lpszCur = Spl_GetCurDir()) {

            cbSize = utlStrSize(lpszDir)    +
                     utlStrSize(g_szSplPfx) +
                     utlStrSize(s_szFmt);

            if (lpszFiles = (LPTSTR)memAlloc(cbSize)) {

                wsprintf(lpszFiles, s_szFmt, lpszDir, g_szSplPfx);

                if (SetCurrentDirectory(lpszDir)) {

                    // Delete all the files that pertain to our criteria.
                    //
                    hFind = FindFirstFile(lpszFiles, &wfd);

                    if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

                        do {

                            DeleteFile(wfd.cFileName);

                        } while (FindNextFile(hFind, &wfd));

                        FindClose(hFind);
                    }

                    SetCurrentDirectory(lpszCur);
                }

                memFreeStr(lpszFiles);
            }

            memFreeStr(lpszCur);
        }

        memFreeStr(lpszDir);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\splpjm.h ===
/*****************************************************************************\
* MODULE: splpjm.h
*
* Header file for the job-mapping list.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   13-Jan-1997 HWP-Guys    Created.
*
\*****************************************************************************/
#ifndef _SPLPJM_H
#define _SPLPJM_H

// Constants.
//
#define PJM_LOCALID  0  // pjmFind().
#define PJM_REMOTEID 1  // pjmFind().


#define PJM_SPOOLING 0x00000001
#define PJM_CANCEL   0x00000002
#define PJM_PAUSE    0x00000004
#define PJM_NOOPEN   0x00000008
#define PJM_ASYNCON  0x00000010

class CFileStream;
typedef class CInetMonPort* PCINETMONPORT;

// JobMap Structure.  This is used to track local/remote job-ids during
// the life of a print-job.  This is necessary with our IPP printing model
// since we would otherwise lose the remote job Id at enddoc time.
//
typedef struct _JOBMAP {

    struct _JOBMAP FAR *pNext;
    PCINETMONPORT      pIniPort;
    DWORD              dwState;
    DWORD              idJobLocal;
    DWORD              idJobRemote;
    LPTSTR             lpszUri;
    LPTSTR             lpszUser;
    LPTSTR             lpszDocName;
    DWORD              dwLocalJobSize;
    SYSTEMTIME         SubmitTime;
    DWORD              dwStatus;
    HANDLE             hSplFile;
    BOOL               bRemoteJob;
} JOBMAP;
typedef JOBMAP *PJOBMAP;
typedef JOBMAP *NPJOBMAP;
typedef JOBMAP *LPJOBMAP;


typedef struct _PPJOB_ENUM {

    DWORD  cItems;
    DWORD  cbSize;
    IPPJI2 ji2[1];

} PPJOB_ENUM;
typedef PPJOB_ENUM *PPPJOB_ENUM;
typedef PPJOB_ENUM *NPPPJOB_ENUM;
typedef PPJOB_ENUM *LPPPJOB_ENUM;


// JobMap Routines.
//
PJOBMAP pjmAdd(
    PJOBMAP*        pjmList,
    PCINETMONPORT   pIniPort,
    LPCTSTR         lpszUser,
    LPCTSTR         lpszDocName);

VOID pjmCleanRemoteFlag(
    PJOBMAP* pjmList);

PJOBMAP pjmFind(
    PJOBMAP* pjmList,
    DWORD    fType,
    DWORD    idJob);

DWORD pjmGetLocalJobCount(
    PJOBMAP* pjmList,
    DWORD*   pcbItems);

PJOBMAP pjmNextLocalJob(
    PJOBMAP*    pjmList,
    PJOB_INFO_2 pJobInfo2,
    PBOOL       pbFound);

VOID pjmDel(
    PJOBMAP *pjmList,
    PJOBMAP pjm);

VOID pjmDelList(
    PJOBMAP pjmList);

CFileStream* pjmSplLock(
    PJOBMAP pjm);

BOOL pjmSplUnlock(
    PJOBMAP pjm);

BOOL pjmSplWrite(
    PJOBMAP pjm,
    LPVOID  lpMem,
    DWORD   cbMem,
    LPDWORD lpcbWr);

BOOL pjmSetState(
    PJOBMAP pjm,
    DWORD   dwState);

VOID pjmClrState(
    PJOBMAP pjm,
    DWORD   dwState);

VOID pjmSetJobRemote(
    PJOBMAP pjm,
    DWORD   idJobRemote,
    LPCTSTR lpszUri);

VOID pjmAddJobSize(
    PJOBMAP pjm,
    DWORD   dwSize);

VOID pjmRemoveOldEntries(
    PJOBMAP      *pjmList);


VOID pjmUpdateLocalJobStatus(
    PJOBMAP pjm,
    DWORD   dwStatus);


/*****************************************************************************\
* pjmJobId
*
\*****************************************************************************/
_inline DWORD pjmJobId(
    PJOBMAP pjm,
    DWORD   fType)
{
    return (pjm ? ((fType == PJM_REMOTEID) ? pjm->idJobRemote : pjm->idJobLocal) : 0);
}

/*****************************************************************************\
* pjmSplFile
*
\*****************************************************************************/
_inline LPCTSTR pjmSplFile(
    PJOBMAP pjm)
{
    return (pjm ? SplFileName(pjm->hSplFile) : NULL);
}

/*****************************************************************************\
* pjmSplUser
*
\*****************************************************************************/
_inline LPCTSTR pjmSplUser(
    PJOBMAP pjm)
{
    return (pjm ? pjm->lpszUser : NULL);
}

/*****************************************************************************\
* pjmChkState
*
\*****************************************************************************/
_inline BOOL pjmChkState(
    PJOBMAP pjm,
    DWORD   dwState)
{
    return (pjm ? (pjm->dwState & dwState) : FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\stubs.h ===
/*****************************************************************************\
* MODULE: stubs.h
*
* Header module for stub routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
#ifndef _STUB_H
#define _STUB_H

HANDLE stubAddPrinter(
    LPTSTR pszName,
    DWORD  dwLevel,
    LPBYTE pbPrinter);

BOOL stubDeletePrinter(
    HANDLE hPrinter);

BOOL stubReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead);

DWORD stubGetPrinterData(
    HANDLE  hPrinter,
    LPTSTR  pszValueName,
    LPDWORD pType,
    LPBYTE  pbData,
    DWORD   dwSize,
    LPDWORD pcbNeeded);

DWORD stubSetPrinterData(
    HANDLE hPrinter,
    LPTSTR pszValueName,
    DWORD  dwType,
    LPBYTE pbData,
    DWORD  cbData);

DWORD stubWaitForPrinterChange(
    HANDLE hPrinter,
    DWORD  dwFlags);

BOOL stubAddPrinterConnection(
    LPTSTR pszName);

BOOL stubDeletePrinterConnection(
    LPTSTR pszName);

DWORD stubPrinterMessageBox(
    HANDLE hPrinter,
    DWORD  dwError,
    HWND   hWnd,
    LPTSTR pszText,
    LPTSTR pszCaption,
    DWORD  dwType);

BOOL stubAddPrinterDriver(
    LPTSTR pszName,
    DWORD  dwLevel,
    LPBYTE pbDriverInfo);

BOOL stubDeletePrinterDriver(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszDriverName);

BOOL stubGetPrinterDriver(
    HANDLE  hPrinter,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded);

BOOL stubEnumPrinterDrivers(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned);

BOOL stubGetPrinterDriverDirectory(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded);

BOOL stubAddPrintProcessor(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszPathName,
    LPTSTR pszPrintProcessorName);

BOOL stubDeletePrintProcessor(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszPrintProcessorName);

BOOL stubEnumPrintProcessors(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned);

BOOL stubGetPrintProcessorDirectory(
    LPTSTR  pszName,
    LPTSTR  pszEnvironment,
    DWORD   dwLevel,
    LPBYTE  pbPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded);

BOOL stubEnumPrintProcessorDatatypes(
    LPTSTR  pszName,
    LPTSTR  pszPrintProcessorName,
    DWORD   dwLevel,
    LPBYTE  pbDataypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned);

BOOL stubAddForm(
    HANDLE hPrinter,
    DWORD  Level,
    LPBYTE pForm);

BOOL stubDeleteForm(
    HANDLE hPrinter,
    LPTSTR pFormName);

BOOL stubGetForm(
    HANDLE  hPrinter,
    LPTSTR  pszFormName,
    DWORD   dwLevel,
    LPBYTE  pbForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded);

BOOL stubSetForm(
    HANDLE hPrinter,
    LPTSTR pszFormName,
    DWORD  dwLevel,
    LPBYTE pbForm);

BOOL stubEnumForms(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pbForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned);

BOOL stubAddMonitor(
    LPTSTR pszName,
    DWORD  dwLevel,
    LPBYTE pbMonitorInfo);

BOOL stubDeleteMonitor(
    LPTSTR pszName,
    LPTSTR pszEnvironment,
    LPTSTR pszMonitorName);

BOOL stubEnumMonitors(
    LPTSTR  pszName,
    DWORD   dwLevel,
    LPBYTE  pbMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned);

BOOL stubAddPort(
    LPTSTR  pName,
    HWND    hWnd,
    LPTSTR  pMonitorName);

BOOL stubDeletePort(
    LPTSTR  pName,
    HWND    hWnd,
    LPTSTR  pPortName);

BOOL stubConfigurePort(
    LPTSTR lpszServerName,
    HWND   hWnd,
    LPTSTR lpszPortName);

HANDLE stubCreatePrinterIC(
    HANDLE     hPrinter,
    LPDEVMODEW pDevMode);

BOOL stubPlayGdiScriptOnPrinterIC(
    HANDLE hPrinterIC,
    LPBYTE pbIn,
    DWORD  cIn,
    LPBYTE pbOut,
    DWORD  cOut,
    DWORD  ul);

BOOL stubDeletePrinterIC(
    HANDLE hPrinterIC);




BOOL stubResetPrinter(
    LPPRINTER_DEFAULTS lpDefault);

BOOL stubGetPrinterDriverEx(
    LPTSTR  lpEnvironment,
    DWORD   dwLevel,
    LPBYTE  lpbDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    DWORD   dwClientMajorVer,
    DWORD   dwClientMinorVer,
    PDWORD  pdwServerMajorVer,
    PDWORD  pdwServerMinorVer);

BOOL stubFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD  dwFlags,
    DWORD  dwOptions,
    HANDLE hNotify,
    PDWORD pdwStatus,
    PVOID  pPrinterNofityOptions,
    PVOID  pPrinterNotifyInit);

BOOL stubFindClosePrinterChangeNotification(
    HANDLE hPrinter);

#ifdef NOT_IMPLEMENTED
// These functions are defined in the PRINTPROVIDER structure, but
// do not have cooresponding entries in this table.
//
// It appears to be OK to not have these defined for this provider.  I
// would leave them out since the spooler will attempt to make some of
// these calls first and this could cause the print-jobs to fail.
//
// 08-Oct-1996 : ChrisWil

BOOL stubAddPortEx(
    LPTSTR lpszName,
    DWORD  dwLevel,
    LPBYTE lpbBuffer,
    LPTSTR lpszMonitorName);

BOOL stubShutDown(
    LPVOID lpvReserved);

BOOL stubRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD  dwReserved,
    PVOID  pvReserved,
    PVOID  pvPrinterNotifyInfo);

BOOL stubOpenPrinterEx(
    LPTSTR             lpszPrinterName,
    LPHANDLE           phPrinter,
    LPPRINTER_DEFAULTS pDefault,
    LPBYTE             lpbClientInfo,
    DWORD              dwLevel);

HANDLE stubAddPrinterEx(
    LPTSTR lpszName,
    DWORD  dwLevel,
    LPBYTE lpbPrinter,
    LPBYTE lpbClientInfo,
    DWORD  dwClientInfoLevel);

BOOL stubSetPort(
    LPTSTR lpszName,
    LPTSTR lpszPortName,
    DWORD  dwLevel,
    LPBYTE lpbPortInfo);

DWORD stubEnumPrinterData(
    HANDLE  hPrinter,
    DWORD   dwIndex,
    LPTSTR  lpszValueName,
    DWORD   cbValueName,
    LPDWORD pcbValueName,
    LPDWORD pdwType,
    LPBYTE  lpbData,
    DWORD   cbData,
    LPDWORD lpcbData);

DWORD stubDeletePrinterData(
    HANDLE  hPrinter,
    LPTSTR  lpszValueName);

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\userdata.cxx ===
/*****************************************************************************\
* MODULE: userdata.cxx
*
* The module contains class for user credentials
*
* Copyright (C) 1997-1998 Microsoft Corporation
*
* History:
*   08/28/98    Weihaic     Created
*
\*****************************************************************************/
#include "precomp.h"

#ifdef WINNT32

#include "priv.h"

CUserData::CUserData ():
    m_pSid(NULL),
    m_bValid(FALSE)
    {
    m_bValid = _GetSid ();
}

CUserData::~CUserData ()
{
    LocalFree (m_pSid);
}

int
CUserData::Compare (
    CUserData * second)
{

    if (m_bValid && second->m_bValid) {
        return RtlEqualSid( m_pSid , second->m_pSid) == FALSE;
    }
    else {
        return TRUE;
    }
}

CUserData &
CUserData::operator= (const CUserData &rhs)
{
    ULONG  ulSidLen;
    DWORD  dwStatus;

    if (this == &rhs) {
        return *this;
    }

    LocalFree (m_pSid);

    m_pSid    = NULL;
    m_bValid = FALSE;

    if (!rhs.m_bValid) 
        goto Cleanup;

    ulSidLen = RtlLengthSid( rhs.m_pSid );

    m_pSid = LocalAlloc( LPTR, ulSidLen );

    if (NULL == m_pSid) 
        goto Cleanup;

    dwStatus = RtlCopySid( ulSidLen, m_pSid, rhs.m_pSid );

    if (NT_ERROR(dwStatus)) {
        LocalFree(m_pSid);
        m_pSid = NULL;
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Cleanup;
    }

    m_bValid = TRUE;

Cleanup:

    return *this;
}

BOOL
CUserData::_GetUserToken (
    PTOKEN_USER &TokenUserInfo)
{
    DWORD                ReturnStatus = 0;
    HANDLE               ClientToken  = NULL;
    BOOL                 bRet         = FALSE;
    ULONG                uSize        = 0;

    //
    // Compare the username specified with that in
    // the impersonation token to ensure the caller isn't bogus.
    //
    // Do this by opening the token,
    //   querying the token user info,
    //   and ensuring the returned SID is for this user.
    //

    TokenUserInfo = NULL;

    if (!OpenThreadToken(
            GetCurrentThread(),         // current thread handle
            TOKEN_QUERY,                // access required
            FALSE,                      // open as self
            &ClientToken)) {            // client token
        ReturnStatus = GetLastError();
        DBG_ASSERT( ReturnStatus , (TEXT("Err : OpenThreadToken: Failed but the lasterror = 0")));
        goto Cleanup;
    }

    //
    // Get the size of user's SID for the token.
    //

    ReturnStatus = NtQueryInformationToken(
            ClientToken,
            TokenUser,
            NULL,
            uSize,
            &uSize);

    if (!NT_ERROR (ReturnStatus) ||
         ReturnStatus != STATUS_BUFFER_TOO_SMALL) {

        // We expected to be told how big a buffer we needed and we weren't
        SetLastError (ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    //
    // Allocate the user's SID
    //

    TokenUserInfo = (PTOKEN_USER) LocalAlloc (LPTR, uSize);

    if (TokenUserInfo == NULL) 
        goto Cleanup;

    ReturnStatus = NtQueryInformationToken(
            ClientToken,
            TokenUser,
            TokenUserInfo,
            uSize,
            &uSize);

    if (NT_ERROR (ReturnStatus) ) {

        // Faild after the allocation
        LocalFree( TokenUserInfo );
        TokenUserInfo = NULL;
        SetLastError (ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }
        
    //
    // Done
    //
    bRet = TRUE;

Cleanup:

    CloseHandle(ClientToken);

    return bRet;
}

BOOL
CUserData::_GetSid (VOID)
{
    BOOL         bRet = FALSE;
    PTOKEN_USER  pUser;
    ULONG        ulSidLen;
    DWORD        dwStatus;

    if (!_GetUserToken(pUser))
        goto Cleanup;
    // Now find the Sid size and copy it locally, free the pUser when done.

    ulSidLen = RtlLengthSid(pUser->User.Sid);

    m_pSid = LocalAlloc( LPTR, ulSidLen );

    if (NULL == m_pSid) 
        goto Cleanup;

    dwStatus = RtlCopySid( ulSidLen, m_pSid, pUser->User.Sid );

    if (NT_ERROR(dwStatus)) {
        LocalFree(m_pSid);
        m_pSid = NULL;
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Cleanup;
    }
    
    bRet = TRUE; 

Cleanup: 

    if (pUser) 
        LocalFree(pUser);

    return bRet;
}


BOOL operator== (
    const CUserData &lhs,
    const CUserData &rhs)
{

    if (lhs.m_bValid && rhs.m_bValid) {
        return RtlEqualSid(lhs.m_pSid , rhs.m_pSid );
    }
    else {
        return FALSE;
    }
}


BOOL operator!= (
    const CUserData &lhs,
    const CUserData &rhs)
{
    return ! (lhs == rhs);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\xcv.cxx ===
/*****************************************************************************\
* MODULE: xcv.cxx
*
* The module contains routines for handling the authentication dialog
* for internet priting
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*   03/31/00  WeihaiC     Created
*
\*****************************************************************************/

#include "precomp.h"

#ifdef WINNT32
#include "priv.h"

#define SZINETPPUI  L"InetppUI.dll"


XCV_METHOD  gpXcvMethod[] = {
                            {L"MonitorUI", GetMonitorUI},
                            {L"AddPort", DoAddPort},
                            {INET_XCV_DELETE_PORT, DoDeletePort},
                            {INET_XCV_GET_CONFIGURATION,    DoGetConfiguration},
                            {INET_XCV_SET_CONFIGURATION,    DoSetConfiguration},
                            {NULL, NULL}
                            };

BOOL
bIsAdmin ()
{
    PRINTER_DEFAULTS pd = {NULL, NULL,  SERVER_ALL_ACCESS};
    HANDLE hServer;
    BOOL bRet = FALSE;

    if (OpenPrinter (NULL, &hServer, &pd)) {
        bRet = TRUE;

        ClosePrinter (hServer);
    }

    return bRet;
}


DWORD
XcvDataPort(
    PCINETMONPORT pPort,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    )
{
    DWORD dwRet;
    DWORD i;

    for(i = 0 ; gpXcvMethod[i].pszMethod &&
                wcscmp(gpXcvMethod[i].pszMethod, pszDataName) ; ++i)
        ;

    if (gpXcvMethod[i].pszMethod) {
        dwRet = (*gpXcvMethod[i].pfn)(  pInputData,
                                        cbInputData,
                                        pOutputData,
                                        cbOutputData,
                                        pcbOutputNeeded,
                                        pPort);

    } else {
        dwRet = ERROR_INVALID_PARAMETER;
    }

    return dwRet;
}

BOOL
PPXcvData(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus)
{
    HANDLE hPort;
    LPTSTR pszPortName;


    //
    // Valid input parameters
    //

    if (!pszDataName || IsBadStringPtr (pszDataName, MAX_INET_XCV_NAME_LEN) ||
        IsBadWritePtr (pdwStatus, sizeof (DWORD))) {
        return  ERROR_INVALID_PARAMETER;
    }

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPXcvData: Name(%s)"), pszDataName));

    semEnterCrit();

    if (pszPortName = utlValidateXcvPrinterHandle(hXcv)) {

        if (hPort = gpInetMon->InetmonFindPort (pszPortName)) {

            *pdwStatus = XcvDataPort((PCINETMONPORT) hPort, pszDataName, pInputData, cbInputData,
                                     pOutputData, cbOutputData, pcbOutputNeeded);
        }
        else {

            //
            // The port may not exit or  have been deleted.
            //
            *pdwStatus = ERROR_NOT_FOUND;
        }
    }
    else
        *pdwStatus = ERROR_INVALID_HANDLE;


    semLeaveCrit();

    DBG_MSG(DBG_LEV_CALLTREE, (TEXT("Call: PPXcvData : Return Value(%d), LastError(%d)"), *pdwStatus, GetLastError()));

    return TRUE;
}

DWORD ValidateInputParameters (
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    CONST DWORD cdwInputDataRequired,
    CONST DWORD cdwOutputDataRequired)
{
    if (!pInputData || !pcbOutputNeeded ||
        (cdwInputDataRequired > 0 && cbInputData != cdwInputDataRequired) ||
        IsBadReadPtr (pInputData, cbInputData) ||

        (pOutputData && cbOutputData && IsBadWritePtr (pOutputData, cbOutputData)) ||
        (pcbOutputNeeded && IsBadWritePtr (pcbOutputNeeded, sizeof (DWORD)))) {

        return  ERROR_INVALID_PARAMETER;
    }

    if (cbOutputData < cdwOutputDataRequired) {
        *pcbOutputNeeded = cdwOutputDataRequired;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    return ERROR_SUCCESS;
}

DWORD
DoGetConfiguration(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
)
{
    PINET_XCV_GETCONFIGURATION_REQ_DATA pReqData = (PINET_XCV_GETCONFIGURATION_REQ_DATA) pInputData;
    PBYTE pEncryptedData = NULL;
    DWORD dwEncryptedDataSize;
    DWORD dwRet;

    //
    // Valid input parameters
    //

    dwRet = ValidateInputParameters (pInputData,
                                     cbInputData,
                                     pOutputData,
                                     cbOutputData,
                                     pcbOutputNeeded,
                                     sizeof (INET_XCV_GETCONFIGURATION_REQ_DATA),
                                     0);

    if (dwRet != ERROR_SUCCESS) {
        return dwRet;
    }

    if (pReqData->dwVersion != 1) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get Current Configuration
    //

    INET_XCV_CONFIGURATION ConfigData;

    if (pPort->GetCurrentConfiguration (&ConfigData)) {

        if (EncryptData ((PBYTE) &ConfigData, sizeof (INET_XCV_CONFIGURATION),  &pEncryptedData,  &dwEncryptedDataSize)) {

            if (cbOutputData < dwEncryptedDataSize) {
                *pcbOutputNeeded = dwEncryptedDataSize;
                dwRet = ERROR_INSUFFICIENT_BUFFER;
            }
            else {
                CopyMemory (pOutputData, pEncryptedData, dwEncryptedDataSize);
                *pcbOutputNeeded = dwEncryptedDataSize;
                dwRet = ERROR_SUCCESS;
            }

            LocalFree (pEncryptedData);
        }
        else
            dwRet = GetLastError ();
    }
    else
        dwRet = GetLastError ();

    return dwRet;
}

DWORD
DoSetConfiguration(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
)
{

    PINET_XCV_CONFIGURATION pReqData;
    DWORD dwRet;
    PBYTE pDecryptedData;
    DWORD dwDecryptedDataSize;


    if (DecryptData (pInputData, cbInputData,  &pDecryptedData,  &dwDecryptedDataSize)) {


        //
        // Valid input parameters
        //
        dwRet = ValidateInputParameters (pDecryptedData,
                                         dwDecryptedDataSize,
                                         pOutputData,
                                         cbOutputData,
                                         pcbOutputNeeded,
                                         sizeof (INET_XCV_CONFIGURATION),
                                         sizeof (INET_CONFIGUREPORT_RESPDATA));
        if (dwRet == ERROR_SUCCESS) {

            pReqData = (PINET_XCV_CONFIGURATION) pDecryptedData;

            if (pReqData->dwVersion != 1) {
                dwRet = ERROR_INVALID_PARAMETER;
            }
            else if (pReqData->bSettingForAll && !bIsAdmin ()) {
                //
                // If the setting is for per-port, but the caller is not an admin
                //
                dwRet = ERROR_ACCESS_DENIED;
            }
            else {

                //
                // We need to leave critical section before changing configurations,
                // before leaving critical section, we need to increase the ref count
                // so that other people won't delete it
                //

                semSafeLeaveCrit (pPort);

                //
                // Get Current Configuration
                //
                if (pPort->ConfigurePort (pReqData,
                                          (PINET_CONFIGUREPORT_RESPDATA) pOutputData,
                                          cbOutputData,
                                          pcbOutputNeeded))
                    dwRet = ERROR_SUCCESS;
                else
                    dwRet = GetLastError ();

                semSafeEnterCrit (pPort);


            }
        }

        LocalFree (pDecryptedData);
    }
    else
        dwRet = GetLastError ();

    return dwRet;
}

DWORD
DoDeletePort(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
)
{
    DWORD dwRet = ERROR_SUCCESS;

    DWORD cbNeeded, dwStatus;
    BOOL bRet = FALSE;

    dwRet = ValidateInputParameters (pInputData,
                                     cbInputData,
                                     pOutputData,
                                     cbOutputData,
                                     pcbOutputNeeded,
                                     0,
                                     0);

    if (dwRet != ERROR_SUCCESS) {
        return dwRet;
    }

    if (IsBadStringPtr ((LPWSTR) pInputData, cbInputData / sizeof (WCHAR)))
        return ERROR_INVALID_PARAMETER;


    if (bIsAdmin ()) {

        if (!PPDeletePort (NULL, NULL, (LPWSTR) pInputData)) {
             dwRet = GetLastError ();
        }

    }
    else
        dwRet = ERROR_ACCESS_DENIED;


    return dwRet;
}


DWORD
DoAddPort(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PCINETMONPORT pPort
)
{
    //
    // We don't support AddPort
    //

    return ERROR_ACCESS_DENIED;

}

DWORD
GetMonitorUI(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
)
{
    DWORD dwRet;

    *pcbOutputNeeded = sizeof( SZINETPPUI );

    if (cbOutputData < *pcbOutputNeeded) {

        dwRet =  ERROR_INSUFFICIENT_BUFFER;

    } else {

        wcscpy((PWSTR) pOutputData, SZINETPPUI);
        dwRet = ERROR_SUCCESS;
    }

    return dwRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\util.cxx ===
/*****************************************************************************\
* MODULE: util.c
*
* This module contains utility routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/
#include "precomp.h"
#include "priv.h"

#ifdef NOT_IMPLEMENTED

// NOTE: The shell-extensions don't seem to be necessary at the moment.
//
//       15-Oct-1996 : ChrisWil
//

int APIENTRY ShexDllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpReserved);

#endif

/*****************************************************************************\
* utlInternalValidatePrinterHandle
*
* Returns the port-handle if the specified printer-handle is a valid.
*
\*****************************************************************************/
PCINETMONPORT utlInternalValidatePrinterHandle(
    HANDLE hPrinter,
    BOOL bAllowDeletePending,
    PBOOL pbDeletePending)
{
    LPINET_HPRINTER pPrt;
    PCINETMONPORT     pIniPort = NULL;

    if (pbDeletePending)
        *pbDeletePending = FALSE;

    _try {

        if ((pPrt = (LPINET_HPRINTER)hPrinter)) {

            if ((pPrt->dwSignature == IPO_SIGNATURE) &&
                !(pPrt->dwStatus & PP_ZOMBIE)) {

                pIniPort = (PCINETMONPORT) pPrt->hPort;

                if (pbDeletePending) {
                    *pbDeletePending = pIniPort->bDeletePending();
                }

                if (!bAllowDeletePending) {
                    if (pIniPort->bDeletePending()) {
                        pIniPort = NULL;

                    }
                }
            }
        }

    } _except(1) {

        pIniPort = NULL;
    }

    if (pIniPort == NULL) {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("Call: utlValidatePrinterHandle: Invalid Handle: Handle(%08lX)"), hPrinter));
        SetLastError(ERROR_INVALID_HANDLE);
    }

    return pIniPort;
}

/*****************************************************************************\
* utlValidatePrinterHandle
*
* Returns the port-handle if the specified printer-handle is a valid.
*
\*****************************************************************************/
PCINETMONPORT utlValidatePrinterHandle(
    HANDLE hPrinter)
{
    return utlInternalValidatePrinterHandle (hPrinter, FALSE, NULL);
}

/*****************************************************************************\
* utlValidatePrinterHandleForClose
*
* Returns the port-handle if the specified printer-handle is a valid.
*
\*****************************************************************************/
PCINETMONPORT utlValidatePrinterHandleForClose(
    HANDLE hPrinter,
    PBOOL pbDeletePending)
{
    return utlInternalValidatePrinterHandle (hPrinter, TRUE, pbDeletePending);
}


#ifdef WINNT32
/*****************************************************************************\
* utlValidateXcvPrinterHandle
*
* Returns the port-handle if the specified printer-handle is a valid.
*
\*****************************************************************************/
LPTSTR utlValidateXcvPrinterHandle(
    HANDLE hPrinter)
{
    LPINET_XCV_HPRINTER pPrt;
    LPTSTR          lpszPortName = NULL;


    _try {

        if ((pPrt = (LPINET_XCV_HPRINTER)hPrinter)) {

            if ((pPrt->dwSignature == IPO_XCV_SIGNATURE)) {

                lpszPortName = pPrt->lpszName;
            }
        }

    } _except(1) {

        lpszPortName = NULL;
    }

    if (lpszPortName == NULL) {

        DBG_MSG(DBG_LEV_ERROR, (TEXT("Call: utlValidateXcvPrinterHandle: Invalid Handle: Handle(%08lX)"), hPrinter));
        SetLastError(ERROR_INVALID_HANDLE);
    }

    return lpszPortName;
}
#endif


/********************************************************************************

Name:
    EncodeUnicodePrinterName

Description:

    Encode the printer name to avoid special characters, also encode any chars
    with ASC code between 0x80 and 0xffff. This is to avoid the conversion betwwen
    different codepages when the client  and the server have different language
    packages.

    The difference between this function and EncodePrinterName in Spllib is that
    this function does not encode ' ', '$' and other special ANSI characters.

Arguments:

    lpText:     the normal text string
    lpHTMLStr:  the buf provided by the caller to store the encoded string
                if it is NULL, the function will return a FALSE
    lpdwSize:   Pointer to the size of the buffer (in characters)

Return Value:

    If the function succeeds, the return value is TRUE;
    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.

********************************************************************************/
BOOL EncodeUnicodePrinterName (LPCTSTR lpText, LPTSTR lpHTMLStr, LPDWORD lpdwSize)
{
#define MAXLEN_PER_CHAR 6
#define BIN2ASC(bCode,lpHTMLStr)   *lpHTMLStr++ = HexToAsc ((bCode) >> 4);\
                                   *lpHTMLStr++ = HexToAsc ((bCode) & 0xf)

    DWORD   dwLen;
    BYTE    bCode;

    if (!lpText || !lpdwSize) {
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    dwLen = MAXLEN_PER_CHAR * lstrlen (lpText) + 1;

    if (!lpHTMLStr || *lpdwSize < dwLen) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        *lpdwSize = dwLen;
        return FALSE;
    }

    while (*lpText) {
        if ((DWORD) (*lpText) > 0xff ) {
            // Encode as ~0hhll hh is the high byte, ll is the low byte
            *lpHTMLStr++ = TEXT ('~');
            *lpHTMLStr++ = TEXT ('0');

            // Get the high byte
            bCode = (*lpText & 0xff00) >> 8;
            BIN2ASC(bCode,lpHTMLStr);

            // Get the low byte
            bCode = (*lpText & 0xff);
            BIN2ASC(bCode,lpHTMLStr);
        }
        else if ((DWORD) (*lpText) > 0x7f) {
            // Encode as ~xx
            *lpHTMLStr++ = TEXT ('~');
            bCode = *lpText & 0xff;
            BIN2ASC(bCode,lpHTMLStr);
        }
        else {
            *lpHTMLStr++ = *lpText;
        }
        lpText++;
    }
    *lpHTMLStr = NULL;
    return TRUE;
}

/*****************************************************************************\
* utlParseHostShare
*
* Parses the PortName (http://host[:port][/][/share]) into its
* post/Share/Port components.
*
* We accept six formats
*   1. http://server
*   2. http://server:port
*   3. http://server/
*   4. http://server:port/
*   5. http://server/share
*   6. http://server:port/share
*
* This routine returns allocated pointers that must be freed by the caller.
*
\*****************************************************************************/
BOOL utlParseHostShare(
    LPCTSTR lpszPortName,
    LPTSTR  *lpszHost,
    LPTSTR  *lpszShare,
    LPINTERNET_PORT  lpPort,
    LPBOOL  lpbHTTPS)
{
    LPTSTR lpszPrt;
    LPTSTR lpszTmp;
    LPTSTR lpszPos;
    BOOL   bRet = FALSE;


    // Initialize the return buffers to NULL.
    //
    *lpszHost  = NULL;
    *lpszShare = NULL;
    *lpPort    = 0;

    // Parse the host-name and the share name.  The pszPortName is
    // currently in the format of http://host[:portnumber]/share.  We will parse
    // this from left->right since the share-name can be a path (we
    // wouldn't really know the exact length).  However, we do know the
    // location for the host-name, and anything after that should be
    // the share-name.
    //
    // First find the ':'.  The host-name should begin two "//" after
    // that.
    //
    if (lpszPrt = memAllocStr(lpszPortName)) {
        static TCHAR szHttp[] = TEXT ("http://");
        static TCHAR szHttps[] = TEXT ("https://");

        lpszTmp = NULL;

        if (!_tcsnicmp (lpszPrt, szHttp, COUNTOF (szHttp) - 1)) {
            lpszTmp = lpszPrt + COUNTOF (szHttp) - 1;
            *lpbHTTPS = FALSE;
        }
        else if (!_tcsnicmp (lpszPrt, szHttps, COUNTOF (szHttps) - 1)) {
            lpszTmp = lpszPrt + COUNTOF (szHttps) - 1;
            *lpbHTTPS = TRUE;
        }

        if (lpszTmp) {

            lpszPos = utlStrChr(lpszTmp, TEXT(':'));
            if (lpszPos) {
                //This url has a port number, we need to parse it
                *lpszPos++ = 0;

                *lpszHost = memAllocStr(lpszTmp);
                *lpPort   = (INTERNET_PORT) _ttol (lpszPos);
                lpszTmp = lpszPos;

                if (lpszPos = utlStrChr(lpszTmp, TEXT('/'))) {
                    *lpszShare = memAllocStr(++lpszPos);
                }
                else {
                    *lpszShare = memAllocStr(TEXT (""));
                }
            }
            else {
                // Use the default port number: 80

                if (lpszPos = utlStrChr(lpszTmp, TEXT('/'))) {
                    *lpszPos++ = TEXT('\0');

                    *lpszHost  = memAllocStr(lpszTmp);
                    *lpszShare = memAllocStr(lpszPos);
                }
                else {
                    // The whole thing is a host name
                    *lpszHost  = memAllocStr(lpszTmp);
                    *lpszShare = memAllocStr(TEXT (""));

                }
            }

#ifdef WINNT32

            if (*lpszShare) {

                //
                // Let's check if we need to encode the share name
                //

                INT iMode = IS_TEXT_UNICODE_ASCII16;

                if (IsTextUnicode ((LPVOID) *lpszShare, lstrlen (*lpszShare) * sizeof (WCHAR), &iMode) == 0) {

                    // The text string is a unicode string contains non-ASCII characters
                    // We need to encode the URL into ansi strings

                    DWORD dwSize;
                    BOOL bConversion = FALSE;
                    LPWSTR pszEncodedName = NULL;

                    EncodeUnicodePrinterName (*lpszShare, NULL, &dwSize);

                    if ((pszEncodedName = (LPWSTR) memAlloc (sizeof (WCHAR) * dwSize))) {

                        if (EncodeUnicodePrinterName (*lpszShare, pszEncodedName, &dwSize)) {
                            memFreeStr (*lpszShare);
                            *lpszShare = pszEncodedName;
                            bConversion = TRUE;
                        }
                    }

                    if (!bConversion) {
                        memFreeStr (pszEncodedName);
                        memFreeStr (*lpszShare);
                        *lpszShare = NULL;
                    }
                }
            }
#endif

            if (*lpszHost && *lpszShare) {

                bRet = TRUE;

            } else {

                // Don't worry that we could be freeing a NULL pointer.
                // The mem-routines check this.
                //
                memFreeStr(*lpszHost);
                memFreeStr(*lpszShare);

                *lpszHost  = NULL;
                *lpszShare = NULL;
            }
        }

        memFreeStr(lpszPrt);
    }

    return bRet;
}


/*****************************************************************************\
* utlStrChr
*
* Looks for the first location where (c) resides.
*
\*****************************************************************************/
LPTSTR utlStrChr(
    LPCTSTR cs,
    TCHAR   c)
{
    while (*cs != TEXT('\0')) {

        if (*cs == c)
            return (LPTSTR)cs;

        cs++;
    }

    // Fail to find c in cs.
    //
    return NULL;
}


/*****************************************************************************\
* utlStrChrR
*
* Looks for first occurrence of (c) starting from the end of the buffer.
*
\*****************************************************************************/
LPTSTR utlStrChrR(
    LPCTSTR cs,
    TCHAR   c)
{
    LPTSTR ct;

    ct = (LPTSTR)cs + (lstrlen(cs) - 1);

    while (ct >= cs) {

        if (*ct == c)
            return ct;

        ct--;
    }

    // Fail to find c in cs.
    //
    return NULL;
}


/*****************************************************************************\
* utlPackStrings
*
*
\*****************************************************************************/
LPBYTE utlPackStrings(
   LPTSTR  *pSource,
   LPBYTE  pDest,
   LPDWORD pDestOffsets,
   LPBYTE  pEnd)
{
    while (*pDestOffsets != (DWORD)-1) {

        if (*pSource) {

            pEnd -= (lstrlen(*pSource) * sizeof(TCHAR)) + sizeof(TCHAR);

            *(LPTSTR *)(pDest + *pDestOffsets) = lstrcpy((LPTSTR)pEnd, *pSource);

        } else {

            *(LPTSTR *)(pDest + *pDestOffsets) = TEXT('\0');
        }

        pSource++;
        pDestOffsets++;
    }

    return pEnd;
}


/*****************************************************************************\
* utlStrSize
*
* Returns the number of bytes needed to store a string including the NULL
* terminator.
*
\*****************************************************************************/
int utlStrSize(
    LPCTSTR lpszStr)
{
    return (lpszStr ? ((lstrlen(lpszStr) + 1) * sizeof(TCHAR)) : 0);
}

/*****************************************************************************\
* utlRegGetVal
*
* Retrieves the registry-value for the specified key.
*
\*****************************************************************************/
LPTSTR utlRegGetVal(
    HKEY    hKey,
    LPCTSTR lpszKey)
{
    DWORD  dwType;
    DWORD  cbSize;
    LONG   lRet;
    LPTSTR lpszStr;


    dwType = 0;
    cbSize = 0;

    lRet = RegQueryValueEx(hKey, lpszKey, NULL, &dwType, NULL, &cbSize);

    if (lRet == ERROR_SUCCESS && cbSize > 0) {

        if (lpszStr = (LPTSTR)memAlloc(cbSize)) {

            lRet = RegQueryValueEx(hKey, lpszKey, NULL, &dwType, (LPBYTE)lpszStr, &cbSize);

            if (lRet == ERROR_SUCCESS)
                return lpszStr;

            memFreeStr(lpszStr);
        }
    }

    return NULL;
}



#ifdef WINNT32

/*++

Routine Description

    Determines whether or not a machine name contains the local machine name.

    Localspl enum calls fail if pName != local machine name (\\Machine).
    Remote enum provider is then called.  The remote enum provider must check
    if the UNC name refers to the local machine, and fail if it does to avoid
    endless recursion.

Arguments:

    LPWSTR pName - UNC name.

Return Value:

    TRUE:   pName == \\szMachineName\...
                  - or -
            pName == \\szMachineName

    FALSE:  anything else

Author: swilson

 --*/

BOOL
MyUNCName(
    LPTSTR   pNameStart
)
{
    LPTSTR pMachine = g_szMachine;
    LPTSTR pName;
    DWORD i;

    if (!pNameStart || !*pNameStart)      // This differs from MyName(), which returns TRUE
        return FALSE;

    if (*pNameStart == L'\\' && *(pNameStart + 1) == L'\\') {
        for (i = 0 , pName = pNameStart + 2 ; i < g_cOtherNames ; ++i , pName = pNameStart + 2) {
            for(pMachine = g_ppszOtherNames[i] ;
                *pName && towupper(*pName) == towupper(*pMachine) ;
                ++pName, ++pMachine)
                ;

            if(!*pMachine && (!*pName || *pName == L'\\'))
                return TRUE;
        }
    }

    return FALSE;
}

BOOL MyName(
    LPCTSTR pName)
{
    DWORD   dwIndex = 0;

    if (!pName || !*pName)
        return TRUE;

    if (*pName == L'\\' && *(pName+1) == L'\\') {

        if (!lstrcmpi(pName, g_szMachine))
            return TRUE;

        while ( dwIndex < g_cOtherNames ) {

            if ( !lstrcmpi(pName+2, g_ppszOtherNames[dwIndex]) )
                return TRUE;
            ++dwIndex;
        }
    }


    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}
#endif

BOOL MyServer(
    LPCTSTR pName)
{
    DWORD   dwIndex = 0;

    if (!pName || !*pName)
        return FALSE;

    if (!lstrcmpi(pName, g_szMachine))
        return TRUE;

    if (!lstrcmpi(pName, TEXT ("localhost")))
        return TRUE;

#ifdef WINNT32
    while ( dwIndex < g_cOtherNames ) {

        if ( !lstrcmpi(pName, g_ppszOtherNames[dwIndex]) )
            return TRUE;
        ++dwIndex;
    }
#endif

    SetLastError( ERROR_INVALID_NAME );
    return FALSE;
}

/*****************************************************************************\
* GetUserName
*
* Retrieves the username for the current logged on thread.
*
\*****************************************************************************/
LPTSTR
GetUserName(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszUser;


    // Initialize the count and retrieve the number of characters
    // necessary for the username.
    //
    cbSize = 0;
    GetUserName(NULL, &cbSize);


    // If we were not able to retrieve a valid-count, then allocate
    // an empty string to return from this call.
    //
    if (cbSize) {

        if (lpszUser = (LPTSTR)memAlloc(cbSize * sizeof(TCHAR))) {

            if (GetUserName(lpszUser, &cbSize) == FALSE) {

                *lpszUser = TEXT('\0');

                goto log_error;
            }

        } else {

            DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : GetUserName : Out of memory")));
        }

    } else {

        lpszUser = memAllocStr(TEXT("Unknown"));

log_error:

        DBG_MSG(DBG_LEV_ERROR, (TEXT("Err : GetUserName Failed %d"), GetLastError()));
        SetLastError(ERROR_OUTOFMEMORY);
    }

    return lpszUser;
}

VOID
EndBrowserSession (
    VOID)
{
    g_pcsEndBrowserSessionLock->Lock();

    InetInternetSetOption(NULL, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0);

    g_pcsEndBrowserSessionLock->Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\xcv.h ===
/*****************************************************************************\
* MODULE: authdlg.cxx
*
* The module contains routines for handling the authentication dialog
* for internet priting
*
* Copyright (C) 2000 Microsoft Corporation
*
* History:
*   03/31/00  WeihaiC     Created
*
\*****************************************************************************/
#ifndef _INETPPXCV_H
#define _INETPPXCV_H


DWORD
GetMonitorUI(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PCINETMONPORT pPort
);

DWORD
DoDeletePort(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
);

DWORD
DoGetConfiguration(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
);

DWORD
DoSetConfiguration(
    PBYTE  pInputData,
    DWORD  cbInputData,
    PBYTE  pOutputData,
    DWORD  cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
);

DWORD
DoAddPort(
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort
);
              
typedef DWORD   (*PFN_XCV_PROTO_TYPE)( 
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD pcbOutputNeeded,
    PCINETMONPORT pPort);

typedef struct {
    PWSTR pszMethod;
    PFN_XCV_PROTO_TYPE pfn;
} XCV_METHOD, *PXCV_METHOD;


DWORD
XcvDataPort(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded
    );

BOOL
XcvOpenPort(
    HANDLE hMonitor,
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    );


BOOL
XcvClosePort(
    HANDLE  hXcv
    );

BOOL
PPXcvData(
    HANDLE  hXcv,
    LPCWSTR pszDataName,
    PBYTE   pInputData,
    DWORD   cbInputData,
    PBYTE   pOutputData,
    DWORD   cbOutputData,
    PDWORD  pcbOutputNeeded,
    PDWORD  pdwStatus);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetpp2\server\util.h ===
/*****************************************************************************\
* MODULE: util.h
*
* Private header for the Print-Processor library.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   07-Oct-1996 HWP-Guys    Initiated port from win95 to winNT
*
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

// Constants defined.
//
#define PRINT_LEVEL_0        0
#define PRINT_LEVEL_1        1
#define PRINT_LEVEL_2        2
#define PRINT_LEVEL_3        3
#define PRINT_LEVEL_4        4
#define PRINT_LEVEL_5        5

#define PORT_LEVEL_1         1
#define PORT_LEVEL_2         2

#define COMPUTER_MAX_NAME   32


// Utility Routines.
//
PCINETMONPORT utlValidatePrinterHandle(
    HANDLE hPrinter);

PCINETMONPORT utlValidatePrinterHandleForClose(
    HANDLE hPrinter,
    PBOOL pbDeletePending);


#ifdef WINNT32

LPTSTR utlValidateXcvPrinterHandle(
    HANDLE hPrinter);
#endif

BOOL utlParseHostShare(
    LPCTSTR lpszPortName,
    LPTSTR  *lpszHost,
    LPTSTR  *lpszShare,
    LPINTERNET_PORT  lpPort,
    LPBOOL  lpbHTTPS);

int utlStrSize(
    LPCTSTR lpszStr);

LPBYTE utlPackStrings(
    LPTSTR  *pSource,
    LPBYTE  pDest,
    LPDWORD pDestOffsets,
    LPBYTE  pEnd);

LPTSTR utlStrChr(
    LPCTSTR cs,
    TCHAR   c);

LPTSTR utlStrChrR(
    LPCTSTR cs,
    TCHAR   c);

LPTSTR utlRegGetVal(
    HKEY    hKey,
    LPCTSTR lpszKey);


// ----------------------------------------------------------------------
//
// Impersonation utilities
//
// ----------------------------------------------------------------------

#ifdef WINNT32

BOOL
MyUNCName(
    LPTSTR   pNameStart
);

BOOL MyName(
    LPCTSTR pName
);
#endif

BOOL MyServer(
    LPCTSTR pName
);

// ---------------------------------------------------------------------
//
// Useful Macros
//
// ---------------------------------------------------------------------

#if (defined(WINNT32))
    #define WIN9X_INLINE
#else
    #define WIN9X_INLINE _inline
#endif

LPTSTR
GetUserName(VOID);

VOID
EndBrowserSession (
    VOID);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\cpldebug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME ""
#endif	// SZ_COMPNAME



static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
        if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
            break;
    }
    wsprintf(ach, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
	_AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  

    wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
	OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
	_DebugMsg(pszMsg);
	_asm {int 3};
}

#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP	_DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\cal.cxx ===
/***************************************************************************
FILE                            cal.cxx

MODULE                          Printers ISAPI DLL

PURPOSE                         Enforces Client Access Licensing

DESCRIBED IN

HISTORY     12/10/97 babakj     created

****************************************************************************/



/*  ==============================================================================
Issues:

Notes:
- I am assumuing the IIS enforcement for authenticated access is done per Post? So we should not have the problem with receiving part of the job, but rejecting the rest due to CAL denial (assuming we use single post job submission).
- So we end up consuming the CAL during the whole Post, even while our call back is waiting for the rest of the bytes from the Post. If the Post never completes, Weihai's clean up thread will kill the job and free up the CAL.
- "mdutil Get w3svc/AnonymousUserName" returns IUSR_BABAKJ3"]
- NtLicenseRequest API defined in ntlsapi.h in sdk\inc
   (could return LS_INSUFFICIENT_UNITS in per-server) (sample in net\svcdlls\srvsvc\server\xsproc.c.

- *** Test with a huge job, and make sure it will be OK to fail the HTTPExtensionProc call that only
       delivered a piece of the job (i.e. IIS may or may not accept the rest of the job
       but in either case delivers the IPP response to the client).

- Test on NTW, verify IsNTW() works.

-

**********************************************************************************/


#include "pch.h"
#include "spool.h"

#include <initguid.h>   // To define the IIS Metabase GUIDs used in this file. Every other file defines GUIDs as extern, except here where we actually define them in initguid.h.
#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines


#pragma hdrstop


#define MY_META_TIMEOUT 1000

TCHAR const c_szProductOptionsPath[] = TEXT( "System\\CurrentControlSet\\Control\\ProductOptions" );




HANDLE
RevertToPrinterSelf(
    VOID)
{
    HANDLE   NewToken, OldToken;
    NTSTATUS Status;

    NewToken = NULL;

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_IMPERSONATE,
                 TRUE,
                 &OldToken
                 );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(Status);
        return FALSE;
    }

    Status = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&NewToken,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(Status);
        return FALSE;
    }

    return OldToken;

}

BOOL
ImpersonatePrinterClient(
    HANDLE  hToken)
{
    NTSTATUS    Status;

    Status = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&hToken,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError(Status);
        return FALSE;
    }

    NtClose(hToken);

    return TRUE;
}


BOOL IsNTW()
{
    HKEY   hKey;
    TCHAR  szProductType[MAX_PATH];
    DWORD  cbData = sizeof(szProductType);

    static BOOL  fProductTypeKnown = FALSE;
    static BOOL  bIsNTW = TRUE;      // We are being forgiving. i.e. in case of a failure, we assume NTW, so no enforcement.


    if( !fProductTypeKnown ) {

        if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szProductOptionsPath, 0, KEY_READ, &hKey)) {

            if( RegQueryValueEx( hKey, L"ProductType", NULL, NULL, (LPBYTE)szProductType, &cbData) == ERROR_SUCCESS ) {

                fProductTypeKnown = TRUE;   // We will never check again...
                if( !lstrcmpi( L"ServerNT", szProductType ))
                    bIsNTW = FALSE;
            }
            RegCloseKey( hKey );
        }
    }

    return bIsNTW;
}

//
// if REMOTE_USER is empty it means anonymous, else, it has the username being impersonated
//
BOOL IsUserAnonymous(
    EXTENSION_CONTROL_BLOCK *pECB
)
{
    char    szRemoteUser[ MAX_PATH ];   // ISAPI interface is ANSI
    ULONG   uSize = sizeof( szRemoteUser );

    szRemoteUser[ 0 ] = 0;   // Set it to empty ANSI string

    // Notice this is an ANSI call.
    pECB->GetServerVariable( pECB->ConnID, "REMOTE_USER", szRemoteUser, &uSize ) ;

    return( !(*szRemoteUser) );  // empty string should point to a zero char
}


//
// Gets user name of the anonymous IIS account by reading it from
// the Metabase's (IISADMIN) path w3svc/AnonymousUserName.
//
// - Returns TRUE if szAnonymousAccountUserName is filled in, FALSE if failed.
// - Caller is supposed to make sure szAnonymousAccountName is MAX_PATH * sizeof(TCHAR) long.
// - We get what "mdutil Get w3svc/AnonymousUserName" gets, e.g. IUSR_MACHINENAME.
//   I am ignoring the fact that the admin might have set the user name not per machine, rather
//   at a more granular level.

//
BOOL GetAnonymousAccountUserName(
    LPTSTR szAnonymousUserName,
    DWORD dwSize
)
{
    BOOL    bRet = FALSE;
    HRESULT hr;                         // com error status
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    CComPtr<IMSAdminBase> pIMeta;       // ATL smart ptr

    DWORD dwMDRequiredDataLen;
    METADATA_RECORD mr;

    HANDLE  hToken = NULL;


    // Need to revert to our service credential to be able to read IIS Metabase.
    hToken = RevertToPrinterSelf();


    if (hToken) {
        // Create a instance of the metabase object
        hr=::CoCreateInstance(CLSID_MSAdminBase,
                              NULL,
                              CLSCTX_ALL,
                              IID_IMSAdminBase,
                              (void **)&pIMeta);
    
    
        if( SUCCEEDED( hr )) {
    
            // open key to ROOT on website #1 (default)
            hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                 L"/LM",
                                 METADATA_PERMISSION_READ,
                                 MY_META_TIMEOUT,
                                 &hMeta);
            if( SUCCEEDED( hr )) {
    
                mr.dwMDIdentifier = MD_ANONYMOUS_USER_NAME;
                mr.dwMDAttributes = 0;
                mr.dwMDUserType   = IIS_MD_UT_FILE;
                mr.dwMDDataType   = STRING_METADATA;
                mr.dwMDDataLen    = dwSize * sizeof(TCHAR);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(szAnonymousUserName);
    
                hr = pIMeta->GetData( hMeta, L"/W3svc", &mr, &dwMDRequiredDataLen );
                pIMeta->CloseKey( hMeta );
    
                if( SUCCEEDED( hr ))
    
                    bRet = TRUE;
            }
        }

        if (!ImpersonatePrinterClient(hToken))
            bRet = FALSE;
    }

    return bRet;
}




//
// Gets user name of the anonymous IIS account, combines with machine name g_szComputerName to
// get the format LocalMachineName\IUSR_LocalMachineName
//
// - Returns TRUE if szAnonymousAccountName is filled in, FALSE if failed.
// - Caller is supposed to make sure szAnonymousAccountName is MAX_PATH * sizeof(TCHAR) long.
//
BOOL GetAnonymousAccountName(
    LPTSTR szAnonymousAccountName,
    DWORD dwSize
)
{
    TCHAR szAnonymousUserName[MAX_PATH];
    ULONG uSize = dwSize;

    if( !GetComputerName( szAnonymousAccountName, &dwSize ))
        return FALSE;

    if( !GetAnonymousAccountUserName( szAnonymousUserName, MAX_PATH ))
        return FALSE;

    // Now add the user name to the machine name
    if (dwSize + 1 + lstrlen (szAnonymousUserName) < uSize ) {
        wsprintf( &szAnonymousAccountName[dwSize], L"\\%ws", szAnonymousUserName );
        return TRUE;
    }
    else {
        return FALSE;
    }
}

//
// Enforce the Client Access Licensing
//
// Returns TRUE if license granted, FALSE otherwise. phLicense contains a license handle that needs
// to be freed later, or NULL if no license was really needed, like NTW, or if non-Anonymous user
// which will be enforced by IIS.
//
// NOTE: We only read the Anonymous account name once, for performance sake, even though it
//       could change during operation.
//
//
BOOL RequestLicense(
    LS_HANDLE *phLicense,
    LPEXTENSION_CONTROL_BLOCK pECB
)
{
    static TCHAR szAnonymousAccountName[ MAX_PATH ];
    static BOOL  fHaveReadAnonymousAccount = FALSE;

    if( !phLicense )
        return FALSE;

    *phLicense = NULL;

    if( IsNTW() || !IsUserAnonymous( pECB ))
        return TRUE;

    if( !fHaveReadAnonymousAccount )
        if( !GetAnonymousAccountName( szAnonymousAccountName , MAX_PATH ))
            return TRUE;       // CAL-wise, we need to be forgiving
        else
            fHaveReadAnonymousAccount = TRUE;


    NT_LS_DATA NtLSData;

    NtLSData.DataType = NT_LS_USER_NAME;
    NtLSData.Data = szAnonymousAccountName;
    NtLSData.IsAdmin = FALSE;    // why is this important to know   ??


    return( NT_SUCCESS( NtLicenseRequest( TEXT("FilePrint"),
                                          TEXT("5.0"),
                                          phLicense,
                                          &NtLSData )));
}


void FreeLicense(
    LS_HANDLE hLicense
)
{

//   hLicense of NULL means no license was needed (like NTW,
//   or non-anonymous case where IIS will take care of it.

    if( hLicense )
        NtLSFreeHandle( hLicense );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\gencab.h ===
/*****************************************************************************\
* MODULE: gencab.h
*
* This is the main header for the CAB generation module.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 <chriswil>  Created.
*
\*****************************************************************************/

// Constants.
//
#define MAX_CAB_BUFFER 1024
#define MIN_CAB_BUFFER   64


// Function Macro mappings.
//
#define EXEC_PROCESS(lpszCmd, psi, ppi) \
    CreateProcess(NULL, lpszCmd, NULL, NULL, FALSE, 0, NULL, NULL, psi, ppi)


// Critical-Section Function Mappings.
//
#define InitCABCrit()   InitializeCriticalSection(&g_csGenCab)
#define FreeCABCrit()   DeleteCriticalSection(&g_csGenCab)


// Entry-point to the whole process.
//
DWORD GenerateCAB(
    LPCTSTR lpszFriendlyName,
    LPCTSTR lpszPortName,
    DWORD   dwCliInfo,
    LPTSTR  lpszOutputName,
    BOOL    bSecure);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\gencdf.h ===
/*****************************************************************************\
* MODULE: gencdf.h
*
* This is the main header for the CDF generation module.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 HWP-Guys    Created.
*
\*****************************************************************************/

#define STD_CDF_BUFFER        256
#define MIN_CDF_BUFFER         16

#define CDF_SECTION_BLOCK    4096
#define CDF_SRCFILE_BLOCK    1024
#define CDF_SECTION_LIMIT       8


// Source-Files Structure.  This is used to track files
// by section.
//
typedef struct _SRCFILES {

    LPTSTR           lpszPath;
    LPTSTR           lpszFiles;
    DWORD            cbMax;
    DWORD            cbSize;
    struct _SRCFILES *pNext;

} SRCFILES;
typedef SRCFILES      *PSRCFILES;
typedef SRCFILES NEAR *NPSRCFILES;
typedef SRCFILES FAR  *LPSRCFILES;


// Element-Array idenifiers for FILEITEM
//
#define FI_MAX_ITEMS    2
#define FI_COL_FILENAME 0
#define FI_COL_PATH     1
#define FI_COL_LAST     1


// File-Item Structure.
//
typedef struct _FILEITEM {

    LPTSTR           aszCols[FI_MAX_ITEMS]; // Filename and Path.
    FILETIME         ftLastModify;          // Filetime stamp.
    struct _FILEITEM *pNext;                // Pointer to next File-Item.

} FILEITEM;
typedef FILEITEM      *PFILEITEM;
typedef FILEITEM NEAR *NPFILEITEM;
typedef FILEITEM FAR  *LPFILEITEM;


// CDF Object Structure.
//
typedef struct _CDFINFO {

    HANDLE    hInf;                  // Handle to current inf object
    DWORD     dwError;               // Error if CDF processing fails
    LPTSTR    lpszCdfFile;           // Full path-name to cdf-file.
    PFILEITEM pTop;                  // List of files to include in the .cdf
    HCATADMIN hCatAdmin;             // Context handle for catalog admin APIs
    BOOL      bSecure;

} CDFINFO;
typedef CDFINFO      *PCDFINFO;
typedef CDFINFO NEAR *NPCDFINFO;
typedef CDFINFO FAR  *LPCDFINFO;


// Interface Objects to CDF.
//
HANDLE cdfCreate(
    HANDLE hinf,
    BOOL   bSecure);

VOID cdfCleanUpSourceFiles(
    HANDLE hInf);

BOOL cdfProcess(
    HANDLE hcdf);

BOOL cdfDestroy(
    HANDLE hcdf);

LPCTSTR cdfGetName(
    HANDLE hcdf);

BOOL cdfGetModTime(
    HANDLE     hcdf,
    LPFILETIME lpftMod);

/***************************************\
* cdfGetError
\***************************************/
__inline DWORD cdfGetError(
    HANDLE hsed)
{
    return (hsed ? (DWORD)((PCDFINFO)hsed)->dwError : ERROR_SUCCESS);
}

/***************************************\
* cdfSetError
\***************************************/
__inline VOID cdfSetError(
    PCDFINFO  hsed,
    DWORD     dwError )
{
    hsed->dwError = dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\gencdf.cxx ===
/*****************************************************************************\
* MODULE: gencdf.c
*
* The module contains routines for generating a CDF (Cabinet Directive File)
* for the IExpress utility.
*
* Work Items:
* ----------
* 1) Redo item-allocations to use single block-heap and append information
*    to reduce heap-overhead.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 HWP-Guys    Created.
*
\*****************************************************************************/

#include "pch.h"

/*****************************************************************************\
* cdf_NextStr (Local Routine)
*
* Proceeds to the next string in a section-list.
*
\*****************************************************************************/
_inline LPTSTR cdf_NextStr(
    LPTSTR lpszStr)
{
    return (lpszStr + (lstrlen(lpszStr) + 1));
}


/******************************************************************************\
*
* GetDirectory (Local Routine)
*
* Returns the directory portion of a full pathname.
*
\******************************************************************************/
LPTSTR cdf_GetDirectoryWithSlash(LPTSTR lpszFile) {

    LPTSTR lpszSlash;
    LPTSTR lpszDir;

    lpszSlash = genFindRChar(lpszFile, TEXT('\\'));

    if (lpszSlash != NULL) {

        if (NULL != (lpszDir = (LPTSTR)genGAlloc((UINT32) (lpszSlash - lpszFile + 2) * sizeof(TCHAR)))) {

            lstrcpyn(lpszDir, lpszFile, (UINT32) (lpszSlash - lpszFile + 2));
            return lpszDir;
        }
    }

    return NULL;
}

/******************************************************************************\
*
* cdf_GetName (Local Routine)
*
* Returns the filename portion of a full pathname.
*
\******************************************************************************/
LPTSTR cdf_GetName(LPTSTR lpszFile) {

    LPTSTR lpszSlash;
    LPTSTR lpszName;
    int    nLength;

    lpszSlash = genFindRChar(lpszFile, TEXT('\\'));

    if (lpszSlash != NULL) {

        nLength = lstrlen(lpszSlash);

        if (NULL != (lpszName = (LPTSTR)genGAlloc((nLength * sizeof(TCHAR))))) {

            lstrcpyn(lpszName, ++lpszSlash, nLength);
            return lpszName;
        }
    }
    return NULL;
}

/*****************************************************************************\
* cdf_SFLAdd (Local Routine)
*
* Adds a new section to our linked-list of sections.  This adds it to the
* head of the list and returns a pointer to the new item (head).
*
\*****************************************************************************/
LPSRCFILES cdf_SFLAdd(
    LPSRCFILES psfList,
    LPCTSTR    lpszPath)
{
    LPSRCFILES psfItem;


    if (psfItem = (LPSRCFILES)genGAlloc(sizeof(SRCFILES))) {

        if (psfItem->lpszPath = genGAllocStr(lpszPath)) {

            // Allocate the files-list buffer.
            //
            if (psfItem->lpszFiles = (LPTSTR)genGAlloc(CDF_SRCFILE_BLOCK)) {

                // Position our item at the head.
                //
                psfItem->cbMax  = CDF_SRCFILE_BLOCK;
                psfItem->cbSize = 0;
                psfItem->pNext  = psfList;


                // Make sure our file beginning is zeroed.
                //
                *(psfItem->lpszFiles) = TEXT('\0');

                return psfItem;
            }

            genGFree(psfItem->lpszPath, genGSize(psfItem->lpszPath));
        }

        genGFree(psfItem, sizeof(SRCFILES));
    }

    DBGMSG(DBG_ERROR, ("cdf_SFLAdd : Out of memory"));

    return NULL;
}


/*****************************************************************************\
* cdf_SFLAddFile (Local Routine)
*
* Adds a file-item to the specified section-pointer.
*
\*****************************************************************************/
BOOL cdf_SFLAddFile(
    LPSRCFILES psfList,
    LPCTSTR    lpszFile)
{
    LPTSTR lpszList;
    LPTSTR lpszPtr;
    LPTSTR lpszNew;
    DWORD  cbSize;
    DWORD  cbOldSize;
    DWORD  cbNewSize;


    // Determine if adding this file exceeds our current maximum
    // buffer.  If so, then realloc a bigger chunk.  We are adding
    // two extra characters to account for the '%' which are to
    // be added to the lpszFile.
    //
    cbSize = (lstrlen(lpszFile) + 1 + 2) * sizeof(TCHAR);

    if ((psfList->cbSize + cbSize) >= psfList->cbMax) {

        cbOldSize = genGSize(psfList->lpszFiles);
        cbNewSize = cbOldSize + CDF_SRCFILE_BLOCK;

        lpszNew = (LPTSTR)genGRealloc(psfList->lpszFiles, cbOldSize, cbNewSize);

        if (lpszNew == NULL) {

            DBGMSG(DBG_ERROR, ("cdf_SFLAddFile : Out of memory"));

            return FALSE;
        }


        // Set new limit criteria.
        //
        psfList->lpszFiles = lpszNew;
        psfList->cbMax     = cbNewSize;
    }


    // We are appending the file to the end of the list.
    //
    lpszPtr = (LPTSTR)(((LPBYTE)psfList->lpszFiles) + psfList->cbSize);

    wsprintf(lpszPtr, TEXT("%%%s%%\0"), lpszFile);

    psfList->cbSize += cbSize;

    return TRUE;
}


/*****************************************************************************\
* cdf_SFLFind (Local Routine)
*
* Looks for the existence of a section-name.
*
\*****************************************************************************/
LPSRCFILES cdf_SFLFind(
    LPSRCFILES psfList,
    LPCTSTR    lpszPath)
{
    while (psfList) {

        if (lstrcmpi(psfList->lpszPath, lpszPath) == 0)
            return psfList;

        psfList = psfList->pNext;
    }

    return NULL;
}


/*****************************************************************************\
* cdf_SFLFree (Local Routine)
*
* Frees up memory associated with the source-file-list.
*
\*****************************************************************************/
BOOL cdf_SFLFree(
    LPSRCFILES psfList)
{
    LPSRCFILES psfItem;


    while (psfList) {

        genGFree(psfList->lpszFiles, genGSize(psfList->lpszFiles));
        genGFree(psfList->lpszPath , genGSize(psfList->lpszPath));

        psfItem = psfList;
        psfList = psfList->pNext;

        genGFree(psfItem, genGSize(psfItem));
    }

    return TRUE;
}


/*****************************************************************************\
* cdf_WriteStrings
*
* Outputs a string to the [Strings] section.
*
\*****************************************************************************/
_inline BOOL cdf_WriteStrings(
    LPCTSTR lpszCdfFile,
    LPCTSTR lpszKey,
    LPCTSTR lpszStr)
{
    return WritePrivateProfileString(g_szStrings, lpszKey, lpszStr, lpszCdfFile);
}


/*****************************************************************************\
* itm_InitList (Local Routine)
*
* Initializes the file-item-list.
*
\*****************************************************************************/
_inline VOID itm_InitList(
    PCDFINFO pCdfInfo)
{
    pCdfInfo->pTop = NULL;
}


/*****************************************************************************\
* itm_GetFirst (Local Routine)
*
* Returns the first PMYITEM in the list
*
\*****************************************************************************/
_inline PFILEITEM itm_GetFirst(
    PCDFINFO pCdfInfo)
{
    return pCdfInfo->pTop;
}


/*****************************************************************************\
* itm_GetNext (Local Routine)
*
* Given the current item, returns the next item in the list.
*
\*****************************************************************************/
_inline PFILEITEM itm_GetNext(
    PFILEITEM pMyItem)
{
    SPLASSERT((pMyItem != NULL));

    return pMyItem->pNext;
}


/*****************************************************************************\
* itm_GetString (Local Routine)
*
* Returns a string associated with an item. You pick the
* string by passing the number of the string.
*
\*****************************************************************************/
_inline LPTSTR itm_GetString(
    PFILEITEM pMyItem,
    UINT      nItem)
{
    SPLASSERT((pMyItem != NULL));
    SPLASSERT((nItem <= FI_COL_LAST));

    return pMyItem->aszCols[nItem];
}


/*****************************************************************************\
* itm_FullPath (Local Routine)
*
* Return a fully-qualified pathname for the item.
*
\*****************************************************************************/
_inline LPTSTR itm_FullPath(
    PFILEITEM pItem)
{
    LPTSTR lpszPath;
    LPTSTR lpszFile;


    // Gather the strings and build the name.
    //
    lpszPath = itm_GetString(pItem, FI_COL_PATH);
    lpszFile = itm_GetString(pItem, FI_COL_FILENAME);

    return genBuildFileName(NULL, lpszPath, lpszFile);
}


/*****************************************************************************\
* itm_GetTime (Local Routine)
*
* Returns a time associated with an item.
*
\*****************************************************************************/
_inline FILETIME itm_GetTime(
    PFILEITEM pMyItem)
{
    SPLASSERT((pMyItem != NULL));

    return pMyItem->ftLastModify;
}


/*****************************************************************************\
* itm_SetTime (Local Routine)
*
* Sets the last modified time of the item.
*
\*****************************************************************************/
VOID itm_SetTime(
    PFILEITEM pMyItem,
    FILETIME  ftLastModify)
{
    SPLASSERT((pMyItem != NULL));

    pMyItem->ftLastModify = ftLastModify;
}


/*****************************************************************************\
* itm_Last (Local Routine)
*
* Used to end a while loop when we've reached the end of list
*
\*****************************************************************************/
_inline BOOL itm_Last(
    PFILEITEM pMyItem)
{
    return (pMyItem == NULL);
}


/*****************************************************************************\
* itm_Free (Local Routine)
*
* Frees the memory associated with an item.
*
\*****************************************************************************/
VOID itm_Free(
    PFILEITEM pItem)
{
    LPTSTR lpszStr;

    if (lpszStr = itm_GetString(pItem, FI_COL_FILENAME))
        genGFree(lpszStr, genGSize(lpszStr));

    if (lpszStr = itm_GetString(pItem, FI_COL_PATH))
        genGFree(lpszStr, genGSize(lpszStr));

    genGFree(pItem, sizeof(FILEITEM));
}


/*****************************************************************************\
* itm_DeleteAll (Local Routine)
*
* Deletes all the items from our file list.
*
\*****************************************************************************/
VOID itm_DeleteAll(
    PCDFINFO pCdfInfo)
{
    PFILEITEM pMyItem;
    PFILEITEM pTempItem;

    pMyItem = itm_GetFirst(pCdfInfo);

    while (itm_Last(pMyItem) == FALSE) {

        pTempItem = pMyItem;
        pMyItem   = itm_GetNext(pMyItem);

        itm_Free(pTempItem);
    }

    itm_InitList(pCdfInfo);
}


/*****************************************************************************\
* itm_Add (Local Routine)
*
* Adds an item to the list.
*
\*****************************************************************************/
PFILEITEM itm_Add(
    LPCTSTR  lpszFilename,
    LPCTSTR  lpszPath,
    PCDFINFO pCdfInfo)
{
    PFILEITEM pMyItem;

    SPLASSERT((lpszFilename != NULL));
    SPLASSERT((lpszPath != NULL));


    if (pMyItem = (PFILEITEM)genGAlloc(sizeof(FILEITEM))) {

        // Allocate the strings for the path/filename.
        //
        if (pMyItem->aszCols[FI_COL_FILENAME] = genGAllocStr(lpszFilename)) {

            if (pMyItem->aszCols[FI_COL_PATH] = genGAllocStr(lpszPath)) {

                pMyItem->pNext = pCdfInfo->pTop;
                pCdfInfo->pTop = pMyItem;

                return pMyItem;
            }

            genGFree(pMyItem->aszCols[FI_COL_FILENAME], genGSize(pMyItem->aszCols[FI_COL_FILENAME]));
        }

        genGFree(pMyItem, sizeof(FILEITEM));
    }

    return NULL;
}


/*****************************************************************************\
* itm_Find (Local Routine)
*
* To see if file is already in list
*
\*****************************************************************************/
PFILEITEM itm_Find(
    LPCTSTR  lpszFindFile,
    PCDFINFO pCdfInfo,
    BOOL     bMatchFullPath)
{
    PFILEITEM pItem = itm_GetFirst(pCdfInfo);
    LPTSTR    lpszItmFile;
    BOOL      bRet = FALSE;


    // Loop through our list of items looking for a file
    // match.
    //
    while (pItem) {

        // Build the file-name from the stored-strings.
        //
        if (bMatchFullPath)
            lpszItmFile = itm_FullPath(pItem);
        else
            lpszItmFile = itm_GetString(pItem, FI_COL_FILENAME);

        if (lpszItmFile) {

            // Check for match.
            //
            if (lstrcmpi(lpszFindFile, lpszItmFile) == 0) {

                // Found.
                //
                if (bMatchFullPath)
                    genGFree(lpszItmFile, genGSize(lpszItmFile));

                return pItem;
            }

            if (bMatchFullPath)
                genGFree(lpszItmFile, genGSize(lpszItmFile));

        } else {

            return NULL;
        }

        pItem = itm_GetNext(pItem);
    }

    return NULL;
}


/*****************************************************************************\
* cdf_WriteTimeStamps
*
* Outputs a struct to the [TimeStamps] section.
*
\*****************************************************************************/
_inline BOOL cdf_WriteTimeStamps(
    LPCTSTR    lpszCdfFile,
    LPCTSTR    lpszKey,
    LPFILEITEM pFileItem)
{
    FILETIME ft = itm_GetTime(pFileItem);

    return WritePrivateProfileStruct(g_szTimeStamps, lpszKey, &ft, sizeof(FILETIME), lpszCdfFile);
}


/*****************************************************************************\
* cdf_WriteSourceFiles
*
* Outputs a struct to the [SourceFiles] section.
*
\*****************************************************************************/
_inline BOOL cdf_WriteSourceFiles(
    LPCTSTR lpszCdfFile,
    LPCTSTR lpszKey,
    LPCTSTR lpszStr)
{
    return WritePrivateProfileString(g_szSourceFiles, lpszKey, lpszStr, lpszCdfFile);
}


/*****************************************************************************\
* cdf_GetSection (Local Routine)
*
* Allocate a buffer which stores either all section-names or the list of
* items specified by (lpszSection) in an INF file.  Currently, we attempt
* a realloc if the buffer is not big enough.
*
* NOTE: should we provide a limit for the amount of allocations before
*       we accept failure?
*
*       09-Dec-1996 : ChrisWil
*
\*****************************************************************************/
LPTSTR cdf_GetSection(
    LPCTSTR lpszSct,
    BOOL    bString,
    LPCTSTR lpszCdfFile)
{
    DWORD  dwCnt;
    DWORD  cch;
    DWORD  dwSize;
    DWORD  dwLimit;
    LPTSTR lpszNames = NULL;


    dwSize  = 0;
    dwLimit = 0;

    while (dwLimit < CDF_SECTION_LIMIT) {

        // We'll start this allocation with an assumed max-size.  Upon
        // successive tries, this buffer is increased each time by the
        // original buffer allocation.
        //
        dwSize += (CDF_SECTION_BLOCK * sizeof(TCHAR));
        dwLimit++;


        // Alloc the buffer and attempt to get the names.
        //
        if (lpszNames = (LPTSTR)genGAlloc(dwSize)) {

            // If a section-name is profided, use that.  Otherwise,
            // enumerate all section-names.
            //
            cch = dwSize / sizeof(TCHAR);

            if (bString) {

                dwCnt = GetPrivateProfileString(lpszSct,
                                                NULL,
                                                g_szEmptyStr,
                                                lpszNames,
                                                cch,
                                                lpszCdfFile);

            } else {

                dwCnt = GetPrivateProfileSection(lpszSct,
                                                 lpszNames,
                                                 cch,
                                                 lpszCdfFile);
            }


            // If the call says the buffer was OK, then we can
            // assume the names are retrieved.  According to spec's,
            // if the return-count is equal to size-2, then buffer
            // isn't quite big-enough (two NULL chars).
            //
            if (dwCnt < (cch - 2))
                goto GetSectDone;


            genGFree(lpszNames, dwSize);
            lpszNames = NULL;
        }
    }

GetSectDone:

    SPLASSERT((dwLimit < CDF_SECTION_LIMIT));

    return lpszNames;
}


/*****************************************************************************\
* cdf_GetValue (Local Routine)
*
*
\*****************************************************************************/
LPTSTR cdf_GetValue(
    LPCTSTR lpszSection,
    LPCTSTR lpszKey,
    LPCTSTR lpszCdfFile)
{
    TCHAR  szBuffer[STD_CDF_BUFFER];
    DWORD  cch;
    LPTSTR lpszVal = NULL;


    cch = GetPrivateProfileString(lpszSection,
                                  lpszKey,
                                  g_szEmptyStr,
                                  szBuffer,
                                  COUNTOF(szBuffer),
                                  lpszCdfFile);

    SPLASSERT((cch < STD_CDF_BUFFER));

    return (cch ? genGAllocStr(szBuffer) : NULL);
}


/*****************************************************************************\
* cdf_GetCdfFile (Local Routine)
*
* Returns an allocated string to the CDF file (Full-Path)
*
\*****************************************************************************/
LPTSTR cdf_GetCdfFile(
    PCDFINFO pCdfInfo)
{
    LPCTSTR lpszDstPath;
    LPCTSTR lpszDstName;


    // Retrieve the strings representing the destination path and name
    // of the output file.  These strings have already been validated
    // by the INF object.
    //
    lpszDstPath = infGetDstPath(pCdfInfo->hInf);
    lpszDstName = infGetDstName(pCdfInfo->hInf);


    return genBuildFileName(lpszDstPath, lpszDstName, g_szDotSed);
}


/*****************************************************************************\
* cdf_GetUncName (Local Routine)
*
* Returns an allocated string to the unc-name.
*
\*****************************************************************************/
LPTSTR cdf_GetUncName(
    PCDFINFO pCdfInfo)
{
    DWORD   cbSize;
    LPCTSTR lpszShrName;
    LPTSTR  lpszUncName = NULL;

    static CONST TCHAR s_szFmt[] = TEXT("\\\\%s\\%s");


    if (lpszShrName = infGetShareName(pCdfInfo->hInf)) {

        cbSize = lstrlen(g_szPrintServerName) +
                 lstrlen(lpszShrName)      +
                 lstrlen(s_szFmt)          +
                 1;

        if (lpszUncName = (LPTSTR)genGAlloc((cbSize * sizeof(TCHAR))))
            wsprintf(lpszUncName, s_szFmt, g_szPrintServerName, lpszShrName);
    }

    return lpszUncName;
}


/*****************************************************************************\
* cdf_BuildFriendlyName (Local Routine)
*
* Builds a \\machinename\friendly type string so that the client can
* refer to the printer as "friendly on machinename".
*
\*****************************************************************************/
LPTSTR cdf_BuildFriendlyName(
    PCDFINFO pCdfInfo)
{
    DWORD   cbSize;
    LPCTSTR lpszFrnName;
    LPTSTR  lpszPtr;
    LPTSTR  lpszFmt;
    LPTSTR  lpszName = NULL;

    static TCHAR s_szFmt0[] = TEXT("\\\\http://%s\\%s");
    static TCHAR s_szFmt1[] = TEXT("\\\\https://%s\\%s");


    if (lpszFrnName = infGetFriendlyName(pCdfInfo->hInf)) {

        if (lpszPtr = genFindChar((LPTSTR)lpszFrnName, TEXT('\\'))) {

            lpszPtr++;
            lpszPtr++;

            if (lpszPtr = genFindChar(lpszPtr, TEXT('\\'))) {

                // Check if this is a secure request.
                //
                lpszFmt = (pCdfInfo->bSecure ? s_szFmt1 : s_szFmt0);


                // This is the friendly name, not the port name, so we don't
                // call GetWebpnpUrl to encode it.
                //
                cbSize = lstrlen(g_szHttpServerName) +
                         lstrlen(++lpszPtr)          +
                         lstrlen(lpszFmt)            +
                         1;

                if (lpszName = (LPTSTR)genGAlloc(cbSize * sizeof(TCHAR)))
                    wsprintf(lpszName, lpszFmt, g_szHttpServerName, lpszPtr);
            }
        }
    }

    return lpszName;
}


/*****************************************************************************\
* cdf_ReadFiles (Local Routine)
*
* Reads in the files under the specified src-path-key.
*
\*****************************************************************************/
BOOL cdf_ReadFiles(
    LPCTSTR  lpszSrcPathKey,
    LPCTSTR  lpszSrcFiles,
    PCDFINFO pCdfInfo)
{
    FILETIME  ftFileTime;
    PFILEITEM pFileItem;
    LPTSTR    lpszPath;
    LPTSTR    lpszFiles;
    LPTSTR    lpszFile;
    LPTSTR    lpszStr;
    BOOL      bRet = FALSE;


    // For the specified SrcKeyPath, read in the list of files
    // associated with the path.
    //
    lpszFiles = cdf_GetSection(lpszSrcPathKey, FALSE, pCdfInfo->lpszCdfFile);

    if (lpszFiles) {

        // Get the path-value associated with the SrcPathKey.
        //
        if (lpszPath = cdf_GetValue(lpszSrcFiles, lpszSrcPathKey, pCdfInfo->lpszCdfFile)) {

            lpszFile = lpszFiles;

            while (*lpszFile) {

                // If the first-character doesn't specify a string-type
                // then we can add it directly.  Otherwise, we're going
                // to have to get the file referenced by the string.
                //
                if (lpszFile[0] != TEXT('%')) {

                    // Store the path and filename in the list.
                    //
                    pFileItem = itm_Add(lpszFile, lpszPath, pCdfInfo);
                    //
                    // Fail if we have run out of memory
                    //
                    if (!pFileItem)
                    {
                        goto ReadFileError;
                    }


                    // Read in file timestamp from .cdf.
                    //
                    if (GetPrivateProfileStruct(g_szTimeStamps,
                                                lpszFile,
                                                &ftFileTime,
                                                sizeof(FILETIME),
                                                pCdfInfo->lpszCdfFile)) {
                        // Store the timestamp.
                        //
                        itm_SetTime(pFileItem, ftFileTime);

                        lpszFile = cdf_NextStr(lpszFile);

                    } else {

                        goto ReadFileError;
                    }

                } else {

                    // Handle %filename% names (localizable strings)
                    // If the filename is delimited by two percent (%)
                    // signs,it is not a literal, but needs to be
                    // looked up [Strings] section of the .cdf file.
                    //
                    // Replace the % on the end of the string
                    // with a null char, then move past the end-char.
                    //
                    lpszFile[lstrlen(lpszFile) - 1] = TEXT('\0');
                    lpszFile++;


                    lpszStr = cdf_GetValue(g_szStrings,
                                           lpszFile,
                                           pCdfInfo->lpszCdfFile);

                    if (lpszStr) {

                        pFileItem = itm_Add(lpszStr, lpszPath, pCdfInfo);


                        // Read in file timestamp from .cdf
                        //
                        GetPrivateProfileStruct(g_szTimeStamps,
                                                lpszFile,
                                                &ftFileTime,
                                                sizeof(FILETIME),
                                                pCdfInfo->lpszCdfFile);

                        genGFree(lpszStr, genGSize(lpszStr));

                        itm_SetTime(pFileItem, ftFileTime);


                        // We add 2 + len of string, because we put in an
                        // extra null to replace the % char
                        //
                        lpszFile = cdf_NextStr(lpszFile) + 1;

                    } else {

                        goto ReadFileError;
                    }
                }
            }

            bRet = TRUE;

ReadFileError:

            genGFree(lpszPath, genGSize(lpszPath));
        }

        genGFree(lpszFiles, genGSize(lpszFiles));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_ReadFileList (Local Routine)
*
* Reads in the file-list from the CDF-File.
*
\*****************************************************************************/
BOOL cdf_ReadFileList(
    PCDFINFO pCdfInfo)
{
    LPTSTR lpszSrcFiles;
    LPTSTR lpszSrcPaths;
    LPTSTR lpszPathKey;
    BOOL   bRet = FALSE;


    // Initialize the head of the list.
    //
    itm_InitList(pCdfInfo);


    // Get source files section of .cdf file
    //
    lpszSrcFiles = cdf_GetValue(g_szOptions,
                                g_szSourceFiles,
                                pCdfInfo->lpszCdfFile);

    if (lpszSrcFiles) {

        // Read in the entire SourceFiles section (as a list of keys).
        //
        lpszSrcPaths = cdf_GetSection(lpszSrcFiles,
                                      TRUE,
                                      pCdfInfo->lpszCdfFile);

        if (lpszPathKey = lpszSrcPaths) {

            // Each section name has a path associated with it.
            // For each section name, read in and add all the
            // files to the list
            //
            while (*lpszPathKey) {

                if (cdf_ReadFiles(lpszPathKey, lpszSrcFiles, pCdfInfo) == FALSE)
                    goto ReadListExit;

                lpszPathKey = cdf_NextStr(lpszPathKey);
            }

            bRet = TRUE;

ReadListExit:

            genGFree(lpszSrcPaths, genGSize(lpszSrcPaths));
        }

        genGFree(lpszSrcFiles, genGSize(lpszSrcFiles));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_AddCATFile (Local Routine)
*
* This is called by cdf_GetFileList for each file being added to the cdf.
* It uses the Catalog File Admin APIs to determine if the driver file was installed
* with an associated catalog file.  If a corresponding catalog file (or files)
* is found, the catalog filename (or filenames), along with its timestamp,
* is added to the cdf file list.
*
\*****************************************************************************/
BOOL cdf_AddCATFile(LPTSTR lpszFile, LPCDFINFO pCdfInfo ) {

    HCATADMIN       hCatAdmin = pCdfInfo->hCatAdmin;
    HCATINFO        hCatInfo = NULL;
    CATALOG_INFO    CatInfo;
    BYTE *          pbHash;
    DWORD           dwBytes;
    WIN32_FIND_DATA ffd;
    PFILEITEM       pFileItem;
    HANDLE          hFind, hFile;
    LPTSTR          pFullPath, pPath, pName;

    // Find the catalog file associated with this file.
    // If we can't find one, that's OK, it's not an error, just a file
    // with no associated .cat file.  The user can decide on the client-end
    // whether or not he wants to install without the verification a .cat file
    // would provide...
    //
    if (INVALID_HANDLE_VALUE != (HANDLE)hCatAdmin) {

        hFind = FindFirstFile(lpszFile, &ffd);

        if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

            FindClose(hFind);

            // Open the file in order to hash it.
            //
            if (INVALID_HANDLE_VALUE != (hFile = CreateFile(lpszFile,
                                                            GENERIC_READ,
                                                            FILE_SHARE_READ,
                                                            NULL,
                                                            OPEN_EXISTING,
                                                            FILE_ATTRIBUTE_NORMAL,
                                                            NULL))) {

                // Determine how many bytes we need for the hash
                //
                dwBytes = 0;
                pbHash = NULL;
                CryptCATAdminCalcHashFromFileHandle(hFile, &dwBytes, pbHash, 0);

                if (NULL != (pbHash = (BYTE *)genGAlloc(dwBytes))) {

                    // Compute the hash for this file
                    //
                    if (CryptCATAdminCalcHashFromFileHandle(hFile, &dwBytes, pbHash, 0)) {

                        // Get the catalog file(s) associated with this file hash
                        //
                        hCatInfo = NULL;

                        do {

                            hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash, dwBytes, 0, &hCatInfo);

                            if (NULL != hCatInfo) {

                                // Split the cat name into file and path here
                                //
                                if (CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, NULL)) {

                                    if (NULL != (pFullPath = genTCFromWC(CatInfo.wszCatalogFile))) {

                                        if (NULL != (pPath = cdf_GetDirectoryWithSlash(pFullPath))) {

                                            if (NULL != (pName = cdf_GetName(pFullPath))) {

                                                // Make sure the file is not already in the cdf, so
                                                // IExpress doesn't give out (see BUG: explanation in cdf_GetFileList() )
                                                //
                                                if (NULL == itm_Find(pName, pCdfInfo, FALSE)) {
                                                    // Add the catalog file and timestamp

                                                    pFileItem = itm_Add(pName, pPath, pCdfInfo);
                                                    itm_SetTime(pFileItem, ffd.ftLastWriteTime);
                                                }

                                                genGFree(pName, genGSize(pName) );
                                            }

                                            genGFree(pPath, genGSize(pPath) );
                                        }

                                        genGFree(pFullPath, genGSize(pFullPath) );
                                    }

                                }

                            }

                        } while (NULL != hCatInfo);

                    }

                    genGFree(pbHash, dwBytes);
                }

                CloseHandle(hFile);
            }
        }
    }

    return TRUE;
}


/*****************************************************************************\
* cdf_GetFileList (Local Routine)
*
* This is a callback function passed to infEnumItems()
* It reads in the list of files from the INF object, and reads
* the filetimes from the disk and adds these to the list also.
*
\*****************************************************************************/
BOOL CALLBACK cdf_GetFileList(
    LPCTSTR lpszName,
    LPCTSTR lpszPath,
    BOOL    bInf,
    LPVOID  lpData)
{
    PCDFINFO        pCdfInfo = (PCDFINFO)lpData;
    HANDLE          hFind;
    PFILEITEM       pFileItem;
    LPTSTR          lpszFile;
    LPTSTR          lpszPtr;
    WIN32_FIND_DATA FindFileData;
    BOOL            bRet = FALSE;

    // Build fully qualified file name.
    //
    if (lpszFile = genBuildFileName(lpszPath, lpszName, NULL)) {

        hFind = FindFirstFile(lpszFile, &FindFileData);

        if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

            FindClose(hFind);

            // BUG : IExpress craps out when it encounters the
            //       same filename twice.  To work-around this,
            //       we will prevent the inclusion of the second
            //       file.  We will match the name-only.
            //
            if (itm_Find(lpszName, pCdfInfo, FALSE) == NULL) {

                // Add the item to the list of CDF-Files.  We
                // store the path-name with the trailing '\'
                // because the CDF format requires such.
                //
                lpszPtr = genFindRChar(lpszFile, TEXT('\\'));

                // Is filename of right format?
                //
                if ( lpszPtr != NULL ) {

                    *(++lpszPtr) = TEXT('\0');
                    pFileItem = itm_Add(lpszName, lpszFile, pCdfInfo);


                    // Set the item-time. This should only fail if we couldn't allocate memory
                    //
                    if (pFileItem != NULL)  {
                        itm_SetTime(pFileItem, FindFileData.ftLastWriteTime);
                        bRet = TRUE;
                    }
                }
                else
                    SetLastError(ERROR_INVALID_PARAMETER);
            }
            else
                bRet = TRUE;    // Item already exits, so TRUE
        }

        genGFree(lpszFile, genGSize(lpszFile));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_CheckFiles (Local Routine)
*
* This is a callback function passed to infEnumItems()
* It checks each filename to see if it is in the .cdf list,
* and if it is up to date.
*
\*****************************************************************************/
BOOL CALLBACK cdf_CheckFiles(
    LPCTSTR lpszName,
    LPCTSTR lpszPath,
    BOOL    bInfFile,
    LPVOID  lpData)
{
    PCDFINFO        pCdfInfo = (PCDFINFO)lpData;
    HANDLE          hFind;
    PFILEITEM       pFileItem;
    LPTSTR          lpszFile;
    LPTSTR          lpszPtr;
    WIN32_FIND_DATA FindFileData;
    LONG            lCompare;
    BOOL            bRet = FALSE;


    // Build fully qualified filename.
    //
    if (lpszFile = genBuildFileName(lpszPath, lpszName, NULL)) {

        // Locate the item, and see if the dates are out-of-sync.
        //
        if (pFileItem = itm_Find(lpszFile, pCdfInfo, TRUE)) {

            hFind = FindFirstFile(lpszFile, &FindFileData);

            if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

                FindClose(hFind);


                // Compare the file-times.
                //
                lCompare = CompareFileTime(&FindFileData.ftLastWriteTime,
                                           &pFileItem->ftLastModify);


                // Skip over INF files since we are generating
                // these in the INF object.
                //
                if (bInfFile || (lCompare == 0))
                    bRet = TRUE;
            }
        }

        genGFree(lpszFile, genGSize(lpszFile));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_get_datfile
*
* Returns the then name of the dat-file.  The name built incorporates
* the sharename to distinguish it from other dat-files in the directory.
* any other files.
*
* <path>\<Share ChkSum>.dat
*
\*****************************************************************************/
LPTSTR cdf_get_datfile(
    LPCTSTR lpszDstPath,
    LPCTSTR lpszShrName)
{
    int   cch;
    TCHAR szName[MIN_CDF_BUFFER];


    // Build the name using the checksum.
    //
    cch = wsprintf(szName, g_szDatName, genChkSum(lpszShrName));

    SPLASSERT((cch < sizeof(szName)));

    return genBuildFileName(lpszDstPath, szName, g_szDotDat);
}


/*****************************************************************************\
* cdf_IsDatCurrent (Local Routine)
*
* Checks the port-name in the dat-file for match.  If they do not, then we
* need to return FALSE to proceed with a new cab-generation.
*
\*****************************************************************************/
BOOL cdf_IsDatCurrent(
    PCDFINFO pCdfInfo)
{
    LPCTSTR lpszPrtName;
    LPCTSTR lpszDstPath;
    LPCTSTR lpszShrName;
    LPTSTR  lpszDatFile;
    LPTSTR  lpszDat;
    LPTSTR  lpszPtr;
    LPTSTR  lpszEnd;
    DWORD   cbSize;
    DWORD   cbRd;
    HANDLE  hFile;
    BOOL    bRet = FALSE;


    // Get the information from the INF-object so we can determine the
    // age of the dat-file.
    //
    lpszDstPath = infGetDstPath(pCdfInfo->hInf);
    lpszPrtName = infGetPrtName(pCdfInfo->hInf);
    lpszShrName = infGetShareName(pCdfInfo->hInf);


    // Build the dat-file-name and open for reading.
    //
    if (lpszDatFile = cdf_get_datfile(lpszDstPath, lpszShrName)) {

        hFile = gen_OpenFileRead(lpszDatFile);

        if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

            cbSize = GetFileSize(hFile, NULL);

            if (lpszDat = (LPTSTR)genGAlloc(cbSize)) {

                if (ReadFile(hFile, lpszDat, cbSize, &cbRd, NULL)) {

                    lpszPtr = lpszDat;

                    while (lpszPtr = genFindChar(lpszPtr, TEXT('/'))) {

                        if (*(++lpszPtr) == TEXT('r')) {

                            lpszPtr++;  // space
                            lpszPtr++;  // quote

                            if (lpszEnd = genFindChar(++lpszPtr, TEXT('\"'))) {

                                *lpszEnd = TEXT('\0');

                                if (lstrcmpi(lpszPtr, lpszPrtName) == 0)
                                    bRet = TRUE;

                                *lpszEnd = TEXT('\"');
                            }

                            break;
                        }


                        // Position pointer to the next flag.
                        //
                        lpszPtr = genFindChar(lpszPtr, TEXT('\n'));
                    }
                }

                genGFree(lpszDat, cbSize);
            }

            CloseHandle(hFile);
        }

        genGFree(lpszDatFile, genGSize(lpszDatFile));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_IsUpToDate (Local Routine)
*
* Determines if the CDF is up-to-date, or needs to be regenerated for
* this printer
*
\*****************************************************************************/
BOOL cdf_IsUpToDate(
    PCDFINFO pCdfInfo)
{
    BOOL bCurrent = FALSE;


    if (genUpdIPAddr()) {

        if (cdf_IsDatCurrent(pCdfInfo)) {

            // Read filelist into CdfInfo structure from .cdf file
            //
            if (cdf_ReadFileList(pCdfInfo)) {

                // Check files in .inf file to see if .cdf is still valid.
                //
                if (infEnumItems(pCdfInfo->hInf, cdf_CheckFiles, (LPVOID)pCdfInfo))
                    bCurrent = TRUE;
            }
        }
    }

    return bCurrent;
}


/*****************************************************************************\
* cdf_EnumICM (Local Routine)
*
* Callback to enumerate all ICM profiles in the BIN-File.  We only need to
* add these profiles to our list of CDF-Files that we package up.
*
\*****************************************************************************/
BOOL CALLBACK cdf_EnumICM(
    LPCTSTR lpszPath,
    LPCTSTR lpszFile,
    LPVOID  lpParm)
{
    return cdf_GetFileList(lpszFile, lpszPath, FALSE, lpParm);
}


/*****************************************************************************\
* cdf_WriteSourceFilesSection (Local Routine)
*
*
\*****************************************************************************/
BOOL cdf_WriteSourceFilesSection(
    PCDFINFO   pCdfInfo,
    LPSRCFILES psfList)
{
    TCHAR szSection[STD_CDF_BUFFER];
    DWORD cch;
    int   idx;
    BOOL  bRet;


    for (idx = 0, bRet = TRUE; psfList; psfList = psfList->pNext) {

        // Build the section name (i.e. SourceFilesX).
        //
        cch = wsprintf(szSection, TEXT("%s%i"), g_szSourceFiles, idx++);

        SPLASSERT((cch < STD_CDF_BUFFER));


        // Write the source file section name in the [SourceFiles]
        // section.
        //
        bRet = cdf_WriteSourceFiles(pCdfInfo->lpszCdfFile,
                                    szSection,
                                    psfList->lpszPath);


        // Write out the [SourceFilesX] section.
        //
        if (bRet) {

            bRet = WritePrivateProfileSection(szSection,
                                              psfList->lpszFiles,
                                              pCdfInfo->lpszCdfFile);
        }
    }

    return bRet;
}


/*****************************************************************************\
* cdf_WriteBinFile (Local Routine)
*
* Writes the .BIN file.
*
\*****************************************************************************/
BOOL cdf_WriteBinFile(
    PCDFINFO pCdfInfo,
    LPCTSTR  lpszDstPath,
    LPCTSTR  lpszDstName)
{
    LPCTSTR lpszFriendlyName;
    LPTSTR  lpszBinFile;
    LPTSTR  lpszBinName;
    HANDLE  hPrinter;
    DWORD   dwCliInfo;
    BOOL    bRet = FALSE;


    if (lpszBinFile = genBuildFileName(lpszDstPath, lpszDstName, g_szDotBin)) {

        if (lpszBinName = genFindRChar(lpszBinFile, TEXT('\\'))) {

            // Increment to the next character for the name.
            //
            lpszBinName++;


            // Retrieve the printer-handle and proceed
            // to write the information to the BIN-File.
            //
            if (lpszFriendlyName = infGetFriendlyName(pCdfInfo->hInf)) {

                if (OpenPrinter((LPTSTR)lpszFriendlyName, &hPrinter, NULL)) {

                    dwCliInfo = infGetCliInfo(pCdfInfo->hInf);

                    // Call the routine to generate the BIN-File.
                    //
                    if (webWritePrinterInfo(hPrinter, lpszBinFile)) {

                        // Add the bin-file to the list of CDF-Files.
                        // Then add ICM-profiles to our list.
                        //
                        if (cdf_GetFileList(lpszBinName, lpszDstPath, FALSE, (LPVOID)pCdfInfo)) {

                            bRet = webEnumPrinterInfo(hPrinter,
                                                      dwCliInfo,
                                                      WEB_ENUM_ICM,
                                                      (FARPROC)cdf_EnumICM,
                                                      (LPVOID)pCdfInfo);
                        }
                    }


                    // Close the printer.
                    //
                    ClosePrinter(hPrinter);
                }
            }
        }

        genGFree(lpszBinFile, genGSize(lpszBinFile));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_WriteCdfCmd (Local Routine)
*
* Writes the .DAT file.
*
\*****************************************************************************/
BOOL cdf_WriteCdfCmd(
    PCDFINFO pCdfInfo,
    LPCTSTR  lpszUncName,
    LPCTSTR  lpszDstPath,
    LPCTSTR  lpszDstName)
{
    HANDLE  hFile;
    LPWSTR  lpszCmd;
    LPTSTR  lpszTmp;
    LPTSTR  lpszBinName;
    LPTSTR  lpszDatFile;
    LPTSTR  lpszDatTmp;
    LPTSTR  lpszFrnName;
    LPCTSTR lpszDrvName;
    LPCTSTR lpszPrtName;
    LPCTSTR lpszInfName;
    LPCTSTR lpszShrName;
    DWORD   dwWr;
    DWORD   cbSize;
    BOOL    bRet = FALSE;


    // Retrive the destination-file info.  These strings have
    // already been validated by the INF object.
    //
    lpszDrvName = infGetDrvName(pCdfInfo->hInf);
    lpszPrtName = infGetPrtName(pCdfInfo->hInf);
    lpszInfName = infGetInfName(pCdfInfo->hInf);
    lpszShrName = infGetShareName(pCdfInfo->hInf);


    // Build the dat-file.
    //
    if (lpszDatFile = cdf_get_datfile(lpszDstPath, lpszShrName)) {

        // This is a temporary duplicate of the (lpszDatFile) that
        // will be written to the cdf-command.  This is necessary so
        // that the client can have a static-name to use when the
        // cab is expanded.
        //
        if (lpszDatTmp = genBuildFileName(lpszDstPath, g_szDatFile, NULL)) {

            if (lpszBinName = genBuildFileName(NULL, lpszDstName, g_szDotBin)) {

                if (lpszFrnName = cdf_BuildFriendlyName(pCdfInfo)) {

                    // Write out the devmode.  If the DEVMODE-file (BIN) was
                    // written correctly, then we will go ahead and generate the
                    // dat-command-file.
                    //
                    if (cdf_WriteBinFile(pCdfInfo, lpszDstPath, lpszDstName)) {

                        cbSize = lstrlen(lpszFrnName)  +
                                 lstrlen(lpszInfName)  +
                                 lstrlen(lpszPrtName)  +
                                 lstrlen(lpszDrvName)  +
                                 lstrlen(lpszUncName)  +
                                 lstrlen(lpszBinName)  +
                                 lstrlen(g_szDatCmd)   +
                                 sizeof(WCHAR);

                        if (lpszTmp = (LPTSTR)genGAlloc(cbSize * sizeof(TCHAR))) {

                            // Build the Data-command.
                            //
                            wsprintf(lpszTmp,
                                     g_szDatCmd,
                                     lpszFrnName,
                                     lpszInfName,
                                     lpszPrtName,
                                     lpszDrvName,
                                     lpszUncName,
                                     lpszBinName);


                            // Open the file for writing.
                            //
                            hFile = gen_OpenFileWrite(lpszDatFile);

                            if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

                                // This is here to assure the file written
                                // is in byte-format.  Otherwise, our strings
                                // written to the file would be in unicode
                                // format.
                                //
#ifdef UNICODE
                                if (lpszCmd = genGAllocStr(lpszTmp)) {
#else
                                if (lpszCmd = genWCFromMB(lpszTmp)) {
#endif
                                    cbSize = (DWORD)SIGNATURE_UNICODE;
                                    WriteFile(hFile, &cbSize, sizeof(WORD), &dwWr, NULL);

                                    cbSize = genGSize(lpszCmd);
                                    WriteFile(hFile, lpszCmd, cbSize, &dwWr, NULL);

                                    genGFree(lpszCmd, genGSize(lpszCmd));
                                }


                                CloseHandle(hFile);


                                // Make a copy of the file to a static name
                                // that will be used in the cdf/cab file.
                                //
                                CopyFile(lpszDatFile, lpszDatTmp, FALSE);


                                // Add the DAT-File to the list of CDF-Files.  Use
                                // the temporary file so that it is a static name
                                // as opposed to our check-sum generated file.
                                //
                                bRet = cdf_GetFileList(g_szDatFile,
                                                       lpszDstPath,
                                                       FALSE,
                                                       (LPVOID)pCdfInfo);
                            }

                            genGFree(lpszTmp, genGSize(lpszTmp));
                        }
                    }

                    genGFree(lpszFrnName, genGSize(lpszFrnName));
                }

                genGFree(lpszBinName, genGSize(lpszBinName));
            }

            genGFree(lpszDatTmp, genGSize(lpszDatTmp));
        }

        genGFree(lpszDatFile, genGSize(lpszDatFile));
    }

    return bRet;
}


/******************************************************************************
** cdf_GenerateSourceFiles (local routine)
**
** Find cases where the source and installed file names are diferent, copy the
** installed file to the cabs directory and rename it to the original target file
** name.
**
*******************************************************************************/
BOOL cdf_GenerateSourceFiles(
    HANDLE   hInf,
    LPCTSTR  lpszDstDir) {

    LPINFINFO       lpInf    = (LPINFINFO)hInf;
    BOOL            bRet     = lpInf != NULL;

    if (bRet) {
        DWORD           dwItems  = lpInf->lpInfItems->dwCount;
        LPINFITEMINFO   lpII     = lpInf->lpInfItems;

        for (DWORD idx = 0; idx < dwItems && bRet; idx++) {
            // We check to see if the file exists as advertised, if it does then we don't
            // change anything, otherwise, we search the system and windows directories to
            // find it, if it exists, we change the path accordingly
            LPTSTR      lpszSource = lpII->aItems[idx].szSource;

            if (*lpszSource) {      // There was a source name, we know it is different
                                    // from the target
                LPTSTR      lpszName      = lpII->aItems[idx].szName;
                LPTSTR      lpszPath      = lpII->aItems[idx].szPath;
                LPTSTR      lpszFile      = genBuildFileName( lpszPath, lpszName, NULL);
                LPTSTR      lpszDestFile  = genBuildFileName( lpszDstDir, lpszSource, NULL);

                if (lpszFile && lpszDestFile) {
                    lstrcpyn( lpszPath, lpszDstDir, MAX_PATH);
                    lstrcpyn( lpszName, lpszSource, INF_MIN_BUFFER);

                    bRet = CopyFile( lpszFile, lpszDestFile, FALSE);
                } else
                    bRet = FALSE;

                if (lpszFile)
                    genGFree(lpszFile, genGSize(lpszFile));

                if (lpszDestFile)
                    genGFree(lpszDestFile, genGSize(lpszDestFile) );
            }
        }
    }
    return bRet;
}



/*****************************************************************************\
* cdf_WriteFilesSection (Local Routine)
*
* Writes the dynamic file information.
*
\*****************************************************************************/
BOOL cdf_WriteFilesSection(
    PCDFINFO pCdfInfo)
{
    TCHAR      szFileX[MIN_CDF_BUFFER];
    LPCTSTR    lpszDstName;
    LPCTSTR    lpszDstPath;
    LPTSTR     lpszUncName;
    LPTSTR     lpszTmp;
    LPTSTR     lpszItem;
    DWORD      cbSize;
    int        idx;
    int        idxFile;
    PFILEITEM  pFileItem;
    LPSRCFILES psfList;
    LPSRCFILES psfItem;
    BOOL       bRet = FALSE;


    static CONST TCHAR s_szFmt0[] = TEXT("\"%s\\%s.webpnp\"");
    static CONST TCHAR s_szFmt1[] = TEXT("\"%s\"");


    if (lpszUncName = cdf_GetUncName(pCdfInfo)) {

        // Retreive the necessary strings from the INF object.  These
        // should already be validated as existing.  Otherwise, the creation
        // of the INF object would've failed.
        //
        lpszDstName = infGetDstName(pCdfInfo->hInf);
        lpszDstPath = infGetDstPath(pCdfInfo->hInf);


        // Build the TargetName and write to the CDF.
        //
        cbSize = lstrlen(lpszDstPath) +
                 lstrlen(lpszDstName) +
                 lstrlen(s_szFmt0)    +
                 1;

        if (lpszTmp = (LPTSTR)genGAlloc(cbSize * sizeof(TCHAR))) {
            wsprintf(lpszTmp, s_szFmt0, lpszDstPath, lpszDstName);
            bRet = cdf_WriteStrings(pCdfInfo->lpszCdfFile, g_szTargetName, lpszTmp);
            genGFree(lpszTmp, genGSize(lpszTmp));
        }


        // Now build cdf-install command; Write it to the CDF.
        //
        cbSize = lstrlen(lpszDstName) + lstrlen(g_szSedCmd) + 1;

        if (bRet && (lpszTmp = (LPTSTR)genGAlloc(cbSize * sizeof(TCHAR)))) {
            wsprintf(lpszTmp, g_szSedCmd, lpszDstName);
            bRet = cdf_WriteStrings(pCdfInfo->lpszCdfFile, g_szAppLaunched, lpszTmp);
            genGFree(lpszTmp, genGSize(lpszTmp));
        }


        // Read in all files and filetimes from .inf file (inf object)
        // Initialize the list.
        //
        itm_DeleteAll(pCdfInfo);
        itm_InitList(pCdfInfo);


        // Add all the files enumerated by the inf object.
        // Note: This enumeration includes the inf file itself, so
        // no need to make a special case for it.
        //
        if (bRet)
            bRet = cdf_GenerateSourceFiles( pCdfInfo->hInf, lpszDstPath );

        if (bRet) {
             if (infEnumItems(pCdfInfo->hInf, cdf_GetFileList, (LPVOID)pCdfInfo)) {


                // Generate the command-line for the URL rundll interface.
                //
                bRet = cdf_WriteCdfCmd(pCdfInfo,
                                       lpszUncName,
                                       lpszDstPath,
                                       lpszDstName);


                // Initialize the pointers/indexes that are used
                // to track our section information.
                //
                idxFile   = 0;
                pFileItem = itm_GetFirst(pCdfInfo);
                psfList   = NULL;


                // If the enumeration succeeded and we have files in the
                // list to process, then proceed to build our sections.
                //
                while (bRet && pFileItem) {

                    // Build our FILEx string.
                    //
                    wsprintf(szFileX, TEXT("FILE%i"), idxFile++);


                    // Write out the quoted-item.
                    //
                    lpszItem = itm_GetString(pFileItem, FI_COL_FILENAME);

                    cbSize = lstrlen(lpszItem) + lstrlen(s_szFmt1) + 1;

                    if (lpszTmp = (LPTSTR)genGAlloc(cbSize * sizeof(TCHAR))) {
                        wsprintf(lpszTmp, s_szFmt1, lpszItem);
                        bRet = cdf_WriteStrings(pCdfInfo->lpszCdfFile, szFileX, lpszTmp);
                        genGFree(lpszTmp, genGSize(lpszTmp));
                    }


                    // Add timestamp to [TimeStamps] section for this file.
                    //
                    if (bRet) {

                        bRet = cdf_WriteTimeStamps(pCdfInfo->lpszCdfFile,
                                                   szFileX,
                                                   pFileItem);
                    }


                    // Look for existence of section (path).  If it exists,
                    // add the file to the section.  Otherwise, create a
                    // new section and add the file.
                    //
                    if (bRet) {

                        lpszItem = itm_GetString(pFileItem, FI_COL_PATH);

                        if ((psfItem = cdf_SFLFind(psfList, lpszItem)) == NULL) {

                            if (psfItem = cdf_SFLAdd(psfList, lpszItem)) {

                                psfList = psfItem;

                            } else {

                                bRet = FALSE;
                            }
                        }
                     }

                    // Add the file to the appropriate section.
                    //
                    if (bRet)
                        bRet = cdf_SFLAddFile(psfItem, szFileX);

                    // Get next file-item.
                    //
                    pFileItem = itm_GetNext(pFileItem);

                }

                // If all went OK in the enumeration, then we can write
                // the sections to the CDF file.
                //


                if (bRet)
                    bRet = cdf_WriteSourceFilesSection(pCdfInfo, psfList);

                    // Free up the Source-Files-List.
                    //
                cdf_SFLFree(psfList);


            } else
                bRet = FALSE;

        }
        genGFree(lpszUncName, genGSize(lpszUncName));
    }

    return bRet;
}


/*****************************************************************************\
* cdf_WriteVersionSection (Local Routine)
*
* Writes the [Version] section in the CDF file.
*
\*****************************************************************************/
BOOL cdf_WriteVersionSection(
    PCDFINFO pCdfInfo)
{
    UINT uCount;
    UINT idx;
    BOOL bRet;

    static struct {

        LPCTSTR lpszKey;
        LPCTSTR lpszStr;

    } aszVer[] = {

        g_szClass     , g_szIExpress,
        g_szSEDVersion, g_szSEDVersionNumber
    };


    // Write out [Version] values.
    //
    uCount = sizeof(aszVer) / sizeof(aszVer[0]);

    for (idx = 0, bRet = TRUE; (idx < uCount) && bRet; idx++) {

        bRet = WritePrivateProfileString(g_szVersionSect,
                                         aszVer[idx].lpszKey,
                                         aszVer[idx].lpszStr,
                                         pCdfInfo->lpszCdfFile);
    }

    return bRet;
}


/*****************************************************************************\
* cdf_WriteOptionsSection (Local Routine)
*
* Writess the [Options] section in the CDF file.
*
\*****************************************************************************/
BOOL cdf_WriteOptionsSection(
    PCDFINFO pCdfInfo)
{
    UINT uCount;
    UINT idx;
    BOOL bRet;

    static struct {

        LPCTSTR lpszKey;
        LPCTSTR lpszStr;

    } aszOpt[] = {

        g_szPackagePurpose    , g_szCreateCAB,
        g_szExtractorStub     , g_szNone,
        g_szShowWindow        , g_sz0,
        g_szUseLongFileName   , g_sz1,
        g_szHideAnimate       , g_sz1,
        g_szRebootMode        , g_szNoReboot,
        g_szCompressionQuantum, g_szCompressionQuantVal,
        g_szTargetName        , g_szTargetNameSection,
        g_szAppLaunched       , g_szAppLaunchedSection,
        g_szSourceFiles       , g_szSourceFiles,
        g_szPostInstallCmd    , g_szNone,
        g_szCompressionType   , g_szCompressTypeVal,
        g_szCompressionMemory , g_szCompressionValue
    };


    // Write out [Options] values.
    //
    uCount = sizeof(aszOpt) / sizeof(aszOpt[0]);

    for (idx = 0, bRet = TRUE; (idx < uCount) && bRet; idx++) {

        bRet = WritePrivateProfileString(g_szOptions,
                                         aszOpt[idx].lpszKey,
                                         aszOpt[idx].lpszStr,
                                         pCdfInfo->lpszCdfFile);
    }


    return bRet;
}


/*****************************************************************************\
* cdf_Generate
*
* Creates a CDF file and writes it to disk.
*
\*****************************************************************************/
BOOL cdf_Generate(
    PCDFINFO pCdfInfo)
{
    if (cdf_WriteVersionSection(pCdfInfo) &&
        cdf_WriteOptionsSection(pCdfInfo) &&
        cdf_WriteFilesSection(pCdfInfo)) {

        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************\
* cdfCreate
*
* Creates a CDF object.
*
* Parameters
* ----------
*   hinf - Handle to a INF object.  The CDF will inherit information from
*          the INF.
*
\*****************************************************************************/
HANDLE cdfCreate(
    HANDLE hinf,
    BOOL   bSecure)
{
    PCDFINFO pCdfInfo;


    if (pCdfInfo = (PCDFINFO)genGAlloc(sizeof(CDFINFO))) {

        // Initialize object-variables.
        //
        pCdfInfo->hInf    = hinf;
        pCdfInfo->bSecure = bSecure;

        return (HANDLE) pCdfInfo;
    }

    return NULL;
}


/*****************************************************************************\
* cdfProcess
*
* Process the CDF object.
*
\*****************************************************************************/
BOOL cdfProcess(
    HANDLE hcdf)
{
    HANDLE   hFile;
    PCDFINFO pCdfInfo;
    DWORD    dwErr;

    if (pCdfInfo = (PCDFINFO)hcdf) {

        if (pCdfInfo->lpszCdfFile = cdf_GetCdfFile(pCdfInfo)) {

            // Check for existence of .cdf file
            //
            hFile = gen_OpenFileRead(pCdfInfo->lpszCdfFile);

            if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

                // If we DO have a .cdf for this printer/architecture,
                // check if it is up to date.
                //
                CloseHandle(hFile);


                // If the .cdf we have is still up to
                // date, we are done.
                //
                if (cdf_IsUpToDate(pCdfInfo)) {

                    return TRUE;

                } else {

                    // Delete the old .cdf if it exists
                    //
                    DeleteFile(pCdfInfo->lpszCdfFile);

CdfGenerate:
                    // Generate a new one.
                    //
                    if (cdf_Generate(pCdfInfo))
                        return TRUE;
                }

            } else {

                dwErr = GetLastError();


                // Force an update of our machine ip-addr.  Usually,
                // this is called in the cdf_IsUpToDat() to verify
                // the machine hasn't changed ip-addresses.
                //
                genUpdIPAddr();


                // If we don't have a CDF already, generate one now.
                //
                if (dwErr == ERROR_FILE_NOT_FOUND)
                    goto CdfGenerate;
            }
        }

        cdfSetError(pCdfInfo,GetLastError());
    }

    return FALSE;
}


/*****************************************************************************\
* cdfDestroy
*
* Destroys the CDF object.
*
\*****************************************************************************/
BOOL cdfDestroy(
    HANDLE hcdf)
{
    PCDFINFO pCdfInfo;
    BOOL     bFree = FALSE;


    if (pCdfInfo = (PCDFINFO)hcdf) {

        // Free up any allocated objects.
        //
        if (pCdfInfo->lpszCdfFile)
            genGFree(pCdfInfo->lpszCdfFile, genGSize(pCdfInfo->lpszCdfFile));

        // Walk the list and free the file-item information.
        //
        itm_DeleteAll(pCdfInfo);

        bFree = genGFree(pCdfInfo, sizeof(CDFINFO));
    }

    return bFree;
}


/*****************************************************************************\
* cdfGetName
*
* Returns the name of the CDF file.  This will not include any path
* information.  This routine derives the filename from the stored full-path
* name in the CDF object.
*
\*****************************************************************************/
LPCTSTR cdfGetName(
    HANDLE hcdf)
{
    PCDFINFO pCdfInfo;
    LPCTSTR  lpszName = NULL;


    if (pCdfInfo = (PCDFINFO)hcdf) {

        if (lpszName = genFindRChar(pCdfInfo->lpszCdfFile, TEXT('\\')))
            lpszName++;
    }

    return lpszName;
}


/*****************************************************************************\
* cdfGetModTime
*
* Returns the time the CDF file was last modified.
*
\*****************************************************************************/
BOOL cdfGetModTime(
    HANDLE     hcdf,
    LPFILETIME lpftMod)
{
    HANDLE   hFile;
    PCDFINFO pCdfInfo;
    BOOL     bRet = FALSE;


    // Fill in struct-info.
    //
    lpftMod->dwLowDateTime  = 0;
    lpftMod->dwHighDateTime = 0;


    // Check the pointer for validity.
    //
    if (pCdfInfo = (PCDFINFO)hcdf) {

        // File should exist at this time, since cdfCreate should always
        // create the file.  Return false (error) if can't open file.
        //
        hFile = gen_OpenFileRead(pCdfInfo->lpszCdfFile);

        if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

            // Get the file creation time.
            //
            bRet = GetFileTime(hFile, NULL, NULL, lpftMod);

            CloseHandle(hFile);
        }
    }

    return bRet;
}

/*************************************************************************************
** cdfCleanUpSourceFiles
**
** This runs through all of the files that we returned from the inf file and in the
** case where there was a source we see if it is in the PrtCabs directory, if it is
** we delete it
**
*************************************************************************************/
VOID cdfCleanUpSourceFiles(
    HANDLE      hInf) {

    LPINFINFO       lpInf    = (LPINFINFO)hInf;

    if (lpInf) {
        DWORD           dwItems     = lpInf->lpInfItems->dwCount;
        LPINFITEMINFO   lpII        = lpInf->lpInfItems;
        LPCTSTR          lpszDstPath = infGetDstPath(hInf);
        // This can't be NULL or we wouldn't have allocated the INF structure

        if (*lpszDstPath) {  // Might not have been set though
            for (DWORD idx = 0; idx < dwItems; idx++) {
                // We check to see if the file exists as advertised, if it does then we don't
                // change anything, otherwise, we search the system and windows directories to
                // find it, if it exists, we change the path accordingly
                LPTSTR      lpszSource = lpII->aItems[idx].szSource;

                if (*lpszSource) {  // If there was a source file different to the target
                    LPTSTR      lpszName    = lpII->aItems[idx].szName;

                    if (!lstrcmp(lpszName,lpszSource)) { // If we renamed the target to the source
                        LPTSTR      lpszPath    = lpII->aItems[idx].szPath;

                        if (!lstrcmp(lpszPath,lpszDstPath)) { // If we set the path on the source
                            LPTSTR lpszFile = (LPTSTR)genBuildFileName(lpszPath, lpszName, NULL);

                            if (lpszFile) {
                                WIN32_FIND_DATA FindFileData;
                                HANDLE hFind = FindFirstFile(lpszFile, &FindFileData);

                                if (hFind && (hFind != INVALID_HANDLE_VALUE)) {
                                    FindClose(hFind);
                                    DeleteFile(lpszFile);
                                }

                                genGFree(lpszFile, genGSize(lpszFile));
                            }   // This is cleanup code, no point in failing it
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\gencab.cxx ===
/*****************************************************************************\
* MODULE: gencab.c
*
* The module contains routines for generating a self-extracting CAB file
* for the IExpress utility.  This relies on the cdfCreate and infCreate
* to create the objects for the IExpress process.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 <chriswil>  Created.
*
\*****************************************************************************/

#include "pch.h"
#include "spool.h"
#include <initguid.h>   // To define the IIS Metabase GUIDs used in this file. Every other file defines GUIDs as extern, except here where we actually define them in initguid.h.
#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines

#define CAB_TIMEOUT 1000

/*****************************************************************************\
* Critical Section Handling
*
\*****************************************************************************/

DWORD gdwCritOwner = 0;

VOID cab_enter_crit(VOID)
{
    EnterCriticalSection(&g_csGenCab);

    gdwCritOwner = GetCurrentThreadId();
}

VOID cab_leave_crit(VOID)
{
    gdwCritOwner = 0;

    LeaveCriticalSection(&g_csGenCab);
}

VOID cab_check_crit(VOID)
{
    DWORD dwCurrent = GetCurrentThreadId();

    SPLASSERT((dwCurrent == gdwCritOwner));
}

#define EnterCABCrit() cab_enter_crit()
#define LeaveCABCrit() cab_leave_crit()
#define CheckCABCrit() cab_check_crit()


/*****************************************************************************\
* cab_SetClientSecurity (Local Routine)
*
* This routine sets the thread security so that it has max-privileges.
*
\*****************************************************************************/
HANDLE cab_SetClientSecurity(VOID)
{
    HANDLE hToken;
    HANDLE hThread = GetCurrentThread();

    if (OpenThreadToken(hThread, TOKEN_IMPERSONATE, TRUE, &hToken)) {

        if (SetThreadToken(&hThread, NULL)) {

            return hToken;
        }

        CloseHandle(hToken);
    }

    return NULL;
}


/*****************************************************************************\
* cab_ResetClientSecurity (Local Routine)
*
* This routine resets the client-security to the token passed in.  This
* is called in order to set the thread to the original security attributes.
*
\*****************************************************************************/
BOOL cab_ResetClientSecurity(
    HANDLE hToken)
{
    BOOL bRet;

    bRet = SetThreadToken(NULL, hToken);

    CloseHandle(hToken);

    return bRet;
}


/*****************************************************************************\
* cab_iexpress_sync (Local Routine)
*
* This routine sychronizes the process and won't return until the process
* is done generating the CAB executable.
*
\*****************************************************************************/
BOOL cab_iexpress_sync(
    HANDLE hProcess)
{
    DWORD dwObj;
    DWORD dwExitCode;

    while (TRUE) {

        dwObj = WaitForSingleObject(hProcess, INFINITE);


        // Look for the exit type.
        //
        switch (dwObj) {

        // The process handle triggered the wait.  Let's get the
        // exit-code and return whether the success.  Otherwise,
        // drop through and return the failure.
        //
        case WAIT_OBJECT_0:
            GetExitCodeProcess(hProcess, &dwExitCode);

            if (dwExitCode == 0)
                return TRUE;


        // Something failed in the call.  We failed.
        //
        case WAIT_FAILED:
            return FALSE;
        }
    }
}


/*****************************************************************************\
* cab_force_delete_file
*
* Reset a files attributes before deleting it. We copied them to the temp dir
* so we can delete them no matter what.
*
\*****************************************************************************/
VOID cab_force_delete_file(
    LPCTSTR lpszFileName)
{
    SetFileAttributes( lpszFileName, FILE_ATTRIBUTE_NORMAL );
    DeleteFile( lpszFileName );
}


/*****************************************************************************\
* cab_cleanup_files
*
* Cleanup any files left-over in our generation process.  Particularly,
* this will remove cab-files.
*
\*****************************************************************************/
VOID cab_cleanup_files(
    LPCTSTR lpszDstPath)
{
    TCHAR           szAllExt[MIN_CAB_BUFFER];
    HANDLE          hFind;
    DWORD           idx;
    DWORD           cItems;
    LPTSTR          lpszCurDir;
    WIN32_FIND_DATA wfd;


    static LPCTSTR s_szFiles[] = {

        g_szDotInf,
        g_szDotBin,
        g_szDotCat
    };



    // Put us into the destination directory where we
    // want to cleanup the files.
    //
    if (lpszCurDir = genGetCurDir()) {

        SetCurrentDirectory(lpszDstPath);

        // Delete the temporary dat-file used in building
        // the cdf-file
        //
        cab_force_delete_file(g_szDatFile);


        // Delete certain extension files.
        //
        cItems = sizeof(s_szFiles) / sizeof(s_szFiles[0]);

        for (idx = 0; idx < cItems; idx++) {

            wsprintf(szAllExt, TEXT("*%s"), s_szFiles[idx]);

            hFind = FindFirstFile(szAllExt, &wfd);

            if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

                do {

                    cab_force_delete_file(wfd.cFileName);

                } while (FindNextFile(hFind, &wfd));

                FindClose(hFind);
            }
        }

        SetCurrentDirectory(lpszCurDir);

        genGFree(lpszCurDir, genGSize(lpszCurDir));
    }

    return;
}


/*****************************************************************************\
* cab_rename_cab
*
* Renames the .CAB to the dstname.
*
\*****************************************************************************/
BOOL cab_rename_cab(
    LPCTSTR lpszDstName)
{
    LPTSTR lpszSrc;
    LPTSTR lpszDst;
    BOOL   bRet = FALSE;


    if (lpszSrc = genBuildFileName(NULL, lpszDstName, g_szDotCab)) {

        if (lpszDst = genBuildFileName(NULL, lpszDstName, g_szDotIpp)) {

            bRet = MoveFileEx(lpszSrc, lpszDst, MOVEFILE_REPLACE_EXISTING);

            genGFree(lpszDst, genGSize(lpszDst));
        }

        genGFree(lpszSrc, genGSize(lpszSrc));
    }

    return bRet;
}


/*****************************************************************************\
* cab_iexpress_exec (Local Routine)
*
* This exec's the IExpress utility to generate the self-extracting CAB
* file.
*
\*****************************************************************************/
BOOL cab_iexpress_exec(
    LPCTSTR lpszCabDir,
    LPCTSTR lpszDstName,
    LPCTSTR lpszSedFile)
{
    PROCESS_INFORMATION pi;
    STARTUPINFO         sti;
    LPTSTR              lpszCmd;
    DWORD               cbSize;
    LPTSTR              lpszOldDir;
    BOOL                bSuccess = FALSE;

    TCHAR               szWindowDir[MAX_PATH];
    DWORD               dwWinDirLen = 0;

    if (dwWinDirLen = GetSystemWindowsDirectory (szWindowDir, MAX_PATH))
    {
        if (szWindowDir[dwWinDirLen - 1] == TEXT ('\\'))
        {
            szWindowDir[dwWinDirLen - 1] = 0;
        }

        // Calculate enough space to hold the command-line arguments.
        //
        cbSize = (dwWinDirLen + lstrlen(lpszSedFile) + lstrlen(g_szCabCmd) + 1) * sizeof(TCHAR);


        // Allocate the command-line for the create-process call.
        //
        if (lpszCmd = (LPTSTR)genGAlloc(cbSize)) {

            // Initialize startup-info fields.
            //
            memset(&sti, 0, sizeof(STARTUPINFO));
            sti.cb = sizeof(STARTUPINFO);


            // Build the command-line string that exec's IExpress.
            //
            wsprintf(lpszCmd, g_szCabCmd, szWindowDir, lpszSedFile);


            // Change the directory to the cab/sed directory.  It
            // appears that IExpress requires this to generate.
            //
            if (lpszOldDir = genGetCurDir()) {

                SetCurrentDirectory(lpszCabDir);


                // Exec the process.
                //
                if (EXEC_PROCESS(lpszCmd, &sti, &pi)) {

                    CloseHandle(pi.hThread);

                    // This will wait until the process if finished generating
                    // the file.  The return from this indicates whether the
                    // generation succeeded or not.
                    //
                    if (cab_iexpress_sync(pi.hProcess))
                        bSuccess = cab_rename_cab(lpszDstName);

                    CloseHandle(pi.hProcess);
                }


                // Restore our current-directory and free up any strings.
                //
                SetCurrentDirectory(lpszOldDir);

                genGFree(lpszOldDir, genGSize(lpszOldDir));
            }

            genGFree(lpszCmd, cbSize);
        }
    }

    return bSuccess;
}


/*****************************************************************************\
* cab_get_modtime
*
* Returns the modified-time of the CAB file.  This can be used to determine
* whether this is out of date with other files.
*
\*****************************************************************************/
BOOL cab_get_modtime(
    LPTSTR     lpszOutPath,
    LPFILETIME lpft)
{
    HANDLE hFile;
    BOOL   bRet = FALSE;


    // Open the file for reading.
    //
    hFile = gen_OpenFileRead(lpszOutPath);


    // If the file exists and was opened, go get the time.
    //
    if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

        bRet = GetFileTime(hFile, NULL, NULL, lpft);

        CloseHandle(hFile);
    }

    return bRet;
}


/*****************************************************************************\
* cab_get_drvname (Local Routine)
*
* This routine attempts to open the printer, and retrieve the printer
* driver-name associated with the FriendlyName.  This returns to pointers
* to a driver and a share-name.
*
\*****************************************************************************/
BOOL cab_get_drvname(
    LPCTSTR lpszFriendlyName,
    LPTSTR* lpszDrvName,
    LPTSTR* lpszShrName,
    DWORD   idxPlt
    )
{
    HANDLE           hPrinter;
    LPPRINTER_INFO_2 lppi;
    DWORD            cbBuf;
    DWORD            cbNeed;
    BOOL             bRet = FALSE;


    // Initialize the pointers for the fail-case.
    //
    *lpszShrName = NULL;
    *lpszDrvName = NULL;


    // Open the printer and use the handle to query the printer for
    // the driver-name.
    //
    if (OpenPrinter((LPTSTR)lpszFriendlyName, &hPrinter, NULL)) {

        // First let's see how big our buffer will need to
        // be in order to hold the PRINTER_INFO_2.
        //
        cbBuf = 0;
        GetPrinter(hPrinter, PRT_LEV_2, NULL, 0, &cbBuf);


        // Allocate storage for holding the print-info structure.
        //
        if (cbBuf && (lppi = (LPPRINTER_INFO_2)genGAlloc(cbBuf))) {

            if (GetPrinter(hPrinter, PRT_LEV_2, (LPBYTE)lppi, cbBuf, &cbNeed)) {

                //If this is a Win9X client make sure the driver name is correct
                if ( genIsWin9X(idxPlt) )
                {
                    // Call get printer driver to get the actual driver name for Win9X
                    DWORD rc, cbNeeded;
                    GetPrinterDriver( hPrinter, (LPTSTR) genStrCliEnvironment(idxPlt), 3,
                                      NULL, 0, &cbNeeded);

                    rc = GetLastError();
                    if ( rc == ERROR_INSUFFICIENT_BUFFER )
                    {
                        LPBYTE pData;
                        DWORD dwSize = cbNeeded;

                        if ( pData = (LPBYTE) genGAlloc(cbNeeded) )
                        {
                            if ( GetPrinterDriver( hPrinter, (LPTSTR) genStrCliEnvironment(idxPlt), 3,
                                                   pData, dwSize, &cbNeeded) )
                            {
                                PDRIVER_INFO_3 pDriver = (PDRIVER_INFO_3) pData;
                                *lpszDrvName = genGAllocStr(pDriver->pName);
                            }
                            genGFree( pData, dwSize );
                        }
                    }
                    else
                        *lpszDrvName = genGAllocStr(lppi->pDriverName);
                }
                else
                    *lpszDrvName = genGAllocStr(lppi->pDriverName);

                if ( *lpszDrvName ) {

                    if (*lpszShrName = genGAllocStr(lppi->pShareName)) {

                        bRet = TRUE;

                    } else {

                        genGFree(*lpszDrvName, genGSize(*lpszDrvName));

                        *lpszDrvName = NULL;
                    }
                }
            }

            genGFree(lppi, cbBuf);
        }

        ClosePrinter(hPrinter);
    }

    return bRet;
}


/*****************************************************************************\
* cab_get_dstname
*
* Returns the then name of the destination-files.  The name built
* incorporates the platform/version so that it is not duplicated with
* any other files.
*
* <Share ChkSum><Arch><Ver>.webpnp
*
* i.e. <share chksum>AXP2 - NT Alpha 4.0
*      <share chksum>A863 - NT x86   5.0
*      <share chksum>AXP3 - NT Alpha 5.0
*      <share chksum>W9X0 - Win9X
*
\*****************************************************************************/
LPTSTR cab_get_dstname(
    DWORD   idxPlt,
    DWORD   idxVer,
    LPCTSTR lpszShr)
{
    int     cch;
    int     cchBuf;
    LPCTSTR lpszPlt;
    LPTSTR  lpszName = NULL;


    // Get the platform requested for the client.
    //
    if (lpszPlt = genStrCliCab(idxPlt)) {

        cchBuf = lstrlen(lpszPlt) + MIN_CAB_BUFFER;


        // Build the cabname according to platform and version.
        //
        if (lpszName = (LPTSTR)genGAlloc(cchBuf * sizeof(TCHAR))) {

            cch = wsprintf(lpszName, g_szCabName, genChkSum(lpszShr), lpszPlt, idxVer);

            SPLASSERT((cch < cchBuf));
        }
    }

    return lpszName;
}


/*****************************************************************************\
* cab_get_name
*
* Returns the name of the returned-file.
*
\*****************************************************************************/
VOID cab_get_name(
    LPCTSTR lpszDstName,
    LPCTSTR lpszShrName,
    LPTSTR  lpszName)
{
    DWORD cch;

    cch = wsprintf(lpszName, TEXT("/printers/%s/%s%s"), g_szPrtCabs, lpszDstName, g_szDotIpp);

    SPLASSERT((cch < MAX_PATH));

    return;
}


/*****************************************************************************\
* cab_get_webdir
*
* Returns the virtual-root-directory where the cab-files are to be generated
* and stored.
*
\*****************************************************************************/
LPTSTR cab_get_webdir(VOID)
{
    BOOL    bRet = FALSE;
    HRESULT hr;                         // com error status
    METADATA_HANDLE hMeta = NULL;       // handle to metabase
    CComPtr<IMSAdminBase> pIMeta;       // ATL smart ptr
    DWORD dwMDRequiredDataLen;
    METADATA_RECORD mr;
    HANDLE  hToken = NULL;
    LPTSTR  lpszDir = NULL;
    TCHAR   szBuf[MAX_CAB_BUFFER];

    // Need to revert to our service credential to be able to read IIS Metabase.
    hToken = RevertToPrinterSelf();

    // Create a instance of the metabase object
    hr=::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMeta);


    if( SUCCEEDED( hr )) {

        // open key to ROOT on website #1 (default)
        hr = pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                             g_szMetabasePath,
                             METADATA_PERMISSION_READ,
                             CAB_TIMEOUT,
                             &hMeta);
        if( SUCCEEDED( hr )) {

            mr.dwMDIdentifier = MD_VR_PATH;
            mr.dwMDAttributes = 0;
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = STRING_METADATA;
            mr.dwMDDataLen    = sizeof(szBuf);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(szBuf);

            hr = pIMeta->GetData( hMeta, L"", &mr, &dwMDRequiredDataLen );
            pIMeta->CloseKey( hMeta );

            if( SUCCEEDED( hr ))
            {
                lpszDir = genBuildFileName(szBuf, g_szPrtCabs, NULL);

            }
        }
    }

    if (hToken)
    {
        ImpersonatePrinterClient(hToken);
    }

    return lpszDir;
}

/*****************************************************************************\
* cab_get_dstpath
*
* Returns a directory string where the cabinet files are to be generated.
*
\*****************************************************************************/
LPTSTR cab_get_dstpath(VOID)
{
    HANDLE hDir;
    LPTSTR lpszDir;


    // First, we need to find the virtual-directory-root the cab files
    // are located.
    //
    if (lpszDir = cab_get_webdir()) {

        // Make sure the directory exists, or we can create it.
        //
        hDir = gen_OpenDirectory(lpszDir);

        if (hDir && (hDir != INVALID_HANDLE_VALUE)) {

            CloseHandle(hDir);

        } else {

            if (CreateDirectory(lpszDir, NULL) == FALSE) {

                genGFree(lpszDir, genGSize(lpszDir));

                lpszDir = NULL;
            }
        }
    }

    return lpszDir;
}


/*****************************************************************************\
* GenerateCAB
*
* Main entry-point for generating the CAB file.
*
* Parameters
* ----------
*   lpszFriendlyName - Name of printer (shared-name).
*   lpszPortName     - Name of output port.
*   dwCliInfo        - Client platform/architecture/version information.
*   lpszOutName      - This is returned to the caller specifying the output.
*
\*****************************************************************************/
DWORD GenerateCAB(
    LPCTSTR lpszFriendlyName,
    LPCTSTR lpszPortName,
    DWORD   dwCliInfo,
    LPTSTR  lpszOutName,
    BOOL    bSecure)
{
    INFGENPARM infParm;
    HANDLE     hToken;
    HANDLE     hsed;
    HANDLE     hinf;
    FILETIME   ftSED;
    FILETIME   ftCAB;
    DWORD      idxVer;
    DWORD      idxPlt;
    BOOL       bSed;
    BOOL       bCab;
    LPTSTR     lpszFullName;
    LPTSTR     lpszDrvName = NULL;
    LPTSTR     lpszShrName = NULL;
    LPTSTR     lpszDstName = NULL;
    LPTSTR     lpszDstPath = NULL;
    LPTSTR     lpszFrnName = NULL;
    LPCTSTR    lpszSedFile;
    DWORD      dwRet = HSE_STATUS_ERROR;
    DWORD      dwFailure = ERROR_SUCCESS;


    // Initialize the security-token so that we will have
    // max-privileges during the file-creation.
    //
    if ((hToken = cab_SetClientSecurity()) == NULL) {

        DBGMSG(DBG_ERROR, ("GenerateCab : Access Denied"));
        goto RetCabDone;
    }


    // Get the platform and version of the client (map to an index
    // into tables).  Validate the indexes to assure the information
    // is valid.
    //
    idxPlt = genIdxCliPlatform(dwCliInfo);
    idxVer = genIdxCliVersion(dwCliInfo);

#ifdef WIN95TST
// WORK : ChrisWil

if (idxPlt == IDX_W9X) {

    lstrcpy(lpszOutName, TEXT("/hplaserj/cab_w9x0.webpnp"));
    return HSE_STATUS_SUCCESS;
}

#endif


    if ((idxPlt == IDX_UNKNOWN) || (idxVer == IDX_UNKNOWN)) {

        dwFailure = ERROR_BAD_ENVIRONMENT;
        DBGMSG(DBG_ERROR, ("GenerateCab : Unsupported client architecture/version"));
        goto RetCabDone;
    }


    // Get the directory where the cab-files will be placed.
    //
    if ((lpszDstPath = cab_get_dstpath()) == NULL)
        goto RetCabDone;


    // Build a cluster-capable friendly-name.
    //
    if ((lpszFrnName = genFrnName(lpszFriendlyName)) == NULL)
        goto RetCabDone;


    // Get the driver information about the friendly-name.
    //
    if (cab_get_drvname(lpszFrnName, &lpszDrvName, &lpszShrName, idxPlt) == FALSE)
        goto RetCabDone;


    // Get the destination-name.
    //
    if ((lpszDstName = cab_get_dstname(idxPlt, idxVer, lpszShrName)) == NULL)
        goto RetCabDone;


    // Fill in the inf-input-parameters.  These values should be
    // validated at this point.
    //
    infParm.lpszFriendlyName = lpszFrnName;
    infParm.lpszShareName    = lpszShrName;
    infParm.lpszPortName     = lpszPortName;
    infParm.idxPlt           = idxPlt;
    infParm.idxVer           = idxVer;
    infParm.dwCliInfo        = dwCliInfo;
    infParm.lpszDrvName      = lpszDrvName;
    infParm.lpszDstName      = lpszDstName;
    infParm.lpszDstPath      = lpszDstPath;


    // Grab the critical-section while we deal with generating
    // the files for the driver-install.
    //
    EnterCABCrit();


    // Call to have the INF/CDF files generated.  If
    // all goes well, then the SED file can be generated
    // using the INF as input.
    //
    if (hinf = infCreate(&infParm)) {

        // We created an INF object. Now process the INF
        if ( infProcess(hinf) ) {

            // Got good INF so now work on CDF
            if (hsed = cdfCreate(hinf, bSecure)) {

                // We created a CDF object. Now process the CDF
                if ( cdfProcess(hsed) ) {

                    // Allocate a string representing the full-path-name of
                    // the generated executable.
                    //
                    lpszFullName = genBuildFileName(lpszDstPath, lpszDstName, g_szDotIpp);

                    if (lpszFullName) {

                        // Get the name of the directive file that we'll be using
                        // to lauch the iexpress-package with.  Do not delete this
                        // pointer as it is handled by the SED object.
                        //
                        if (lpszSedFile = cdfGetName(hsed)) {

                            // Retrieve modified dates so that we can determine whether
                            // to generate a new-CAB or return an existing one.  If the
                            // calls return FALSE, the we can assume a file doesn't
                            // exist, so we'll generate an new one anyway.
                            //
                            bSed = cdfGetModTime(hsed, &ftSED);
                            bCab = cab_get_modtime(lpszFullName, &ftCAB);


                            // Get the name of the Cab-File that will be
                            // generated (or returned).  This is relative to the
                            // wwwroot path and is in the form /share/printer.
                            //
                            cab_get_name(lpszDstName, lpszShrName, lpszOutName);


                            // If the bCabMod is TRUE (meaning we have a CAB), and the
                            // SED is not newer than the CAB, then we really only need
                            // to return the existing CAB.  Otherwise, some files
                            // must have changed.
                            //
                            if ((bSed && bCab) && (CompareFileTime(&ftSED, &ftCAB) <= 0)) {

                                goto RetCabName;

                            } else {

                                if (cab_iexpress_exec(lpszDstPath, lpszDstName, lpszSedFile)) {
RetCabName:
                                    dwRet = HSE_STATUS_SUCCESS;
                                }
                                else
                                   dwFailure = ERROR_CANNOT_MAKE;
                            }
                        }
                        else   // If cdfGetName
                           dwFailure = GetLastError();

                        genGFree(lpszFullName, genGSize(lpszFullName));
                    }
                    else   //  If lpszFullName
                       dwFailure = GetLastError();

                }
                else   // If cdfProcess()
                   dwFailure = cdfGetError(hsed);   // Get saved error

                cdfCleanUpSourceFiles(hinf);        // Even if cdfProcess fails it might have
                                                    // partialy generated some temporary files
                cdfDestroy(hsed);
            }
            else   // If cdfCreate
               dwFailure = GetLastError();
        }
        else   // If infProcess()
           dwFailure = infGetError(hinf);   // Get saved error

        infDestroy(hinf);
    }
    else   // If infCreate
       dwFailure = GetLastError();


    // Cleanup the files generated during processing.
    //
    cab_cleanup_files(lpszDstPath);


RetCabDone:

    // If something failed but we don't know what yet.. Get the error
    if ( (dwRet == HSE_STATUS_ERROR) && ( dwFailure == ERROR_SUCCESS ) )
       dwFailure = GetLastError();

    // Free our strings allocated through this scope.
    //
    if (lpszFrnName)
        genGFree(lpszFrnName, genGSize(lpszFrnName));

    if (lpszDrvName)
        genGFree(lpszDrvName, genGSize(lpszDrvName));

    if (lpszDstName)
        genGFree(lpszDstName, genGSize(lpszDstName));

    if (lpszShrName)
        genGFree(lpszShrName, genGSize(lpszShrName));

    if (lpszDstPath)
        genGFree(lpszDstPath, genGSize(lpszDstPath));

    if (hToken)
        cab_ResetClientSecurity(hToken);

    LeaveCABCrit();

    if (dwFailure != ERROR_SUCCESS)
       SetLastError(dwFailure);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\genmem.h ===
/*****************************************************************************\
* MODULE: genmem.h
*
*   This is the header module for mem.c.  This contains valuable memory
*   management wrappers.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* history:
*   22-Nov-1996 <chriswil> created.
*
\*****************************************************************************/

// Identifier at the end of the memory-block to check when
// verifying memory-overwrites.
//
#define DEADBEEF 0xdeadbeef


// Memory Routines.
//
LPVOID genGAlloc(DWORD);
BOOL   genGFree(LPVOID, DWORD);
LPVOID genGRealloc(LPVOID, DWORD, DWORD);
LPWSTR genGAllocWStr(LPCWSTR);
LPTSTR genGAllocStr(LPCTSTR);
LPVOID genGCopy(LPVOID);
DWORD  genGSize(LPVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\genmem.cxx ===
/*****************************************************************************\
* MODULE: genmem.c
*
*   This module contains memory-management wrapper routines.  These provide
*   debugging checks if needed.
*
*   The blocks allocated with these routines include two DWORD entrys for
*   marking the head and tail of the allocation block.  This is structured as
*   follows:
*
*         DWORD              cbSize             DWORD
*      -------------------------------------------------
*     | Block Size |  ...Alocated Memory...  | DEADBEEF |
*      -------------------------------------------------
*                  ^
*                  |
*                   Allocations return this pointer.
*
*   routines
*   --------
*   genGAlloc
*   genGFree
*   genGRealloc
*   genGAllocStr
*   genGCopy
*   genGSize
*
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* history:
*   22-Nov-1996 <chriswil> created.
*
\*****************************************************************************/

#include "pch.h"

#ifdef DEBUG

/*****************************************************************************\
* mem_validate
*
*   Checks the block of memory for any overwrites or size mismatches.
*
\*****************************************************************************/
LPVOID gen_validate(
    PDWORD_PTR lpMem,
    DWORD   cbSize)
{
    DWORD   cbNew;
    PDWORD_PTR lpTail;
    PDWORD_PTR lpHead;
    LPVOID  lpRet = NULL;


    // Bad thing if a null-pointer is passed in.
    //
    if (lpMem != NULL) {

        // Reset the block to the true position.
        //
        lpHead = --lpMem;


        // Calculate the "real" size of our allocated block and round it
        // up to an even number of DWORD_PTR s.
        //
        cbNew = cbSize + (2 * sizeof(DWORD_PTR));

        if (cbNew & 7)
            cbNew += sizeof(DWORD_PTR) - (cbNew & 7);


        // Get the tail location.
        //
        lpTail = (DWORD_PTR)((LPBYTE)lpHead + cbNew - sizeof(DWORD_PTR));


        // Compare the values that memAlloc stored at the beginning
        // and end of the block
        //
        SPLASSERT(*lpHead == cbSize);
        SPLASSERT(*lpTail == DEADBEEF);

        lpRet = (LPVOID)lpHead;
        } else {

        DBGMSG(DBG_ERROR, ("gen_validate: Bad Pointer"));
    }

    return lpRet;
}

#else

/*****************************************************************************\
* gen_validate (Non-Debug)
*
*   On non-debug builds, we will just return the head ptr.
*
\*****************************************************************************/
_inline LPVOID gen_validate(
    PDWORD_PTR lpMem,
    DWORD   cbSize)
{
    if (lpMem) {

        lpMem--;

        return (LPVOID)lpMem;
    }

    return NULL;
}

#endif

/*****************************************************************************\
* genGAlloc
*
*   Allocates a global-memory block.  This allocation also includes a header
*   block which contains block-information.  This allows for the tracking
*   of overwrites.
*
\*****************************************************************************/
LPVOID genGAlloc(
    DWORD cbSize)
{
    PDWORD_PTR lpMem;
    DWORD   cbNew;


    // Give us a little room for debugging info and make sure that our
    // size in bytes results in a whole number of DWORDs.
    //
    cbNew = cbSize + (2 * sizeof(DWORD_PTR));


    // DWORD_PTR align the memory so that we can track the correct amount
    // of dword-allocations.
    //
    if (cbNew & 7)
        cbNew += sizeof(DWORD_PTR) - (cbNew & 7);


    // Attempt to allocate the memory.
    //
    if ((lpMem = (PDWORD_PTR)GlobalAlloc(GPTR, cbNew)) == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }


    // Set up extra tracking information -- region size at the front
    // and an easily distinguishable constant at the back to help
    // us detect overwrites.
    //
    *lpMem = cbSize;
    *(PDWORD_PTR)((LPBYTE)lpMem + cbNew - sizeof(DWORD_PTR)) = DEADBEEF;

    return (LPVOID)(lpMem + 1);
}


/*****************************************************************************\
* genGFree
*
*   Free the memory allocated from genGAlloc.  Validate the memory to see
*   if any bad-overwrites occured.
*
\*****************************************************************************/
BOOL genGFree(
    LPVOID lpMem,
    DWORD  cbSize)
{
    LPVOID lpHead;
    BOOL   bRet = FALSE;


    // Try to at least make sure it's our memory and that no pointers have
    // gone astray in it.
    //
    if (lpHead = gen_validate((PDWORD_PTR)lpMem, cbSize))
        bRet = (GlobalFree(lpHead) == NULL);

    return bRet;
}


/*****************************************************************************\
* genGRealloc
*
*   Reallocate the memory block.  This allocates a new block, then copies
*   the information to the new-memory.  The old one is freed.
*
\*****************************************************************************/
PVOID genGRealloc(
    LPVOID lpMem,
    DWORD  cbOldSize,
    DWORD  cbNewSize)
{
    LPVOID lpNew;

    if (lpNew = (LPVOID)genGAlloc(cbNewSize)) {

        memcpy(lpNew, lpMem, cbOldSize);

        genGFree(lpMem, cbOldSize);
    }

    return lpNew;
}


/*****************************************************************************\
* genGAllocWStr
*
* Allocate and store a UNICODE string.
*
\*****************************************************************************/
LPWSTR genGAllocWStr(
    LPCWSTR lpwszStr)
{
    LPWSTR lpwszMem;

    if (lpwszStr == NULL)
       return NULL;

    if (lpwszMem = (LPWSTR)genGAlloc((lstrlen(lpwszStr) + 1) * sizeof(WCHAR)))
       lstrcpy(lpwszMem, lpwszStr);

    return lpwszMem;

}


/*****************************************************************************\
* genGAllocStr
*
*   Allocate and store a string.
*
\*****************************************************************************/
LPTSTR genGAllocStr(
    LPCTSTR lpszStr)
{
    LPTSTR lpszMem;

    if (lpszStr == NULL)
       return NULL;

    if (lpszMem = (LPTSTR)genGAlloc((lstrlen(lpszStr) + 1) * sizeof(TCHAR)))
       lstrcpy(lpszMem, lpszStr);

    return lpszMem;
}


/*****************************************************************************\
* genGCopy
*
*   Makes a copy of the memory pointed to by (lpSrc), and returns a new
*   allocated block.
*
\*****************************************************************************/
LPVOID genGCopy(
    LPVOID lpSrc)
{
    DWORD  cbSize;
    LPVOID lpCpy = NULL;


    if ((lpSrc != NULL) && (cbSize = genGSize(lpSrc))) {

        if (lpCpy = genGAlloc(cbSize))
            memcpy(lpCpy, lpSrc, cbSize);
    }

    return lpCpy;
}


/*****************************************************************************\
* genGSize
*
*   Returns the size of the block alloced by genGAlloc().
*
\*****************************************************************************/
DWORD genGSize(
    LPVOID lpMem)
{
    PDWORD_PTR lpHead;

    if (lpHead = (PDWORD_PTR)lpMem)
        return (DWORD) *(--lpHead);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\geninf.h ===
/*****************************************************************************\
* MODULE: geninf.h
*
* This is the main header for the INF generation module.
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 HWP-Guys    Created.
*
\*****************************************************************************/

#define INF_SECTION_BLOCK  4096     // Used as a block-size for section gets.
#define INF_SECTION_LIMIT     8     // Limit of section blocks to allocate.
#define INF_ITEM_BLOCK       16     // Number of items/per alloc-block.
#define INF_MAX_BUFFER      512     // Maximum size buffer.
#define INF_MIN_BUFFER       64     // Minimum size buffer.

#define INF_DRV_DRID      66000     // Setup dir-id for Driver-directory.
#define INF_PRC_DRID      66001     // Setup dir-id for Processor-directory.
#define INF_SYS_DRID      66002     // Setup dir-id for System-directory.
#define INF_ICM_DRID      66003     // Setup dir-id for Color-directory.


typedef BOOL (CALLBACK* INFENUMPROC)(LPCTSTR, LPCTSTR, BOOL, LPVOID);
typedef BOOL (CALLBACK* INFSCANPROC)(HINF, LPCTSTR, LPVOID);

typedef HANDLE (WINAPI* PSETUPCREATE)(LPVOID);
typedef BOOL   (WINAPI* PSETUPDESTROY)(LPVOID);
typedef BOOL   (WINAPI* PSETUPGET)(HANDLE, LPCWSTR, LPCWSTR, LPVOID);



// Parameter Structure for infCreate().
//
typedef struct _INFGENPARM {

    LPCTSTR lpszFriendlyName;       // Friendly-name for printer.
    LPCTSTR lpszShareName;          // Share-name of printer.
    LPCTSTR lpszPortName;           // Name of output-port.
    DWORD   idxPlt;                 // Client platform index.
    DWORD   idxVer;                 // Client version index.
    DWORD   dwCliInfo;              // Client Information.
    LPCTSTR lpszDrvName;            // Driver-name.
    LPCTSTR lpszDstName;            // Name of target-file.
    LPCTSTR lpszDstPath;            // Dest-directory to place target files.

} INFGENPARM;
typedef INFGENPARM      *PINFGENPARM;
typedef INFGENPARM NEAR *NPINFGENPARM;
typedef INFGENPARM FAR  *LPINFGENPARM;


// INF File-Item.
//
typedef struct _INFITEM {

    TCHAR  szName[INF_MIN_BUFFER];   // Name of file-item.
    TCHAR  szSource[INF_MIN_BUFFER]; // Original Name of file-item
    TCHAR  szPath[MAX_PATH];         // Path of file-item.
    TCHAR  szOrd[INF_MIN_BUFFER];    // Ordinal value of winntdir section.
    BOOL   bInf;                     // Specifies if this is an inf-file-item.
  } INFITEM;

typedef INFITEM      *PINFITEM;
typedef INFITEM NEAR *NPINFITEM;
typedef INFITEM FAR  *LPINFITEM;


// INF Item-Obj-Header
//
typedef struct _INFITEMINFO {

    DWORD   dwCount;                // Count of file-items in inf-build.
    INFITEM aItems[1];              // Contiguous array of file-items.

} INFITEMINFO;
typedef INFITEMINFO      *PINFITEMINFO;
typedef INFITEMINFO NEAR *NPINFITEMINFO;
typedef INFITEMINFO FAR  *LPINFITEMINFO;


// INF Object/Methods.
//
typedef struct _INFINFO {
    DWORD                   idxPlt;           // architecture/Environment index.
    DWORD                   idxVer;           // version index.
    DWORD                   dwCliInfo;        // Client Information.
    DWORD                   dwError;          // Error if INF processing fails
    HINF                    hInfObj;          // handle to an INF file object.
    LPTSTR                  lpszInfName;      // name of main inf file.
    LPTSTR                  lpszFrnName;      // friendly name of printer.
    LPTSTR                  lpszDrvName;      // name of driver.
    LPTSTR                  lpszDrvPath;      // windows driver directory.
    LPTSTR                  lpszDstName;      // name of destination file.
    LPTSTR                  lpszDstPath;      // output directory for destination file.
    LPTSTR                  lpszPrtName;      // name of output port.
    LPTSTR                  lpszShrName;      // share name of printer.
    LPINFITEMINFO           lpInfItems;       // object array of file-items.
    SP_ORIGINAL_FILE_INFO   OriginalFileInfo; // orignal name of .inf and .cat file for this inf

} INFINFO;
typedef INFINFO      *PINFINFO;
typedef INFINFO NEAR *NPINFINFO;
typedef INFINFO FAR  *LPINFINFO;


// INF Scan Structure.
//
typedef struct _INFSCAN {

    LPINFINFO     lpInf;
    LPINFITEMINFO lpII;

} INFSCAN;

typedef INFSCAN      *PINFSCAN;
typedef INFSCAN NEAR *NPINFSCAN;
typedef INFSCAN FAR  *LPINFSCAN;


// CATCOUNT and CATCOUNTARRAY structures used for determining
// the CAT file to use.
//
typedef struct _CATCOUNT {
    LPWSTR    lpszCATName;
    UINT      uCount;
} CATCOUNT, *LPCATCOUNT;

typedef struct _CATCOUNTARRAY {
    DWORD      dwIndivSigned;       // Individually signed file count
    UINT       uItems;
    UINT       uNextAvailable;
    HCATADMIN  hCatAdmin;
    LPCATCOUNT lpArray;
} CATCOUNTARRAY, *LPCATCOUNTARRAY;

HANDLE infCreate(
    LPINFGENPARM lpInf);

BOOL infProcess(
    HANDLE hInf);

BOOL infDestroy(
    HANDLE hInf);

BOOL infEnumItems(
    HANDLE      hInf,
    INFENUMPROC pfnEnum,
    LPVOID      lpvData);

WORD infGetEnvArch(
    HANDLE hInf);

WORD infGetEnvArchCurr(
    HANDLE hInf);



/***************************************\
* infGetInfName
\***************************************/
__inline LPCTSTR infGetInfName(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszInfName : NULL);
}


/***************************************\
* infGetDrvName
\***************************************/
__inline LPCTSTR infGetDrvName(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszDrvName : NULL);
}


/***************************************\
* infGetPrtName
\***************************************/
__inline LPCTSTR infGetPrtName(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszPrtName : NULL);
}


/***************************************\
* infGetDstName
\***************************************/
__inline LPCTSTR infGetDstName(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszDstName : NULL);
}


/***************************************\
* infGetDstPath
\***************************************/
__inline LPCTSTR infGetDstPath(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszDstPath : NULL);
}


/***************************************\
* infGetFriendlyName
\***************************************/
__inline LPCTSTR infGetFriendlyName(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszFrnName : NULL);
}


/***************************************\
* infGetShareName
\***************************************/
__inline LPCTSTR infGetShareName(
    HANDLE hInf)
{
    return (hInf ? (LPCTSTR)((LPINFINFO)hInf)->lpszShrName : NULL);
}

/***************************************\
* infGetCliInfo
\***************************************/
__inline DWORD infGetCliInfo(
    HANDLE hInf)
{
    return (hInf ? (DWORD)((LPINFINFO)hInf)->dwCliInfo : 0);
}

/***************************************\
* infGetError
\***************************************/
__inline DWORD infGetError(
    HANDLE hInf)
{
    return (hInf ? (DWORD)((LPINFINFO)hInf)->dwError : ERROR_SUCCESS);
}

/***************************************\
* infSetError
\***************************************/
__inline VOID infSetError(
    LPINFINFO hInf,
    DWORD     dwError )
{
    hInf->dwError = dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\genutil.h ===
/*****************************************************************************\
* MODULE: genutil.h
*
*   This is the header module for genutil.c.  This contains useful utility
*   routines shared across the gen* file.s
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* history:
*   22-Nov-1996 <chriswil> created.
*
\*****************************************************************************/

#define PRT_LEV_2 2


LPTSTR genGetCurDir(VOID);
LPTSTR genGetWinDir(VOID);
LPTSTR genBuildFileName(LPCTSTR, LPCTSTR, LPCTSTR);
LPTSTR genFindCharDiff(LPTSTR, LPTSTR);
LPTSTR genFindChar(LPTSTR, TCHAR);
LPTSTR genFindRChar(LPTSTR, TCHAR);
LPWSTR genWCFromMB(LPCSTR);
LPTSTR genTCFromMB(LPCSTR);
LPTSTR genTCFromWC(LPCWSTR);
LPSTR  genMBFromWC(LPCWSTR);
LPSTR  genMBFromTC(LPCTSTR);
LPTSTR genItoA(int);
BOOL   genUpdIPAddr(VOID);
LPTSTR genFrnName(LPCTSTR);
WORD   genChkSum(LPCTSTR);


#define IDX_X86     ((DWORD) 0)
#define IDX_MIP     ((DWORD) 1)
#define IDX_AXP     ((DWORD) 2)
#define IDX_PPC     ((DWORD) 3)
#define IDX_W9X     ((DWORD) 4)
#define IDX_I64     ((DWORD) 5)
#define IDX_AMD64   ((DWORD) 6)
#define IDX_UNKNOWN ((DWORD)-1)

#define IDX_SPLVER_0 ((DWORD)0)
#define IDX_SPLVER_1 ((DWORD)1)
#define IDX_SPLVER_2 ((DWORD)2)
#define IDX_SPLVER_3 ((DWORD)3)


typedef struct _PLTINFO {

    LPCTSTR lpszCab;  // Name of cab platform.
    LPCTSTR lpszEnv;  // Environment string.
    LPCTSTR lpszPlt;  // Platform override string.
    WORD    wArch;    // Integer representation of platform-type.

} PLTINFO;
typedef PLTINFO      *PPLTINFO;
typedef PLTINFO NEAR *NPPLTINFO;
typedef PLTINFO FAR  *LPPLTINFO;

BOOL    genIsWin9X(DWORD);
DWORD   genIdxCliPlatform(DWORD);
LPCTSTR genStrCliCab(DWORD);
LPCTSTR genStrCliEnvironment(DWORD);
LPCTSTR genStrCliOverride(DWORD);
WORD    genValCliArchitecture(DWORD);
DWORD   genIdxCliVersion(DWORD);
LPCTSTR genStrCliVersion(DWORD);
DWORD   genIdxFromStrVersion(LPCTSTR);
WORD    genValSvrArchitecture(VOID);

/***************************************\
* genIsWin9X
\***************************************/
__inline BOOL genIsWin9X(
    DWORD idxPlt)
{
    return (idxPlt == IDX_W9X);
}

/***************************************\
* genWCtoMB
\***************************************/
__inline DWORD genWCtoMB(
    LPSTR   lpszMB,
    LPCWSTR lpszWC,
    DWORD   cbSize)
{
    cbSize = (DWORD)WideCharToMultiByte(CP_ACP,
                                        0,
                                        lpszWC,
                                        -1,
                                        lpszMB,
                                        (int)cbSize,
                                        NULL,
                                        NULL);

    return cbSize;
}


/***************************************\
* genMBtoWC
\***************************************/
__inline DWORD genMBtoWC(
    LPWSTR lpszWC,
    LPCSTR lpszMB,
    DWORD  cbSize)
{
    cbSize = (DWORD)MultiByteToWideChar(CP_ACP,
                                        MB_PRECOMPOSED,
                                        lpszMB,
                                        -1,
                                        lpszWC,
                                        (int)(cbSize / sizeof(WCHAR)));

    return (cbSize * sizeof(WCHAR));
}


/***************************************\
* gen_OpenFileRead
\***************************************/
__inline HANDLE gen_OpenFileRead(
    LPCTSTR lpszName)
{
    return CreateFile(lpszName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
}


/***************************************\
* gen_OpenFileWrite
\***************************************/
__inline HANDLE gen_OpenFileWrite(
    LPCTSTR lpszName)
{
    return CreateFile(lpszName,
                      GENERIC_WRITE,
                      0,
                      NULL,
                      CREATE_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
}


/***************************************\
* gen_OpenDirectory
\***************************************/
__inline HANDLE gen_OpenDirectory(
    LPCTSTR lpszDir)
{
    return CreateFile(lpszDir,
                      0,
                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
                      NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\genutil.cxx ===
/*****************************************************************************\
* MODULE: genutil.c
*
* Various common routines used throughout the gen* files.
*
*   routines
*   --------
*   genGetCurDir
*   genGetWinDir
*   genBuildFileName
*   genFindChar
*   genFindCharDiff
*   genFindRChar
*   genWCFromMB
*   genMBFromWC
*   genItoA
*
*   genIsWin9X
*   genIdxCliPlatform
*   genStrCliCab
*   genStrCliEnvironment
*   genStrCliOverride
*   genValCliArchitecture
*   genIdxCliVersion
*   genStrCliVersion
*   genValSvrArchitecture
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* history:
*   22-Nov-1996 <chriswil> created.
*
\*****************************************************************************/

#include "pch.h"

/*****************************************************************************\
* genGetCurDir
*
* Returns string indicating current-directory.
*
\*****************************************************************************/
LPTSTR genGetCurDir(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszDir = NULL;


    cbSize = GetCurrentDirectory(0, NULL);

    if (cbSize && (lpszDir = (LPTSTR)genGAlloc((cbSize * sizeof(TCHAR)))))
        GetCurrentDirectory(cbSize, lpszDir);

    return lpszDir;
}


/*****************************************************************************\
* genGetWinDir
*
* Returns string indicating the windows-directory.
*
\*****************************************************************************/
LPTSTR genGetWinDir(VOID)
{
    DWORD  cbSize;
    LPTSTR lpszDir = NULL;


    cbSize = GetWindowsDirectory(NULL, 0);

    if (cbSize && (lpszDir = (LPTSTR)genGAlloc((cbSize * sizeof(TCHAR)))))
        GetWindowsDirectory(lpszDir, cbSize);

    return lpszDir;
}


/*****************************************************************************\
* genBuildFileName
*
* Takes path, name, extension strings and builds a fully-qualified
* string representing the file.  This can also be used to build other
* names.
*
\*****************************************************************************/
LPTSTR genBuildFileName(
    LPCTSTR lpszPath,
    LPCTSTR lpszName,
    LPCTSTR lpszExt)
{
    DWORD  cch;
    LPTSTR lpszFull;


    // Calculate the size necessary to hold the full-path filename.
    //
    cch  = lstrlen(g_szBkSlash);
    cch += (lpszPath ? lstrlen(lpszPath) : 0);
    cch += (lpszName ? lstrlen(lpszName) : 0);
    cch += (lpszExt  ? lstrlen(lpszExt)  : 0);


    if (lpszFull = (LPTSTR)genGAlloc(((cch + 1) * sizeof(TCHAR)))) {

        if (lpszPath) {

            if (lpszExt)
                cch = wsprintf(lpszFull, TEXT("%s\\%s%s"), lpszPath, lpszName, lpszExt);
            else
                cch = wsprintf(lpszFull, TEXT("%s\\%s"), lpszPath, lpszName);

        } else {

            if (lpszExt)
                cch = wsprintf(lpszFull, TEXT("%s%s"), lpszName, lpszExt);
            else
                cch = wsprintf(lpszFull, TEXT("%s"), lpszName);
        }
    }

    return lpszFull;
}


/*****************************************************************************\
* genFindCharDiff
*
* This routine returns a pointer to the location in DST, where the characters
* cease to match.
*
\*****************************************************************************/
LPTSTR genFindCharDiff(
    LPTSTR lpszDst,
    LPTSTR lpszSrc)
{
    LPTSTR lpszCS;
    LPTSTR lpszCD;


    CharLower(lpszSrc);
    CharLower(lpszDst);


    lpszCS = lpszSrc;
    lpszCD = lpszDst;

    while (*lpszCS == *lpszCD) {
        lpszCD++;
        lpszCS++;
    }

    return (*lpszCD ? lpszCD : NULL);
}


/*****************************************************************************\
* genFindChar
*
* Searches for the first occurence of (cch) in a string.
*
\*****************************************************************************/
LPTSTR genFindChar(
    LPTSTR lpszStr,
    TCHAR  cch)
{
    if (lpszStr) {

        while ((*lpszStr != cch) && (*lpszStr != TEXT('\0')))
            lpszStr++;

        if (((cch != TEXT('\0')) && (*lpszStr != TEXT('\0'))) || (cch == TEXT('\0')))
            return lpszStr;
    }

    return NULL;
}


/*****************************************************************************\
* genFindRChar
*
* Searches for the first occurence of (cch) in a string in reverse order.
*
\*****************************************************************************/
LPTSTR genFindRChar(
    LPTSTR lpszStr,
    TCHAR  cch)
{
    int nLimit;

    if (nLimit = lstrlen(lpszStr)) {

        lpszStr += nLimit;

        while ((*lpszStr != cch) && nLimit--)
            lpszStr--;

        if (nLimit >= 0)
            return lpszStr;
    }

    return NULL;
}


/*****************************************************************************\
* genWCFromMB
*
* This routine returns a buffer of wide-character representation of a
* ansi string.  The caller is responsible for freeing this pointer returned
* by this function.
*
\*****************************************************************************/
LPWSTR genWCFromMB(
    LPCSTR lpszStr)
{
    DWORD  cbSize;
    LPWSTR lpwszBuf = NULL;


    cbSize = genMBtoWC(NULL, lpszStr, 0);

    if (cbSize && (lpwszBuf = (LPWSTR)genGAlloc(cbSize)))
        genMBtoWC(lpwszBuf, lpszStr, cbSize);

    return lpwszBuf;
}


/*****************************************************************************\
* genTCFromMB
*
* This routine returns a buffer of tchar representation of a
* ansi string.  The caller is responsible for freeing this pointer returned
* by this function.
*
\*****************************************************************************/
LPTSTR genTCFromMB(
    LPCSTR lpszStr)
{

#ifdef UNICODE

    return genWCFromMB(lpszStr);

#else

    return genGAllocStr(lpszStr);

#endif
}

/*****************************************************************************\
* genTCFromWC
*
* This routine returns a buffer of tchar representation of a
* wide string.  The caller is responsible for freeing this pointer returned
* by this function.
*
\*****************************************************************************/
LPTSTR genTCFromWC(
    LPCWSTR lpszwStr)
{

#ifdef UNICODE
    
    return genGAllocStr(lpszwStr);

#else

    return genMBFromWC(lpszwStr);
    
#endif
}


/*****************************************************************************\
* genMBFromWC
*
* This routine returns a buffer of byte-character representation of a
* wide-char string.  The caller is responsible for freeing this pointer
* returned by this function.
*
\*****************************************************************************/
LPSTR genMBFromWC(
    LPCWSTR lpwszStr)
{
    DWORD cbSize;
    LPSTR lpszBuf = NULL;


    cbSize = genWCtoMB(NULL, lpwszStr, 0);

    if (cbSize && (lpszBuf = (LPSTR)genGAlloc(cbSize)))
        genWCtoMB(lpszBuf, lpwszStr, cbSize);

    return lpszBuf;
}


/*****************************************************************************\
* genMBFromTC
*
* This routine returns a buffer of byte-character representation of a
* tchar string.  The caller is responsible for freeing this pointer
* returned by this function.
*
\*****************************************************************************/
LPSTR genMBFromTC(
    LPCTSTR lpszStr)
{

#ifdef UNICODE

    return genMBFromWC(lpszStr);

#else

    return genGAllocStr(lpszStr);

#endif

}


/*****************************************************************************\
* genItoA
*
* Convert integer to string.
*
\*****************************************************************************/
LPTSTR genItoA(
    int nVal)
{
    DWORD  cch = 0;
    LPTSTR lpszVal;

    if (lpszVal = (LPTSTR)genGAlloc(INF_MIN_BUFFER))
        cch = wsprintf(lpszVal, TEXT("%d"), nVal);

    SPLASSERT((cch < INF_MIN_BUFFER));

    return lpszVal;
}


/*****************************************************************************\
* Client Platform Table.
*
* This table describes the various platforms/architectures.  By refering
* to the index into the table, various platform information can be
* obtained.
*
* Members are as follows:
* a) CAB string.  Used to denote the architecture in the cab-name.
* b) Environment string.  Used to denote printer-environment.
* c) Platform string.  Used for path override in setup api's.
* d) Architecture value.  Used to denote platform of client.
*
\*****************************************************************************/
static PLTINFO s_PltTable[] = {

    g_szCabX86, g_szEnvX86, g_szPltX86, PROCESSOR_ARCHITECTURE_INTEL,   // IDX_X86
    g_szCabMIP, g_szEnvMIP, g_szPltMIP, PROCESSOR_ARCHITECTURE_MIPS,    // IDX_MIP
    g_szCabAXP, g_szEnvAXP, g_szPltAXP, PROCESSOR_ARCHITECTURE_ALPHA,   // IDX_AXP
    g_szCabPPC, g_szEnvPPC, g_szPltPPC, PROCESSOR_ARCHITECTURE_PPC,     // IDX_PPC
    g_szCabW9X, g_szEnvW9X, g_szPltW9X, PROCESSOR_ARCHITECTURE_INTEL,   // IDX_W9X
    g_szCabI64, g_szEnvI64, g_szPltI64, PROCESSOR_ARCHITECTURE_IA64,    // IDX_I64
    g_szCabAMD64, g_szEnvAMD64, g_szPltAMD64, PROCESSOR_ARCHITECTURE_AMD64 // IDX_AMD64
};


/*****************************************************************************\
* Client Version Table.
*
* This table describes the spooler-versions which the client can request
* drivers for.
*
\*****************************************************************************/
static LPCTSTR s_VerTable[] = {

    TEXT("\\0"),    // Win NT 3.1  - IDX_SPLVER_0
    TEXT("\\1"),    // Win NT 3.51 - IDX_SPLVER_1
    TEXT("\\2"),    // Win NT 4.0  - IDX_SPLVER_2
    TEXT("\\3")     // Win NT 5.0  - IDX_SPLVER_3
};


/*****************************************************************************\
* genIdxCliPlatform
*
* This routine returns a platform-index into the s_PltTable.  The caller
* can use this index to refer to platform specific information about the
* client.
*
\*****************************************************************************/
DWORD genIdxCliPlatform(
    DWORD dwCliInfo)
{
    DWORD idx;
    DWORD cEnv;
    WORD  wArch;


    // If the platform is win9X, then set the index appropriately.  Otherwise,
    // continue on to determine the correct architecture for the NT case.
    //
    if (webGetOSPlatform(dwCliInfo) == VER_PLATFORM_WIN32_WINDOWS)
        return IDX_W9X;


    // Otherwise, the client is an NT platform.
    //
    cEnv  = sizeof(s_PltTable) / sizeof(s_PltTable[0]);
    wArch = webGetOSArch(dwCliInfo);


    // Look for matching client-info for the NT case.  The architecture
    // values will match up in this case.
    //
    for (idx = 0; idx < cEnv; idx++) {

        if (wArch == s_PltTable[idx].wArch)
            return idx;
    }

    return IDX_UNKNOWN;

}

/*****************************************************************************\
* genStrCliCab
*
* This routine returns a static-string representing the client-cabname.
*
\*****************************************************************************/
LPCTSTR genStrCliCab(
    DWORD idxPlt)
{
    return (idxPlt < (sizeof(s_PltTable) / sizeof(s_PltTable[0])) ? s_PltTable[idxPlt].lpszCab : NULL);
}


/*****************************************************************************\
* genStrCliEnvironment
*
* This routine returns a static-string representing the client-platform.  This
* string is used by the spooler API calls to specify environment.
*
\*****************************************************************************/
LPCTSTR genStrCliEnvironment(
    DWORD idxPlt)
{
    return (idxPlt < (sizeof(s_PltTable) / sizeof(s_PltTable[0])) ? s_PltTable[idxPlt].lpszEnv : NULL);
}


/*****************************************************************************\
* genStrCliOverride
*
* This routines returns a static-string representing the client-path-override
* for the setup API.
*
\*****************************************************************************/
LPCTSTR genStrCliOverride(
    DWORD idxPlt)
{
    return (idxPlt < (sizeof(s_PltTable) / sizeof(s_PltTable[0])) ? s_PltTable[idxPlt].lpszPlt : NULL);
}


/*****************************************************************************\
* genValCliArchitecture
*
* Returns the architecture platform of the client.
*
\*****************************************************************************/
WORD genValCliArchitecture(
    DWORD idxPlt)
{
    return (idxPlt < (sizeof(s_PltTable) / sizeof(s_PltTable[0])) ? s_PltTable[idxPlt].wArch : PROCESSOR_ARCHITECTURE_UNKNOWN);
}


/*****************************************************************************\
* genValSvrArchitecture
*
* Returns the architecture platform of the server.  The current architecture
* running this dll.
*
\*****************************************************************************/
WORD genValSvrArchitecture(VOID)
{
    DWORD idxEnv;

#if defined(_X86_)

    idxEnv = IDX_X86;

#elif defined(_AMD64_)

    idxEnv = IDX_AMD64;

#elif defined(_IA64_)

    idxEnv = IDX_I64;
    
#endif

    return genValCliArchitecture(idxEnv);
}


/*****************************************************************************\
* genIdxCliVersion
*
* This routine returns an index into the s_VerTable.  The caller can refer
* to this index for the client-version information.
*
\*****************************************************************************/
DWORD genIdxCliVersion(
    DWORD dwCliInfo)
{
    DWORD dwPlt = webGetOSPlatform(dwCliInfo);
    DWORD dwMaj = webGetOSMajorVer(dwCliInfo);
    DWORD dwMin = webGetOSMinorVer(dwCliInfo);


    if (dwMaj == 5)
        return IDX_SPLVER_3;

    if ((dwMaj == 4) && (dwPlt == VER_PLATFORM_WIN32_NT))
        return IDX_SPLVER_2;

    if ((dwMaj == 3) && (dwMin == 51))
        return IDX_SPLVER_1;

    if ((dwMaj == 4) && (dwPlt == VER_PLATFORM_WIN32_WINDOWS))
        return IDX_SPLVER_0;

    if ((dwMaj == 3) && (dwMin == 1))
        return IDX_SPLVER_0;

    return IDX_UNKNOWN;
}


/*****************************************************************************\
* genStrCliVersion
*
* Returns a string representing the spooler-version directory.  This is
* the relative directory off the system32\spool\drivers\*\ path that contains
* the drivers.
*
\*****************************************************************************/
LPCTSTR genStrCliVersion(
    DWORD idxVer)
{
    return (idxVer < (sizeof(s_VerTable) / sizeof(s_VerTable[0])) ? s_VerTable[idxVer] : NULL);
}


/*****************************************************************************\
* genIdxFromStrVersion
*
* Returns an index that matches the client-version-string.
*
\*****************************************************************************/
DWORD genIdxFromStrVersion(
    LPCTSTR lpszVer)
{
    DWORD idx;
    DWORD cVer;


    cVer  = sizeof(s_VerTable) / sizeof(s_VerTable[0]);

    for (idx = 0; idx < cVer; idx++) {

        if (lstrcmpi(lpszVer, s_VerTable[idx]) == 0)
            return idx;
    }

    return IDX_UNKNOWN;
}


/*****************************************************************************\
* genUpdIPAddr
*
* Updates the registry with the current IP-Addr of this machine.  If there
* is already an entry in the registry and it's different than the one
* currently established for the machine, then we return FALSE, and update
* the entry.
*
\*****************************************************************************/
BOOL genUpdIPAddr(VOID)
{
    HKEY    hKey;
    LRESULT lRet;
    LPSTR   lpszCmp;
    DWORD   cbData;
    DWORD   dwIpCmp;
    DWORD   dwIpReg;
    DWORD   dwVal;
    BOOL    bRet = TRUE;


    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        g_szPrtReg,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey);

    if (lRet == ERROR_SUCCESS) {

        if (lpszCmp = genMBFromWC(g_szHttpServerName)) {

            // Get the IP-Addr associated with this machine.
            //
            dwIpCmp = GetIPAddr(lpszCmp);


            // Setup our registry-information so get/set a value.
            //
            dwVal  = REG_DWORD;
            cbData = sizeof(DWORD);


            // Get what we already have stored there.  If no value exists,
            // the write it out.
            //
            lRet = RegQueryValueEx(hKey,
                                   g_szIpAddr,
                                   NULL,
                                   &dwVal,
                                   (LPBYTE)&dwIpReg,
                                   &cbData);

            if ((lRet != ERROR_SUCCESS) || (dwIpReg != dwIpCmp)) {

                bRet = FALSE;

                RegSetValueEx(hKey,
                              g_szIpAddr,
                              0,
                              REG_DWORD,
                              (LPBYTE)&dwIpCmp,
                              cbData);
            }

            genGFree(lpszCmp, genGSize(lpszCmp));
        }

        RegCloseKey(hKey);
    }

    return bRet;
}


/*****************************************************************************\
* genFrnName
*
* Returns a cluster-capable friendly-name.
*
\*****************************************************************************/
LPTSTR genFrnName(
    LPCTSTR lpszFrnName)
{
    DWORD  cbSize;
    LPTSTR lpszName = NULL;


    // Calc size for friendly-name.
    //
    cbSize = lstrlen(lpszFrnName) + lstrlen(g_szPrintServerName) + 6;


    // Build it.
    //
    if (lpszName = (LPTSTR)genGAlloc(cbSize * sizeof(TCHAR)))
        wsprintf(lpszName, TEXT("\\\\%s\\%s"), g_szPrintServerName, lpszFrnName);

    return lpszName;
}


/*****************************************************************************\
* genChkSum (Local Routine)
*
* This routine checksums a string into a WORD value.
*
\*****************************************************************************/

#define CRC_HI(wHi) (((wHi << 1) | (wHi & 0x8000)) ? 0x0001 : 0)
#define CRC_LO(wLo) (((wLo >> 1) | (wLo & 0x0001)) ? 0x8000 : 0)

WORD genChkSum(
    LPCTSTR lpszStr)
{
    WORD  wMask;
    DWORD idx;
    DWORD cLoop;
    DWORD cbStr;
    WORD  wHi     = 0;
    WORD  wLo     = 0;
    WORD  wChkSum = 0;


    if (lpszStr && (cbStr = lstrlen(lpszStr))) {

        // Loop through the bytes (in WORD increments).  This is an
        // optimized method in cyclying through bits.
        //
        cLoop = (cbStr / sizeof(WORD));

        for (idx = 0, wLo = 0, wHi = 0, wChkSum = 0; idx < cLoop; idx++) {

            wChkSum += *(((PWORD)lpszStr) + idx);

            wHi = CRC_HI(wHi) ^ wChkSum;
            wLo = CRC_LO(wLo) ^ wChkSum;
        }


        // If there's any extra bytes left over, then include that
        // in the checksum.  Mask off any bytes that should be
        // excluded from the checksum.
        //
        if (cbStr & 3) {

            wMask = ((WORD)-1 >> ((sizeof(WORD) - (cbStr & 3)) * 8));

            wChkSum += ((*((PWORD)lpszStr + cLoop)) & wMask);

            wHi = CRC_HI(wHi) ^ wChkSum;
            wLo = CRC_LO(wLo) ^ wChkSum;
        }
    }

    return (wChkSum + wHi + wLo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\geninf.cxx ===
/*****************************************************************************\
* MODULE: geninf.c
*
* The module contains routines for generating a setup INF file.
*
*
* Needed Work
* -----------
* 1) look at reducing the item-list size to contiguous buffers.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 HWP-Guys    Created.
*
\*****************************************************************************/

#include "pch.h"

/******************************************************************************
** Defines
******************************************************************************/

/******************************************************************************
** Define      - INF_CAT_INCREMENT
** Description - The increment in size between cat file increments
******************************************************************************/
#if (!defined(INF_CAT_INCREMENT))
   #define INF_CAT_INCREMENT   16
#endif

/*****************************************************************************\
* inf_NextStr (Local Routine)
*
* Proceeds to the next string in a section-list.
*
\*****************************************************************************/
_inline LPTSTR inf_NextStr(
    LPTSTR lpszStr)
{
    return (lpszStr + (lstrlen(lpszStr) + 1));
}


/*****************************************************************************\
* inf_WriteInfSct (Local Routine)
*
* Writes a section to the 9x-generated-inf-file.
*
\*****************************************************************************/
_inline BOOL inf_WriteInfSct(
    HANDLE hFile,
    LPCSTR lpszSct)
{
    DWORD cbWr;

    return WriteFile(hFile, (LPBYTE)lpszSct, lstrlenA(lpszSct), &cbWr, NULL);
}


/*****************************************************************************\
* inf_GetInfMfgKey (Local Routine)
*
* Returns the first word of the drvname which is used to denote mfg-section.
*
\*****************************************************************************/
LPSTR inf_GetInfMfgKey(
    LPCTSTR lpszDrvName)
{
    LPTSTR lpszTmp;
    LPSTR  lpszMfg = NULL;


    if (lpszTmp = genFindChar((LPTSTR)lpszDrvName, TEXT(' '))) {

        *lpszTmp = TEXT('\0');

        lpszMfg = genMBFromTC(lpszDrvName);

        *lpszTmp = TEXT(' ');

    } else {

        lpszMfg = genMBFromTC(lpszDrvName);
    }

    return lpszMfg;
}


/*****************************************************************************\
* inf_WriteInfMfg (Local Routine)
*
* Writes the manufacturer section.
*
\*****************************************************************************/
_inline BOOL inf_WriteInfMfg(
    HANDLE  hFile,
    LPCTSTR lpszDrvName)
{
    DWORD  cbWr;
    LPSTR  lpszMfg;
    LPSTR  lpszBuf;
    DWORD  cbSize;
    DWORD  cch;
    BOOL   bRet = FALSE;


    if (lpszMfg = inf_GetInfMfgKey(lpszDrvName)) {

        cbSize = lstrlenA(g_szInfSctMfg) + lstrlenA(lpszMfg) + 1;

        if (lpszBuf = (LPSTR)genGAlloc(cbSize)) {

            cch = wsprintfA(lpszBuf, g_szInfSctMfg, lpszMfg);

            bRet = WriteFile(hFile, lpszBuf, cch, &cbWr, NULL);

            genGFree(lpszBuf, cbSize);
        }

        genGFree(lpszMfg, genGSize(lpszMfg));
    }

    return bRet;
}


/*****************************************************************************\
* inf_WriteInfDrv (Local Routine)
*
* Writes the driver-section.
*
\*****************************************************************************/
_inline BOOL inf_WriteInfDrv(
    HANDLE  hFile,
    LPCTSTR lpszDrvName,
    LPCTSTR lpszDrvPath)
{
    DWORD  cbWr;
    LPTSTR lpszTmp;
    LPSTR  lpszName;
    LPSTR  lpszFile;
    LPSTR  lpszMfg;
    LPSTR  lpszBuf;
    DWORD  cbSize;
    DWORD  cch;
    BOOL   bRet = FALSE;


    if (lpszMfg = inf_GetInfMfgKey(lpszDrvName)) {

        if (lpszTmp = genFindRChar((LPTSTR)lpszDrvPath, TEXT('\\'))) {

            if (lpszFile = genMBFromTC(++lpszTmp)) {

                if (lpszName = genMBFromTC(lpszDrvName)) {

                    cbSize = lstrlenA(g_szInfSctDrv) +
                             lstrlenA(lpszName)      +
                             lstrlenA(lpszFile)      +
                             lstrlenA(lpszMfg)       +
                             1;

                    if (lpszBuf = (LPSTR)genGAlloc(cbSize)) {

                        cch = wsprintfA(lpszBuf, g_szInfSctDrv, lpszMfg, lpszName, lpszFile);

                        bRet = WriteFile(hFile, lpszBuf, cch, &cbWr, NULL);

                        genGFree(lpszBuf, cbSize);
                    }

                    genGFree(lpszName, genGSize(lpszName));
                }

                genGFree(lpszFile, genGSize(lpszFile));
            }
        }

        genGFree(lpszMfg, genGSize(lpszMfg));
    }

    return bRet;
}


/*****************************************************************************\
* inf_WriteInfIns (Local Routine)
*
* Writes the install-section.
*
\*****************************************************************************/
_inline BOOL inf_WriteInfIns(
    HANDLE  hFile,
    LPCTSTR lpszDrvPath)
{
    DWORD  cbWr;
    LPTSTR lpszTmp;
    LPSTR  lpszFile;
    LPSTR  lpszBuf;
    DWORD  cbSize;
    DWORD  cch;
    BOOL   bRet = FALSE;



    if (lpszTmp = genFindRChar((LPTSTR)lpszDrvPath, TEXT('\\'))) {

        if (lpszFile = genMBFromTC(++lpszTmp)) {

            cbSize = lstrlenA(g_szInfSctIns) +
                     lstrlenA(lpszFile)      +
                     1;

            if (lpszBuf = (LPSTR)genGAlloc(cbSize)) {

                cch = wsprintfA(lpszBuf, g_szInfSctIns, lpszFile);

                bRet = WriteFile(hFile, lpszBuf, cch, &cbWr, NULL);

                genGFree(lpszBuf, cbSize);
            }

            genGFree(lpszFile, genGSize(lpszFile));
        }
    }

    return bRet;
}


/*****************************************************************************\
* inf_WrintInfDta (Local Routine)
*
* Writes the data-section.
*
\*****************************************************************************/
_inline BOOL inf_WriteInfDta(
    HANDLE hFile,
    LPTSTR lpszDtaFile,
    LPTSTR lpszHlpFile)
{
    DWORD  cbWr;
    LPTSTR lpszDta;
    LPTSTR lpszHlp;
    LPSTR  lpszIns;
    LPSTR  lpszDtaName;
    LPSTR  lpszHlpName;
    DWORD  cbSize;
    DWORD  cch;
    BOOL   bRet = FALSE;


    if (lpszDta = genFindRChar(lpszDtaFile, TEXT('\\'))) {

        if (lpszHlp = genFindRChar(lpszHlpFile, TEXT('\\'))) {

            if (lpszDtaName = genMBFromTC(++lpszDta)) {

                if (lpszHlpName = genMBFromTC(++lpszHlp)) {

                    cbSize = lstrlenA(g_szInfSctIns) +
                             lstrlenA(lpszDtaName)   +
                             lstrlenA(lpszHlpName)   +
                             1;


                    if (lpszIns = (LPSTR)genGAlloc(cbSize)) {

                        cch  = wsprintfA(lpszIns, g_szInfSctDta, lpszDtaName, lpszHlpName);
                        bRet = WriteFile(hFile, lpszIns, cch, &cbWr, NULL);

                        genGFree(lpszIns, genGSize(lpszIns));
                    }

                    genGFree(lpszHlpName, genGSize(lpszHlpName));
                }

                genGFree(lpszDtaName, genGSize(lpszDtaName));
            }
        }
    }

    return bRet;
}


/*****************************************************************************\
* inf_WriteInfFiles (Local Routine)
*
* Writes the file-list section.
*
\*****************************************************************************/
BOOL inf_WriteInfFiles(
    HANDLE hFile,
    LPTSTR lpaszFiles)
{
    LPTSTR lpszPtr;
    LPTSTR lpszFile;
    LPSTR  lpszItm;
    DWORD  cbWr;
    DWORD  cch;
    CHAR   szBuf[255];
    BOOL   bRet = FALSE;


    // Write out the CopyFiles Section.  This will take the
    // dependent files list and alter it to delminate the
    // strings with commas.
    //
    if ((lpszPtr = lpaszFiles) && *lpszPtr) {

        WriteFile(hFile, g_szInfSctFil, lstrlenA(g_szInfSctFil), &cbWr, NULL);

        while (*lpszPtr) {

            if (lpszFile = genFindRChar(lpszPtr, TEXT('\\'))) {

                if (lpszItm = genMBFromTC(++lpszFile)) {

                    cch = wsprintfA(szBuf, "%s\r\n", lpszItm);
                    WriteFile(hFile, szBuf, cch, &cbWr, NULL);

                    bRet = TRUE;

                    genGFree(lpszItm, genGSize(lpszItm));
                }
            }

            lpszPtr = inf_NextStr(lpszPtr);
        }
    }

    return bRet;
}


/*****************************************************************************\
* inf_WriteInfSDF (Local Routine)
*
* Writes the file-list section.
*
\*****************************************************************************/
BOOL inf_WriteInfSDF(
    HANDLE  hFile,
    LPCTSTR lpaszFiles)
{
    LPTSTR lpszPtr;
    LPTSTR lpszFile;
    LPSTR  lpszItm;
    DWORD  cbWr;
    DWORD  cch;
    CHAR   szBuf[255];
    BOOL   bRet = FALSE;


    // Write out the CopyFiles Section.  This will take the
    // dependent files list and alter it to delminate the
    // strings with commas.
    //
    if ((lpszPtr = (LPTSTR)lpaszFiles) && *lpszPtr) {

        WriteFile(hFile, g_szInfSctSDF, lstrlenA(g_szInfSctSDF), &cbWr, NULL);

        while (*lpszPtr) {

            if (lpszFile = genFindRChar(lpszPtr, TEXT('\\'))) {

                if (lpszItm = genMBFromTC(++lpszFile)) {

                    cch = wsprintfA(szBuf, "%hs = 1\r\n", lpszItm);

                    WriteFile(hFile, szBuf, cch, &cbWr, NULL);

                    bRet = TRUE;

                    genGFree(lpszItm, genGSize(lpszItm));
                }
            }

            lpszPtr = inf_NextStr(lpszPtr);
        }
    }

    return bRet;
}


/*****************************************************************************\
* inf_BuildW9XInf (Local Routine)
*
*
\*****************************************************************************/
LPTSTR inf_BuildW9XInf(
    LPINFINFO       lpInf,
    LPCTSTR         lpszDrvName,
    LPDRIVER_INFO_3 lpdi3)
{
    LPTSTR lpszInfFile;
    HANDLE hFile;
    LPTSTR lpszInfName = NULL;


    if (lpszInfFile = genBuildFileName(lpInf->lpszDstPath, lpInf->lpszDstName, g_szDotInf)) {

        hFile = CreateFile(lpszInfFile,
                           GENERIC_READ | GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);


        if (hFile && (hFile != INVALID_HANDLE_VALUE)) {

            inf_WriteInfSct(hFile, (LPCSTR)g_szInfSctVer);
            inf_WriteInfMfg(hFile, lpszDrvName);
            inf_WriteInfDrv(hFile, lpszDrvName, (LPCTSTR)lpdi3->pDriverPath);
            inf_WriteInfIns(hFile, (LPCTSTR)lpdi3->pDriverPath);
            inf_WriteInfDta(hFile, lpdi3->pDataFile, lpdi3->pHelpFile);
            inf_WriteInfSct(hFile, (LPSTR)g_szInfSctSDN);
            inf_WriteInfSDF(hFile, (LPCTSTR)lpdi3->pDependentFiles);
            inf_WriteInfFiles(hFile, lpdi3->pDependentFiles);
            inf_WriteInfSct(hFile, g_szInfSctStr);

            lpszInfName = lpszInfFile;

            CloseHandle(hFile);

        } else {
            infSetError(lpInf,GetLastError());
            genGFree(lpszInfFile, genGSize(lpszInfFile));
        }
    }

    return lpszInfName;
}


/*****************************************************************************\
* inf_GetW9XInfo (Local Routine)
*
* Retrieves the files (drivers) for a 9x client.  This essentially takes the
* files and calls a routine to build an INF that the client will use to
* install the drivers.
*
\*****************************************************************************/
LPDRIVER_INFO_3 inf_GetW9XInfo(
    LPINFINFO lpInf,
    LPTSTR*   ppszDrvName)
{
    HANDLE          hPrinter;
    DWORD           cbBuf;
    DWORD           cbNeed;
    LPDRIVER_INFO_1 lpdi1;
    LPDRIVER_INFO_3 lpdi3 = NULL;


    *ppszDrvName = NULL;


    if (OpenPrinter(lpInf->lpszFrnName, &hPrinter, NULL)) {

        // First let's see how big our buffer will need to
        // be in order to hold the printer-driver-name-information.
        //
        cbBuf = 0;
        GetPrinterDriver(hPrinter, (LPTSTR)g_szEnvW9X, 1, NULL, 0, &cbBuf);


        // Allocate storage for holding the driver-info structure.
        //
        if (cbBuf && (lpdi1 = (LPDRIVER_INFO_1)genGAlloc(cbBuf))) {

            if (GetPrinterDriver(hPrinter, (LPTSTR)g_szEnvW9X, 1, (LPBYTE)lpdi1, cbBuf, &cbNeed)) {

                // Get size to hold the printer-driver-files-information.
                //
                cbBuf = 0;
                GetPrinterDriver(hPrinter, (LPTSTR)g_szEnvW9X, 3, NULL, 0, &cbBuf);


                if (cbBuf && (lpdi3 = (LPDRIVER_INFO_3)genGAlloc(cbBuf))) {

                    if (GetPrinterDriver(hPrinter, (LPTSTR)g_szEnvW9X, 3, (LPBYTE)lpdi3, cbBuf, &cbNeed)) {

                        *ppszDrvName = genGAllocStr(lpdi1->pName);

                    } else {

                        genGFree(lpdi3, genGSize(lpdi3));
                        lpdi3 = NULL;
                    }
                }
            }

            genGFree(lpdi1, genGSize(lpdi1));
        }

        ClosePrinter(hPrinter);
    }

    if (lpdi3 == NULL)
       infSetError(lpInf,GetLastError());

    return lpdi3;
}


/*****************************************************************************\
* inf_GetW9XInf (Local Routine)
*
*
\*****************************************************************************/
LPTSTR inf_GetW9XInf(
    LPINFINFO lpInf)
{
    LPDRIVER_INFO_3 lpdi3;
    LPTSTR          lpszDrvName;
    LPTSTR          lpszInfFile = NULL;


    if (lpdi3 = inf_GetW9XInfo(lpInf, &lpszDrvName)) {

        lpszInfFile = inf_BuildW9XInf(lpInf, lpszDrvName, lpdi3);

        genGFree(lpszDrvName, genGSize(lpszDrvName));
        genGFree(lpdi3, genGSize(lpdi3));
    }

    return lpszInfFile;
}


/*****************************************************************************\
* inf_GetIdx (Local Routine)
*
* Quick wrapper which returns the line in the INF file where the section/key
* resides.
*
\*****************************************************************************/
_inline BOOL inf_GetIdx(
    LPCTSTR     lpszSct,
    LPCTSTR     lpszKey,
    HINF        hInfObj,
    PINFCONTEXT pic)
{
    return SetupFindFirstLine(hInfObj, lpszSct, lpszKey, pic);
}


/*****************************************************************************\
* inf_GetInfInfoFileName (Local Routine)
*
* Retreive the filename from the INF-INFO index.
*
\*****************************************************************************/
LPTSTR inf_GetInfInfoFileName(
    PSP_INF_INFORMATION pii,
    DWORD               idx)
{
    DWORD  cbSize, dwBufferSize;
    LPTSTR lpszInfFile;


    if (SetupQueryInfFileInformation(pii, idx, NULL, 0, &cbSize)) {

        dwBufferSize = (cbSize + 1) * sizeof(TCHAR);

        if (lpszInfFile = (LPTSTR)genGAlloc(dwBufferSize)) {

            if (SetupQueryInfFileInformation(pii, idx, lpszInfFile, cbSize, NULL))
                return lpszInfFile;

            genGFree(lpszInfFile, genGSize(lpszInfFile));
        }
    }

    return NULL;
}


/*****************************************************************************\
* inf_GetInfInfo (Local Routine)
*
* Returns a pointer to an INF-INFO struct.
*
\*****************************************************************************/
PSP_INF_INFORMATION inf_GetInfInfo(
    HINF hInfObj)
{
    DWORD               cbSize;
    BOOL                bRet;
    PSP_INF_INFORMATION pii;


    cbSize = 0;
    bRet = SetupGetInfInformation(hInfObj,
                                  INFINFO_INF_SPEC_IS_HINF,
                                  NULL,
                                  0,
                                  &cbSize);

    if (bRet && cbSize && (pii = (PSP_INF_INFORMATION)genGAlloc(cbSize))) {

        bRet = SetupGetInfInformation(hInfObj,
                                      INFINFO_INF_SPEC_IS_HINF,
                                      pii,
                                      cbSize,
                                      NULL);

        if (bRet)
            return pii;

        genGFree(pii, genGSize(pii));
    }

    return NULL;
}


/*****************************************************************************\
* inf_AddItem (Local Routine)
*
* Add an INF file-item to the list.  If adding the new item exceeds the
* available space, then reallocate the memory and return a pointer to the
* new block.
*
\*****************************************************************************/
LPINFITEMINFO inf_AddItem(
    LPINFITEMINFO lpII,
    LPCTSTR       lpszItmName,
    LPCTSTR       lpszItmPath,
    BOOL          bInfFile)
{
    DWORD         idx;
    DWORD         dwOldSize;
    DWORD         dwNewSize;
    LPINFITEMINFO lpNewII;


    idx = lpII->dwCount++;

    if ((lpII->dwCount % INF_ITEM_BLOCK) == 0) {

        dwOldSize = genGSize(lpII);
        dwNewSize = dwOldSize + (sizeof(INFITEM) * INF_ITEM_BLOCK);


        // If we can't realloc the memory, then we are going to free up
        // our existing block and return NULL.  In our implementation, if
        // we can't add items, we need to fail-out.
        //
        lpNewII = (LPINFITEMINFO)genGRealloc(lpII, dwOldSize, dwNewSize);

        if (lpNewII == NULL) {

            genGFree(lpII, genGSize(lpII));

            DBGMSG(DBG_ERROR, ("inf_AddItem : Out of memory"));

            return NULL;
        }

        lpII = lpNewII;
    }


    // Add the item to the list.  The (szOrd) parameter is
    // filled in during the writing of the source-disk-files
    // section.  The Ord indicates which directory the file
    // is located in the LAYOUT.INF.
    //
    lpII->aItems[idx].bInf = bInfFile;
    lstrcpyn(lpII->aItems[idx].szName, lpszItmName, INF_MIN_BUFFER);
    lstrcpyn(lpII->aItems[idx].szPath, lpszItmPath, MAX_PATH);
    // Set the SOURCE name to NULL by default, if we find a source that has a different name
    // to the target, we'll set it to the original name
    lpII->aItems[idx].szSource[0] = _TEXT('\0');

    return lpII;
}


/*****************************************************************************\
* inf_GetTextLine (Local Routine)
*
* Quick wrapper which returns the text-value of the line specified in the
* inf-object.
*
\*****************************************************************************/
LPTSTR inf_GetTextLine(
    HINF        hInfObj,
    PINFCONTEXT pic)
{
    BOOL   bOK;
    DWORD  cbSize;
    LPTSTR lpszTxt;


    cbSize = 0;
    if (SetupGetLineText(pic, hInfObj, NULL, NULL, NULL, 0, &cbSize)) {

        if (cbSize) {

            cbSize *= sizeof(TCHAR);

            if (lpszTxt = (LPTSTR)genGAlloc(cbSize)) {

                bOK = SetupGetLineText(pic,
                                       hInfObj,
                                       NULL,
                                       NULL,
                                       lpszTxt,
                                       cbSize,
                                       NULL);

                if (bOK)
                    return lpszTxt;

                genGFree(lpszTxt, cbSize);
            }
        }
    }

    return NULL;
}


/*****************************************************************************\
* inf_GetText (Local Routine)
*
* Quick wrapper which returns the text-value of the line specified in the
* inf-object.  This only returns the first string if the line contains
* a field-list.
*
\*****************************************************************************/
LPTSTR inf_GetText(
    HINF        hInfObj,
    PINFCONTEXT pic)
{
    DWORD  cbSize;
    LPTSTR lpszTxt;


    cbSize = 0;
    if (SetupGetStringField(pic, 1, NULL, 0, &cbSize)) {

        if (cbSize) {

            cbSize *= sizeof(TCHAR);

            if (lpszTxt = (LPTSTR)genGAlloc(cbSize)) {

                if (SetupGetStringField(pic, 1, lpszTxt, cbSize, NULL))
                    return lpszTxt;

                genGFree(lpszTxt, cbSize);
            }
        }
    }

    return NULL;
}

/******************************************************************************************
** inf_ScanSection (local routine)
**
** Run through all of the members of a section that match a particular Key (possibly NULL)
** Supply the callback routine we receive with the MultiString that we get from scanning
** the section.
******************************************************************************************/
BOOL inf_ScanSection(HINF        hInf,        // The handle to the inf file we are searching
                     LPCTSTR     lpszSection, // The section name we are scanning from
                     LPCTSTR     lpszKey,     // The key to search the sections for
                     LPVOID      pCookie,     // The data about the inf that we have picked up
                     INFSCANPROC pFn          // The enumeration function
                     ) {
    ASSERT(pFn);

    DWORD       dwFieldSize     = MAX_PATH;
    LPTSTR      pmszFields      = (LPTSTR)genGAlloc(sizeof(TCHAR)*dwFieldSize);
    INFCONTEXT  Context;         // This is the search context we use
    BOOL        bRet            = pmszFields && SetupFindFirstLine(hInf, lpszSection, lpszKey , &Context);
    BOOL        bScan           = bRet;

    while(bScan) {
        DWORD dwRequiredSize;

        // Get the Scan Line from the context
        bScan = SetupGetMultiSzField( &Context, 1, pmszFields, dwFieldSize, &dwRequiredSize);

        if (!bScan && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            LPTSTR pmszTempFields  =  (LPTSTR)genGRealloc( pmszFields,
                                                           sizeof(TCHAR) * dwFieldSize,
                                                           sizeof(TCHAR) * dwRequiredSize );

            if (pmszTempFields) {
                pmszFields = pmszTempFields;
                dwFieldSize = dwRequiredSize;

                bRet = bScan = SetupGetMultiSzField( &Context, 1, pmszFields, dwFieldSize, &dwRequiredSize );
            } else
            bRet = bScan = FALSE;
        }

       // We find all the lpszKey Keys and then Pass the Fields through to the Enum Function

        if (bScan)
            bScan = bRet = (*pFn)( hInf, pmszFields, pCookie);

        if (bScan)
            bScan = SetupFindNextMatchLine( &Context, lpszKey, &Context );
    }

    if (pmszFields)
        genGFree( pmszFields, dwFieldSize * sizeof(TCHAR) );

    return bRet;
}


/******************************************************************************
** Structure - ENUMMFGS
**
** This structure is used to pass info up to the enumerator function
** (inf_EnumMfgSections) and return the install sections
*******************************************************************************/
typedef struct _EnumMfgs {
    LPCTSTR     lpszDrv;            // The driver to find
    LPTSTR      lpszIns;            // The install section in which it is found

    inline _EnumMfgs(LPCTSTR lpszDrv) : lpszDrv(lpszDrv), lpszIns(NULL) {}
} ENUMMFGS;

typedef ENUMMFGS *PENUMMFGS;


/******************************************************************************
** inf_EnumMfgSections
**
** This functions is called for every manufacturer install section in an inf
** file (there may be more than one). For each one it checks to see whether the
** required driver is inside the install section. If it is, it sets the return
** string to the install section for the driver. (Subsequent calls will be ignored).
******************************************************************************/
BOOL inf_EnumMfgSections(HINF hInf, LPCTSTR lpMfgSec, LPVOID pCookie) {
    ASSERT(pCookie);                    // Should not be NULL

    PENUMMFGS pMfgs = (PENUMMFGS)pCookie;

    if (lpMfgSec && pMfgs->lpszIns == NULL) {  // No matching driver has been found yet
        INFCONTEXT  Context;           // This context is used to get the install section

        if ( inf_GetIdx( lpMfgSec, pMfgs->lpszDrv, hInf, &Context) ) {

            pMfgs->lpszIns = inf_GetText( hInf, &Context );

        }
    }

    return TRUE;
}


/*****************************************************************************\
* inf_GetInsVal (Local Routine)
*
* Looks for the line indicated by section/key, and returns the text-string
* for this line.  This also returns an index to the line in the inf-file.
*
\*****************************************************************************/
LPTSTR inf_GetInsVal(
    LPCTSTR     lpszMfg,
    LPCTSTR     lpszDrv,
    HINF        hInfObj)
{
    ENUMMFGS EnumMfgs(lpszDrv);
    LPTSTR   lpszIns = NULL;

    if (inf_ScanSection( hInfObj, g_szMfgName, lpszMfg, (LPVOID)&EnumMfgs, inf_EnumMfgSections) )
        lpszIns = EnumMfgs.lpszIns;

    return lpszIns;
}


/*****************************************************************************\
* inf_RealSect (Local Routine)
*
* Looks for the real-section-mapping.  Some sections could be [.platform]
* specific, so we should be able to take in the section-name and
* create a real key.
*
\*****************************************************************************/
LPTSTR inf_GetRealSect(
    LPINFINFO   lpInf,
    LPCTSTR     lpszKey)
{
    BOOL   bRet;
    DWORD  cbSize;
    LPTSTR lpszSect;


    if (SetupSetPlatformPathOverride(genStrCliOverride(lpInf->idxPlt))) {

        cbSize = 0;
        bRet = SetupDiGetActualSectionToInstall(lpInf->hInfObj,
                                                lpszKey,
                                                NULL,
                                                0,
                                                &cbSize,
                                                NULL);

        if (bRet && cbSize) {

            if (lpszSect = (LPTSTR)genGAlloc(cbSize)) {

                bRet = SetupDiGetActualSectionToInstall(lpInf->hInfObj,
                                                        lpszKey,
                                                        lpszSect,
                                                        cbSize,
                                                        NULL,
                                                        NULL);

                if (bRet) {

                    SetupSetPlatformPathOverride(NULL);
                    return lpszSect;
                }

                genGFree(lpszSect, genGSize(lpszSect));
            }
        }

        SetupSetPlatformPathOverride(NULL);
    }

    return NULL;
}


/*****************************************************************************\
* inf_GetInfFile (Local Routine)
*
* Return the name of the inf-file.  This looks for the inf-file with the
* identified (lpszSection)...if NULL is specified, the first (main) inf
* file is returned.
*
\*****************************************************************************/
LPTSTR inf_GetInfFile(
    HINF    hInfObj,
    LPCTSTR lpszSct)
{
    PSP_INF_INFORMATION pii;
    INFCONTEXT          ic;
    LPTSTR              lpszInfFile = NULL;


    if (lpszSct) {

        if (inf_GetIdx(lpszSct, NULL, hInfObj, &ic))
            lpszInfFile = inf_GetInfFile(ic.CurrentInf, NULL);

    } else {

        if (pii = inf_GetInfInfo(hInfObj)) {

            lpszInfFile = inf_GetInfInfoFileName(pii, 0);

            genGFree(pii, genGSize(pii));
        }
    }

    return lpszInfFile;
}


/*****************************************************************************\
* inf_GetLayoutFile (Local Routine)
*
* Return the name of the Layout file.
*
\*****************************************************************************/
LPTSTR inf_GetLayoutFile(
    HINF    hInf )
{
    LPTSTR              lpszLayoutFile = NULL;
    INFCONTEXT INFContext;
    PINFCONTEXT pINFContext = &INFContext;
    DWORD dwBufferNeeded;

    // To get the source directories correct, we need to load all included INFs
    //  separately. THen use their associated layout files.
    if ( SetupFindFirstLine(  hInf, TEXT( "Version" ), TEXT( "LayoutFile" ), &INFContext ) )
    {
       // Find each INF and load it & it's LAYOUT files
       DWORD dwINFs = SetupGetFieldCount( &INFContext );

       if ( SetupGetStringField(  &INFContext, 1, NULL, 0, &dwBufferNeeded ) )
       {
          if (lpszLayoutFile = (LPTSTR)genGAlloc( ( dwBufferNeeded * sizeof(TCHAR) ) )) {
             if ( SetupGetStringField(  &INFContext, 1, lpszLayoutFile, ( dwBufferNeeded * sizeof(TCHAR) ), &dwBufferNeeded ) )
                return lpszLayoutFile;


             genGFree(lpszLayoutFile, genGSize(lpszLayoutFile));
          }  // Allocated pszINFName
       }  // Got the Field from the INF Line
    }  // Found a Layout File

    return NULL;
}


/*****************************************************************************\
* inf_GetSrcInf  (Local Routine)
*
* Get the name of the src inf file given the printer friendly name.  This
* will return a name without the full-path to the inf-directory.
*
\*****************************************************************************/
LPTSTR inf_GetSrcInf(
    LPINFINFO lpInf)
{
    LPTSTR lpszRet = NULL;

    HMODULE       hLib;
    PSETUPCREATE  pSCreate;
    PSETUPDESTROY pSDelete;
    PSETUPGET     pSGet;
    LPWSTR        lpszF;
    HDEVINFO      hDevInfo;
    WCHAR         szTmp[MAX_PATH];
    DWORD         cbSize = MAX_PATH;
    BOOL          bGet;


    if (genIsWin9X(lpInf->idxPlt)) {

        lpszRet = inf_GetW9XInf(lpInf);

    } else {

        if (hLib = LoadLibraryFromSystem32(g_szNtPrintDll)) {

            if (pSCreate = (PSETUPCREATE)GetProcAddress(hLib, g_szSetupCreate)) {

                if (pSGet = (PSETUPGET)GetProcAddress(hLib, g_szSetupGet)) {

                    if (pSDelete = (PSETUPDESTROY)GetProcAddress(hLib, g_szSetupDestroy)) {

                        if (hDevInfo = (*pSCreate)(NULL)) {

#ifdef UNICODE
                            bGet = (*pSGet)(hDevInfo, lpInf->lpszFrnName, szTmp, &cbSize);

                            if (bGet)
                                lpszRet = genGAllocStr(szTmp);
                            else
                                infSetError(lpInf,GetLastError());

#else
                            if (lpszF = genWCFromMB(lpInf->lpszFrnName)) {

                                bGet = (*pSGet)(hDevInfo, lpszF, szTmp, &cbSize);

                                if (bGet)
                                    lpszRet = genMBFromWC(szTmp);

                                genGFree(lpszF, genGSize(lpszF));
                            }
#endif

                            (*pSDelete)(hDevInfo);
                        }
                    }
                }
            }

            FreeLibrary(hLib);
        }
    }


    return lpszRet;
}

/*****************************************************************************\
* inf_CopyAndRenameInf (Local Routine)
*
* Opens the inf (the installed, possibly renamed inf), and queries setup for the
* original name.  Copies the inf to our dest directory, renaming it to the
* original name, if we have one.  Also saves the orignal file info so that we
* can rename the .cat file to the original name later.
*
\*****************************************************************************/
LPTSTR inf_CopyAndRenameInf(
    LPINFINFO   lpInf,
    LPTSTR      lpszSrcInf,
    LPTSTR      lpszSrcInfName) {

    HINF hInf;
    PSP_INF_INFORMATION pii;
    LPTSTR lpszDstInf = NULL;
    LPTSTR lpszDstName;
    DWORD  dwErr;

    // If this is a Win9x cab then simply return the passed in name
    if (genIsWin9X(lpInf->idxPlt)) {
        lpszDstInf = genGAllocStr(lpszSrcInf);
    } else {
        // Open the main-inf file.
        //
        hInf = SetupOpenInfFile(lpszSrcInf,
                                g_szPrinterClass,
                                INF_STYLE_WIN4,
                                (PUINT)&dwErr);
        if ( hInf != INVALID_HANDLE_VALUE ) {

            if (pii = inf_GetInfInfo(hInf)) {

                // Set the dst name to default to the src name, just in case we don't
                // succeed in getting original file info from setup.
                // If we don't get original file info, we DON'T bail out, because even though
                // the verification will fail on the client, the user will be prompted as to whether
                // to install the unverified driver files, which is what we want - the user will
                // still be able to print.
                //
                lpszDstName = lpszSrcInfName;

                // Ask setupapi for the original names of the .inf and .cat file
                //
                lpInf->OriginalFileInfo.cbSize = sizeof(SP_ORIGINAL_FILE_INFO);
                lpInf->OriginalFileInfo.OriginalInfName[0] = TEXT('\0');
                lpInf->OriginalFileInfo.OriginalCatalogName[0] = TEXT('\0');
                if (SetupQueryInfOriginalFileInformation(pii, 0, NULL, &(lpInf->OriginalFileInfo))) {
                    lpszDstName = (LPTSTR)&(lpInf->OriginalFileInfo.OriginalInfName);
                }

                // Build full-path to inf-file destination.  This will be our
                // new inf-file in the .\cabinets directory.
                //
                lpszDstInf = genBuildFileName(lpInf->lpszDstPath,
                                              lpszDstName,
                                              NULL);
                if (lpszDstInf) {

                    // Make a copy of our inf to the destination-directory, which will
                    // effectively rename it if we were successful in getting original file info.
                    //
                    if ( !CopyFile(lpszSrcInf, lpszDstInf, FALSE) )
                    {
                       infSetError(lpInf,GetLastError());
                       genGFree(lpszDstInf, genGSize(lpszDstInf));
                       lpszDstInf = NULL;
                    }
                } else {
                    infSetError(lpInf,GetLastError());
                    lpszDstInf = NULL;
                }

                genGFree(pii, genGSize(pii));
            } // if (pii = ...)
            else
                infSetError(lpInf,GetLastError());

            SetupCloseInfFile(hInf);
            hInf = NULL;

        } // if (hInf)
        else
            infSetError(lpInf,GetLastError());
    }

    return lpszDstInf;
}


/*****************************************************************************\
* inf_GetInfObj (Local Routine)
*
* Get the INF file object handle.  This utilizes fields from the lpInf
* structure (lpszDstDir, lpszFriendly).
*
\*****************************************************************************/
HINF inf_GetInfObj(
    LPINFINFO lpInf)
{

    DWORD  dwErr;
    LPTSTR lpszLayName;
    LPTSTR lpszInfName;
    LPTSTR lpszDstInf;
    LPTSTR lpszSrcInf;
    LPTSTR lpszLayFile;
    LPTSTR lpszLaySrc;
    LPTSTR lpszTmp;
    HINF   hInf = INVALID_HANDLE_VALUE;

    // Get main INF file and make a copy to our destination.
    //
    if (lpszTmp = inf_GetSrcInf(lpInf)) {

        // Save our inf-filename.
        //
        if (lpszSrcInf = genGAllocStr(lpszTmp)) {

            // Split up the SrcInf file to path and name.
            //
            lpszInfName    = genFindRChar(lpszTmp, TEXT('\\'));

            if (lpszInfName != NULL) {

                *lpszInfName++ = TEXT('\0');

                if (lpszDstInf = inf_CopyAndRenameInf(lpInf, lpszSrcInf, lpszInfName)) {

                    // Open the main-inf file.
                    //
                    hInf = SetupOpenInfFile(lpszDstInf,
                                            g_szPrinterClass,
                                            INF_STYLE_WIN4,
                                            (PUINT)&dwErr);

                    if ( hInf == INVALID_HANDLE_VALUE )
                        infSetError(lpInf,GetLastError());

                    genGFree(lpszDstInf, genGSize(lpszDstInf));
                } // if (lpszDstInf)

            }  // if (lpszInfName != NULL)
            else
                infSetError(lpInf, ERROR_PATH_NOT_FOUND);

            genGFree(lpszSrcInf, genGSize(lpszSrcInf));
        } // if (lpszSrcInf)
        else
            infSetError(lpInf,GetLastError());

        genGFree(lpszTmp, genGSize(lpszTmp));
    } // if (lpszTmp)

    return hInf;
}


/*****************************************************************************\
* inf_GetInsLine (Local Routine)
*
* Returns the install-line to install.
*
\*****************************************************************************/
LPTSTR inf_GetInsLine(
    LPINFINFO lpInf,
    LPCTSTR   lpszMfgName)
{
    LPTSTR     lpszSct;
    BOOL       bRet;
    DWORD      cbSize;
    LPTSTR     lpszIns = NULL;


    // Retrieve the install-section (raw).
    //
    lpszSct = inf_GetInsVal(lpszMfgName, lpInf->lpszDrvName, lpInf->hInfObj);

    if (lpszSct) {

        // Set the platform override so that we may be specify
        // architecture section to install.
        //
        SetupSetPlatformPathOverride(genStrCliOverride(lpInf->idxPlt));


        // Determine the size necessary to hold the install-section
        // string.
        //
        cbSize = 0;
        SetupDiGetActualSectionToInstall(lpInf->hInfObj,
                                         lpszSct,
                                         NULL,
                                         0,
                                         &cbSize,
                                         NULL);


        // Get the true install section string.
        //
        cbSize *= sizeof(TCHAR);

        if (cbSize && (lpszIns = (LPTSTR)genGAlloc(cbSize))) {

            bRet = SetupDiGetActualSectionToInstall(lpInf->hInfObj,
                                                   lpszSct,
                                                   lpszIns,
                                                   cbSize,
                                                   NULL,
                                                   NULL);


            // If we failed, for some reason, then
            // return NULL.
            //
            if (bRet == FALSE) {

                genGFree(lpszIns, cbSize);
                lpszIns = NULL;
            }
        }

        SetupSetPlatformPathOverride(NULL);

        genGFree(lpszSct, genGSize(lpszSct));
    }

    return lpszIns;
}


/*****************************************************************************\
* inf_GetInfName (Local Routine)
*
* Returns the name of an inf-file.
*
\*****************************************************************************/
LPTSTR inf_GetInfName(
    LPINFINFO lpInf)
{
    PSP_INF_INFORMATION pii;
    LPTSTR              lpszFile;
    LPTSTR              lpszPtr;
    LPTSTR              lpszName = NULL;


    if (lpszFile = inf_GetInfFile(lpInf->hInfObj, NULL)) {

        // Seperate the path and file info.
        //
        if (lpszPtr = genFindRChar(lpszFile, TEXT('\\')))
            lpszName = genGAllocStr(lpszPtr + 1);

        genGFree(lpszFile, genGSize(lpszFile));
    }

    return lpszName;
}


/*****************************************************************************\
* inf_IsDrvSupported (Local Routine)
*
* Returns whether the driver-version is supported for the client-version.
*
\*****************************************************************************/
BOOL inf_IsDrvSupported(
    DWORD idxVerCli,
    DWORD idxVerSpl)
{
    BOOL bSupported = FALSE;


    // If the client is less than NT 4.0, then we can't support any
    // drivers that are kernel-mode.
    //
    if ((idxVerCli < IDX_SPLVER_2) && (idxVerSpl >= IDX_SPLVER_2)) {

        bSupported = FALSE;

    } else {

        // Determine if the requesting client can handle the
        // driver-version installed for this printer.  Typically,
        // we can support drivers if they're within one major-version
        // from each other.
        //
        if (abs((int)idxVerCli - (int)idxVerSpl) <= 1)
            bSupported = TRUE;
    }


    return bSupported;
}


/*****************************************************************************\
* inf_GetDrvPath (Local Routine)
*
* Returns a string representing the requested driverpath.
*
\*****************************************************************************/
LPTSTR inf_GetDrvPath(
    LPCTSTR lpszDrvName,
    DWORD   idxPlt,
    DWORD   idxVer)
{
    BOOL    bGet;
    DWORD   cbNeed;
    DWORD   cbSize;
    LPCTSTR lpszEnv;
    LPTSTR  lpszPath = NULL;

#if 1

    LPDRIVER_INFO_2 lpdi;
    LPDRIVER_INFO_2 lpdiItem;
    DWORD           cRet;
    DWORD           idx;
    BOOL            bMatch = FALSE;
    DWORD           idxSpl;
    LPTSTR          lpszEnd;

    if (lpszEnv = genStrCliEnvironment(idxPlt)) {

        cbSize = 0;
        EnumPrinterDrivers(NULL,
                           (LPTSTR)lpszEnv,
                           2,
                           NULL,
                           0,
                           &cbSize,
                           &cRet);

        if (cbSize && (lpdi = (LPDRIVER_INFO_2)genGAlloc(cbSize))) {

            cRet = 0;
            bGet = EnumPrinterDrivers(NULL,
                                      (LPTSTR)lpszEnv,
                                      2,
                                      (LPBYTE)lpdi,
                                      cbSize,
                                      &cbNeed,
                                      &cRet);

            if (bGet && cRet) {

                // The goal here is to search for the driver-version
                // that matches the printer-name, then look to see if
                // this version will work on the requested client.  Typically,
                // clients can support driver-versions that are (n) to (n-1)
                //
                for (idx = 0; idx < cRet; idx++) {

                    lpdiItem = (lpdi + idx);


                    // Potential match?
                    //
                    if (lstrcmpi(lpdiItem->pName, lpszDrvName) == 0) {

                        if (lpszPath = genGAllocStr(lpdiItem->pDriverPath)) {

                            if (lpszEnd = genFindRChar(lpszPath, TEXT('\\'))) {

                                *lpszEnd = TEXT('\0');
                                bMatch   = FALSE;


                                // Find the version-directory-string.
                                //
                                if (lpszEnd = genFindRChar(lpszPath, TEXT('\\'))) {

                                    // Get the index for the driver-version.
                                    //
                                    if ((idxSpl = genIdxFromStrVersion(lpszEnd)) != IDX_UNKNOWN) {

                                        bMatch = inf_IsDrvSupported(idxVer, idxSpl);
                                    }
                                }
                            }


                            // If we're not a supported driver for the
                            // client, then don't use this path.
                            //
                            if (bMatch == FALSE) {

                                genGFree(lpszPath, genGSize(lpszPath));
                                lpszPath = NULL;

                                continue;
                            }
                        }

                        break;
                    }
                }

                // Chek top see if we found a compatible driver
                if ( (idx == cRet) && (bMatch == FALSE) )
                   // We went though the whole list without finding a match
                   SetLastError(ERROR_DRIVER_NOT_FOUND);
            }

            genGFree(lpdi, cbSize);
        }
        else if ( cbSize == 0 )
            SetLastError(ERROR_DRIVER_NOT_FOUND);
    }

    return lpszPath;

#else

    DWORD   cbVer;
    LPCTSTR lpszVer;

    if (lpszEnv = genStrCliEnvironment(idxPlt)) {

        if (lpszVer = genStrCliVersion(idxVer)) {

            // Get the required size for storing the full-directory name.
            //
            cbSize = 0;
            GetPrinterDriverDirectory(NULL, (LPTSTR)lpszEnv, 1, NULL, 0, &cbSize);


            cbVer = (lstrlen(lpszVer) * sizeof(TCHAR));

            // Allocate buffer for holding the string and version directory.
            //
            if (cbSize && (lpszPath = (LPTSTR)genGAlloc(cbSize + cbVer))) {

                bGet = GetPrinterDriverDirectory(NULL,
                                                 (LPTSTR)lpszEnv,
                                                 1,
                                                 (LPBYTE)lpszPath,
                                                 cbSize + cbVer,
                                                 &cbNeed);

                if (bGet) {

                    lstrcat(lpszPath, lpszVer);

                    return lpszPath;
                }

                genGFree(lpszPath, cbSize + cbVer);
            }
        }
    }

    return NULL;

#endif

}


/*****************************************************************************\
* inf_GetPrcPath (Local Routine)
*
* Returns a string representing the print-processor path.
*
\*****************************************************************************/
LPTSTR inf_GetPrcPath(
    DWORD idxPlt)
{
    BOOL    bGet;
    DWORD   cbNeed;
    DWORD   cbSize;
    LPCTSTR lpszEnv;
    LPTSTR  lpszPath;


    if (lpszEnv = genStrCliEnvironment(idxPlt)) {

        // Get the required size for storing the full-directory name.
        //
        cbSize = 0;
        GetPrintProcessorDirectory(NULL, (LPTSTR)lpszEnv, 1, NULL, 0, &cbSize);


        // Allocate buffer for holding the string.
        //
        if (cbSize && (lpszPath = (LPTSTR)genGAlloc(cbSize))) {

            bGet = GetPrintProcessorDirectory(NULL,
                                              (LPTSTR)lpszEnv,
                                              1,
                                              (LPBYTE)lpszPath,
                                              cbSize,
                                              &cbNeed);

            if (bGet)
                return lpszPath;

            genGFree(lpszPath, cbSize);
        }
    }

    return NULL;
}


/*****************************************************************************\
* inf_GetIcmPath (Local Routine)
*
* Returns a string representing the ICM color path.
*
\*****************************************************************************/
LPTSTR inf_GetIcmPath(
    DWORD idxPlt)
{
    DWORD  cbSize;
    LPTSTR lpszPath;


    // Get the required size for storing the full-directory name.
    //
    cbSize = 0;
    GetColorDirectory(NULL, NULL, &cbSize);


    // Allocate buffer for holding the string.
    //
    if (cbSize && (lpszPath = (LPTSTR)genGAlloc(cbSize))) {

        if (GetColorDirectory(NULL, lpszPath, &cbSize))
            return lpszPath;

        genGFree(lpszPath, cbSize);
    }

    return NULL;
}


/*****************************************************************************\
* inf_GetSysPath (Local Routine)
*
* Returns a string representing the system directory.
*
\*****************************************************************************/
LPTSTR inf_GetSysPath(
    DWORD idxPlt)
{
    DWORD  cbSize;
    LPTSTR lpszPath;


    cbSize = (MAX_PATH * sizeof(TCHAR));


    // Allocate buffer for holding the string.
    //
    if (lpszPath = (LPTSTR)genGAlloc(cbSize)) {

        if (GetSystemDirectory(lpszPath, MAX_PATH))
            return lpszPath;

        genGFree(lpszPath, cbSize);
    }

    return NULL;
}


/*****************************************************************************\
* inf_AllocStrings (Local Routine)
*
* Initializes the fields relating to the string-fields.
*
\*****************************************************************************/
BOOL inf_AllocStrings(
    LPINFINFO    lpInf,
    LPINFGENPARM lpParm)
{

    // Initialize the driver-name field.
    //
    if (lpInf->lpszDrvPath = inf_GetDrvPath(lpParm->lpszDrvName, lpInf->idxPlt, lpInf->idxVer)) {

        if (lpInf->lpszDrvName = genGAllocStr(lpParm->lpszDrvName)) {

            if (lpInf->lpszDstName = genGAllocStr(lpParm->lpszDstName)) {

                if (lpInf->lpszDstPath = genGAllocStr(lpParm->lpszDstPath)) {

                    if (lpInf->lpszPrtName = genGAllocStr(lpParm->lpszPortName)) {

                        if (lpInf->lpszShrName = genGAllocStr(lpParm->lpszShareName)) {

                            if (lpInf->lpszFrnName = genGAllocStr(lpParm->lpszFriendlyName))
                                return TRUE;

                            genGFree(lpInf->lpszShrName, genGSize(lpInf->lpszShrName));
                        }

                        genGFree(lpInf->lpszPrtName, genGSize(lpInf->lpszPrtName));
                    }

                    genGFree(lpInf->lpszDstPath, genGSize(lpInf->lpszDstPath));
                }

                genGFree(lpInf->lpszDstName, genGSize(lpInf->lpszDstName));
            }

            genGFree(lpInf->lpszDrvName, genGSize(lpInf->lpszDrvName));
        }

        genGFree(lpInf->lpszDrvPath, genGSize(lpInf->lpszDrvPath));
    }

    return FALSE;
}


/*****************************************************************************\
* inf_AddInfFile (Local Routine)
*
* Adds the inf-file to the list.  If this fails, then the (lpII) object
* is deleted.  This keeps this consistent with the inf_AddItem() routine.
*
\*****************************************************************************/
LPINFITEMINFO inf_AddInfFile(
    LPINFINFO     lpInf,
    LPINFITEMINFO lpII)
{
    LPTSTR        lpszInfFile;
    LPTSTR        lpszFile;
    LPINFITEMINFO lpIIRet = NULL;


    if (lpszInfFile = inf_GetInfFile(lpInf->hInfObj, NULL)) {

        // Seperate the path and file info, and add to the list.
        //
        if (lpszFile = genFindRChar(lpszInfFile, TEXT('\\'))) {

            *lpszFile = TEXT('\0');
            lpIIRet = inf_AddItem(lpII, ++lpszFile, lpszInfFile, TRUE);

        }

        genGFree(lpszInfFile, genGSize(lpszInfFile));
    }

    return lpIIRet;
}




/*****************************************************************************\
* inf_AddCATToCountArray (Local Routine)
*
* Takes a CAT filename, and adds it to our count array (if a new one), or increments
* the count if it already is in our array.
*
\*****************************************************************************/
BOOL inf_AddCATToCountArray(LPWSTR          lpszCATName,
                            LPCATCOUNTARRAY lpCatCountArray) {

    BOOL bReturn = TRUE;
    BOOL bFound = FALSE;
    UINT i;

    // Alloc or realloc for more memory if needed.  We alloc INF_CAT_INCREMENT items at a time, as needed.
    //
    // When we start there is no Next Available item defined
    if (!lpCatCountArray->uNextAvailable) {
        if (lpCatCountArray->lpArray = (LPCATCOUNT)genGAlloc(sizeof(CATCOUNT) * INF_CAT_INCREMENT) ) {
            lpCatCountArray->uNextAvailable = INF_CAT_INCREMENT;
            lpCatCountArray->uItems         = 0;
        }
        else goto CATCOUNTFAIL;
    }

    // See if we have already encountered this CAT file name.  If so, increment the count
    // for this CAT.  If not, add this CAT to our array.
    //
    for (i=0; i < lpCatCountArray->uItems; i++) {
        if (!lstrcmp(lpszCATName, lpCatCountArray->lpArray[i].lpszCATName)) {
            lpCatCountArray->lpArray[i].uCount++;
            bFound = TRUE;
            break;
        }
    }

    if (!bFound) {
        // We might need to reallocate the array, we need to do this if the new position
        // becomes equal to the next available item
        UINT uItem = lpCatCountArray->uItems;

        if (uItem >= lpCatCountArray->uNextAvailable) {
            LPCATCOUNT  lpNewArray = (LPCATCOUNT)genGRealloc((LPVOID)lpCatCountArray->lpArray,
                                                                    sizeof(CATCOUNT) * lpCatCountArray->uNextAvailable,
                                                                    sizeof(CATCOUNT) * (uItem + INF_CAT_INCREMENT) );
            if (lpNewArray) {
                lpCatCountArray->lpArray = lpNewArray;
                lpCatCountArray->uNextAvailable = uItem + INF_CAT_INCREMENT;
            }
            else goto CATCOUNTFAIL;
        }

        lpCatCountArray->lpArray[uItem].uCount = 1;
        lpCatCountArray->lpArray[uItem].lpszCATName = genGAllocWStr(lpszCATName);

        if (lpCatCountArray->lpArray[uItem].lpszCATName)
            lpCatCountArray->uItems = uItem + 1;
        else goto CATCOUNTFAIL;

    }

    return TRUE;

CATCOUNTFAIL:

    return FALSE;

}


/******************************************************************************
* inf_IsIndividuallySigned (Local Routine)
*
* Returns TRUE if a driver file is individually signed
*
*******************************************************************************/
BOOL inf_IsIndividuallySigned(
    LPCTSTR lpszDriverFileName) {

    GUID                gSubject;
    SIP_DISPATCH_INFO   SipDispatch;
    SIP_SUBJECTINFO     SubjectInfo;
    DWORD               cbData          = 0;
    BOOL                bRet            = FALSE;
    DWORD               dwEncodingType  = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;

    ASSERT(lpszDriverFileName);

    if (!CryptSIPRetrieveSubjectGuid(  // This GUID is used for passing to CryptSIPLoad
            lpszDriverFileName,        // which verifies the sig on the file
            NULL,
            &gSubject)) goto Failure;

    ZeroMemory( &SipDispatch, sizeof(SipDispatch) );
    SipDispatch.cbSize = sizeof(SipDispatch);

    if (!CryptSIPLoad(
            &gSubject,
            0,
            &SipDispatch)) goto Failure;

    // Now that we have the SIP Dispatch, fill out the subject info

    ZeroMemory( &SubjectInfo,  sizeof(SubjectInfo) );
    SubjectInfo.cbSize         = sizeof(SubjectInfo);
    SubjectInfo.pgSubjectType  = (GUID *)&gSubject;
    SubjectInfo.hFile          = INVALID_HANDLE_VALUE;
    SubjectInfo.pwsFileName    = lpszDriverFileName;
    SubjectInfo.dwEncodingType = dwEncodingType;

    if (!SipDispatch.pfGet(
            &SubjectInfo,
            &dwEncodingType,
            0,
            &cbData,
            NULL)) goto Failure;

    if (cbData != 0) bRet = TRUE;

Failure:

    return bRet;

}


/*****************************************************************************\
* inf_CATCountProc (Local Routine)
*
* Callback used to count up all references to CAT files by the driver files.
*
\*****************************************************************************/
BOOL CALLBACK inf_CATCountProc(LPCTSTR lpszName,
                               LPCTSTR lpszPath,
                               BOOL bInf,
                               LPVOID  lpData) {


    BOOL bReturn = TRUE;
    LPCATCOUNTARRAY lpCatCountArray = (LPCATCOUNTARRAY)(lpData);
    HCATADMIN       hCatAdmin = lpCatCountArray->hCatAdmin;
    LPTSTR          lpszDriverFileName;

    HCATINFO        hCatInfo = NULL;
    HCATINFO        hCatInfoPrev = NULL;
    CATALOG_INFO    CatalogInfo;
    BYTE *          pbHash;
    DWORD           dwBytes;
    WIN32_FIND_DATA ffd;
    PFILEITEM       pFileItem;
    HANDLE          hFind, hFile;
    LPTSTR          pFullPath, pPath, pName;

    // Find the catalog file associated with this file.
    // If we can't find one, that's OK, it's not an error, just a file
    // with no associated .cat file.  The user can decide on the client-end
    // whether or not he wants to install without the verification a .cat file
    // would provide...
    //

    if (INVALID_HANDLE_VALUE != (HANDLE)hCatAdmin) {

        if (lpszDriverFileName = genBuildFileName(lpszPath, lpszName, NULL)) {

            hFind = FindFirstFile(lpszDriverFileName, &ffd);

            if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

                FindClose(hFind);

                // The first thing we need to determine is whether the file is individually
                // signed, if it is we don't look for a cat and up the individually signed
                // count

                if ( inf_IsIndividuallySigned(lpszDriverFileName) ) {
                        lpCatCountArray->dwIndivSigned++;
                    }  else {

                    // Open the file in order to hash it.
                    //
                    if (INVALID_HANDLE_VALUE != (hFile = CreateFile(lpszDriverFileName,
                                                                    GENERIC_READ,
                                                                    FILE_SHARE_READ,
                                                                    NULL,
                                                                    OPEN_EXISTING,
                                                                    FILE_ATTRIBUTE_NORMAL,
                                                                    NULL))) {

                        // Determine how many bytes we need for the hash
                        //
                        dwBytes = 0;
                        pbHash = NULL;
                        CryptCATAdminCalcHashFromFileHandle(hFile, &dwBytes, pbHash, 0);

                        if (NULL != (pbHash = (BYTE *)genGAlloc(dwBytes))) {

                            // Compute the hash for this file
                            //
                            if (CryptCATAdminCalcHashFromFileHandle(hFile, &dwBytes, pbHash, 0)) {

                                // Get the catalog file(s) associated with this file hash
                                //
                                hCatInfo = NULL;

                                do {

                                    hCatInfoPrev = hCatInfo;
                                    hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbHash, dwBytes, 0, &hCatInfoPrev);

                                    if (NULL != hCatInfo) {

                                        CatalogInfo.cbStruct = sizeof(CATALOG_INFO);

                                        if (CryptCATCatalogInfoFromContext(hCatInfo, &CatalogInfo, 0)) {

                                           if (!inf_AddCATToCountArray(CatalogInfo.wszCatalogFile, lpCatCountArray)) {

                                              bReturn = FALSE;
                                              hCatInfo = NULL;  // fail out of loop
                                           }
                                        }
                                    }

                                } while (NULL != hCatInfo);

                            } // if (CryptCATAdminCalcHashFromFileHandle(hFile, &dwBytes, pbHash, 0)) {

                            genGFree(pbHash, dwBytes);

                        } // if (NULL != (pbHash = (BYTE *)genGAlloc(dwBytes))) {

                        CloseHandle(hFile);

                    }  // if (INVALID_HANDLE_VALUE != (hFile = CreateFile(lpszDriverFileName,

                } // if ( inf_IsIndividuallySigned(hFile, lpszDriverFileName) )

            } // if (hFind && (hFind != INVALID_HANDLE_VALUE)) {

            genGFree(lpszDriverFileName, genGSize(lpszDriverFileName));

        } // if (lpszDriverFileName = genBuildFileName(lpszPath, lpszName, NULL)) {

    }   // if (INVALID_HANDLE_VALUE != (HANDLE)hCatAdmin) {

    return bReturn;
}



/*****************************************************************************\
* inf_AddCATFile (Local Routine)
*
* Adds the cat-file to the list (if any).
*
\*****************************************************************************/
BOOL inf_AddCATFile(
    LPINFINFO     lpInf) {

    LPTSTR        lpszInfFile;
    LPTSTR        lpszFile;
    LPTSTR        lpszDstCAT;
    LPTSTR        lpszDstName;
    LPTSTR        lpszInstalledCATFileName;
    LPINFITEMINFO lpIIRet;

    // We initialize return to TRUE because we want to NOT fail out of the cab generation process
    // at this point, even if we fail to find a CAT file.  This will at least still return the driver cab
    // package to the client and let the user accept or decline the package when it fails to
    // verify.
    //
    BOOL bReturn = TRUE;
    CATCOUNTARRAY CatCountArray;

    CatCountArray.dwIndivSigned = 0;  // The number of individually signed files
    CatCountArray.uItems = 0;
    CatCountArray.uNextAvailable = 0;
    CatCountArray.lpArray = NULL;

    // Initialize the catalog admin context handle
    //
    if (FALSE == CryptCATAdminAcquireContext(&(CatCountArray.hCatAdmin), NULL, 0)) {
        CatCountArray.hCatAdmin = (HCATADMIN)INVALID_HANDLE_VALUE;
        infSetError(lpInf,GetLastError());
        return FALSE;
    }

    // Enumerate all the items in the inf.  The enumeration callback (inf_CATCountProc)
    // will count the number of references for each unique CAT file that is referenced by
    // one of our driver files.  We will add to the CAB file, the CAT file that is referenced
    // the most times by the driver files - this CAT file SHOULD be referenced by ALL of the
    // driver files, or there is no point in adding the CAT to the CAB, since the driver verification
    // will fail on the client if not all files are verified by the CAT.
    //
    if (infEnumItems((HANDLE)lpInf, inf_CATCountProc, (LPVOID)&CatCountArray )) {

        if (CatCountArray.uItems > 0) {

            UINT uIndex;

            // Search our CAT file array to find the CAT file that was referenced more than the others.
            // This is the CAT file we want to package into the CAB.
            //
            UINT uIndexOfMostCommonCAT = 0;
            for (uIndex=0; uIndex < CatCountArray.uItems; uIndex++) {
                if (CatCountArray.lpArray[uIndexOfMostCommonCAT].uCount < CatCountArray.lpArray[uIndex].uCount)
                    uIndexOfMostCommonCAT = uIndex;
            }

            // Make sure that every file referenced this CAT file - if they all didn't,
            // then it will fail verification on client - so no sense in sending the CAT
            // to the CAB package
            //
            if (CatCountArray.lpArray[uIndexOfMostCommonCAT].uCount + CatCountArray.dwIndivSigned
                    >= (lpInf->lpInfItems->dwCount)) {

                lpszInstalledCATFileName = CatCountArray.lpArray[uIndexOfMostCommonCAT].lpszCATName;

                // If we have an original .cat file name, use it for the dest name,
                // otherwise, just use the current (installed) name
                //
                if (lpInf->OriginalFileInfo.OriginalCatalogName[0] != TEXT('\0')) {
                    lpszDstName = (LPTSTR)&(lpInf->OriginalFileInfo.OriginalCatalogName);
                }
                else {
                    // Find the filename portion of the current (installed) .cat file name.
                    lpszDstName = genFindRChar(lpszInstalledCATFileName, TEXT('\\'));
                    lpszDstName++;
                }

                if (lpszDstCAT = genBuildFileName(lpInf->lpszDstPath,
                                                  lpszDstName,
                                                  NULL)) {

                    // Copy the CAT file into our directory, renaming it to the original name.
                    //
                    if ( CopyFile(lpszInstalledCATFileName, lpszDstCAT, FALSE) )
                    {
                       // Add this (renamed) file to our file list to be added to the cab.
                       //
                       lpIIRet = inf_AddItem(lpInf->lpInfItems, lpszDstName, lpInf->lpszDstPath, TRUE);
                       if (lpIIRet == NULL) {
                           infSetError(lpInf,GetLastError());
                           bReturn = FALSE;
                       }

                       lpInf->lpInfItems = lpIIRet;
                    }
                    else
                    {
                       infSetError(lpInf,GetLastError());
                       genGFree(lpInf->lpInfItems, genGSize(lpInf->lpInfItems));
                       lpInf->lpInfItems = NULL;
                       bReturn = FALSE;
                    }
                    genGFree(lpszDstCAT, genGSize(lpszDstCAT));
                }
            }
        }
        else {
            DBGMSG(DBG_INFO, ("geninf: No CAT Files found for driver package.\n"));
        }
    }

    // Free all our CAT array items here
    //

    if (CatCountArray.lpArray) {

        UINT uItem = 0;
        for (uItem = 0; uItem < CatCountArray.uItems; uItem++) {
            genGFree(CatCountArray.lpArray[uItem].lpszCATName, genGSize(CatCountArray.lpArray[uItem].lpszCATName));
        }

        genGFree(CatCountArray.lpArray, genGSize(CatCountArray.lpArray));
    }

    // Release the Catalog Admin context handle, if we have one
    //
    if (INVALID_HANDLE_VALUE != (HANDLE)(CatCountArray.hCatAdmin)) {
        CryptCATAdminReleaseContext(CatCountArray.hCatAdmin, 0);
    }

    return bReturn;
}


/*****************************************************************************\
* inf_SetDefDirIds (Local Routine)
*
* Sets the Default DRID values for the setup-process.
*
\*****************************************************************************/
BOOL inf_SetDefDirIds(
    LPINFINFO lpInf)
{
    LPTSTR lpszDrv;
    LPTSTR lpszPrc;
    LPTSTR lpszSys;
    LPTSTR lpszIcm;
    BOOL   bRet = FALSE;


    if (lpszDrv = lpInf->lpszDrvPath) {

        if (lpszPrc = inf_GetPrcPath(lpInf->idxPlt)) {

            if (lpszSys = inf_GetSysPath(lpInf->idxPlt)) {

                if (lpszIcm = inf_GetIcmPath(lpInf->idxPlt)) {

                    if (SetupSetDirectoryId(lpInf->hInfObj, INF_DRV_DRID, lpszDrv) &&
                        SetupSetDirectoryId(lpInf->hInfObj, INF_PRC_DRID, lpszPrc) &&
                        SetupSetDirectoryId(lpInf->hInfObj, INF_SYS_DRID, lpszSys) &&
                        SetupSetDirectoryId(lpInf->hInfObj, INF_ICM_DRID, lpszIcm)) {

                        bRet = TRUE;
                    }

                    genGFree(lpszIcm, genGSize(lpszIcm));
                }

                genGFree(lpszSys, genGSize(lpszSys));
            }

            genGFree(lpszPrc, genGSize(lpszPrc));
        }
    }

    return bRet;
}


/*****************************************************************************\
* inf_SetDirIds (Local Routine)
*
* Sets the DRID values for the setup-process.
*
\*****************************************************************************/
BOOL inf_SetDirIds(
    LPINFINFO lpInf)
{
    INFCONTEXT ic;
    DWORD      idx;
    DWORD      dwCount;
    WORD       wEnvCli;
    WORD       wEnvSrv;
    DWORD      dwDRID;
    LPTSTR     lpszDir;
    BOOL       bRet = FALSE;



    // Initialize the default directories for DRID values.
    //
    inf_SetDefDirIds(lpInf);


    // Look through the INF-File for any overriding DRID values and
    // set these.
    //
    if ((dwCount = SetupGetLineCount(lpInf->hInfObj, g_szDestDirs)) != (DWORD)-1) {

        for (idx = 0, bRet = TRUE; (idx < dwCount) && bRet; idx++) {

            if (bRet = SetupGetLineByIndex(lpInf->hInfObj, g_szDestDirs, idx, &ic)) {

                if (bRet = SetupGetIntField(&ic, 1, (PINT)&dwDRID)) {

                    if (dwDRID < DIRID_USER)
                        continue;

                    switch (dwDRID) {

                    case INF_DRV_DRID:
                        bRet = SetupSetDirectoryId(lpInf->hInfObj, dwDRID, lpInf->lpszDrvPath);
                        continue;

#if 1
// We don't necessarily need to copy the procesor and system32 files
// since they are architecture specific.  In this case we will let the
// files default to the skip-dir.
//
// NOTE: if do not include these files, we might need to modify the INF
// so that they are not referenced during client-side install.
//
                    case INF_PRC_DRID:
                        wEnvCli = genValCliArchitecture(lpInf->idxPlt);
                        wEnvSrv = genValSvrArchitecture();

                        if (wEnvCli == wEnvSrv) {

                            lpszDir = inf_GetPrcPath(lpInf->idxPlt);

                        } else {

                            lpszDir = genGAllocStr(g_szSkipDir);
                        }
                        break;

                    case INF_SYS_DRID:
                        wEnvCli = genValCliArchitecture(lpInf->idxPlt);
                        wEnvSrv = genValSvrArchitecture();

                        if (wEnvCli == wEnvSrv) {

                            lpszDir = inf_GetSysPath(lpInf->idxPlt);

                        } else {

                            lpszDir = genGAllocStr(g_szSkipDir);
                        }
                        break;
#endif

                    case INF_ICM_DRID:
                        lpszDir = inf_GetIcmPath(lpInf->idxPlt);
                        break;

                    default:
                        lpszDir = genGAllocStr(g_szSkipDir);
                    }


                    if (lpszDir) {

                        bRet = SetupSetDirectoryId(lpInf->hInfObj, dwDRID, lpszDir);

                        genGFree(lpszDir, genGSize(lpszDir));

                    } else {

                        bRet = FALSE;
                    }
                }
            }
        }
    }

    return bRet;
}


/*****************************************************************************\
* inf_ScanFiles (Local Routine)
*
* Callback routine which returns the items in a copyfiles list.
*
\*****************************************************************************/
UINT CALLBACK inf_ScanFiles(
    LPVOID lpCtxt,
    UINT   uNotify,
    UINT_PTR   Parm1,
    UINT_PTR   Parm2)
{
    LPINFSCAN lpScan;
    LPTSTR    lpszPath;
    LPTSTR    lpszFile;


    if ((lpScan = (LPINFSCAN)lpCtxt) && (lpszPath = (LPTSTR)Parm1)) {

        if (lpszFile = genFindRChar(lpszPath, TEXT('\\'))) {

            *lpszFile = TEXT('\0');


            // If this is a skip-dir item then do not add to our
            // list.  This can happen for files that are not stored
            // in platform-specific directories.  For example, files
            // stored in the SYSTEM32 directory have no architecture
            // counter-part.  We do not want to download the incorrect
            // file for a different architecture.
            //
            if (lstrcmpi(lpszPath, g_szSkipDir) != 0) {

                lpScan->lpII = inf_AddItem(lpScan->lpII, lpszFile + 1, lpszPath, FALSE);

            }

            *lpszFile = TEXT('\\');

            return (lpScan->lpII ? 0 : 1);
        }
    }

    return 1;
}


/*****************************************************************************\
* inf_BuildW9XList (Local Routine)
*
* This enumerates the W9X dependent files and adds them to our list.
*
\*****************************************************************************/
LPINFITEMINFO inf_BuildW9XList(
    LPINFINFO lpInf,
    LPINFSCAN lpis)
{
    LPDRIVER_INFO_3 lpdi3;
    LPTSTR          lpszDrvName;
    LPTSTR          lpszItm;
    BOOL            bRet = FALSE;


    if (lpdi3 = inf_GetW9XInfo(lpInf, &lpszDrvName)) {

        if (lpszItm = lpdi3->pDependentFiles) {

            bRet = TRUE;

            while (*lpszItm) {

                if (inf_ScanFiles(lpis, 0, (UINT_PTR)lpszItm, 0) != 0)
                    break;

                lpszItm = inf_NextStr(lpszItm);
            }
        }

        genGFree(lpszDrvName, genGSize(lpszDrvName));
        genGFree(lpdi3, genGSize(lpdi3));
    }


    if (bRet == FALSE) {
        genGFree(lpis->lpII, genGSize(lpis->lpII));
        lpis->lpII = NULL;
    }

    return lpis->lpII;
}



/*******************************************************************************************
** inf_ScanSourceTarget  (local routine)
**
** Get the source and target, and then run through all the inf files if there is a source
** and find the target file that matches and add the source to the database
**
*******************************************************************************************/
BOOL CALLBACK inf_ScanSourceTarget(HINF      hInf,
                                   LPCTSTR   pmszFields,
                                   LPVOID    pCookie) {
    ASSERT(pmszFields);   // Should never be NULL, we allocate it
    ASSERT(pCookie);      // Should never be NULL, we pass it in after check

    LPINFSCAN       lpis      = (LPINFSCAN)pCookie;
    LPINFITEMINFO   lpII      = lpis->lpII;
    LPCTSTR         szTarget  = pmszFields;
    BOOL            bRet      = lpII != NULL;

    if (*szTarget && bRet) {   // There is a target file (non NULL)
        LPCTSTR szSource = &pmszFields[ lstrlen(szTarget) + 1 ];

        if (*szSource) {
            DWORD         dwIdx;
            DWORD         dwCount;

            // We don't need to do anything if source and target name are the same, even
            // if they are expressly listed in the inf file

            if ( lstrcmpi ( szTarget, szSource) ) {
                dwCount = lpII->dwCount;

                for(dwIdx = 0; dwIdx < dwCount; ++dwIdx) {
                    if (!lstrcmpi( lpII->aItems[dwIdx].szName, szTarget))
                        // Targets match, write the source file name into the structure
                        lstrcpyn( lpII->aItems[dwIdx].szSource, szSource, INF_MIN_BUFFER );
                }
            }
        }
    }

    return bRet;
}

/******************************************************************************************
** inf_ScanCopyFields (local routine)
**
** Run through the Copy Fields supplied by inf_ScanSection and Scan through those sections
** for Source and Destination Pairs
**
******************************************************************************************/
BOOL CALLBACK inf_ScanCopyFields(HINF hInf, LPCTSTR pmszFields, LPVOID pCookie) {
    ASSERT(pmszFields);

    BOOL bRet = TRUE;

    while(*pmszFields && bRet) {
        if (*pmszFields != TEXT('@'))   // Check for an individual file install
            bRet = inf_ScanSection( hInf, pmszFields, NULL, pCookie, inf_ScanSourceTarget);

        pmszFields += lstrlen(pmszFields) + 1;
    }

    return bRet;
}




/*****************************************************************************\
* inf_BuildWNTList (Local Routine)
*
* This builds our list from the NT scan-file-queue of an inf-parser.
*
\*****************************************************************************/
LPINFITEMINFO inf_BuildWNTList(
    LPINFINFO lpInf,
    LPCTSTR   lpszMfgName,
    LPINFSCAN lpis)
{
    LPTSTR   lpszIns;
    HSPFILEQ hFQ;
    DWORD    dwRet;
    BOOL     bRet = FALSE;


    if (lpszIns = inf_GetInsLine(lpInf, lpszMfgName)) {

        SetupSetPlatformPathOverride(genStrCliOverride(lpInf->idxPlt));

        hFQ = SetupOpenFileQueue();
        if (hFQ != INVALID_HANDLE_VALUE) {

            inf_SetDirIds(lpInf);

            bRet = SetupInstallFilesFromInfSection(lpInf->hInfObj,
                                                   NULL,
                                                   hFQ,
                                                   lpszIns,
                                                   NULL,
                                                   0);

            if (bRet) {
                // Setup the user-defined data passed to the
                // enum-callback.
                //
                dwRet = 0;
                bRet = SetupScanFileQueue(hFQ,
                                          SPQ_SCAN_USE_CALLBACK,
                                          0,
                                          inf_ScanFiles,
                                          (LPVOID)lpis,
                                          &dwRet);
            }

            SetupCloseFileQueue(hFQ);

            // Now that we have all of the files, we run through the inf file to see what the
            // original file names where. If they are different, we insert them into
            // the inf file

            if (bRet)
                bRet = inf_ScanSection(lpInf->hInfObj,
                                      lpszIns,
                                      g_szCopyFiles,
                                      (PVOID)lpis,
                                      inf_ScanCopyFields
                                      );
        }

        SetupSetPlatformPathOverride(NULL);

        genGFree(lpszIns, genGSize(lpszIns));
    }

    if (bRet == FALSE) {
        genGFree(lpis->lpII, genGSize(lpis->lpII));
        lpis->lpII = NULL;
    }


    return lpis->lpII;
}


/*****************************************************************************\
* inf_GetItemList (Local Routine)
*
* Get the items from the INF file and build our array of files from this
* search.  This does quite a bit of work.
*
\*****************************************************************************/
LPINFITEMINFO inf_GetItemList(
    LPINFINFO lpInf,
    LPCTSTR   lpszMfgName)
{
    INFSCAN is;
    DWORD   cbSize;
    BOOL    bRet;


    // Initialize a default-block to contain our inf-items.
    //
    cbSize = sizeof(INFITEMINFO) + (sizeof(INFITEM) * INF_ITEM_BLOCK);


    // Setup a structure which will be utilized by either the
    // setup-scan-file-queue, or our own routine to process W9X
    // items.
    //
    if (is.lpII = (LPINFITEMINFO)genGAlloc(cbSize)) {

        is.lpInf = lpInf;

        // Add the inf-files to the list.
        //
        if (is.lpII = inf_AddInfFile(lpInf, is.lpII)) {

            if (genIsWin9X(lpInf->idxPlt)) {

                is.lpII = inf_BuildW9XList(lpInf, &is);

            } else {

                is.lpII = inf_BuildWNTList(lpInf, lpszMfgName, &is);
            }
        }
    }

    return is.lpII;
}

/*****************************************************************************\
* inf_GetSection (Local Routine)
*
* Allocate a buffer which stores either all section-names or the list of
* items specified by (lpszSection) in an INF file.  Currently, we attempt
* a realloc if the buffer is not big enough.
*
\*****************************************************************************/
LPTSTR inf_GetSection(
    LPINFINFO lpInf,
    LPCTSTR   lpszSct)
{
    LPTSTR lpszInfFile;
    DWORD  dwCnt;
    DWORD  cch;
    DWORD  dwSize;
    DWORD  dwLimit;
    LPTSTR lpszNames = NULL;


    // Get the inf-file-name whith contains the specified section.
    //
    if (lpszInfFile = inf_GetInfFile(lpInf->hInfObj, lpszSct)) {

        dwSize  = 0;
        dwLimit = 0;

        while (dwLimit < INF_SECTION_LIMIT) {

            // We'll start this allocation with an assumed max-size.  Upon
            // successive tries, this buffer is increased each time by the
            // original buffer allocation.
            //
            dwSize += (INF_SECTION_BLOCK * sizeof(TCHAR));
            dwLimit++;


            // Alloc the buffer and attempt to get the names.
            //
            if (lpszNames = (LPTSTR)genGAlloc(dwSize)) {

                // If a section-name is profided, use that.  Otherwise,
                // enumerate all section-names.
                //
                cch = dwSize / sizeof(TCHAR);

                if (lpszSct) {

                    dwCnt = GetPrivateProfileSection(lpszSct,
                                                     lpszNames,
                                                     cch,
                                                     lpszInfFile);
                } else {

                    dwCnt = GetPrivateProfileSectionNames(lpszNames,
                                                          cch,
                                                          lpszInfFile);
                }


                // If the call says the buffer was OK, then we can
                // assume the names are retrieved.  According to spec's,
                // if the return-count is equal to size-2, then buffer
                // isn't quite big-enough (two NULL chars).
                //
                if (dwCnt < (cch - 2))
                    goto GetSectDone;


                genGFree(lpszNames, dwSize);
                lpszNames = NULL;
            }
        }

GetSectDone:

        SPLASSERT((dwLimit < INF_SECTION_LIMIT));

        genGFree(lpszInfFile, genGSize(lpszInfFile));
    }

    return lpszNames;
}


/*****************************************************************************\
* inf_GetMfgName (Local Routine)
*
* Get the manufacture-name from the driver-name.  Some drivers do not really
* begin with the manufacture-name.  These will have to be special-cased
* to determine their cooresponding manufacturer-name.
*
\*****************************************************************************/
LPTSTR inf_GetMfgNameExe(
    LPINFINFO lpInf)
{
    INFCONTEXT ic;
    BOOL       bFind;
    LPTSTR     lpszNames;
    LPTSTR     lpszDrvCpy;
    LPTSTR     lpszPtr;
    LPTSTR     lpszMfgName = NULL;


    // Make a copy for us to muck with.
    //
    if (lpszDrvCpy = genGAllocStr(lpInf->lpszDrvName)) {

        // Let's assume the best-case and the model-name's first word
        // is the Manufacturer.  All we need in this case is to find
        // the first <space> in the driver-name.
        //
        // Find the first word to use in locating the manufacturer.
        //
        if (lpszPtr = genFindChar(lpszDrvCpy, TEXT(' ')))
            *lpszPtr = TEXT('\0');



        // Take the first-word and try to get a manufacture out
        // of it.
        //
        if (lpszMfgName = genGAllocStr(lpszDrvCpy)) {

            // Look for the module-name in the manufacturers section.  This
            // will return us an index into the inf-file.
            //
            bFind = inf_GetIdx(lpszMfgName,
                               lpInf->lpszDrvName,
                               lpInf->hInfObj,
                               &ic);


            // If the model-manufacturer lookup failed, then we
            // need to look at other model-manufacturer mappings.
            //
            if (bFind == FALSE) {

                // Free the existing string used for this test.  Since,
                // we could conceptually come up with another manufacturer
                // name for this model.
                //
                genGFree(lpszMfgName, genGSize(lpszMfgName));
                lpszMfgName = NULL;


                // Since we were not able to find the model-name through
                // conventional means, we are going to look through every
                // section-name in the Inf for the model-name.
                //
                if (lpszNames = inf_GetSection(lpInf, NULL)) {

                    lpszPtr = lpszNames;

                    while (*lpszPtr != TEXT('\0')) {

                        bFind = inf_GetIdx(lpszPtr,
                                           lpInf->lpszDrvName,
                                           lpInf->hInfObj,
                                           &ic);

                        // See if we found a match.  If so, break out
                        // of our loop.
                        //
                        if (bFind) {
                            lpszMfgName = genGAllocStr(lpszPtr);
                            break;
                        }


                        // Goto the next section.
                        //
                        lpszPtr = inf_NextStr(lpszPtr);
                    }

                    genGFree(lpszNames, genGSize(lpszNames));
                }
            }
        }

        genGFree(lpszDrvCpy, genGSize(lpszDrvCpy));
    }

    return lpszMfgName;
}



/*****************************************************************************\
* inf_GetMfgName (Local Routine)
*
* Get the manufacture-name from the driver-name.  Some drivers do not really
* begin with the manufacture-name.  These will have to be special-cased
* to determine their cooresponding manufacturer-name.
*
\*****************************************************************************/
LPTSTR inf_GetMfgName(
    LPINFINFO lpInf)
{
    HANDLE hPrinter;
    LPTSTR lpszMfgName = NULL;


    if (OpenPrinter(lpInf->lpszFrnName, &hPrinter, NULL)) {
        DWORD    cbNeeded = 0;
        LPTSTR   lpszClientEnvironment = (LPTSTR)genStrCliEnvironment(lpInf->idxPlt);

        GetPrinterDriver( hPrinter,
                          lpszClientEnvironment,
                          6,
                          NULL,
                          0,
                          &cbNeeded
                          );

        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {
            LPBYTE pData;
            DWORD  dwSize = cbNeeded;

            if ( pData = (LPBYTE) genGAlloc(cbNeeded) ) {
                if (GetPrinterDriver( hPrinter,
                                      lpszClientEnvironment,
                                      6,
                                      pData,
                                      dwSize,
                                      &cbNeeded) ) {
                    PDRIVER_INFO_6 pDriverInfo = (PDRIVER_INFO_6) pData;

                    if (pDriverInfo->pszMfgName)
                        lpszMfgName = genGAllocStr(pDriverInfo->pszMfgName);
                        else
                        SetLastError(ERROR_BAD_ENVIRONMENT);

                }
                genGFree( pData, dwSize );
            }
        }

        ClosePrinter(hPrinter);
    }

    if (NULL == lpszMfgName)
        lpszMfgName = inf_GetMfgNameExe(lpInf);

    return lpszMfgName;
}


/*****************************************************************************\
* inf_BuildItems (Local Routine)
*
* This routine builds a file-list of items that the INF setup requires.
*
\*****************************************************************************/
LPINFITEMINFO inf_BuildItems(
    LPINFINFO lpInf)
{
    LPTSTR        lpszMfgName;
    LPINFITEMINFO lpItems = NULL;


    // Get the manufacturer-name that we will be dealing with.  If
    // we can't find the matching name that cooresponds with our driver,
    // then no need to proceed.
    //
    if (lpszMfgName = inf_GetMfgName(lpInf)) {

        // Build the item-list.  If successful, then rewrite our new
        // inf-files for a flat-install.
        //
        lpItems = inf_GetItemList(lpInf, lpszMfgName);

        genGFree(lpszMfgName, genGSize(lpszMfgName));
    }

    return lpItems;
}


/*****************************************************************************\
* infCreate
*
* Creates an INF object.
*
\*****************************************************************************/
HANDLE infCreate(
    LPINFGENPARM lpParm)
{
    LPINFINFO lpInf;


    if (lpInf = (LPINFINFO)genGAlloc(sizeof(INFINFO))) {

        lpInf->dwCliInfo = lpParm->dwCliInfo;
        lpInf->idxPlt    = lpParm->idxPlt;
        lpInf->idxVer    = lpParm->idxVer;

        // Allocate our parameter-strings.
        //
        if ( inf_AllocStrings(lpInf, lpParm) )
             return (HANDLE)lpInf;

        // Since the allocate Strings failed free up the Object
        genGFree(lpInf, sizeof(INFINFO));
    }

    return NULL;
}

/*****************************************************************************\
* infProcess
*
* Uses INF object to prepare for CAB.
*
\*****************************************************************************/
BOOL infProcess(
    HANDLE hInf)
{

    LPINFINFO lpInf = (LPINFINFO) hInf;

    // Create handle to setup-inf-object.  This requires
    // strings in lpInf to be allocated and correct.
    //
    lpInf->hInfObj = inf_GetInfObj(lpInf);
    if ( lpInf->hInfObj != INVALID_HANDLE_VALUE )  {

        // Retrieve the inf-name from the inf-object.
        //
        if (lpInf->lpszInfName = inf_GetInfName(lpInf)) {

            // Build our file object-list.
            //
            if (lpInf->lpInfItems = inf_BuildItems(lpInf)) {

                // Next, use the item list to determine the cat file and add it
                // to the list.  This can't be done any earlier (like in inf_BuildItems() )
                // because it uses the infEnumItems callback, and so it relies on the
                // item list being setup already.
                //
                if (genIsWin9X(lpInf->idxPlt)) {

                    // Do something different here for 9X?
                    // The server isn't caching the CAT files for 9X drivers, so
                    // we don't have access to them anyway.
                    //
                    return TRUE;
                }
                else {
                    if (inf_AddCATFile(lpInf)) {
                        return TRUE;
                    }
                }
            }
        }

        // Some Type of failure...
        infSetError(lpInf,GetLastError());
    }

    return FALSE;
}

/*****************************************************************************\
* infDestroy
*
* Destroys the INF object and all resources allocated on its behalf.
*
\*****************************************************************************/
BOOL infDestroy(
    HANDLE hInf)
{
    LPINFINFO lpInf;
    BOOL      bFree = FALSE;


    if (lpInf = (LPINFINFO)hInf) {

        if (lpInf->hInfObj != INVALID_HANDLE_VALUE)
            SetupCloseInfFile(lpInf->hInfObj);

        if (lpInf->lpszInfName)
            genGFree(lpInf->lpszInfName, genGSize(lpInf->lpszInfName));

        if (lpInf->lpszFrnName)
            genGFree(lpInf->lpszFrnName, genGSize(lpInf->lpszFrnName));

        if (lpInf->lpszDrvName)
            genGFree(lpInf->lpszDrvName, genGSize(lpInf->lpszDrvName));

        if (lpInf->lpszDrvPath)
            genGFree(lpInf->lpszDrvPath, genGSize(lpInf->lpszDrvPath));

        if (lpInf->lpszDstName)
            genGFree(lpInf->lpszDstName, genGSize(lpInf->lpszDstName));

        if (lpInf->lpszDstPath)
            genGFree(lpInf->lpszDstPath, genGSize(lpInf->lpszDstPath));

        if (lpInf->lpszPrtName)
            genGFree(lpInf->lpszPrtName, genGSize(lpInf->lpszPrtName));

        if (lpInf->lpszShrName)
            genGFree(lpInf->lpszShrName, genGSize(lpInf->lpszShrName));

        if (lpInf->lpInfItems)
            genGFree(lpInf->lpInfItems, genGSize(lpInf->lpInfItems));

        bFree = genGFree(lpInf, sizeof(INFINFO));
    }

    return bFree;
}


/*****************************************************************************\
* infEnumItems
*
* Enumerates the file-items in the INF object.  Enumeration will stop if the
* user-callback returns FALSE.  Otherwise, it will exhaust all files in the
* list.
*
\*****************************************************************************/
BOOL infEnumItems(
    HANDLE      hInf,
    INFENUMPROC pfnEnum,
    LPVOID      lpvData)
{
    LPINFINFO     lpInf;
    LPINFITEMINFO lpII;
    DWORD         dwItems;
    DWORD         idx;
    BOOL          bRet = FALSE;


    if ((lpInf = (LPINFINFO)hInf) && (dwItems = lpInf->lpInfItems->dwCount)) {

        for (idx = 0, lpII = lpInf->lpInfItems; idx < dwItems; idx++) {

            bRet = (*pfnEnum)(lpII->aItems[idx].szName,
                              lpII->aItems[idx].szPath,
                              lpII->aItems[idx].bInf,
                              lpvData);

            if (bRet == FALSE)
                return FALSE;
        }
    }

    return bRet;
}


/*****************************************************************************\
* infGetEnvArch
*
* Returns the platform/environment type identifier.
*
\*****************************************************************************/
WORD infGetEnvArch(
    HANDLE hInf)
{
    LPINFINFO lpInf;
    WORD      wType = PROCESSOR_ARCHITECTURE_UNKNOWN;


    if (lpInf = (LPINFINFO)hInf)
        wType = genValCliArchitecture(lpInf->idxPlt);

    return wType;
}


/*****************************************************************************\
* infGetEnvArchCurr
*
* Returns the platform/environment type for the current-architecture.
*
\*****************************************************************************/
WORD infGetEnvArchCurr(
    HANDLE hInf)
{
    return genValSvrArchitecture();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\genglobl.cxx ===
/*****************************************************************************\
* MODULE: genglobl.c
*
* The module contains global-vars for generation routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 <chriswil>  Created.
*
\*****************************************************************************/

#include "pch.h"

// Synchonization section.  We only allow one cab-generation at a time.
//
CRITICAL_SECTION g_csGenCab;


// Command-Line Strings.
//
CONST TCHAR g_szCabCmd[] = TEXT("%s\\system32\\iexpress.exe /Q /N %s");
CONST TCHAR g_szSedCmd[] = TEXT("wpnpinst.exe @%s.webpnp");
CONST TCHAR g_szDatCmd[] = TEXT("/if\n/x\n/b \"%s\"\n/f \"%s\"\n/r \"%s\"\n/m \"%s\"\n/n \"%s\"\n/a \"%s\" /q\n");


// Executable Names.
//
CONST TCHAR g_szNtPrintDll[] = TEXT("ntprint.dll");
CONST TCHAR g_szCabName[]    = TEXT("%04X%s%d");
CONST TCHAR g_szDatName[]    = TEXT("%04X");
CONST TCHAR g_szDatFile[]    = TEXT("cab_ipp.dat");


// File-Extension Strings.
//
CONST TCHAR g_szDotCab[] = TEXT(".cab");
CONST TCHAR g_szDotInf[] = TEXT(".inf");
CONST TCHAR g_szDotSed[] = TEXT(".sed");
CONST TCHAR g_szDotDat[] = TEXT(".dat");
CONST TCHAR g_szDotBin[] = TEXT(".bin");
CONST TCHAR g_szDotIpp[] = TEXT(".webpnp");
CONST TCHAR g_szDotCat[] = TEXT(".cat");


// Cab, Environment and Platform-Override strings.  These strings
// are built into a table in (genutil.cxx) which describes the various
// architectures and version info.
//
CONST TCHAR g_szCabX86[] = TEXT("X86");
CONST TCHAR g_szCabAXP[] = TEXT("AXP");
CONST TCHAR g_szCabPPC[] = TEXT("PPC");
CONST TCHAR g_szCabMIP[] = TEXT("MIP");
CONST TCHAR g_szCabW9X[] = TEXT("W9X");
CONST TCHAR g_szCabI64[] = TEXT("I64");
CONST TCHAR g_szCabAMD64[] = TEXT("AMD64");

CONST TCHAR g_szEnvX86[] = TEXT("Windows NT x86");
CONST TCHAR g_szEnvAXP[] = TEXT("Windows NT Alpha_AXP");
CONST TCHAR g_szEnvPPC[] = TEXT("Windows NT PowerPC");
CONST TCHAR g_szEnvMIP[] = TEXT("Windows NT R4000");
CONST TCHAR g_szEnvW9X[] = TEXT("Windows 4.0");
CONST TCHAR g_szEnvI64[] = TEXT("Windows IA64");
CONST TCHAR g_szEnvAMD64[] = TEXT("Windows AMD64");

CONST TCHAR g_szPltX86[] = TEXT("i386");
CONST TCHAR g_szPltAXP[] = TEXT("alpha");
CONST TCHAR g_szPltPPC[] = TEXT("ppc");
CONST TCHAR g_szPltMIP[] = TEXT("mips");
CONST TCHAR g_szPltW9X[] = TEXT("i386");
CONST TCHAR g_szPltI64[] = TEXT("ia64");
CONST TCHAR g_szPltAMD64[] = TEXT("amd64");


// Registry Strings.
//
CONST TCHAR g_szPrtReg[]        = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Printers");
CONST TCHAR g_szIpAddr[]        = TEXT("IpAddr");
CONST TCHAR g_szPnpData[]       = TEXT("PnpData");
CONST TCHAR g_szMfgName[]       = TEXT("Manufacturer");
CONST TCHAR g_szPrtCabs[]       = TEXT("PrtCabs");
CONST TCHAR g_szPrtDir[]        = TEXT("/Printers");

// Metabase String for path to check for virtual roots
//

CONST TCHAR g_szMetabasePath[]  = TEXT("LM/W3SVC/1/ROOT/PRINTERS");


// NTPRINT Function-Pointers.  These are used in GetProcAddress().
// Therefore, require they be CHAR types.
//
CONST CHAR g_szSetupCreate[]  = "PSetupCreatePrinterDeviceInfoList";
CONST CHAR g_szSetupDestroy[] = "PSetupDestroyPrinterDeviceInfoList";
CONST CHAR g_szSetupGet[]     = "PSetupGetDriverInfForPrinter";


// Common Strings.
//
CONST TCHAR g_szEmptyStr[]    = TEXT("");
CONST TCHAR g_szBkSlash[]     = TEXT("\\");
CONST TCHAR g_szVersionSect[] = TEXT("Version");


// INF-File Strings.
//
CONST TCHAR g_szSkipDir[]        = TEXT("A:\\__Skip__");
CONST TCHAR g_szDestDirs[]       = TEXT("DestinationDirs");
CONST TCHAR g_szPrinterClass[]   = TEXT("Printer");
CONST TCHAR g_szCopyFiles[]      = TEXT("CopyFiles");
CONST TCHAR g_szLayoutKey[]      = TEXT("LayoutFile");
CONST TCHAR g_szWinDirSect[]     = TEXT("WinntDirectories");
CONST TCHAR g_szSrcDskFileSect[] = TEXT("SourceDisksFiles");


// SED-File Strings.
//
CONST TCHAR g_szIExpress[]           = TEXT("IExpress");
CONST TCHAR g_szPackagePurpose[]     = TEXT("PackagePurpose");
CONST TCHAR g_szCreateCAB[]          = TEXT("CreateCAB");
CONST TCHAR g_szPostInstallCmd[]     = TEXT("PostInstallCmd");
CONST TCHAR g_szCompressionMemory[]  = TEXT("CompressionMemory");
CONST TCHAR g_szCompressionValue[]   = TEXT("19");
CONST TCHAR g_szCompressionType[]    = TEXT("CompressionType");
CONST TCHAR g_szCompressTypeVal[]    = TEXT("LZX");
CONST TCHAR g_szCompressionQuantum[] = TEXT("Quantum");
CONST TCHAR g_szCompressionQuantVal[]= TEXT("7");
CONST TCHAR g_szNone[]               = TEXT("<None>");
CONST TCHAR g_szClass[]              = TEXT("Class");
CONST TCHAR g_szSEDVersion[]         = TEXT("SEDVersion");
CONST TCHAR g_szOptions[]            = TEXT("Options");
CONST TCHAR g_szShowWindow[]         = TEXT("ShowInstallProgramWindow");
CONST TCHAR g_szUseLongFileName[]    = TEXT("UseLongFileName");
CONST TCHAR g_szHideAnimate[]        = TEXT("HideExtractAnimation");
CONST TCHAR g_szRebootMode[]         = TEXT("RebootMode");
CONST TCHAR g_szExtractorStub[]      = TEXT("ExtractorStub");
CONST TCHAR g_szSourceFiles[]        = TEXT("SourceFiles");
CONST TCHAR g_szStrings[]            = TEXT("Strings");
CONST TCHAR g_szTimeStamps[]         = TEXT("TimeStamps");
CONST TCHAR g_szSEDVersionNumber[]   = TEXT("2.0");
CONST TCHAR g_sz1[]                  = TEXT("1");
CONST TCHAR g_sz0[]                  = TEXT("0");
CONST TCHAR g_szNoReboot[]           = TEXT("N");
CONST TCHAR g_szTargetName[]         = TEXT("TargetName");
CONST TCHAR g_szAppLaunched[]        = TEXT("AppLaunched");
CONST TCHAR g_szTargetNameSection[]  = TEXT("%TargetName%");
CONST TCHAR g_szAppLaunchedSection[] = TEXT("%AppLaunched%");


#if 0
                             "ClassGUID = {4D36E979-E325-11CE-BFC1-08002BE10318}\r\n"
#endif

CONST CHAR g_szInfSctVer[] = "[Version]\r\n"                                           \
                             "Signature = \"$CHICAGO$\"\r\n"                           \
                             "Class = Printer\r\n"                                     \
                             "InfVersion = 1.0.1\r\n"                                  \
                             "Provider = %MS%\r\n";

CONST CHAR g_szInfSctMfg[] = "\r\n[Manufacturer]\r\n" \
                             "%%MS%% = %hs\r\n";

CONST CHAR g_szInfSctDrv[] = "\r\n[%hs]\r\n"                   \
                             "\"%hs\" = %hs, InetPrinter\r\n";

CONST CHAR g_szInfSctIns[] = "\r\n[%hs]\r\n"                    \
                             "CopyFiles = FileList\r\n"         \
                             "DataSection = InetDriverData\r\n";

CONST CHAR g_szInfSctFil[] = "\r\n[FileList]\r\n";

CONST CHAR g_szInfSctDta[] = "\r\n[InetDriverData]\r\n" \
                             "DataFile = %hs\r\n"       \
                             "HelpFile = %hs\r\n";                              \

CONST CHAR g_szInfSctStr[] = "\r\n[Strings]\r\n" \
                             "MS = \"Inet\"\r\n"    \
                             "DISK1 = \"Disk1\"\r\n";

CONST CHAR g_szInfSctSDN[] = "\r\n[SourceDisksNames]\r\n"  \
                             "1 = %DISK1%,, 0000-0000\r\n";

CONST CHAR g_szInfSctSDF[] = "\r\n[SourceDisksFiles]\r\n";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\globals.cxx ===
/***************************************************************************
FILE                            globals.cpp

MODULE                          Printers ISAPI DLL

PURPOSE                         Windows HTML printer UI over WWW/HTTP

DESCRIBED IN

HISTORY     01/16/96 eriksn     Created based on ISAPI sample DLL
            03/05/97 weihaic    More feature added

****************************************************************************/

#include "pch.h"
#include "printers.h"

// Global Variables; once per process

// Critical section for job spooling info
CRITICAL_SECTION SplCritSect = {0, 0, 0, 0, 0, 0};
// Critical section for maintaining the loaded tag processor list
CRITICAL_SECTION TagCritSect = {0, 0, 0, 0, 0, 0};


// Debugging Environment (SPLLIB).
//
#ifdef DEBUG
MODULE_DEBUG_INIT(DBG_ERROR | DBG_WARN | DBG_TRACE, DBG_ERROR);
#else
MODULE_DEBUG_INIT(DBG_ERROR | DBG_WARN | DBG_TRACE, 0);
#endif

// Query map relates a query string to what it does.
const QUERY_MAP rgQueryMap[] =
{
    TEXT ("IPP"),                      CMD_IPP,
    TEXT ("CreateExe"),                CMD_CreateExe,
};
const int iNumQueryMap = ARRAY_COUNT(rgQueryMap);

TCHAR       g_szComputerName[INTERNET_MAX_HOST_NAME_LENGTH + 1];

//
// g_szHttpServerName is the server name in HTTP request
//
TCHAR       g_szHttpServerName[INTERNET_MAX_HOST_NAME_LENGTH + 1];

//
// g_szPrintServerName is the server name used in OpenPrinter
// If the web server is behind a firewall the PrintServerName 
// will be different from HttpServerName because the public network
// address is different from the private network address
//
TCHAR       g_szPrintServerName[INTERNET_MAX_HOST_NAME_LENGTH + 1];

HINSTANCE   g_hInstance = NULL;

// TEXT ("PrintersFolder") is not a localizable string
LPTSTR      g_szPrintersFolder  = TEXT ("PrintersFolder");
LPTSTR      g_szPrinters        = TEXT ("Printers");
LPTSTR      g_szRemotePortAdmin = TEXT ("RemotePortAdmin");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\genglobl.h ===
/*****************************************************************************\
* MODULE: genglobl.h
*
* This is the main header for genglobl file.  Global variables for the
* generation routines.
*
*
* Copyright (C) 1996-1997 Microsoft Corporation
* Copyright (C) 1996-1997 Hewlett Packard
*
* History:
*   22-Nov-1996 <chriswil>  Created.
*
\*****************************************************************************/

#define SIGNATURE_UNICODE ((WORD)0xFEFF)


// Synchonization section.  We only allow one cab-generation at a time.
//
extern CRITICAL_SECTION g_csGenCab;


// Command-Line Strings.
//
extern CONST TCHAR g_szCabCmd[];
extern CONST TCHAR g_szSedCmd[];
extern CONST TCHAR g_szDatCmd[];


// Executable Names.
//
extern CONST TCHAR g_szNtPrintDll[];
extern CONST TCHAR g_szCabName[];
extern CONST TCHAR g_szDatName[];
extern CONST TCHAR g_szDatFile[];


// File-Extension Strings.
//
extern CONST TCHAR g_szDotCab[];
extern CONST TCHAR g_szDotInf[];
extern CONST TCHAR g_szDotSed[];
extern CONST TCHAR g_szDotDat[];
extern CONST TCHAR g_szDotBin[];
extern CONST TCHAR g_szDotIpp[];
extern CONST TCHAR g_szDotCat[];


// Cab, Environment and Platform-Override strings.
//
extern CONST TCHAR g_szCabX86[];
extern CONST TCHAR g_szCabAXP[];
extern CONST TCHAR g_szCabPPC[];
extern CONST TCHAR g_szCabMIP[];
extern CONST TCHAR g_szCabW9X[];
extern CONST TCHAR g_szCabI64[];
extern CONST TCHAR g_szCabAMD64[];

extern CONST TCHAR g_szEnvX86[];
extern CONST TCHAR g_szEnvAXP[];
extern CONST TCHAR g_szEnvPPC[];
extern CONST TCHAR g_szEnvMIP[];
extern CONST TCHAR g_szEnvW9X[];
extern CONST TCHAR g_szEnvI64[];
extern CONST TCHAR g_szEnvAMD64[];

extern CONST TCHAR g_szPltX86[];
extern CONST TCHAR g_szPltAXP[];
extern CONST TCHAR g_szPltPPC[];
extern CONST TCHAR g_szPltMIP[];
extern CONST TCHAR g_szPltW9X[];
extern CONST TCHAR g_szPltI64[];
extern CONST TCHAR g_szPltAMD64[];


// Registry Strings.
//
extern CONST TCHAR g_szPrtReg[];
extern CONST TCHAR g_szIpAddr[];
extern CONST TCHAR g_szPnpData[];
extern CONST TCHAR g_szMfgName[];
extern CONST TCHAR g_szPrtCabs[];
extern CONST TCHAR g_szPrtDir[];

// Metabase paths
//
extern CONST TCHAR g_szMetabasePath[];

// NTPRINT Function-Pointers.  These are used in GetProcAddress().
// Therefore, require they be CHAR types.
//
extern CONST CHAR g_szSetupCreate[];
extern CONST CHAR g_szSetupDestroy[];
extern CONST CHAR g_szSetupGet[];


// Common Strings.
//
extern CONST TCHAR g_szEmptyStr[];
extern CONST TCHAR g_szBkSlash[];
extern CONST TCHAR g_szVersionSect[];


// INF-File Strings.
//
extern CONST TCHAR g_szSkipDir[];
extern CONST TCHAR g_szDestDirs[];
extern CONST TCHAR g_szPrinterClass[];
extern CONST TCHAR g_szCopyFiles[];
extern CONST TCHAR g_szLayoutKey[];
extern CONST TCHAR g_szWinDirSect[];
extern CONST TCHAR g_szSrcDskFileSect[];


// SED-File Strings.
//
extern CONST TCHAR g_szIExpress[];
extern CONST TCHAR g_szPackagePurpose[];
extern CONST TCHAR g_szCreateCAB[];
extern CONST TCHAR g_szPostInstallCmd[];
extern CONST TCHAR g_szCompressionMemory[];
extern CONST TCHAR g_szCompressionValue[];
extern CONST TCHAR g_szCompressionType[];
extern CONST TCHAR g_szCompressTypeVal[];
extern CONST TCHAR g_szCompressionQuantum[];
extern CONST TCHAR g_szCompressionQuantVal[];
extern CONST TCHAR g_szNone[];
extern CONST TCHAR g_szClass[];
extern CONST TCHAR g_szSEDVersion[];
extern CONST TCHAR g_szOptions[];
extern CONST TCHAR g_szShowWindow[];
extern CONST TCHAR g_szUseLongFileName[];
extern CONST TCHAR g_szHideAnimate[];
extern CONST TCHAR g_szRebootMode[];
extern CONST TCHAR g_szExtractorStub[];
extern CONST TCHAR g_szSourceFiles[];
extern CONST TCHAR g_szStrings[];
extern CONST TCHAR g_szTimeStamps[];
extern CONST TCHAR g_szSEDVersionNumber[];
extern CONST TCHAR g_sz1[];
extern CONST TCHAR g_sz0[];
extern CONST TCHAR g_szNoReboot[];
extern CONST TCHAR g_szTargetName[];
extern CONST TCHAR g_szAppLaunched[];
extern CONST TCHAR g_szTargetNameSection[];
extern CONST TCHAR g_szAppLaunchedSection[];


// Inf Generater Strings.
//
extern CONST CHAR g_szInfSctVer[];
extern CONST CHAR g_szInfSctMfg[];
extern CONST CHAR g_szInfSctDrv[];
extern CONST CHAR g_szInfSctIns[];
extern CONST CHAR g_szInfSctFil[];
extern CONST CHAR g_szInfSctDta[];
extern CONST CHAR g_szInfSctStr[];
extern CONST CHAR g_szInfSctSDN[];
extern CONST CHAR g_szInfSctSDF[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\inetio.cxx ===
/*****************************************************************************\
* MODULE: inetinfo.cxx
*
*
* PURPOSE:  Handles the data pumping to the client via IIS
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*     01/16/96 eriksn     Created based on ISAPI sample DLL
*     07/15/96 babakj     Moved to a separate file
*     05/12/97 weihaic    ASP template support
*
\*****************************************************************************/

#include "pch.h"
#include "printers.h"


static char c_szRemoteHost[]      = "REMOTE_HOST";
static char c_szServerName[]      = "SERVER_NAME";


/* AnsiToUnicodeString
 *
 * Parameters:
 *
 *     pAnsi - A valid source ANSI string.
 *
 *     pUnicode - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source ANSI string.
 *         If 0 , the string is assumed to be
 *         null-terminated.
 *
 * Return:
 *
 *     The return value from MultiByteToWideChar, the number of
 *         wide characters returned.
 *
 *
 */
INT AnsiToUnicodeString( LPSTR pAnsi, LPWSTR pUnicode, UINT StringLength )
{
    INT iReturn;

    if( StringLength == 0 )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


/* UnicodeToAnsiString
 *
 * Parameters:
 *
 *     pUnicode - A valid source Unicode string.
 *
 *     pANSI - A pointer to a buffer large enough to accommodate
 *         the converted string.
 *
 *     StringLength - The length of the source Unicode string.
 *         If 0 , the string is assumed to be
 *         null-terminated.
 *
 *
 * Notes:
 *      Added the #ifdef DBCS directive for MS-KK, if compiled
 *      with DBCS enabled, we will allocate twice the size of the
 *      buffer including the null terminator to take care of double
 *      byte character strings - KrishnaG
 *
 *      pUnicode is truncated to StringLength characters.
 *
 * Return:
 *
 *     The return value from WideCharToMultiByte, the number of
 *         multi-byte characters returned.
 *
 *
 */
INT
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    UINT StringLength)
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( !StringLength  ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }


    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //
    //if (pUnicode[StringLength])
    //    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //
    if( pAnsi == (LPSTR)pUnicode )
    {
        // Allocate enough memory anyway (in case of the far easten language
        // the conversion needs that much
        pTempBuf = (LPSTR) LocalAlloc( LPTR, (1 + StringLength) * 2 );

        if (!pTempBuf) {
            return 0;
        }

        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength * 2,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}

LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
)
{
    LPWSTR  pUnicodeString;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR) LocalAlloc(LPTR, strlen(pAnsiString) * sizeof(WCHAR) +
                                          sizeof(WCHAR));

    if (pUnicodeString)
        AnsiToUnicodeString(pAnsiString, pUnicodeString, 0);

    return pUnicodeString;
}


//======================================================================
//                  HTML HELPER FUNCTIONS
//======================================================================

///////////////////////////////////////////////////////////////////////////////////////
//
// Server communications: First we send a HSE_REQ_SEND_RESPONSE_HEADER.
// Then we do WriteClient if we have leftover data.
//
// This routune allows a string to be written to the client using printf syntax.
//
///////////////////////////////////////////////////////////////////////////////////////


/********************************************************************************

Name:
    htmlSendRedirect

Description:

    Send a redirect to the client to let the client request the server again

Arguments:

    pAllInfo:   Pointer to the ALLINFO structure
    lpszURL:    The redirect URL. It is the unicode version of the URL.
                Its content will be modified!!!

Return Value:
    TRUE  if succeed, FASE otherwise.

********************************************************************************/

BOOL htmlSendRedirect(PALLINFO pAllInfo, LPTSTR lpszURL)
{
    DWORD   dwLen;


    if (lpszURL && (dwLen = UnicodeToAnsiString (lpszURL, (LPSTR) lpszURL, NULL))) {
        return pAllInfo->pECB->ServerSupportFunction(pAllInfo->pECB->ConnID,
                                                     HSE_REQ_SEND_URL_REDIRECT_RESP,
                                                     (LPVOID) lpszURL,
                                                     &dwLen,
                                                     NULL);
    }
    else
        return FALSE;
}

unsigned long GetIPAddr (LPSTR lpName)
{
    struct hostent * hp;
    struct sockaddr_in dest,from;

    if (! (hp = gethostbyname(lpName))) {
        return inet_addr(lpName);
    }

    memcpy (&(dest.sin_addr),hp->h_addr,hp->h_length);
    return dest.sin_addr.S_un.S_addr;
}


#if 0
BOOL IsClientSameAsServer(EXTENSION_CONTROL_BLOCK *pECB)
{
    LPSTR   lpServer    = NULL;
    LPSTR   lpClient    = NULL;
    DWORD   dwSize      = 32;
    BOOL    bRet        = FALSE;
    DWORD   dwClient;
    DWORD   dwServer;

    if (! (lpClient = (LPSTR) LocalAlloc (LPTR, dwSize))) goto Cleanup;

    if (!pECB->GetServerVariable (pECB->ConnID, c_szRemoteHost, lpClient, &dwSize))
        if (GetLastError () == ERROR_INSUFFICIENT_BUFFER) {
            LocalFree (lpClient);
            lpClient = NULL;
            if ( !(lpClient = (LPSTR) LocalAlloc (LPTR, dwSize)) ||
                !pECB->GetServerVariable (pECB->ConnID, c_szRemoteHost, lpClient, &dwSize))
                goto Cleanup;;
        }
        else
            goto Cleanup;

    if (! (lpServer = (LPSTR) LocalAlloc (LPTR, dwSize))) goto Cleanup;

    if (!pECB->GetServerVariable (pECB->ConnID, c_szServerName, lpServer, &dwSize))
        if (GetLastError () == ERROR_INSUFFICIENT_BUFFER) {
            LocalFree (lpServer);
            lpServer = NULL;
            if (!(lpServer = (LPSTR) LocalAlloc (LPTR, dwSize)) ||
                !pECB->GetServerVariable (pECB->ConnID, c_szServerName, lpServer, &dwSize))
                goto Cleanup;
        }
        else
            goto Cleanup;

    bRet = GetIPAddr (lpClient) == GetIPAddr (lpServer);

Cleanup:
    LocalFree (lpClient);
    LocalFree (lpServer);
    return bRet;

}
#endif

/********************************************************************************

Name:
    EncodeFriendlyName

Description:

    Encode the friendly name to avoid special characters

Arguments:

    lpText:     the normal text string

Return Value:

    Pointer to the HTML string. The caller is responsible to free the pointer.
    NULL is returned if no enougth memory
********************************************************************************/
LPTSTR EncodeFriendlyName (LPCTSTR lpText)
{
    DWORD   dwLen;
    LPTSTR  lpHTMLStr       = NULL;

    dwLen = 0;
    if (!EncodePrinterName (lpText, NULL, &dwLen) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (lpHTMLStr = (LPTSTR) LocalAlloc (LPTR, dwLen * sizeof (TCHAR))) &&
        EncodePrinterName (lpText, lpHTMLStr, &dwLen))
        return lpHTMLStr;
    else {
        LocalFree (lpHTMLStr);
        return NULL;
    }
}

/********************************************************************************

Name:
    DecodeFriendlyName

Description:

    Decode the frienly name to get rid of %xx pattern.

Arguments:

    lpText:     the encoded printer friendly name

Return Value:

    Pointer to the decoded friendly name.

********************************************************************************/
LPTSTR DecodeFriendlyName (LPTSTR lpStr)
{
    LPTSTR   lpParsedStr = lpStr;
    LPTSTR   lpUnparsedStr = lpStr;
    TCHAR    d1, d2;

    if (!lpStr) return lpStr;

    while (*lpUnparsedStr) {
        switch (*lpUnparsedStr) {
        case '~':
            // To take care the case when the DecodeString ends with %
            if (! (d1 = *++lpUnparsedStr) || (! (d2 = *++lpUnparsedStr)))
                break;
            lpUnparsedStr++;
            *lpParsedStr++ = AscToHex (d1) * 16 + AscToHex (d2);
            break;
        default:
            *lpParsedStr++ = *lpUnparsedStr++;
        }
    }
    *lpParsedStr = NULL;
    return lpStr;
}

BOOL IsClientHttpProvider (PALLINFO pAllInfo)
{
    EXTENSION_CONTROL_BLOCK *pECB;
    DWORD   dwVersion = 0;
    char    buf[64];
    DWORD   dwSize = sizeof (buf);
    // This string is copied from ../inetpp/globals.c
    const   char c_szUserAgent[]     = "Internet Print Provider";

    pECB = pAllInfo->pECB;


    // Check the UserAgent variable at first to see the IE version
    if (pECB->GetServerVariable (pECB->ConnID, "HTTP_USER_AGENT", buf, &dwSize))
        return !strcmp (buf, c_szUserAgent);
    else
        return FALSE;
}

BOOL htmlSendHeader(PALLINFO pAllInfo, LPTSTR lpszHeader, LPTSTR lpszContent)
{
    LPSTR lpszAnsiHeader = NULL;
    LPSTR lpszAnsiContent = NULL;
    BOOL  bRet = FALSE;
    DWORD dwSize = 0;

    lpszAnsiHeader =  (LPSTR) LocalAlloc (LPTR, (1 + lstrlen (lpszHeader)) * sizeof (TCHAR));
    if (lpszContent)
        lpszAnsiContent = (LPSTR) LocalAlloc (LPTR, (1 + lstrlen (lpszContent)) * sizeof (TCHAR));

    if (!lpszAnsiHeader || !lpszAnsiContent) {
        goto Cleanup;
    }

    UnicodeToAnsiString(lpszHeader,  lpszAnsiHeader, 0);
    if (lpszContent)
        dwSize = UnicodeToAnsiString(lpszContent, lpszAnsiContent, 0);

    bRet = pAllInfo->pECB->ServerSupportFunction(pAllInfo->pECB->ConnID,
                                                 HSE_REQ_SEND_RESPONSE_HEADER,
                                                 (LPVOID) lpszAnsiHeader,
                                                 &dwSize,
                                                 (LPDWORD) lpszAnsiContent);
Cleanup:
    LocalFree (lpszAnsiHeader);
    LocalFree (lpszAnsiContent);

    return bRet;

}

BOOL htmlSend500Header(PALLINFO pAllInfo, DWORD dwError)
{
    TCHAR   szStatusPattern [] = TEXT ("500 %d");
    LPTSTR  lpszHeader = NULL;
    DWORD   bRet = FALSE;
    LPTSTR  pszErrorContent = GetString(pAllInfo, IDS_ERROR_500CONTENT);

    if (! (lpszHeader = (LPTSTR) LocalAlloc (LPTR,
                                             sizeof (szStatusPattern) + sizeof (TCHAR) * 40)))
        goto Cleanup;
    else {
        wsprintf (lpszHeader, szStatusPattern, dwError);
        bRet = htmlSendHeader(pAllInfo, lpszHeader, pszErrorContent);
    }

    Cleanup:
    if (lpszHeader) {
        LocalFree (lpszHeader);
    }

    return bRet;

}

/********************************************************************************

Name:
    ProcessErrorMessage

Description:

    Do the authentication if the error is Permission denied, show the error
    meesage otherwise

Arguments:

    pAllInfo:                   Pointer to the infor struction
    dwError(optional):          Error code, if not provided, dwError in
                                the pAllInfo is used

Return Value:

    HSE_STATUS_SUCCESS if ok.

********************************************************************************/
DWORD ProcessErrorMessage (PALLINFO pAllInfo, DWORD dwError)
{
    DWORD dwRet = HSE_STATUS_ERROR;

    if (!pAllInfo) {
        return dwRet;
    }

    if (dwError != ERROR_SUCCESS)
        pAllInfo->dwError = dwError;

    SetLastError (pAllInfo->dwError);

    if (pAllInfo->dwError == ERROR_ACCESS_DENIED ||
        pAllInfo->dwError == ERROR_INVALID_OWNER)  {
        if (AuthenticateUser(pAllInfo))
            dwRet = HSE_STATUS_SUCCESS;
    } else {

#if 0
        if (IsClientHttpProvider (pAllInfo)) {
            // This piece will not be needed when IPP port validation (OpenPrinter) is done by Chris.
            LPTSTR  pszErrorContent = GetString(pAllInfo, IDS_ERROR_501CONTENT);
            return htmlSendHeader (pAllInfo,
                                   TEXT ("501 Function not supported"),
                                   pszErrorContent);
        }
        else {
#endif
       if (htmlSend500Header(pAllInfo, dwError))
           dwRet = HSE_STATUS_SUCCESS;
    }

    return dwRet;

}

LPTSTR AllocStr( LPCTSTR pStr )
{

    LPTSTR pMem = NULL;
    DWORD  cbStr;

    if( !pStr )
        return NULL;

    cbStr = lstrlen( pStr )*sizeof(TCHAR) + sizeof(TCHAR);

    if( pMem = (LPTSTR)LocalAlloc( LPTR, cbStr ))
        CopyMemory( pMem, pStr, cbStr );

    return pMem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\inetio.h ===
/*****************************************************************************\
* MODULE: inetinfo.h
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*     04/14/97 weihaic      Pull declaration from global.h
*
\*****************************************************************************/

#ifndef INETIO_H
#define INETIO_H

INT AnsiToUnicodeString(LPSTR pAnsi, LPWSTR pUnicode, UINT StringLength );
INT UnicodeToAnsiString(LPWSTR pUnicode, LPSTR pAnsi, UINT StringLength);
LPWSTR AllocateUnicodeString(LPSTR  pAnsiString );

BOOL htmlSendHeader(PALLINFO pAllInfo, LPTSTR lpszHeader, LPTSTR lpszContent);

BOOL IsClientSameAsServer(EXTENSION_CONTROL_BLOCK *pECB);
BOOL IsClientHttpProvider (PALLINFO pAllInfo);
BOOL htmlSendRedirect(PALLINFO pAllInfo, LPTSTR lpszURL);

LPTSTR EncodeFriendlyName (LPCTSTR lpText);
LPTSTR DecodeFriendlyName (LPTSTR lpText);

DWORD ProcessErrorMessage (PALLINFO pAllInfo, DWORD dwError = ERROR_SUCCESS);
unsigned long GetIPAddr(LPSTR lpszName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\globals.h ===
/********
*
*  Copyright (c) 1995  Microsoft Corporation
*
*
*  Module Name  : globals.h
*
*  Abstract :
*
*     This module contains  the structure definitions and prototypes for the
*     version 1.0 HTTP Printers Server Extension.
*
******************/

//
// Notes:
//   TEXT (".printer"), TEXT ("/scripts"), TEXT ("PrintersFolder") hardcoded
//   ReadRegistry needs implementation


#ifndef _GLOBALS_H
#define _GLOBALS_H

// Debugging Environment (SPLLIB.LIB)
//
#define MODULE "msw3prt:"

// Define local error code
#define ERROR_DRIVER_NOT_FOUND 5500
#define ERROR_SERVER_DISK_FULL 5512


// URL strings for links
#define  URL_PREFIX             TEXT ("http://%s")             // g_szComputerName

#define  URL_PRINTER            TEXT ("/printers/%s/.printer") // pPageInfo->pPrinterInfo->pShareName
#define  URL_PRINTER_LINK       TEXT ("/%s")                   // pPageInfo->pPrinterInfo->pShareName
#define  URL_FOLDER             TEXT ("/%s/")                  // g_szPrinters

#define  URLS_JOBINFO           TEXT ("?ShowJobInfo&%d")       // dwJobID
#define  URLS_JOBCONTROL        TEXT ("?JobControl&%d&")       // dwJobID, append P,R,C,S

//
//
#define PROCESSOR_ARCHITECTURE_UNSUPPORTED   0xFFFE


// Buffer size for HTML format buffer and size to flush after

#define BUFSIZE   2047
#define FLUSHSIZE 1792

#define STRBUFSIZE  256   // For string resources and our path


#define MAX_Q_ARG 32       // Maximum number of query arguments




// This contains all relevant info for this specific connection
typedef struct
{

    //
    // Group the structure fields in 4*DWORD groups so it can be easily found in the debugger dump.
    //

    // Transient info that is regenerated each session
    EXTENSION_CONTROL_BLOCK *pECB;              // Struct from ISAPI interface
    LPTSTR                  lpszMethod;         // Unicode correspondece of the data member in pECB
    LPTSTR                  lpszQueryString;
    LPTSTR                  lpszPathInfo;

    LPTSTR                  lpszPathTranslated;

    UINT                    iQueryCommand;          // CMD_something
    int                     iNumQueryArgs;          // Yep, number of query arguments

    BOOL                    fQueryArgIsNum[MAX_Q_ARG];  // TRUE if arg is a number
    UINT_PTR                QueryArgValue[MAX_Q_ARG];   // number or pointer to string

    DWORD                   dwError;                // Error message ID set in action tags
    TCHAR                   szStringBuf[STRBUFSIZE];  // For string resources

} ALLINFO, *PALLINFO;

// Contains information opened for the printer page, if any.
typedef struct
{
    LPTSTR              pszFriendlyName;    // Friendly name from Windows (!JobData && !JobClose)
    PPRINTER_INFO_2     pPrinterInfo;       // NULL if JobData or JobClose
    HANDLE              hPrinter;           // NULL if JobData or JobClose

} PRINTERPAGEINFO, *PPRINTERPAGEINFO;



// Query string command identifiers
enum
{
    CMD_Invalid,
    CMD_IPP,
    CMD_Install,
    CMD_CreateExe,
    CMD_WebUI
};

// Supported Architectures ids.
typedef enum _ARCHITECTURE {
    ARCHITECTURE_X86,
    ARCHITECTURE_ALPHA
} ARCHITECTURE;

// Relates status values to status strings (job or printer status)
typedef struct
{
    DWORD   dwStatus;           // Status code (ie, PRINTER_STATUS_PAUSED)
    UINT    iShortStringID;     // Short string (ie, TEXT ("Paused"))
    UINT    iLongStringID;      // Long string(ie, TEXT ("The printer is paused."))

} STAT_STRING_MAP, *PSTAT_STRING_MAP;

// Structure to relate query string command to command ID
typedef struct
{
    LPTSTR   pszCommand;
    UINT    iCommandID;
} QUERY_MAP, *PQUERY_MAP;

// Inline functions and macros

#define ARRAY_COUNT(x) (sizeof(x) / sizeof(x[0]))

//
// utils
//
BOOL FreeStr( LPCTSTR );
LPTSTR AllocStr( LPCTSTR );


// from Spool.CPP
DWORD SplIppJob(WORD wReq, PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);

// Variables in globals.cpp
extern        CRITICAL_SECTION      SplCritSect;
extern        CRITICAL_SECTION      TagCritSect;

extern  const QUERY_MAP             rgQueryMap[];
extern  const int                   iNumQueryMap;
//extern        TCHAR                 g_szComputerName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
extern        TCHAR                 g_szHttpServerName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
extern        TCHAR                 g_szPrintServerName[INTERNET_MAX_HOST_NAME_LENGTH + 1];

extern        HINSTANCE             g_hInstance;
extern        LPTSTR                g_szPrintersFolder;
extern        LPTSTR                g_szPrinters;
extern        LPTSTR                g_szRemotePortAdmin;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\msw3prt.h ===
/*****************************************************************************\
* MODULE: msw3prt.h
*
* The module contains routines to implement the ISAPI interface.
*
* PURPOSE       Windows HTTP/HTML printer interface
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*     02/04/97 weihaic    Create the header file
*
\*****************************************************************************/

#ifndef _MSW3PRT_H
#define _MSW3PRT_H

LPTSTR GetString(PALLINFO pAllInfo, UINT iStringID);
BOOL IsSecureReq(EXTENSION_CONTROL_BLOCK *pECB);

BOOL IsUserAnonymous(EXTENSION_CONTROL_BLOCK *pECB);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\pch.cxx ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\pagefcns.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************                                                                  
//*                                                                         *
//* PAGEFCNS.H -                                                            *
//*                                                                         *
//***************************************************************************       


//***************************************************************************
//* DEFINES                                                                 *
//***************************************************************************
#define IDD_BACK            0x3023      // From commctrl defines...
#define IDD_NEXT            0x3024      // From commctrl defines...

#define MAX_TITLE           128         // Max size of Title
#define MAX_PROMPT          512         // Max size of prompt
#define MAX_CUSTOM          512         // Max size of Custom command
#define MAX_FINISHMSG       512         // Max size of Finished message

/*                                     
#define _SORT_DESCENDING    1           // 0001
#define _SORT_ASCENDING     2           // 0010
#define _SORT_ORDER         3           // 0011
#define _SORT_FILENAME      4           // 0100
#define _SORT_PATH          8           // 1000
*/

//***************************************************************************
//* TYPE DEFINITIONS                                                        *
//***************************************************************************

// This structure holds the list of files that are in the List View
// Control.

typedef struct _MyItem {
    LPSTR           aszCols[2];     // Filename and Path
    FILETIME        ftLastModify;
    struct _MyItem *Next;
} MYITEM, *PMYITEM;

// This structure (generally) holds all the information that will be
// saved in the CABPack Directive File.

typedef struct _CDF {
    TCHAR    achFilename[MAX_PATH];
    BOOL     fSave;
    TCHAR    achTitle[MAX_TITLE];
    BOOL     fPrompt;            
    TCHAR    achPrompt[MAX_PROMPT];
    BOOL     fLicense;             
    TCHAR    achLicense[MAX_PATH]; 
    TCHAR    achTarget[MAX_PATH];
    BYTE     bShowWindow;           
    BOOL     fFinishMsg;
    TCHAR    achFinishMsg[MAX_FINISHMSG];
    TCHAR    achTargetPath[MAX_PATH];
    TCHAR    achTargetBase[MAX_PATH];
    TCHAR    achDDF[MAX_PATH];
    TCHAR    achCAB[MAX_PATH];
    TCHAR    achCABPath[MAX_PATH];
    TCHAR    achINF[MAX_PATH];
    TCHAR    achRPT[MAX_PATH];
    BOOL     fCustom;              
    TCHAR    achSelectCmd[MAX_PATH];
    TCHAR    achCustomCmd[MAX_CUSTOM];
    LPTSTR   szCAB;                 
    FILETIME ftCABMake;           
    FILETIME ftFileListChange;       
//    WORD     wSortOrder;
    PMYITEM  pTop;                   
} CDF, *PCDF;


//***************************************************************************
//* GLOBAL CONSTANTS                                                        *
//***************************************************************************
static TCHAR achExtEXE[] = ".EXE";
static TCHAR achExtBAT[] = ".BAT";
static TCHAR achExtCOM[] = ".COM";
static TCHAR achExtINF[] = ".INF";
                         

//***************************************************************************
//* FUNCTION PROTOTYPES                                                     *
//***************************************************************************
BOOL WelcomeInit( HWND, BOOL );
BOOL WelcomeCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL WelcomeOK( HWND, BOOL, UINT *, BOOL * );

BOOL ModifyInit( HWND, BOOL );
BOOL ModifyOK( HWND, BOOL, UINT *, BOOL * );

BOOL TitleInit( HWND, BOOL );
BOOL TitleOK( HWND, BOOL, UINT *, BOOL * );

BOOL PromptInit( HWND, BOOL );
BOOL PromptCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL PromptOK( HWND, BOOL, UINT *, BOOL * );

BOOL LicenseTxtInit( HWND, BOOL );
BOOL LicenseTxtCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL LicenseTxtOK( HWND, BOOL, UINT *, BOOL * );

BOOL FilesInit( HWND, BOOL );
BOOL FilesCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL FilesNotify( HWND, WPARAM, LPARAM );
BOOL FilesOK( HWND, BOOL, UINT *, BOOL * );

BOOL CommandInit( HWND, BOOL );
BOOL CommandCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL CommandOK( HWND, BOOL, UINT *, BOOL * );

BOOL ShowWindowInit( HWND, BOOL );
BOOL ShowWindowOK( HWND, BOOL, UINT *, BOOL * );

BOOL FinishMsgInit( HWND, BOOL );
BOOL FinishMsgCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL FinishMsgOK( HWND, BOOL, UINT *, BOOL * );

BOOL TargetInit( HWND, BOOL );
BOOL TargetCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL TargetOK( HWND, BOOL, UINT *, BOOL * );

BOOL SaveInit( HWND, BOOL );
BOOL SaveCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL SaveOK( HWND, BOOL, UINT *, BOOL * );

BOOL CreateInit( HWND, BOOL );
BOOL CreateOK( HWND, BOOL, UINT *, BOOL * );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\msw3prt.cxx ===
/*****************************************************************************\
* MODULE: msw3prt.cxx
*
* The module contains routines to implement the ISAPI interface.
*
* PURPOSE       Windows HTTP/HTML printer interface
*
* Copyright (C) 1996-1997 Microsoft Corporation
*
* History:
*     01/16/96 eriksn     Created based on ISAPI sample DLL
*     07/15/96 babakj     Ported to NT
*     02/04/97 weihaic    Enabled Unicode mode
*
\*****************************************************************************/

#include "pch.h"

/*****************************************************************************\
* GetClientInfo
*
* Returns a DWORD representation of the client architecture/ver information.
*
\*****************************************************************************/
DWORD GetClientInfo(
    PALLINFO pAllInfo)
{
    DWORD dwCliInfo = 0;
    LPSTR lpszPtr;


    if (pAllInfo->pECB->cbAvailable) {

        if (lpszPtr = (LPSTR)pAllInfo->pECB->lpbData) {

            while (*lpszPtr && (*lpszPtr != '='))
                lpszPtr++;

            if (*lpszPtr)
                dwCliInfo = atoi(++lpszPtr);
        }

    } else {

        if (lpszPtr = pAllInfo->pECB->lpszQueryString) {

            while (*lpszPtr && (*lpszPtr != '&'))
                lpszPtr++;

            if (*lpszPtr)
                dwCliInfo = atoi(++lpszPtr);
        }
    }

    return dwCliInfo;
}


/*****************************************************************************\
* GetIppReq
*
* Returns the request-type of the IPP-stream.
*
\*****************************************************************************/
WORD GetIppReq(
    PALLINFO pAllInfo)
{
    LPWORD  pwPtr;
    WORD    wValue = 0;

    if (pAllInfo->pECB->cbAvailable >= sizeof(DWORD)) {

        if (pwPtr = (LPWORD)pAllInfo->pECB->lpbData) {

            CopyMemory (&wValue, pwPtr + 1, sizeof (WORD));

            return ntohs(wValue);
        }
    }

    return 0;
}


/*****************************************************************************\
* IsSecureReq
*
* Returns whether the request comes from a secure https channel.
*
\*****************************************************************************/
BOOL IsSecureReq(
    EXTENSION_CONTROL_BLOCK *pECB)
{
    BOOL  bRet;
    DWORD cbBuf;
    CHAR  szBuf[10];

    cbBuf = 10;
    bRet = pECB->GetServerVariable(pECB->ConnID,
                                   "HTTPS",
                                   &szBuf,
                                   &cbBuf);

    if (bRet && (cbBuf <= 4)) {

        if (lstrcmpiA(szBuf, "on") == 0)
            return TRUE;
    }

    return FALSE;
}



/*****************************************************************************\
* GetPrinterName
*
* Get the printer name from the path
*
\*****************************************************************************/
LPTSTR GetPrinterName (LPTSTR lpszPathInfo)
{
    // The only format we support is "/printers/ShareName|Encoded Printer Name/.printer"

    static  TCHAR szPrinter[] = TEXT ("/.printer");
    static  TCHAR szPrinters[] = TEXT ("/printers/");

    LPTSTR  lpPtr           = NULL;
    LPTSTR  lpPathInfo      = NULL;
    LPTSTR  lpPrinterName   = NULL;
    LPTSTR  lpSuffix        = NULL;
    DWORD   dwLen;

    // Make a copy of lpszPathInfo
    if (! (lpPathInfo = lpPtr = AllocStr (lpszPathInfo)))
        return  NULL;

    // Verify the prefix
    if (_tcsnicmp (lpPathInfo, szPrinters, COUNTOF (szPrinters) - 1)) {
        goto Cleanup;
    }
    lpPathInfo += COUNTOF (szPrinters) - 1;

    dwLen = lstrlen (lpPathInfo);
    // Compare the length of the printer name with .printer suffix
    if (dwLen <= COUNTOF (szPrinter) - 1) {
        goto Cleanup;
    }

    lpSuffix = lpPathInfo + dwLen - COUNTOF (szPrinter) + 1;
    //lpszStr should point to .printer

    // Verify the suffix.
    if (lstrcmpi(lpSuffix, szPrinter)) {
        goto Cleanup;
    }

    *lpSuffix = TEXT('\0');   // Terminate string

    lpPrinterName = AllocStr (lpPathInfo);

Cleanup:

    LocalFree(lpPtr);
    return lpPrinterName;
}

/*****************************************************************************\
* DllMain
*
*
\*****************************************************************************/
BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD fdwReason,
   LPVOID lpvReserved)
{
    BOOL bRet = TRUE;

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hinstDLL;

        // Init debug support in spllib.lib
        bSplLibInit( NULL );

        __try {
            InitializeCriticalSection(&SplCritSect);
            InitializeCriticalSection(&TagCritSect);

            // Initialize the CAB generation crit-sect for web-pnp.
            //
            InitCABCrit();
        }
        __except (1) {
            bRet = FALSE;
            SetLastError (ERROR_INVALID_HANDLE);
        }

        if (bRet) {
            // Initializa the sleeper, which is used to cleanup the pritner jobs
            InitSleeper ();
    
            // We don't care about fdwReason==DLL_THREAD_ATTACH or _DETACH
            DisableThreadLibraryCalls(hinstDLL);
    
            srand( (UINT)time( NULL ) );
        }

    }

    if (fdwReason == DLL_PROCESS_DETACH)
    {
        // Terminate the additional cleanup thread
        ExitSleeper ();

        DeleteCriticalSection(&SplCritSect);
        DeleteCriticalSection(&TagCritSect);

        // Free our web-pnp crit-sect.
        //
        FreeCABCrit();

        // Free debug support in spllib.lib
        vSplLibFree();
    }

    // Do any other required initialize/deinitialize here.
    return bRet;
}


/*****************************************************************************\
* GetExtensionVersion
*
* Required ISAPI export function.
*
\*****************************************************************************/
BOOL WINAPI GetExtensionVersion(
    HSE_VERSION_INFO *pVer)
{
    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    TCHAR szBuf[80];
    szBuf[0] = TEXT('\0');
    LoadString(g_hInstance, IDS_ISAPI_DESCRIPTION, szBuf, sizeof(szBuf) / sizeof (TCHAR));


    // Convert szBuf to ANSI
    // Weihaic
    if (UnicodeToAnsiString (szBuf, (LPSTR) szBuf, NULL)) {
        lstrcpynA( pVer->lpszExtensionDesc, (LPSTR) szBuf,
                   HSE_MAX_EXT_DLL_NAME_LEN );

        return TRUE;
    }
    else
        return FALSE;
} // GetExtensionVersion()


/*****************************************************************************\
* GetServerName
*
* Get the server name and convert it to the unicode string.
*
\*****************************************************************************/
BOOL GetServerName (EXTENSION_CONTROL_BLOCK *pECB)

{
    static  char c_szServerName[]      = "SERVER_NAME";
    DWORD   dwSize;
    char    szAnsiHttpServerName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    BOOL    bRet = FALSE;
    DWORD   dwClusterState;
    BOOL    bCluster = FALSE;

    dwSize = sizeof (szAnsiHttpServerName);

    if (pECB->GetServerVariable (pECB->ConnID, c_szServerName, szAnsiHttpServerName, &dwSize)) {

        AnsiToUnicodeString(szAnsiHttpServerName, g_szHttpServerName, 0);
        // Now, the computer name becomes the server name. In case of the intranet, it is the computer
        // name, in case of internet, it is either the IP address or the DNS name

        if (!lstrcmpi (g_szHttpServerName, TEXT ("localhost")) ||
            !lstrcmpi (g_szHttpServerName, TEXT ("127.0.0.1"))) {

            dwSize = ARRAY_COUNT (g_szHttpServerName);

            bRet = GetComputerName(  g_szHttpServerName, &dwSize);
        }
        else
            bRet = TRUE;
    }


    if (bRet) {

        bRet = FALSE;

        // Now let's get the printer server name
    
        // 
        // Check if we are running in a cluster node
        //
        if (GetNodeClusterState (NULL, &dwClusterState) == ERROR_SUCCESS && 
            (dwClusterState & ClusterStateRunning)) {
    
            bCluster = TRUE;
        }
        
        //
        // If we are running in the cluster mode, we have to use the ServerName referred in the HTTP header.
        // Otherwise, we can use the computer name directly. 
        //
        if (bCluster) {
            lstrcpy (g_szPrintServerName, g_szHttpServerName);
            bRet = TRUE;
        }
        else {
            
            dwSize = ARRAY_COUNT (g_szPrintServerName);
            bRet = GetComputerName(  g_szPrintServerName, &dwSize);
        }

    }

    return bRet;
}


/*****************************************************************************\
* ParseQueryString
*
* ParseQueryString converts the query string into a sequence of arguments.
*  The main command is converted to a command ID. Subsequent arguments are
*   converted to strings or DWORDs.
*
* Format:  Command & Arg1 & Arg2 & Arg3 ...
*   Each arg is either a number or a string in quotes.
*
* returns FALSE if the query string exists but is invalid
*
\*****************************************************************************/
BOOL ParseQueryString(PALLINFO pAllInfo)
{
    LPTSTR  pszQueryString, pszTmp, pszTmp2, pszTmp3;
    int     iNumArgs = 0;

    pszQueryString = pAllInfo->lpszQueryString;

    if (!pszQueryString || (*pszQueryString == 0)) {


        // Chceck if the method is post
        if (!lstrcmp (pAllInfo->lpszMethod, TEXT ("POST"))) {
            // also check here for content-type application/ipp ???
            //
            pAllInfo->iQueryCommand = CMD_IPP;  // can we use the NULL cmd ???
        }
        else {
            pAllInfo->iQueryCommand = CMD_WebUI;  // redirect to webui
        }

        return TRUE;
    }

    // Get a copy of the string to do surgery on it in this routine and save pieces of it as other info.
    // Save it too so it can be freed later.
    // This line is bogus. 1. It leads to a memory leak. To, it can fail and the
    // return value is unchecked.....

    pszQueryString = AllocStr ( pszQueryString );

    if (pszQueryString != NULL) {
        // We will find and replace the first '&' with NULL. This it to isolate the first
        // piece of the query string and examine it.
        // pszQueryString then points to this first piece (command), pszTmp to the rest.
        if( pszTmp = _tcschr( pszQueryString, TEXT('&'))) {
            *pszTmp = TEXT('\0');
            pszTmp++;
        }

        // Search for main command
        pAllInfo->iQueryCommand = CMD_Invalid;

        // If we had {WinPrint.PrinterCommandURL}?/myfile.htm&bla1&bla2&bla3.....
        // or {WinPrint.PrinterCommandURL}?/bla1/bla2/.../blaN/myfile.htm&aaa&bbb&ccc...
        // then pszQueryString is pointing to a NULL we inserted in place of '/', so it is OK.
        // So just attempt to find a iQueryCommand only if pszQueryString is pointing to a non-NULL char.
        if( *pszQueryString ) {

            for (int i=0; i<iNumQueryMap; i++) {
                if (!lstrcmpi(rgQueryMap[i].pszCommand, pszQueryString)) {
                    pAllInfo->iQueryCommand = rgQueryMap[i].iCommandID;
                    break;
                }
            }

            if( pAllInfo->iQueryCommand == CMD_Invalid )
                return FALSE;       // No command found. Bad query string.
        }

        // At this point we continue with pszTmp for the arguments.

        // We take at most MAX_Q_ARG arguments to avoid memory corruption
        while( (NULL != pszTmp) && (*pszTmp) && iNumArgs < MAX_Q_ARG) {
            pszTmp2 = pszTmp;
            pszTmp = _tcschr( pszTmp, TEXT('&'));
            if (pszTmp != NULL) {
                *pszTmp = 0;
                pszTmp ++;
            }
            if (*pszTmp2 >= TEXT('0') && *pszTmp2 <= TEXT('9')) {
                // DWORD integer value
                pAllInfo->fQueryArgIsNum[iNumArgs] = TRUE;
                pAllInfo->QueryArgValue[iNumArgs] = (DWORD)_ttoi(pszTmp2);
            }
            else {
                // Pointer to string
                pAllInfo->fQueryArgIsNum[iNumArgs] = FALSE;
                pAllInfo->QueryArgValue[iNumArgs] = (UINT_PTR)pszTmp2;
            }
            iNumArgs ++;
        }

        pAllInfo->iNumQueryArgs = iNumArgs;

        DBGMSG(DBG_INFO, ("ParseQueryString: %d query arguments\r\n", iNumArgs));

        LocalFree( pszQueryString );
        return TRUE;
    }

    return FALSE;
}


#if 0
/*****************************************************************************\
* ParsePathInfo
*
* Take the PATH_INFO string and figure out what to do with it.
*
\*****************************************************************************/
DWORD ParsePathInfo(PALLINFO pAllInfo)
{
    // The only format we support is "/ShareName|Encoded Printer Name/.printer"

    static  TCHAR szPrinter[] = TEXT ("/.printer");

    DWORD   dwRet = HSE_STATUS_ERROR;
    LPTSTR  lpPtr = NULL;
    LPTSTR  lpszStr;
    LPTSTR  lpPrinterName = NULL;
    DWORD   dwLen;

    // Make a copy of lpszPathInfo
    if (! (lpPrinterName = lpPtr = AllocStr (pAllInfo->lpszPathInfo)))
        return  HSE_STATUS_ERROR;

    // First remove the "/" prefix

    if (*lpPrinterName++ != TEXT ('/') ) {
        goto Cleanup;
    }

    dwLen = lstrlen (lpPrinterName);
    // Compare the length of the printer name with .printer suffix
    if (dwLen <= COUNTOF (szPrinter) - 1) {
        goto Cleanup;
    }

    lpszStr = lpPrinterName + dwLen - COUNTOF (szPrinter) + 1;
    //lpszStr should point to .printer

    // Verify the suffix.
    if (lstrcmpi(lpszStr, TEXT("/.printer"))) {
        goto Cleanup;
    }

    *lpszStr = TEXT('\0');   // Terminate string

    if( !ParseQueryString( pAllInfo ))
        goto Cleanup;

    dwRet = ShowPrinterPage(pAllInfo, lpPrinterName);

Cleanup:

    LocalFree(lpPtr);
    return dwRet;

}

#endif

/*****************************************************************************\
* CreateExe
*
*
\*****************************************************************************/
DWORD CreateExe(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo, DWORD dwCliInfo)
{
    LPTSTR          lpPortName      = NULL;
    LPTSTR          lpExeName       = NULL;
    LPTSTR          lpFriendlyName  = NULL;
    DWORD           dwRet           = HSE_STATUS_ERROR ;
    DWORD           dwLen           = 0;
    DWORD           dwLastError     = ERROR_INVALID_DATA;
    BOOL            bSecure         = IsSecureReq (pAllInfo->pECB);

    GetWebpnpUrl (g_szHttpServerName, pPageInfo->pPrinterInfo->pShareName, NULL, bSecure, NULL, &dwLen);
    if (GetLastError () != ERROR_INSUFFICIENT_BUFFER)
        goto Cleanup;

    if (! (lpPortName = (LPTSTR)LocalAlloc(LPTR, dwLen * sizeof (*lpPortName))))
        goto Cleanup;

    if (!GetWebpnpUrl (g_szHttpServerName, pPageInfo->pPrinterInfo->pShareName, NULL, bSecure, lpPortName, &dwLen))
        goto Cleanup;

    lpExeName = (LPTSTR)LocalAlloc(LPTR, MAX_PATH * sizeof (*lpExeName));
    if (!lpExeName)
        goto Cleanup;

    lpFriendlyName = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pPageInfo->pszFriendlyName)+1) * sizeof (*lpFriendlyName));
    if (!lpFriendlyName)
        goto Cleanup;

    lstrcpy(lpFriendlyName, pPageInfo->pszFriendlyName);

    dwRet = GenerateCAB(lpFriendlyName,
                        lpPortName,
                        dwCliInfo,
                        lpExeName,
                        IsSecureReq(pAllInfo->pECB));

    if (dwRet == HSE_STATUS_SUCCESS) {
        LPTSTR lpEncodedExeName = EncodeString (lpExeName, TRUE);

        if (!lpEncodedExeName) {
            dwRet = HSE_STATUS_ERROR;
            goto Cleanup;
        }
        htmlSendRedirect (pAllInfo, lpEncodedExeName);
        LocalFree (lpEncodedExeName);
    }
    else {
        dwLastError = GetLastError ();

        if (dwLastError == ERROR_FILE_NOT_FOUND) {
            dwLastError = ERROR_DRIVER_NOT_FOUND;
        }
        
        if (dwLastError == ERROR_DISK_FULL) {
            dwLastError = ERROR_SERVER_DISK_FULL;
        }
    }

Cleanup:

    LocalFree(lpPortName);
    LocalFree(lpExeName);
    LocalFree(lpFriendlyName);

    if (dwRet !=  HSE_STATUS_SUCCESS)
        return ProcessErrorMessage (pAllInfo, dwLastError);
    else
        return dwRet;
}

/*****************************************************************************\
* ProcessRequest
*
* Process the incoming request
*
\*****************************************************************************/
DWORD ProcessRequest(PALLINFO pAllInfo, LPTSTR lpszPrinterName)
{
    DWORD            dwRet              = HSE_STATUS_ERROR;
    PPRINTER_INFO_2  pPrinterInfo       = NULL;
    HANDLE           hPrinter           = NULL;
    DWORD            iQueryCommand;
    LPTSTR           lpszFriendlyName;
    DWORD            dwCliInfo;
    WORD             wIppReq            = 0;
    LPTSTR           pszDecodedName     = NULL;
    DWORD            dwSize             = 0;
    PRINTER_DEFAULTS pd                 = {NULL, NULL, PRINTER_ACCESS_USE};
    LPTSTR           lpszWebUIUrl       = NULL;
    LPTSTR           pszOpenName        = NULL;
    LPTSTR           pszTmpName         = NULL;

    iQueryCommand = pAllInfo->iQueryCommand;

    DBGMSG(DBG_INFO, ("ShowPrinterPage for printer \"%ws\"\n", lpszPrinterName));

    // Open the printer and get printer info level 2.
    DecodePrinterName (lpszPrinterName, NULL, &dwSize);

    if (! (pszDecodedName = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * dwSize)))
        return ProcessErrorMessage (pAllInfo, GetLastError ());

    if (!DecodePrinterName (lpszPrinterName, pszDecodedName, &dwSize)) {
        dwRet = ProcessErrorMessage (pAllInfo, GetLastError ());
        goto Cleanup;
    }

    if (*pszDecodedName != TEXT ('\\') ) {
        // There is no server name before the printer name, append the server name
        if (! (pszOpenName = pszTmpName = (LPTSTR) LocalAlloc (LPTR, sizeof (TCHAR) * (lstrlen (pszDecodedName)
                                                  + lstrlen (g_szPrintServerName) + 4 ))))
            goto Cleanup;

        lstrcpy (pszOpenName, TEXT ("\\\\"));
        lstrcat (pszOpenName, g_szPrintServerName);
        lstrcat (pszOpenName, TEXT ("\\"));
        lstrcat (pszOpenName, pszDecodedName);

    }
    else {
        pszOpenName = pszDecodedName;
    }

    if (! OpenPrinter(pszOpenName, &hPrinter, &pd)) {
        dwRet = ProcessErrorMessage (pAllInfo, GetLastError ());
        goto Cleanup;
    }

    // Get a PRINTER_INFO_2 structure filled up
    dwSize = 0;
    GetPrinter(hPrinter, 2, NULL, 0, &dwSize);
    if ((GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
        (NULL == (pPrinterInfo = (PPRINTER_INFO_2)LocalAlloc(LPTR, dwSize))) ||
        (!GetPrinter(hPrinter, 2, (byte *)pPrinterInfo, dwSize, &dwSize))) {
        dwRet = ProcessErrorMessage (pAllInfo, GetLastError ());
        goto Cleanup;
    }

    if (! (pPrinterInfo->Attributes & PRINTER_ATTRIBUTE_SHARED)) {
        // If the printer is not shared, return access denied
        dwRet = ProcessErrorMessage (pAllInfo, ERROR_ACCESS_DENIED);
        goto Cleanup;
    }

    // Find printer friendly name.
    // If we opened with UNC path we need to remove server name
    if (pPrinterInfo->pPrinterName) {
        lpszFriendlyName = _tcsrchr (pPrinterInfo->pPrinterName, TEXT('\\'));
        if (lpszFriendlyName)
            lpszFriendlyName ++;
        else
            lpszFriendlyName = pPrinterInfo->pPrinterName;
    }

    // We've got an open printer and some printer info. Ready to go.
    // Fill in structure of info for whatever function we call
    PRINTERPAGEINFO ppi;
    ZeroMemory(&ppi, sizeof(ppi));

    ppi.pszFriendlyName = lpszFriendlyName;
    ppi.pPrinterInfo    = pPrinterInfo;
    ppi.hPrinter        = hPrinter;

        // Do appropriate action based on query string
    switch (iQueryCommand) {
    case CMD_WebUI:
        // Construct a URL to redirect
        dwSize = 0;
        if (GetWebUIUrl (NULL,  pszDecodedName,  lpszWebUIUrl, &dwSize))
            goto Cleanup;

        if (GetLastError () != ERROR_INSUFFICIENT_BUFFER)
            goto Cleanup;

        if (!(lpszWebUIUrl = (LPTSTR)LocalAlloc(LPTR, dwSize * sizeof (TCHAR))))
            goto Cleanup;

        if (! GetWebUIUrl (NULL,  pszDecodedName,  lpszWebUIUrl, &dwSize))
            goto Cleanup;

        dwRet = htmlSendRedirect (pAllInfo, lpszWebUIUrl);

        break;

    case CMD_IPP:

        if (wIppReq = GetIppReq(pAllInfo)) {

            dwRet = SplIppJob(wIppReq, pAllInfo, &ppi);

        } else {

            DBGMSG(DBG_WARN, ("ShowPrinterPage: Warn : Invalid IPP Stream.\n"));

            if (IsClientHttpProvider (pAllInfo)){
                // To improve the perfomance for the internet provider by returning something really quick
                LPTSTR  pszContent = GetString(pAllInfo, IDS_ERROR_200CONTENT);
                htmlSendHeader (pAllInfo, TEXT ("200 OK"), pszContent);
                dwRet = HSE_STATUS_SUCCESS;
            }

            if (INVALID_HANDLE_VALUE != hPrinter)
                ClosePrinter(hPrinter);

            break;
        }

        break;

    case CMD_CreateExe:

        DBGMSG(DBG_TRACE, ("Calling CreateExe.\n"));

        if (dwCliInfo = GetClientInfo(pAllInfo)) {

            dwRet = CreateExe(pAllInfo, &ppi, dwCliInfo);

        } else {

            dwRet = ProcessErrorMessage (pAllInfo, ERROR_NOT_SUPPORTED);
            goto Cleanup;
        }
        break;

    default:
        dwRet = ProcessErrorMessage (pAllInfo, ERROR_INVALID_PRINTER_COMMAND);
        break;
    }


Cleanup:
    // Clean up our stuff

    if (dwRet != HSE_STATUS_ERROR)
        pAllInfo->pECB->dwHttpStatusCode=200; // 200 OK

    LocalFree (lpszWebUIUrl);

    LocalFree (pszDecodedName);
    LocalFree (pszTmpName);
    LocalFree (pPrinterInfo);

    // For any commands other than CMD_IPP commands, we can close the
    // printer-handle.  Otherwise, we rely on the Spool*() routines
    // to handle this for us after we're done reading and processing
    // the entire print-job.
    //
    if (hPrinter && (iQueryCommand != CMD_IPP))
        ClosePrinter(hPrinter);

    return dwRet;

}

/*****************************************************************************\
* GetString
*
*
\*****************************************************************************/
LPTSTR GetString(PALLINFO pAllInfo, UINT iStringID)
{
    LPTSTR lpszBuf = pAllInfo->szStringBuf;

    lpszBuf[0] = TEXT('\0');
    LoadString(g_hInstance, iStringID, lpszBuf, STRBUFSIZE);
    SPLASSERT(lpszBuf[0] != TEXT('\0'));

    return lpszBuf;
}

/*****************************************************************************\
* HttpExtensionProc
*
* Main entrypoint for HTML generation.
*
\*****************************************************************************/
DWORD WINAPI HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK *pECB)
{
    DWORD       dwRet = HSE_STATUS_ERROR;
    PALLINFO    pAllInfo = NULL;     // This structure contains all relevant info for this connection
    LPTSTR      pPrinterName = NULL;

    // Assume failure
    if(!pECB) return HSE_STATUS_ERROR;

    pECB->dwHttpStatusCode = HTTP_STATUS_NOT_SUPPORTED;

    // Get the server name and convert it to the unicode string.
    if (!GetServerName (pECB))
        return HSE_STATUS_ERROR;

    if (!(pAllInfo = (PALLINFO) LocalAlloc (LPTR, sizeof (ALLINFO))))
        return HSE_STATUS_ERROR;

    // Initialize pAllInfo
    ZeroMemory(pAllInfo, sizeof(ALLINFO));

    pAllInfo->pECB = pECB;

    // Convert the ANSI string in ECB to Unicode
    // weihaic
    // pAllInfo->lpszQueryString = AllocateUnicodeString(DecodeStringA (pECB->lpszQueryString));
    // We can not decode now becuase the decoded string will bring troubles in parsing
    //
    pAllInfo->lpszQueryString    = AllocateUnicodeString(pECB->lpszQueryString);
    pAllInfo->lpszMethod         = AllocateUnicodeString(pECB->lpszMethod);
    pAllInfo->lpszPathInfo       = AllocateUnicodeString(pECB->lpszPathInfo);
    pAllInfo->lpszPathTranslated = AllocateUnicodeString(pECB->lpszPathTranslated);

    if (!pAllInfo->lpszQueryString ||
        !pAllInfo->lpszMethod      ||
        !pAllInfo->lpszPathInfo    ||
        !pAllInfo->lpszPathTranslated ) {

        goto Cleanup;
    }

    // weihaic
    // The query string contain user entered text such as printer location
    // priner description, etc. These strings are case sensitive, so we
    // could not convert them to upper case at the very beginning
    // CharUpper (pAllInfo->lpszQueryString);
    //
    CharUpper (pAllInfo->lpszMethod);
    CharUpper (pAllInfo->lpszPathInfo);
    CharUpper (pAllInfo->lpszPathTranslated);


    if (! (pPrinterName = GetPrinterName (pAllInfo->lpszPathInfo))) {
        // This is a wrong URL, return error code
        dwRet = ProcessErrorMessage (pAllInfo, ERROR_INVALID_DATA);
        goto Cleanup;
    }

    if (! ParseQueryString (pAllInfo)) 
        goto Cleanup;
    
     
    dwRet = ProcessRequest (pAllInfo, pPrinterName);   // We always hit Cleanup anyway


    //dwRet = ParsePathInfo(pAllInfo);

#if 0
    if (dwRet == HSE_STATUS_ERROR) {
        LPTSTR  pszErrorContent = GetString(pAllInfo, IDS_ERROR_501CONTENT);
        LPSTR   pszAnsiErrorContent = (LPSTR)pszErrorContent;

        UnicodeToAnsiString(pszErrorContent, pszAnsiErrorContent, 0);

        DWORD dwSize = strlen (pszAnsiErrorContent);

        pECB->ServerSupportFunction(pECB->ConnID,
                                    HSE_REQ_SEND_RESPONSE_HEADER,
                                    "501 Function not supported",
                                    &dwSize,
                                    (LPDWORD) pszAnsiErrorContent);
    }
#endif


Cleanup:

    LocalFree (pPrinterName);
    LocalFree (pAllInfo->lpszQueryString);
    LocalFree (pAllInfo->lpszMethod);
    LocalFree (pAllInfo->lpszPathInfo);
    LocalFree (pAllInfo->lpszPathTranslated);

    LocalFree (pAllInfo);

    return dwRet;
} // HttpExtensionProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by printers.rc
//
#define IDS_ISAPI_DESCRIPTION           1
#define IDS_USER                        15
#define IDS_COLOR                       50

#define IDS_INVALID_DOS_SHARE           70

#define IDS_ERROR_CPUNOTSUPPORTED       200
#define IDS_ERROR_501CONTENT            202
#define IDS_ERROR_500CONTENT            203
#define IDS_ERROR_200CONTENT            204

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\pch.h ===
// Designed to allow automatic precompiled headers to do its thing

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <atlbase.h>    // ATL 2.1 support

#include <ntlsapi.h>    // Client Access Licensing
#include <httpext.h>
#include <wininet.h>
#include <spllib.hxx>

#include <icm.h>
#include <setupapi.h>
#include <splsetup.h>
#include <mscat.h>
#include <wincrypt.h>   // Support for individually signed files
#include <wintrust.h>

#include <clusapi.h>

#include "genglobl.h"
#include "genmem.h"
#include "genutil.h"
#include "geninf.h"
#include "gencdf.h"
#include "gencab.h"


#include "time.h"
#include "resource.h"
#include "globals.h"
#include "msw3prt.h"
#include "inetio.h"
#include "sleeper.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\printers.h ===
/********
*
*  Copyright (c) 1996  Microsoft Corporation
*
*
*  Module Name  : printers.h
*
*  Abstract :
*
*     This module contains the prototypes for the msw3prt.cxx file for
*		HTTP Printers Server Extension.
*
******************/

#ifndef _PRINTERS_H
#define _PRINTERS_H

// Function prototypes

void    ReadRegistry(PALLINFO pAllInfo);
DWORD   ListSharedPrinters(PALLINFO pAllInfo);
DWORD   ShowPrinterPage(PALLINFO pAllInfo, LPTSTR lpszPrinterName);
DWORD   ShowRemotePortAdmin( PALLINFO pAllInfo, LPTSTR lpszMoitorName );
DWORD   UploadFileToPrinter(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);
DWORD   ParsePathInfo(PALLINFO pAllInfo);
DWORD   ShowDetails(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);
DWORD   ShowJobInfo(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);
void    htmlAddLinks(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo=NULL);
DWORD   CreateExe(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo, ARCHITECTURE Architecture);
DWORD   InstallExe(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);
DWORD   JobControl(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);
DWORD   PrinterControl(PALLINFO pAllInfo, PPRINTERPAGEINFO pPageInfo);

BOOL    AuthenticateUser(PALLINFO pAllInfo);

void htmlStartHead(PALLINFO pAllInfo);
void htmlEndHead(PALLINFO pAllInfo);
void htmlStartBody(PALLINFO pAllInfo);
void htmlEndBody(PALLINFO pAllInfo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\sleeper.cxx ===
#include "pch.h"
#include "spool.h"

static BOOL    bInitialized;
static HANDLE  hQuitRequestEvent;

void InitSleeper (void)
{
    HANDLE  hThread;
    DWORD   dwThreadId;       // The thread id

    DBGMSG(DBG_INFO, ("Sleeper: Constructing..\r\n"));

    // Initialize member variables
    bInitialized = TRUE;
    hQuitRequestEvent = NULL;

    // These two events are used to synchronize the working thread and the main thread

    // The request event is set when the main thread plan to terminate the working thread.
    hQuitRequestEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (!hQuitRequestEvent)
        goto Cleanup;

    // Create a working thread
    hThread = CreateThread( NULL,0,
                            (LPTHREAD_START_ROUTINE) SleeperSchedule,
                            (LPVOID) hQuitRequestEvent,
                            0,
                            &dwThreadId );

    // Cleanup the handles
    if (!hThread) {
        goto Cleanup;
    }
    else {
        CloseHandle (hThread);
    }

    DBGMSG(DBG_INFO, ("Sleeper: Constructed\r\n"));
    return;

Cleanup:
    bInitialized = FALSE;

    if (hQuitRequestEvent) {
        CloseHandle (hQuitRequestEvent);
    }
}

void ExitSleeper ()
{
    DBGMSG(DBG_INFO, ("Sleeper: Destructing\r\n"));

    if (!bInitialized)
        return;

    DBGMSG(DBG_INFO, ("Sleeper: release event %x\r\n", hQuitRequestEvent));
    if (hQuitRequestEvent)
        SetEvent (hQuitRequestEvent);

    Sleep (1000);

    DBGMSG(DBG_INFO, ("Sleeper: Destructed\r\n"));
}

void SleeperSchedule (HANDLE hQuitRequestEvent)
{

    DBGMSG(DBG_INFO, ("Sleeper: Schedule\r\n"));
    DWORD dwStatus;

    while (1) {
        DBGMSG(DBG_INFO, ("Sleeper: Waiting for event %x\r\n", hQuitRequestEvent));

        dwStatus = WaitForSingleObject (hQuitRequestEvent, SLEEP_INTERVAL);

        DBGMSG(DBG_INFO, ("Sleeper: Wait returns %x\r\n", dwStatus));
        switch (dwStatus) {
        case WAIT_TIMEOUT:
            //Time out, continue working
            CleanupOldJob ();
            break;
        default:
            // quit if it is either WAIT_OBJECT_0 or any other events
            DBGMSG(DBG_INFO, ("Sleeper: The working thread quit\r\n"));
            CloseHandle (hQuitRequestEvent);
            ExitThread (0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\sleeper.h ===
/***********************************************************************
*
*  Copyright (c) 1997  Microsoft Corporation
*
*
*  Module Name  : sleeper.h
*
*  Abstract :
*
*     This module contains  the structure definitions and prototypes for the
*     sleeper class in HTTP Printers Server Extension.
*
******************/

#ifndef _SLEEPER_H
#define _SLEEPER_H

// The sleep wake up every 5 minutes
#define SLEEP_INTERVAL 300000

void InitSleeper (void);
void ExitSleeper (void);
void SleeperSchedule (HANDLE hQuitRequestEvent);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\spool.h ===
/********
*
*  Copyright (c) 1996  Microsoft Corporation
*
*
*  Module Name  : spool.h
*
*  Abstract :
*
*     This module contains the prototypes for the spool.cpp file for
*		HTTP Printers Server Extension.
*
******************/

#ifndef _SPOOL_H
#define _SPOOL_H

// ----------------------------------------------------------------------
//
// GLOBAL EXTERNS
//
// ----------------------------------------------------------------------


// This structure defines the asynchronous-reads when processing large
// jobs.  This is used to track state-information during the job.
//
#define SPL_ASYNC_BUF  65535

typedef struct _SPLASYNC {

    WORD   wReq;        // Type of request processing.
    HANDLE hPrinter;    // Handle to printer.
    LPTSTR lpszShare;   // Sharename for printer (used in job-response).
    HANDLE hIpp;        // Handle to an Ipp-Stream-Processor.
    LPBYTE lpbBuf;      // Buffer which asynchronous reads are kept.
    DWORD  cbTotal;     // Total bytes to read for the job.
    DWORD  cbRead;      // Number of bytes accumulated during reads.
    DWORD  cbBuf;       // Size of our buffer (static size).
    LPBYTE lpbRet;      // Return-buffer based upon request.

} SPLASYNC, *PSPLASYNC, *LPSPLASYNC;



// ----------------------------------------------------------------------
//
// JOB FUNCTIONS
//
// ----------------------------------------------------------------------

// Structure for linked list we keep open job information in
typedef struct _INIJOB {
    DWORD       signature;
    DWORD       cb;
    struct _INIJOB  *pNext;
    struct _INIJOB  *pPrevious;

    DWORD       JobId;
    HANDLE      hPrinter;
    DWORD       dwFlags;
    DWORD       dwStatus;

    LS_HANDLE      hLicense;               // Client Access License Handle
    DWORD       dwStartTime;
    EXTENSION_CONTROL_BLOCK *pECB;              // Struct from ISAPI interface

} INIJOB, *PINIJOB;

#define IJ_SIGNATURE    0x494A  /* 'IJ' is the signature value */

#define MAX_JOB_MINUTE  15  // The maximum duration for a single job in spooler is 15 minutes


#define JOB_READY       0   // Job is ready for deleting or processing
#define JOB_BUSY        1   // Job is being processed by some thread

DWORD
OpenJob(
    IN  LPEXTENSION_CONTROL_BLOCK pECB,
    IN  HANDLE                    hPrinter,
    IN  PIPPREQ_PRTJOB            pipr,
    IN  DWORD                     dwSize,
    OUT PINIJOB                   *ppCopyIniJob = NULL
);

BOOL
WriteJob(
    DWORD JobId,
    LPBYTE pBuf,
    DWORD dwSize,
    LPDWORD pWritten
);

BOOL
CloseJob(
    DWORD JobId
);

BOOL
DeleteJob(
    DWORD JobId
);

VOID
AddJobEntry(
    PINIJOB     pIniJob
);

VOID
DeleteJobEntry(
    PINIJOB     pIniJob
);

PINIJOB
FindJob(
    DWORD JobId, DWORD dwStatus = JOB_READY
);

BOOL CleanupOldJob(void);
DWORD GetCurrentMinute (void);


// ----------------------------------------------------------------------
//
// Client Access Licensing FUNCTIONS
//
// ----------------------------------------------------------------------

BOOL RequestLicense(
    LS_HANDLE *phLicense,
    LPEXTENSION_CONTROL_BLOCK pECB
);

void FreeLicense(
    LS_HANDLE hLicense
);


// ----------------------------------------------------------------------
//
// Impersonation utilities
//
// ----------------------------------------------------------------------


HANDLE
RevertToPrinterSelf(
    VOID
);

BOOL
ImpersonatePrinterClient(
    HANDLE  hToken
);


// ----------------------------------------------------------------------
//
// HELPER FUNCTIONS
//
// ----------------------------------------------------------------------


#ifdef DEBUG

LPVOID
AllocSplMem(
    DWORD cb
);


BOOL
FreeSplMem(
   LPVOID pMem,
   DWORD  cb
);

#else

#define AllocSplMem(a)      LocalAlloc(LPTR, a)
#define FreeSplMem(a, b)    LocalFree(a)

#endif

LPTSTR
AllocSplStr(
    LPCTSTR lpStr
);

BOOL
FreeSplStr(
   LPTSTR lpStr
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\spool.cxx ===
/***************************************************************************
FILE                            spool.cpp

MODULE                          Printers ISAPI DLL

PURPOSE                         Spool Print Jobs

DESCRIBED IN

HISTORY     01/16/96 ccteng     Stub
            02/14/97 weihaic
            11/11/97 sylvan     IPP PrintJobRequest
            11/20/97 chriswil   Asynchronous read rewrite
****************************************************************************/

#include "pch.h"
#include "spool.h"
#include "printers.h"


#ifndef HSE_REQ_ASYNC_READ_CLIENT
#define HSE_REQ_ASYNC_READ_CLIENT ((DWORD)1010)
#endif

PINIJOB pIniFirstJob = NULL;

/*****************************************************************************
 * EnterSplSem
 * LeaveSplSem
 *
 *****************************************************************************/
#define EnterSplSem()    EnterCriticalSection(&SplCritSect)
#define LeaveSplSem()    LeaveCriticalSection(&SplCritSect)


/*****************************************************************************
 * Spl_StrSize (Local Routine)
 *
 * Returns the size (in bytes) of the string (includes null-terminator).
 *
 *****************************************************************************/
inline DWORD Spl_StrSize(
    LPCTSTR lpszStr)
{
    return (lpszStr ? ((lstrlen(lpszStr) + 1) * sizeof(TCHAR)) : 0);
}


/*****************************************************************************
 * Spl_CallSSF (Local Routine)
 *
 * Calls the ISAPI ServerSupportFunction
 *
 *****************************************************************************/
inline BOOL Spl_CallSSF(
    LPEXTENSION_CONTROL_BLOCK pECB,
    DWORD                     dwCmd,
    LPVOID                    lpvBuf,
    LPDWORD                   lpdwBuf,
    LPDWORD                   lpdwType)
{
    return pECB->ServerSupportFunction(pECB->ConnID, dwCmd, lpvBuf, lpdwBuf, lpdwType);
}


/*****************************************************************************
 * Spl_SetAsyncCB (Local Routine)
 *
 * Calls the ISAPI ServerSupportFunction to set an asynchronous callback.
 *
 *****************************************************************************/
inline BOOL Spl_SetAsyncCB(
    LPEXTENSION_CONTROL_BLOCK pECB,
    LPVOID                    pfnCallback,
    LPDWORD                   lpdwCtx)
{
    return pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_IO_COMPLETION, pfnCallback, NULL, lpdwCtx);
}


/*****************************************************************************
 * Spl_ReadClient (Local Routine)
 *
 * Calls the ISAPI ServerSupportFunction to do an asynchronous read.
 *
 *****************************************************************************/
inline BOOL Spl_ReadClient(
    LPEXTENSION_CONTROL_BLOCK pECB,
    LPVOID                    lpvBuf,
    DWORD                     cbBuf)
{
    DWORD dwType = HSE_IO_ASYNC;

    return pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_ASYNC_READ_CLIENT, lpvBuf, &cbBuf, &dwType);
}


/*****************************************************************************
 * Spl_WriteClient (Local Routine)
 *
 * Calls the ISAPI WriteClient to do a write.
 *
 *****************************************************************************/
inline BOOL Spl_WriteClient(
    LPEXTENSION_CONTROL_BLOCK pECB,
    LPVOID                    lpvBuf,
    DWORD                     cbBuf)
{
    return pECB->WriteClient(pECB->ConnID, lpvBuf, &cbBuf, (DWORD)NULL);
}


/*****************************************************************************
 * Spl_EndSession (Local Routine)
 *
 * Calls the ISAPI ServerSupportFunction to end our session.
 *
 *****************************************************************************/
inline BOOL Spl_EndSession(
    LPEXTENSION_CONTROL_BLOCK pECB)
{
    DWORD dwStatus = HSE_STATUS_SUCCESS;
    return pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_DONE_WITH_SESSION, &dwStatus, NULL, NULL);
}


/*****************************************************************************
 * Spl_WriteJob (Local Routine)
 *
 * Writes the byte-stream for a print-job.
 *
 *****************************************************************************/
BOOL Spl_WriteJob(
    DWORD  dwJobId,
    LPBYTE lpbData,
    DWORD  cbBytes)
{
    DWORD cbLeft;
    DWORD cbWritten;
    BOOL  fRet = TRUE;


    for (cbLeft = cbBytes; (cbLeft > 0) && fRet; ) {

        if (fRet = WriteJob(dwJobId, lpbData, cbBytes, &cbWritten)) {

            lpbData += cbWritten;
            cbLeft  -= cbWritten;

        } else {

            DBGMSG(DBG_WARN, ("Spl_WriteJob() call failed.\r\n"));
            break;
        }
    }

    return fRet;
}


/*****************************************************************************
 * Spl_AllocPrtUri (Local Routine)
 *
 * Returns a PrinterURI string.
 *
 *****************************************************************************/
LPTSTR Spl_AllocPrtUri(
    LPCTSTR lpszShare,
    LPDWORD lpcbUri,
    BOOL    bSecure)
{

    DWORD  cch;
    DWORD  cbSize;
    LPTSTR lpszUri;


    // Get the size necessary to hold the printer-uri.
    //
    *lpcbUri = 0;
    cch      = 0;

    GetWebpnpUrl(g_szHttpServerName, lpszShare, NULL, bSecure, NULL, &cch);

    if (cch && (lpszUri = (LPTSTR)AllocSplMem(sizeof(TCHAR) * cch))) {

        if (GetWebpnpUrl(g_szHttpServerName, lpszShare, NULL, bSecure, lpszUri, &cch)) {

            *lpcbUri = cch * sizeof(TCHAR);

            return lpszUri;
        }

        FreeSplMem(lpszUri, cch * sizeof(TCHAR));
    }

    return NULL;
}


/*****************************************************************************
 * Spl_AllocJobUri (Local Routine)
 *
 * Returns a JobURI string.
 *
 *****************************************************************************/
LPTSTR Spl_AllocJobUri(
    LPCTSTR lpszShare,
    DWORD   idJob,
    LPDWORD lpcbUri,
    BOOL    bBase,
    BOOL    bSecure)
{
    LPTSTR lpszPrt;
    DWORD  cbSize;
    DWORD  cbPrt;
    DWORD  cch;
    LPTSTR lpszUri = NULL;

    static CONST TCHAR s_szFmt1[] = TEXT("%s?IPP&JobId=%d");
    static CONST TCHAR s_szFmt2[] = TEXT("%s?IPP&JobId=");


    // Set our return-count to zero.
    //
    *lpcbUri = 0;


    // Get the printer-uri, and append a job-id to the end
    // as our job-uri.
    //
    cbPrt = 0;
    if (lpszPrt = Spl_AllocPrtUri(lpszShare, &cbPrt, bSecure)) {

        cbSize = cbPrt + sizeof(s_szFmt1) + 40;

        if (lpszUri = (LPTSTR)AllocSplMem(cbSize)) {

            if (bBase)
                cch = wsprintf(lpszUri, s_szFmt2, lpszPrt);
            else
                cch = wsprintf(lpszUri, s_szFmt1, lpszPrt, idJob);

//          *lpcbUri = (cch * sizeof(TCHAR));  This is the number of bytes written, not
//  the amount of memory allocated
            *lpcbUri = cbSize;
        }

        FreeSplMem(lpszPrt, cbPrt);
    }

    return lpszUri;
}


/*****************************************************************************
 * Spl_GetJI2 (Local Routine)
 *
 * Returns a JOB_INFO_2 struct.
 *
 *****************************************************************************/
LPJOB_INFO_2 Spl_GetJI2(
    HANDLE  hPrinter,
    DWORD   idJob,
    LPDWORD lpcbSize)
{
    DWORD        cbSize;
    DWORD        dwLE;
    LPJOB_INFO_2 pji2 = NULL;


    // Clear return-size.
    //
    *lpcbSize = 0;


    // Get the size necessary for the job.
    //
    cbSize = 0;
    GetJob(hPrinter, idJob, 2, NULL, 0, &cbSize);


    // Get the job-information.
    //
    if (cbSize && (pji2 = (LPJOB_INFO_2)AllocSplMem(cbSize))) {

        if (GetJob(hPrinter, idJob, 2, (LPBYTE)pji2, cbSize, &cbSize)) {

            *lpcbSize = cbSize;

        } else {

            dwLE = GetLastError();

            FreeSplMem(pji2, cbSize);
            pji2 = NULL;
        }

    } else {

        dwLE = GetLastError();
    }


    if (pji2 == NULL)
        SetLastError(dwLE);

    return pji2;
}


/*****************************************************************************
 * Spl_AllocAsync
 *
 * Allocate a spool-async-read structure.  This is basically a structure
 * that we use to track where we are in the asynchronous read processing.
 *
 * Parameter/Field descriptions
 * ----------------------------
 * wReq      - IPP Request identifier.
 *
 * hPrinter  - handle to printer.  We are in charge of closing this when
 *             we're done processing the asynchronous reads.
 *
 * lpszShare - share-name of printer.  This is necessary when we respond
 *             back to the client when done processing the job.
 *
 * cbTotal   - Total number of bytes to expect in job.
 *
 * cbRead    - Current bytes read during async read.
 *
 * cbBuf     - Size of read-buffer.
 *
 * lpbRet    - Return-Buffer dependent upon IPP Request identifier.
 *
 *****************************************************************************/
LPSPLASYNC Spl_AllocAsync(
    WORD    wReq,
    HANDLE  hPrinter,
    LPCTSTR lpszShare,
    DWORD   cbTotal)
{
    LPSPLASYNC pAsync;


    if (pAsync = (LPSPLASYNC)AllocSplMem(sizeof(SPLASYNC))) {

        if (pAsync->hIpp = WebIppRcvOpen(wReq)) {

            if (pAsync->lpbBuf = (LPBYTE)AllocSplMem(SPL_ASYNC_BUF)) {

                if (pAsync->lpszShare = AllocSplStr(lpszShare)) {

                    pAsync->wReq     = wReq;
                    pAsync->hPrinter = hPrinter;
                    pAsync->cbTotal  = cbTotal;
                    pAsync->cbRead   = 0;
                    pAsync->cbBuf    = SPL_ASYNC_BUF;
                    pAsync->lpbRet   = NULL;

                    return pAsync;
                }

                FreeSplMem(pAsync->lpbBuf, SPL_ASYNC_BUF);
            }

            WebIppRcvClose(pAsync->hIpp);
        }

        FreeSplMem(pAsync, sizeof(SPLASYNC));
    }

    DBGMSG(DBG_ERROR, ("Spl_AllocAsync() : Out of Memory\r\n"));

    SetLastError(ERROR_OUTOFMEMORY);

    return NULL;
}


/*****************************************************************************
 * Spl_FreeAsync
 *
 * Free our asynchronous read structure.  This also closes our printer
 * handle that was setup prior to the beginning of the job.
 *
 *****************************************************************************/
BOOL Spl_FreeAsync(
    LPSPLASYNC pAsync)
{
    LPIPPRET_JOB pj;


    // Close the printer-handle.  We do this here as oppose to in
    // (msw3prt.cxx), since if we had performed asynchronous reads
    // we would need to leave the scope the HttpExtensionProc() call.
    //
    // NOTE: CloseJob() closes the printer-handle.  Only in the case
    //       where we were not able to open a job should we close it
    //       here.
    //
    pj = (LPIPPRET_JOB)pAsync->lpbRet;

    if ((pAsync->wReq == IPP_REQ_PRINTJOB) && pj && pj->bRet) {

        CloseJob((DWORD)pj->bRet);

    } else {

        ClosePrinter(pAsync->hPrinter);
    }


    // Free up our Ipp-handle, and all resources allocated.
    //
    if (pAsync->lpbBuf)
        FreeSplMem(pAsync->lpbBuf, pAsync->cbBuf);

    if (pAsync->lpszShare)
        FreeSplStr(pAsync->lpszShare);

    if (pAsync->lpbRet)
        WebIppFreeMem(pAsync->lpbRet);

    if (pAsync->hIpp)
        WebIppRcvClose(pAsync->hIpp);

    FreeSplMem(pAsync, sizeof(SPLASYNC));

    return TRUE;
}


/*****************************************************************************
 * Spl_OpenPrn (Local Routine)
 *
 * Opens a printer-handle with administrator rights.
 *
 *****************************************************************************/
HANDLE Spl_OpenPrn(
    HANDLE hPrinter)
{
    PPRINTER_INFO_1  ppi;
    PRINTER_DEFAULTS pa;
    DWORD            cbSize;
    HANDLE           hPrn = NULL;


    cbSize = 0;
    GetPrinter(hPrinter, 1, NULL, 0, &cbSize);

    if (cbSize && (ppi = (PPRINTER_INFO_1)AllocSplMem(cbSize))) {

        if (GetPrinter(hPrinter, 1, (LPBYTE)ppi, cbSize, &cbSize)) {

            // Since the OpenPrinter call in msw3prt.cxx has been
            // opened with the share-name, the (pName) field of this
            // call will already have the server-name prepended to the
            // friendly-name.  We do not need to do any further work
            // on the friendly-name to accomodate clustering.  If in the
            // future the OpenPrinter() specifies the friendly-name over
            // the share-name, then this routine will need to call
            // genFrnName() to convert the friendly to <server>\friendly.
            //
            ZeroMemory(&pa, sizeof(PRINTER_DEFAULTS));
            pa.DesiredAccess = PRINTER_ALL_ACCESS;

            OpenPrinter(ppi->pName, &hPrn, &pa);
        }

        FreeSplMem(ppi, cbSize);
    }

    return hPrn;
}

/*****************************************************************************
** Spl_AllocSplMemFn (Local Routine)
**
** The WebIppPackJI2 call takes an allocator, however AllocSplMem is a #define
** if we are not using a debug library, so in this case, we have to create
** a small stub function ourselves.
**
*****************************************************************************/
#ifdef DEBUG
    #define Spl_AllocSplMemFn  AllocSplMem
#else
LPVOID Spl_AllocSplMemFn(DWORD cb) {
    return LocalAlloc(LPTR, cb);
}
#endif // #ifdef DEBUG

/*****************************************************************************
 * Spl_CreateJobInfo2 (Local Routine)
 *
 * This creates a JobInfo2 structure from the various printer details that have
 * been passed in to us. 
 *
 *****************************************************************************/
LPJOB_INFO_2 Spl_CreateJobInfo2( 
    IN  PIPPREQ_PRTJOB  ppj,            // This provides some info that is useful for constructing
                                        // our own JOB_INFO_2 if necessary
    IN  PINIJOB         pInijob,        // This is also used for constructing a JOB_INFO_2
    OUT LPDWORD         lpcbSize        
    ) {
    ASSERT(ppj);                        // This should never be NULL if this code path is reached
    ASSERT(lpcbSize);
    ASSERT(*lpcbSize == 0);             // This should be passed in zero
    

    LPJOB_INFO_2  pji2 = NULL;          // The packed and allocated JI2

    if (pInijob) {                      // This could conceivably be NULL
        DWORD            cbNeeded = 0;

        GetPrinter( pInijob->hPrinter, 2, NULL, 0, &cbNeeded );

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER && cbNeeded) {
            LPPRINTER_INFO_2 ppi2;          // The printer info to fill out
            DWORD            cbNextNeeded;            

            ppi2 = (LPPRINTER_INFO_2)AllocSplMem( cbNeeded );
            
            if (ppi2 && GetPrinter( pInijob->hPrinter, 2, (LPBYTE)ppi2, cbNeeded, &cbNextNeeded) ) {
                JOB_INFO_2    ji2;                  // The ji2 we will fill out, a properly packed one will
                                                    // be returned
                ZeroMemory( &ji2, sizeof(ji2) );

                ji2.JobId               = pInijob->JobId;
                ji2.pPrinterName        = ppi2->pPrinterName;           
                ji2.pMachineName        = ppi2->pServerName;
                ji2.pUserName           = ppj->pUserName;
                ji2.pNotifyName         = ppj->pUserName;
                ji2.pDocument           = ppj->pDocument;
                ji2.pDatatype           = ppi2->pDatatype;
                ji2.pPrintProcessor     = ppi2->pPrintProcessor;
                ji2.pParameters         = ppi2->pParameters;
                ji2.pDriverName         = ppi2->pDriverName;
                ji2.Status              = pInijob->dwStatus; 
                ji2.Priority            = ppi2->Priority;
                ji2.StartTime           = pInijob->dwStartTime;
                ji2.UntilTime           = pInijob->dwStartTime;
                GetSystemTime (&ji2.Submitted);   
                
                pji2 = WebIppPackJI2(&ji2, lpcbSize, Spl_AllocSplMemFn);
            }

            if (ppi2) 
                FreeSplMem( ppi2, cbNeeded );
           
        }
    }
    
    return pji2;
}

    

/*****************************************************************************
 * Spl_ConfirmJob (Local Routine)
 *
 * This confirms that a Job has been printed if it returns a JOB_INFO_2 if
 * this is possible. GSNW printers can return an ERROR_PRINT_CANCELLED for the
 * first GetJob call and then fail on the second call. In this case we need to
 * build a shell JOB_INFO_2 with whatever data we can find and return it. We pass
 * this in to Web FILL IN HERE which packs the correct strings and returns a 
 * Legitimate JOB_INFO_2 structure.
 *
 *****************************************************************************/
LPJOB_INFO_2 Spl_ConfirmJob(
    IN  HANDLE          hPrinter,       // This is the printer handle we are using
    IN  DWORD           idJob,          // This is the job id given to us by StartDocPrinter
    OUT LPDWORD         lpcbSize,       // This is the size of the allocated block
    IN  PIPPREQ_PRTJOB  ppj,            // This provides some info that is useful for constructing
                                        // our own JOB_INFO_2 if necessary
    IN  PINIJOB         pInijob         // This is also used for constructing a JOB_INFO_2
    )
{
    DWORD        cbSize;
    DWORD        dwLE;
    LPJOB_INFO_2 pji2 = NULL;
    

    ASSERT(lpcbSize);
    // Clear return-size.
    //
    *lpcbSize = 0;

    // Get the size necessary for the job.
    //
    cbSize = 0;
    GetJob(hPrinter, idJob, 2, NULL, 0, &cbSize);

    dwLE = GetLastError();

    switch(dwLE) {
    case ERROR_INSUFFICIENT_BUFFER:
        // Get the job-information.
        //
        if (cbSize && (pji2 = (LPJOB_INFO_2)AllocSplMem(cbSize))) {
    
            if (GetJob(hPrinter, idJob, 2, (LPBYTE)pji2, cbSize, &cbSize)) {
    
                *lpcbSize = cbSize;
                
            } else {
    
                dwLE = GetLastError();
    
                FreeSplMem(pji2, cbSize);
                pji2 = NULL;
            }
    
        } else {
    
            dwLE = GetLastError();
        }

        break;

    case ERROR_PRINT_CANCELLED:
        // This is special-cased for GSNW masq printers where the job cannot
        // be retrieved from the Server, but we do not want to fail the EndDocPrinter
        // call

        if (pji2 = Spl_CreateJobInfo2( ppj, pInijob, lpcbSize) )
            SetLastError(dwLE = ERROR_SUCCESS);

        break;

    case ERROR_SUCCESS:
        // What the?

        dwLE = ERROR_INVALID_PARAMETER;

        break;
    }
    
    if (pji2 == NULL)
        SetLastError(dwLE);

    return pji2;
}



/*****************************************************************************
 * Spl_IppJobDataPrt (Local Routine)
 *
 * Handles the IPP_REQ_PRINTJOB request.
 *
 *****************************************************************************/
BOOL Spl_IppJobDataPrt(
    LPEXTENSION_CONTROL_BLOCK pECB,
    HANDLE                    hPrinter,
    LPCTSTR                   lpszShare,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE                    lpbDta,
    DWORD                     cbDta,
    LPBYTE*                   lplpbRet)
{
    PIPPREQ_PRTJOB ppj;
    JOB_INFO_IPP   ipp;
    DWORD          cbUri;
    DWORD          cbPrn;
    DWORD          cbJI2;
    WORD           wError;
    DWORD          idJob = 0;
    LPJOB_INFO_2   pji2  = NULL;
    BOOL           bRet  = FALSE;


    if (ppj = (PIPPREQ_PRTJOB)lpbHdr) {

        // Initialize job-information.
        //
        ZeroMemory(&ipp, sizeof(JOB_INFO_IPP));


        // See if we're only to validate the job.
        //
        if (ppj->bValidate) {

            // NOTE: We'll return only a success for now until
            //       we can build a table of validation criteria.
            //
            //       30-Jul-1998 : ChrisWil
            //
            wError = IPPRSP_SUCCESS;
            idJob  = (DWORD)TRUE;

        } else {

            // Start the job.
            //
            PINIJOB pInijob;

            if (idJob = OpenJob(pECB, hPrinter, ppj, cbHdr, &pInijob)) {

                if (pji2 = Spl_ConfirmJob(hPrinter, idJob, &cbJI2, ppj, pInijob)) {
                    
                    wError      = IPPRSP_SUCCESS;
                    ipp.pJobUri = Spl_AllocJobUri(lpszShare, idJob, &cbUri, FALSE, IsSecureReq(pECB));
                    ipp.pPrnUri = Spl_AllocPrtUri(lpszShare, &cbPrn, IsSecureReq(pECB));

                } else {

                    wError = WebIppLeToRsp(GetLastError());
                }

                // Delete the pIniJob (if it has been allocated)

                if (pInijob) 
                    FreeSplMem( pInijob, sizeof(INIJOB) );
            } else {

                wError = WebIppLeToRsp(GetLastError());
            }
        }


        // Build the return structure.
        //
        *lplpbRet = (LPBYTE)WebIppCreateJobRet(wError,
                                               (BOOL)idJob,
                                               ppj->bValidate,
                                               pji2,
                                               &ipp);

        // Free allocated resources.
        //
        WebIppFreeMem(lpbHdr);

        if (pji2)
            FreeSplMem(pji2, cbJI2);

        if (ipp.pJobUri)
            FreeSplMem(ipp.pJobUri, cbUri);

        if (ipp.pPrnUri)
            FreeSplMem(ipp.pPrnUri, cbPrn);


        // If we failed to get a job-id, then we need to
        // return with no further processing.
        //
        if (idJob == 0)
            return FALSE;

        bRet = TRUE;

    } else {

        // If we had no header, then we are processing stream data
        // for the job.  In this case we would have already been through
        // the code-path above where the job-id was set as our return
        // code.
        //
        if (*lplpbRet)
            idJob = (DWORD)((PIPPRET_JOB)*lplpbRet)->bRet;
    }


    // If we were able to get a data-stream, then we
    // need to process that in the write.  If we are chunking
    // data and the lpbHdr is NULL, then the (lpdwJobId) is
    // passed in as input to this routine to be used in chunk
    // writes.
    //
    if (lpbDta)
        bRet = Spl_WriteJob(idJob, lpbDta, cbDta);

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobDataSet (Local Routine)
 *
 * Handles the SetJob requests.
 *
 *****************************************************************************/
BOOL Spl_IppJobDataSet(
    LPEXTENSION_CONTROL_BLOCK pECB,
    HANDLE                    hPrinter,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE*                   lplpbRet)
{
    PIPPREQ_SETJOB psj;
    JOB_INFO_2     ji2;
    WORD           wError;
    BOOL           bRet = FALSE;


    if (psj = (PIPPREQ_SETJOB)lpbHdr) {

        // Initialize job-information.
        //
        ZeroMemory(&ji2, sizeof(JOB_INFO_2));


        // Perform the SetJob command.
        //
        bRet = SetJob(hPrinter, psj->idJob, 0, NULL, psj->dwCmd);


        // Get LastError for return to the client.
        //
        wError = (bRet ? IPPRSP_SUCCESS : WebIppLeToRsp(GetLastError()));


        // Return the SetJobRet structure.
        //
        *lplpbRet = (LPBYTE)WebIppCreateJobRet(wError, bRet, FALSE, &ji2, NULL);


        // Free allocated resources.
        //
        WebIppFreeMem(lpbHdr);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobDataAth (Local Routine)
 *
 * Handles the Authentication request.
 *
 *****************************************************************************/
BOOL Spl_IppJobDataAth(
    LPEXTENSION_CONTROL_BLOCK pECB,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE*                   lplpbRet)
{
    PIPPREQ_AUTH pfa;
    WORD         wError;
    BOOL         bRet = FALSE;


    if (pfa = (PIPPREQ_AUTH)lpbHdr) {

        // Call authentication check.
        //
        bRet = !IsUserAnonymous(pECB);


        // Get LastError for return to the client.
        //
        wError = (bRet ? IPPRSP_SUCCESS : IPPRSP_ERROR_401);


        // Return the SetJobRet structure.
        //
        *lplpbRet = (LPBYTE)WebIppCreateAuthRet(wError, bRet);


        // Free allocated resources.
        //
        WebIppFreeMem(lpbHdr);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobDataEnu (Local Routine)
 *
 * Handles the IPP_REQ_ENUJOB request.  This returns a complete enumeration
 * of jobs.  It is up to the client to determine which job they are
 * interested in (if they're only interested in one-job).
 *
 *****************************************************************************/
BOOL Spl_IppJobDataEnu(
    LPEXTENSION_CONTROL_BLOCK pECB,
    HANDLE                    hPrinter,
    LPCTSTR                   lpszShare,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE*                   lplpbRet)
{
    LPIPPREQ_ENUJOB pgj;
    LPIPPJI2        lpIppJi2;
    LPTSTR          lpszJobBase;
    LPJOB_INFO_2    lpji2;
    DWORD           cbJobs;
    DWORD           cJobs;
    DWORD           cbNeed;
    DWORD           cNeed;
    DWORD           cbUri;
    WORD            wError;
    BOOL            bRet = FALSE;


    if (pgj = (LPIPPREQ_ENUJOB)lpbHdr) {

        // Initialize IPP return variables.
        //
        cbJobs = 0;
        cJobs  = 0;
        lpji2  = NULL;


        // Get the size necessary to hold the enumerated jobs.  We
        // will return JOB_INFO_2, since that has the most information.
        //
        cbNeed = 0;
        bRet = EnumJobs(hPrinter, 0, pgj->cJobs, 2, NULL, 0, &cbNeed, &cNeed);


        // If we have jobs to enumerate, then grab them.
        //
        if (cbNeed && (lpji2 = (LPJOB_INFO_2)AllocSplMem(cbNeed))) {

            bRet = EnumJobs(hPrinter,
                            0,
                            pgj->cJobs,
                            2,
                            (LPBYTE)lpji2,
                            cbNeed,
                            &cbJobs,
                            &cJobs);

            DBGMSG(DBG_INFO,("Spl_IppJobDataEnu(): cJobs(%d), cbJobs(%d)\r\n", cJobs, cbJobs));
        }

        wError = (bRet ? IPPRSP_SUCCESS : WebIppLeToRsp(GetLastError()));


        // Convert the enumerated-jobs to an IPPJI2 structure.  This
        // allows us to pass information that is not part of a JOB_INFO_2.
        //
        lpszJobBase = Spl_AllocJobUri(lpszShare, 0, &cbUri, TRUE, IsSecureReq (pECB));

        lpIppJi2 = WebIppCvtJI2toIPPJI2(lpszJobBase, &cbJobs, cJobs, lpji2);

        if (lpszJobBase)
            FreeSplMem(lpszJobBase, cbUri);


        // Return the EnuJobRet structure as an IPP stream.
        //
        *lplpbRet = (LPBYTE)WebIppCreateEnuJobRet(wError,
                                                  bRet,
                                                  cbJobs,
                                                  cJobs,
                                                  lpIppJi2);


        // Free allocated resources.
        //
        WebIppFreeMem(lpbHdr);

        if (lpIppJi2)
            WebIppFreeMem(lpIppJi2);

        if (lpji2)
            FreeSplMem(lpji2, cbNeed);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobDataGet (Local Routine)
 *
 * Handles the IPP_REQ_GETJOB request. This returns the information for a single
 * job.
 *
 *****************************************************************************/
BOOL Spl_IppJobDataGet(
    LPEXTENSION_CONTROL_BLOCK pECB,
    HANDLE                    hPrinter,
    LPCTSTR                   lpszShare,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE*                   lplpbRet)
{
    PIPPREQ_GETJOB pgj;
    LPJOB_INFO_2   pji2;
    JOB_INFO_IPP   ipp;
    DWORD          cbUri;
    DWORD          cbPrn;
    WORD           wError;
    DWORD          cbJI2;
    BOOL           bRet   = FALSE;


    if (pgj = (PIPPREQ_GETJOB)lpbHdr) {

        // Initialize job-information.
        //
        ZeroMemory(&ipp, sizeof(JOB_INFO_IPP));


        if (pji2 = Spl_GetJI2(hPrinter, pgj->idJob, &cbJI2)) {

            wError      = IPPRSP_SUCCESS;
            ipp.pJobUri = Spl_AllocJobUri(lpszShare, pgj->idJob, &cbUri, FALSE, IsSecureReq(pECB));
            ipp.pPrnUri = Spl_AllocPrtUri(lpszShare, &cbPrn, IsSecureReq(pECB));

        } else {

            wError = WebIppLeToRsp(GetLastError());
        }


        // Set the return value.
        //
        *lplpbRet = (LPBYTE)WebIppCreateJobRet(wError, bRet, FALSE, pji2, &ipp);


        // Free allocated resources.
        //
        WebIppFreeMem(lpbHdr);

        if (pji2)
            FreeSplMem(pji2, cbJI2);

        if (ipp.pJobUri)
            FreeSplMem(ipp.pJobUri, cbUri);

        if (ipp.pPrnUri)
            FreeSplMem(ipp.pPrnUri, cbPrn);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppPrnDataGet (Local Routine)
 *
 * Handles the IPP_REQ_GETPRN request.
 *
 *****************************************************************************/
BOOL Spl_IppPrnDataGet(
    LPEXTENSION_CONTROL_BLOCK pECB,
    HANDLE                    hPrinter,
    LPCTSTR                   lpszShare,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE*                   lplpbRet)
{
    LPIPPREQ_GETPRN  pgp;
    LPPRINTER_INFO_2 lppi2;
    PRINTER_INFO_IPP ipp;
    DWORD            cbSize;
    DWORD            cbUri;
    WORD             wError;
    BOOL             bRet = FALSE;


    if (pgp = (LPIPPREQ_GETPRN)lpbHdr) {

        // Initialize the default information.
        //
        ZeroMemory(&ipp, sizeof(PRINTER_INFO_IPP));
        ipp.pPrnUri = Spl_AllocPrtUri(lpszShare, &cbUri, IsSecureReq(pECB));


        // Get PRINTER_INFO_2 information.
        //
        cbSize = 0;
        GetPrinter(hPrinter, 2, NULL, 0, &cbSize);

        if (lppi2 = (LPPRINTER_INFO_2)AllocSplMem(cbSize)) {
            bRet = GetPrinter(hPrinter, 2, (LPBYTE)lppi2, cbSize, &cbSize);
            if (!bRet) {        // lppi2 might be full of garbage, so free it and pass NULL
                FreeSplMem( lppi2, cbSize );
                lppi2 = NULL;
            }
        }
            
        // Grab last-error if call failed.
        //
        wError = (bRet ? IPPRSP_SUCCESS : WebIppLeToRsp(GetLastError()));


        // Return the printer-structure.
        //
        *lplpbRet = (LPBYTE)WebIppCreatePrnRet(wError, bRet, lppi2, &ipp);


        // Free allocated resources.
        //
        if (lppi2)
            FreeSplMem(lppi2, cbSize);

        if (ipp.pPrnUri)
            FreeSplMem(ipp.pPrnUri, cbUri);

        WebIppFreeMem(lpbHdr);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppPrnDataSet (Local Routine)
 *
 * Handles SetPrinter Requests.
 *
 *****************************************************************************/
BOOL Spl_IppPrnDataSet(
    LPEXTENSION_CONTROL_BLOCK pECB,
    HANDLE                    hPrinter,
    LPBYTE                    lpbHdr,
    DWORD                     cbHdr,
    LPBYTE*                   lplpbRet)
{
    PIPPREQ_SETPRN psp;
    PRINTER_INFO_2 pi2;
    HANDLE         hPrn;
    WORD           wError;
    BOOL           bRet = FALSE;


    if (psp = (PIPPREQ_SETPRN)lpbHdr) {

        // Initialize default information.
        //
        ZeroMemory(&pi2, sizeof(PRINTER_INFO_2));


        // Open the printer with admin-priviledges to get
        // the printer information.
        //
        if (hPrn = Spl_OpenPrn(hPrinter)) {

            // Set the job for SetPrinter.
            //
            if ((bRet = SetPrinter(hPrn, 0, NULL, psp->dwCmd)) == FALSE)
                wError = WebIppLeToRsp(GetLastError());
            else
                wError = IPPRSP_SUCCESS;

            ClosePrinter(hPrn);

        } else {

            wError = WebIppLeToRsp(GetLastError());
        }


        // Return the printer-information structure.
        //
        *lplpbRet = (LPBYTE)WebIppCreatePrnRet(wError, bRet, &pi2, NULL);


        // Free allocated resources.
        //
        WebIppFreeMem(lpbHdr);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobData (Local Routine)
 *
 * Processes ipp stream data.  This returns a structure specific to the
 * type of request.
 *
 *****************************************************************************/
BOOL Spl_IppJobData(
    LPEXTENSION_CONTROL_BLOCK pECB,
    WORD                      wReq,
    HANDLE                    hPrinter,
    LPCTSTR                   lpszShare,
    HANDLE                    hIpp,
    LPBYTE                    lpbBuf,
    DWORD                     cbBuf,
    LPBYTE*                   lplpbRet)
{
    DWORD  dwIpp;
    LPBYTE lpbHdr;
    DWORD  cbHdr;
    LPBYTE lpbDta;
    DWORD  cbDta;
    BOOL   bRet = FALSE;


    // Convert the stream.
    //
    dwIpp = WebIppRcvData(hIpp, lpbBuf, cbBuf, &lpbHdr, &cbHdr, &lpbDta, &cbDta);


    // See how to process it.
    //
    switch (dwIpp) {

    case WEBIPP_OK:

        switch (wReq) {

        case IPP_REQ_FORCEAUTH:
            bRet = Spl_IppJobDataAth(pECB, lpbHdr, cbHdr, lplpbRet);
            break;

        case IPP_REQ_PRINTJOB:
        case IPP_REQ_VALIDATEJOB:
            bRet = Spl_IppJobDataPrt(pECB,
                                     hPrinter,
                                     lpszShare,
                                     lpbHdr,
                                     cbHdr,
                                     lpbDta,
                                     cbDta,
                                     lplpbRet);
            break;

        case IPP_REQ_CANCELJOB:
        case IPP_REQ_PAUSEJOB:
        case IPP_REQ_RESUMEJOB:
        case IPP_REQ_RESTARTJOB:
            bRet = Spl_IppJobDataSet(pECB, hPrinter, lpbHdr, cbHdr, lplpbRet);
            break;

        case IPP_REQ_ENUJOB:
            bRet = Spl_IppJobDataEnu(pECB, hPrinter, lpszShare, lpbHdr, cbHdr, lplpbRet);
            break;

        case IPP_REQ_GETJOB:
            bRet = Spl_IppJobDataGet(pECB, hPrinter, lpszShare, lpbHdr, cbHdr, lplpbRet);
            break;

        case IPP_REQ_GETPRN:
            bRet = Spl_IppPrnDataGet(pECB, hPrinter, lpszShare, lpbHdr, cbHdr, lplpbRet);
            break;

        case IPP_REQ_PAUSEPRN:
        case IPP_REQ_RESUMEPRN:
        case IPP_REQ_CANCELPRN:
            bRet = Spl_IppPrnDataSet(pECB, hPrinter, lpbHdr, cbHdr, lplpbRet);
            break;
        }
        break;

    case WEBIPP_MOREDATA:

        // More processing.  Do nothing here.
        //
        *lplpbRet = NULL;
        bRet      = TRUE;
        break;

    case WEBIPP_NOMEMORY:
        DBGMSG(DBG_WARN, ("Spl_IppJobData() failed (%d)\r\n", dwIpp));

        *lplpbRet = NULL;
        bRet      = FALSE;
        break;

    case WEBIPP_BADHANDLE:
        *lplpbRet = (LPBYTE)WebIppCreateBadRet(IPPRSP_ERROR_500, FALSE);
        bRet      = FALSE;
        break;

    default:
    case WEBIPP_FAIL:
        *lplpbRet = (LPBYTE)WebIppCreateBadRet(WebIppGetError(hIpp), FALSE);
        bRet      = TRUE;
        break;
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobRsp
 *
 * Sends back a job-response in IPP format.
 *
 *****************************************************************************/
BOOL Spl_IppJobRsp(
   LPEXTENSION_CONTROL_BLOCK pECB,
   WORD                      wReq,
   LPREQINFO                 lpri,
   LPBYTE                    lpbRet)
{
    LPBYTE lpIpp;
    DWORD  cbIpp;
    DWORD  cbHdr;
    DWORD  dwIpp;
    DWORD  cch;
    LPCSTR lpszErr;
    CHAR   szHdr[1024];
    BOOL   bRet = FALSE;

    static CONST CHAR s_szErr400[] = "400 Failed Response";
    static CONST CHAR s_szErr401[] = "401 Authentication Required";
    static CONST CHAR s_szHtpHdr[] = "Content-Type: application/ipp\r\nContent-Length: %d\r\n\r\n";


    if (lpbRet) {

        // Convert to an IPP-Buffer from the return-buffer structure.  For
        // failure cases, the last-error is initialized in the (lpbRet)
        // structure so that the appropriate stream can be generated.
        //
        dwIpp = WebIppSndData((IPP_RESPONSE | wReq),
                              lpri,
                              lpbRet,
                              *((LPDWORD)lpbRet),
                              &lpIpp,
                              &cbIpp);

        if (dwIpp == WEBIPP_OK) {

            // If we had an access-denied, then we will need to include
            // error 401.  This will force the client to prompt for
            // validation.
            //
            if (((LPIPPRET_ALL)lpbRet)->dwLastError == ERROR_ACCESS_DENIED)
                lpszErr = s_szErr401;
            else
                lpszErr = NULL;


            // Build header information.
            //
            cch = wsprintfA(szHdr, s_szHtpHdr, cbIpp);


            // First we send a standard SEND_RESPONSE_HEADER w/our
            // content-type ServerSupportFunction only handles szText,
            // ANSI ??? see URL:
            //
            //   http://www.microsoft.com/WIN32DEV/APIEXT/ISAPIREF.HTM
            //
            // see include httpfilt.h
            //
            Spl_CallSSF(pECB,
                        HSE_REQ_SEND_RESPONSE_HEADER,
                        (LPVOID)lpszErr,
                        (LPDWORD)&cch,
                        (LPDWORD)szHdr);


            // For binary data we use WriteClient.
            //
            bRet = Spl_WriteClient(pECB, lpIpp, cbIpp);

            WebIppFreeMem(lpIpp);

        } else {

            DBGMSG(DBG_WARN, ("Warn: WebIppSndData failed (%d)", dwIpp));
        }
    }


    // Send an HTTP error header if we had big problems...
    //
    if (bRet == FALSE) {

        cch = lstrlenA(s_szErr400);

        Spl_CallSSF(pECB,
                    HSE_REQ_SEND_RESPONSE_HEADER,
                    (LPVOID)s_szErr400,
                    (LPDWORD)&cch,
                    (LPDWORD)NULL);
    }

    return bRet;
}


/*****************************************************************************
 * Spl_IppJobAsyncCB
 *
 * Process the asynchronous reads.  This is called by a random ISAPI thread.
 *
 *****************************************************************************/
VOID Spl_IppJobAsyncCB(
    LPEXTENSION_CONTROL_BLOCK pECB,
    PVOID                     pInfo,
    DWORD                     cbIO,
    DWORD                     dwError)
{
    LPSPLASYNC pAsync;
    REQINFO    ri;
    BOOL       bRet;


    if (pAsync = (LPSPLASYNC)pInfo) {

        if ((dwError == 0) && cbIO) {

            // Process the return from the IPP-Receive.  This will
            // process the bytes to the job.
            //
            bRet = Spl_IppJobData(pECB,
                                  pAsync->wReq,
                                  pAsync->hPrinter,
                                  pAsync->lpszShare,
                                  pAsync->hIpp,
                                  pAsync->lpbBuf,
                                  cbIO,
                                  &pAsync->lpbRet);


            // Read another chunk if we haven't read it all yet..
            //
            pAsync->cbRead += cbIO;


            // If an error occured, or we reached the end of our reads,
            // then we need to bail out of the asynchronous callback.
            //
            if ((bRet == FALSE) || (pAsync->cbRead >= pAsync->cbTotal)) {

                goto SplCBDone;
            }


            // Read another chunk.
            //
            Spl_ReadClient(pECB, pAsync->lpbBuf, pAsync->cbBuf);

        } else {

            DBGMSG(DBG_WARN, ("Spl_IppJobAsyncCB() : Called with error or zero-bytes\r\n"));

            bRet = (pAsync->cbRead >= pAsync->cbTotal);

SplCBDone:

            // Send our response-header.
            //
            WebIppGetReqInfo(pAsync->hIpp, &ri);

            Spl_IppJobRsp(pECB, pAsync->wReq, &ri, pAsync->lpbRet);

            Spl_FreeAsync(pAsync);

            Spl_EndSession(pECB);
        }

    } else {

        DBGMSG(DBG_ERROR, ("Spl_IppJobAsyncCB() : No Context Value\r\n"));

        Spl_EndSession(pECB);
    }
}


/*****************************************************************************
 * Spl_IppJobAsync
 *
 * This routine processes the job as an asynchronous read.
 * It is only called once, the rest of the packets are handled by the async call back.
 *
 * How IIS's Async reads work:
 *  1) ISAPI's HTTPExtensionProc gets called for the first chunk of data as usual.
 *  2) In that call:
 *       - The ISAPI sets up a context, allocs a buffer and registers a call back for
 *         async reads.
 *       - Consumes the first chunk of the data.
 *       - Calls ServerSupportFunction( HSE_REQ_ASYNC_READ_CLIENT...) passing the buffer
 *           for IIS to write to. This call returns immediately with no data. When
 *           IIS has got more data from the client, it writes it to the ISAPI's buffer, then
 *           calls the call back passing the context handle that points to the buffer.
 *  3) The call back consumes the data, then calls ServerSupportFunction(
 *      HSE_REQ_ASYNC_READ_CLIENT) again to repeat the cycle. IIS calls the call back
 *      once per ISAPI's call to ServerSupportFunction( HSE_REQ_ASYNC_READ_CLIENT ).
 *
 *****************************************************************************/
DWORD Spl_IppJobAsync(
    LPEXTENSION_CONTROL_BLOCK pECB,
    WORD                      wReq,
    LPCTSTR                   lpszShare,
    HANDLE                    hPrinter)
{
    LPSPLASYNC pAsync;
    REQINFO    ri;
    BOOL       bRet = FALSE;
    BOOL       bSuccess = FALSE;

    // Allocate our structure that contains our state
    // info during asynchronous reads.
    //
    if (pAsync = Spl_AllocAsync(wReq, hPrinter, lpszShare, pECB->cbTotalBytes)) {

        // Set our asynchronous callback.  Specify our (pAsync) structure
        // as the context which is passed to each callback.
        //
        if (Spl_SetAsyncCB(pECB, (LPVOID)Spl_IppJobAsyncCB, (LPDWORD)pAsync)) {

            // Process our first buffer.  Our first chunk will utilize
            // what's already in the ECB-structure.  For other chunks,
            // we will specify our own buffer.
            //
            bSuccess = Spl_IppJobData(pECB,
                                  wReq,
                                  pAsync->hPrinter,
                                  pAsync->lpszShare,
                                  pAsync->hIpp,
                                  pECB->lpbData,
                                  pECB->cbAvailable,
                                  &pAsync->lpbRet);

            if (bSuccess) {

                // Increment our read-count for the bytes we've
                // just processed.
                //
                pAsync->cbRead += pECB->cbAvailable;


                // Do our first asynchronous read.  Return if all is
                // successful.
                //
                if (Spl_ReadClient(pECB, pAsync->lpbBuf, pAsync->cbBuf))
                    return HSE_STATUS_PENDING;
            }

            WebIppGetReqInfo(pAsync->hIpp, &ri);

            Spl_IppJobRsp(pECB, wReq, &ri, pAsync->lpbRet);

            Spl_EndSession(pECB);

            bRet = TRUE;  // We must return HSE_STATUS_PENDING if we call 
                          // HSE_REQ_DONE_WITH_SESSION
        }


        // Free our async-structure.  This indirectly frees the
        // return buffer as well.
        //
        Spl_FreeAsync(pAsync);

    } else {

        ClosePrinter(hPrinter);
    }

    return (bRet ? HSE_STATUS_PENDING : HSE_STATUS_ERROR);
}


/*****************************************************************************
 * Spl_IppJobSync
 *
 * This routine processes the job as a synchronous-read.  This implies that
 * our entire job made it in one-post, and thus doesn't need to perform
 * any reads.
 *
 *****************************************************************************/
DWORD Spl_IppJobSync(
    LPEXTENSION_CONTROL_BLOCK pECB,
    WORD                      wReq,
    LPCTSTR                   lpszShare,
    HANDLE                    hPrinter)
{
    HANDLE       hIpp;
    LPIPPRET_JOB pj;
    REQINFO      ri;
    LPBYTE       lpbRet = NULL;
    BOOL         bRet   = FALSE;


    // Initialize request structure.
    //
    ZeroMemory(&ri, sizeof(REQINFO));
    ri.idReq     = 0;
    ri.cpReq     = CP_UTF8;
    ri.pwlUns    = NULL;
    ri.bFidelity = FALSE;

    ri.fReq[0] = IPP_REQALL;
    ri.fReq[1] = IPP_REQALL;

    // Open an IPP-Receive channel and call the routine to process
    // the job.
    //
    if (hIpp = WebIppRcvOpen(wReq)) {

        bRet = Spl_IppJobData(pECB,
                              wReq,
                              hPrinter,
                              lpszShare,
                              hIpp,
                              pECB->lpbData,
                              pECB->cbAvailable,
                              &lpbRet);

        WebIppGetReqInfo(hIpp, &ri);
    }


    // Send the job-response back to the client.  If we weren't able
    // to open an IPP-Receive handle, or our job-processing failed,
    // then our error is FALSE.
    //
    bRet = Spl_IppJobRsp(pECB, wReq, &ri, lpbRet);


    // Free up the receive-handle only after the response.  We need to
    // insure the integrity of the unsupported-list-handle.
    //
    if (hIpp)
        WebIppRcvClose(hIpp);


    // Close the printer-handle.  We do this here as oppose to in
    // (msw3prt.cxx), since if we had performed asynchronous reads
    // we would need to leave the scope the HttpExtensionProc() call.
    //
    // NOTE: CloseJob() closes the printer-handle.  Only in the case
    //       where we were not able to open a job should we close it
    //       here.
    //
    pj = (LPIPPRET_JOB)lpbRet;

    if((wReq == IPP_REQ_PRINTJOB) && pj && pj->bRet) {

        CloseJob((DWORD)pj->bRet);

    } else {

        ClosePrinter(hPrinter);
    }


    // Free our return-structure.
    //
    if (lpbRet)
        WebIppFreeMem(lpbRet);

    return (bRet ? HSE_STATUS_SUCCESS : HSE_STATUS_ERROR);
}


/*****************************************************************************
 * SplIppJob
 *
 * Process the IPP Job Request.
 *
 * Get the print-job.  If we can't handle the entire post within this
 * scope, then we setup for asynchronous reads.
 *
 *****************************************************************************/
DWORD SplIppJob(
    WORD             wReq,
    PALLINFO         pAllInfo,
    PPRINTERPAGEINFO pPageInfo)
{
    DWORD dwRet;


    // If our bytes aren't contained in one-chunk, then
    // we need to start an asynchronous read.
    //
    // Otherwise, if our available amounts to the total-bytes
    // of the job, then we can process the entire command sychronousely.
    //
    if (pAllInfo->pECB->cbAvailable < pAllInfo->pECB->cbTotalBytes) {

        dwRet = Spl_IppJobAsync(pAllInfo->pECB,
                                wReq,
                                pPageInfo->pPrinterInfo->pShareName,
                                pPageInfo->hPrinter);
    } else {

        dwRet = Spl_IppJobSync(pAllInfo->pECB,
                               wReq,
                               pPageInfo->pPrinterInfo->pShareName,
                               pPageInfo->hPrinter);
    }

    return dwRet;
}


/*****************************************************************************
 * OpenJob
 *
 * Starts a job.  This creates a new spool-job-entry, the returns a jobid.
 *  
 *
 *****************************************************************************/
DWORD OpenJob(
    IN  LPEXTENSION_CONTROL_BLOCK pECB,
    IN  HANDLE                    hPrinter,
    IN  PIPPREQ_PRTJOB            pipr,
    IN  DWORD                     dwSize,
    OUT PINIJOB                   *ppCopyIniJob)
{
    PINIJOB   pIniJob;
    DWORD     JobId = 0;
    LS_HANDLE hLicense;


    if ((NULL == hPrinter) || (NULL == pipr) || (dwSize < sizeof(IPPREQ_PRTJOB)))
        return 0;


    if( RequestLicense( &hLicense, pECB )) {    // Enforce the Client Access Licensing

        if (pIniJob = (PINIJOB)AllocSplMem(sizeof(INIJOB))) {
            
            DWORD      dwNeeded;
            DOC_INFO_1 di = {0, 0, 0};

            ZeroMemory( pIniJob, sizeof(INIJOB) );  // This ensures that unset fields are NULL

            pIniJob->signature = IJ_SIGNATURE;
            pIniJob->cb        = sizeof(INIJOB);
            pIniJob->hLicense  = hLicense;


            di.pDocName = pipr->pDocument;


            if (JobId = StartDocPrinter(hPrinter, 1, (LPBYTE)&di)) {

                // we successfully add a job to spooler
                //
                pIniJob->JobId = JobId;

#if 0
                //This is a long, complicated way of doing nothing! 
                //We do a GetJob with no call to SetJob or any other side effect.  
                // --  MLAWRENC

                // set User name

                // =======================================================
                // CCTENG 2/5/96
                //
                // The way we set user name here may not work on NT.
                // We do this because we don't have client impersonation.
                //
                // This also require a UPDATED SPOOLSS.DLL to work,
                // it doesn't work on WIN95.
                // =======================================================

                // MAKE SURE ALL THE LEVEL PARAMETERS ARE THE SAME !!!
                //
                if (!GetJob(hPrinter, pIniJob->JobId, 1, NULL, 0, &dwNeeded) &&
                    (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
                {
                    PJOB_INFO_1 pJobInfo;
                    DWORD       cb = dwNeeded;

                    if(pJobInfo = (PJOB_INFO_1)AllocSplMem(cb)) {

                        if (GetJob(hPrinter, pIniJob->JobId, 1, (LPBYTE)pJobInfo, cb, &dwNeeded)) {

                            pJobInfo->pUserName = (pipr->pUserName ? pipr->pUserName : TEXT("Unknown"));

                            //
                            // If you do not want to set a printer job's position in that printer queue, you
                            // should set the Position member to be JOB_POSITION_UNSPECIFIED
                            //
                            // weihaic 07/09/98
                            //pJobInfo->Position  = JOB_POSITION_UNSPECIFIED;

                            //SetJob(hPrinter, pIniJob->JobId, 1, (LPBYTE)pJobInfo, 0);
                        }

                        FreeSplMem(pJobInfo, cb);
                    }
                }
#endif

                // keep the hPrinter until CloseJob
                //
                pIniJob->hPrinter = hPrinter;

                pIniJob->dwStartTime = GetCurrentMinute();
                pIniJob->dwStatus    = JOB_READY;
                pIniJob->pECB        = pECB;

                
                if (ppCopyIniJob) 
                // Allocate and copy the new ppIniJob structure out, some of the elements
                // will be null
                    if (*ppCopyIniJob = (PINIJOB)AllocSplMem( sizeof(INIJOB) ) )
                        CopyMemory( *ppCopyIniJob, pIniJob, sizeof(INIJOB) );
                
                AddJobEntry(pIniJob);

            } else {

                // StartDocPrinter Failed
                //
                DBGMSG(DBG_WARN, ("StartDocPrinter Failed %d\n", GetLastError()));

                FreeSplMem(pIniJob, pIniJob->cb);

                FreeLicense( hLicense );
            }
        }
        else   // if alloc failed
            FreeLicense( hLicense );

    } else {         // if failed to update a license


        // Spl_IppJobRsp() will check for this and send down
        // proper error to the client.
        //
        SetLastError( ERROR_LICENSE_QUOTA_EXCEEDED );
    }


#ifdef DEBUG

    if (JobId)
        DBGMSG(DBG_INFO,("OpenJob : succeed, JobID == %d\r\n", JobId));
    else
        DBGMSG(DBG_WARN,("OpenJob : failed!\r\n"));
#endif

    // what is this for in the failure case ???
    //
    // AuthenticateUser(pAllInfo);
    //


    return JobId;
}


/*****************************************************************************
 * WriteJob
 *
 * Write the job.
 *
 *****************************************************************************/
BOOL WriteJob(
    DWORD   JobId,
    LPBYTE  pBuf,
    DWORD   dwSize,
    LPDWORD pWritten)
{
    PINIJOB pIniJob;
    BOOL    bRet = FALSE;

    if (pIniJob = FindJob(JobId, JOB_BUSY)) {

        // need to add code to check *pWritten == dwSize
        // No need to check. The caller will check if all the bytes are written - weihaic
        //
        bRet = WritePrinter(pIniJob->hPrinter, pBuf, dwSize, pWritten);
        pIniJob->dwStatus = JOB_READY;
        return bRet;
    }

    return FALSE;
}


/*****************************************************************************
 * CloseJob
 *
 * Close job and remove from the list.
 *
 *****************************************************************************/
BOOL CloseJob(
    DWORD JobId)
{
    PINIJOB pIniJob;
    BOOL    ret = FALSE;

    if (pIniJob = FindJob(JobId, JOB_BUSY)) {

        ret = EndDocPrinter(pIniJob->hPrinter);

        ClosePrinter(pIniJob->hPrinter);

        DeleteJobEntry(pIniJob);

        // CleanupOldJob needs to do the same to take care of orphan Async jobs.
        FreeLicense( pIniJob->hLicense );

        FreeSplMem(pIniJob, pIniJob->cb);
    }

    return ret;
}


/*****************************************************************************
 * DeleteJob
 *
 * TBD : Unimplemented.
 *
 *****************************************************************************/
BOOL DeleteJob(
    DWORD JobId)
{
    return TRUE;
}


/*****************************************************************************
 * AddJobEntryToLinkList
 *
 * Add an entry from a double linked list
 *
 *****************************************************************************/

VOID AddJobEntryToLinkList(
    PINIJOB &pIniFirstJob,
    PINIJOB pIniJob)
{
    PINIJOB pIniJobTmp;

    pIniJob->pNext = NULL;
    pIniJob->pPrevious = NULL;

    if (!(pIniJobTmp = pIniFirstJob))
    {
        pIniFirstJob = pIniJob;
    }
    else
    {
        // add pIniJob to the end of the list

        for (; pIniJobTmp->pNext; pIniJobTmp = pIniJobTmp->pNext)
            ;

        pIniJob->pPrevious = pIniJobTmp;
        pIniJobTmp->pNext = pIniJob;
    }
}


/*****************************************************************************
 * DeleteJobEntryFromLinkList
 *
 * Delete an entry from a double linked list
 *
 *****************************************************************************/
VOID DeleteJobEntryFromLinkList(
    PINIJOB &pIniFirstJob,
    PINIJOB pIniJob)
{
    if (pIniJob->pPrevious)
        pIniJob->pPrevious->pNext = pIniJob->pNext;
    else
        // pIniJob must be the first job
        pIniFirstJob = pIniJob->pNext;

    if (pIniJob->pNext)
        pIniJob->pNext->pPrevious = pIniJob->pPrevious;
}

/*****************************************************************************
 * AddJobEntry
 *
 * I just use a simple double linked list for now.  Can be changed to
 * something else such as a hash table later, if desired.
 *
 *****************************************************************************/
VOID AddJobEntry(
    PINIJOB pIniJob)
{
    EnterSplSem();

    AddJobEntryToLinkList(pIniFirstJob, pIniJob);

    LeaveSplSem();
}


/*****************************************************************************
 * DeleteJobEntry
 *
 * Delete job from the job-list.
 *
 *****************************************************************************/
VOID DeleteJobEntry(
    PINIJOB pIniJob)
{
    EnterSplSem();

    DeleteJobEntryFromLinkList (pIniFirstJob, pIniJob);

    LeaveSplSem();
}



/*****************************************************************************
 *
 * FindJob
 *
 * Looks for job in the job-list and dwStatus
 *
 *****************************************************************************/
PINIJOB FindJob(
    DWORD JobId,
    DWORD dwStatus)
{
    PINIJOB pIniJob;

    EnterSplSem();

    // pIniJob will end up being NULL if a match is not found

    for (pIniJob = pIniFirstJob; pIniJob; pIniJob = pIniJob->pNext)
    {
        if (pIniJob->dwStatus == JOB_READY && pIniJob->JobId == JobId) {
            // found the match, break and return pIniJob
            // Set the status
            pIniJob->dwStatus = dwStatus;
            break;
        }
    }

    LeaveSplSem();

    return pIniJob;
}


/*****************************************************************************
 * CleanupOldJob
 *
 * This function is called by Sleeper->Work() about every 15 minutes to cleanup
 * the pending unclosed jobs due to the failure of the network or any other
 * possible reasons.
 *
 *****************************************************************************/
BOOL CleanupOldJob()
{
    DWORD           dwCurrentTime       = GetCurrentMinute();
    PINIJOB         pIniJob;
    PINIJOB         pIniTmpJob;
    PINIJOB         pIniFirstOldJob     = NULL;

    if (!pIniFirstJob) return TRUE;

    DBGMSG (DBG_WARN, ("Enter Cleanup...\r\n"));

    EnterSplSem();

    for (pIniJob = pIniFirstJob; pIniJob; pIniJob = pIniTmpJob) {
        pIniTmpJob = pIniJob->pNext;
        if (pIniJob->dwStatus == JOB_READY) {
            DWORD dwDiff = (1440 + dwCurrentTime - pIniJob->dwStartTime) % 1440;

            if (dwDiff > MAX_JOB_MINUTE) {
                DBGMSG (DBG_WARN, ("OldJob found %x\r\n", pIniJob->hPrinter));
                DeleteJobEntry (pIniJob);
                AddJobEntryToLinkList (pIniFirstOldJob, pIniJob);
            }
        }
    }

    LeaveSplSem();

    DWORD dwStatus =  HTTP_STATUS_REQUEST_TIMEOUT;

    // Delete the job outside the critical section
    for (pIniJob = pIniFirstOldJob; pIniJob; pIniJob = pIniTmpJob) {
        pIniTmpJob = pIniJob->pNext;
        EndDocPrinter(pIniJob->hPrinter);
        ClosePrinter(pIniJob->hPrinter);
        FreeLicense( pIniJob->hLicense );     // CleanupOldJob needs to do the same to take care of orphan Async jobs.


#ifdef ASYNC_READ_ENABLED

        // Disable it because we're not trying to manage the cleanup for
        // http sessions. If there is a session pending because we close
        // the job, the callback function (Spl_JobPrintCB)
        // will close the session itself.
        //
        pIniJob->pECB->ServerSupportFunction(pIniJob->pECB->ConnID,
                                             HSE_REQ_DONE_WITH_SESSION,
                                             &dwStatus,
                                             NULL,
                                             NULL);
#endif
        FreeSplMem(pIniJob, pIniJob->cb);
    }
    return TRUE;
}

/*****************************************************************************
 * GetCurrentMinute
 *
 * Get the current minute since midnight
 *
 *****************************************************************************/
DWORD GetCurrentMinute ()
{
    SYSTEMTIME CurTime;

    GetSystemTime (&CurTime);
    return CurTime.wHour * 60 + CurTime.wMinute;
}

#ifdef DEBUG

DWORD dwSplHeapSize = 0;

/*****************************************************************************
 * AllocSplMem (Helper)
 *
 * Routine Description:
 *
 *     This function will allocate local memory. It will possibly allocate extra
 *     memory and fill this with debugging information for the debugging version.
 *
 * Arguments:
 *
 *     cb - The amount of memory to allocate
 *
 * Return Value:
 *
 *     NON-NULL - A pointer to the allocated memory
 *
 *     FALSE/NULL - The operation failed. Extended error status is available
 *     using GetLastError.
 *
 *
 *****************************************************************************/
LPVOID AllocSplMem(
    DWORD cb)
{
    PDWORD  pMem;
    DWORD   cbNew;

    cbNew = cb+2*sizeof(DWORD);
    if (cbNew & 3)
        cbNew += sizeof(DWORD) - (cbNew & 3);

    pMem=(PDWORD)LocalAlloc(LPTR, cbNew);

    if (!pMem)
    {
        DBGMSG(DBG_ERROR, ("Memory Allocation failed for %d bytes\n", cbNew));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    *pMem=cb;
    *(PDWORD)((PBYTE)pMem+cbNew-sizeof(DWORD))=0xdeadbeef;

    dwSplHeapSize += cbNew;

    return (LPVOID)(pMem+1);
}


/*****************************************************************************
 * FreeSplMem (Helper)
 *
 *
 *****************************************************************************/
BOOL FreeSplMem(
    LPVOID pMem,
    DWORD  cb)
{
    DWORD   cbNew;
    LPDWORD pNewMem;

    if (!pMem)
        return FALSE;

    pNewMem = (LPDWORD)pMem;
    pNewMem--;

    cbNew = cb+2*sizeof(DWORD);
    if (cbNew & 3)
        cbNew += sizeof(DWORD) - (cbNew & 3);

    if (*pNewMem != cb) {
        DBGMSG(DBG_ERROR, ("Corrupt Memory Size in inetsrv-spool : %0lx %0lx != %0lx\n", 
                           pNewMem, *pNewMem, cb));
        return FALSE;
    }

    if (*(LPDWORD)((LPBYTE)pNewMem + cbNew - sizeof(DWORD)) != 0xdeadbeef) {
        DBGMSG(DBG_ERROR, ("Memory Overrun in inetsrv-spool : %0lx\n", pNewMem));
        return FALSE;        
    }

    LocalFree((LPVOID)pNewMem);

    dwSplHeapSize -= cbNew;

    return TRUE;
}

#endif // DEBUG


/*****************************************************************************
 * AllocSplStr (Helper)
 *
 * Routine Description:
 *
 *     This function will allocate enough local memory to store the specified
 *     string, and copy that string to the allocated memory
 *
 * Arguments:
 *
 *     pStr - Pointer to the string that needs to be allocated and stored
 *
 * Return Value:
 *
 *     NON-NULL - A pointer to the allocated memory containing the string
 *
 *     FALSE/NULL - The operation failed. Extended error status is available
 *     using GetLastError.
 *****************************************************************************/
LPTSTR AllocSplStr(
    LPCTSTR lpszStr)
{
    DWORD  cbSize;
    LPTSTR lpszCpy = NULL;


    if (cbSize = Spl_StrSize(lpszStr)) {

        if (lpszCpy = (LPTSTR)AllocSplMem(cbSize))
           CopyMemory((PVOID)lpszCpy, (PVOID)lpszStr, cbSize);
    }

    return lpszCpy;
}


/*****************************************************************************
 * FreeSplStr (Helper)
 *
 *
 *****************************************************************************/
#ifdef DEBUG
    #define FREE_PTR_TO_LONG(X) (X)
#else
    #define FREE_PTR_TO_LONG(X) (PtrToLong(X))
#endif
    
BOOL FreeSplStr(
   LPTSTR lpszStr)
{
   DWORD cbSize;

   cbSize = Spl_StrSize(lpszStr);

   return (BOOL)(lpszStr ? FREE_PTR_TO_LONG(FreeSplMem(lpszStr, cbSize)) : FALSE);
}


/*****************************************************************************
 * AuthenticateUser (Helper)
 *
 *
 *****************************************************************************/
BOOL AuthenticateUser(
    PALLINFO pAllInfo)
{
    // Wade says if we don't specify a header (szAuthHdr), and just submit a 401 error, IIS
    // would include (in the automatically generated header) what authenticaitons it is setup
    // to use (NTLM and/or Basic). So the client can pick the first one on the list and use it
    // (this is what IE does).
    //
    // Note: for NTLM to work, you need adirect socket connection. So it won't work across
    // firewalls (IIS admins are supposed to know this). Secure socket seems to do it though,
    // so for the new MS Proxy, it might be doable.
    //
    return Spl_CallSSF(pAllInfo->pECB,
                       HSE_REQ_SEND_RESPONSE_HEADER,
                       (LPVOID)"401 Authentication Required",
                       (LPDWORD)NULL,
                       (LPDWORD)NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\addjob.c ===
/*++

Copyright (c) 1990-1994 Microsoft Corporation

Module Name:

    addjob.c


Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Local Print Providor. This module contains
    LocalSpl's implementation of the following spooler apis

    LocalAddJob
    LocalScheduleJob


Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Rewritten both apis -- Krishna Ganugapati (KrishnaG) 5-Apr-1994
    RapidPrint -- Matthew A Felton (mattfe) June 1994

--*/

#include <precomp.h>
#pragma hdrstop

#include "jobid.h"
#include "winsprlp.h"
#include "filepool.hxx"

VOID
AddJobEntry(
    PINIPRINTER pIniPrinter,
    PINIJOB     pIniJob
);


BOOL
LocalAddJob(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    PINIPRINTER pIniPrinter;
    PINIJOB     pIniJob;
    PSPOOL      pSpool=(PSPOOL)hPrinter;
    DWORD       cb;
    WCHAR       szFileName[MAX_PATH];
    LPBYTE      pEnd;
    DWORD       LastError=0;
    LPADDJOB_INFO_1 pAddJob = (LPADDJOB_INFO_1)pData;
    DWORD       NextId;
    BOOL        bRemote = FALSE;
    DOC_INFO_1 DocInfo1;
    BOOL        bRet;
    DWORD       dwStatus = 0;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    LPWSTR      pMachineName = NULL;
    LPWSTR      pszSpoolFile = NULL;
    PMAPPED_JOB pMappedJob = NULL;
    
    SplOutSem();

    switch( Level ){
    case 1:
        break;

    case 2:
    case 3:
        pMachineName = (LPWSTR)( ((PBYTE)pData) +
                                 (ULONG_PTR)((PADDJOB_INFO_2W)pData)->pData );

        //
        // Validate string.
        //
        if( pMachineName > (LPWSTR)( ((PBYTE)pData)+cbBuf )){
            SetLastError( ERROR_INVALID_LEVEL );
            return FALSE;
        }

        //
        // Ensure NULL termination.
        //
        *(PWCHAR)(((ULONG_PTR)(pData + cbBuf - sizeof( WCHAR ))&~1)) = 0;
        break;

    default:
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

   //
   // memset docinfo
   //

   memset((LPBYTE)&DocInfo1, 0, sizeof(DOC_INFO_1));

   //
   // Figure out whether the job is a remote or local job
   //

   if (!IsLocalCall()) {
       bRemote = TRUE;
   }

   //
   // Get the name of the user
   //

   if (bRemote) {
       DocInfo1.pDocName = szRemoteDoc;
   } else{
       DocInfo1.pDocName = szLocalDoc;
   }


   EnterSplSem();

   if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {
       LeaveSplSem();
       return(FALSE);
   }

   //
   // We're interested if this is a remote call (not if it was opened
   // via \\server\remote).  The server process does this.
   //
   if (pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_CALL) {
       LeaveSplSem();
       SetLastError(ERROR_INVALID_PARAMETER);
       return(FALSE);
   }

   if (pSpool->TypeofHandle & PRINTER_HANDLE_PORT) {
       if (pSpool->pIniPort->Status & PP_MONITOR) {
           LeaveSplSem();
           SetLastError(ERROR_INVALID_PARAMETER);
           return(FALSE);
       } else {

           //
           // If we had level == 2 (passing in the computer name), then
           // convert back down to level 1 for old print providers.
           // We don't need to fix up the structure since level 1 and 2
           // are identical; it's just that level 2 is an in-out buffer.
           //
           //
           if (Level == 2 || Level == 3) {
               Level = 1;
           }

           //
           // This is the "Local Printer masquerading as a Remote  Printer"
           //
           LeaveSplSem();
           bRet = AddJob(pSpool->hPort, Level,  pData, cbBuf, pcbNeeded);
           return(bRet);
       }
   }

   pIniPrinter = pSpool->pIniPrinter;

   SPLASSERT(pIniPrinter);

   if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT) {
       LeaveSplSem();
       SetLastError(ERROR_INVALID_ACCESS);
       return(FALSE);
   }

   //
   // Disallow EMF if PRINTER_ATTRIBUTE_RAW_ONLY is set.
   //
   if( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_RAW_ONLY ){

       LPWSTR pszDatatype = pSpool->pDatatype ?
                                pSpool->pDatatype :
                                pIniPrinter->pDatatype;

       if( !ValidRawDatatype( pszDatatype )){
           LeaveSplSem();
           SetLastError( ERROR_INVALID_DATATYPE );
           return FALSE;
       }
   }

   NextId = GetNextId( pIniPrinter->pIniSpooler->hJobIdMap );

   GetFullNameFromId(pIniPrinter, NextId, TRUE, szFileName,
                        pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_CALL);
   cb = wcslen(szFileName)*sizeof(WCHAR) + sizeof(WCHAR) +
            sizeof(ADDJOB_INFO_1);

   *pcbNeeded = cb;
   if (cb > cbBuf) {

       // Freeup the JobId.
       vMarkOff( pIniPrinter->pIniSpooler->hJobIdMap, NextId);
       LeaveSplSem();
       SetLastError(ERROR_INSUFFICIENT_BUFFER);
       return(FALSE);
   }
   
   //
   // WMI Trace Event
   //
   LeaveSplSem();
   
   LogWmiTraceEvent(NextId, EVENT_TRACE_TYPE_SPL_SPOOLJOB, NULL);
   
   EnterSplSem();
   
   SplInSem();


   dwStatus = JOB_SPOOLING | JOB_TYPE_ADDJOB;
   if (Level == 2 || Level ==3) {
       dwStatus |= JOB_DOWNLEVEL;
   }
   if ((pIniJob = CreateJobEntry(pSpool,
                                 1,
                                 (LPBYTE)&DocInfo1,
                                 NextId,
                                 bRemote,
                                 dwStatus,
                                 pMachineName)) == NULL) {

       // Freeup the JobId.
       vMarkOff( pIniPrinter->pIniSpooler->hJobIdMap, NextId);
       DBGMSG(DBG_WARNING,("Error: CreateJobEntry failed in LocalAddJob\n"));
       LeaveSplSem();
       return(FALSE);
   }

   //
   // Level 3 is called only by RDR/SRV. For details see LocalScheduleJob
   //
   pIniJob->AddJobLevel = Level;

   pIniPrinter->cSpooling++;
   if (pIniPrinter->cSpooling > pIniPrinter->cMaxSpooling) {
       pIniPrinter->cMaxSpooling = pIniPrinter->cSpooling;
   }

   AddJobEntry(pIniPrinter, pIniJob);

   pEnd = (LPBYTE)pAddJob+cbBuf;
   pEnd -= wcslen(szFileName)*sizeof(WCHAR)+sizeof(WCHAR);
   WORD_ALIGN_DOWN(pEnd);

   wcscpy((LPWSTR)pEnd, szFileName);
   pAddJob->Path = (LPWSTR)pEnd;
   pAddJob->JobId = pIniJob->JobId;

   //
   // Now we want to add the job into the spools list of current jobs.
   // This is so that the spool file can be deleted correctly at the end 
   // of the job, even if we have aborted.
   //
   pMappedJob = AllocSplMem(sizeof( MAPPED_JOB ));

   pszSpoolFile = AllocSplMem(MAX_PATH * sizeof( WCHAR ));

   if (pMappedJob && pszSpoolFile)
   {
       BOOL bDuplicate = FALSE;
       DWORD TempJobId = pIniJob->JobId;
       PMAPPED_JOB pTempMappedJob;
        
       wcscpy(pszSpoolFile, szFileName); 
        
       //
       // Run through the list and make sure we have no duplicates
       //
        
       for (pTempMappedJob = pSpool->pMappedJob;
            pTempMappedJob;
            pTempMappedJob = pTempMappedJob->pNext) {
        
            if (pTempMappedJob->JobId == TempJobId) {
                bDuplicate = TRUE;
                break;
           }
       }
        
       //
       // No duplicates, add this job to the linked list.
       //
       if (!bDuplicate) {
        
           pMappedJob->pszSpoolFile = pszSpoolFile;
           pMappedJob->JobId = TempJobId;
           pMappedJob->pNext = pSpool->pMappedJob;
           pSpool->pMappedJob = pMappedJob;
        
       } else {
        
           FreeSplMem(pszSpoolFile);
           FreeSplMem(pMappedJob);
       }
   
   }
   else
   {
       FreeSplMem(pMappedJob);
       FreeSplMem(pszSpoolFile);
   }

   //
   //
   // Storing pIniJob in pSpool is bogus since you can call AddJob multiple
   // times.  We should have a linked list here.  If the client calls AddJob
   // two times then closes the handle (no ScheduleJob), then only the last
   // job is rundown and eliminated.
   //
   // This bug has been here since 3.1, and probably isn't worth fixing.
   //
   pSpool->pIniJob = pIniJob;
   pSpool->Status |= SPOOL_STATUS_ADDJOB;

   SetPrinterChange(pSpool->pIniPrinter,
                    pIniJob,
                    NVAddJob,
                    PRINTER_CHANGE_ADD_JOB | PRINTER_CHANGE_SET_PRINTER,
                    pSpool->pIniSpooler );

   //
   //  If necessary Start Downlevel Size Detection thread
   //

   CheckSizeDetectionThread();

   LeaveSplSem();
   SplOutSem();
   return TRUE;
}

BOOL
LocalScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId)

/*++

Routine Description:


Arguments:


Returns:

--*/
{
    PSPOOL  pSpool=(PSPOOL)hPrinter;
    WCHAR szFileName[MAX_PATH];
    PINIJOB pIniJob;
    DWORD   Position;
    DWORD   LastError = FALSE;
    HANDLE  hPort;
    BOOL    bRet;
    NOTIFYVECTOR NotifyVector;
    WIN32_FILE_ATTRIBUTE_DATA FileAttributeData;

    COPYNV(NotifyVector, NVJobStatus);

    //
    // WMI Trace Event.
    //
    LogWmiTraceEvent(JobId, EVENT_TRACE_TYPE_SPL_TRACKTHREAD, NULL);

    SplOutSem();
    EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, PRINTER_HANDLE_SERVER )) {
        LeaveSplSem();
        return (FALSE);
    }

    if (pSpool->Status & SPOOL_STATUS_STARTDOC) {
        SetLastError(ERROR_SPL_NO_ADDJOB);
        LeaveSplSem();
        return(FALSE);
    }

    if (pSpool->TypeofHandle & PRINTER_HANDLE_PORT) {
        if (pSpool->pIniPort->Status & PP_MONITOR) {
            SetLastError(ERROR_INVALID_ACCESS);
            LeaveSplSem();
            return(FALSE);
        }

        //
        // This is the "Local Printer masquerading as the Network Printer"
        //

        hPort = pSpool->hPort;
        LeaveSplSem();
        bRet = ScheduleJob(hPort, JobId);
        return(bRet);
    }

    if ((pIniJob = FindJob(pSpool->pIniPrinter, JobId, &Position)) == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        LeaveSplSem();
        return(FALSE);

    }

    if (pIniJob->Status & JOB_SCHEDULE_JOB) {

        DBGMSG(DBG_WARNING, ("ScheduleJob: job 0x%x (id = %d) already scheduled\n",
                             pIniJob, pIniJob->JobId));

        SetLastError(ERROR_INVALID_PARAMETER);
        LeaveSplSem();
        return FALSE;
    }

    if (!(pIniJob->Status & JOB_TYPE_ADDJOB)) {

        DBGMSG(DBG_WARNING, ("ScheduleJob: job 0x%x (id = %d) no addjob\n",
                             pIniJob, pIniJob->JobId));

        SetLastError(ERROR_SPL_NO_ADDJOB);
        LeaveSplSem();
        return(FALSE);
    }

    pIniJob->Status |= JOB_SCHEDULE_JOB;

    if (pIniJob->Status  & JOB_SPOOLING) {
        pIniJob->Status &= ~JOB_SPOOLING;
        pIniJob->pIniPrinter->cSpooling--;
    }

    if ( pIniJob->Status & JOB_TIMEOUT ) {
        pIniJob->Status &= ~( JOB_TIMEOUT | JOB_ABANDON );
        FreeSplStr(pIniJob->pStatus);
        pIniJob->pStatus = NULL;
    }

    SplInSem();

    // Despooling whilst spooling requires us to wake the writing
    // thread if it is waiting.

    if ( pIniJob->WaitForWrite != NULL )
        SetEvent(pIniJob->WaitForWrite);

    // Release any thread waiting on SeekPrinter for this job.

    SeekPrinterSetEvent(pIniJob, NULL, TRUE);

    SPLASSERT(pIniJob->cRef != 0);

    DECJOBREF(pIniJob);

    DBGMSG(DBG_TRACE, ("ScheduleJob:cRef = %d\n", pIniJob->cRef));

    //
    // FP Change
    // For File pools, we know the Filename of the spool file, so
    // we can just copy it in.
    //
    if ( pIniJob->pszSplFileName )
    {
        wcsncpy(szFileName, pIniJob->pszSplFileName, COUNTOF(szFileName));
    }
    else
    {
        GetFullNameFromId(pSpool->pIniPrinter, pIniJob->JobId, TRUE,
                          szFileName, FALSE);
    }

    bRet = GetFileAttributesEx(szFileName,
                               GetFileExInfoStandard,
                               &FileAttributeData);

    //
    // According to MSDN: The ScheduleJob function checks for a valid spool file. 
    // If there is an invalid spool file, or if it is empty, ScheduleJob deletes 
    // both the spool file and the corresponding print job entry in the print spooler.
    //
    // The RDR/SRV will call AddJob even if the caller of CreateFile did noy request
    // WRITE access. This will cause us at add a job, but nobody will ever write to
    // the spooler file. In this case, we delete the job. For this reason we have 
    // level 3 for AddJob. Level 3 is meant to be used only by RDR/SRV.
    //
    if (!bRet ||
        !(FileAttributeData.nFileSizeLow || FileAttributeData.nFileSizeHigh) && pIniJob->AddJobLevel == 3) {

        DBGMSG(DBG_WARNING, ("Could not GetFileAttributesEx %ws in ScheduleJob or file size is 0\n", szFileName));

        DeleteJob(pIniJob, BROADCAST);
        pSpool->pIniJob = NULL;
        pSpool->Status &= ~SPOOL_STATUS_ADDJOB;
        LeaveSplSem();

        //
        // If we deleted the job because the spool file was empty and the job came via RDR/SRV 
        // In this case we return success.
        //
        if (bRet)
        {
            return TRUE;
        }
        
        //
        // We delete the job because the spool is not found
        //
        SetLastError(ERROR_SPOOL_FILE_NOT_FOUND);
        return(FALSE);        
    }

    //
    // If size changed, we must update our size
    // and potentially notify people.
    //
    if (pIniJob->Size != FileAttributeData.nFileSizeLow) {
        ADDNV(NotifyVector, NVSpoolJob);
        pIniJob->Size = FileAttributeData.nFileSizeLow;
    }

    WriteShadowJob(pIniJob, FALSE);

    if (pIniJob->Status & JOB_PENDING_DELETION) {

        DBGMSG(DBG_TRACE, ("LocalScheduleJob: Deleting Job because its pending deletion\n"));
        DeleteJob(pIniJob, BROADCAST);

    } else {

        CHECK_SCHEDULER();

        SetPrinterChange(pIniJob->pIniPrinter,
                         pIniJob,
                         NotifyVector,
                         PRINTER_CHANGE_SET_JOB,
                         pIniJob->pIniPrinter->pIniSpooler );
    }
    pSpool->pIniJob = NULL;

    pSpool->Status &= ~SPOOL_STATUS_ADDJOB;

    LeaveSplSem();
    SplOutSem();
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\catalog.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    catalog.cxx

Abstract:

   This module provides all the public exported APIs relating to the
   catalog-based Spooler Apis for the Local Print Provider

       AddDriverCatalog
   
Author:

    Larry Zhu      (LZhu)    30-Mar-2001 Created                                         

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include "catalog.hxx"

#include <spapip.h>
#include "ssp.hxx"

/*++
    
Routine Name:

    LocalAddDriverCatalog

Routine Description:

    This routine implements the private print provider interface AddDriverCatalog.
        
Arguments:
    
    hPrinter              - This must be a server handle
    dwLevel               - DRIVER_INFCAT_INFO Level, only 1 and 2 is supported
    pvDriverInfCatInfo    - Points to a DRIVER_INFCAT_INFO_X structure
    dwCatalogCopyFlags    - Catalog file copy flags
    
Return Value:

    A BOOL               - TRUE if success; FALSE otherwise, Call GetLastError() 
                           to get the Error code 
                           
--*/
BOOL
LocalAddDriverCatalog(
    IN     HANDLE      hPrinter,
    IN     DWORD       dwLevel,
    IN     VOID        *pvDriverInfCatInfo,
    IN     DWORD       dwCatalogCopyFlags
    )
{
    HRESULT hRetval = E_FAIL;
    
    hRetval = hPrinter && pvDriverInfCatInfo ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = SplAddDriverCatalog(hPrinter,
                                      dwLevel,
                                      pvDriverInfCatInfo,
                                      dwCatalogCopyFlags) ? S_OK : GetLastErrorAsHResult();
    }

    if (FAILED(hRetval)) 
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return SUCCEEDED(hRetval);
}

/*++

Routine Name:

    SplAddDriverCatalog

Routine Description:

    This is the Spl call for AddDriverCatalog.
        
Arguments:
    
    hPrinter              - This must be a server handle
    dwLevel               - DRIVER_INFCAT_INFO Level, only 1 and 2 is supported
    pvDriverInfCatInfo    - Points to a DRIVER_INFCAT_INFO_X structure
    dwCatalogCopyFlags    - Catalog file copy flags
    
Return Value:

    A BOOL               - TRUE if success; FALSE otherwise, Call GetLastError() 
                           to get the Error code 
                           
--*/
BOOL
SplAddDriverCatalog(
    IN     HANDLE      hPrinter,
    IN     DWORD       dwLevel,
    IN     VOID        *pvDriverInfCatInfo,
    IN     DWORD       dwCatalogCopyFlags
    )
{
    HRESULT hRetval = E_FAIL;
    SPOOL   *pSpool = reinterpret_cast<SPOOL*>(hPrinter);

    DBGMSG(DBG_TRACE, ("AddDriverCatalog\n"));

    hRetval = pSpool && (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) && pvDriverInfCatInfo ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {     
        EnterSplSem();

        hRetval = ValidateSpoolHandle(pSpool, 0) ? S_OK : GetLastErrorAsHResult();

        if (SUCCEEDED(hRetval)) 
        {    
            hRetval = ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                                           SERVER_ACCESS_ADMINISTER,
                                           NULL, NULL, pSpool->pIniSpooler) ? S_OK : GetLastErrorAsHResult();    
        }
    
        if (SUCCEEDED(hRetval)) 
        {
            hRetval = InternalAddDriverCatalog(hPrinter,
                                               dwLevel,
                                               pvDriverInfCatInfo,
                                               dwCatalogCopyFlags) ? S_OK : GetLastErrorAsHResult();;
        }

        LeaveSplSem();
    }

    if (FAILED(hRetval)) 
    {
        SetLastError(HRESULT_CODE(hRetval));
    }
    
    return SUCCEEDED(hRetval);
}

/*++

Routine Name:

    CatalogAppendUniqueTag

Routine Description:

    This routine makes the scratch directory unique w.r.t process id and thread
    id that executes this function.
    
Arguments:

    cchBuffer      - size of buffer in number of chars including the NULL 
                     terminating character
    pszBuffer      - Points to the buffer
    

Return Value:
   
    An HRESULT
    
--*/
HRESULT
CatalogAppendUniqueTag(
    IN     UINT        cchBuffer,
    IN OUT PWSTR       pszBuffer
    )
{
    HRESULT hRetval = E_FAIL;
    DWORD   dwPID   = 0;
    DWORD   dwTID   = 0;
    DWORD   cchLen  = 0;

    hRetval = pszBuffer && cchBuffer ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        cchLen = wcslen(pszBuffer);
        dwPID = GetCurrentProcessId();
        dwTID = GetCurrentThreadId();

        if ((pszBuffer[cchLen - 1] != L'\\') && (cchLen + 1 < cchBuffer - 1))
        {
            pszBuffer[cchLen++] = L'\\';
            pszBuffer[cchLen]   = 0;
        }

        hRetval = cchBuffer > cchLen && _snwprintf(pszBuffer + cchLen, cchBuffer - cchLen, L"%d_%d", dwPID, dwTID) > 0 ? S_OK : HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogGetScratchDirectory
    
Routine Description:

    This routine returns the catalog scratch directory.
        
Arguments:

    hPrinter        - Server handle
    cchBuffer       - Size of buffer in number of chars including the NULL 
                      character
    pszCatalogDir   - Points to the buffer
    

Return Value:
   
    An HRESULT
    
--*/
HRESULT
CatalogGetScratchDirectory(
    IN     HANDLE      hPrinter,
    IN     UINT        cchBuffer,
       OUT PWSTR       pszCatalogDir
    )
{
    HRESULT hRetval  = E_FAIL;
    DWORD   dwNeeded = 0;

    hRetval = hPrinter && cchBuffer && pszCatalogDir ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = SplGetPrinterDriverDirectory(NULL,               // local machine
                                               LOCAL_ENVIRONMENT,
                                               1,
                                               reinterpret_cast<BYTE*>(pszCatalogDir),
                                               cchBuffer * sizeof(WCHAR),
                                               &dwNeeded,
                                               reinterpret_cast<SPOOL*>(hPrinter)->pIniSpooler) ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = CatalogAppendUniqueTag(cchBuffer, pszCatalogDir);
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogCopyFile

Routine Description:

    This routine copies the catalog file to the scratch directory.
        
Arguments:

    pszSourcePath      - Source Path
    pszDestDir         - Destination directory
    pszFileName        - File name
    
Return Value:
   
    An HRESULT
    
--*/
HRESULT
CatalogCopyFile(
    IN     PCWSTR      pszSourcePath,
    IN     PCWSTR      pszDestDir,
    IN     PCWSTR      pszFileName    
    )
{
    HRESULT hRetval          = E_FAIL;
    WCHAR   szPath[MAX_PATH] = {0};

    hRetval = pszSourcePath && pszDestDir && pszFileName ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = _snwprintf(szPath, COUNTOF(szPath), L"%s\\%s", pszDestDir, pszFileName) > 0 ? S_OK : HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE); 
    }
    
    if (SUCCEEDED(hRetval)) 
    {
        hRetval = CopyFile(pszSourcePath, szPath, FALSE) ? S_OK : GetLastErrorAsHResult();
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogCreateScratchDirectory

Routine Description:

    This routine creates the catalog scratch directory. If the scratch 
    directory already exists, this routine does nothing
        
Arguments:

    pszScratchDir       - Scratch directory 
        
Return Value:
   
    An HRESULT
    
--*/
HRESULT
CatalogCreateScratchDirectory(
    IN     PCWSTR      pszScratchDir
    )
{

    HRESULT hRetval = E_FAIL;

    hRetval = pszScratchDir ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval) && !DirectoryExists(const_cast<PWSTR>(pszScratchDir)))
    {
        hRetval = CreateDirectoryWithoutImpersonatingUser(const_cast<PWSTR>(pszScratchDir)) ? S_OK : GetLastErrorAsHResult();   
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogCleanUpScratchDirectory
       
Routine Description:

    This routine cleans up the scratch directory and it does nothing when the
    scratch directory does not exist.
        
Arguments:

    pszScratchDir - Scratch Path 
  
Return Value:
   
    An HRESULT
    
--*/
HRESULT
CatalogCleanUpScratchDirectory(
    IN     PCWSTR      pszScratchDir
    )
{
    HRESULT hRetval = E_FAIL;
    
    hRetval = pszScratchDir ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {       
        (void)DeleteAllFilesAndDirectory(const_cast<PWSTR>(pszScratchDir), 
                                         FALSE);    
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogCopyFileToDir
 
Routine Description:

    This routine copy catalog files to a directory.
            
Arguments:
    
    pszPath               - Source Path
    pszDir                - Destination directory

Return Value:

    An HRESULT
                               
--*/
CatalogCopyFileToDir(
    IN     PCWSTR      pszPath,
    IN     PCWSTR      pszDir
    )
{
    HRESULT hRetval     = E_FAIL;
    PCWSTR  pszFileName = NULL;

    hRetval = pszPath && pszDir ? S_OK : E_FAIL;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = GetFileNamePart(pszPath, &pszFileName);
    }
    
    if (SUCCEEDED(hRetval)) 
    {
        hRetval = CatalogCopyFile(pszPath, pszDir, pszFileName);
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogCopyFilesByLevel
 
Routine Description:

    This routine copy catalog files to a scratch directory.
            
Arguments:
    
    dwLevel               - DRIVER_INFCAT_INFO Level, only 1 and 2 is supported
    pvDriverInfCatInfo    - Points to a DRIVER_INFCAT_INFO_X structure
    pszScratchDirectory   - Catalog Scratch directory

Return Value:

    An HRESULT
                               
--*/
HRESULT
CatalogCopyFilesByLevel(
    IN     DWORD       dwLevel,
    IN     VOID        *pvDriverInfCatInfo,
    IN     PCWSTR      pszScratchDirectory
    )
{
    HRESULT hRetval = E_FAIL; 

    hRetval = pvDriverInfCatInfo && pszScratchDirectory? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        switch (dwLevel) 
        {
        case 1:

            hRetval = CatalogCopyFileToDir(reinterpret_cast<DRIVER_INFCAT_INFO_1*>(pvDriverInfCatInfo)->pszCatPath, 
                                           pszScratchDirectory);

            break;

        case 2:

            hRetval = CatalogCopyFileToDir(reinterpret_cast<DRIVER_INFCAT_INFO_2*>(pvDriverInfCatInfo)->pszCatPath, 
                                           pszScratchDirectory);

            if (SUCCEEDED(hRetval)) 
            {
                hRetval = CatalogCopyFileToDir(reinterpret_cast<DRIVER_INFCAT_INFO_2*>(pvDriverInfCatInfo)->pszInfPath, 
                                               pszScratchDirectory);            
            }

            break;

        default:

            hRetval = HRESULT_FROM_WIN32(ERROR_INVALID_LEVEL);

            break;
        }
    }

    return hRetval;
}

/*++

Routine Name:

    CatalogInstallLevel1
 
Routine Description:

    This routine installs driver catalog using CrypoAPI for level 1.
        
Arguments:
    
    pDriverInfCatInfo1    - Points to a DRIVER_INFCAT_INFO_1 structure
    pszScratchDirectory   - Catalog Scratch directory

Return Value:

    An HRESULT
                               
--*/
HRESULT
CatalogInstallLevel1(
    IN     DRIVER_INFCAT_INFO_1  *pDriverInfCatInfo1,
    IN     BOOL                  bUseOriginalCatName,
    IN     PCWSTR                pszCatalogScratchDirectory
    )
{
    HRESULT hRetval          = E_FAIL;
    WCHAR   szPath[MAX_PATH] = {0};
    PCWSTR  pszFileName      = NULL;
    
    TSSP    ssp;   

    hRetval = pDriverInfCatInfo1 && pszCatalogScratchDirectory ? S_OK : E_FAIL;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = ssp.IsValid();
    }

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = GetFileNamePart(pDriverInfCatInfo1->pszCatPath, &pszFileName);
    }

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = pszFileName && _snwprintf(szPath, COUNTOF(szPath), L"%s\\%s", pszCatalogScratchDirectory, pszFileName) > 0 ? S_OK : HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
    } 

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = ssp.VerifyCatalog(szPath);
    }

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = ssp.AddCatalogDirect(szPath, 
                                       bUseOriginalCatName ? pszFileName : pDriverInfCatInfo1->pszCatNameOnSystem);
    }

    return hRetval;   
}

/*++

Routine Name:

    CatalogInstallLevel2
 
Routine Description:

    This routine installs driver catalog using setup api for level 2.
        
Arguments:
    
    pDriverInfCatInfo2     - Points to a DRIVER_INFCAT_INFO_2 structure
    pszScratchDirectory   - Catalog Scratch directory

Return Value:

    An HRESULT
                               
--*/
HRESULT
CatalogInstallLevel2(
    IN     DRIVER_INFCAT_INFO_2  *pDriverInfCatInfo2,
    IN     PCWSTR                pszCatalogScratchDirectory
    )
{
    HRESULT hRetval                = E_FAIL;
    WCHAR   szPath[MAX_PATH]       = {0};
    PCWSTR  pszFileName            = NULL;
    BOOL    bIsSetupNonInteractive = TRUE; 

    hRetval = pDriverInfCatInfo2 && pszCatalogScratchDirectory ? S_OK : E_FAIL;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = GetFileNamePart(pDriverInfCatInfo2->pszInfPath, &pszFileName);
    }

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = pszFileName && _snwprintf(szPath, COUNTOF(szPath), L"%s\\%s", 
                                            pszCatalogScratchDirectory, pszFileName) > 0 ? S_OK : HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
    }
    
    if (SUCCEEDED(hRetval)) 
    {
        hRetval = CatalogCopyOEMInf(szPath, 
                                    pDriverInfCatInfo2->pszSrcLoc, 
                                    pDriverInfCatInfo2->dwMediaType, 
                                    pDriverInfCatInfo2->dwCopyStyle);
    } 

    return hRetval;   
}

/*++

Routine Name:

    CatalogCopyOEMInf
 
Routine Description:

    This routine installs driver catalog using setup api for level 2.
        
Arguments:
    
    pszInfPath            - Inf Path
    pszSrcLoc             - Source location string
    dwMediaType           - Media type, aka whether is WU/URL, or disk location
    dwCopyStyle           - SetupCopyOEMInf CopyStyle

Return Value:

    An HRESULT
                               
--*/
HRESULT
CatalogCopyOEMInf(
    IN     PCWSTR      pszInfPath,
    IN     PCWSTR      pszSrcLoc,      OPTIONAL
    IN     DWORD       dwMediaType,
    IN     DWORD       dwCopyStyle
    )
{
    HRESULT hRetval  = E_FAIL;
    HMODULE hLibrary = NULL;

    PFuncSetupCopyOEMInfW pfnSetupCopyOEMInfW = NULL;
    PFuncpSetupModifyGlobalFlags pfnpSetupModifyGlobalFlags = NULL;

    hRetval = pszInfPath ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hLibrary = LoadLibrary(L"setupapi.dll");
        hRetval = hLibrary ? S_OK : GetLastErrorAsHResult();
    }   
    
    if (SUCCEEDED(hRetval))
    {
        pfnSetupCopyOEMInfW = reinterpret_cast<PFuncSetupCopyOEMInfW>(GetProcAddress(hLibrary, "SetupCopyOEMInfW"));   
        
        hRetval = pfnSetupCopyOEMInfW ? S_OK : GetLastErrorAsHResult();
    }
    
    if (SUCCEEDED(hRetval))
    {
        pfnpSetupModifyGlobalFlags = reinterpret_cast<PFuncpSetupModifyGlobalFlags>(GetProcAddress(hLibrary, "pSetupModifyGlobalFlags"));   
        
        hRetval = pfnpSetupModifyGlobalFlags ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval)) 
    {
        //
        //  Prohibit all UIs and pSetupModifyGlobalFlags can not fail
        //
        (void)pfnpSetupModifyGlobalFlags(PSPGF_NONINTERACTIVE, PSPGF_NONINTERACTIVE);

        hRetval = pfnSetupCopyOEMInfW(pszInfPath, 
                                      pszSrcLoc, 
                                      dwMediaType, 
                                      dwCopyStyle, 
                                      NULL, 0, 0, NULL) ? S_OK : GetLastErrorAsHResult();
    }

    if (hLibrary)
    {
        (void)FreeLibrary(hLibrary);
    }
    
    return hRetval;
}

/*++

Routine Name:

    CatalogInstallByLevel
 
Routine Description:

    This routine installs driver catalog using CrypoAPI for level 1 and using
    setup api for level 2.
        
Arguments:
    
    dwLevel               - DRIVER_INFCAT_INFO Level, only 1 and 2 is supported
    pvDriverInfCatInfo    - Points to a DRIVER_INFCAT_INFO_X structure
    dwCatalogCopyFlags    - Catalog file copy flags
    pszScratchDirectory   - Catalog Scratch directory

Return Value:

    An HRESULT
                               
--*/
HRESULT
CatalogInstallByLevel(
    IN     DWORD      dwLevel,
    IN     VOID       *pvDriverInfCatInfo,
    IN     DWORD      dwCatalogCopyFlags,
    IN     PCWSTR     pszCatalogScratchDirectory
    )
{
    HRESULT hRetval = E_FAIL;

    hRetval = pvDriverInfCatInfo && pszCatalogScratchDirectory? S_OK : E_INVALIDARG;
    
    if (SUCCEEDED(hRetval)) 
    {
        switch (dwLevel) 
        {
        case 1:
    
            hRetval = CatalogInstallLevel1(reinterpret_cast<DRIVER_INFCAT_INFO_1*>(pvDriverInfCatInfo),
                                           dwCatalogCopyFlags & APDC_USE_ORIGINAL_CAT_NAME,
                                           pszCatalogScratchDirectory);

            break;
    
        case 2:
    
            hRetval = CatalogInstallLevel2(reinterpret_cast<DRIVER_INFCAT_INFO_2*>(pvDriverInfCatInfo),
                                           pszCatalogScratchDirectory);

            break;
    
        default:
    
            hRetval = HRESULT_FROM_WIN32(ERROR_INVALID_LEVEL);

            break;
        }
    }
    
    return hRetval;
} 

/*++

Routine Name:

    CatalogInstall

Routine Description:

    This routine installs driver catalog.
        
Arguments:
    
    dwLevel               - DRIVER_INFCAT_INFO Level, only 1 and 2 is supported
    pvDriverInfCatInfo    - Points to a DRIVER_INFCAT_INFO_X structure
    pszScratchDirectory   - Catalog Scratch directory
    dwCatalogCopyFlags    - Catalog file copy flags
    
Return Value:

    An HRESULT
                               
--*/
HRESULT
CatalogInstall(
    IN     DWORD       dwLevel,
    IN     VOID        *pvDriverInfCatInfo,
    IN     DWORD       dwCatalogCopyFlags,
    IN     PCWSTR      pszScratchDirectory
    )
{
    HRESULT hRetval = E_FAIL;
    HANDLE  hToken  = NULL;
    
    hRetval = pvDriverInfCatInfo && pszScratchDirectory? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        hRetval = CatalogCopyFilesByLevel(dwLevel, pvDriverInfCatInfo, pszScratchDirectory);
    }

    if (SUCCEEDED(hRetval)) 
    {
        hToken = RevertToPrinterSelf();
            
        hRetval = CatalogInstallByLevel(dwLevel, pvDriverInfCatInfo, dwCatalogCopyFlags, pszScratchDirectory);   
    }
        
    if (hToken)
    {
        (void)ImpersonatePrinterClient(hToken);
    }
    
    return hRetval;
}

/*++

Routine Name:

    InternalAddDriverCatalog
    
Routine Description:

    This routine implements the private print provider interface AddDriverCatalog.
        
Arguments:
    
    hPrinter              - This must be a server handle
    dwLevel               - DRIVER_INFCAT_INFO Level, only 1 and 2 is supported
    pvDriverInfCatInfo    - Points to a DRIVER_INFCAT_INFO_X structure
    dwCatalogCopyFlags    - Catalog file copy flags
    
Return Value:

    A BOOL                - TRUE if success; FALSE otherwise, Call GetLastError() 
                            to get the Error code 
                           
--*/
BOOL
InternalAddDriverCatalog(
    IN     HANDLE      hPrinter,
    IN     DWORD       dwLevel,
    IN     VOID        *pvDriverInfCatInfo,
    IN     DWORD       dwCatalogCopyFlags
    )
{
    HRESULT hRetval                             = E_FAIL;
    WCHAR   szCatalogScratchDirectory[MAX_PATH] = {0};
    
    hRetval = hPrinter && pvDriverInfCatInfo ? S_OK : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    //
    // When in system context, we may not have permission to read the catalog
    // file, so we copy it to a scratch directory while still in impersonation 
    // context
    //
    if (SUCCEEDED(hRetval)) 
    {
        hRetval = CatalogGetScratchDirectory(hPrinter, COUNTOF(szCatalogScratchDirectory), szCatalogScratchDirectory);
        
        if (FAILED(hRetval) && ERROR_INSUFFICIENT_BUFFER == HRESULT_CODE(hRetval)) 
        {
            hRetval = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
        } 
    }
    
    if (SUCCEEDED(hRetval)) 
    {
        hRetval = CatalogCreateScratchDirectory(szCatalogScratchDirectory);
    
        if (SUCCEEDED(hRetval)) 
        {
            hRetval = CatalogInstall(dwLevel, pvDriverInfCatInfo, dwCatalogCopyFlags, szCatalogScratchDirectory);
        }
    
        (void)CatalogCleanUpScratchDirectory(szCatalogScratchDirectory);
    }

    if (FAILED(hRetval))
    {
        SetLastError(HRESULT_CODE(hRetval));
    }

    return SUCCEEDED(hRetval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\change.c ===
/*++

Copyright (c) 1993 - 1995  Microsoft Corporation

Abstract:

    This module provides the exported API WaitForPrinterChange,
    and the support functions internal to the local spooler.

Author:

    Andrew Bell (AndrewBe) March 1993

Revision History:

--*/


#include<precomp.h>


typedef struct _NOTIFY_FIELD_TABLE {
    WORD Field;
    WORD Table;
    WORD Offset;
} NOTIFY_FIELD_TYPE, *PNOTIFY_FIELD_TYPE;

//
// Translation table from PRINTER_NOTIFY_FIELD_* to bit vector
//
NOTIFY_FIELD_TYPE NotifyFieldTypePrinter[] = {
#define DEFINE(field, x, y, table, offset) \
    { PRINTER_NOTIFY_FIELD_##field, table, OFFSETOF(INIPRINTER, offset) },
#include <ntfyprn.h>
#undef DEFINE
    { 0, 0, 0 }
};

NOTIFY_FIELD_TYPE NotifyFieldTypeJob[] = {
#define DEFINE(field, x, y, table, offset) \
    { JOB_NOTIFY_FIELD_##field, table, OFFSETOF(INIJOB, offset) },
#include <ntfyjob.h>
#undef DEFINE
    { 0, 0, 0 }
};

typedef struct _NOTIFY_RAW_DATA {
    PVOID pvData;
    DWORD dwId;
} NOTIFY_RAW_DATA, *PNOTIFY_RAW_DATA;

//
// Currently we assume that the number of PRINTER_NOTIFY_FIELD_* elements
// will fit in one DWORD vector (32 bits).  If this is ever false,
// we need to re-write this code.
//
PNOTIFY_FIELD_TYPE apNotifyFieldTypes[NOTIFY_TYPE_MAX] = {
    NotifyFieldTypePrinter,
    NotifyFieldTypeJob
};

DWORD adwNotifyFieldOffsets[NOTIFY_TYPE_MAX] = {
    I_PRINTER_END,
    I_JOB_END
};

#define NOTIFY_FIELD_TOTAL (I_PRINTER_END + I_JOB_END)


//
// Common NotifyVectors used in the system.
// NV*
//
NOTIFYVECTOR NVPrinterStatus = {
    BIT(I_PRINTER_STATUS), // | BIT(I_PRINTER_STATUS_STRING),
    BIT_NONE
};

NOTIFYVECTOR NVPrinterSD = {
    BIT(I_PRINTER_SECURITY_DESCRIPTOR),
    BIT_NONE
};

NOTIFYVECTOR NVJobStatus = {
    BIT_NONE,
    BIT(I_JOB_STATUS)
};

NOTIFYVECTOR NVJobStatusAndString = {
    BIT_NONE,
    BIT(I_JOB_STATUS) | BIT(I_JOB_STATUS_STRING)
};

NOTIFYVECTOR NVJobStatusString = {
    BIT_NONE,
    BIT(I_JOB_STATUS_STRING)
};

NOTIFYVECTOR NVPurge = {
    BIT(I_PRINTER_STATUS),
    BIT_NONE,
};

NOTIFYVECTOR NVDeletedJob = {
    BIT(I_PRINTER_CJOBS),
    BIT(I_JOB_STATUS)
};

NOTIFYVECTOR NVAddJob = {
    BIT(I_PRINTER_CJOBS),
    BIT_ALL
};

NOTIFYVECTOR NVPrinterAll = {
    BIT_ALL,
    BIT_NONE
};

NOTIFYVECTOR NVSpoolJob = {
    BIT_NONE,
    BIT(I_JOB_TOTAL_BYTES) | BIT(I_JOB_TOTAL_PAGES)
};

NOTIFYVECTOR NVWriteJob = {
    BIT_NONE,
    BIT(I_JOB_BYTES_PRINTED) | BIT(I_JOB_PAGES_PRINTED)
};

NOTIFYVECTOR NVJobPrinted = {
    BIT_NONE,
    BIT(I_JOB_BYTES_PRINTED) | BIT(I_JOB_PAGES_PRINTED) | BIT(I_JOB_STATUS)
};


//
// Forward prototypes.
//
ESTATUS
ValidateStartNotify(
    PSPOOL pSpool,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PINIPRINTER* ppIniPrinter);

BOOL
SetSpoolChange(
    PSPOOL pSpool,
    PNOTIFY_RAW_DATA pNotifyRawData,
    PDWORD pdwNotifyVectors,
    DWORD  Flags);

BOOL
SetupNotifyOptions(
    PSPOOL pSpool,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions);

VOID
NotifyInfoTypes(
    PSPOOL pSpool,
    PNOTIFY_RAW_DATA pNotifyRawData,
    PDWORD pdwNotifyVectors,
    DWORD ChangeFlags);

BOOL
RefreshBuildInfoData(
    PSPOOL pSpool,
    PPRINTER_NOTIFY_INFO pInfo,
    UINT cInfo,
    WORD Type,
    PNOTIFY_RAW_DATA pNotifyRawData);



DWORD
LocalWaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   fdwFilterFlags)

/*++

Routine Description:

    This API may be called by an application if it wants to know
    when the status of a printer or print server changes.
    Valid events to wait for are defined by the PRINTER_CHANGE_* manifests.

Arguments:

    hPrinter - A printer handle returned by OpenPrinter.
               This may correspond to either a printer or a server.

    fdwFilterFlags - One or more PRINTER_CHANGE_* values combined.
               The function will return if any of these changes occurs.

Return Value:

    Non-zero: A mask containing the change which occurred.

    Zero: Either an error occurred or the handle (hPrinter) was closed
          by another thread.  In the latter case GetLastError returns
          ERROR_INVALID_HANDLE.

    When a call is made to WaitForPrinterChange, we create an event in the
    SPOOL structure pointed to by the handle, to enable signaling between
    the thread causing the printer change and the thread waiting for it.

    When a change occurs, e.g. StartDocPrinter, the function SetPrinterChange
    is called, which traverses the linked list of handles pointed to by
    the PRINTERINI structure associated with that printer, and also any
    open handles on the server, then signals any events which it finds
    which has reuested to be informed if this change takes place.

    If there is no thread currently waiting, the change flag is maintained,
    so that later calls to WaitForPrinterChange can return immediately.
    This ensures that changes which occur between calls will not be lost.

--*/


{
    PSPOOL          pSpool = (PSPOOL)hPrinter;
    PINIPRINTER     pIniPrinter = NULL; /* Remains NULL for server */
    DWORD           rc = 0;
    DWORD           ChangeFlags = 0;
    HANDLE          ChangeEvent = 0;
    DWORD           TimeoutFlags = 0;
#if DBG
    static DWORD    Count = 0;
#endif

    DBGMSG(DBG_NOTIFY,
           ("WaitForPrinterChange( %08x, %08x )\n", hPrinter, fdwFilterFlags));

    EnterSplSem();

    switch (ValidateStartNotify(pSpool,
                                fdwFilterFlags,
                                0,
                                NULL,
                                &pIniPrinter)) {
    case STATUS_PORT:

        DBGMSG(DBG_NOTIFY, ("Port with no monitor: Calling WaitForPrinterChange\n"));
        LeaveSplSem();

        return WaitForPrinterChange(pSpool->hPort, fdwFilterFlags);

    case STATUS_FAIL:

        LeaveSplSem();
        return 0;

    case STATUS_VALID:
        break;
    }

    DBGMSG(DBG_NOTIFY, ("WaitForPrinterChange %08x on %ws:\n%d caller%s waiting\n",
                        fdwFilterFlags,
                        pIniPrinter ? pIniPrinter->pName : pSpool->pIniSpooler->pMachineName,
                        Count, Count == 1 ? "" : "s"));

    //
    // There may already have been a change since we last called:
    //
    if ((pSpool->ChangeFlags == PRINTER_CHANGE_CLOSE_PRINTER) ||
        (pSpool->ChangeFlags & fdwFilterFlags)) {

        if (pSpool->ChangeFlags == PRINTER_CHANGE_CLOSE_PRINTER)
            ChangeFlags = 0;
        else
            ChangeFlags = pSpool->ChangeFlags;

        DBGMSG(DBG_NOTIFY, ("No need to wait: Printer change %08x detected on %ws:\n%d remaining caller%s\n",
                            (ChangeFlags & fdwFilterFlags),
                            pIniPrinter ? pIniPrinter->pName : pSpool->pIniSpooler->pMachineName,
                            Count, Count == 1 ? "" : "s"));

        pSpool->ChangeFlags = 0;

        LeaveSplSem();
        return (ChangeFlags & fdwFilterFlags);
    }

    ChangeEvent = CreateEvent(NULL,
                              EVENT_RESET_AUTOMATIC,
                              EVENT_INITIAL_STATE_NOT_SIGNALED,
                              NULL);

    if ( !ChangeEvent ) {

        DBGMSG( DBG_WARNING, ("CreateEvent( ChangeEvent ) failed: Error %d\n", GetLastError()));

        LeaveSplSem();
        return 0;
    }

    DBGMSG(DBG_NOTIFY, ("ChangeEvent == %x\n", ChangeEvent));

    //
    // SetSpoolChange checks that pSpool->ChangeEvent is non-null
    // to decide whether to call SetEvent().
    //
    pSpool->WaitFlags = fdwFilterFlags;
    pSpool->ChangeEvent = ChangeEvent;
    pSpool->pChangeFlags = &ChangeFlags;
    pSpool->Status |= SPOOL_STATUS_NOTIFY;

    LeaveSplSem();


    DBGMSG( DBG_NOTIFY,
            ( "WaitForPrinterChange: Calling WaitForSingleObject( %x )\n",
              pSpool->ChangeEvent ));

    rc = WaitForSingleObject(pSpool->ChangeEvent,
                             PRINTER_CHANGE_TIMEOUT_VALUE);

    DBGMSG( DBG_NOTIFY,
            ( "WaitForPrinterChange: WaitForSingleObject( %x ) returned\n",
              pSpool->ChangeEvent ));

    EnterSplSem();

    pSpool->Status &= ~SPOOL_STATUS_NOTIFY;
    pSpool->ChangeEvent = NULL;
    pSpool->pChangeFlags = NULL;

    if (rc == WAIT_TIMEOUT) {

        DBGMSG(DBG_INFO, ("WaitForPrinterChange on %ws timed out after %d minutes\n",
                          pIniPrinter ? pIniPrinter->pName : pSpool->pIniSpooler->pMachineName,
                          (PRINTER_CHANGE_TIMEOUT_VALUE / 60000)));

        ChangeFlags |= fdwFilterFlags;
        TimeoutFlags = PRINTER_CHANGE_TIMEOUT;
    }

    if (ChangeFlags == PRINTER_CHANGE_CLOSE_PRINTER) {

        ChangeFlags = 0;
        SetLastError(ERROR_INVALID_HANDLE);
    }

    DBGMSG(DBG_NOTIFY, ("Printer change %08x detected on %ws:\n%d remaining caller%s\n",
                        ((ChangeFlags & fdwFilterFlags) | TimeoutFlags),
                        pIniPrinter ? pIniPrinter->pName : pSpool->pIniSpooler->pMachineName,
                        Count, Count == 1 ? "" : "s"));

    if (ChangeEvent && !CloseHandle(ChangeEvent)) {

        DBGMSG(DBG_WARNING, ("CloseHandle( %x ) failed: Error %d\n",
                             ChangeEvent, GetLastError()));
    }

    //
    // If the pSpool is pending deletion, we must free it here.
    //
    if (pSpool->eStatus & STATUS_PENDING_DELETION) {

        FreeSplMem(pSpool);
    }

    LeaveSplSem();

    return ((ChangeFlags & fdwFilterFlags) | TimeoutFlags);
}

BOOL
SetSpoolClosingChange(
    PSPOOL pSpool)

/*++

Routine Description:

    A print handle is closing; trigger a notification.

Arguments:

Return Value:

--*/

{
    return SetSpoolChange(pSpool,
                          NULL,
                          NULL,
                          PRINTER_CHANGE_CLOSE_PRINTER);
}

BOOL
SetSpoolChange(
    PSPOOL pSpool,
    PNOTIFY_RAW_DATA pNotifyRawData,
    PDWORD pdwNotifyVectors,
    DWORD  Flags)

/*++

Routine Description:

    Sets the event for notification or calls ReplyPrinterChangeNotification.
    This is called by SetPrinterChange for every open handle on a printer
    and the local server.

    It should also be called when an individual handle is closed.

    Assumes we're INSIDE the spooler critical section

Arguments:

    pSpool -- Specifies handle that changed.

    pIniJob -- Used if there is a watch on job information.

    pdwNotifyVectors -- Specifies what things have changed.

    Flags -- WaitForPrinterChange flags.

Return Value:

--*/

{
    DWORD  ChangeFlags;

    SplInSem();

    if( Flags == PRINTER_CHANGE_CLOSE_PRINTER ) {

        ChangeFlags = PRINTER_CHANGE_CLOSE_PRINTER;

    } else {

        ChangeFlags = ( pSpool->ChangeFlags | Flags ) & pSpool->WaitFlags;
    }

    //
    // If we have STATUS_VALID set
    // then we are using the new FFPCN code.
    //

    if ( pSpool->eStatus & STATUS_VALID ) {

        NotifyInfoTypes(pSpool,
                        pNotifyRawData,
                        pdwNotifyVectors,
                        ChangeFlags);

    }

    if ( ChangeFlags ) {

        pSpool->ChangeFlags = 0;

        if ( pSpool->pChangeFlags ) {

            *pSpool->pChangeFlags = ChangeFlags;

            DBGMSG( DBG_NOTIFY, ( "SetSpoolChange: Calling SetEvent( %x )\n", pSpool->ChangeEvent ));

            SetEvent(pSpool->ChangeEvent);

            DBGMSG( DBG_NOTIFY, ( "SetSpoolChange: SetEvent( %x ) returned\n", pSpool->ChangeEvent ));

            pSpool->pChangeFlags = NULL;
        }
    }

    return TRUE;
}


BOOL
SetPrinterChange(
    PINIPRINTER pIniPrinter,
    PINIJOB     pIniJob,
    PDWORD      pdwNotifyVectors,
    DWORD       Flags,
    PINISPOOLER pIniSpooler)

/*++

Routine Description:

    Calls SetSpoolChange for every open handle for the server
    and printer, if specified.

Arguments:

    pIniPrinter - NULL, or a valid pointer to the INIPRINTER for the printer
                  on which the change occurred.

    Flags - PRINTER_CHANGE_* constant indicating what happened.


    Note: we pass a pointer to pPrinterNotifyInfo to SetSpoolChange.
    If one call needs it, it will check this parm, then create it if
    necessary.  This way it is retrieved only once.

Return Value:

--*/

{
    NOTIFY_RAW_DATA aNotifyRawData[NOTIFY_TYPE_MAX];
    PSPOOL pSpool;
    PINIPRINTER mypIniPrinter;

    SPLASSERT( pIniSpooler->signature == ISP_SIGNATURE );

    SplInSem();

    if ( pIniSpooler->SpoolerFlags & SPL_PRINTER_CHANGES ) {

        aNotifyRawData[0].pvData = pIniPrinter;
        aNotifyRawData[0].dwId =   pIniPrinter ? pIniPrinter->dwUniqueSessionID : 0;

        aNotifyRawData[1].pvData = pIniJob;
        aNotifyRawData[1].dwId = pIniJob ? pIniJob->JobId : 0;

        if ( pIniPrinter ) {

            SPLASSERT( ( pIniPrinter->signature == IP_SIGNATURE ) &&
                       ( pIniPrinter->pIniSpooler == pIniSpooler ));

            DBGMSG(DBG_NOTIFY, ("SetPrinterChange %ws; Flags: %08x\n",
                                pIniPrinter->pName, Flags));

            for (pSpool = pIniPrinter->pSpool; pSpool; pSpool = pSpool->pNext) {

                SetSpoolChange( pSpool,
                                aNotifyRawData,
                                pdwNotifyVectors,
                                Flags );
            }

        } else {

            //  WorkStation Caching requires a time stamp change
            //  any time cached data changes

            if ( Flags & ( PRINTER_CHANGE_FORM | PRINTER_CHANGE_ADD_PRINTER_DRIVER ) ) {

                for ( mypIniPrinter = pIniSpooler->pIniPrinter;
                      mypIniPrinter != NULL ;
                      mypIniPrinter = mypIniPrinter->pNext ) {

                    UpdatePrinterIni ( mypIniPrinter, CHANGEID_ONLY );
                }
            }
        }

        if ( pSpool = pIniSpooler->pSpool ) {

            DBGMSG( DBG_NOTIFY, ("SetPrinterChange %ws; Flags: %08x\n",
                                  pIniSpooler->pMachineName, Flags));

            for ( ; pSpool; pSpool = pSpool->pNext) {

                SetSpoolChange( pSpool,
                                aNotifyRawData,
                                pdwNotifyVectors,
                                Flags );
            }
        }
    }

    return TRUE;
}


BOOL
LocalFindFirstPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    HANDLE hNotify,
    PDWORD pfdwStatus,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PVOID pvReserved1)
{
    PINIPRINTER pIniPrinter = NULL;
    PSPOOL pSpool = (PSPOOL)hPrinter;

    EnterSplSem();

    switch (ValidateStartNotify(pSpool,
                                fdwFilterFlags,
                                fdwOptions,
                                pPrinterNotifyOptions,
                                &pIniPrinter)) {
    case STATUS_PORT:

        DBGMSG(DBG_NOTIFY, ("LFFPCN: Port nomon 0x%x\n", pSpool));
        pSpool->eStatus |= STATUS_PORT;

        LeaveSplSem();

        *pfdwStatus = 0;

        return ProvidorFindFirstPrinterChangeNotification(pSpool->hPort,
                                                          fdwFilterFlags,
                                                          fdwOptions,
                                                          hNotify,
                                                          pPrinterNotifyOptions,
                                                          pvReserved1);
    case STATUS_FAIL:

        DBGMSG(DBG_WARNING, ("ValidateStartNotify failed!\n"));
        LeaveSplSem();
        return FALSE;

    case STATUS_VALID:
        break;
    }

    pSpool->eStatus = STATUS_NULL;

    if (pPrinterNotifyOptions) {

        if (!SetupNotifyOptions(pSpool, pPrinterNotifyOptions)) {

            DBGMSG(DBG_WARNING, ("SetupNotifyOptions failed!\n"));
            LeaveSplSem();

            return FALSE;
        }
    }

    //
    // Setup notification
    //
    DBGMSG(DBG_NOTIFY, ("LFFPCN: Port has monitor: Setup 0x%x\n", pSpool));

    pSpool->WaitFlags = fdwFilterFlags;
    pSpool->hNotify = hNotify;
    pSpool->eStatus |= STATUS_VALID;

    pSpool->Status |= SPOOL_STATUS_NOTIFY;

    LeaveSplSem();

    *pfdwStatus = PRINTER_NOTIFY_STATUS_ENDPOINT;

    return TRUE;
}

BOOL
LocalFindClosePrinterChangeNotification(
    HANDLE hPrinter)
{
    PSPOOL pSpool = (PSPOOL)hPrinter;
    BOOL bReturn = FALSE;

    
    if (ValidateSpoolHandle(pSpool, 0)) {
        
        EnterSplSem();

        //
        // If it's the port case (false connect) we pass the close
        // request to the right providor.
        // Otherwise, close ourselves.
        //
        if (pSpool->eStatus & STATUS_PORT) {

            DBGMSG(DBG_TRACE, ("LFCPCN: Port nomon 0x%x\n", pSpool));

            LeaveSplSem();

            bReturn = ProvidorFindClosePrinterChangeNotification(pSpool->hPort);

        } else {

            if (pSpool->eStatus & STATUS_VALID) {

                DBGMSG(DBG_TRACE, ("LFCPCN: Close notify 0x%x\n", pSpool));

                pSpool->WaitFlags = 0;
                pSpool->eStatus = STATUS_NULL;

                pSpool->Status &= ~SPOOL_STATUS_NOTIFY;

                bReturn = TRUE;

            } else {

                DBGMSG(DBG_WARNING, ("LFCPCN: Invalid handle 0x%x\n", pSpool));
                SetLastError(ERROR_INVALID_PARAMETER);
            }

            LeaveSplSem();
        }
    }

    return bReturn;
}


ESTATUS
ValidateStartNotify(
    PSPOOL pSpool,
    DWORD fdwFilterFlags,
    DWORD fdwOptions,
    PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions,
    PINIPRINTER* ppIniPrinter)

/*++

Routine Description:

    Validates the pSpool and Flags for notifications.

Arguments:

    pSpool - pSpool to validate

    fdwFilterFlags - Flags to validate

    fdwOptions - Options to validate

    pPrinterNotifyOptions

    ppIniPrinter - returned pIniPrinter; valid only STATUS_VALID

Return Value:

    EWAITSTATUS

--*/

{
    PINIPORT pIniPort;

    if (ValidateSpoolHandle(pSpool, 0)) {

        if ( pSpool->TypeofHandle & PRINTER_HANDLE_PRINTER ) {

            *ppIniPrinter = pSpool->pIniPrinter;

        } else if (pSpool->TypeofHandle & PRINTER_HANDLE_SERVER) {

            *ppIniPrinter = NULL;

        } else if ((pSpool->TypeofHandle & PRINTER_HANDLE_PORT) &&
                   (pIniPort = pSpool->pIniPort) &&
                   (pIniPort->signature == IPO_SIGNATURE) &&
                   !(pSpool->pIniPort->Status & PP_MONITOR)) {

            if (pSpool->hPort == INVALID_PORT_HANDLE) {

                DBGMSG(DBG_WARNING, ("WaitForPrinterChange called for invalid port handle.  Setting last error to %d\n",
                                     pSpool->OpenPortError));

                SetLastError(pSpool->OpenPortError);
                return STATUS_FAIL;
            }

            return STATUS_PORT;

        } else {

            DBGMSG(DBG_WARNING, ("The handle is invalid\n"));
            SetLastError(ERROR_INVALID_HANDLE);
            return STATUS_FAIL;
        }
    } else {

        *ppIniPrinter = NULL;
    }

    //
    // Allow only one wait on each handle.
    //
    if( pSpool->Status & SPOOL_STATUS_NOTIFY ) {

        DBGMSG(DBG_WARNING, ("There is already a thread waiting on this handle\n"));
        SetLastError(ERROR_ALREADY_WAITING);

        return STATUS_FAIL;
    }

    if (!(fdwFilterFlags & PRINTER_CHANGE_VALID) && !pPrinterNotifyOptions) {

        DBGMSG(DBG_WARNING, ("The wait flags specified are invalid\n"));

        SetLastError(ERROR_INVALID_PARAMETER);
        return STATUS_FAIL;
    }

    return STATUS_VALID;
}

//-------------------------------------------------------------------

VOID
GetInfoData(
    PSPOOL pSpool,
    PNOTIFY_RAW_DATA pNotifyRawData,
    PNOTIFY_FIELD_TYPE pNotifyFieldType,
    PPRINTER_NOTIFY_INFO_DATA pData,
    PBYTE* ppBuffer)

/*++

Routine Description:

    Based on the type and field, find and add the information.

Arguments:

Return Value:

--*/

{
    static LPWSTR szNULL = L"";
    DWORD cbData = 0;
    DWORD cbNeeded = 0;

    union {
        DWORD dwData;
        PDWORD pdwData;
        PWSTR pszData;
        PVOID pvData;
        PINIJOB pIniJob;
        PINIPORT pIniPort;
        PDEVMODE pDevMode;
        PSECURITY_DESCRIPTOR pSecurityDescriptor;
        PINIPRINTER pIniPrinter;

        PWSTR* ppszData;
        PINIPORT* ppIniPort;
        PINIPRINTER* ppIniPrinter;
        PINIDRIVER* ppIniDriver;
        PINIPRINTPROC* ppIniPrintProc;
        LPDEVMODE* ppDevMode;
        PSECURITY_DESCRIPTOR* ppSecurityDescriptor;
    } Var;

    Var.pvData = (PBYTE)pNotifyRawData->pvData + pNotifyFieldType->Offset;
    *ppBuffer = NULL;

    //
    // Determine space needed, and convert Data from an offset into the
    // actual data.
    //
    switch (pNotifyFieldType->Table) {
    case TABLE_JOB_POSITION:

        FindJob(Var.pIniJob->pIniPrinter,
                Var.pIniJob->JobId,
                &Var.dwData);
        goto DoDWord;

    case TABLE_JOB_STATUS:

        Var.dwData = MapJobStatus(MAP_READABLE, *Var.pdwData);
        goto DoDWord;

    case TABLE_DWORD:

        Var.dwData = *Var.pdwData;
        goto DoDWord;

    case TABLE_DEVMODE:

        Var.pDevMode = *Var.ppDevMode;

        if (Var.pDevMode) {

            cbData = Var.pDevMode->dmSize + Var.pDevMode->dmDriverExtra;

        } else {

            cbData = 0;
        }

        break;

    case TABLE_SECURITYDESCRIPTOR:

        Var.pSecurityDescriptor = *Var.ppSecurityDescriptor;
        cbData = GetSecurityDescriptorLength(Var.pSecurityDescriptor);
        break;

    case TABLE_STRING:

        Var.pszData = *Var.ppszData;
        goto DoString;

    case TABLE_TIME:

        //
        // Var already points to the SystemTime.
        //
        cbData = sizeof(SYSTEMTIME);
        break;

    case TABLE_PRINTPROC:

        Var.pszData = (*Var.ppIniPrintProc)->pName;
        goto DoString;

    case TABLE_JOB_PRINTERNAME:

        Var.pszData = (*Var.ppIniPrinter)->pName;
        goto DoString;

    case TABLE_JOB_PORT:

        Var.pIniPort = *Var.ppIniPort;

        //
        // Only if the job has been scheduled will pIniJob->pIniPort be
        // valid.  If it is NULL, then just call DoString which will
        // return a NULL string.
        //
        if (Var.pIniPort) {

            Var.pszData = Var.pIniPort->pName;
        }
        goto DoString;

    case TABLE_DRIVER:

        Var.pszData = (*Var.ppIniDriver)->pName;
        goto DoString;

    case TABLE_PRINTER_SERVERNAME:

        Var.pszData = pSpool->pFullMachineName;
        goto DoString;

    case TABLE_PRINTER_STATUS:

        Var.dwData = MapPrinterStatus(MAP_READABLE, Var.pIniPrinter->Status) |
                     Var.pIniPrinter->PortStatus;
        goto DoDWord;

    case TABLE_PRINTER_PORT:

        // Get required printer port size
        cbNeeded = 0;
        GetPrinterPorts(Var.pIniPrinter, 0, &cbNeeded);

        *ppBuffer = AllocSplMem(cbNeeded);

        if (*ppBuffer)
            GetPrinterPorts(Var.pIniPrinter, (LPWSTR) *ppBuffer, &cbNeeded);

        Var.pszData = (LPWSTR) *ppBuffer;

        goto DoString;

    case TABLE_NULLSTRING:

        Var.pszData = NULL;
        goto DoString;

    case TABLE_ZERO:

        Var.dwData = 0;
        goto DoDWord;

    default:
        SPLASSERT(FALSE);
        break;
    }

    pData->NotifyData.Data.pBuf = Var.pvData;
    pData->NotifyData.Data.cbBuf = cbData;

    return;


DoDWord:
    pData->NotifyData.adwData[0] = Var.dwData;
    pData->NotifyData.adwData[1] = 0;
    return;

DoString:
    if (Var.pszData) {

        //
        // Calculate string length.
        //
        pData->NotifyData.Data.cbBuf = (wcslen(Var.pszData)+1) *
                                        sizeof(Var.pszData[0]);

        pData->NotifyData.Data.pBuf = Var.pszData;

    } else {

        //
        // Use NULL string.
        //
        pData->NotifyData.Data.cbBuf = sizeof(Var.pszData[0]);
        pData->NotifyData.Data.pBuf  = szNULL;
    }
    return;
}





//-------------------------------------------------------------------



VOID
NotifyInfoTypes(
    PSPOOL pSpool,
    PNOTIFY_RAW_DATA pNotifyRawData,
    PDWORD pdwNotifyVectors,
    DWORD ChangeFlags)

/*++

Routine Description:

    Sends notification info (possibly with PRINTER_NOTIFY_INFO) to
    the router.

Arguments:

    pSpool -- Handle the notification is occurring on.

    pNotifyRawData -- Array of size NOTIFY_TYPE_MAX that has the
                      offset structure can be used against + id.

    pdwNotifyVectors -- Identifies what's changing (# elements
                        is also NOTIFY_TYPE_MAX).

                        NULL if no changes needed.

    ChangeFlags -- Old style change flags.

Return Value:

--*/

{
    PNOTIFY_FIELD_TYPE pNotifyFieldType;
    PRINTER_NOTIFY_INFO_DATA Data;
    PBYTE pBuffer;
    BOOL bReturn;

    DWORD i,j;
    DWORD dwMask;

    //
    // If we are not valid, OR
    //    we have no notify vectors, OR
    //    we have no RAW data OR
    //    our vectors don't match what change
    // then
    //    If no ChangeFlags return
    //    DoReply and avoid any Partials.
    //
    if (!(pSpool->eStatus & STATUS_INFO) ||
        !pdwNotifyVectors ||
        !pNotifyRawData ||
        (!(pdwNotifyVectors[0] & pSpool->adwNotifyVectors[0] ||
            pdwNotifyVectors[1] & pSpool->adwNotifyVectors[1]))) {

        if (!ChangeFlags)
            return;

        goto DoReply;
    }

    //
    // HACK: Special case NVPurge so that it causes a discard.
    // (We don't want to send all those notifications.)
    //
    if (pdwNotifyVectors == NVPurge) {

        PartialReplyPrinterChangeNotification(pSpool->hNotify, NULL);
        goto DoReply;
    }

    for (i=0; i< NOTIFY_TYPE_MAX; i++, pdwNotifyVectors++) {

        dwMask = 0x1;

        SPLASSERT(adwNotifyFieldOffsets[i] < sizeof(DWORD)*8);

        for (j=0; j< adwNotifyFieldOffsets[i]; j++, dwMask <<= 1) {

            //
            // If we have a change we are interested in,
            // PartialReply.
            //
            if (dwMask & *pdwNotifyVectors & pSpool->adwNotifyVectors[i]) {

                pNotifyFieldType = &apNotifyFieldTypes[i][j];

                GetInfoData(pSpool,
                            &pNotifyRawData[i],
                            pNotifyFieldType,
                            &Data,
                            &pBuffer);

                Data.Type = (WORD)i;
                Data.Field = pNotifyFieldType->Field;
                Data.Reserved = 0;
                Data.Id = pNotifyRawData[i].dwId;

                //
                // If the partial reply failed, then we will be refreshing
                // soon, so exit now.
                //
                bReturn = PartialReplyPrinterChangeNotification(
                              pSpool->hNotify,
                              &Data);

                if (pBuffer) {
                    FreeSplMem(pBuffer);
                }

                if (!bReturn) {

                    DBGMSG(DBG_TRACE, ("PartialReplyPCN %x failed: %d!\n",
                                       pSpool->hNotify,
                                       GetLastError()));
                    goto DoReply;
                }
            }
        }
    }

DoReply:

    //
    // A full reply is needed to kick off the notification.
    //
    ReplyPrinterChangeNotification(pSpool->hNotify,
                                   ChangeFlags,
                                   NULL,
                                   NULL);
}

BOOL
RefreshBuildInfoData(
    PSPOOL pSpool,
    PPRINTER_NOTIFY_INFO pInfo,
    UINT cInfo,
    WORD Type,
    PNOTIFY_RAW_DATA pNotifyRawData)

/*++

Routine Description:

    Sends notification info (possibly with PRINTER_NOTIFY_INFO) to
    the router.

Arguments:

    pSpool -- Handle the notification is occurring on.

    pInfo -- Array of structure to receive new info.

    cInfo -- Number of structures in array pInfo.

    Type -- Indicates type of notification: job or printer.

    pNotifyRawData -- Array of size NOTIFY_TYPE_MAX that has the
                      offset structure can be used against + id.

Return Value:

--*/

{
    PRINTER_NOTIFY_INFO_DATA Data;
    DWORD cbData;
    PNOTIFY_FIELD_TYPE pNotifyFieldType;
    PBYTE pBuffer;
    BOOL bReturn;

    DWORD j;
    DWORD dwMask;

    dwMask = 0x1;

    SPLASSERT(adwNotifyFieldOffsets[Type] < sizeof(DWORD)*8);

    for (j=0; j< adwNotifyFieldOffsets[Type]; j++, dwMask <<= 1) {

        //
        // If we have a change we are interested in,
        // add it.
        //
        if (dwMask & pSpool->adwNotifyVectors[Type]) {

            //
            // Check if we have enough space.
            //
            if (pInfo->Count >= cInfo) {
                SPLASSERT(pInfo->Count < cInfo);
                return FALSE;
            }

            pNotifyFieldType = &apNotifyFieldTypes[Type][j];

            GetInfoData(pSpool,
                        pNotifyRawData,
                        pNotifyFieldType,
                        &Data,
                        &pBuffer);

            Data.Type = Type;
            Data.Field = pNotifyFieldType->Field;
            Data.Reserved = 0;
            Data.Id = pNotifyRawData->dwId;

            bReturn = AppendPrinterNotifyInfoData(pInfo, &Data, 0);

            if (pBuffer)
                FreeSplMem(pBuffer);

            if (!bReturn) {

                DBGMSG(DBG_WARNING, ("AppendPrinterNotifyInfoData failed: %d!\n",
                                     GetLastError()));
                return FALSE;
            }
        }
    }
    return TRUE;
}


//-------------------------------------------------------------------

BOOL
SetupNotifyVector(
    PDWORD pdwNotifyVectors,
    PPRINTER_NOTIFY_OPTIONS_TYPE pType)

/*++

Routine Description:

    Setup the notification vector based on pPrinterNotifyType.
    We assume that the size of pPrinterNotifyType has been validated
    (so that it fits within the containing structure).  We only
    need to verify that the Count falls within its stated Size.

Arguments:

    pdwNotifyVectors - Structure to fill in.

    pType - Source information.

Return Value:

    TRUE = success,
    FALSE = failure.

--*/

{
    PNOTIFY_FIELD_TYPE pNotifyFieldType;
    PWORD pFields;
    DWORD i, j;
    DWORD Count;
    BOOL bReturn = FALSE;

    __try {

        if( pType ){

            Count = pType->Count;
            pFields = pType->pFields;

            if (pType->Type >= NOTIFY_TYPE_MAX) {

                DBGMSG(DBG_WARN, ("SetupNotifyVector: type %d field %d not found!\n",
                                     pType->Type, *pFields));
            } else {

                for (i=0; i < Count; i++, pFields++) {

                    if (*pFields >= adwNotifyFieldOffsets[pType->Type]) {

                        DBGMSG(DBG_WARN, ("SetupNotifyVector: type %d field %d not found!\n",
                                             pType->Type, *pFields));

                        break;
                    }

                    SPLASSERT(apNotifyFieldTypes[pType->Type][*pFields].Table != TABLE_SPECIAL);
                    SPLASSERT(apNotifyFieldTypes[pType->Type][*pFields].Field == *pFields);
                    SPLASSERT(*pFields < 32);

                    //
                    // Found index j, set this bit in our array.
                    //
                    pdwNotifyVectors[pType->Type] |= (1 << *pFields);
                }

                if( i == Count ){
                    bReturn = TRUE;
                }
            }
        }
    } __except( EXCEPTION_EXECUTE_HANDLER ){
    }


    return bReturn;
}

BOOL
SetupNotifyOptions(
    PSPOOL pSpool,
    PPRINTER_NOTIFY_OPTIONS pOptions)

/*++

Routine Description:

    Initializes pSpool->adwNotifyVectors.

Arguments:

    pSpool - Spool handle to setup the notification against.

    pOptions - Options that specify the notification.

Return Value:

    TRUE - Success, FALSE - FAILURE

    LastError set.

--*/

{
    DWORD i;
    BOOL bAccessGranted = TRUE;

    SplInSem();

    ZeroMemory(pSpool->adwNotifyVectors,
               sizeof(pSpool->adwNotifyVectors));

    //
    // Traverse Options structure.
    //
    for (i = 0; i < pOptions->Count; i++) {

        if (!SetupNotifyVector(pSpool->adwNotifyVectors,
                               &pOptions->pTypes[i])){

            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    //
    // Now check if we have sufficient privilege to setup the notification.
    //

    //
    // Check if we are looking for the security descriptor on
    // a printer.  If so, we need READ_CONTROL or ACCESS_SYSTEM_SECURITY
    // enabled.
    //
    if( pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE] &
        BIT(I_PRINTER_SECURITY_DESCRIPTOR )){

        if( !AreAnyAccessesGranted( pSpool->GrantedAccess,
                                    READ_CONTROL | ACCESS_SYSTEM_SECURITY )){
            bAccessGranted = FALSE;
        }
    }

    if( pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE] &
        ~BIT(I_PRINTER_SECURITY_DESCRIPTOR )){

        if( pSpool->TypeofHandle & PRINTER_HANDLE_SERVER ){

            //
            // There does not appear to be a check for EnumPrinters.
            //
            // This seems odd since you there is a security check on a
            // GetPrinter call, but there is none on EnumPrinters (aside
            // from enumerating share printers only for remote non-admins).
            //

        } else {

            //
            // This matches the check in SplGetPrinter: we need to
            // have PRINTER_ACCESS_USE to read the non-security information.
            //
            if( !AccessGranted( SPOOLER_OBJECT_PRINTER,
                                PRINTER_ACCESS_USE,
                                pSpool )){

                bAccessGranted = FALSE;
            }
        }
    }

    if( !bAccessGranted ){

        SetLastError( ERROR_ACCESS_DENIED );
        return FALSE;
    }

    pSpool->eStatus |= STATUS_INFO;

    return TRUE;
}

UINT
PopCount(
    DWORD dwValue)
{
    UINT i;
    UINT cPopCount = 0;

    for(i=0; i< sizeof(dwValue)*8; i++) {

        if (dwValue & (1<<i))
            cPopCount++;
    }

    return cPopCount;
}


BOOL
LocalRefreshPrinterChangeNotification(
    HANDLE hPrinter,
    DWORD dwColor,
    PPRINTER_NOTIFY_OPTIONS pOptions,
    PPRINTER_NOTIFY_INFO* ppInfo)

/*++

Routine Description:

    Refreshes data in the case of overflows.

Arguments:

Return Value:

--*/

{
    PINIJOB pIniJob;
    PINIPRINTER pIniPrinter;
    DWORD cPrinters;
    PSPOOL pSpool = (PSPOOL)hPrinter;
    PDWORD pdwNotifyVectors = pSpool->adwNotifyVectors;
    UINT cInfo = 0;
    PPRINTER_NOTIFY_INFO pInfo = NULL;
    NOTIFY_RAW_DATA NotifyRawData;

    EnterSplSem();

    if (!ValidateSpoolHandle(pSpool, 0 ) ||
        !(pSpool->eStatus & STATUS_INFO)) {

        SetLastError( ERROR_INVALID_HANDLE );
        goto Fail;
    }

    //
    // New bits added, can't compare directly against PRINTER_HANDLE_SERVER.
    //
    if( pSpool->TypeofHandle & PRINTER_HANDLE_SERVER ){

        //
        // If the call is a remote one, and the user is not an admin, then
        // we don't want to show unshared printers.
        //
        BOOL bHideUnshared = (pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_CALL)  &&
                             !(pSpool->TypeofHandle & PRINTER_HANDLE_REMOTE_ADMIN);


        for (cPrinters = 0, pIniPrinter = pSpool->pIniSpooler->pIniPrinter;
            pIniPrinter;
            pIniPrinter=pIniPrinter->pNext ) {

            if ((!(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED) &&
                 bHideUnshared)

#ifdef _HYDRA_
                || !ShowThisPrinter(pIniPrinter)
#endif
                ) {

                continue;
            }

            cPrinters++;
        }

        cInfo += PopCount(pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE]) *
                 cPrinters;

        //
        // Traverse all printers and create info.
        //
        pInfo = RouterAllocPrinterNotifyInfo(cInfo);

        if (!pInfo)
            goto Fail;

        if (pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE]) {

            for (pIniPrinter = pSpool->pIniSpooler->pIniPrinter;
                pIniPrinter;
                pIniPrinter=pIniPrinter->pNext) {

                //
                // Do not send notification for non-shared printers for remote
                // users who are not admins
                //
                if ((!(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_SHARED) &&
                     bHideUnshared )

#ifdef _HYDRA_
                    || !ShowThisPrinter(pIniPrinter)
#endif
                    ) {

                    continue;
                }



                NotifyRawData.pvData = pIniPrinter;
                NotifyRawData.dwId = pIniPrinter->dwUniqueSessionID;

                if (!RefreshBuildInfoData(pSpool,
                                          pInfo,
                                          cInfo,
                                          PRINTER_NOTIFY_TYPE,
                                          &NotifyRawData)) {

                    goto Fail;
                }
            }
        }
    } else {

        //
        // Calculate size of buffer needed.
        //
        if (pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE]) {

            //
            // Setup printer info.
            //
            cInfo += PopCount(pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE]);
        }

        if (pSpool->adwNotifyVectors[JOB_NOTIFY_TYPE]) {

            cInfo += PopCount(pSpool->adwNotifyVectors[JOB_NOTIFY_TYPE]) *
                              pSpool->pIniPrinter->cJobs;
        }

        //
        // Traverse all jobs and create info.
        //
        pInfo = RouterAllocPrinterNotifyInfo(cInfo);

        if (!pInfo)
            goto Fail;

        if (pSpool->adwNotifyVectors[PRINTER_NOTIFY_TYPE]) {

            NotifyRawData.pvData = pSpool->pIniPrinter;
            NotifyRawData.dwId = pSpool->pIniPrinter->dwUniqueSessionID;

            if (!RefreshBuildInfoData(pSpool,
                                      pInfo,
                                      cInfo,
                                      PRINTER_NOTIFY_TYPE,
                                      &NotifyRawData)) {

                goto Fail;
            }
        }

        if (pSpool->adwNotifyVectors[JOB_NOTIFY_TYPE]) {

            for (pIniJob = pSpool->pIniPrinter->pIniFirstJob;
                pIniJob;
                pIniJob = pIniJob->pIniNextJob) {

                //
                // Hide Chained Jobs
                //

                if (!(pIniJob->Status & JOB_HIDDEN )) {

                    NotifyRawData.pvData = pIniJob;
                    NotifyRawData.dwId = pIniJob->JobId;

                    if (!RefreshBuildInfoData(pSpool,
                                              pInfo,
                                              cInfo,
                                              JOB_NOTIFY_TYPE,
                                              &NotifyRawData)) {

                        goto Fail;
                    }
                }
            }
        }
    }

    SPLASSERT(cInfo >= pInfo->Count);
    LeaveSplSem();

    *ppInfo = pInfo;
    return TRUE;

Fail:

    SPLASSERT(!pInfo || cInfo >= pInfo->Count);
    LeaveSplSem();

    *ppInfo = NULL;
    if (pInfo) {
        RouterFreePrinterNotifyInfo(pInfo);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\aspapp\ipp_res.inc ===
<%
'------------------------------------------------------------
'
'   Microsoft Internet Printing Project
'
'   Copyright (c) Microsoft Corporation 1998
'
'------------------------------------------------------------


Const PROGID_CLIENT_HELPER  = "OlePrn.PrinterURL"
Const PROGID_SNMP           = "OlePrn.OleSNMP"
Const PROGID_HELPER         = "OlePrn.AspHelp"
Const PROGID_CONVERTER      = "OlePrn.OleCvt"

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\clusport.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved

Module Name:

    Downlevel cluster port support.

Abstract:

    Supports mixing and matching downlevel and uplevel language
    and monitor ports.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop


/********************************************************************

    Downlevel Port Monitor (Dp)

    Dp support is used when we have an uplevel language monitor
    and downlevel port monitor.  We pass a stub function vector
    to the LM and set the hMonitor to the downlevel pIniMonitor.

    When we get called, we can dereference the hMonitor to call the
    real downlevel monitor.

********************************************************************/


BOOL
DpEnumPorts(
    HANDLE  hMonitor,
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnEnumPorts( pName,
                                              Level,
                                              pPorts,
                                              cbBuf,
                                              pcbNeeded,
                                              pcReturned );
}

BOOL
DpOpenPort(
    HANDLE  hMonitor,
    LPWSTR  pName,
    PHANDLE pHandle
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnOpenPort( pName, pHandle );
}

BOOL
DpOpenPortEx(
    HANDLE  hMonitor,
    LPWSTR  pPortName,
    LPWSTR  pPrinterName,
    PHANDLE pHandle,
    struct _MONITOR FAR *pMonitor
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnOpenPortEx( pPortName,
                                               pPrinterName,
                                               pHandle,
                                               pMonitor );
}

BOOL
DpAddPort(
    HANDLE   hMonitor,
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pMonitorName
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnAddPort( pName,
                                            hWnd,
                                            pMonitorName );
}

BOOL
DpAddPortEx(
    HANDLE   hMonitor,
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnAddPortEx( pName,
                                              Level,
                                              pBuffer,
                                              pMonitorName );
}

BOOL
DpConfigurePort(
    HANDLE  hMonitor,
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnConfigurePort( pName,
                                                  hWnd,
                                                  pPortName );
}

BOOL
DpDeletePort(
    HANDLE  hMonitor,
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnDeletePort( pName,
                                               hWnd,
                                               pPortName );
}

BOOL
DpXcvOpenPort(
    HANDLE  hMonitor,
    LPCWSTR pszObject,
    ACCESS_MASK GrantedAccess,
    PHANDLE phXcv
    )
{
    PINIMONITOR pIniMonitor = (PINIMONITOR)hMonitor;

    return pIniMonitor->Monitor.pfnXcvOpenPort( pszObject,
                                                GrantedAccess,
                                                phXcv );
}


/********************************************************************

    Downlevel Language Monitor (Dl)

    Dl support is used when we have a downlevel language monitor
    and uplevel port monitor.

    This is very messy, since the language monitor is given the
    ports function vector directly, and we don't have any extra
    handles to pass around state information.

    Instead, we overload the name string yet again.  The port name
    is converted to:

        {NormalPortName},{pIniMonitorHex}

        LPT1:,a53588

    We then strip off the two trailing hex numbers and pass LPT1:
    back.

********************************************************************/

BOOL
GetDlPointers(
    IN LPCWSTR pszName,
    OUT LPWSTR  pszNameNew,
    OUT PINIMONITOR *ppIniMonitor,
    IN DWORD cchBufferSize
    )

/*++

Routine Description:

    Hack function to take a pszName and convert it to a new name
    string with two additional parameters: hMonitor and pMonitor2

Arguments:

    pszName - Hacked up name overloaded with pIniMonitor.

    pszNameNew - Receives "real" shorter name of the port.

    ppIniMonitor - Receives cracked pIniMonitor.

Return Value:

--*/

{
    BOOL bReturn = FALSE;
    LPCWSTR p;
    LPCWSTR p1 = NULL;

    for( p = pszName; p = wcschr( p, TEXT( ',' )); ){
        p1 = p;
        ++p;
    }

    if( p1 ){

        lstrcpyn( pszNameNew, pszName, cchBufferSize );
        pszNameNew[p1-pszName] = 0;

        ++p1;

        *ppIniMonitor = (PINIMONITOR)atox( p1 );

        __try {

            bReturn = ( (*ppIniMonitor)->signature == IMO_SIGNATURE );

        } except( EXCEPTION_EXECUTE_HANDLER ){

        }

        if( bReturn ){
            return TRUE;
        }
    }

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
CreateDlName(
    IN LPCWSTR pszName,
    IN PINIMONITOR pIniMonitor,
    OUT LPWSTR pszNameNew
    )

/*++

Routine Description:

    Create a downlevel name that can be parsed by GetDlPointers.

Arguments:

    pszName - Name of port.  The newly created name must be < MAX_PATH,
        and since we need to append one hex values (4 characters) plus
        one comma, we need to verify that the string length has at least
        5 characters left.

    pIniMonitor - Monitor structure of the uplevel port monitor.

Return Value:

    TRUE - Success

    FALSE - Failure, due to too long port name length.

--*/

{
    if( lstrlen( pszName ) >= MAX_PATH - sizeof(ULONG_PTR) -1 ){

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    wsprintf( pszNameNew,
              TEXT( "%s,%p" ),
              pszName,
              pIniMonitor );

    return TRUE;
}


FARPROC gafpMonitor2Stub[] = {
    (FARPROC) &DpEnumPorts,
    (FARPROC) &DpOpenPort,
    NULL,               // OpenPortEx
    NULL,               // StartDocPort
    NULL,               // WritePort
    NULL,               // ReadPort
    NULL,               // EndDocPort
    NULL,               // ClosePort
    (FARPROC) &DpAddPort,
    (FARPROC) &DpAddPortEx,
    (FARPROC) &DpConfigurePort,
    (FARPROC) &DpDeletePort,
    NULL,
    NULL,
    (FARPROC) &DpXcvOpenPort,
    NULL,               // XcvDataPortW
    NULL,               // XcvClosePortW
    NULL                // Shutdown
};



BOOL
DlEnumPorts(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
    )
{
    WCHAR szName[MAX_PATH];
    PINIMONITOR pIniMonitor;

    if( GetDlPointers( pName, szName, &pIniMonitor, COUNTOF(szName) )){

        return pIniMonitor->Monitor2.pfnEnumPorts( pIniMonitor->hMonitor,
                                                   szName,
                                                   Level,
                                                   pPorts,
                                                   cbBuf,
                                                   pcbNeeded,
                                                   pcReturned );
    }
    return FALSE;
}

BOOL
DlOpenPort(
    LPWSTR  pName,
    PHANDLE pHandle
    )
{
    WCHAR szName[MAX_PATH];
    PINIMONITOR pIniMonitor;

    if( GetDlPointers( pName, szName, &pIniMonitor, COUNTOF(szName) )){

        return pIniMonitor->Monitor2.pfnOpenPort( pIniMonitor->hMonitor,
                                                  szName,
                                                  pHandle );
    }
    return FALSE;
}

BOOL
DlOpenPortEx(
    LPWSTR  pPortName,
    LPWSTR  pPrinterName,
    PHANDLE pHandle,
    struct _MONITOR FAR *pMonitor
    )
{
    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
}

BOOL
DlAddPort(
    LPWSTR   pName,
    HWND     hWnd,
    LPWSTR   pMonitorName
    )
{
    WCHAR szName[MAX_PATH];
    PINIMONITOR pIniMonitor;

    if( GetDlPointers( pName, szName, &pIniMonitor, COUNTOF(szName) )){

        return pIniMonitor->Monitor2.pfnAddPort( pIniMonitor->hMonitor,
                                                 szName,
                                                 hWnd,
                                                 pMonitorName );
    }
    return FALSE;
}

BOOL
DlAddPortEx(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
    )
{
    WCHAR szName[MAX_PATH];
    PINIMONITOR pIniMonitor;

    if( GetDlPointers( pName, szName, &pIniMonitor, COUNTOF(szName) )){

        return pIniMonitor->Monitor2.pfnAddPortEx( pIniMonitor->hMonitor,
                                                   pName,
                                                   Level,
                                                   pBuffer,
                                                   pMonitorName );
    }
    return FALSE;
}

BOOL
DlConfigurePort(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
    WCHAR szName[MAX_PATH];
    PINIMONITOR pIniMonitor;

    if( GetDlPointers( pName, szName, &pIniMonitor, COUNTOF(szName) )){

        return pIniMonitor->Monitor2.pfnConfigurePort( pIniMonitor->hMonitor,
                                                       szName,
                                                       hWnd,
                                                       pPortName );
    }
    return FALSE;
}

BOOL
DlDeletePort(
    LPWSTR  pName,
    HWND    hWnd,
    LPWSTR  pPortName
    )
{
    WCHAR szName[MAX_PATH];
    PINIMONITOR pIniMonitor;

    if( GetDlPointers( pName, szName, &pIniMonitor, COUNTOF(szName) )){

        return pIniMonitor->Monitor2.pfnDeletePort( pIniMonitor->hMonitor,
                                                    szName,
                                                    hWnd,
                                                    pPortName );
    }
    return FALSE;
}

FARPROC gafpDlStub[] = {
    (FARPROC) &DlEnumPorts,
    (FARPROC) &DlOpenPort,
    (FARPROC) &DlOpenPortEx,
    NULL,               // StartDocPort
    NULL,               // WritePort
    NULL,               // ReadPort
    NULL,               // EndDocPort
    NULL,               // ClosePort
    (FARPROC) &DlAddPort,
    (FARPROC) &DlAddPortEx,
    (FARPROC) &DlConfigurePort,
    (FARPROC) &DlDeletePort,
    NULL,
    NULL,
};


VOID
InitializeUMonitor(
    PINIMONITOR pIniMonitor
    )

/*++

Routine Description:

    Initialize an uplevel port monitor for downlevel support.  When a
    downlevel language monitor is used with an uplevel port monitor,
    we need to setup stubs since the language monitor calls the port
    monitor interfaces directly.

    We create a downlevel function vector with patched entries and pass
    it to the language monitor.  The LM is passed in a formatted name
    that has both the port name and also the pIniMonitor encoded in the
    string.

Arguments:

    pIniMonitor - Monitor to initialize.

Return Value:

--*/

{
    FARPROC *pfpSrc;
    FARPROC *pfpDest;
    FARPROC *pfpStub;
    INT i;

    //
    // Create the downlevel port monitor interface.  This is
    // used when we have a downlevel language monitor with an
    // uplevel port monitor.
    //
    CopyMemory( (LPBYTE)&pIniMonitor->Monitor,
                (LPBYTE)&pIniMonitor->Monitor2.pfnEnumPorts,
                sizeof( pIniMonitor->Monitor ));

    for( i=0,
         pfpSrc = (FARPROC*)&pIniMonitor->Monitor2.pfnEnumPorts,
         pfpDest = (FARPROC*)&pIniMonitor->Monitor,
         pfpStub = gafpDlStub;

         i < sizeof( pIniMonitor->Monitor )/sizeof( *pfpDest );

         ++i, ++pfpDest, ++pfpStub, ++pfpSrc ){

        *pfpDest = *pfpStub ?
                       *pfpStub :
                       *pfpSrc;
    }
}


/********************************************************************

    Initialize a Downlevel language or port monitor.

********************************************************************/

//
// List of monitor functions for downlevel (3.51) monitors.  Instead
// of receiving a function vector, the spooler has to call GetProcAddress
// on each of these functions.  The order of these ports must be in the
// same format as the pMonitor2 structure.
//

LPCSTR aszMonitorFunction[] = {
    "EnumPortsW",
    "OpenPort",
    NULL,
    "StartDocPort",
    "WritePort",
    "ReadPort",
    "EndDocPort",
    "ClosePort",
    "AddPortW",
    "AddPortExW",
    "ConfigurePortW",
    "DeletePortW",
    NULL,
    NULL,
    "XcvOpenPortW",
    "XcvDataPortW",
    "XcvClosePortW"
};


PINIMONITOR
InitializeDMonitor(
    PINIMONITOR pIniMonitor,
    LPWSTR pszRegistryRoot
    )

/*++

Routine Description:

    Initialize downlevel monitor.

Arguments:

    pIniMonitor - Partially created pIniMonitor that needs to be initialized
        with functions.

Return Value:

    NULL - Initialization failed, but possibly because monitor could not
        initialize.  Still add monitor to spooler datastructures.

    (PINIMONITOR)-1 - Failed.

--*/

{
    BOOL        (*pfnInitialize)(LPWSTR) = NULL;
    BOOL        (*pfnInitializeMonitorEx)(LPWSTR, LPMONITOR) = NULL;
    LPMONITOREX (*pfnInitializePrintMonitor)(LPWSTR) = NULL;
    LPMONITOREX pMonEx;
    DWORD cbDpMonitor;

    PINIMONITOR pReturnValue = (PINIMONITOR)-1;

    //
    // Try calling the entry points in the following order:
    //     InitializePrintMonitor,
    //     InitializeMonitorEx,
    //     InitializeMonitor
    //
    (FARPROC)pfnInitializePrintMonitor = GetProcAddress(
                                             pIniMonitor->hModule,
                                             "InitializePrintMonitor" );
    if( !pfnInitializePrintMonitor ){

        (FARPROC)pfnInitializeMonitorEx = GetProcAddress(
                                              pIniMonitor->hModule,
                                              "InitializeMonitorEx" );

        if( !pfnInitializeMonitorEx ){

            (FARPROC)pfnInitialize = GetProcAddress(
                                         pIniMonitor->hModule,
                                         "InitializeMonitor" );
        }
    }

    if ( !pfnInitializePrintMonitor &&
         !pfnInitializeMonitorEx    &&
         !pfnInitialize ) {

        DBGMSG( DBG_WARNING,
                ( "InitializeDLPrintMonitor %ws GetProcAddress failed %d\n",
                  pszRegistryRoot,
                  GetLastError()));
    } else {

        BOOL bSuccess = FALSE;

        LeaveSplSem();

        if( pfnInitializePrintMonitor ) {

            pMonEx = (*pfnInitializePrintMonitor)(pszRegistryRoot);

            if( pMonEx ){

                bSuccess = TRUE;
                cbDpMonitor = pMonEx->dwMonitorSize;
                CopyMemory((LPBYTE)&pIniMonitor->Monitor,
                           (LPBYTE)&pMonEx->Monitor,
                           min(pMonEx->dwMonitorSize, sizeof(MONITOR)));
            }

        } else if ( pfnInitializeMonitorEx ) {

            bSuccess = (*pfnInitializeMonitorEx)( pszRegistryRoot,
                                                  &pIniMonitor->Monitor );
            cbDpMonitor = sizeof(MONITOR);

        } else {

            INT i;
            FARPROC* pfp;

            bSuccess = (BOOL)((*pfnInitialize)(pszRegistryRoot));
            cbDpMonitor = sizeof(MONITOR);

            for( i=0, pfp=(FARPROC*)&pIniMonitor->Monitor;
                i< COUNTOF( aszMonitorFunction );
                ++i, ++pfp ){

                if( aszMonitorFunction[i] ){

                    *pfp = GetProcAddress( pIniMonitor->hModule,
                                           aszMonitorFunction[i] );
                }
            }
        }

        EnterSplSem();

        if( bSuccess ){

            INT i;
            INT iMax;
            FARPROC* pfpSrc;
            FARPROC* pfpDest;
            FARPROC* pfpStub;

            //
            // Store away the pIniMonitor as the handle returned from the monitor.
            // When we call the stub, it will cast it back to a pIniMonitor then
            // use it to get to pIniMonitor->Monitor.fn.
            //
            pIniMonitor->hMonitor = (HANDLE)pIniMonitor;

            //
            // New size of the stub Monitor2 structure is the size of the
            // downlevel monitor, plus the extra DWORD for Monitor2.cbSize.
            //
            pIniMonitor->Monitor2.cbSize = min( cbDpMonitor + sizeof( DWORD ),
                                                sizeof( MONITOR2 ));

            //
            // The number of stub pointers we want to copy is the size of
            // the struct, minus the extra DWORD that we added above.
            //
            iMax = (pIniMonitor->Monitor2.cbSize - sizeof( DWORD )) / sizeof( pfpSrc );

            //
            // We have copied the monitor entrypoints into the downlevel Monitor
            // structure.  Now we must run through the uplevel vector and fill
            // it in with the stubs.
            //
            for( i=0,
                 pfpSrc = (FARPROC*)&pIniMonitor->Monitor,
                 pfpDest = (FARPROC*)&pIniMonitor->Monitor2.pfnEnumPorts,
                 pfpStub = (FARPROC*)gafpMonitor2Stub;

                 i< iMax;

                 ++i, ++pfpSrc, ++pfpDest, ++pfpStub ){

                if( *pfpSrc ){

                    //
                    // Stubs aren't needed for all routines.  Only use them
                    // when they are needed; in other cases, just use the
                    // regular one.
                    //
                    *pfpDest = *pfpStub ?
                                   *pfpStub :
                                   *pfpSrc;
                }
            }

            //
            // Success, return the original pIniMonitor.
            //
            pReturnValue = pIniMonitor;

        } else {

            DBGMSG( DBG_WARNING,
                    ( "InitializeDLPrintMonitor %ws Init failed %d\n",
                      pszRegistryRoot,
                      GetLastError()));

            //
            // Some old (before NT 4.0) monitors may not initialize until
            // reboot.
            //
            if( pfnInitialize ){
                pReturnValue = NULL;
            }
        }
    }

    return pReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\clusreg.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Cluster registry apis.

Abstract:

    Determines whether ClusterReg or Reg apis should be used.

    The printer information is stored in the registry.  When we access
    local printers, we hit the local registry; when we access cluster
    printers, we hit the cluster registry.

Author:

    Albert Ting (AlbertT) 8-Oct-96

Environment:

    User Mode -Win32

Revision History:

    Felix Maxa (amaxa) 18-Jun-2000
       Added ClusterGetResourceID
             ClusterGetResourceDriveLetter

--*/

#include "precomp.h"
#pragma hdrstop

#include <clusapi.h>
#include "clusspl.h"

enum  
{
    kDriveLetterStringSize = 3,
    kGuidStringSize        = 40
};


/********************************************************************

    Globals.

********************************************************************/

typedef struct _CLUSAPI {

    HCLUSTER
    (*pfnOpenCluster)(
        IN LPCWSTR lpszClusterName
        );

    BOOL
    (*pfnCloseCluster)(
        IN HCLUSTER hCluster
        );

    HRESOURCE
    (*pfnOpenClusterResource)(
        IN HCLUSTER hCluster,
        IN LPCWSTR lpszResourceName
        );

    BOOL
    (*pfnCloseClusterResource)(
        IN HRESOURCE hResource
        );

    HKEY 
    (*pfnGetClusterKey)(
        IN HCLUSTER hCluster, 
        IN REGSAM   samDesired  
        );

    HKEY
    (*pfnGetClusterResourceKey)(
        IN HRESOURCE hResource,
        IN REGSAM samDesired
        );

    LONG
    (*pfnClusterRegCreateKey)(
        IN HKEY hKey,
        IN LPCWSTR lpszSubKey,
        IN DWORD dwOptions,
        IN REGSAM samDesired,
        IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        OUT PHKEY phkResult,
        OUT OPTIONAL LPDWORD lpdwDisposition
        );

    LONG
    (*pfnClusterRegOpenKey)(
        IN HKEY hKey,
        IN LPCWSTR lpszSubKey,
        IN REGSAM samDesired,
        OUT PHKEY phkResult
        );

    LONG
    (*pfnClusterRegDeleteKey)(
        IN HKEY hKey,
        IN LPCWSTR lpszSubKey
        );

    LONG
    (*pfnClusterRegCloseKey)(
        IN HKEY hKey
        );

    LONG
    (*pfnClusterRegEnumKey)(
        IN HKEY hKey,
        IN DWORD dwIndex,
        OUT LPWSTR lpszName,
        IN OUT LPDWORD lpcbName,
        OUT PFILETIME lpftLastWriteTime
        );

    DWORD
    (*pfnClusterRegSetValue)(
        IN HKEY hKey,
        IN LPCWSTR lpszValueName,
        IN DWORD dwType,
        IN CONST BYTE* lpData,
        IN DWORD cbData
        );

    DWORD
    (*pfnClusterRegDeleteValue)(
        IN HKEY hKey,
        IN LPCWSTR lpszValueName
        );

    LONG
    (*pfnClusterRegQueryValue)(
        IN HKEY hKey,
        IN LPCWSTR lpszValueName,
        OUT LPDWORD lpValueType,
        OUT LPBYTE lpData,
        IN OUT LPDWORD lpcbData
        );

    DWORD
    (*pfnClusterRegEnumValue)(
        IN HKEY hKey,
        IN DWORD dwIndex,
        OUT LPWSTR lpszValueName,
        IN OUT LPDWORD lpcbValueName,
        OUT LPDWORD lpType,
        OUT LPBYTE lpData,
        IN OUT LPDWORD lpcbData
        );

    LONG
    (*pfnClusterRegQueryInfoKey)(
        HKEY hKey,
        LPDWORD lpcSubKeys,
        LPDWORD lpcbMaxSubKeyLen,
        LPDWORD lpcValues,
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime
        );

    DWORD 
    (*pfnClusterResourceControl)(
        HRESOURCE hResource,  
        HNODE     hHostNode,      
        DWORD     dwControlCode,  
        LPVOID    lpInBuffer,    
        DWORD     cbInBufferSize,  
        LPVOID    lpOutBuffer,   
        DWORD     cbOutBufferSize, 
        LPDWORD   lpcbBytesReturned  
        );

} CLUSAPI, *PCLUSAPI;

CLUSAPI ClusApi;

LPCSTR aszClusApi[] = {
    "OpenCluster",
    "CloseCluster",
    "OpenClusterResource",
    "CloseClusterResource",
    "GetClusterKey",
    "GetClusterResourceKey",
    "ClusterRegCreateKey",
    "ClusterRegOpenKey",
    "ClusterRegDeleteKey",
    "ClusterRegCloseKey",
    "ClusterRegEnumKey",
    "ClusterRegSetValue",
    "ClusterRegDeleteValue",
    "ClusterRegQueryValue",
    "ClusterRegEnumValue",
    "ClusterRegQueryInfoKey",
    "ClusterResourceControl"
};

/********************************************************************

    OpenCluster
    CloseCluster

    OpenClusterResource
    CloseClusterResource
    GetClusterResourceKey

    ClusterRegCreateKey
    ClusterRegOpenKey
    ClusterRegDeleteKey
    ClusterRegCloseKey
    ClusterRegEnumKey

    ClusterRegSetValue
    ClusterRegDeleteValue
    ClusterRegQueryValue
    ClusterRegEnumValue
    ClusterRegQueryInfoKey

********************************************************************/

BOOL
LoadClusterFunctions(
    VOID
    )

/*++

Routine Description:

    Load ClusApi functions.  Must be called before any cluster api
    is used.

Arguments:

Return Value:

    TRUE - Success

    FALSE - Fail

--*/

{
    HANDLE hLibrary;
    UINT i;
    FARPROC* pFarProc = (FARPROC*)&ClusApi;

    //
    // Size of string table and structure are identical.
    //
    SPLASSERT( COUNTOF( aszClusApi ) == sizeof( ClusApi )/sizeof( FARPROC ));

    if( ClusApi.pfnOpenCluster ){
        return TRUE;
    }

    i = SetErrorMode(SEM_FAILCRITICALERRORS);
    hLibrary = LoadLibrary( TEXT( "clusapi.dll" ));
    SetErrorMode(i);
    if( !hLibrary ){
        goto Fail;
    }

    for( i=0; i< COUNTOF( aszClusApi ); ++i, ++pFarProc) {

        *pFarProc = GetProcAddress( hLibrary, aszClusApi[i] );
        if( !*pFarProc ){

            DBGMSG( DBG_WARN,
                    ( "LoadClusterFunctions: Loading function %hs failed %d\n",
                      aszClusApi[i], GetLastError( )));
            goto Fail;
        }
    }

    return TRUE;

Fail:

    if( hLibrary ){
        FreeLibrary( hLibrary );
    }

    ClusApi.pfnOpenCluster = NULL;
    return FALSE;
}

HKEY
OpenClusterParameterKey(
    IN LPCTSTR pszResource
    )

/*++

Routine Description:

    Based on a resource string, open the cluster key with FULL access.

Arguments:

    pszResource - Name of the resource key.

Return Value:

    HKEY - Success.  Key must be closed with

    NULL - Failure.  LastError set.

--*/

{
    HCLUSTER hCluster;
    HRESOURCE hResource = NULL;
    HKEY hKeyResource = NULL;
    HKEY hKey = NULL;
    DWORD Status;
    DWORD dwDisposition;

    if( !LoadClusterFunctions( )){
        return NULL;
    }

    hCluster = ClusApi.pfnOpenCluster( NULL );

    if( !hCluster ){

        DBGMSG( DBG_WARN,
                ( "OpenClusterResourceKey: failed to open cluster %d\n",
                  GetLastError() ));
        goto Fail;
    }

    hResource = ClusApi.pfnOpenClusterResource( hCluster, pszResource );

    if( !hResource ){
        DBGMSG( DBG_WARN,
                ( "OpenClusterResourceKey: failed to open resource "TSTR" %d\n",
                  pszResource, GetLastError() ));
        goto Fail;
    }

    hKeyResource = ClusApi.pfnGetClusterResourceKey( hResource,
                                                     KEY_ALL_ACCESS );

    if( !hKeyResource ){
        DBGMSG( DBG_WARN,
                ( "OpenClusterResourceKey: failed to open resource key %d\n",
                  GetLastError() ));
        goto Fail;
    }

    

    if((Status = ClusApi.pfnClusterRegOpenKey( hKeyResource,
                                               szParameters,
                                               KEY_CREATE_SUB_KEY | KEY_ALL_ACCESS,
                                               &hKey )) == ERROR_FILE_NOT_FOUND)
    {
        Status = ClusApi.pfnClusterRegCreateKey( hKeyResource,
                                                 szParameters,
                                                 0,
                                                 KEY_ALL_ACCESS,
                                                 NULL,
                                                 &hKey,
                                                 &dwDisposition );
    }

    if( Status != ERROR_SUCCESS ){

        SetLastError( Status );
        hKey = NULL;
        DBGMSG( DBG_WARN,
                ( "OpenClusterResourceKey: failed to create resource key %d\n",
                  Status ));
    }

Fail:

    if( hKeyResource ){
        ClusApi.pfnClusterRegCloseKey( hKeyResource );
    }

    if( hResource ){
        ClusApi.pfnCloseClusterResource( hResource );
    }

    if( hCluster ){
        ClusApi.pfnCloseCluster( hCluster );
    }

    return hKey;
}


/********************************************************************

    SplReg*Key functions:

    Used for printer registry access.

********************************************************************/

LONG
SplRegCreateKey(
    IN     HKEY hKey,
    IN     LPCTSTR pszSubKey,
    IN     DWORD dwOptions,
    IN     REGSAM samDesired,
    IN     PSECURITY_ATTRIBUTES pSecurityAttributes,
       OUT PHKEY phkResult,
       OUT PDWORD pdwDisposition,
    IN     PINISPOOLER pIniSpooler OPTIONAL
    )
{
    DWORD dwDisposition;
    DWORD Status;

    if( !pdwDisposition ){
        pdwDisposition = &dwDisposition;
    }

    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG )
    {

        if( !LoadClusterFunctions( ))
        {
            return GetLastError();
        }
        

        if((Status = ClusApi.pfnClusterRegOpenKey( hKey,
                                         pszSubKey,
                                         KEY_CREATE_SUB_KEY | samDesired,
                                         phkResult)) == ERROR_FILE_NOT_FOUND)
        {
            Status = ClusApi.pfnClusterRegCreateKey( hKey,
                                                     pszSubKey,
                                                     dwOptions,
                                                     samDesired,
                                                     pSecurityAttributes,
                                                     phkResult,
                                                     &dwDisposition );
        }
    }

    else
    {
        Status = RegCreateKeyEx( hKey,
                                 pszSubKey,
                                 0,
                                 NULL,
                                 dwOptions,
                                 samDesired,
                                 pSecurityAttributes,
                                 phkResult,
                                 &dwDisposition );    
    }
    return(Status);
}

LONG
SplRegOpenKey(
    IN     HKEY hKey,
    IN     LPCTSTR pszSubKey,
    IN     REGSAM samDesired,
       OUT PHKEY phkResult,
    IN     PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegOpenKey( hKey,
                                             pszSubKey,
                                             samDesired,
                                             phkResult );
    }

    return RegOpenKeyEx( hKey,
                         pszSubKey,
                         0,
                         samDesired,
                         phkResult );
}

LONG
SplRegCloseKey(
    IN HKEY hKey,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegCloseKey( hKey );
    }

    return RegCloseKey( hKey );
}

LONG
SplRegDeleteKey(
    IN HKEY hKey,
    IN LPCTSTR pszSubKey,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegDeleteKey( hKey, pszSubKey );
    }

    return RegDeleteKey( hKey, pszSubKey );
}

LONG
SplRegEnumKey(
    IN     HKEY hKey,
    IN     DWORD dwIndex,
    IN     LPTSTR pszName,
    IN OUT PDWORD pcchName,
       OUT PFILETIME pft,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    FILETIME ft;

    if( !pft ){
        pft = &ft;
    }

    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegEnumKey( hKey,
                                             dwIndex,
                                             pszName,
                                             pcchName,
                                             pft );
    }

    return RegEnumKeyEx( hKey,
                         dwIndex,
                         pszName,
                         pcchName,
                         NULL,
                         NULL,
                         NULL,
                         pft );
}

LONG
SplRegSetValue(
    IN HKEY hKey,
    IN LPCTSTR pszValue,
    IN DWORD dwType,
    IN const BYTE* pData,
    IN DWORD cbData,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }

        //
        // ClusterRegSetValue doesn't like NULL pointers.
        //
        if( cbData == 0 ){
            pData = (PBYTE)&cbData;
        }
        return ClusApi.pfnClusterRegSetValue( hKey,
                                              pszValue,
                                              dwType,
                                              pData,
                                              cbData );
    }

    return RegSetValueEx( hKey,
                          pszValue,
                          0,
                          dwType,
                          pData,
                          cbData );
}

LONG
SplRegDeleteValue(
    IN HKEY hKey,
    IN LPCTSTR pszValue,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegDeleteValue( hKey, pszValue );
    }

    return RegDeleteValue( hKey, pszValue );
}

LONG
SplRegQueryValue(
    IN     HKEY hKey,
    IN     LPCTSTR pszValue,
       OUT PDWORD pType, OPTIONAL
       OUT PBYTE pData,
    IN OUT PDWORD pcbData,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegQueryValue( hKey,
                                                pszValue,
                                                pType,
                                                pData,
                                                pcbData );
    }

    return RegQueryValueEx( hKey,
                            pszValue,
                            NULL,
                            pType,
                            pData,
                            pcbData );
}

LONG
SplRegEnumValue(
    IN     HKEY hKey,
    IN     DWORD dwIndex,
       OUT LPTSTR pszValue,
    IN OUT PDWORD pcbValue,
       OUT PDWORD pType, OPTIONAL
       OUT PBYTE pData,
    IN OUT PDWORD pcbData,
    IN PINISPOOLER pIniSpooler OPTIONAL
    )
{
    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        return ClusApi.pfnClusterRegEnumValue( hKey,
                                               dwIndex,
                                               pszValue,
                                               pcbValue,
                                               pType,
                                               pData,
                                               pcbData );
    }

    return RegEnumValue( hKey,
                         dwIndex,
                         pszValue,
                         pcbValue,
                         NULL,
                         pType,
                         pData,
                         pcbData );
}



LONG
SplRegQueryInfoKey(
    HKEY hKey,
    PDWORD pcSubKeys,
    PDWORD pcbKey,
    PDWORD pcValues,
    PDWORD pcbValue,
    PDWORD pcbData,
    PDWORD pcbSecurityDescriptor,
    PFILETIME pftLastWriteTime,
    PINISPOOLER pIniSpooler
    )
{
    LONG rc;

    if( pIniSpooler && pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG ){

        if( !LoadClusterFunctions( )){
            return GetLastError();
        }
        rc = ClusApi.pfnClusterRegQueryInfoKey( hKey,
                                                pcSubKeys,
                                                pcbKey,
                                                pcValues,
                                                pcbValue,
                                                pcbData,
                                                pcbSecurityDescriptor,
                                                pftLastWriteTime);
    } else {

        rc = RegQueryInfoKey( hKey,           // Key
                              NULL,           // lpClass
                              NULL,           // lpcbClass
                              NULL,           // lpReserved
                              pcSubKeys,      // lpcSubKeys
                              pcbKey,         // lpcbMaxSubKeyLen
                              NULL,           // lpcbMaxClassLen
                              pcValues,       // lpcValues
                              pcbValue,       // lpcbMaxValueNameLen
                              pcbData,        // lpcbMaxValueLen
                              pcbSecurityDescriptor, // lpcbSecurityDescriptor
                              pftLastWriteTime       // lpftLastWriteTime
                              );
    }

    if( pcbValue ){
        *pcbValue = ( *pcbValue + 1 ) * sizeof(WCHAR);
    }

    return rc;
}


/*++

Routine Name:
    
    ClusterGetResourceDriveLetter
    
Routine Description:
    
    Gets the dependent disk for a cluster resource
    (a cluster spooler resource)

Arguments:
    
    pszResource            - spooler resource name
    ppszClusResDriveLetter - pointer that will get the pointer to string
                             Must be freed by caller using FreeSplMem()  
    
Return Value:
    
    Win32 error code
    
--*/
DWORD 
ClusterGetResourceDriveLetter(
    IN     LPCWSTR  pszResource, 
       OUT LPWSTR  *ppszClusResDriveLetter
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;
    
    if (pszResource && ppszClusResDriveLetter) 
    {    
        HCLUSTER    hCluster   = NULL;
        HRESOURCE   hRes       = NULL;
        LPCWSTR     pszDllName = L"resutils.dll";
        HMODULE     hModule    = NULL;
        typedef DWORD (WINAPI *PFNFINDDISK)(HCLUSTER, HRESOURCE, LPWSTR, LPDWORD); 
        PFNFINDDISK pfnFindDisk;

        //
        // Don't leave the out var uninitialized
        //
        *ppszClusResDriveLetter = NULL;

        if (LoadClusterFunctions() &&
            (hCluster    = ClusApi.pfnOpenCluster(NULL)) &&
            (hRes        = ClusApi.pfnOpenClusterResource(hCluster, pszResource)) &&
            (hModule     = LoadLibrary(pszDllName)) &&
            (pfnFindDisk = (PFNFINDDISK)GetProcAddress(hModule, "ResUtilFindDependentDiskResourceDriveLetter")))
        {
            //
            // We make a guess for how large the buffer must be. We may not have to call
            // the resutil function twice. Driver letter + colon + NULL = 3
            //
            DWORD cchDriveLetter = kDriveLetterStringSize;

            dwError = ERROR_NOT_ENOUGH_MEMORY;
                            
            if (*ppszClusResDriveLetter = AllocSplMem(cchDriveLetter * sizeof(WCHAR)))
            {
                dwError = pfnFindDisk(hCluster, hRes, *ppszClusResDriveLetter, &cchDriveLetter);
    
                //
                // Reallocate buffer if it was not sufficient
                //
                if (dwError == ERROR_MORE_DATA) 
                {
                    FreeSplMem(*ppszClusResDriveLetter);
                                    
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    
                    if (*ppszClusResDriveLetter = AllocSplMem(cchDriveLetter * sizeof(WCHAR)))
                    {
                        dwError = pfnFindDisk(hCluster, hRes, *ppszClusResDriveLetter, &cchDriveLetter);
                    }
                }
    
                if (dwError != ERROR_SUCCESS) 
                {
                    //
                    // Clean up in case of failure
                    //
                    FreeSplMem(*ppszClusResDriveLetter);
                    *ppszClusResDriveLetter = NULL;
                }                                                                                                     
            }
        }
        else
        {
            dwError = GetLastError();
        }

        if (hCluster) 
        {
            ClusApi.pfnCloseCluster(hCluster);
        }

        if (hRes)
        {   
            ClusApi.pfnCloseClusterResource(hRes);
        }

        if (hModule) 
        {
            FreeLibrary(hModule);
        }
    }
    
    DBGMSG(DBG_CLUSTER, ("ClusterGetResourceDriveLetter returns Win32 error %u\n", dwError));

    return dwError;
}

/*++

Routine Name:
    
    ClusterGetResourceID
    
Routine Description:
    
    Gets the resource id (guid) for a specified cluster resource.                             

Arguments:
    
    pszResource   - spooler resource name
    ppszClusResID - pointer that will get the pointer to string
                    Must be freed by caller using FreeSplMem()  
    
Return Value:
    
    Win32 error code
    
--*/
DWORD 
ClusterGetResourceID(
    IN  LPCWSTR  pszResource, 
    OUT LPWSTR  *ppszClusResID
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;
    
    if (pszResource && ppszClusResID) 
    {    
        HCLUSTER  hCluster = NULL;
        HRESOURCE hRes     = NULL;

        *ppszClusResID = NULL;

        if (LoadClusterFunctions() &&
           (hCluster = ClusApi.pfnOpenCluster(NULL)) &&
           (hRes     = ClusApi.pfnOpenClusterResource(hCluster, pszResource)))
        {
            //
            // The resource ID is a GUID. We make a gues for its size, maybe we
            // get around calling the function ClusterResourceControl twice.
            //
            DWORD cbIDString = kGuidStringSize * sizeof(WCHAR);

            dwError = ERROR_NOT_ENOUGH_MEMORY;
                            
            if (*ppszClusResID = AllocSplMem(cbIDString))
            {
                dwError = ClusApi.pfnClusterResourceControl(hRes, 
                                                            NULL,
                                                            CLUSCTL_RESOURCE_GET_ID,
                                                            NULL,                                               
                                                            0,
                                                            *ppszClusResID,
                                                            cbIDString,
                                                            &cbIDString);
                //
                // Reallocate buffer if it was not sufficiently large
                //
                if (dwError == ERROR_MORE_DATA) 
                {
                    FreeSplMem(*ppszClusResID);
                                    
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                            
                    if (*ppszClusResID = AllocSplMem(cbIDString ))
                    {
                        dwError = ClusApi.pfnClusterResourceControl(hRes, 
                                                                    NULL,
                                                                    CLUSCTL_RESOURCE_GET_ID,
                                                                    NULL,                                               
                                                                    0,
                                                                    *ppszClusResID,
                                                                    cbIDString,
                                                                    &cbIDString);
                    }
                }
    
                if (dwError != ERROR_SUCCESS) 
                {
                    //
                    // Clean up in case of failure
                    //
                    FreeSplMem(*ppszClusResID);
                    *ppszClusResID = NULL;
                }                                                                                                     
            }
        }
        else
        {
            dwError = GetLastError();
        }
                    
        if (hRes)
        {
            ClusApi.pfnCloseClusterResource(hRes);
        }
                    
        if (hCluster) 
        {
            ClusApi.pfnCloseCluster(hCluster);
        }       
    }
    
    DBGMSG(DBG_CLUSTER, ("ClusterGetResourceID returns Win32 error %u\n", dwError));

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\clusspl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusspl.c

Abstract:

    Cluster code support.

Author:

    Albert Ting (AlbertT) 1-Oct-96

Revision History:
    Khaled Sedky (Khaleds) 6-Jan-1996

--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"

extern PWCHAR ipszRegistryMonitors;
extern PWCHAR ipszRegistryEnvironments;
extern PWCHAR ipszRegistryEventLog;
extern PWCHAR ipszRegistryProviders;
extern PWCHAR ipszEventLogMsgFile;
extern PWCHAR ipszRegistryForms;
extern PWCHAR ipszDriversShareName;

//
// TESTING
//
//#define CLS_TEST

/********************************************************************

    Prototypes

********************************************************************/

VOID
BuildOtherNamesFromCommaList(
    LPTSTR pszCommaList,
    PINISPOOLER pIniSpooler
    );

BOOL
ReallocNameList(
    IN     LPCTSTR pszName,
    IN OUT PDWORD pdwCount,
    IN OUT LPTSTR **pppszNames
    );


DWORD
AddLongNamesToShortNames(
    PCTSTR   pszNames,
    PWSTR   *ppszLongNames
);

/********************************************************************

    SplCluster functions.

********************************************************************/


BOOL
SplClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phCluster,
    LPCTSTR pszName,
    LPCTSTR pszAddress
    )

/*++

Routine Description:

    Open a new cluster resource.

Arguments:

    pszServer - Name of the server to open--we recognize only the
        local machine (NULL, or \\server).

    pszResource - Name of resource to open.

    phCluster - Receives cluster handle.  NULL on failure.

    pszName - Name that the cluster must recognize.  Comma delimited.

    pszAddress - Address the cluster must recognize.  Comma delimited.

Return Value:

    Note: this really returns a DWORD--winsplp.h should be fixed.

    ROUTER_UNKNOWN - Unknown pszServer.
    ROUTER_SUCCESS - Successfully created.

--*/

{
    DWORD dwReturn = ROUTER_STOP_ROUTING;
    SPOOLER_INFO_2 SpoolerInfo2;
    HANDLE hSpooler = NULL;
    PCLUSTER pCluster = NULL;
    TCHAR szServer[MAX_PATH];
    PTCHAR pcMark;
    PWSTR   pszAllNames = NULL;

    *phCluster = NULL;

    if( !MyName( (LPTSTR)pszServer, pLocalIniSpooler )){
        return ROUTER_UNKNOWN;
    }

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pLocalIniSpooler )) {

        return ROUTER_STOP_ROUTING;
    }

    //
    // Create the spooler.
    //
    if(!pszName)
    {
         return ERROR_INVALID_PARAMETER;
    }

    szServer[0] = szServer[1] = TEXT( '\\' );
    lstrcpyn( &szServer[2], pszName, COUNTOF( szServer ) - 2 );

    //
    // Nuke trailing comma if we have one (we might have multiple names).
    //
    pcMark = wcschr( szServer, TEXT( ',' ));
    if( pcMark ){
        *pcMark = 0;
    }

    // Add in the DNS names for all the provided Server names
    if (AddLongNamesToShortNames(pszName, &pszAllNames) != ERROR_SUCCESS) {
        DBGMSG( DBG_WARN, ( "SplClusterSplOpen: SplCreateSpooler failed %d\n", GetLastError( )));
        goto Done;
    }

    //
    // Open the resource dll for parameter information: pDir.
    //

#ifdef CLS_TEST
    SpoolerInfo2.pszRegistryRoot = L"Software\\Cluster";
    SpoolerInfo2.pszRegistryPrinters = L"Software\\Cluster\\Printers";
#endif

    //
    // In Granite, we needed to create a share path \\GroupName\print$ instead
    // of just print$, since we needed to use the GroupName, not the
    // NodeName since clients would have to reauthenticate (it's the same
    // physical machine, but it's a different name).  However, in NT 5.0,
    // we always use the name that the user passed in so we're ok.
    //
    SpoolerInfo2.pszDriversShare         = ipszDriversShareName;

    SpoolerInfo2.pDir                    = NULL;
    SpoolerInfo2.pDefaultSpoolDir        = NULL;

    SpoolerInfo2.pszRegistryMonitors     = ipszRegistryMonitors;
    SpoolerInfo2.pszRegistryEnvironments = ipszRegistryEnvironments;
    SpoolerInfo2.pszRegistryEventLog     = ipszRegistryEventLog;
    SpoolerInfo2.pszRegistryProviders    = ipszRegistryProviders;
    SpoolerInfo2.pszEventLogMsgFile      = ipszEventLogMsgFile;
    SpoolerInfo2.pszRegistryForms        = ipszRegistryForms;

    SpoolerInfo2.pszResource = (LPTSTR)pszResource;
    SpoolerInfo2.pszName     = (LPTSTR)pszAllNames;
    SpoolerInfo2.pszAddress  = (LPTSTR)pszAddress;

    SpoolerInfo2.pszEventLogMsgFile = L"%SystemRoot%\\System32\\LocalSpl.dll";
    SpoolerInfo2.SpoolerFlags = SPL_PRINTER_CHANGES                       |
                                SPL_LOG_EVENTS                            |
                                SPL_SECURITY_CHECK                        |
                                SPL_OPEN_CREATE_PORTS                     |
                                SPL_FAIL_OPEN_PRINTERS_PENDING_DELETION   |
                                SPL_REMOTE_HANDLE_CHECK                   |
                                SPL_PRINTER_DRIVER_EVENT                  |
                                SPL_SERVER_THREAD                         |
                                SPL_PRINT                                 |
#ifndef CLS_TEST
                                SPL_CLUSTER_REG                           |
#endif
                                SPL_TYPE_CLUSTER                          |
                                SPL_TYPE_LOCAL;

    SpoolerInfo2.pfnReadRegistryExtra    = NULL;
    SpoolerInfo2.pfnWriteRegistryExtra   = NULL;

    DBGMSG( DBG_TRACE,
            ( "SplClusterSplOpen: Called "TSTR", "TSTR", "TSTR"\n",
              pszResource, pszName, pszAddress ));

    hSpooler = SplCreateSpooler( szServer,
                                 2,
                                 (LPBYTE)&SpoolerInfo2,
                                 NULL );

    if( hSpooler == INVALID_HANDLE_VALUE ){

        DBGMSG( DBG_WARN,
                ( "SplClusterSplOpen: SplCreateSpooler failed %d\n",
                  GetLastError( )));

        goto Done;
    }

    pCluster = (PCLUSTER)AllocSplMem( sizeof( CLUSTER ));

    if( pCluster ){

        pCluster->signature = CLS_SIGNATURE;
        pCluster->hSpooler = hSpooler;

        *phCluster = (HANDLE)pCluster;
        dwReturn = ROUTER_SUCCESS;
    }

    //
    // Reshareout the printers.
    //
    FinalInitAfterRouterInitComplete(
        0,
        (PINISPOOLER)hSpooler
        );

    CHECK_SCHEDULER();

Done:

    //
    // On failure, cleanup everything.
    //

    FreeSplMem(pszAllNames);

    if( dwReturn != ROUTER_SUCCESS ){

        if( hSpooler && hSpooler != INVALID_HANDLE_VALUE ){

            ShutdownSpooler( hSpooler );
        }
        FreeSplMem( *phCluster );
    }

    return dwReturn;
}

BOOL
SplClusterSplClose(
    HANDLE hCluster
    )

/*++

Routine Description:

    Shut down a cluster.

Arguments:

    hCluster - Cluster to close.

Return Value:

    TRUE - Success

    FALSE - Failed, LastError set.

--*/

{
    BOOL bStatus;
    PCLUSTER pCluster = (PCLUSTER)hCluster;

    DBGMSG( DBG_TRACE, ( "SplClusterSplClose: Called close\n" ));

    //
    // Close the spooler
    //

    DBGMSG( DBG_TRACE, ( "SplClusterSplClose: close %x\n", hCluster ));

    SPLASSERT( pCluster->signature == CLS_SIGNATURE );

    if ( !ValidateObjectAccess(SPOOLER_OBJECT_SERVER,
                               SERVER_ACCESS_ADMINISTER,
                               NULL, NULL, pCluster->hSpooler )) {

        return ROUTER_STOP_ROUTING;
    }

    ShutdownSpooler( pCluster->hSpooler );

    //
    // Atttempt to delete the spooler.  This is reference counted so
    // it may take a while to complete.  We do this before we close the
    // spooler, because deleting the spooler requires a reference
    // to it.  Once we close the handle, we don't have access to it.
    // (It may be deleted during the close call if it was the last
    // reference and it was marked pending deletion).
    //
    EnterSplSem();
    SplDeleteSpooler( pCluster->hSpooler );
    LeaveSplSem();

    SplCloseSpooler( pCluster->hSpooler );

    FreeSplMem( hCluster );

    return TRUE;
}

BOOL
SplClusterSplIsAlive(
    HANDLE hCluster
    )
{
    DBGMSG( DBG_TRACE, ( "SplClusterSplIsAlive: Called IsAlive\n" ));

    EnterSplSem();
    LeaveSplSem();

    return TRUE;
}



/********************************************************************

    Internal support routines.

********************************************************************/


BOOL
ShutdownSpooler(
    HANDLE hSpooler
    )

/*++

Routine Description:

    Cleanly shuts down a PINISPOOLER

Arguments:

    hSpooler - Spooler to shut down.

Return Value:

--*/


{
    PINISPOOLER pIniSpooler = (PINISPOOLER)hSpooler;
    PINISPOOLER pCurrentIniSpooler;
    PINIPRINTER pIniPrinter;
    PINIPRINTER pIniPrinterNext;
    HANDLE hEvent;
    BOOL bStatus = FALSE;
    PSPOOL pSpool;
    PINIPORT pIniPort;

    SPLASSERT( hSpooler );
    DBGMSG( DBG_TRACE, ( "ShutdownSpooler: called %x\n", hSpooler ));

    EnterSplSem();

    //
    // First set the spooler offline so no more jobs get scheduled.
    //
    pIniSpooler->SpoolerFlags |= SPL_OFFLINE;

    //
    // If there are jobs printing, wait until they are completed.
    //
    if( pIniSpooler->cFullPrintingJobs ){

        hEvent = CreateEvent( NULL,
                              EVENT_RESET_AUTOMATIC,
                              EVENT_INITIAL_STATE_NOT_SIGNALED,
                              NULL );

        if( !hEvent ){
            pIniSpooler->SpoolerFlags &= ~SPL_OFFLINE;
            goto DoneLeave;
        }

        pIniSpooler->hEventNoPrintingJobs = hEvent;

        LeaveSplSem();
        WaitForSingleObject( hEvent, pIniSpooler->dwJobCompletionTimeout );
        EnterSplSem();
    }

    //
    // No printing jobs anymore.  Disable updating shadow job/printer
    // updates and stop logging/notifications.
    //
    pIniSpooler->SpoolerFlags |= SPL_NO_UPDATE_JOBSHD |
                                 SPL_NO_UPDATE_PRINTERINI;
    pIniSpooler->SpoolerFlags &= ~( SPL_LOG_EVENTS |
                                    SPL_PRINTER_CHANGES );

    //
    // Zombie all spool handles.
    //
    for( pSpool = pIniSpooler->pSpool; pSpool; pSpool = pSpool->pNext ){
        pSpool->Status |= SPOOL_STATUS_ZOMBIE;

        //
        // !! LATER !!
        //
        // Close notifications so that the client refreshes.
        //
    }

    for( pIniPrinter = pIniSpooler->pIniPrinter;
         pIniPrinter;
         pIniPrinter = pIniPrinterNext ){

        //
        // Purge and delete all printers.  This will clean up the memory
        // but leave everything intact since we've requested that the
        // changes aren't persistant (SPL_NO_UPDATE flags).
        //

        pIniPrinter->cRef++;
        PurgePrinter( pIniPrinter );
        SPLASSERT( pIniPrinter->cRef );
        pIniPrinter->cRef--;
        pIniPrinterNext = pIniPrinter->pNext;

        InternalDeletePrinter( pIniPrinter );
    }

    //
    // Even if a job was paused, the purge printer will have deleted
    // it.  Since we set SPL_NO_UPDATE_JOBSHD this job will get restarted
    // on the other node.
    //
    // We still want to wait until this job finshes, however, otherwise
    // the port will be in a bad state.
    //
    if( pIniSpooler->cFullPrintingJobs ){

        LeaveSplSem();
        WaitForSingleObject( pIniSpooler->hEventNoPrintingJobs, INFINITE );
        EnterSplSem();
    }

    for( pIniPrinter = pIniSpooler->pIniPrinter;
         pIniPrinter;
         pIniPrinter = pIniPrinterNext ){

        //
        // Zombie print handles.
        //
        for( pSpool = pIniPrinter->pSpool; pSpool; pSpool = pSpool->pNext ){
            pSpool->Status |= SPOOL_STATUS_ZOMBIE;

            //
            // !! LATER !!
            //
            // Close notifications so that the client refreshes.
            //
        }
    }


    if( pIniSpooler->hEventNoPrintingJobs ){

        CloseHandle( pIniSpooler->hEventNoPrintingJobs );
        pIniSpooler->hEventNoPrintingJobs = NULL;
    }

    //
    // N.B. Spooling jobs get nuked when the rundown occurs.
    //

    //
    // Leave it linked on the spooler.  When there are no more jobs, the
    // port thread relies on the scheduler thread to kill it, so we
    // can't remove the pIniSpooler from the master list.
    //
    bStatus = TRUE;

DoneLeave:

    LeaveSplSem();

    return bStatus;
}


PINISPOOLER
FindSpooler(
    LPCTSTR pszMachine,
    DWORD SpoolerFlags
    )

/*++

Routine Description:

    Look for a spooler based on machine name and type.

Arguments:

    pszMachineName - "\\Machine" formatted string.

    SpoolerFlags - The spooler matches only if it has at least one
        of the SPL_TYPE bits on specified by SpoolerFlags.

Return Value:

    PINISPOOLER - Match.

    NULL - no Match.

--*/

{
    PINISPOOLER pIniSpooler;

    if( !pszMachine ){
        return NULL;
    }

    SplInSem();

    //
    // Search clustered spoolers first, since we don't want to
    // since using the tcpip address will match pLocalIniSpooler.
    //
    for( pIniSpooler = pLocalIniSpooler->pIniNextSpooler;
         pIniSpooler;
         pIniSpooler = pIniSpooler->pIniNextSpooler ){

        //
        // Verify flags and ensure not pending deletion.
        //
        if( (pIniSpooler->SpoolerFlags & SpoolerFlags & SPL_TYPE ) &&
            !(pIniSpooler->SpoolerFlags & SPL_PENDING_DELETION )){

            //
            // Verify the name.
            //
            if( MyName( (LPTSTR)pszMachine, pIniSpooler )){
                break;
            }
        }
    }

    //
    // Check Localspl.
    //
    //
    // Verify flags.
    //
    if( !pIniSpooler && pLocalIniSpooler &&
        ( pLocalIniSpooler->SpoolerFlags & SpoolerFlags & SPL_TYPE )){

        //
        // Verify the name.
        //
        if( MyName( (LPTSTR)pszMachine, pLocalIniSpooler )){
            pIniSpooler = pLocalIniSpooler;
        }
    }

    return pIniSpooler;
}

BOOL
InitializeShared(
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Initialize the shared component of the pIniSpooler.

    When a SPL_TYPE_LOCAL printer is created, we use the shared
    resources from the pLocalIniSpooler.  However, this is not
    reference counted.  When pLocalIniSpooler is deleted, the
    shared resources are too.

Arguments:

    pIniSpooler - Object->pShared to initialize.

Return Value:

    TRUE - Success

    FALSE - Failed, LastError set.

--*/

{
    SPLASSERT( pIniSpooler->SpoolerFlags );

    //
    // If it's SPL_TYPE_LOCAL, it should use the shared resources, unless
    // this is the first one and we haven't set them up yet.
    //
    if(( pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ) && pLocalIniSpooler ){

        //
        // Use the shared one.
        //
        pIniSpooler->pShared = pLocalIniSpooler->pShared;

    } else {

       PSHARED pShared = (PSHARED)AllocSplMem( sizeof( SHARED ));

       if( !pShared ){
           return FALSE;
       }

       pIniSpooler->pShared = pShared;
    }

    return TRUE;
}

VOID
DeleteShared(
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Cleanup after the InitializeShared call.

    Note: pShared is not a reference counted structure.  If it is not
    shared, then we immediately free it.  If it is shared, we assume
    that it's owned by pLocalIniSpooler only.  Also, this implies that
    pLocalIniSpooler is always deleted last.

Arguments:

    pIniSpooler - Object->pShared to Cleanup.

Return Value:

--*/

{
    //
    // Free if it's not shared.
    //
    if( pIniSpooler == pLocalIniSpooler ||
        !(pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL )){

        FreeSplMem( pIniSpooler->pShared );
        pIniSpooler->pShared = NULL;
    }
}

VOID
ShutdownMonitors(
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Shutdown all the monitors and free pIniMonitor functions.

Arguments:

    pIniSpooler - Spooler to shut down.

Return Value:

--*/

{
    PINIMONITOR pIniMonitor;
    PINIMONITOR pIniMonitorNext;
    PINIPORT pIniPort;
    PINIPORT pIniPortNext;

    SplInSem();

    //
    // Every monitor must have a shutdown function.  They must only mark
    // themselves pending deletion--they must not wait for resources to
    // close.
    //
    for( pIniMonitor = pIniSpooler->pIniMonitor;
         pIniMonitor;
         pIniMonitor = pIniMonitorNext ){

        pIniMonitorNext = pIniMonitor->pNext;

        LeaveSplSem();
        SplOutSem();

        DBGMSG( DBG_TRACE,
                ( "ShutdownMonitors: closing %x %x on %x\n",
                  pIniMonitor, pIniMonitor->hMonitor, pIniSpooler ));

        (*pIniMonitor->Monitor2.pfnShutdown)( pIniMonitor->hMonitor );

        EnterSplSem();
    }
}

PINISPOOLER
FindSpoolerByNameIncRef(
    LPTSTR pName,
    LPCTSTR *ppszLocalName OPTIONAL
    )

/*++

Routine Description:

    Searches for a spooler by name and increments the refcount if one
    is found.

    NOTE: The callee is responsible for calling FindSpoolerByNameDecRef()
    if the retur nvalue is non-NULL.

Arguments:

    pName - Name to search on.

    ppszLocalName - Returns local name (optional).

Return Value:

    PINISPOOLER - IncRef'd pIniSpooler
    NULL

--*/

{
    PINISPOOLER pIniSpooler;

    EnterSplSem();

    pIniSpooler = FindSpoolerByName( pName, ppszLocalName );
    if( pIniSpooler ){
        INCSPOOLERREF( pIniSpooler );
    }

    LeaveSplSem();

    return pIniSpooler;
}

VOID
FindSpoolerByNameDecRef(
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Matching call to FindSpoolerByNameIncRef.

Arguments:

    pIniSpooler - Spooler to derement; can be NULL.

Return Value:

--*/

{
    EnterSplSem();

    if( pIniSpooler ){
        DECSPOOLERREF( pIniSpooler );
    }
    LeaveSplSem();
}


PINISPOOLER
FindSpoolerByName(
    LPTSTR pszName,
    LPCTSTR *ppszLocalName OPTIONAL
    )

/*++

Routine Description:

    Search for the right pIniSpooler based on name.

Arguments:

    pszName - Name, either a server or printer.  This string is
        modified then restored.

    ppszLocalName - Optional; receives local name of the printer.
        If pszName is a remote name (e.g., "\\server\Printer"),
        then *ppszLocalName receives the local name (e.g., "Printer").
        This is a pointer into pszName.  If pszName is a local name,
        then ppszLocalName points to pszName.

Return Value:

    PINISPOOLER pIniSpooler found.
    NULL not found.

--*/

{
    PINISPOOLER pIniSpooler = NULL;
    PTCHAR pcMark = NULL;

    SplInSem();

    if( ppszLocalName ){
        *ppszLocalName = pszName;
    }

    //
    // Search for right spooler.
    //
    if( !pszName ){
        return pLocalIniSpooler;
    }


    //
    // If it's in the format \\server\printer or \\server,
    // then we need to look for various spoolers.  If it doesn't
    // start with \\, then it's always on the local machine.
    //
    if( pszName[0] == L'\\' &&
        pszName[1] == L'\\' ){

        if( pcMark = wcschr( &pszName[2], L'\\' )){
            *pcMark = 0;
        }

        EnterSplSem();
        pIniSpooler = FindSpooler( pszName, SPL_TYPE_LOCAL );
        LeaveSplSem();

        if( pcMark ){
            *pcMark = L'\\';

            if( ppszLocalName ){
                *ppszLocalName = pcMark + 1;
            }
        }

    } else {

        pIniSpooler = pLocalIniSpooler;
    }

    return pIniSpooler;
}


VOID
BuildOtherNamesFromSpoolerInfo2(
    PSPOOLER_INFO_2 pSpoolerInfo2,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    This routine builds list of names other than the machine name and
    stores them in the alternate names.

    !! LATER !!

    Make it recognize multiple names.

Arguments:

    pSpoolerInfo2 - Source of alternate names.

    pIniSpooler - Spooler to update.  The current name arrays are assumed
        to be NULL.

Return Value:

--*/

{
    LPTSTR pszName = NULL;
    LPTSTR pszAddress = NULL;

    SPLASSERT( pIniSpooler->cOtherNames == 0 );
    SPLASSERT( !pIniSpooler->ppszOtherNames );

    BuildOtherNamesFromCommaList( pSpoolerInfo2->pszName, pIniSpooler );
    BuildOtherNamesFromCommaList( pSpoolerInfo2->pszAddress, pIniSpooler );
}

VOID
BuildOtherNamesFromCommaList(
    LPTSTR pszCommaList,
    PINISPOOLER pIniSpooler
    )

/*++

Routine Description:

    Add to the list of other names from a comma delimited list.

Arguments:

    pszCommaList - List of names to add.  This string is modifed and
        restored.

    pIniSpooler - Spooler to modify.

Return Value:

--*/

{
    UINT cchLen;
    LPTSTR pcMark;

    while( pszCommaList && *pszCommaList ){

        //
        // Skip commas.
        //
        if( *pszCommaList == TEXT( ',' )){
            ++pszCommaList;
            continue;
        }

        //
        // We have a name.  Search for comma.
        //
        pcMark = wcschr( pszCommaList, TEXT( ',' ));

        //
        // If we found a comma, then delimit it.  Note that we're changing
        // the input buffer, but we'll restore it later.  Can have bad
        // effects if the buffer is not writable or accessed by other threads.
        //
        if( pcMark ){
            *pcMark = 0;
        }

        ReallocNameList( pszCommaList,
                         &pIniSpooler->cOtherNames,
                         &pIniSpooler->ppszOtherNames );

        if( pcMark ){
            *pcMark = TEXT( ',' );
            ++pcMark;
        }

        //
        // Skip past this name.
        //
        pszCommaList = pcMark;
    }
}

BOOL
ReallocNameList(
    IN     LPCTSTR pszName,
    IN OUT PDWORD pdwCount,
    IN OUT LPTSTR **pppszNames
    )

/*++

Routine Description:

    Adds new name to vector of strings.

Arguments:

    pszName - New name to add.

    pdwCount - Count of names.  On successful exit, incremented by 1.

    pppszNames - Pointer to address of string vector.  This is freed and
        reallocated to hold a new name.

Return Value:

    TRUE - Success.  *pdwCount and *pppszNames updated.

    FALSE - Failed.  Nothing changd.

--*/

{
    LPTSTR pszNameBuf = AllocSplStr( (LPTSTR)pszName );
    LPTSTR *ppszNamesBuf = AllocSplMem(( *pdwCount + 1 ) * sizeof( LPTSTR ));

    if( !pszNameBuf || !ppszNamesBuf ){
        goto Fail;
    }

    //
    // Copy the name and existing pointers.
    //
    lstrcpy( pszNameBuf, pszName );
    CopyMemory( ppszNamesBuf, *pppszNames, *pdwCount * sizeof( LPTSTR ));

    //
    // Update the vector and increment the count.
    //
    ppszNamesBuf[ *pdwCount ] = pszNameBuf;
    ++(*pdwCount);

    //
    // Free the old pointer buffer and use the new one.
    //
    FreeSplMem( *pppszNames );
    *pppszNames = ppszNamesBuf;

    return TRUE;

Fail:

    FreeSplStr( pszNameBuf );
    FreeSplMem( ppszNamesBuf );

    return FALSE;
}

LPTSTR
pszGetPrinterName(
    PINIPRINTER pIniPrinter,
    BOOL bFull,
    LPCTSTR pszToken OPTIONAL
    )
{
    INT cchLen;
    LPTSTR pszPrinterName;

    cchLen = lstrlen( pIniPrinter->pName ) +
             lstrlen( pIniPrinter->pIniSpooler->pMachineName ) + 2;

    if( pszToken ){

        cchLen += lstrlen( pszToken ) + 1;
    }

    pszPrinterName = AllocSplMem( cchLen * sizeof( pszPrinterName[0] ));

    if( pszPrinterName ){

        if( pszToken ){

            if( bFull ){
                wsprintf( pszPrinterName,
                          L"%s\\%s,%s",
                          pIniPrinter->pIniSpooler->pMachineName,
                          pIniPrinter->pName,
                          pszToken );
            } else {

                wsprintf( pszPrinterName,
                          L"%s,%s",
                          pIniPrinter->pName,
                          pszToken );
            }
        } else {

            if( bFull ){
                wsprintf( pszPrinterName,
                          L"%s\\%s",
                          pIniPrinter->pIniSpooler->pMachineName,
                          pIniPrinter->pName );
            } else {

                lstrcpy( pszPrinterName, pIniPrinter->pName );
            }
        }

        SPLASSERT( lstrlen( pszPrinterName ) < cchLen );
    }

    return pszPrinterName;
}


VOID
DeleteSpoolerCheck(
    PINISPOOLER pIniSpooler
    )
{
    SplInSem();

    if( pIniSpooler->cRef == 0 &&
        ( pIniSpooler->SpoolerFlags & SPL_PENDING_DELETION )){

        SplDeleteSpooler( pIniSpooler );
    }
}

DWORD
AddLongNamesToShortNames(
    PCTSTR   pszShortNameDelimIn,
    PWSTR   *ppszAllNames
)
/*++

Routine Description:

    Add a list of comma delimited dns (long) names to a given list of comma delimited short names.

Arguments:

    pszShortNameDelimIn - Input list of comma delimited short names

    ppszAllNames - Output list of short plus long names, comma delimited.

Return Value:

--*/
{
    PSTRINGS    pLongName = NULL;
    PSTRINGS    pShortName = NULL;
    PWSTR        pszLongNameDelim = NULL;
    PWSTR        pszShortNameDelim = NULL;
    DWORD        dwRet = ERROR_SUCCESS;

    *ppszAllNames = NULL;

    // Clean up redundant delimiters, if any
    pszShortNameDelim = FixDelim(pszShortNameDelimIn, L',');
    if (!pszShortNameDelim) {
        dwRet = GetLastError();
        goto error;
    }

    if (!*pszShortNameDelim) {
        *ppszAllNames = AllocSplStr((PWSTR) pszShortNameDelim);

    } else {

        // Convert comma separated short names to array of names
        pShortName = DelimString2Array(pszShortNameDelim, L',');
        if (!pShortName) {
            dwRet = GetLastError();
            goto error;
        }

        // Get long name array from short names
        pLongName = ShortNameArray2LongNameArray(pShortName);
        if (!pLongName) {
            dwRet = GetLastError();
            goto error;
        }

        // Convert long name array to comma separated string
        pszLongNameDelim = Array2DelimString(pLongName, L',');
        if (pszLongNameDelim) {

            // Concatenate short & long name arrays
            *ppszAllNames = (PWSTR) AllocSplMem((wcslen(pszLongNameDelim) + wcslen(pszShortNameDelim) + 2)*sizeof(WCHAR));
            if (!*ppszAllNames) {
                dwRet = GetLastError();
                goto error;
            }

            wsprintf(*ppszAllNames, L"%s,%s", pszShortNameDelim, pszLongNameDelim);

        } else {
            *ppszAllNames = AllocSplStr((PWSTR) pszShortNameDelim);
        }
    }

error:

    FreeStringArray(pShortName);
    FreeStringArray(pLongName);
    FreeSplMem(pszLongNameDelim);
    FreeSplMem(pszShortNameDelim);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\clusspl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusspl.c

Abstract:

    Cluster code support.

Author:

    Albert Ting (AlbertT) 6-Oct-96

Revision History:

--*/

#ifndef _CLUSTER_H
#define _CLUSTER_H

#ifdef __cplusplus
extern "C" {
#endif


typedef struct _CLUSTER {
    DWORD       signature;
    HANDLE      hSpooler;
} CLUSTER, *PCLUSTER;

#define CLS_SIGNATURE 0x636c73  // CLS

BOOL
ShutdownSpooler(
    HANDLE hSpooler
    );

VOID
ShutdownMonitors(
    PINISPOOLER pIniSpooler
    );

BOOL
InitializeShared(
    PINISPOOLER pIniSpooler
    );

VOID
DeleteShared(
    PINISPOOLER pIniSpooler
    );


/********************************************************************

    Cluster registry access.

********************************************************************/

HKEY
OpenClusterParameterKey(
    IN LPCTSTR pszResource
    );

LONG
SplRegCreateKey(
    IN     HKEY hKey,
    IN     LPCTSTR pszSubKey,
    IN     DWORD dwOptions,
    IN     REGSAM samDesired,
    IN     PSECURITY_ATTRIBUTES pSecurityAttirbutes,
       OUT PHKEY phkResult,
       OUT PDWORD pdwDisposition,
    IN     PINISPOOLER pIniSpooler
    );

LONG
SplRegOpenKey(
    IN     HKEY hKey,
    IN     LPCTSTR pszSubKey,
    IN     REGSAM samDesired,
       OUT PHKEY phkResult,
    IN     PINISPOOLER pIniSpooler
    );

LONG
SplRegCloseKey(
    IN HKEY hKey,
    IN PINISPOOLER pIniSpooler
    );

LONG
SplRegDeleteKey(
    IN HKEY hKey,
    IN LPCTSTR pszSubKey,
    IN PINISPOOLER pIniSpooler
    );

LONG
SplRegEnumKey(
    IN     HKEY hKey,
    IN     DWORD dwIndex,
       OUT LPTSTR pszName,
    IN OUT PDWORD pcchName,
       OUT PFILETIME pftLastWriteTime,
    IN PINISPOOLER pIniSpooler
    );

LONG
SplRegQueryInfoKey(
    HKEY hKey,
    PDWORD pcSubKeys, OPTIONAL
    PDWORD pcbKey, OPTIONAL
    PDWORD pcValues, OPTIONAL
    PDWORD pcbValue, OPTIONAL
    PDWORD pcbData, OPTIONAL
    PDWORD pcbSecurityDescriptor, OPTIONAL
    PFILETIME pftLastWriteTime, OPTIONAL
    PINISPOOLER pIniSpooler
    );

LONG
SplRegSetValue(
    IN HKEY hKey,
    IN LPCTSTR pszValue,
    IN DWORD dwType,
    IN const BYTE* pData,
    IN DWORD cbData,
    IN PINISPOOLER pIniSpooler
    );

LONG
SplRegDeleteValue(
    IN HKEY hKey,
    IN LPCTSTR pszValue,
    IN PINISPOOLER pIniSpooler
    );

LONG
SplRegEnumValue(
    IN     HKEY hKey,
    IN     DWORD dwIndex,
       OUT LPTSTR pszValue,
    IN OUT PDWORD pcbValue,
       OUT PDWORD pType, OPTIONAL
       OUT PBYTE pData,
    IN OUT PDWORD pcbData,
    IN PINISPOOLER pIniSpooler
    );

LONG
SplRegQueryValue(
    IN     HKEY hKey,
    IN     LPCTSTR pszValue,
       OUT PDWORD pType, OPTIONAL
       OUT PBYTE pData,
    IN OUT PDWORD pcbData,
    IN PINISPOOLER pIniSpooler
    );


/********************************************************************

    Misc changes

********************************************************************/


VOID
BuildOtherNamesFromSpoolerInfo2(
    PSPOOLER_INFO_2 pSpoolerInfo2,
    PINISPOOLER pIniSpooler
    );

LPTSTR
pszGetPrinterName(
    PINIPRINTER pIniPrinter,
    BOOL bFull,
    LPCTSTR pszToken OPTIONAL
    );

BOOL
CreateDlName(
    IN LPCWSTR pszName,
    IN PINIMONITOR pIniMonitor,
    OUT LPCWSTR pszNameNew
    );

PINIMONITOR
InitializeDMonitor(
    PINIMONITOR pIniMonitor,
    LPWSTR pszRegistryRoot
    );

VOID
InitializeUMonitor(
    PINIMONITOR pIniMonitor
    );

//
// Clustering support.
//

BOOL
SplClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phSpooler,
    LPCTSTR pszName,
    LPCTSTR pszAddress
);

BOOL
SplClusterSplClose(
    HANDLE hSpooler
);

BOOL
SplClusterSplIsAlive(
    HANDLE hSpooler
);

DWORD 
ClusterGetResourceDriveLetter(
    IN  LPCWSTR  pszResource, 
    OUT LPWSTR  *ppszClusResDriveLetter
    );

DWORD 
ClusterGetResourceID(
    IN  LPCWSTR  pszResource, 
    OUT LPWSTR  *ppszClusResID
    );

#ifdef __cplusplus
}
#endif

#endif // ifdef _CLUSTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\config.c ===
/*++

Copyright (c) 1996 - 1998  Microsoft Corporation

Module Name:

    config.c

Abstract:

    Routines to do multiple hardware profile support for printing

Author:

    Muhunthan Sivapragasam (MuhuntS) 07-Nov-96 (Rewrite from Win95)

Revision History:


--*/

#include    <precomp.h>
#include    "config.h"
#include    "clusspl.h"
#include    <devguid.h>

#define     CM_REGSITRY_CONFIG      0x00000200

WCHAR   cszPnPKey[]             = L"PnPData";
WCHAR   cszPrinter[]            = L"Printer";
WCHAR   cszPrinterOnLine[]      = L"PrinterOnLine";
WCHAR   cszDeviceInstanceId[]   = L"DeviceInstanceId";

WCHAR   cszRegistryConfig[]     = L"System\\CurrentControlSet\\Hardware Profiles\\";



BOOL
LoadSetupApiDll(
    PSETUPAPI_INFO  pSetupInfo
    )
{
    UINT    uOldErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    pSetupInfo->hSetupApi = LoadLibrary(L"setupapi");
    SetErrorMode(uOldErrMode);


    if ( !pSetupInfo->hSetupApi )
        return FALSE;

    (FARPROC) pSetupInfo->pfnDestroyDeviceInfoList
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiDestroyDeviceInfoList");

    (FARPROC) pSetupInfo->pfnGetClassDevs
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiGetClassDevsA");

    (FARPROC) pSetupInfo->pfnRemoveDevice
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiRemoveDevice");

    (FARPROC) pSetupInfo->pfnOpenDeviceInfo
            = GetProcAddress(pSetupInfo->hSetupApi,
                             "SetupDiOpenDeviceInfoW");

    if ( !pSetupInfo->pfnDestroyDeviceInfoList      ||
         !pSetupInfo->pfnGetClassDevs               ||
         !pSetupInfo->pfnRemoveDevice               ||
         !pSetupInfo->pfnOpenDeviceInfo ) {

        FreeLibrary(pSetupInfo->hSetupApi);
        pSetupInfo->hSetupApi = NULL;
        return FALSE;
    }

    return TRUE;
}



BOOL
DeletePrinterDevNode(
    LPWSTR  pszDeviceInstanceId
    )
{
    BOOL                bRet = FALSE;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA     DevData;
    SETUPAPI_INFO       SetupInfo;
    HANDLE              UserToken;

    if ( !LoadSetupApiDll(&SetupInfo) )
        return FALSE;

    UserToken = RevertToPrinterSelf();

    hDevInfo = SetupInfo.pfnGetClassDevs((LPGUID)&GUID_DEVCLASS_PRINTER,
                                         NULL,
                                         INVALID_HANDLE_VALUE,
                                         0);

    if ( hDevInfo == INVALID_HANDLE_VALUE )
        goto Cleanup;

    DevData.cbSize = sizeof(DevData);
    if ( SetupInfo.pfnOpenDeviceInfo(hDevInfo,
                                     pszDeviceInstanceId,
                                     INVALID_HANDLE_VALUE,
                                     0,
                                     &DevData) ) {

        bRet = SetupInfo.pfnRemoveDevice(hDevInfo, &DevData);
    }

Cleanup:

    if ( hDevInfo != INVALID_HANDLE_VALUE )
        SetupInfo.pfnDestroyDeviceInfoList(hDevInfo);

    if (!ImpersonatePrinterClient(UserToken))
    {
        DBGMSG(DBG_ERROR, ("DeletePrinterDevNode: ImpersonatePrinterClient Failed. Error %d\n", GetLastError()));
    }

    FreeLibrary(SetupInfo.hSetupApi);

    return bRet;
}


LPWSTR
GetPrinterDeviceInstanceId(
    PINIPRINTER     pIniPrinter
    )
{
    WCHAR   buf[MAX_PATH];
    DWORD   dwType, cbNeeded, dwReturn;
    HKEY    hKey = NULL;
    LPWSTR  pszDeviceInstanceId = NULL;

    SplInSem();
    cbNeeded = sizeof(buf);

    if ( ERROR_SUCCESS == OpenPrinterKey(pIniPrinter,
                                         KEY_READ,
                                         &hKey,
                                         cszPnPKey,
                                         TRUE)                          &&
         ERROR_SUCCESS == SplRegQueryValue(hKey,
                                           cszDeviceInstanceId,
                                           &dwType,
                                           (LPBYTE)buf,
                                           &cbNeeded,
                                           pIniPrinter->pIniSpooler)    &&
         dwType == REG_SZ ) {

        pszDeviceInstanceId = AllocSplStr(buf);
    }

    if ( hKey )
        SplRegCloseKey(hKey, pIniPrinter->pIniSpooler);

    return pszDeviceInstanceId;
}


BOOL
DeleteIniPrinterDevNode(
    PINIPRINTER     pIniPrinter
    )
{
    BOOL    bRet = FALSE;
    LPWSTR  pszStr = GetPrinterDeviceInstanceId(pIniPrinter);

    if ( pszStr ) {

        bRet = DeletePrinterDevNode(pszStr);
        FreeSplStr(pszStr);
    }

    return bRet;
}


VOID
SplConfigChange(
    )
{
    PINIPRINTER     pIniPrinter     = NULL;
    BOOL            bCheckScheduler = FALSE;
    HKEY            hConfig         = NULL;
    HKEY            hKey;
    DWORD           dwOnline, dwType, cbNeeded;   

    EnterSplSem();

    //
    // If we have no printers which are offline then we would not have
    // created the key at all
    //
    if ( RegCreateKeyEx(HKEY_CURRENT_CONFIG,
                        ipszRegistryPrinters,
                        0,
                        NULL,
                        0,
                        KEY_READ,
                        NULL,
                        &hConfig,
                        NULL) )
        goto Cleanup;

    for ( pIniPrinter = pLocalIniSpooler->pIniPrinter ;
          pIniPrinter ;
          pIniPrinter = pIniPrinter->pNext ) {

        //
        // Don't consider printers that have invalid ports, these must always
        // stay offline until this is resolved. If the user explicitely turns 
        // the port online, that is up to them.
        // 
        UINT    i = 0;

        //
        // If pIniPrinter->ppIniPorts is NULL, cPorts would be zero.
        // 
        for(i = 0; i < pIniPrinter->cPorts; i++) {

            if (pIniPrinter->ppIniPorts[i]->Status & PP_PLACEHOLDER) {
                break;
            }
        }

        //
        // If we reached the end of the list, none of the ports were 
        // placeholders. If we didn't go onto the next one.
        // 
        if (i < pIniPrinter->cPorts) {

            continue;
        }

        if ( RegOpenKeyEx(hConfig,
                          pIniPrinter->pName,
                          0,
                          KEY_READ,
                          &hKey) )
            continue; // to next printer

        cbNeeded = sizeof(dwOnline);
        if ( ERROR_SUCCESS == SplRegQueryValue(hKey,
                                               cszPrinterOnLine,
                                               &dwType,
                                               (LPBYTE)&dwOnline,
                                               &cbNeeded,
                                               NULL) ) {
            if ( dwOnline ) {

                //
                // If any printers which are offline in current config
                // become online in the new config then we need to trigger
                // the scheduler
                //
                if ( pIniPrinter->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE ) {

                    pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_WORK_OFFLINE;
                    bCheckScheduler = TRUE;
                }

            } else {

                pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_WORK_OFFLINE;
            }
        }

        RegCloseKey(hKey);
    }

    if ( bCheckScheduler )
        CHECK_SCHEDULER();

Cleanup:
    LeaveSplSem();

    if ( hConfig )
        RegCloseKey(hConfig);
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DeletePrinterInAllConfigs

Routine Description:

    Deletes a pIniPrinter from all the hardware profiles.

Arguments:

    pIniPrinter - Printer to delete.

Return Value:

    BOOL, TRUE = success, FALSE = FAILUER

Last Error:

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

BOOL
DeletePrinterInAllConfigs(
    PINIPRINTER pIniPrinter
    )
{
    HKEY hConfig;
    WCHAR szSubKey[2 * MAX_PATH];
    DWORD Config;
    DWORD Size;
    DWORD Status;

    SplInSem();

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          cszRegistryConfig,
                          0,
                          KEY_ALL_ACCESS,
                          &hConfig);

    if (Status != ERROR_SUCCESS)
    {
        DBGMSG(DBG_WARN, ("DeletePrinterInAllConfigs: RegOpenKey failed %d\n", Status));
    }
    else
    {
        DWORD RegPrintersLen = wcslen(ipszRegistryPrinters);
        for (Config = 0;

             Size = (DWORD)(COUNTOF(szSubKey) - ( RegPrintersLen + wcslen(pIniPrinter->pName) +2)) ,
             (Status = RegEnumKeyEx(hConfig,
                                    Config,
                                    szSubKey,
                                    &Size,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL)) == ERROR_SUCCESS;

             ++Config)
        {
            wcscat(szSubKey, L"\\");
            wcscat(szSubKey, ipszRegistryPrinters);
            wcscat(szSubKey, L"\\");
            wcscat(szSubKey, pIniPrinter->pName);

            Status = RegDeleteKey(hConfig, szSubKey);

            if (Status != ERROR_SUCCESS &&
                Status != ERROR_FILE_NOT_FOUND)
            {
                DBGMSG( DBG_WARN, ("DeletePrinterInAllConfigs: RegDeleteKey failed %d\n", Status));
            }
        }

        if (Status != ERROR_NO_MORE_ITEMS)
        {
            DBGMSG(DBG_WARN, ("DeletePrinterInAllConfigs: RegEnumKey failed %d\n", Status));
        }

        RegCloseKey(hConfig);
    }

    return TRUE;
}


BOOL
WritePrinterOnlineStatusInCurrentConfig(
    PINIPRINTER     pIniPrinter
    )
{
    HKEY                hKey = NULL;
    DWORD               dwOnline, dwReturn;
    WCHAR               szKey[2 * MAX_PATH];
    HANDLE              hToken;

    SplInSem();

    hToken = RevertToPrinterSelf();

    wcscpy(szKey, ipszRegistryPrinters);
    wcscat(szKey, L"\\");
    wcscat(szKey, pIniPrinter->pName);

    dwOnline = (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE)
                            ? 0 : 1;

    dwReturn = RegCreateKeyEx(HKEY_CURRENT_CONFIG,
                              szKey,
                              0,
                              NULL,
                              0,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              NULL);

    if ( dwReturn == ERROR_SUCCESS )
        dwReturn = RegSetValueEx(hKey,
                                 cszPrinterOnLine,
                                 0,
                                 REG_DWORD,
                                 (LPBYTE)&dwOnline,
                                 sizeof(DWORD));

    if ( hKey )
        RegCloseKey(hKey);

    ImpersonatePrinterClient(hToken);

    return dwReturn == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\aspapp\ipp_adsi.inc ===
<%
'------------------------------------------------------------
'
'   Microsoft Internet Printing Project
'
'   Copyright (c) Microsoft Corporation 1998
'
'------------------------------------------------------------
%>

<%
Const ADSI_PRINTER_NAME = 1
Const ADSI_PRINTER_LOCATION = 2
Const ADSI_PRINTER_COMMENT = 3
Const ADSI_PRINTER_MODEL = 4
Const ADSI_PRINTER_STATUS = 5
Const ADSI_PRINTER_JOBS = 6
Const ADSI_PRINTER_SHARE = 7
Const ADSI_PRINTER_ACCESS = 8
Const ADSI_PRINTER_ATTRIBUTES = 8

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\aspapp\ipp_0000.inc ===
<%
'------------------------------------------------------------
'
'   Microsoft Internet Printing Project
'
'   Copyright (c) Microsoft Corporation 1998
'
'------------------------------------------------------------
Const SNMP_ALERT_SEVERITY       = 0
Const SNMP_ALERT_INDEX          = 1
Const SNMP_ALERT_SUBUNIT        = 2
Const SNMP_ALERT_DESCRIPTION    = 3
Const SNMP_ALERT_CODE           = 4
Const SNMP_ALERT_TRAINING       = 5
Const SNMP_ALERT_ATTRIBUTES     = 5
Const SNMP_INTRAY_TYPE          = 0
Const SNMP_INTRAY_UNITS         = 1
Const SNMP_INTRAY_MAX           = 2
Const SNMP_INTRAY_CURRENT       = 3
Const SNMP_INTRAY_STATE         = 4
Const SNMP_INTRAY_MEDIA         = 5
Const SNMP_INTRAY_UNIT          = 6
Const SNMP_INTRAY_NAME          = 7
Const SNMP_INTRAY_ATTRIBUTES    = 7
Const SNMP_LIGHT_ON             = 0
Const SNMP_LIGHT_OFF            = 1
Const SNMP_LIGHT_COLOR          = 2
Const SNMP_LIGHT_DESCRIPTION    = 3
Const SNMP_LIGHT_ATTRIBUTES     = 3

Function rgSNMPGetState(objSNMP, iDevice)
    Dim rgFetchList, rgState, StrDevice, rgFetchValue, hrPrintDetectedState

    On Error Resume Next
    Err.Clear
    StrDevice = CStr(iDevice)
    rgFetchList = Array("25.3.2.1.5." & StrDevice, "25.3.5.1.1." & StrDevice)

    hrPrintDetectedState = objSNMP.GetAsByte ("25.3.5.1.2." & StrDevice)
    If Err Then Exit Function

    rgFetchValue = objSNMP.GetList(rgFetchList)
    If Err Then Exit Function

    rgState = Array (rgFetchValue(0), rgFetchValue(1), hrPrintDetectedState)
    If Err Then Exit Function

    rgSNMPGetState = rgState
End Function

Function GetLastNode (strMib)
    Dim strTmp, j

    For j = 1 To Len (strMib)
        strTmp = Right (strMib, j)
        If Left (strTmp, 1) = "." Then
            GetLastNode = strTmp
            Exit Function
        End If
    Next
    GetLastNode = ""
End Function

Function rgSNMPGetAlerts(objSNMP, objHelper, iDevice, iAlerts)
    Dim rgTmp, rgAlerts()
    Dim i, StrDevice

    On Error Resume Next

    iAlerts = -1
    StrDevice = CStr(iDevice)
    rgTmp = objSNMP.GetTree("43.18.1.1.2." & StrDevice) 'alert severities
    If Err Then 'assume there is not alert table
        Err.Clear
        Exit Function
    End If

    If UBound(rgTmp, 2) >= 0 Then
        iAlerts = UBound(rgTmp, 2)

        ReDim rgAlerts(SNMP_ALERT_ATTRIBUTES, iAlerts)

        For i = 0 to iAlerts
            rgAlerts(SNMP_ALERT_INDEX, i) = i
            rgAlerts(SNMP_ALERT_SEVERITY, i) = rgTmp(1, i)
        Next

        'rgTmp = objSNMP.GetTree("43.18.1.1.3." & StrDevice)

        'If UBound(rgTmp,2)  = iAlerts Then
        '    For i = 0 to iAlerts
        '        rgAlerts(SNMP_ALERT_TRAINING, i) = rgTmp(1, i)
        '    Next
        'End If

        rgTmp = objSNMP.GetTree("43.18.1.1.4." & StrDevice)

        If UBound(rgTmp,2)  = iAlerts Then
            For i = 0 to iAlerts
                rgAlerts(SNMP_ALERT_SUBUNIT, i) = rgTmp(1, i)
            Next
        End If

        rgTmp = objSNMP.GetTree("43.18.1.1.5." & StrDevice)

        If UBound(rgTmp,2)  = iAlerts Then
            For i = 0 to iAlerts
                rgAlerts(SNMP_ALERT_INDEX, i) = rgTmp(1, i)
            Next
        End If

        rgTmp = objSNMP.GetTree("43.18.1.1.7." & StrDevice)

        If UBound(rgTmp,2)  = iAlerts Then
            For i = 0 to iAlerts
                rgAlerts(SNMP_ALERT_CODE, i) = rgTmp(1, i)
            Next

            For i = 0 to iAlerts
                If rgTmp(1,i) = 1 Then 'Other Error
                    rgAlerts(SNMP_ALERT_DESCRIPTION, i) = objSNMP.Get ("43.18.1.1.8." & StrDevice & GetLastNode (rgTmp (0, i)))
                    If rgAlerts(SNMP_ALERT_DESCRIPTION, i) = "" Then
                        rgAlerts(SNMP_ALERT_DESCRIPTION, i) = objHelper.MibErrorDscp (rgTmp(1, i))
                    End If
                Else
                    rgAlerts(SNMP_ALERT_DESCRIPTION, i) = objHelper.MibErrorDscp (rgTmp(1, i))
                    If rgAlerts(SNMP_ALERT_DESCRIPTION, i) = "" Then
                        rgAlerts(SNMP_ALERT_DESCRIPTION, i) = objSNMP.Get ("43.18.1.1.8." & StrDevice & GetLastNode (rgTmp (0, i)))
                    End If
                End If
            Next

        End If

        rgSNMPGetAlerts = rgAlerts
    End If
End Function

Function rgSNMPGetInputTrays(objSNMP, iDevice, iTrays)
    Dim rgWork, iFetch, StrDevice, i, rgTrays()
    Dim j
    Dim rgFetchOid(7)

    On Error Resume Next
    Err.Clear

    StrDevice = CStr(iDevice)
    rgFetchOid(0) = "43.8.2.1.2." & StrDevice      'type
    rgFetchOid(1) = "43.8.2.1.8." & StrDevice      'units
    rgFetchOid(2) = "43.8.2.1.9." & StrDevice      'max
    rgFetchOid(3) = "43.8.2.1.10." & StrDevice     'current
    rgFetchOid(4) = "43.8.2.1.11." & StrDevice     'state
    rgFetchOid(5) = "43.8.2.1.12." & StrDevice     'media
    rgFetchOid(6) = "43.8.2.1.13." & StrDevice     'input unit
    rgFetchOid(7) = "43.8.2.1.18." & StrDevice     'trayname



    rgWork = objSNMP.GetTree(rgFetchOid(0))
    If Err Then Exit Function
    iTrays = UBound(rgWork, 2)


    If iTrays >= 0 Then
        ReDim rgTrays(SNMP_INTRAY_ATTRIBUTES, iTrays)

        For j = 0 To 7
            If j <> 0 Then
                rgWork = objSNMP.GetTree(rgFetchOid(j))
                If Err Then Exit Function
            End If

            For i = 0 To UBound(rgWork, 2)
                rgTrays(j, i) = rgWork(1, i)
            Next
        Next

        rgSNMPGetInputTrays = rgTrays

    End If
End Function

Function strAppendStr (strBody, strTail)
    Dim L_Comma_Text

    L_Comma_Text = ", "

    If strBody = "" Then
        strAppendStr = strTail
    Else
        strAppendStr = strBody & L_Comma_Text & strTail
    End If
End Function

Function strSNMPStatus(rgState)
    Dim strHTML
    Dim str1, str2, strSubject
    Dim bDisplay
    Dim L_DeviceStatus_Text
    Dim L_UpRunning_Text, L_Warning_Text, L_Tested_Text, L_UnAvailable_Text
    Dim L_IdleState_Text, L_Printing_Text, L_WarmingUp_Text
    Const strIndent = "&nbsp;"

    L_DeviceStatus_Text  = "<B>Status:</b> "
    L_UpRunning_Text     = "<font color = red>Up and Running</font>"
    L_Warning_Text       = "<font color = red>Functioning but has one or more warnings</font>"
    L_Tested_Text        = "<font color = red>Being tested</font>"
    L_UnAvailable_Text   = "<font color = red>Unavailable for any use</font>"
    L_IdleState_Text     = "<p>In an idle state</p>"
    L_Printing_Text      = " Printing documents "
    L_WarmingUp_Text     = " Warming up "

    strHTML = "<table><tr><td>" & strIndent & "</td><td>" & DEF_FONT_TAG

    Select Case rgState(1)
        Case 4
            str2 = L_Printing_Text
        Case 5
            str2 = L_WarmingUp_Text
        Case Else
            str2 = ""
    End Select

    If str2 <> "" Then
        strHTML = strHTML & " - " & str2
    End If

    bDisplay = TRUE
    Select Case rgState(0)
        Case 2
            str1 = L_UpRunning_Text
        Case 3
            str1 = L_Warning_Text
        Case 4
            str1 = L_Tested_Text
        Case 5
            str1 = L_UnAvailable_Text
        Case Else
            bDisplay = FALSE
    End Select
    If bDisplay Then
        strHTML = strHTML & str1
    End If

    strHTML = strHTML & "</font></td></tr>"

    If (rgState(0) = 3 Or rgState(0) = 5) Then
        Dim lErrState, lMask, lNumMsg
        Dim L_ErrMsg_Text(7)
        Const L_DetectedWarn_Text = "<b>Warnings:</b> "
        Const L_DetectedErr_Text  = "<b>Errors:</b> "

        L_ErrMsg_Text(0) = "service requested"
        L_ErrMsg_Text(1) = "offline"
        L_ErrMsg_Text(2) = "paper jammed"
        L_ErrMsg_Text(3) = "door open"
        L_ErrMsg_Text(4) = "no toner"
        L_ErrMsg_Text(5) = "toner low"
        L_ErrMsg_Text(6) = "out of paper"
        L_ErrMsg_Text(7) = "low paper"

        lErrState = CInt (rgState(2))

        str1 = ""
        lMask = 1
        lNumMsg = 0
        For i = 0 To 7
            If lErrState And lMask Then
                str1 = strAppendStr (str1, L_ErrMsg_Text(i))
                lNumMsg = lNumMsg + 1
            End If
            lMask = lMask * 2
        Next

        If lNumMsg > 0 Then
            strHTML = strHTML & "<tr><td>" & strIndent & "</td><td>" & DEF_FONT_TAG
            If rgState(0) = 3 Then
                strHTML = strHTML & L_DetectedWarn_Text
            Else
                strHTML = strHTML & L_DetectedErr_Text
            End If

            strHTML = strHTML & str1 & "</font></td></tr>"
        End If
    End If

    strHTML = strHTML & "</table>"

    strSNMPStatus = strHTML

End Function

Function rgSNMPConsole(objSNMP, iDevice, iRow, iColumn, rgConText, strLang)

Const prtConsoleLocalization = "43.5.1.1.10."
Const prtConsoleNumberOfDisplayLines = "43.5.1.1.11."
Const prtConsoleNumberOfDisplayChars = "43.5.1.1.12."
Const prtConsoleDisplayBufferText = "43.16.5.1.2."
Const prtLocalizationLanguage = "43.7.1.1.3."

    Dim StrDevice, i, rgOidList, rgConsole

    StrDevice = CStr(iDevice)
    rgSNMPConsole = False
    rgConText = ""

    rgOidList = Array(prtConsoleLocalization & StrDevice, prtConsoleNumberOfDisplayLines & StrDevice, prtConsoleNumberOfDisplayChars & StrDevice)
    rgConsole = objSNMP.GetList(rgOidList)
    If Err.Number <> 0 Then Exit Function

    iRow = rgConsole(1)
    iColumn = rgConsole(2)

    if iRow <> 0 Then

        ReDim rgConTextOidList(iRow - 1)
        For i = 0 To iRow - 1
            rgConTextOidList(i) = prtConsoleDisplayBufferText & StrDevice & "." & CStr(i + 1)
        Next

        rgConText = objSNMP.GetList(rgConTextOidList)
        If Err.Number <> 0 Then Exit Function

        strLang = objSNMP.Get (prtLocalizationLanguage & StrDevice & "." & rgConsole(0))
        If Err.Number <> 0 Then Exit Function
    End If

    rgSNMPConsole = True

End Function


Function rgSNMPLights(objSNMP, iDevice, iLights)
    Dim rgWork
    Dim rgFetchOid(4)
    Dim StrDevice

    StrDevice = CStr(iDevice)
	
    On Error Resume Next
    rgFetchOid(0) = "43.17.6.1.2." & StrDevice & "."
    rgFetchOid(1) = "43.17.6.1.3." & StrDevice & "."
    rgFetchOid(2) = "43.17.6.1.4." & StrDevice & "."
    rgFetchOid(3) = "43.17.6.1.5." & StrDevice & "."

    rgWork = objSNMP.GetTree(rgFetchOid(0))
    If Err Then Exit Function

    iLights = UBound(rgWork, 2)

    If iLights >= 0 Then
        Dim i, j
        ReDim rgLights(SNMP_LIGHT_ATTRIBUTES, iLights)

        For j = 0 To 3
            If j <> 0 Then
                rgWork = objSNMP.GetTree(rgFetchOid(j))
                If Err Then Exit Function
            End If

            For i = 0 To UBound(rgWork, 2)
                rgLights(j, i) = rgWork(1, i)
            Next
        Next

        rgSNMPLights = rgLights

    End If

End Function
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\config.h ===
/*++

Copyright (c) 1990 - 1997 Microsoft Corporation

Module Name:

    config.h

Abstract:

    Header file for multiple hardware profile support

Author:

    Muhunthan Sivapragasam  (MuhuntS)   30-Apr-97

Revision History:

--*/

#include    <setupapi.h>
#include    <initguid.h>

typedef
(WINAPI * pfSetupDiDestroyDeviceInfoList)(
    IN HDEVINFO DeviceInfoSet
    );

typedef
HDEVINFO
(WINAPI * pfSetupDiGetClassDevs)(
    IN LPGUID ClassGuid,  OPTIONAL
    IN PCSTR  Enumerator, OPTIONAL
    IN HWND   hwndParent, OPTIONAL
    IN DWORD  Flags
    );

typedef
BOOL
(WINAPI * pfSetupDiRemoveDevice)(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );

typedef
BOOL
(WINAPI * pfSetupDiOpenDeviceInfo)(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCWSTR           DeviceInstanceId,
    IN  HWND             hwndParent,       OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
    );

typedef struct  _SETUPAPI_INFO {

    HMODULE     hSetupApi;

    pfSetupDiDestroyDeviceInfoList      pfnDestroyDeviceInfoList;
    pfSetupDiGetClassDevs               pfnGetClassDevs;
    pfSetupDiRemoveDevice               pfnRemoveDevice;
    pfSetupDiOpenDeviceInfo             pfnOpenDeviceInfo;
} SETUPAPI_INFO, *PSETUPAPI_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\data.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    data.c

Abstract:

    Generates globals used for marshalling spooler data structures.
    Actual definitions in spl\inc.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include <precomp.h>

#define PRINTER_STRINGS
#define JOB_STRINGS
#define DRIVER_STRINGS
#define ADDJOB_STRINGS
#define FORM_STRINGS
#define PORT_STRINGS
#define PRINTPROCESSOR_STRINGS
#define MONITOR_STRINGS
#define DOCINFO_STRINGS

#include <stddef.h>
#include <data.h>

DWORD IniDriverOffsets[]={offsetof(INIDRIVER, pName),
                          offsetof(INIDRIVER, pDriverFile),
                          offsetof(INIDRIVER, pConfigFile),
                          offsetof(INIDRIVER, pDataFile),
                          offsetof(INIDRIVER, pHelpFile),
                          offsetof(INIDRIVER, pDependentFiles),
                          offsetof(INIDRIVER, pMonitorName),
                          offsetof(INIDRIVER, pDefaultDataType),
                          offsetof(INIDRIVER, pszzPreviousNames),
                          offsetof(INIDRIVER, pszMfgName),
                          offsetof(INIDRIVER, pszOEMUrl),
                          offsetof(INIDRIVER, pszHardwareID),
                          offsetof(INIDRIVER, pszProvider),
                          0xFFFFFFFF};

DWORD IniPrinterOffsets[]={offsetof(INIPRINTER, pName),
                           offsetof(INIPRINTER, pShareName),
                           offsetof(INIPRINTER, pDatatype),
                           offsetof(INIPRINTER, pParameters),
                           offsetof(INIPRINTER, pComment),
                           offsetof(INIPRINTER, pDevMode),
                           offsetof(INIPRINTER, pSepFile),
                           offsetof(INIPRINTER, pLocation),
                           offsetof(INIPRINTER, pSpoolDir),
                           offsetof(INIPRINTER, ppIniPorts),
                           offsetof(INIPRINTER, pszObjectGUID),
                           offsetof(INIPRINTER, pszDN),
                           offsetof(INIPRINTER, pszCN),
                           0xFFFFFFFF};

DWORD IniSpoolerOffsets[]={offsetof(INISPOOLER, pMachineName),
                           offsetof(INISPOOLER, pDir),
                           offsetof(INISPOOLER, pDefaultSpoolDir),
                           offsetof(INISPOOLER, pszRegistryMonitors),
                           offsetof(INISPOOLER, pszRegistryEnvironments),
                           offsetof(INISPOOLER, pszRegistryEventLog),
                           offsetof(INISPOOLER, pszRegistryProviders),
                           offsetof(INISPOOLER, pszEventLogMsgFile),
                           offsetof(INISPOOLER, pszDriversShare),
                           offsetof(INISPOOLER, pszRegistryForms),
                           offsetof(INISPOOLER, pszClusterGUID),
                           offsetof(INISPOOLER, pszClusResDriveLetter),
                           offsetof(INISPOOLER, pszClusResID),
                           offsetof(INISPOOLER, pszFullMachineName),
                           0xFFFFFFFF};

DWORD IniEnvironmentOffsets[] = {offsetof(INIENVIRONMENT, pDirectory),
                                 0xFFFFFFFF};

DWORD IniPrintProcOffsets[] = { offsetof(INIPRINTPROC, pDatatypes),
                                0xFFFFFFFF};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\copyreg.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    copyreg.c

Abstract:

    This module provides functions to copy registry keys

Author:

    Krishna Ganugapati (KrishnaG) 20-Apr-1994

Notes:
    List of functions include

    CopyValues
    CopyRegistryKeys

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#include "clusspl.h"

extern WCHAR *szRegistryPrinters;

VOID
CopyValues(
    HKEY hSourceKey,
    HKEY hDestKey,
    PINISPOOLER pIniSpooler
    );

BOOL
CopyRegistryKeys(
    HKEY hSourceParentKey,
    LPWSTR szSourceKey,
    HKEY hDestParentKey,
    LPWSTR szDestKey,
    PINISPOOLER pIniSpooler
    );


VOID
CopyValues(
    HKEY hSourceKey,
    HKEY hDestKey,
    PINISPOOLER pIniSpooler
    )
/*++
   Description: This function copies all the values from hSourceKey to hDestKey.
   hSourceKey should be opened with KEY_READ and hDestKey should be opened with
   KEY_WRITE.

   Returns: VOID
--*/
{
    DWORD iCount = 0;
    WCHAR szValueString[MAX_PATH];
    DWORD dwSizeValueString;
    DWORD dwType = 0;
    PBYTE pData;

    DWORD cbData = 1024;
    DWORD dwSizeData;

    SplRegQueryInfoKey( hSourceKey,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     &cbData,
                     NULL,
                     NULL,
                     pIniSpooler );

    pData = (PBYTE)AllocSplMem( cbData );

    if( pData ){

        dwSizeValueString = COUNTOF(szValueString);
        dwSizeData = cbData;

        while ((SplRegEnumValue(hSourceKey,
                            iCount,
                            szValueString,
                            &dwSizeValueString,
                            &dwType,
                            pData,
                            &dwSizeData,
                            pIniSpooler
                            )) == ERROR_SUCCESS ) {

            SplRegSetValue( hDestKey,
                           szValueString,
                           dwType,
                           pData,
                           dwSizeData, pIniSpooler);

            dwSizeValueString = COUNTOF(szValueString);
            dwType = 0;
            dwSizeData = cbData;
            iCount++;
        }

        FreeSplMem( pData );
    }
}


BOOL
CopyRegistryKeys(
    HKEY hSourceParentKey,
    LPWSTR szSourceKey,
    HKEY hDestParentKey,
    LPWSTR szDestKey,
    PINISPOOLER pIniSpooler
    )
/*++
    Description:This function recursively copies the szSourceKey to szDestKey. hSourceParentKey
    is the parent key of szSourceKey and hDestParentKey is the parent key of szDestKey.

    Returns: TRUE if the function succeeds; FALSE on failure.

--*/
{
    DWORD dwRet;
    DWORD iCount;
    HKEY hSourceKey, hDestKey;
    WCHAR lpszName[MAX_PATH];
    DWORD dwSize;

    dwRet = SplRegOpenKey(hSourceParentKey,
                         szSourceKey, KEY_READ, &hSourceKey, pIniSpooler);

    if (dwRet != ERROR_SUCCESS) {
        return(FALSE);
    }

    dwRet = SplRegCreateKey(hDestParentKey,
                            szDestKey, 0, KEY_WRITE, NULL, &hDestKey, NULL, pIniSpooler);

    if (dwRet != ERROR_SUCCESS) {
        SplRegCloseKey(hSourceKey, pIniSpooler);
        return(FALSE);
    }

    iCount = 0;

    memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
    dwSize =  COUNTOF(lpszName);

    while((SplRegEnumKey(hSourceKey, iCount, lpszName,
                    &dwSize,NULL,pIniSpooler)) == ERROR_SUCCESS) {

        CopyRegistryKeys( hSourceKey,
                          lpszName,
                          hDestKey,
                          lpszName,
                          pIniSpooler );

        memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
        dwSize =  COUNTOF(lpszName);

        iCount++;
    }

    CopyValues(hSourceKey, hDestKey, pIniSpooler);

    SplRegCloseKey(hSourceKey, pIniSpooler);
    SplRegCloseKey(hDestKey, pIniSpooler);
    return(TRUE);
}


BOOL
bValidPrinter(
    HKEY hKey
    )
/*++
   Description: Assume that hKey is a printer key and check for existence of value Attributes.
                If Attributes exists, assume it's a valid printer key.
                This function is called when migrate keys between SYSTEM and SOFTWARE hives.

   Returns: TRUE if it is a valid printer key

--*/
{
    DWORD  dwRet;

    dwRet = RegQueryValueEx( hKey, L"Attributes", 0, NULL, NULL, NULL );

    return dwRet == ERROR_SUCCESS;
}

VOID
CopyPrinterValues(
    HKEY hSourceKey,
    HKEY hDestKey
    )
/*++
   Description: Copy values from hSourceKey to hDestKey if their names are: Name, Printer Driver or Default DevMode
                This function is called when migrate keys between SYSTEM and SOFTWARE hive in order to copy only
                few values( the most important one)

   Returns: VOID
--*/
{
    DWORD dwSizeData;
    DWORD dwType;
    PBYTE pData;
    int iCount;

    DWORD cbData = 1024;


    static LPCWSTR PrinterValuesTable [] = {{L"Name"},
                                            {L"Printer Driver"},
                                            {L"Default DevMode"},
                                            {L"Port"},
                                            {0}};
    RegQueryInfoKey( hSourceKey,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     &cbData,
                     NULL,
                     NULL );

    pData = (PBYTE)AllocSplMem( cbData );

    if( pData ){

        for ( iCount = 0;
              dwSizeData = cbData, PrinterValuesTable[iCount];
              iCount++ ){

            if ( RegQueryValueEx(hSourceKey,
                                 PrinterValuesTable[iCount],
                                 0,
                                 &dwType,
                                 pData,
                                 &dwSizeData
                                ) == ERROR_SUCCESS ) {

                    RegSetValueEx( hDestKey,
                                   PrinterValuesTable[iCount],
                                   0,
                                   dwType,
                                   pData,
                                   dwSizeData);
                }
        }

        FreeSplMem( pData );
    }
}

BOOL
CopyPrinters(
    HKEY    hSourceParentKey,
    LPWSTR  szSourceKey,
    HKEY    hDestParentKey,
    LPWSTR  szDestKey,
    BOOL    bTruncated)
/*++
    Description: Recursively copy printer keys from hSourceParentKey,szSourceKey to hDestParentKey,szDestKey.
                 This function is called at registry migration time and szDestKey and szSourceKey
                 are one of the ...\Print\Printers paths in SYSTEM or SOFTWARE hives.
                 bTruncated on TRUE specifies that subkeys under "\Printers" must not be copy and only a minimal
                 set of value should be copied.bTruncated must be true when copy from SOFTWARE to SYSTEM.

                 Also, the keys under "\Printers" key are verified from a "valid printer" point of view.

    Returns: TRUE if the function succeeds; FALSE on failure.

--*/
{
    DWORD dwRet;
    INT   iCount;
    WCHAR szName[MAX_PATH];
    DWORD dwSize;
    BOOL  bRetValue;
    HKEY  hSourceKey = NULL, hDestKey = NULL;
    HKEY  hSourceSubKey, hDestSubKey;


    bRetValue = FALSE;

    //
    // Open source "Printers" key
    //
    dwRet = RegOpenKeyEx(hSourceParentKey,
                         szSourceKey,
                         0,
                         KEY_READ,
                         &hSourceKey);

    if (dwRet != ERROR_SUCCESS) {
        goto End;
    }

    //
    // Create/Open destination "Printers" key
    //
    dwRet = RegCreateKeyEx(hDestParentKey,
                           szDestKey,
                           0,
                           NULL,
                           0,
                           KEY_WRITE,
                           NULL,
                           &hDestKey,
                           NULL);

    if ( dwRet != ERROR_SUCCESS ) {
        goto End;
    }

    //
    // Enumerates printer keys
    //
    for ( iCount = 0, bRetValue = TRUE;
          dwSize =  COUNTOF(szName),
          (RegEnumKeyEx(hSourceKey,
                        iCount,
                        szName,
                        &dwSize,
                        NULL,
                        NULL,
                        NULL,
                        NULL) == ERROR_SUCCESS ) &&
          bRetValue;

         iCount++
        ) {

        dwRet = RegOpenKeyEx(hSourceKey,
                             szName,
                             0,
                             KEY_READ,
                             &hSourceSubKey);

        if ( bRetValue = (dwRet == ERROR_SUCCESS) ) {

            if( bValidPrinter(hSourceSubKey) ){

                //
                // Copy printer key if valid
                //
                dwRet = RegCreateKeyEx(hDestKey,
                                       szName,
                                       0,
                                       NULL,
                                       0,
                                       KEY_WRITE,
                                       NULL,
                                       &hDestSubKey,
                                       NULL);

                if( bRetValue = (dwRet == ERROR_SUCCESS) ){

                    if( bTruncated ){

                        //
                        // It is a copying from SOFTWARE to SYSTEM
                        // Copy only most important values , without any subkeys
                        //
                        CopyPrinterValues(hSourceSubKey, hDestSubKey);

                    }else{

                        //
                        // Recursive copy printer key with all it's values and subkeys
                        //
                        bRetValue = CopyRegistryKeys( hSourceKey,
                                                      szName,
                                                      hDestKey,
                                                      szName,
                                                      NULL);
                    }

                    RegCloseKey(hDestSubKey);
                }

            }

            RegCloseKey(hSourceSubKey);
        }

    }

    //
    // Copy all values from '.../Printers" to ".../Printers' keys
    //
    CopyValues(hSourceKey, hDestKey, NULL);

    if( hSourceKey ){

        RegCloseKey(hSourceKey);
    }

    if( hDestKey ){

        RegCloseKey(hDestKey);
    }

End:
    return bRetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\copyfile.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    copyfile.c

Abstract:

    InternalCopyFile - Copies a file retaining time and attributes

Author:

    Matthew A Felton

Revision History:

    Matthew Felton (mattfe) 27 March 1995

--*/


#include <precomp.h>

#define FILE_SHARE_EXCLUSIVE 0
#define BUFFER_SIZE     4096

BOOL
InternalCopyFile(
    HANDLE  hSourceFile,
    PWIN32_FIND_DATA pSourceFileData,
    LPWSTR  lpNewFileName,
    BOOL    bFailIfExists
    )

/*++

Routine Description:


Arguments:

    hSourceFile - SourceFile Handle

    pSourceFileData - Pointer to WIN32_FIND_DATA for the source file

    lpNewFileName - Supplies the name where a copy of the existing
        files data and attributes are to be stored.

    bFailIfExists - Supplies a flag that indicates how this operation is
        to proceed if the specified new file already exists.  A value of
        TRUE specifies that this call is to fail.  A value of FALSE
        causes the call to the function to succeed whether or not the
        specified new file exists.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    DWORD       dwSourceFileAttributes;
    BOOL        bReturnValue = FALSE;
    HANDLE      hTargetFile = INVALID_HANDLE_VALUE;
    DWORD       dwLowFileSize, dwHighFileSize;
    LPVOID      pBuffer;
    DWORD       cbBufferSize = BUFFER_SIZE;
    DWORD       cbBytesRead;
    DWORD       cbBytesWritten;
    DWORD       dwSourceFilePointer;

    DWORD       dwTargetFileAttributes;

    SPLASSERT( hSourceFile != NULL &&
               hSourceFile != INVALID_HANDLE_VALUE &&
               pSourceFileData != NULL &&
               lpNewFileName != NULL );


#if DBG
    //  <<<<< DEBUG ONLY >>>>>>
    //
    //  ASSERTION Check Source File Pointer is Zero.
    //
    dwSourceFilePointer = SetFilePointer( hSourceFile, 0, NULL, FILE_CURRENT );
    if ( dwSourceFilePointer != 0xffffffff ) {
        SPLASSERT( dwSourceFilePointer == 0 );
    }
#endif // DBG


    //
    //  Alloc I/O Buffer
    //


    pBuffer = AllocSplMem( BUFFER_SIZE );
    if ( pBuffer == NULL )
        goto    InternalCopyFileExit;


    //
    //  Create TagetFile with same File Attributes except for READ ONLY attribute
    //  which must be cleared.
    //
    dwTargetFileAttributes = pSourceFileData->dwFileAttributes & ~FILE_ATTRIBUTE_READONLY;
    if (pSourceFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY)
    {
        //
        // Clear the READ ONLY attribute if the corresponding source file attribute
        // is set. In fact at that point we don't know if the target file exists and
        // that is the reason to ignore the value returned by SetFileAttributes.
        // The file shouldn't exist on Whistler because of the dwTargetFileAttributes
        // value where the READ ONLY flag is cleared. There are slim chances to be there 
        // if the machine was upgraded from W2K ( where the bug still exists) if on that 
        // machine the driver was ever installed. 
        //
        SetFileAttributes( lpNewFileName, dwTargetFileAttributes );
    }

    hTargetFile = CreateFile( lpNewFileName,
                               GENERIC_WRITE,
                               FILE_SHARE_EXCLUSIVE,
                               NULL,
                               bFailIfExists ? CREATE_NEW : CREATE_ALWAYS,
                               dwTargetFileAttributes | FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL );

    if ( hTargetFile != INVALID_HANDLE_VALUE ) {

        //
        //  Copy The Data
        //

        while (( bReturnValue = ReadFile( hSourceFile, pBuffer, cbBufferSize, &cbBytesRead, NULL )) &&
                 cbBytesRead != 0 ) {

            //
            //  Add Code to Build CheckSum Here
            //

            bReturnValue = WriteFile( hTargetFile, pBuffer, cbBytesRead, &cbBytesWritten, NULL );

            if ( bReturnValue  == FALSE  ||
                 cbBytesWritten != cbBytesRead ) {

                bReturnValue = FALSE;
                break;
            }
        }



        if ( bReturnValue ) {

            //
            // Set TargetFile Times to be the same as the Source File
            //

            bReturnValue = SetFileTime( hTargetFile,
                                        &pSourceFileData->ftCreationTime,
                                        &pSourceFileData->ftLastAccessTime,
                                        &pSourceFileData->ftLastWriteTime );

            //
            //  Verify that the file size is correct.
            //

            if ( bReturnValue ) {

                dwLowFileSize = GetFileSize( hTargetFile, &dwHighFileSize );

                if ( dwLowFileSize != pSourceFileData->nFileSizeLow ||
                     dwHighFileSize != pSourceFileData->nFileSizeHigh ) {

                    DBGMSG(DBG_ERROR,
                           ("InternalCopyFile: sizes do not match for %ws: (%d %d) and (%d %d)",
                            lpNewFileName,
                            pSourceFileData->nFileSizeHigh,
                            pSourceFileData->nFileSizeLow,
                            dwHighFileSize,
                            dwLowFileSize));
                    bReturnValue = FALSE;
                    SetLastError(ERROR_FILE_INVALID);
                }
            }

            //
            //  Add Code here to Verify the CheckSum is correct.
            //

        }

        CloseHandle( hTargetFile );
    }

    FreeSplMem( pBuffer );

InternalCopyFileExit:

    if ( !bReturnValue ) {
        DBGMSG( DBG_WARN, ("InternalCopyFile hSourceFile %x %ws error %d\n", hSourceFile, lpNewFileName, GetLastError() ));
        SPLASSERT( GetLastError() != ERROR_SUCCESS );
    }

    return  bReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\inetsrv\aspapp\ipp_util.inc ===
<%
'------------------------------------------------------------
'
' Microsoft Internet Printing Project
'
' Copyright (c) Microsoft Corporation. All rights reserved.
'
'------------------------------------------------------------
%>

<%

Const L_DocumentList_Text   = "Document List"
Const L_DerivedFont_Text    = " face=""Tahoma, Verdana, Arial, MS Sans Serif"" "
Const L_DoubleDevFont_Text  = " face=""""Tahoma, Verdana, Arial, MS Sans Serif"""" "

Const PROGID_CLIENT_HELPER  = "OlePrn.PrinterURL"
Const PROGID_SNMP           = "OlePrn.OleSNMP"
Const PROGID_HELPER         = "OlePrn.AspHelp"
Const PROGID_CONVERTER      = "OlePrn.OleCvt"
Const PROGID_ADDPRINTER     = "OlePrn.AddPrint"
Const VIEW_EQUALS           = "&view="
Const ONCLICK_EQUALS        = " onclick="
Const QUOTE                 = """"
Const QUEUE_VIEW            = "ipp_0007.asp"
Const PROPERTY_VIEW         = "ipp_0006.asp"
Const UNAUTHORIZED_401      = "401 Unauthorized"
Const FAXDRIVER             = "Microsoft Shared Fax Driver"

Const COMPUTER              = "MS_Computer"
Const LOCAL_SERVER          = "MS_LocalServer"
Const DHTML_ENABLED         = "MS_DHTMLEnabled"
Const DEFAULT_PAGE          = "MS_DefaultPage"
Const PRINTER               = "MS_Printer"
Const URLPRINTER            = "MS_URLPrinter"
Const SNMP                  = "MS_SNMP"
Const IPADDRESS             = "MS_IPAddress"
Const COMMUNITY             = "MS_Community"
Const DEVICE                = "MS_Device"
Const PORTNAME              = "MS_Portname"
Const MODEL                 = "MS_Model"
Const ASP1                  = "MS_ASP1"
Const CONNECT               = "showconnect"
Const ATPRINTER             = "&MS_Printer="
Const ATURLPRINTER          = "&MS_URLPrinter="
Const ATSNMP                = "&MS_SNMP="
Const ATIPADDRESS           = "&MS_IPAddress="
Const ATCOMMUNITY           = "&MS_Community="
Const ATDEVICE              = "&MS_Device="
Const ATPORTNAME            = "&MS_Portname="
Const ATMODEL               = "&MS_Model="
Const ATASP1                = "&MS_ASP1="
Const ATPAGE                = "&page="
Const ATCONNECT             = "&showconnect="

Dim   DEF_FONT, DEF_BASEFONT_TAG, DEF_FONT_TAG, LARGE_FONT_TAG, MENU_FONT_TAG
Dim   SUBMENU_FONT, SUBMENU_FONT_TAG, CLIENT_FONT, DEF_DOUBLEFONT, DEF_DOUBLEFONT_TAG

DEF_FONT                    = L_DerivedFont_Text
DEF_DOUBLEFONT              = L_DoubleDevFont_Text
DEF_BASEFONT_TAG            = "<basefont  " & L_DerivedFont_Text & " size=2>"
DEF_FONT_TAG                = "<font " & L_DerivedFont_Text & " size=2>"
LARGE_FONT_TAG              = "<font " & L_DerivedFont_Text & " size=4>"
MENU_FONT_TAG               = "<font " & L_DerivedFont_Text & " size=2 color=white>"
SUBMENU_FONT                = L_DerivedFont_Text & " size=1 "
SUBMENU_FONT_TAG            = "<font " & L_DerivedFont_Text & " size=2>"
CLIENT_FONT                 = "<font " & L_DerivedFont_Text & ">"
Const END_FONT              = "</font>"

'Initialize UTF8 related information
Dim bUTF8
Dim OleCvt

Function bUTF8Capable
    Dim objBrowcap

    Set objBrowcap = server.CreateObject("MSWC.browsertype")
    If (objBrowcap.browser = "IE" Or objBrowcap.browser = "Netscape")  And objBrowcap.majorver >= "4" Then
        bUTF8Capable = True
    Else
        bUTF8Capable = False
    End If
End Function


Sub InitCodepage ()
    Set OleCvt = Server.CreateObject (PROGID_CONVERTER)

    bUTF8 = bUTF8Capable
    If bUTF8 Then
        Session.Codepage = 65001
    End If

End Sub

InitCodePage

Function SetCodePage ()
    If (bUTF8) Then 'If not UTF enabled, use the default charset
        SetCodePage = "<Meta Http-equiv=""Content-Type"" Content=""text/html; CHARSET=UTF-8"">"
    Else
        SetCodePage = ""
    End If
End Function

Function Write (strUnicode)
    Write = strUnicode
End Function

Function SubstituteString(strIn, strPattern, strReplacement)
    Dim iStrPos

    iStrPos = InStr(strIn,strPattern)
    SubstituteString = Left(strIn, iStrPos-1) & strReplacement & Mid(strIn, iStrPos + Len(strPattern))
End Function

Function RepString1( strIn, strRep )
    RepString1 = SubStituteString( strIn, "%1", strRep)
End Function

Function RepString2( strIn, strRep1, strRep2 )
    RepString2 = SubStituteString( RepString1(strIn, strRep1) , "%2", strRep2)
End Function

Function RepString3( strIn, strRep1, strRep2, strRep3 )
    RepString3 = SubStituteString( RepString2(strIn, strRep1, StrRep2), "%3", strRep3)
End Function

Function GenErrorPage (iCode, strSource, strDscp, strNote)
    Dim strHTML
    Const L_ErrCode_Text      = "<b>Error Code:</b>"
    Const L_ErrDscp_Text      = "<b>Description:</b>"
    Const L_ErrNote_Text      = "<b>Note:</b>"
    Const L_ErrTitle_Text     = "Internet Printing Error"
    Const L_ErrSource_Text    = "The error occurred in <b>%1</b>"
    Const L_ErrOccurProc_Text = "<p>An <b>error</b> occurred processing your request.</p>"

    strHTML = "<html><head><title>" & L_ErrTitle_Text & "</title>"
    strHTML = strHTML & SetCodePage
    strHTML = strHTML & "</head><body bgcolor=#FFFFFF>" & DEF_BASEFONT_TAG
    strHTML = strHTML & L_ErrOccurProc_Text

    If strSource <> "" Then
        strHTML = strHTML & RepString1(L_ErrSource_Text, strSource)
    End If

    strHTML = strHTML & "<table>"

    strHTML = strHTML & "<tr><td>" & L_ErrCode_Text & "</td><td>" & (Hex (iCode)) & "</td></tr>"

    If strDscp <> "" Then
        strHTML = strHTML & "<tr><td>" & L_ErrDscp_Text & "</td><td>" & strDscp & "</td></tr>"
    End If

    If strNote <> "" Then
        strHTML = strHTML & "<tr><td>" & L_ErrNote_Text & "</td><td>" & strNote & "</td></tr>"
    End If

    strHTML = strHTML & "</table></body></html>"
    GenErrorPage = strHTML
End Function

Sub ErrorHandler(strNotes)
    Dim strDscp, strSource

    Dim str401Error

    If Err.Number = 70 Or Err.Number = &H80070005 Then
        Const L_ErrTitle_Text = "Internet Printing Authentication Error"
        Const L_ErrTitle2_Text = "Authentication Failed"
        Const L_ErrLine1_Text = "The error indicates that the action you chose requires a higher privilege than what you have with your account."
        Const L_ErrLine2_Text = "Please contact your system administrator to verify that you have the privilege on the requested action."

        str401Error = "<html><head><title>" & L_ErrTitle_Text & "</title>" &_
            SetCodePage &_
            "</head>" &_
            "<body bgcolor=#FFFFFF>" &_
            DEF_FONT_TAG &_
            "<p><H2>" & L_ErrTitle2_Text & "</H2></p>" &_
            "<p>" & L_ErrLine1_Text &_
            "<br>" &_
            "<br>" & L_ErrLine2_Text & "</p>" &_
            "</font></body></html>"
        response.write (Write(str401Error))
        response.status = UNAUTHORIZED_401
    Else
        If Err.Number = &H80070709 Then
            Const L_ErrInvalidName_Text = "Printer not found on server, unable to connect."
            Err.Description = L_ErrInvalidName_Text
        End If

        response.write(Write(GenErrorPage (Err.Number, Err.Source, Err.Description, strCleanString(strNotes))))
    End If
    response.Expires = 0
    response.end

End Sub

Function bDHTMLSupported()
    On Error Resume Next
    Err.Clear
    Dim objBrowcap

    Set objBrowcap = server.CreateObject("MSWC.browsertype")
    If Not Err And objBrowcap.browser = "IE" And objBrowcap.majorver >= "4" Then
        bDHTMLSupported = True
    Else
        bDHTMLSupported = False
    End If
End Function

Sub CheckSession()
    ' check to see if the session has timed out
    If Session(COMPUTER) = "" Then
        response.redirect ("ipp_0003.asp")
        response.end
    End If
End Sub

Function strPrinterStatus(iStatus)
    Dim L_PrinterStatus_Text(24)
    Const L_Seperator_Text = " - "
    Const L_PrinterReady_Text = "Ready"

    L_PrinterStatus_Text(0)  = "Paused"
    L_PrinterStatus_Text(1)  = "Error"
    L_PrinterStatus_Text(2)  = "Deleting"
    L_PrinterStatus_Text(3)  = "Paper Jam"
    L_PrinterStatus_Text(4)  = "Out of Paper"
    L_PrinterStatus_Text(5)  = "Manual Feed Required"
    L_PrinterStatus_Text(6)  = "Paper Problem"
    L_PrinterStatus_Text(7)  = "Printer Offline"
    L_PrinterStatus_Text(8)  = "IO Active"
    L_PrinterStatus_Text(9)  = "Busy"
    L_PrinterStatus_Text(10) = "Printing"
    L_PrinterStatus_Text(11) = "Output Bin Full"
    L_PrinterStatus_Text(12) = "Not Available"
    L_PrinterStatus_Text(13) = "Waiting"
    L_PrinterStatus_Text(14) = "Processing"
    L_PrinterStatus_Text(15) = "Initializing"
    L_PrinterStatus_Text(16) = "Warming Up"
    L_PrinterStatus_Text(17) = "Toner Low"
    L_PrinterStatus_Text(18) = "No Toner"
    L_PrinterStatus_Text(19) = "Page Punt"
    L_PrinterStatus_Text(20) = "User Intervention Required"
    L_PrinterStatus_Text(21) = "Out of Memory"
    L_PrinterStatus_Text(22) = "Door Open"
    L_PrinterStatus_Text(23) = "Server Status Unknown"
    L_PrinterStatus_Text(24) = "Power Save Mode"

    Dim bit, i
    bit = 1
    i = 0
    Dim strHTML, bFirst

    bFirst = True
    strHTML = ""

    For i = 0 To 24
    If iStatus And bit Then
        If Not bFirst Then
        strHTML = strHTML + L_Seperator_Text
        End If
        strHTML = strHTML + L_PrinterStatus_Text(i)
            bFirst = False
    End If
        bit = bit * 2
    Next
    If bFirst Then
        strHTML = "<font color=green>" & L_PrinterReady_Text & "</font>"
    Else
        strHTML = "<font color=red>" & strHTML & "</font>"
    End If

    strPrinterStatus = strHTML
End Function

Function strFormatJobSize(iJobSize)
    Const  L_Bytes_Text     = "%1 bytes"
    Const  L_KiloBytes_Text = "%1 Kb"
    Const  L_MegaBytes_Text = "%1 Mb"
	

    If iJobSize < 1024 Then
        strFormatJobSize = RepString1(L_Bytes_Text, CStr(iJobSize) )
    ElseIf iJobSize < 1048576 Then
        strFormatJobSize = RepString1(L_KiloBytes_Text, formatnumber(iJobSize / 1024, 1) )
    Else
        strFormatJobSize = RepString1(L_MegaBytes_Text, formatnumber(iJobSize / (1024 * 1024), 1) )
    End If
End Function

Function strFormatString(str)
    If str = "" Then
        strFormatString = "&nbsp;"
    Else
        strFormatString = str
    End If
End Function

Function strCleanString (str)

    Dim strClean, i, iLength, ch

    strClean = ""
    iLength = Len (str)

    For i = 1 To iLength
        ch = Mid (str, i, 1)

        Select Case ch
        Case "<"
            strClean = strClean & "&lt;"
        Case ">"
            strClean = strClean & "&gt;"
        Case """"
            strClean = strClean & "&quot;"
        Case "&"
            strClean = strClean & "&amp;"
        Case Else
            strClean = strClean & ch
        End Select
    Next
    strCleanString = strClean

End Function

Function strCleanRequest (str)

    strCleanRequest = strCleanString (Request(str))

End Function

Function JobEtaInfo (objPrinter)
    Dim strTime, iJobCount, iMinute
    Dim strHTML

    Const L_NoJobPending_Text = "&nbsp;&nbsp;&nbsp;&nbsp;<b>Waiting Time:</b> 0 <br><b>Pending Documents:</b> 0 "
    Const L_ErrorNoJobCompletion_Text = "<font color=red>Error in printing</font> "
    Const L_LongHour_Text = "> 8 hr"
    Const L_About_Text = "about "
    Const L_Hour_Text = " hr"
    Const L_Minute_Text = " min"

    Const L_QueueStatus_Text = "<b>Printer Queue:</b> "
    Const L_WaitingTime_Text = " &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Waiting Time:</b> "
    Const L_Unknown_Text = "Unknown"
    Const L_JobPending_Text = "<b>Pending Documents:</b> "
    Const L_AvgSize_Text = " &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Average size:</b> "
    Const L_Pages_Text =  " page(s)"


    strHTML = L_QueueStatus_Text & strPrinterStatus (objPrinter.Status) & L_WaitingTime_Text

    objPrinter.CalcJobETA

    If ( objPrinter.Status And &H9F ) Then
        strHTML = strHTML & L_Unknown_Text
    'End If
    'If 1 Then
    Else
        If objPrinter.PendingJobCount = 0 Then
            strHTML = strHTML & "0"
        Else
            iMinute = objPrinter.JobCompletionMinute
            'iMinute = 240  'For testing purpose
            If iMinute <> -1 Then
                If iMinute > 480 Then
                    strTime = L_LongHour_Text
                Elseif iMinute > 60 Then
                    strTime = L_About_Text & CStr (Int (iMinute / 60)) & L_Hour_Text
                Else
                    strTime = L_About_Text & CStr (iMinute) & L_Minute_Text
                End If
                strHTML = strHTML & strTime
            Else
                strHTML = strHTML & L_Unknown_Text
            End If
        End If
    End If

    strHTML = strHTML & "<br>"
    iJobCount = objPrinter.PendingJobCount
    strHTML = strHTML & L_JobPending_Text & CStr (iJobCount)

    If iJobCount > 0 Then
        strHTML = strHTML & L_AvgSize_Text
        If ObjPrinter.AvgJobSizeUnit = 1 Then 'Page
            strHTML = strHTML & CStr (ObjPrinter.AvgJobSize) + L_Pages_Text
        Else
            strHTML = strHTML & strFormatJobSize(ObjPrinter.AvgJobSize)
        End If
    End If

    JobEtaInfo = "<font " & DEF_FONT & "size= -1>" & strHTML & "</font>"

End Function

Function GetFriendlyName (strPrtName, strComputer)

    Dim lOffset, strServerName

    If Left (strPrtName, 2) = "\\" Then
        lOffset = InStr (3, strPrtName, "\")
        strServerName = Mid (strPrtName, 3, lOffset - 3)
        If strServerName = strComputer Then 'Cut the server name only if it is same as the computer name
            strPrtName = Mid (strPrtName, lOffset + 1)
        End If
    End If
    GetFriendlyName = strPrtName

End Function

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\debug.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation
All rights reserved

Module Name:

    debug.c

Abstract:

    Simple debug routines to log job references.  This will capture
    a backtrace of all pIniJob->cRef changes into a memory log.

    To enable, do the following:

    1. Define DEBUG_JOB_CREF in sources.
    2. Add this file to sources.
    3. Run with debug version of spoolss.dll (this uses the debug
       log routines from spllib that are in spoolss.dll).

    When you have a job that won't be deleted, dump it out and
    look at the last field (usually it's right before the
    0xdeadbeef trailer in pIniJob).  Then use the spllib debug
    extensions to dump it (splx.dll, built from spooler\exts).

    !splx.ddt -x {pvRef Address}

    The -b option is handy to look at backtraces (available on x86
    only).  Note that ddt list most recent entries first (see
    !splx.help for more info.

    This code should only be used when debugging specific pIniJob->cRef
    problems.

Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef DEBUG_JOB_CREF

VOID
DbgJobInit(
    PINIJOB pIniJob
    )
{
    if( gpDbgPointers ){
        pIniJob->pvRef = gpDbgPointers->pfnAllocBackTrace();
    }
}

VOID
DbgJobFree(
    PINIJOB pIniJob
    )
{
    if( pIniJob->pvRef ){
        gpDbgPointers->pfnFreeBackTrace( (HANDLE)pIniJob->pvRef );
    }
}

VOID
DbgJobDecRef(
    PINIJOB pIniJob
    )
{
    HANDLE hBackTrace = (HANDLE)pIniJob->pvRef;

    SPLASSERT(pIniJob->cRef);
    pIniJob->cRef--;

    if (!hBackTrace) {
        return;
    }

    gpDbgPointers->pfnCaptureBackTrace( hBackTrace,
                                        pIniJob->cRef+1,
                                        pIniJob->cRef,
                                        0 );
}


VOID
DbgJobIncRef(
    PINIJOB pIniJob
    )
{
    HANDLE hBackTrace = (HANDLE)pIniJob->pvRef;

    pIniJob->cRef++;

    if (!hBackTrace) {
        return;
    }

    gpDbgPointers->pfnCaptureBackTrace( hBackTrace,
                                        pIniJob->cRef-1,
                                        pIniJob->cRef,
                                        0 );
}

#endif // def DEBUG_JOB_CREF



#ifdef DEBUG_PRINTER_CREF

#undef DbgPrinterInit
#undef DbgPrinterFree
#undef DbgPrinterDecRef
#undef DbgPrinterIncRef

VOID
DbgPrinterInit(
    PINIPRINTER pIniPrinter
    )
{
    if( gpDbgPointers ){
        pIniPrinter->pvRef = gpDbgPointers->pfnAllocBackTrace();
    }
}

VOID
DbgPrinterFree(
    PINIPRINTER pIniPrinter
    )
{
    if( pIniPrinter->pvRef ){
        gpDbgPointers->pfnFreeBackTrace( (HANDLE)pIniPrinter->pvRef );
    }
}

VOID
DbgPrinterDecRef(
    PINIPRINTER pIniPrinter
    )
{
    HANDLE hBackTrace = (HANDLE)pIniPrinter->pvRef;

    SPLASSERT(pIniPrinter->cRef+1);

    if (!hBackTrace) {
        return;
    }

    gpDbgPointers->pfnCaptureBackTrace( hBackTrace,
                                        pIniPrinter->cRef+1,
                                        pIniPrinter->cRef,
                                        0 );
}


VOID
DbgPrinterIncRef(
    PINIPRINTER pIniPrinter
    )
{
    HANDLE hBackTrace = (HANDLE)pIniPrinter->pvRef;

    if (!hBackTrace) {
        return;
    }

    gpDbgPointers->pfnCaptureBackTrace( hBackTrace,
                                        pIniPrinter->cRef-1,
                                        pIniPrinter->cRef,
                                        0 );
}

#endif // def DEBUG_PRINTER_CREF


#ifdef DEBUG_STARTENDDOC

HANDLE ghbtStartEndDoc;

VOID
DbgStartEndDoc(
    HANDLE hPort,
    PINIJOB pIniJob,
    DWORD dwFlags
    )
{
    if( !ghbtStartEndDoc ){

        ghbtStartEndDoc = gpDbgPointers->pfnAllocBackTraceFile();

        if( !ghbtStartEndDoc ){

            SPLASSERT( FALSE );
            return;
        }
    }

    gpDbgPointers->pfnCaptureBackTrace( ghbtStartEndDoc,
                                        (DWORD)hPort,
                                        (DWORD)pIniJob,
                                        dwFlags );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\devqury.c ===
/*++

Copyright (c) 1994 - 1996  Microsoft Corporation

Module Name:

    devqury.c

Abstract:

    This module provides all the scheduling services for the Local Spooler

Author:

    Krishna Ganugapati (KrishnaG) 15-June-1994

Revision History:


--*/

#include <precomp.h>

BOOL    (*pfnOpenPrinter)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS);
BOOL    (*pfnClosePrinter)(HANDLE);
BOOL    (*pfnDevQueryPrint)(HANDLE, LPDEVMODE, DWORD *, LPWSTR, DWORD);
BOOL    (*pfnPrinterEvent)(LPWSTR, INT, DWORD, LPARAM);
LONG    (*pfnDocumentProperties)(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODE, DWORD);

BOOL
InitializeWinSpoolDrv(
    VOID
    )
{
    fnWinSpoolDrv    fnList;

    if (!SplInitializeWinSpoolDrv(&fnList)) {
        return FALSE;
    }

    pfnOpenPrinter   =  fnList.pfnOpenPrinter;
    pfnClosePrinter  =  fnList.pfnClosePrinter;
    pfnDevQueryPrint =  fnList.pfnDevQueryPrint;
    pfnPrinterEvent  =  fnList.pfnPrinterEvent;
    pfnDocumentProperties  =  fnList.pfnDocumentProperties;

    return TRUE;
}

BOOL
CallDevQueryPrint(
    LPWSTR    pPrinterName,
    LPDEVMODE pDevMode,
    LPWSTR    ErrorString,
    DWORD     dwErrorString,
    DWORD     dwPrinterFlags,
    DWORD     dwJobFlags
    )
{

    HANDLE hPrinter;
    DWORD  dwResID=0;

    //
    // Do not process for Direct printing
    // If a job is submitted as direct, then
    // ignore the devquery print stuff
    //

    if ( dwJobFlags ) {

        return TRUE;
    }

    if (!pDevMode) {

        return TRUE;
    }

    if  (dwPrinterFlags && pfnOpenPrinter && pfnDevQueryPrint && pfnClosePrinter) {

        if ( (*pfnOpenPrinter)(pPrinterName, &hPrinter, NULL) ) {

             (*pfnDevQueryPrint)(hPrinter, pDevMode, &dwResID, ErrorString, dwErrorString);
             (*pfnClosePrinter)(hPrinter);
        }
    }

    return(dwResID == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\ds.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//  All rights reserved.
//
//  File:       ds.hxx
//
//  Contents:   Print DS
//
//
//  History:    Nov 1996  SWilson
//
//----------------------------------------------------------------------------


#ifdef __cplusplus
extern "C" {
#endif

DWORD
SetPrinterDs(
    HANDLE          hPrinter,
    DWORD           dwAction,
    BOOL            bSynchronous
);

VOID
InitializeDS(
    PINISPOOLER pIniSpooler
    );

VOID
UpdateDsSpoolerKey(
    HANDLE  hPrinter,
    DWORD   dwVector
);

VOID
UpdateDsDriverKey(
    HANDLE hPrinter
);

DWORD
RecreateDsKey(
    HANDLE  hPrinter,
    PWSTR   pszKey
);


DWORD
InitializeDSClusterInfo(
    PINISPOOLER     pIniSpooler,
    HANDLE          *hToken
);

HRESULT
GetDNSMachineName(
    PWSTR pszShortServerName,
    PWSTR *ppszServerName
);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\ds.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

    This module provides functionality for ADs within spooler

Author:

    Steve Wilson (NT) December 1996

Revision History:

--*/


#include <precomp.h>
#pragma hdrstop

#include "ds.hxx"

#define LOG_EVENT_ERROR_BUFFER_SIZE     11
#define PPM_FACTOR                      48
#define LOTS_OF_FORMS                   300     // This is a little more than twice the number of built-in forms

extern BOOL gbInDomain;
extern BOOL gdwLogDsEvents;

extern "C" HANDLE    ghDsUpdateThread;
extern "C" DWORD     gdwDsUpdateThreadId;

extern "C" BOOL (*pfnOpenPrinter)(LPTSTR, LPHANDLE, LPPRINTER_DEFAULTS);
extern "C" BOOL (*pfnClosePrinter)(HANDLE);

extern "C" DWORD
SetPrinterDs(
    HANDLE          hPrinter,
    DWORD           dwAction,
    BOOL            bSynchronous
)
{
    PSPOOL          pSpool = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    HRESULT         hr;
    HANDLE          hToken = NULL;
    PWSTR           pszObjectGUID, pszCN, pszDN;
    DWORD           DsKeyUpdate, Attributes;
    BOOL            DoChange = FALSE;
    NOTIFYVECTOR    NotifyVector;

    SplInSem();

    if (!gbInDomain)
        return ERROR_DS_UNAVAILABLE;

    // Don't allow masquerading printer publishing
    if (pSpool->pIniPort && !(pSpool->pIniPort->Status & PP_MONITOR))
        return ERROR_INVALID_PARAMETER;

    hToken = RevertToPrinterSelf(); // All DS accesses are done by LocalSystem account


    // If any of these change we'll update the registry entry
    DsKeyUpdate = pIniPrinter->DsKeyUpdate;
    pszObjectGUID = pIniPrinter->pszObjectGUID;
    pszCN = pIniPrinter->pszCN;
    pszDN = pIniPrinter->pszDN;
    Attributes = pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED;


    // Attribute states desired state, not current state
    switch (dwAction) {
        case DSPRINT_UPDATE:
            if (!(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED)) {
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND);

            } else if (bSynchronous) {

                // We are in the background thread.
                if (pIniPrinter->DsKeyUpdate) {
                    INCPRINTERREF(pIniPrinter);
                    LeaveSplSem();
                    hr = DsPrinterPublish(hPrinter);
                    EnterSplSem();
                    DECPRINTERREF(pIniPrinter);
                } else {
                    hr = ERROR_SUCCESS;
                }
            } else {

                // Here we are in the foreground thread.
                if (pIniPrinter->DsKeyUpdateForeground) {
                    pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_PUBLISHED;
                    pIniPrinter->dwAction = DSPRINT_PUBLISH;
                    hr = ERROR_IO_PENDING;
                } else {
                    hr = ERROR_SUCCESS;
                }
            }
            break;

        case DSPRINT_PUBLISH:
            if (!(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED) &&
                  PrinterPublishProhibited()) {

                // There is a policy against publishing printers from this machine.
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, ERROR_ACCESS_DENIED);

            } else {
                if (bSynchronous) {
                    INCPRINTERREF(pIniPrinter);
                    LeaveSplSem();
                    hr = DsPrinterPublish(hPrinter);
                    EnterSplSem();
                    DECPRINTERREF(pIniPrinter);
                } else {

                    // This is a Pending Unpublish state
                    if (!(pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED) && pIniPrinter->pszObjectGUID)
                        pIniPrinter->dwAction = DSPRINT_REPUBLISH;
                    else
                        pIniPrinter->dwAction = DSPRINT_PUBLISH;

                    pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_PUBLISHED;
                    hr = ERROR_IO_PENDING;
                }
            }
            break;

        case DSPRINT_REPUBLISH:
            if (PrinterPublishProhibited()) {

                // There is a policy against publishing printers from this machine.
                hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, ERROR_ACCESS_DENIED);

            } else {
                // Synchronous mode is from background thread and it should only call Publish/Unpublish
                if (bSynchronous) {
                    hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_PARAMETER);
                    SPLASSERT(FALSE);
                } else {
                    pIniPrinter->dwAction = DSPRINT_REPUBLISH;
                    pIniPrinter->Attributes |= PRINTER_ATTRIBUTE_PUBLISHED;
                    hr = ERROR_IO_PENDING;
                }
            }
            break;

        case DSPRINT_UNPUBLISH:
            if (bSynchronous) {
                INCPRINTERREF(pIniPrinter);
                LeaveSplSem();
                hr = DsPrinterUnpublish(hPrinter);
                EnterSplSem();
                DECPRINTERREF(pIniPrinter);
            } else {
                pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_PUBLISHED;
                pIniPrinter->dwAction = DSPRINT_UNPUBLISH;
                hr = ERROR_IO_PENDING;
            }
            break;

        default:
            hr = ERROR_INVALID_PARAMETER;
            break;
    }

    // Update Registry and set notifications
    if (pszCN != pIniPrinter->pszCN ||
        pszDN != pIniPrinter->pszDN ||
        pszObjectGUID != pIniPrinter->pszObjectGUID ||
        DsKeyUpdate != pIniPrinter->DsKeyUpdate ||
        Attributes != (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED)) {

        ZERONV(NotifyVector);

        if (pszObjectGUID != pIniPrinter->pszObjectGUID) {
            NotifyVector[PRINTER_NOTIFY_TYPE] |= BIT(I_PRINTER_OBJECT_GUID);
            DoChange = TRUE;
        }
        if (Attributes != (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_PUBLISHED)) {
            NotifyVector[PRINTER_NOTIFY_TYPE] |= BIT(I_PRINTER_ATTRIBUTES);
            DoChange = TRUE;
        }
        if (DoChange) {
            UpdatePrinterIni(pIniPrinter, UPDATE_CHANGEID);
            SetPrinterChange(pIniPrinter,
                             NULL,
                             NotifyVector,
                             PRINTER_CHANGE_SET_PRINTER,
                             pIniPrinter->pIniSpooler);

        } else if (DsKeyUpdate != pIniPrinter->DsKeyUpdate) {
            UpdatePrinterIni(pIniPrinter, UPDATE_DS_ONLY);
        }
    }

    SplInSem();

    if (hr == ERROR_IO_PENDING && !bSynchronous)
        SpawnDsUpdate(1);

    if (hToken)
        ImpersonatePrinterClient(hToken);

    return (DWORD) hr;
}


HRESULT
DsPrinterPublish(
    HANDLE  hPrinter
)
{
    HRESULT         hr;
    PSPOOL          pSpool       = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter  = pSpool->pIniPrinter;
    WCHAR           ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    BOOL            bUpdating = !!pIniPrinter->pszObjectGUID;
    DWORD           dwDsKeyUpdate;

    SplOutSem();

#if DBG
    EnterSplSem();
    DBGMSG( DBG_EXEC, ("DsPrinterPublish: %ws\n", pIniPrinter->pName));
    LeaveSplSem();
#endif


    // On first publish update all keys and tell the driver to write its non-devcap properties
    if (!bUpdating) {

        // We execute this on the background thread and hence donot need any
        // to be in the critical section.
        pIniPrinter->DsKeyUpdate |= DS_KEY_PUBLISH | DS_KEY_SPOOLER | DS_KEY_DRIVER | DS_KEY_USER;
    }


    // Update DS properties
    dwDsKeyUpdate = pIniPrinter->DsKeyUpdate & (DS_KEY_SPOOLER | DS_KEY_DRIVER | DS_KEY_USER);
    hr = DsPrinterUpdate(hPrinter);
    BAIL_ON_FAILURE(hr);
    DBGMSG( DBG_EXEC, ("PublishDsUpdate: Printer Updated\n" ) );

error:

    if (SUCCEEDED(hr)) {
        // Only write a success event if something changed
        if (dwDsKeyUpdate != pIniPrinter->DsKeyUpdate) {
            SplLogEvent( pIniPrinter->pIniSpooler,
                         gdwLogDsEvents & LOG_INFO,
                         bUpdating ? MSG_PRINTER_UPDATED
                                   : MSG_PRINTER_PUBLISHED,
                         FALSE,
                         pIniPrinter->pszCN,
                         pIniPrinter->pszDN,
                         NULL );
        }
    } else if (pIniPrinter->pszCN && pIniPrinter->pszDN) {
        wsprintf(ErrorBuffer, L"%x", hr);
        SplLogEvent( pIniPrinter->pIniSpooler,
                     gdwLogDsEvents & LOG_ERROR,
                     MSG_PRINTER_NOT_PUBLISHED,
                     FALSE,
                     pIniPrinter->pszCN,
                     pIniPrinter->pszDN,
                     ErrorBuffer,
                     NULL );
    }

    if (pIniPrinter->DsKeyUpdate)
        hr = ERROR_IO_PENDING;

    return hr;
}


HRESULT
DsPrinterUpdate(
    HANDLE  hPrinter
)
{
    PSPOOL          pSpool = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    HRESULT         hr = S_OK;
    DWORD           dwResult;
    BOOL            bImpersonating = FALSE;
    IADs            *pADs = NULL;

    SplOutSem();


    if(!(pIniPrinter->DsKeyUpdate & (DS_KEY_SPOOLER | DS_KEY_DRIVER | DS_KEY_USER))) {
        pIniPrinter->DsKeyUpdate = 0;
    }

    // If we aren't truly published yet, be sure to publish mandatory properties first!
    if (!pIniPrinter->pszObjectGUID) {
        //
        // Fail if we're on a cluster but couldn't get the Cluster GUID
        // The Cluster GUID is required later in AddClusterAce
        //
        if ((pIniPrinter->pIniSpooler->SpoolerFlags & SPL_CLUSTER_REG) &&
            !pIniPrinter->pIniSpooler->pszClusterGUID) {
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_CLUSTER_NO_SECURITY_CONTEXT);
            BAIL_ON_FAILURE(hr);
        }

        // Get or Create printQueue object
        hr = GetPrintQueue(hPrinter, &pADs);
        BAIL_ON_FAILURE(hr);

        hr = PublishMandatoryProperties(hPrinter, pADs);
        BAIL_ON_FAILURE(hr);

    } else {

        // If we are a Cluster, impersonate the Cluster User
        if (pIniPrinter->pIniSpooler->hClusterToken != INVALID_HANDLE_VALUE) {
            // Impersonate the client
            if (!ImpersonatePrinterClient(pIniPrinter->pIniSpooler->hClusterToken)) {
                dwResult = GetLastError();
                DBGMSG(DBG_WARNING,("DsPrinterPublish FAILED: %d\n", dwResult));
                hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
                BAIL_ON_FAILURE(hr);
            }
            bImpersonating = TRUE;
        }

        // Get or Create printQueue object
        hr = GetPrintQueue(hPrinter, &pADs);
        BAIL_ON_FAILURE(hr);
    }


    // Update User - updates from Registry
    //
    // CopyRegistry2Ds for DS_KEY_USER values must
    // be called in the first place since there could be duplicate values
    // that might overwrite properties contained by either
    // DS_KEY_SPOOLER or DS_KEY_DRIVER.
    // Ignore the return value since publishing of DS_KEY_USER values
    // is not critical
    //
    if (pIniPrinter->DsKeyUpdate & DS_KEY_USER) {
        CopyRegistry2Ds(hPrinter, DS_KEY_USER, pADs);
    }

    // Update Spooler - updates from Registry
    if (pIniPrinter->DsKeyUpdate & DS_KEY_SPOOLER) {
        hr = CopyRegistry2Ds(hPrinter, DS_KEY_SPOOLER, pADs);
        BAIL_ON_FAILURE(hr);
    }


    // Update Driver - updates from Registry
    if (pIniPrinter->DsKeyUpdate & DS_KEY_DRIVER) {
        hr = CopyRegistry2Ds(hPrinter, DS_KEY_DRIVER, pADs);

        // Ignore missing key
        if (HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND)
            hr = S_OK;

        BAIL_ON_FAILURE(hr);
    }


error:

    if (pADs)
        pADs->Release();

    if (bImpersonating)
        pIniPrinter->pIniSpooler->hClusterToken = RevertToPrinterSelf();

    return hr;
}


HRESULT
DsDeletePQObject(
    HANDLE  hPrinter
)
{
    PSPOOL          pSpool = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    IADsContainer   *pADsContainer    = NULL;
    IADs            *pADs = NULL;
    HRESULT         hr = E_FAIL;
    WCHAR           ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    BOOL            bImpersonating = FALSE;
    DWORD           dwError;

    //
    // This routine is called when AddClusterAce failed. Even if we faild deleteing the object,
    // we really want to clean up the pIniPrinter structure so that we prevent the case where
    // the object stays forever in pending un/publishing.
    // That's because the other cluster node fails to delete/update it
    // since the printQueue object doesn't have the cluster user ace added. Pruner also fails to delete it
    // since the PrintQueue's GUID matches the pIniPrinter's GUID.
    //
    SplOutSem();

    hr = GetPrintQueueContainer(hPrinter, &pADsContainer, &pADs);
    BAIL_ON_FAILURE(hr);

    // Delete Printer Object
    hr = pADsContainer->Delete(SPLDS_PRINTER_CLASS, pIniPrinter->pszCN);
    DBGMSG(DBG_EXEC,("DsPrinterUnpublish FAILED: %x, %ws\n", hr, pIniPrinter->pszCN));
    BAIL_ON_FAILURE(hr);

error:

    if (pADs)
        pADs->Release();

    if (pADsContainer)
        pADsContainer->Release();

    pIniPrinter->DsKeyUpdate = 0;

    FreeSplStr(pIniPrinter->pszObjectGUID);
    pIniPrinter->pszObjectGUID = NULL;

    FreeSplStr(pIniPrinter->pszCN);
    pIniPrinter->pszCN = NULL;

    FreeSplStr(pIniPrinter->pszDN);
    pIniPrinter->pszDN = NULL;

    return hr;
}

HRESULT
DsPrinterUnpublish(
    HANDLE  hPrinter
)
{
    PSPOOL          pSpool = (PSPOOL) hPrinter;
    PINIPRINTER     pIniPrinter = pSpool->pIniPrinter;
    IADsContainer   *pADsContainer    = NULL;
    IADs            *pADs = NULL;
    HRESULT         hr = E_FAIL;
    WCHAR           ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    BOOL            bImpersonating = FALSE;
    DWORD           dwError;

    SplOutSem();

    // If we are a Cluster, impersonate the Cluster User
    if (pIniPrinter->pIniSpooler->hClusterToken != INVALID_HANDLE_VALUE) {
        // Impersonate the client
        if (!ImpersonatePrinterClient(pIniPrinter->pIniSpooler->hClusterToken)) {
            dwError = GetLastError();
            DBGMSG(DBG_WARNING,("DsPrinterUnpublish FAILED: %d\n", dwError));
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwError);
            goto error;
        }
        bImpersonating = TRUE;
    }

    hr = GetPrintQueueContainer(hPrinter, &pADsContainer, &pADs);
    BAIL_ON_FAILURE(hr);

    // Delete Printer Object
    hr = pADsContainer->Delete(SPLDS_PRINTER_CLASS, pIniPrinter->pszCN);
    DBGMSG(DBG_EXEC,("DsPrinterUnpublish FAILED: %x, %ws\n", hr, pIniPrinter->pszCN));
    BAIL_ON_FAILURE(hr);


error:

    if (bImpersonating)
        pIniPrinter->pIniSpooler->hClusterToken = RevertToPrinterSelf();

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) ||
        HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND ||
        HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND) {
        hr = S_OK;
        SplLogEvent(  pIniPrinter->pIniSpooler,
                      gdwLogDsEvents & LOG_INFO,
                      MSG_MISSING_PRINTER_UNPUBLISHED,
                      FALSE,
                      pIniPrinter->pName,
                      NULL );

    } else if (SUCCEEDED(hr)) {
            SplLogEvent(  pIniPrinter->pIniSpooler,
                          gdwLogDsEvents & LOG_INFO,
                          MSG_PRINTER_UNPUBLISHED,
                          FALSE,
                          pIniPrinter->pszCN,
                          pIniPrinter->pszDN,
                          NULL );

    } else if(pIniPrinter->pszCN && pIniPrinter->pszDN) {
        wsprintf(ErrorBuffer, L"%x", hr);
        SplLogEvent(  pIniPrinter->pIniSpooler,
                      gdwLogDsEvents & LOG_ERROR,
                      MSG_CANT_DELETE_PRINTQUEUE,
                      FALSE,
                      pIniPrinter->pszCN,
                      pIniPrinter->pszDN,
                      ErrorBuffer,
                      NULL );
    }


    if (SUCCEEDED(hr)) {
        pIniPrinter->DsKeyUpdate = 0;

        FreeSplStr(pIniPrinter->pszObjectGUID);
        pIniPrinter->pszObjectGUID = NULL;

        FreeSplStr(pIniPrinter->pszCN);
        pIniPrinter->pszCN = NULL;

        FreeSplStr(pIniPrinter->pszDN);
        pIniPrinter->pszDN = NULL;

    } else {
        pIniPrinter->DsKeyUpdate = DS_KEY_UNPUBLISH;
    }

    if (pADs)
        pADs->Release();

    if (pADsContainer)
        pADsContainer->Release();

    if (pIniPrinter->DsKeyUpdate)
        hr = ERROR_IO_PENDING;

    return hr;
}

LPCWSTR
MapDSFlag2DSKey(
    DWORD   Flag
)
{
    DWORD   idx;
    LPCWSTR pKey = NULL;

    struct DSEntry
    {
        DWORD       Flag;
        LPCWSTR     pKey;
    };

    static DSEntry DSKeys [] = {
    {DS_KEY_SPOOLER ,   SPLDS_SPOOLER_KEY},
    {DS_KEY_DRIVER  ,   SPLDS_DRIVER_KEY},
    {DS_KEY_USER    ,   SPLDS_USER_KEY},
    {0              ,   NULL},
    };

    for (idx = 0; DSKeys[idx].pKey; idx++) {
        if(DSKeys[idx].Flag & Flag) {
            pKey = DSKeys[idx].pKey;
        }
    }
    return pKey;
}

HRESULT
CopyRegistry2Ds(
    HANDLE          hPrinter,
    DWORD           Flag,
    IADs            *pADs
)
{
    HRESULT     hr = ERROR_SUCCESS;
    DWORD       i;
    DWORD       dwLDAPError;
    DWORD       cbEnumValues = 0;
    PPRINTER_ENUM_VALUES pEnumValues = NULL;
    DWORD       nEnumValues;
    DWORD       dwResult;
    WCHAR       ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    BSTR        bstrADsPath = NULL;
    PINIPRINTER pIniPrinter = ((PSPOOL)hPrinter)->pIniPrinter;
    LPCWSTR     pKey = MapDSFlag2DSKey(Flag);


#if DBG
    EnterSplSem();
    DBGMSG(DBG_EXEC, ("Mass Publish %ws", ((PSPOOL)hPrinter)->pIniPrinter->pName));
    LeaveSplSem();
#endif

    // Enumerate and Publish Key
    dwResult = SplEnumPrinterDataEx(    hPrinter,
                                        pKey,
                                        (LPBYTE) pEnumValues,
                                        cbEnumValues,
                                        &cbEnumValues,
                                        &nEnumValues
                                     );

    if (dwResult != ERROR_MORE_DATA) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        if( HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND && Flag != DS_KEY_SPOOLER) {
            goto IgnoreError;
        }
        else {
            goto error;
        }
    }

    if (!(pEnumValues = (PPRINTER_ENUM_VALUES) AllocSplMem(cbEnumValues))) {
        DBGMSG(DBG_EXEC,("CopyRegistry2Ds EnumPrinterDataEx FAILED: %d\n", GetLastError()));
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwResult = SplEnumPrinterDataEx(    hPrinter,
                                        pKey,
                                        (LPBYTE) pEnumValues,
                                        cbEnumValues,
                                        &cbEnumValues,
                                        &nEnumValues
                                     );
    if (dwResult != ERROR_SUCCESS) {
        DBGMSG(DBG_EXEC,("CopyRegistry2Ds 2nd EnumPrinterDataEx FAILED: %d\n", GetLastError()));
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        if( HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND && Flag != DS_KEY_SPOOLER) {
            goto IgnoreError;
        }
        else {
            goto error;
        }
    }


    // Mass publish
    for (i = 0 ; i < nEnumValues ; ++i) {

        hr = PublishDsData( pADs,
                            pEnumValues[i].pValueName,
                            pEnumValues[i].dwType,
                            (PBYTE) pEnumValues[i].pData);

        // Don't bail out on failure to put a specific property
        if (FAILED(hr)) {
            if (pEnumValues[i].pValueName) {
                DBGMSG(DBG_EXEC, ("Put property failed: %x, %ws\n", hr, pEnumValues[i].pValueName));
            } else {
                DBGMSG(DBG_EXEC, ("Put property failed: %x\n", hr));
            }
        } else {
            DBGMSG(DBG_EXEC, ("Put %ws succeeded\n", pEnumValues[i].pValueName));
        }
    }

    hr = pADs->SetInfo();

    // Mass publishing failed, now try Setting on every Put
    if (SUCCEEDED(hr)) {

        DBGMSG( DBG_EXEC, ("Mass Publishing Succeeded for %ws\n", pKey) );

    } else {

        if (HRESULT_CODE(hr) == ERROR_EXTENDED_ERROR)
            ADsGetLastError(&dwLDAPError, NULL, 0, NULL, 0);
        else
            dwLDAPError = hr;

        DBGMSG( DBG_EXEC, ("Mass Publishing FAILED for %ws: %x\n", pKey, dwLDAPError) );

        // Now we have to try SetInfo/GetInfo on every Put.
        // If the DS lacks a spooler property, then the spooler will never
        // be able to publish any properties.  Also, we'll fail if duplicate
        // strings exist in REG_MULTISZ attributes.
        // Maybe it is better to publish what we can,
        // but this requires calling SetInfo() for every property, which defeats the cache.
        // Alternatively, we could try doing the single SetInfo once and if that fails, resort
        // to the SetInfo on every Put.
        // Additionally, when SetInfo fails it is necessary to call GetInfo on that property
        // in order to clear the cache's update flag for the property.  When SetInfo fails
        // it does not clear the update flag: the update flag is only cleared when SetInfo
        // succeeds.  Not calling GetInfo will result in SetInfo() errors on all subsequent
        // attempts to publish a property.


        // Refresh the cache
        hr = pADs->GetInfo();
        BAIL_ON_FAILURE(hr);


        for (i = 0 ; i < nEnumValues ; ++i) {

            hr = PublishDsData( pADs,
                                pEnumValues[i].pValueName,
                                pEnumValues[i].dwType,
                                (PBYTE) pEnumValues[i].pData);

            // Don't bail out on failure to put a specific property
            if (FAILED(hr)) {
                if (pEnumValues[i].pValueName) {
                    DBGMSG(DBG_EXEC, ("Put property failed: %x, %ws\n", hr, pEnumValues[i].pValueName));
                } else {
                    DBGMSG(DBG_EXEC, ("Put property failed: %x\n", hr));
                }

                wsprintf(ErrorBuffer, L"%x", hr);
                hr = pADs->get_ADsPath(&bstrADsPath);
                if (SUCCEEDED(hr)) {
                    SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                                  gdwLogDsEvents & LOG_WARNING,
                                  MSG_CANT_PUBLISH_PROPERTY,
                                  FALSE,
                                  pEnumValues[i].pValueName ? pEnumValues[i].pValueName : L"NULLName",
                                  bstrADsPath,
                                  ErrorBuffer,
                                  NULL );
                    SysFreeString(bstrADsPath);
                }
            } else {
                DBGMSG(DBG_EXEC, ("Put2 %ws succeeded\n", pEnumValues[i].pValueName));
            }


            hr = pADs->SetInfo();
            if (FAILED(hr)) {

                if (HRESULT_CODE(hr) == ERROR_EXTENDED_ERROR)
                    ADsGetLastError(&dwLDAPError, NULL, 0, NULL, 0);

                if (pEnumValues[i].dwType == REG_SZ)
                    DBGMSG(DBG_EXEC, ("PUBLISH FAILED: %ws, \"%ws\", %x\n", pEnumValues[i].pValueName,
                                                                         (LPWSTR) pEnumValues[i].pData,
                                                                         dwLDAPError));
                else
                    DBGMSG(DBG_EXEC, ("PUBLISH FAILED: %ws, %x\n", pEnumValues[i].pValueName, dwLDAPError));

                wsprintf(ErrorBuffer, L"%x", hr);
                hr = pADs->get_ADsPath(&bstrADsPath);
                if (SUCCEEDED(hr)) {
                    SplLogEvent(  ((PSPOOL) hPrinter)->pIniSpooler,
                                  gdwLogDsEvents & LOG_WARNING,
                                  MSG_CANT_PUBLISH_PROPERTY,
                                  FALSE,
                                  pEnumValues[i].pValueName ? pEnumValues[i].pValueName : L"NULLName",
                                  bstrADsPath,
                                  ErrorBuffer,
                                  NULL );
                    SysFreeString(bstrADsPath);
                }

                // reset cache update flag
                // If this fails, there's nothing more that can be done except throw our hands up
                // in despair.  If this fails, no spooler properties will ever be published.
                hr = pADs->GetInfo();
                BAIL_ON_FAILURE(hr);
            }
            else {
                DBGMSG( DBG_EXEC, ("Published: %ws\n", pEnumValues[i].pValueName) );
            }
        }
    }

IgnoreError:

    EnterSplSem();
    pIniPrinter->DsKeyUpdate &= ~Flag;

    if(!(pIniPrinter->DsKeyUpdate & (DS_KEY_SPOOLER | DS_KEY_DRIVER | DS_KEY_USER))) {
        pIniPrinter->DsKeyUpdate = 0;
    }
    LeaveSplSem();

error:

    FreeSplMem(pEnumValues);

    return hr;
}



HRESULT
PublishDsData(
    IADs   *pADs,
    LPWSTR pValue,
    DWORD  dwType,
    PBYTE  pData
)
{
    HRESULT hr;
    BOOL    bCreated = FALSE;

    switch (dwType) {
        case REG_SZ:
            hr = put_BSTR_Property(pADs, pValue, (LPWSTR) pData);
            break;

        case REG_MULTI_SZ:
            hr = put_MULTISZ_Property(pADs, pValue, (LPWSTR) pData);
            break;

        case REG_DWORD:
            hr = put_DWORD_Property(pADs, pValue, (DWORD *) pData);
            break;

        case REG_BINARY:
            hr = put_BOOL_Property(pADs, pValue, (BOOL *) pData);
            break;
    }

    return hr;
}


HRESULT
PublishMandatoryProperties(
    HANDLE  hPrinter,
    IADs    *pADs
)
{
    PSPOOL      pSpool = (PSPOOL) hPrinter;
    PINIPRINTER pIniPrinter = pSpool->pIniPrinter;
    HRESULT     hr, hrAce;
    WCHAR       ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];

#if DBG
    EnterSplSem();
    DBGMSG(DBG_EXEC, ("PublishMandatoryProperties: %ws\n", pIniPrinter->pName));
    LeaveSplSem();
#endif

    hr = SetMandatoryProperties(hPrinter, pADs);

    DBGMSG(DBG_EXEC, ("PublishMandatoryProperties: SMP result %d\n", hr));
    BAIL_ON_FAILURE(hr);


    // New Schema has correct SD by default, so no need to call PutDSSD
    // hr = PutDSSD(pIniPrinter, pADs);
    hr = pADs->SetInfo();

    if (FAILED(hr)) {

        DBGMSG(DBG_EXEC, ("PublishMandatoryProperties: SetInfo failed %d\n", hr));

        wsprintf(ErrorBuffer, L"%x", hr);
        SplLogEvent(  pSpool->pIniSpooler,
                      gdwLogDsEvents & LOG_ERROR,
                      MSG_CANT_PUBLISH_MANDATORY_PROPERTIES,
                      FALSE,
                      pIniPrinter->pszCN,
                      pIniPrinter->pszDN,
                      ErrorBuffer,
                      NULL );

        // If SetInfo returns ERROR_BUSY it means the object already exists.
        // We should have avoided this conflict when we created the CN because
        // we check for conflicts and generate a random name.  Nonetheless, an
        // object could have appeared between the time we generated the CN and this SetInfo,
        // so failing here will let us try again and we'll generate a new name if we clear the
        // current one.
        if (HRESULT_CODE(hr) == ERROR_BUSY) {
            FreeSplMem(pIniPrinter->pszCN);
            pIniPrinter->pszCN = NULL;
            FreeSplMem(pIniPrinter->pszDN);
            pIniPrinter->pszDN = NULL;
        }

        BAIL_ON_FAILURE(hr);
    }

    // Get & Set ACE if we're a cluster
    hrAce = AddClusterAce(pSpool, pADs);


    // Get & store GUID
    hr = GetGUID(pADs, &pIniPrinter->pszObjectGUID);

    //
    // Keep the first failure, if present
    //
    if (FAILED(hrAce)) {
        hr = hrAce;
        wsprintf(ErrorBuffer, L"%x", hrAce);
        SplLogEvent(  pSpool->pIniSpooler,
                      gdwLogDsEvents & LOG_ERROR,
                      MSG_CANT_ADD_CLUSTER_ACE,
                      FALSE,
                      pIniPrinter->pszCN,
                      pIniPrinter->pszDN,
                      ErrorBuffer,
                      NULL );
        DsDeletePQObject(hPrinter);
        DBGMSG(DBG_EXEC, ("PublishMandatoryProperties: AddClusterAce failed %d\n", hr));
        BAIL_ON_FAILURE(hr);
    }

    //
    // Unpublish if we can't add the cluster ace or get the GUID
    // If we can't get the GUID, unpublishing will fail, but internal flags
    // will be set correctly and pruner will delete the orphan
    //
    if (FAILED(hr)){
        DsPrinterUnpublish(hPrinter);
        DBGMSG(DBG_EXEC, ("PublishMandatoryProperties: GetGuid failed %d\n", hr));
        BAIL_ON_FAILURE(hr);

    } else {
        DBGMSG(DBG_EXEC, ("PublishMandatoryProperties: GetGuid success %ws\n",
                          pIniPrinter->pszObjectGUID));
    }

error:

    if (FAILED(hr)) {
        pIniPrinter->Attributes &= ~PRINTER_ATTRIBUTE_PUBLISHED;
    }

    return hr;
}


HRESULT
SetMandatoryProperties(
    HANDLE  hPrinter,
    IADs    *pADs
)
{
    PSPOOL              pSpool = (PSPOOL) hPrinter;
    PINIPRINTER         pIniPrinter = pSpool->pIniPrinter;
    WCHAR               szBuffer[MAX_UNC_PRINTER_NAME + 1];
    DWORD               dwResult;
    DWORD               dwTemp;
    HRESULT             hr;
    PWSTR               pszServerName = NULL;


    // Get FQDN of this machine
    hr = GetDNSMachineName(pIniPrinter->pIniSpooler->pMachineName + 2, &pszServerName);
    BAIL_ON_FAILURE(hr);


    // UNC Printer Name
    // Build the UNC Printer Path
    wcscpy(szBuffer, L"\\\\");
    wcscat(szBuffer, pszServerName);
    wcscat(szBuffer, TEXT("\\"));
    wcscat(szBuffer, pIniPrinter->pName);
    dwResult = SplSetPrinterDataEx(
                        hPrinter,
                        SPLDS_SPOOLER_KEY,
                        SPLDS_UNC_NAME,
                        REG_SZ,
                        (PBYTE) szBuffer,
                        (wcslen(szBuffer) + 1)*sizeof *szBuffer);
    if (dwResult != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        BAIL_ON_FAILURE(hr);
    }

    if (pADs) {
        hr = PublishDsData( pADs,
                            SPLDS_UNC_NAME,
                            REG_SZ,
                            (PBYTE) szBuffer);
        BAIL_ON_FAILURE(hr);
    }


    // versionNumber
    dwTemp = DS_PRINTQUEUE_VERSION_WIN2000;
    dwResult = SplSetPrinterDataEx(
                        hPrinter,
                        SPLDS_SPOOLER_KEY,
                        SPLDS_VERSION_NUMBER,
                        REG_DWORD,
                        (PBYTE) &dwTemp,
                        sizeof dwTemp);
    if (dwResult != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        BAIL_ON_FAILURE(hr);
    }

    if (pADs) {
        hr = PublishDsData( pADs,
                            SPLDS_VERSION_NUMBER,
                            REG_DWORD,
                            (PBYTE) &dwTemp);
        BAIL_ON_FAILURE(hr);
    }


    // ServerName (without \\)
    dwResult = SplSetPrinterDataEx( hPrinter,
                                    SPLDS_SPOOLER_KEY,
                                    SPLDS_SERVER_NAME,
                                    REG_SZ,
                                    (PBYTE) pszServerName,
                                    (wcslen(pszServerName) + 1)*sizeof(WCHAR));
    if (dwResult != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        BAIL_ON_FAILURE(hr);
    }

    if (pADs) {
        hr = PublishDsData( pADs,
                            SPLDS_SERVER_NAME,
                            REG_SZ,
                            (PBYTE) pszServerName);
        BAIL_ON_FAILURE(hr);
    }


    // ShortServerName (without \\)
    dwResult = SplSetPrinterDataEx( hPrinter,
                                    SPLDS_SPOOLER_KEY,
                                    SPLDS_SHORT_SERVER_NAME,
                                    REG_SZ,
                                    (PBYTE) (pIniPrinter->pIniSpooler->pMachineName + 2),
                                    (wcslen(pIniPrinter->pIniSpooler->pMachineName + 2) + 1)*sizeof(WCHAR));
    if (dwResult != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        BAIL_ON_FAILURE(hr);
    }

    if (pADs) {
        hr = PublishDsData( pADs,
                            SPLDS_SHORT_SERVER_NAME,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pIniSpooler->pMachineName + 2);
        BAIL_ON_FAILURE(hr);
    }


    // printerName
    dwResult = SplSetPrinterDataEx(
                        hPrinter,
                        SPLDS_SPOOLER_KEY,
                        SPLDS_PRINTER_NAME,
                        REG_SZ,
                        (PBYTE) pIniPrinter->pName,
                        pIniPrinter->pName ?
                        (wcslen(pIniPrinter->pName) + 1)*sizeof *pIniPrinter->pName : 0);
    if (dwResult != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        BAIL_ON_FAILURE(hr);
    }

    if (pADs) {
        hr = PublishDsData( pADs,
                            SPLDS_PRINTER_NAME,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pName);
        BAIL_ON_FAILURE(hr);
    }


error:

    FreeSplStr(pszServerName);

    return hr;
}



// UpdateDsSpoolerKey - writes IniPrinter to registry

VOID
UpdateDsSpoolerKey(
    HANDLE  hPrinter,
    DWORD   dwVector
)
{
    PSPOOL      pSpool = (PSPOOL) hPrinter;
    PINIPRINTER pIniPrinter = pSpool->pIniPrinter;
    DWORD       i, cbBytes, dwTemp;
    LPWSTR      pString = NULL, pStr;
    DWORD       dwResult = ERROR_SUCCESS;
    BOOL        bSet = FALSE;
    BYTE        Byte;
    PWSTR       pszUrl = NULL;

    SplInSem();

    // *** PRINTER_INFO_2 properties ***

    // Description
    if (dwVector & BIT(I_PRINTER_COMMENT)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_DESCRIPTION,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pComment,
                            pIniPrinter->pComment ?
                            (wcslen(pIniPrinter->pComment) + 1)*sizeof *pIniPrinter->pComment : 0);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: Description, %x\n", dwResult) );
#endif
    }

    // Driver-Name
    if (dwVector & BIT(I_PRINTER_DRIVER_NAME)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_DRIVER_NAME,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pIniDriver->pName,
                            pIniPrinter->pIniDriver->pName ?
                            (wcslen(pIniPrinter->pIniDriver->pName) + 1)*sizeof *pIniPrinter->pIniDriver->pName : 0);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: DriverName, %x\n", dwResult) );
#endif
    }

    // Location
    if (dwVector & BIT(I_PRINTER_LOCATION)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_LOCATION,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pLocation,
                            pIniPrinter->pLocation ?
                            (wcslen(pIniPrinter->pLocation) + 1)*sizeof *pIniPrinter->pLocation : 0);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: Location, %x\n", dwResult) );
#endif
    }

    // portName
    if (dwVector & BIT(I_PRINTER_PORT_NAME)) {

        for(i = cbBytes = 0 ; i < pIniPrinter->cPorts ; ++i)
            cbBytes += (wcslen(pIniPrinter->ppIniPorts[i]->pName) + 1)*sizeof(WCHAR);
        cbBytes += sizeof(WCHAR);   // final NULL of MULTI_SZ

        if (!(pString = (LPWSTR) AllocSplMem(cbBytes))) {
            dwResult = GetLastError();
            goto error;
        }

        for(i = 0, pStr = pString ; i < pIniPrinter->cPorts ; ++i, pStr += wcslen(pStr) + 1)
            wcscpy(pStr, pIniPrinter->ppIniPorts[i]->pName);

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PORT_NAME,
                            REG_MULTI_SZ,
                            (PBYTE) pString,
                            cbBytes);

        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: PortName, %x\n", dwResult) );
#endif
    }


    // startTime
    if (dwVector & BIT(I_PRINTER_START_TIME)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINT_START_TIME,
                            REG_DWORD,
                            (PBYTE) &pIniPrinter->StartTime,
                            sizeof pIniPrinter->StartTime);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: StartTime, %x\n", dwResult) );
#endif
    }

    // endTime
    if (dwVector & BIT(I_PRINTER_UNTIL_TIME)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINT_END_TIME,
                            REG_DWORD,
                            (PBYTE) &pIniPrinter->UntilTime,
                            sizeof pIniPrinter->UntilTime);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: EndTime, %x\n", dwResult) );
#endif
    }

    // printerName
    if (dwVector & BIT(I_PRINTER_PRINTER_NAME)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINTER_NAME,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pName,
                            pIniPrinter->pName ?
                            (wcslen(pIniPrinter->pName) + 1)*sizeof *pIniPrinter->pName : 0);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: PrinterName, %x\n", dwResult) );
#endif
    }

    // keepPrintedJobs
    if (dwVector & BIT(I_PRINTER_ATTRIBUTES)) {
        Byte = (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS) ? 1 : 0;
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINT_KEEP_PRINTED_JOBS,
                            REG_BINARY,
                            &Byte,
                            sizeof Byte);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: KeepPrintedJobs, %x\n", dwResult) );
#endif
    }

    // printSeparatorFile
    if (dwVector & BIT(I_PRINTER_SEPFILE)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINT_SEPARATOR_FILE,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pSepFile,
                            pIniPrinter->pSepFile ?
                            (wcslen(pIniPrinter->pSepFile) + 1)*sizeof *pIniPrinter->pSepFile : 0);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: SeparatorFile, %x\n", dwResult) );
#endif
    }

    // printShareName
    if (dwVector & BIT(I_PRINTER_SHARE_NAME)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINT_SHARE_NAME,
                            REG_SZ,
                            (PBYTE) pIniPrinter->pShareName,
                            pIniPrinter->pShareName ?
                            (wcslen(pIniPrinter->pShareName) + 1)*sizeof *pIniPrinter->pShareName : 0);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: ShareName, %x\n", dwResult) );
#endif
    }

    // printSpooling
    if (dwVector & BIT(I_PRINTER_ATTRIBUTES)) {
        if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DIRECT) {
            pStr = L"PrintDirect";
        } else if (pIniPrinter->Attributes & PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST) {
            pStr = L"PrintAfterSpooled";
        } else {
            pStr = L"PrintWhileSpooling";
        }

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRINT_SPOOLING,
                            REG_SZ,
                            (PBYTE) pStr,
                            (wcslen(pStr) + 1)*sizeof *pStr);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: PrintSpooling, %x\n", dwResult) );
#endif
    }

    // priority
    if (dwVector & BIT(I_PRINTER_PRIORITY)) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_PRIORITY,
                            REG_DWORD,
                            (PBYTE) &pIniPrinter->Priority,
                            sizeof pIniPrinter->Priority);
        bSet = TRUE;
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: Priority, %x\n", dwResult) );
#endif
    }


    // Non-Info2 properties

    if (bSet) {

        SetMandatoryProperties(hPrinter, NULL);

        // URL
        if (pszUrl = GetPrinterUrl(pSpool)) {
            dwResult = SplSetPrinterDataEx(
                                hPrinter,
                                SPLDS_SPOOLER_KEY,
                                SPLDS_URL,
                                REG_SZ,
                                (PBYTE) pszUrl,
                                (wcslen(pszUrl) + 1)*sizeof *pszUrl);
#if DBG
            if (dwResult != ERROR_SUCCESS)
                DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: URL, %x\n", dwResult) );
#endif
        }

        // Immortal
        dwResult = ImmortalPolicy();
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_SPOOLER_KEY,
                            SPLDS_FLAGS,
                            REG_DWORD,
                            (PBYTE) &dwResult,
                            sizeof(dwResult));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsSpoolerKey: Immortal, %x\n", dwResult) );
#endif
    }


error:

    FreeSplMem(pszUrl);
    FreeSplMem(pString);
}



VOID
UpdateDsDriverKey(
    HANDLE hPrinter
)
{
    PSPOOL      pSpool = (PSPOOL) hPrinter;
    PINIPRINTER pIniPrinter = pSpool->pIniPrinter;
    DWORD       i, cbBytes;
    WCHAR       szBuffer[33];       // Used by ltow
    LPWSTR      pString, pStr;
    BOOL        bResult;
    DWORD       dwResult;
    BYTE        Byte;
    LPWSTR      pOutput = NULL, pTemp = NULL, pTemp1 = NULL;
    DWORD       cOutputBytes, cTempBytes;
    POINTS      point;
    DWORD       dwServerMajorVersion, dwServerMinorVersion;
    DWORD       cbNeeded;
    HANDLE      hModule = FALSE;
    PDEVCAP     pDevCap;
    PSPLDEVCAP  pSplDevCaps;
    HANDLE      hDevCapPrinter = NULL;
    WCHAR       pPrinterName[MAX_UNC_PRINTER_NAME];
    WCHAR       pBuf[100];
    BOOL        bInSplSem = TRUE;
    DWORD       dwTemp, dwPrintRate, dwPrintRateUnit, dwPrintPPM;


    // *** DeviceCapability properties ***

    SplInSem();

    DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: %ws\n", pIniPrinter->pName));

    pOutput = (LPWSTR) AllocSplMem(cOutputBytes = 200);
    if (!pOutput)
        goto error;


    pTemp = (LPWSTR) AllocSplMem(cTempBytes = 200);
    if (!pTemp)
        goto error;


    // Get & Load Driver
    PINIENVIRONMENT pIniEnvironment;

    pIniEnvironment = FindEnvironment(szEnvironment, pSpool->pIniSpooler);

    if (pIniEnvironment) {

        WCHAR       szConfigFile[INTERNET_MAX_HOST_NAME_LENGTH + MAX_PATH + 1];
        PINIVERSION pIniVersion;

        pIniVersion = FindVersionForDriver(pIniEnvironment, pIniPrinter->pIniDriver);
        if (!pIniVersion)
            goto error;

        if( !(i = GetDriverVersionDirectory(szConfigFile,
                                            (DWORD)(COUNTOF(szConfigFile) - wcslen(pIniPrinter->pIniDriver->pConfigFile) - 1),
                                            pSpool->pIniSpooler,
                                            pIniEnvironment,
                                            pIniVersion,
                                            pIniPrinter->pIniDriver,
                                            NULL)) ) {
			goto error;
		}

        szConfigFile[i++] = L'\\';
        wcscpy(szConfigFile + i, pIniPrinter->pIniDriver->pConfigFile);

        if (!(hModule = LoadLibrary(szConfigFile))) {
            goto error;
        }

        if (!(pDevCap = reinterpret_cast<PDEVCAP>(GetProcAddress(hModule, "DrvDeviceCapabilities")))) {
            goto error;
        }

        pSplDevCaps = reinterpret_cast<PSPLDEVCAP>(GetProcAddress(hModule, (LPCSTR) MAKELPARAM(254, 0)));

    } else {
        goto error;
    }


    DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: driver found\n"));

    INCPRINTERREF(pIniPrinter);

    // We need to use UNC format so we go to the right pIniSpooler.
    // For instance, we won't find the printer if it's in the cluster pIniSpooler and we don't use
    // the virtual cluster name (\\server\printer).

    wsprintf(pPrinterName, L"%s\\%s", pIniPrinter->pIniSpooler->pMachineName, pIniPrinter->pName);
    LeaveSplSem();
    bInSplSem = FALSE;

    if (!(*pfnOpenPrinter)(pPrinterName, &hDevCapPrinter, NULL)) {
        dwResult = GetLastError();
        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: OpenPrinter failed %d\n",
                           dwResult));

        goto error;
    }


    // printBinNames
    if (!DevCapMultiSz( hPrinter,
                        hDevCapPrinter,
                        pDevCap,
                        NULL,
                        pPrinterName,
                        DC_BINNAMES,
                        24,
                        SPLDS_PRINT_BIN_NAMES)) {
        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_BINNAMES failed %d\n", GetLastError()));
    }


    // printCollate (awaiting DC_COLLATE)
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_COLLATE,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_COLLATE,
                            REG_BINARY,
                            (PBYTE) &dwResult,
                            sizeof(BYTE));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Collate, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_COLLATE failed %d\n", GetLastError()));
    }


    // printColor
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_COLORDEVICE,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult == GDI_ERROR) {

        // Try alternative method
        dwResult = ThisIsAColorPrinter(pIniPrinter->pName);
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_COLORDEVICE failed %d\n", GetLastError()));
    }

    dwResult = SplSetPrinterDataEx(
                        hPrinter,
                        SPLDS_DRIVER_KEY,
                        SPLDS_PRINT_COLOR,
                        REG_BINARY,
                        (PBYTE) &dwResult,
                        sizeof(BYTE));
#if DBG
    if (dwResult != ERROR_SUCCESS)
        DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Color, %x\n", dwResult) );
#endif


    // printDuplexSupported
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_DUPLEX,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {
        dwResult = !!dwResult;
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_DUPLEX_SUPPORTED,
                            REG_BINARY,
                            (PBYTE) &dwResult,
                            sizeof(BYTE));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Duplex, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_DUPLEX failed %d\n", GetLastError()));
    }


    // printStaplingSupported
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_STAPLE,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_STAPLING_SUPPORTED,
                            REG_BINARY,
                            (PBYTE) &dwResult,
                            sizeof(BYTE));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Duplex, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_STAPLE failed %d\n", GetLastError()));
    }


    // printMaxXExtent & printMaxYExtent

    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_MAXEXTENT,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {

        *((DWORD *) &point) = dwResult;

        dwTemp = (DWORD) point.x;
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_MAX_X_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: MaxXExtent, %x\n", dwResult) );
#endif

        dwTemp = (DWORD) point.y;
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_MAX_Y_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: MaxYExtent, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_MAXEXTENT failed %d\n", GetLastError()));
    }


    // printMinXExtent & printMinYExtent

    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_MINEXTENT,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {

        *((DWORD *) &point) = dwResult;

        dwTemp = (DWORD) point.x;
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_MIN_X_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: MinXExtent, %x\n", dwResult) );
#endif

        dwTemp = (DWORD) point.y;
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_MIN_Y_EXTENT,
                            REG_DWORD,
                            (PBYTE) &dwTemp,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: MinYExtent, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_MINEXTENT failed %d\n", GetLastError()));
    }

    // printMediaSupported - Not part of printQueue, but is in Schema
    if (!DevCapMultiSz( hPrinter,
                        hDevCapPrinter,
                        pDevCap,
                        pSplDevCaps,
                        pPrinterName,
                        DC_PAPERNAMES,
                        64,
                        SPLDS_PRINT_MEDIA_SUPPORTED)) {
        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_PAPERNAMES failed %d\n", GetLastError()));
    }

    // printMediaReady
    if (!DevCapMultiSz( hPrinter,
                        hDevCapPrinter,
                        pDevCap,
                        pSplDevCaps,
                        pPrinterName,
                        DC_MEDIAREADY,
                        64,
                        SPLDS_PRINT_MEDIA_READY)) {
        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_MEDIAREADY failed %d\n", GetLastError()));
    }


    // printNumberUp
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_NUP,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_NUMBER_UP,
                            REG_DWORD,
                            (PBYTE) &dwResult,
                            sizeof(DWORD));

#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: NumberUp, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_NUP failed %d\n", GetLastError()));
    }


    // printMemory
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_PRINTERMEM,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_MEMORY,
                            REG_DWORD,
                            (PBYTE) &dwResult,
                            sizeof(DWORD));

#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: printMemory, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_PRINTERMEM failed %d\n", GetLastError()));
    }


    // printOrientationsSupported
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_ORIENTATION,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {

        if (dwResult == 90 || dwResult == 270) {
            wcscpy(pBuf, L"PORTRAIT");
            wcscpy(pStr = pBuf + wcslen(pBuf) + 1, L"LANDSCAPE");
        }
        else {
            wcscpy(pStr = pBuf, L"PORTRAIT");
        }
        pStr += wcslen(pStr) + 1;
        *pStr++ = L'\0';

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_ORIENTATIONS_SUPPORTED,
                            REG_MULTI_SZ,
                            (PBYTE) pBuf,
                            (DWORD) ((ULONG_PTR) pStr - (ULONG_PTR) pBuf));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Orientations, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_ORIENTATION failed %d\n", GetLastError()));
    }


    // printMaxResolutionSupported

    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_ENUMRESOLUTIONS,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {

        if (cOutputBytes < dwResult*2*sizeof(DWORD)) {
            if(!(pTemp1 = (LPWSTR) ReallocSplMem(pOutput, 0, cOutputBytes = dwResult*2*sizeof(DWORD))))
                goto error;
            pOutput = pTemp1;
        }

        _try {
            dwResult = (*pDevCap)(  hDevCapPrinter,
                                    pPrinterName,
                                    DC_ENUMRESOLUTIONS,
                                    pOutput,
                                    NULL);
        } _except(1) {
            SetLastError(GetExceptionCode());
            dwResult = GDI_ERROR;
        }
        if (dwResult != GDI_ERROR && dwResult > 0) {

            // Find the maximum resolution: we have dwResult*2 resolutions to check
            _try {
                for(i = dwTemp = 0 ; i < dwResult*2 ; ++i) {
                    if (((DWORD *) pOutput)[i] > dwTemp)
                        dwTemp = ((DWORD *) pOutput)[i];
                }

                dwResult = SplSetPrinterDataEx(
                                    hPrinter,
                                    SPLDS_DRIVER_KEY,
                                    SPLDS_PRINT_MAX_RESOLUTION_SUPPORTED,
                                    REG_DWORD,
                                    (PBYTE) &dwTemp,
                                    sizeof(DWORD));
            } _except(1) {
                SetLastError(dwResult = GetExceptionCode());
            }

#if DBG
            if (dwResult != ERROR_SUCCESS)
                DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Resolution, %x\n", dwResult) );
#endif
        }
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_ENUMRESOLUTIONS failed %d\n", GetLastError()));
    }


    // printLanguage
    if (!DevCapMultiSz( hPrinter,
                        hDevCapPrinter,
                        pDevCap,
                        NULL,
                        pPrinterName,
                        DC_PERSONALITY,
                        32,
                        SPLDS_PRINT_LANGUAGE)) {
        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_PERSONALITY failed %d\n", GetLastError()));
    }


    // printRate
    // NOTE: If PrintRate is 0, no value is published
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_PRINTRATE,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    dwPrintRate = dwResult ? dwResult : GDI_ERROR;
    if (dwPrintRate != GDI_ERROR) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_RATE,
                            REG_DWORD,
                            (PBYTE) &dwPrintRate,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: PrintRate, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_PRINTRATE failed %d\n", GetLastError()));
    }


    // printRateUnit
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_PRINTRATEUNIT,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    dwPrintRateUnit = dwResult;

    //
    // If the capability isn't supported, set printRateUnit to empty string.
    //
    switch (dwPrintRateUnit) {
        case PRINTRATEUNIT_PPM:
            pStr = L"PagesPerMinute";
            break;

        case PRINTRATEUNIT_CPS:
            pStr = L"CharactersPerSecond";
            break;

        case PRINTRATEUNIT_LPM:
            pStr = L"LinesPerMinute";
            break;

        case PRINTRATEUNIT_IPM:
            pStr = L"InchesPerMinute";
            break;

        default:
            pStr = L"";
            break;
    }

    if (pStr) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_RATE_UNIT,
                            REG_SZ,
                            (PBYTE) pStr,
                            (wcslen(pStr) + 1)*sizeof *pStr);
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: PrintRateUnit, %x\n", dwResult) );
#endif
    } else {
        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_PRINTRATEUNIT no unit %d\n", dwPrintRateUnit ));
    }


    // printPagesPerMinute
    // DevCap returns 0 if there is no entry in GPD
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_PRINTRATEPPM,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }

    if (dwResult == GDI_ERROR)
        dwResult = 0;

    dwPrintPPM = dwResult;

    // If dwPrintPPM == 0, then calculate PPM from PrintRate
    if (dwPrintPPM == 0) {
        if (dwPrintRate == GDI_ERROR) {
            dwPrintPPM = GDI_ERROR;
        } else {
            switch (dwPrintRateUnit) {
                case PRINTRATEUNIT_PPM:
                    dwPrintPPM = dwPrintRate;
                    break;

                case PRINTRATEUNIT_CPS:
                case PRINTRATEUNIT_LPM:
                    dwPrintPPM = dwPrintRate/PPM_FACTOR;
                    if (dwPrintPPM == 0)
                        dwPrintPPM = 1;     // min PPM is 1
                    break;

                default:

                    DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: PRINTRATEUNIT not found %d\n",
                                       dwPrintRateUnit));
                    dwPrintPPM = GDI_ERROR;
                    break;
            }
        }
    }
    if (dwPrintPPM != GDI_ERROR) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_PRINT_PAGES_PER_MINUTE,
                            REG_DWORD,
                            (PBYTE) &dwPrintPPM,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG(DBG_WARNING, ("UpdateDsDriverKey: PrintPagesPerMinute, %x\n", dwResult));
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: PPM failed %d\n", GetLastError()));
    }


    // printDriverVersion
    _try {
        dwResult = (*pDevCap)(  hDevCapPrinter,
                                pPrinterName,
                                DC_VERSION,
                                NULL,
                                NULL);
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }
    if (dwResult != GDI_ERROR) {
        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            SPLDS_DRIVER_VERSION,
                            REG_DWORD,
                            (PBYTE) &dwResult,
                            sizeof(DWORD));
#if DBG
        if (dwResult != ERROR_SUCCESS)
            DBGMSG( DBG_WARNING, ("UpdateDsDriverKey: Driver Version, %x\n", dwResult) );
#endif
    } else {

        DBGMSG( DBG_EXEC, ("UpdateDsDriverKey: DC_VERSION failed %d\n", GetLastError()));
    }



error:

    if (hDevCapPrinter)
        (*pfnClosePrinter)(hDevCapPrinter);

    if (!bInSplSem) {
        EnterSplSem();
        DECPRINTERREF(pIniPrinter);
    }

    if (hModule)
        FreeLibrary(hModule);

    FreeSplMem(pOutput);
    FreeSplMem(pTemp);
}


BOOL
DevCapMultiSz(
    HANDLE      hPrinter,
    HANDLE      hDevCapPrinter,
    PDEVCAP     pDevCap,
    PSPLDEVCAP  pSplDevCap,
    PWSTR       pszPrinterName,
    WORD        fwCapability,
    DWORD       dwElementBytes,
    PWSTR       pszRegValue
)
/*++
Function Description:
    This function writes a multisz devcap string to the DsDriverKey registry

Parameters:
    hPrinter       - printer handle
    hDevCapPrinter - devcap handle
    pDevCap        - devcap function pointer
    pszPrinterName - name of the printer
    fwCapability - devcap capability entry
    dwElementBytes - length of each string element in the array returned by devcaps
    pszRegValue - name of the registry value to which the multisz string will be written

Return Values:
    BOOL - TRUE if successful, FALSE if not.  Call GetLastError to retrieve failure error.

--*/
{
    DWORD dwResult, cbBytes;
    PWSTR pszDevCapBuffer = NULL;
    PWSTR pszRegData = NULL;

    _try {
        dwResult = GDI_ERROR;
        if (pSplDevCap) {
            dwResult = (*pSplDevCap)(   hDevCapPrinter,
                                        pszPrinterName,
                                        fwCapability,
                                        NULL,
                                        0,
                                        NULL);
        }
        if (dwResult == GDI_ERROR) {
            dwResult = (*pDevCap)(  hDevCapPrinter,
                                    pszPrinterName,
                                    fwCapability,
                                    NULL,
                                    NULL);
        }

        if (dwResult != GDI_ERROR) {

            //
            // DeviceCapabilities doesn't take a buffer size parameter, so if you get
            // printer properties on a hundred or so printers at the same time, you will
            // occasionally hit the case where win32 cache is deleting & adding forms in
            // RefreshFormsCache and DC_PAPERNAMES calls EnumForms and gets different
            // results.  The first call may return 3 forms and second returns 20.  So we
            // allocate a big buffer here so third party drivers don't AV.  For unidrv
            // we have a different interface that accepts a buffer size.
            //
            if ((fwCapability == DC_PAPERNAMES || fwCapability == DC_MEDIAREADY) && dwResult < LOTS_OF_FORMS) {
                cbBytes = LOTS_OF_FORMS*dwElementBytes*sizeof(WCHAR);
            } else {
                cbBytes = dwResult*dwElementBytes*sizeof(WCHAR);
            }
            pszDevCapBuffer = (PWSTR) AllocSplMem(cbBytes);

            if (pszDevCapBuffer) {
                dwResult = GDI_ERROR;
                if (pSplDevCap) {
                    dwResult = (*pSplDevCap)(   hDevCapPrinter,
                                                pszPrinterName,
                                                fwCapability,
                                                pszDevCapBuffer,
                                                cbBytes/sizeof(WCHAR),
                                                NULL);
                }
                if (dwResult == GDI_ERROR) {
                    dwResult = (*pDevCap)(  hDevCapPrinter,
                                            pszPrinterName,
                                            fwCapability,
                                            pszDevCapBuffer,
                                            NULL);
                }

                if (dwResult != GDI_ERROR) {
                    if (!(pszRegData = DevCapStrings2MultiSz(pszDevCapBuffer, dwResult, dwElementBytes, &cbBytes))) {
                        dwResult = GDI_ERROR;
                    }
                }
            } else {
                dwResult = GDI_ERROR;
            }
        }
    } _except(1) {
        SetLastError(GetExceptionCode());
        dwResult = GDI_ERROR;
    }

    if (dwResult != GDI_ERROR) {

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            pszRegValue,
                            REG_MULTI_SZ,
                            (PBYTE) pszRegData,
                            cbBytes);

        if (dwResult != ERROR_SUCCESS) {
            SetLastError(dwResult);
            dwResult = GDI_ERROR;
        }
    } else {

        WCHAR   szzNull[2];
        szzNull[0] = szzNull[1] = '\0';

        dwResult = SplSetPrinterDataEx(
                            hPrinter,
                            SPLDS_DRIVER_KEY,
                            pszRegValue,
                            REG_MULTI_SZ,
                            (PBYTE) szzNull,
                            2 * sizeof(WCHAR));
    }

    FreeSplStr(pszDevCapBuffer);
    FreeSplStr(pszRegData);

    return dwResult != GDI_ERROR;
}



// RecreateDsKey: Clears existing published properties and recreates & republishes Registry key

extern "C" DWORD
RecreateDsKey(
    HANDLE  hPrinter,
    PWSTR   pszKey
)
{
    PSPOOL      pSpool = (PSPOOL)hPrinter;
    PINIPRINTER pIniPrinter = pSpool->pIniPrinter;

    SplOutSem();

    // 1) Clear all published Properties under Key

    ClearDsKey(hPrinter, pszKey);


    // 2) Delete Key

    EnterSplSem();
    SplDeletePrinterKey(hPrinter, pszKey);


    // 3) Recreate Key

    if (!wcscmp(pszKey, SPLDS_DRIVER_KEY)) {
        UpdateDsDriverKey(hPrinter);
    }
    else if (!wcscmp(pszKey, SPLDS_SPOOLER_KEY)) {
        UpdateDsSpoolerKey(hPrinter, 0xffffffff);
    }



    // 4) Republish Key

    SetPrinterDs(hPrinter, DSPRINT_UPDATE, FALSE);

    LeaveSplSem();
    SplOutSem();

    return ERROR_SUCCESS;
}


// ClearDsKey: clears all properties in specified key

HRESULT
ClearDsKey(
    HANDLE hPrinter,
    PWSTR  pszKey
)
{
    HRESULT                 hr = ERROR_SUCCESS;
    DWORD                   i;
    DWORD                   cbEnumValues = 0;
    PPRINTER_ENUM_VALUES    pEnumValues = NULL;
    DWORD                   nEnumValues;
    DWORD                   dwResult;
    PSPOOL                  pSpool = (PSPOOL)hPrinter;
    PINIPRINTER             pIniPrinter = pSpool->pIniPrinter;
    IADs                    *pADs = NULL;
    HANDLE                  hToken = NULL;
    VARIANT                 var;


    SplOutSem();

    //
    // If we're not published, there's no DS key to clear, so just return success
    //
    if (!pIniPrinter->pszObjectGUID)
        return S_OK;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
        return hr;

    hToken = RevertToPrinterSelf(); // All DS accesses are done by LocalSystem account


    // 1) Enumerate all the Values under key

    // Enumerate and Publish Key
    dwResult = SplEnumPrinterDataEx(    hPrinter,
                                        pszKey,
                                        NULL,
                                        0,
                                        &cbEnumValues,
                                        &nEnumValues
                                     );

    if (dwResult != ERROR_MORE_DATA) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        goto error;
    }

    if (!(pEnumValues = (PPRINTER_ENUM_VALUES) AllocSplMem(cbEnumValues))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwResult = SplEnumPrinterDataEx(    hPrinter,
                                        pszKey,
                                        (LPBYTE) pEnumValues,
                                        cbEnumValues,
                                        &cbEnumValues,
                                        &nEnumValues
                                     );
    if (dwResult != ERROR_SUCCESS) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwResult);
        goto error;
    }


    // Get or Create printQueue object
    hr = GetPrintQueue(hPrinter, &pADs);
    BAIL_ON_FAILURE(hr);


    // 2) Clear Published Properties

    VariantInit(&var);

    for (i = 0 ; i < nEnumValues ; ++i) {

        hr = pADs->PutEx(
                ADS_PROPERTY_CLEAR,
                pEnumValues[i].pValueName,
                var
                );

#if DBG
        if (FAILED(hr))
            DBGMSG(DBG_EXEC, ("Failed to clear property: %ws\n", pEnumValues[i].pValueName));
#endif
    }

    hr = pADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    FreeSplMem(pEnumValues);

    if (hToken)
        ImpersonatePrinterClient(hToken);

    if (pADs) {
        pADs->Release();
    }

    CoUninitialize();

    return hr;
}


HRESULT
PutDSSD(
    PINIPRINTER pIniPrinter,
    IADs        *pADs
)
{
    IADsSecurityDescriptor  *pSD = NULL;
    IADsAccessControlList   *pACL = NULL;
    IDispatch               *pSDDispatch = NULL;
    IDispatch               *pACLDispatch = NULL;
    HRESULT                 hr, hr1;
    DWORD                   cb, cbDomain;
    DOMAIN_CONTROLLER_INFO  *pDCI = NULL;
    PWSTR                   pszTrustee = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
    DWORD                   dwRet;
    WCHAR                   ErrorBuffer[LOG_EVENT_ERROR_BUFFER_SIZE];
    BSTR                    bstrADsPath = NULL;

    // Get SecurityDescriptor
    // *** Create ACE
    hr = CoCreateInstance(  CLSID_SecurityDescriptor,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IADsSecurityDescriptor,
                            (void **) &pSD);
    BAIL_ON_FAILURE(hr);

    hr = pSD->QueryInterface(IID_IDispatch, (void **) &pSDDispatch);
    BAIL_ON_FAILURE(hr);


    // Create DACL
    hr = CoCreateInstance(  CLSID_AccessControlList,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IADsAccessControlList,
                            (void **) &pACL);
    BAIL_ON_FAILURE(hr);

    hr = pACL->QueryInterface(IID_IDispatch, (void **) &pACLDispatch);
    BAIL_ON_FAILURE(hr);


    // Get Domain name
    dwRet = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) &pDsRole);
    if (dwRet) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
        BAIL_ON_FAILURE(hr);
    }

    // *** Create ACEs ***

    // NTPRINTING\SWILSONTEST$
    cbDomain = wcslen(pDsRole->DomainNameFlat);
    cb = cbDomain + wcslen(pIniPrinter->pIniSpooler->pMachineName + 2) + 3;   // add \, $, NULL
    cb *= sizeof(WCHAR);
    if (!(pszTrustee = (PWSTR) AllocSplMem(cb))) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
        BAIL_ON_FAILURE(hr);
    }
    wsprintf(pszTrustee, L"%ws\\%ws$", pDsRole->DomainNameFlat, pIniPrinter->pIniSpooler->pMachineName + 2);

    hr = CreateAce(pACL, (BSTR) pszTrustee, GENERIC_ALL);
    BAIL_ON_FAILURE(hr);

    hr = CreateAce(pACL, (BSTR) L"Domain Admins", GENERIC_ALL);
    BAIL_ON_FAILURE(hr);

    hr = CreateAce(pACL, (BSTR) L"Authenticated Users", GENERIC_READ);
    BAIL_ON_FAILURE(hr);

    hr = CreateAce(pACL, (BSTR) L"System", GENERIC_ALL);
    BAIL_ON_FAILURE(hr);

    // Write it out

    hr = pACL->put_AclRevision(ACL_REVISION4);
    BAIL_ON_FAILURE(hr);

    hr = pSD->put_DiscretionaryAcl(pACLDispatch);
    BAIL_ON_FAILURE(hr);

    hr = put_Dispatch_Property(pADs, L"nTSecurityDescriptor", pSDDispatch);
    BAIL_ON_FAILURE(hr);


    // If SetInfo returns ERROR_BUSY it means the object already exists
    // If the object exists, delete it and create a new one
    hr = pADs->SetInfo();

    if (HRESULT_CODE(hr) == ERROR_BUSY)
        pIniPrinter->DsKeyUpdate = DS_KEY_REPUBLISH;

    BAIL_ON_FAILURE(hr);

    DBGMSG(DBG_EXEC, ("PutDSSD: Successfully added ACL\n"));

error:

    FreeSplMem(pszTrustee);

    if (pSDDispatch)
        pSDDispatch->Release();

    if (pACLDispatch)
        pACLDispatch->Release();

    if (pSD)
        pSD->Release();

    if (pACL)
        pACL->Release();

    if (pDCI)
        NetApiBufferFree(pDCI);

    if (pDsRole)
        DsRoleFreeMemory((PVOID) pDsRole);

    if (FAILED(hr)) {
        DBGMSG(DBG_EXEC, ("PutDSSD: Failed to add ACL: %x\n\n", hr));
        wsprintf(ErrorBuffer, L"%x", hr);
        hr1 = pADs->get_ADsPath(&bstrADsPath);
        if (SUCCEEDED(hr1)) {
            SplLogEvent(  pIniPrinter->pIniSpooler,
                          gdwLogDsEvents & LOG_ERROR,
                          MSG_CANT_WRITE_ACL,
                          FALSE,
                          bstrADsPath,
                          ErrorBuffer,
                          NULL );
            SysFreeString(bstrADsPath);
        }
    }

    return hr;
}



HRESULT
CreateAce(
    IADsAccessControlList   *pACL,
    BSTR                    pszTrustee,
    DWORD                   dwAccessMask
)
{
    IADsAccessControlEntry  *pACE = NULL;
    IDispatch               *pACEDispatch = NULL;
    HRESULT                 hr;


    // *** Create ACE
    hr = CoCreateInstance(  CLSID_AccessControlEntry,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IADsAccessControlEntry,
                            (void **) &pACE);
    BAIL_ON_FAILURE(hr);

    hr = pACE->put_AccessMask(dwAccessMask);
    BAIL_ON_FAILURE(hr);

    hr = pACE->put_AceType(ACCESS_ALLOWED_ACE_TYPE);
    BAIL_ON_FAILURE(hr);

    hr = pACE->put_AceFlags(0);
    BAIL_ON_FAILURE(hr);

    hr = pACE->put_Trustee(pszTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pACE->QueryInterface(IID_IDispatch, (void **) &pACEDispatch);
    BAIL_ON_FAILURE(hr);

    hr = pACL->AddAce(pACEDispatch);
    BAIL_ON_FAILURE(hr);

error:

    if (pACEDispatch)
        pACEDispatch->Release();

    if (pACE)
        pACE->Release();

    return hr;
}



HRESULT
AddClusterAce(
    PSPOOL  pSpool,
    IADs    *pADsPrintQueue
)
{
    PINIPRINTER                 pIniPrinter             = pSpool->pIniPrinter;
    IDispatch                   *pSDPrintQueueDispatch  = NULL;
    IADsSecurityDescriptor      *pSDPrintQueue          = NULL;
    IDispatch                   *pACLPrintQueueDispatch = NULL;
    IADsAccessControlList       *pACLPrintQueue         = NULL;
    PWSTR                       pszClusterDN            = NULL;
    PWSTR                       pszAccount              = NULL;
    HRESULT                     hr;

    // If we don't have a GUID, then we're not a cluster and we don't need to add the ACE
    if (!pIniPrinter->pIniSpooler->pszClusterGUID)
        return S_OK;

    // Get the Cluster Object DN
    hr = GetPublishPointFromGUID(NULL, pIniPrinter->pIniSpooler->pszClusterGUID, &pszClusterDN, NULL, FALSE);
    BAIL_ON_FAILURE(hr);

    // Get the PrintQueue Security Descriptor
    hr = get_Dispatch_Property(pADsPrintQueue, L"nTSecurityDescriptor", &pSDPrintQueueDispatch);
    BAIL_ON_FAILURE(hr);

    hr = pSDPrintQueueDispatch->QueryInterface(IID_IADsSecurityDescriptor, (void **) &pSDPrintQueue);
    BAIL_ON_FAILURE(hr);

    // Get DACL from the Security Descriptor
    hr = pSDPrintQueue->get_DiscretionaryAcl(&pACLPrintQueueDispatch);
    BAIL_ON_FAILURE(hr);

    hr = pACLPrintQueueDispatch->QueryInterface(IID_IADsAccessControlList, (void **) &pACLPrintQueue);
    BAIL_ON_FAILURE(hr);

    // Create the new ACE & Add it to the ACL
    // Cluster account is a user account, so get current user and stick it in this ACE
    hr = FQDN2Whatever(pszClusterDN, &pszAccount, DS_NT4_ACCOUNT_NAME);
    BAIL_ON_FAILURE(hr);

    hr = CreateAce(pACLPrintQueue, (BSTR) pszAccount, GENERIC_ALL);
    BAIL_ON_FAILURE(hr);

    // Write the ACL back to the Security Descriptor

    hr = pSDPrintQueue->put_DiscretionaryAcl(pACLPrintQueueDispatch);
    BAIL_ON_FAILURE(hr);

    // Write the Security Descriptor back to the object
    hr = put_Dispatch_Property(pADsPrintQueue, L"nTSecurityDescriptor", pSDPrintQueueDispatch);
    BAIL_ON_FAILURE(hr);

    hr = pADsPrintQueue->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    if (pACLPrintQueueDispatch)
        pACLPrintQueueDispatch->Release();

    if (pACLPrintQueue)
        pACLPrintQueue->Release();

    if (pSDPrintQueueDispatch)
        pSDPrintQueueDispatch->Release();

    if (pSDPrintQueue)
        pSDPrintQueue->Release();

    FreeSplStr(pszClusterDN);
    FreeSplStr(pszAccount);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\spooler\localspl\driver.c ===
/*++

Copyright (c) 1990 - 1995 Microsoft Corporation

Module Name:

    driver.c

Abstract:

   This module provides all the public exported APIs relating to the
   Driver-based Spooler Apis for the Local Print Providor

   LocalAddPrinterDriver
   LocalDeletePrinterDriver
   SplGetPrinterDriver
   LocalGetPrinterDriverDirectory
   LocalEnumPrinterDriver

   Support Functions in driver.c

   CopyIniDriverToDriver            -- KrishnaG
   GetDriverInfoSize                -- KrishnaG
   DeleteDriverIni                  -- KrishnaG
   WriteDriverIni                   -- KrishnaG

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

Revision History:

    Felix Maxa (amaxa) 18-Jun-2000
    Modified registry functions to take pIniSpooler
    Added code to propagate drivers to the cluster disk

    Khaled Sedky (khaleds) 2 Feb 1999
    Modified CompleteDriverUpgrade to enable upgrading v.2 drivers to newer v.2 drivers

    Ramanathan Venkatapathy (RamanV) 14 Feb 1997
     Modified CreateVersionEntry,CreateDriverEntry, LocalDeletePrinterDriver,
      SplDeletePrinterDriver.
     Added Driver File RefCounting functions, DeletePrinterDriverEx functions.

    Muhunthan Sivapragasam (MuhuntS) 26 May 1995
    Changes to support DRIVER_INFO_3

    Matthew A Felton (MattFe) 27 June 1994
    pIniSpooler

    Matthew A Felton (MattFe) 23 Feb 1995
    CleanUp InternalAddPrinterDriver for win32spl use so it allows copying from non local
    directories.

    Matthew A Felton (MattFe) 23 Mar 1994
    Added DrvUpgradePrinter calls, changes required to AddPrinterDriver so to save old
    files.

--*/

#include <precomp.h>
#include <lm.h>
#include <offsets.h>
#include <wingdip.h>
#include "clusspl.h"


//
// Private Declarations
//
#define COMPATIBLE_SPOOLER_VERSION 2

//
// This definition is duplicated from oak\inc\winddi.h.
//
#define DRVQUERY_USERMODE 1

extern NET_API_STATUS (*pfnNetShareAdd)();
extern SHARE_INFO_2 PrintShareInfo;
extern NET_API_STATUS (*pfnNetShareSetInfo)();


#define MAX_DWORD_LENGTH 11

typedef struct _DRVFILE {
    struct _DRVFILE *pnext;
    LPCWSTR  pFileName;
}  DRVFILE, *PDRVFILE;

DWORD
CopyICMToClusterDisk(
    IN PINISPOOLER pIniSpooler
    );

DWORD
PropagateMonitorToCluster(
    IN LPCWSTR     pszName,
    IN LPCWSTR     pszDDLName,
    IN LPCWSTR     pszEnvName,
    IN LPCWSTR     pszEnvDir,
    IN PINISPOOLER pIniSpooler
    );

BOOL
CheckFilePlatform(
    IN  LPWSTR  pszFileName,
    IN  LPWSTR  pszEnvironment
    );

LPBYTE
CopyIniDriverToDriverInfo(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    LPBYTE  pEnd,
    LPWSTR  lpRemote,
    PINISPOOLER pIniSpooler
    );

LPBYTE
CopyIniDriverToDriverInfoVersion(
    IN  PINIENVIRONMENT pIniEnvironment,
    IN  PINIVERSION pIniVersion,
    IN  PINIDRIVER pIniDriver,
    IN  LPBYTE  pDriverInfo,
    IN  LPBYTE  pEnd,
    IN  LPWSTR  lpRemote,
    IN  PINISPOOLER pIniSpooler
    );

LPBYTE
CopyIniDriverFilesToDriverInfo(
    IN  LPDRIVER_INFO_VERSION   pDriverVersion,
    IN  PINIVERSION             pIniVersion,
    IN  PINIDRIVER              pIniDriver,
    IN  LPCWSTR                 pszDriverVersionDir,
    IN  LPBYTE                  pEnd
    );

LPBYTE
FillDriverInfo (
    IN  LPDRIVER_INFO_VERSION   pDriverFile,
    IN  DWORD                   Index,
    IN  PINIVERSION             pIniVersion,
    IN  LPCWSTR                 pszPrefix,
    IN  LPCWSTR                 pszFileName,
    IN  DRIVER_FILE_TYPE        FileType,
    IN  LPBYTE                  pEnd
    );

BOOL GetDriverFileCachedVersion(
     IN     PINIVERSION      pIniVersion,
     IN     LPCWSTR          pFileName,
     OUT    DWORD            *pFileVersion
    );

BOOL
DriverAddedOrUpgraded (
    IN  PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN  DWORD               dwFileCount
    );

BOOL
BuildDependentFilesFromDriverInfo (
    IN  LPDRIVER_INFO_VERSION pDriverInfo,
    OUT LPWSTR               *ppDependentFiles
    );

VOID
UpdateDriverFileVersion(
    IN  PINIVERSION             pIniVersion,
    IN  PINTERNAL_DRV_FILE      pInternalDriverFiles,
    IN  DWORD                   FileCount
    );

BOOL SaveDriverVersionForUpgrade(
    IN  HKEY                    hDriverKey,
    IN  PDRIVER_INFO_VERSION    pDriverVersion,
    IN  LPWSTR                  pName,
    IN  DWORD                   dwDriverMoved,
    IN  DWORD                   dwVersion
    );

DWORD
CopyFileToClusterDirectory (
    IN  PINISPOOLER         pIniSpooler,
    IN  PINIENVIRONMENT     pIniEnvironment,
    IN  PINIVERSION         pIniVersion,
    IN  PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN  DWORD               FileCount
    );

VOID
CleanupInternalDriverInfo(
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               FileCount
    );

BOOL
GetDriverFileVersionsFromNames(
    IN  PINTERNAL_DRV_FILE    pInternalDriverFiles,
    IN  DWORD                 dwCount
    );

BOOL
GetDriverFileVersions(
    IN  LPDRIVER_INFO_VERSION pDriverVersion,
    IN  PINTERNAL_DRV_FILE    pInternalDriverFiles,
    IN  DWORD                 dwCount
    );

BOOL
GetFileNamesFromDriverVersionInfo (
    IN  LPDRIVER_INFO_VERSION   pDriverInfo,
    OUT LPWSTR                  *ppszDriverPath,
    OUT LPWSTR                  *ppszConfigFile,
    OUT LPWSTR                  *ppszDataFile,
    OUT LPWSTR                  *ppszHelpFile
    );

BOOL 
WaitRequiredForDriverUnload(
    IN      PINISPOOLER         pIniSpooler,
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      PINIDRIVER          pIniDriver,
    IN      DWORD               dwLevel,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               dwFileCount,
    IN      DWORD               dwVersion,
    IN      BOOL                bDriverMoved,
        OUT LPBOOL              pbSuccess
    );

BOOL FilesUnloaded(
    PINIENVIRONMENT pIniEnvironment,
    LPWSTR  pDriverFile,
    LPWSTR  pConfigFile,
    DWORD   dwDriverAttributes);

DWORD StringSizeInBytes(
    LPWSTR pString,
    BOOL   bMultiSz);

BOOL SaveParametersForUpgrade(
    LPWSTR pName,
    BOOL   bDriverMoved,
    DWORD  dwLevel,
    LPBYTE pDriverInfo,
    DWORD  dwVersion);

VOID CleanUpResources(
    LPWSTR              pKeyName,
    LPWSTR              pSplName,
    PDRIVER_INFO_6      pDriverInfo,
    PINTERNAL_DRV_FILE *pInternalDriverFiles,
    DWORD               dwFileCount);

BOOL RestoreParametersForUpgrade(
    HKEY     hUpgradeKey,
    DWORD    dwIndex,
    LPWSTR   *pKeyName,
    LPWSTR   *pSplName,
    LPDWORD  pdwLevel,
    LPDWORD  pdwDriverMoved,
    PDRIVER_INFO_6   *ppDriverInfo);

VOID CleanUpgradeDirectories();

VOID FreeDriverInfo6(
    PDRIVER_INFO_6   pDriver6
    );

BOOL RegGetValue(
    HKEY    hDriverKey,
    LPWSTR  pValueName,
    LPBYTE  *pValue
    );

BOOL
WriteDriverIni(
    PINIDRIVER      pIniDriver,
    PINIVERSION     pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER      pIniSpooler
    );

BOOL
DeleteDriverIni(
    PINIDRIVER      pIniDriver,
    PINIVERSION     pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
    );

BOOL
CreateVersionDirectory(
    PINIVERSION pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    BOOL bUpdate,
    PINISPOOLER pIniSpooler
    );

DWORD
GetDriverInfoSize(
    PINIDRIVER  pIniDriver,
    DWORD       Level,
    PINIVERSION pIniVersion,
    PINIENVIRONMENT  pIniEnvironment,
    LPWSTR      lpRemote,
    PINISPOOLER pIniSpooler
    );

BOOL
DeleteDriverVersionIni(
    PINIVERSION pIniVersion,
    PINIENVIRONMENT  pIniEnvironment,
    PINISPOOLER     pIniSpooler
    );

BOOL
WriteDriverVersionIni(
    PINIVERSION     pIniVersion,
    PINIENVIRONMENT pIniEnvironment,
    PINISPOOLER     pIniSpooler
    );

PINIDRIVER
FindDriverEntry(
    PINIVERSION pIniVersion,
    LPWSTR pszName
    );

PINIDRIVER
CreateDriverEntry(
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      DWORD               Level,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN      PINISPOOLER         pIniSpooler,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               FileCount,
    IN      DWORD               dwTempDir,
    IN      PINIDRIVER          pOldIniDriver
    );

BOOL
IsKMPD(
    LPWSTR  pDriverName
    );

VOID
CheckDriverAttributes(
    PINISPOOLER     pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION     pIniVersion,
    PINIDRIVER      pIniDriver
    );

BOOL
NotifyDriver(
    PINISPOOLER     pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION     pIniVersion,
    PINIDRIVER      pIniDriver,
    DWORD           dwDriverEvent,
    DWORD           dwParameter
    );

BOOL
AddTempDriver(
    IN      PINISPOOLER         pIniSpooler,
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      DWORD               dwLevel,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN  OUT PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               dwFileCount,
    IN      DWORD               dwVersion,
    IN      BOOL                bDriverMoved
    );

BOOL
CompleteDriverUpgrade(
    IN      PINISPOOLER         pIniSpooler,
    IN      PINIENVIRONMENT     pIniEnvironment,
    IN      PINIVERSION         pIniVersion,
    IN      PINIDRIVER          pIniDriver,
    IN      DWORD               dwLevel,
    IN      LPBYTE              pDriverInfo,
    IN      DWORD               dwFileCopyFlags,
    IN      PINTERNAL_DRV_FILE  pInternalDriverFiles,
    IN      DWORD               dwFileCount,
    IN      DWORD               dwVersion,
    IN      DWORD               dwTempDir,
    IN      BOOL                bDriverMoved,
    IN      BOOL                bDriverFileMoved,
    IN      BOOL                bConfigFileMoved
    );

BOOL
FilesInUse(
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver
    );

BOOL
UpdateDriverFileRefCnt(
    PINIENVIRONMENT  pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER  pIniDriver,
    LPCWSTR     pDirectory,
    DWORD       dwDeleteFlag,
    BOOL        bIncrementFlag
    );

PDRVREFCNT
IncrementFileRefCnt(
    PINIVERSION pIniVersion,
    LPCWSTR szFileName
    );

PDRVREFCNT
DecrementFileRefCnt(
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver,
    LPCWSTR szFileName,
    LPCWSTR szDirectory,
    DWORD dwDeleteFlag
    );

VOID
RemovePendingUpgradeForDeletedDriver(
    LPWSTR      pDriverName,
    DWORD       dwVersion,
    PINISPOOLER pIniSpooler
    );

VOID
RemoveDriverTempFiles(
    PINISPOOLER  pIniSpooler,
    PINIENVIRONMENT pIniEnvironment,
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver
    );

VOID
DeleteDriverEntry(
    PINIVERSION pIniVersion,
    PINIDRIVER pIniDriver
    );

PINIVERSION
CreateVersionEntry(
    PINIENVIRONMENT pIniEnvironment,
    DWORD dwVersion,
    PINISPOOLER pInispooler
    );

DWORD
GetEnvironmentScratchDirectory(
    LPWSTR   pDir,
    DWORD    MaxLength,
    PINIENVIRONMENT  pIniEnvironment,
    BOOL    Remote
    );

VOID
SetOldDateOnDriverFilesInScratchDirectory(
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               FileCount,
    PINISPOOLER         pIniSpooler
    );

BOOL
CopyFilesToFinalDirectory(
    PINISPOOLER         pIniSpooler,
    PINIENVIRONMENT     pIniEnvironment,
    PINIVERSION         pIniVersion,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    DWORD               dwFileCopyFlags,
    BOOL                bImpersonateOnCreate,
    LPBOOL              pbFilesMoved
    );

BOOL
CreateInternalDriverFileArray(
    IN  DWORD               Level,
    IN  LPBYTE              pDriverInfo,
    OUT PINTERNAL_DRV_FILE *pInternalDriverFiles,
    OUT LPDWORD             pFileCount,
    IN  BOOL                bUseScratchDir,
    IN  PINIENVIRONMENT     pIniEnvironment,
    IN  BOOL                bFileNamesOnly
    );

BOOL
CheckFileCopyOptions(
    PINIENVIRONMENT     pIniEnvironment,
    PINIVERSION         pIniVersion,
    PINIDRIVER          pIniDriver,
    PINTERNAL_DRV_FILE  pInternalDriverFiles,
    DWORD               dwFileCount,
    DWORD               dwFileCopyFlags,
    LPBOOL              pbUpgrade
    );

/*++

Routine Name

    FindIndexInDrvFileInfo

Routine Description:

    Checks if a certain driver file is present in an DRIVER_FILE_INFO
    file set. The search is done by the type of the file. The index
    to the first occurence of the file is returned.

Arguments:

    pDrvFileInfo - pointer to DRIVER_FILE_INFO array
    cElements    - count of elements in pDrvFileInfo
    kFileType    - file type to search for
    pIndex       - on success contains the index of the found file in 
                   the pDrvFileInfo array

Return Value:

    S_OK         - the file was found and pIndex is usable
    S_FALSE      - the file was not found, pIndex is not usable
    E_INVALIDARG - invalid arguments were passed in

--*/
HRESULT
FindIndexInDrvFileInfo(
    IN  DRIVER_FILE_INFO *pDrvFileInfo,
    IN  DWORD             cElements,
    IN  DRIVER_FILE_TYPE  kFileType,
    OUT DWORD            *pIndex
    )
{
    HRESULT hr = E_INVALIDARG;

    if (pDrvFileInfo && pIndex) 
    {
        DWORD i;

        //
        // Not found
        //
        hr = S_FALSE;

        for (i = 0; i < cElements; i++) 
        {
            if (pDrvFileInfo[i].FileType == kFileType) 
            {
                *pIndex = i;

                hr = S_OK;

                break;
            }
        }
    }

    return hr;
}


BOOL
LocalStartSystemRestorePoint(
    IN      PCWSTR      pszDriverName,
        OUT HANDLE      *phRestorePoint
    );

/*++

Routine Name

    IsDriverInstalled

Routine Description:

    Checks if a certain driver is already installed.

Arguments:

    pDriver2    - pointer to DRIVER_INFO_2
    pIniSpooler - pointer to spooler structure

Return Value:

    TRUE  - driver is installed on the pIniSpooler
    FALSE - driver is not present in pIniSpooler

--*/
BOOL
IsDriverInstalled(
    DRIVER_INFO_2 *pDriver2,
    PINISPOOLER    pIniSpooler
    )
{
    BOOL bReturn  = FALSE;

    if (pIniSpooler &&
        pDriver2 &&
        pDriver2->pName)
    {
        PINIENVIRONMENT pIniEnv;
        PINIVERSION     pIniVer;

        EnterSplSem();

        if ((pIniEnv = FindEnvironment(pDriver2->pEnvironment && *pDriver2->pEnvironment ?
                                       pDriver2->pEnvironment : szEnvironment,
                                       pIniSpooler)) &&
            (pIniVer = FindVersionEntry(pIniEnv, pDriver2->cVersion)) &&
            FindDriverEntry(pIniVer, pDriver2->pName))
        {
            bReturn = TRUE;
        }

        LeaveSplSem();
    }

    DBGMSG(DBG_CLUSTER, ("IsDriverInstalled returns %u\n", bReturn));

    return bReturn;
}

BOOL
LocalAddPrinterDriver(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
    )
{
    return LocalAddPrinterDriverEx( pName,
                                    Level,
                                    pDriverInfo,
                                    APD_COPY_NEW_FILES );
}

BOOL
LocalAddPrinterDriverEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags
    )
{
    PINISPOOLER pIniSpooler;
    BOOL        bReturn = TRUE;
    
    if (Level == 7)
    {
        bReturn = FALSE;
        SetLastError(ERROR_INVALID_LEVEL);
    }
    else if (dwFileCopyFlags & APD_COPY_TO_ALL_SPOOLERS)
    {
        //
        // Mask flag otherwise SplAddPrinterDriverEx will be fail.
        // This flag is used by Windows Update to update all the
        // drivers for all the spoolers hosted by the local machine
        //
        dwFileCopyFlags = dwFileCopyFlags & ~APD_COPY_TO_ALL_SPOOLERS;

        for (pIniSpooler = pLocalIniSpooler;
             pIniSpooler && bReturn;
             pIniSpooler = pIniSpooler->pIniNextSpooler)
        {
            //
            // We do not want to add a driver to a pIniSpooler. We want to update
            // an existing driver. That is why we check if the driver is already
            // installed
            //
            if ((pIniSpooler->SpoolerFlags & SPL_TYPE_LOCAL ||
                 pIniSpooler->SpoolerFlags & SPL_TYPE_CLUSTER) &&
                 IsDriverInstalled((DRIVER_INFO_2 *)pDriverInfo, pIniSpooler))
            {
                EnterSplSem();
                INCSPOOLERREF(pIniSpooler);
                LeaveSplSem();

                //
                // The 6th parameter indicates whether to use the scratch
                // directory (TRUE) or not (FALSE)
                //
                bReturn = SplAddPrinterDriverEx(pName,
                                                Level,
                                                pDriverInfo,
                                                dwFileCopyFlags,
                                                pIniSpooler,
                                                !(dwFileCopyFlags & APD_COPY_FROM_DIRECTORY),
                                                IMPERSONATE_USER);

                DBGMSG(DBG_CLUSTER, ("LocalAddPrinterDriverEx adding driver to "TSTR" bRet %u\n",
                                                            pIniSpooler->pMachineName, bReturn));

                EnterSplSem();
                DECSPOOLERREF(pIniSpooler);
                LeaveSplSem();
            }
        }
    }
    else
    {
        if (!(pIniSpooler = FindSpoolerByNameIncRef(pName, NULL)))
        {
            return ROUTER_UNKNOWN;
        }
        else
        {
            //
            // The 6th parameter indicates whether to use the scratch
            // directory (TRUE) or not (FALSE)
            //
            bReturn = SplAddPrinterDriverEx(pName,
                                            Level,
                                            pDriverInfo,
                                            dwFileCopyFlags,
                                            pIniSpooler,
                                            !(dwFileCopyFlags & APD_COPY_FROM_DIRECTORY),
                                            IMPERSONATE_USER);
        }

        FindSpoolerByNameDecRef(pIniSpooler);
    }

    return bReturn;
}

BOOL
SplAddPrinterDriverEx(
    LPWSTR  pName,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   dwFileCopyFlags,
    PINISPOOLER pIniSpooler,
    BOOL    bUseScratchDir,
    BOOL    bImpersonateOnCreate
    )
{
    PINISPOOLER pTempIniSpooler = pIniSpooler;

    DBGMSG( DBG_TRACE, ("AddPrinterDriver\n"));

    if (!MyName( pName, pIniSpooler )) {

        return FALSE;
    }

    //  Right now all drivers are global ie they are shared between all IniSpoolers
    //  If we want to impersonate the user then lets validate against pLocalIniSpooler
    //  whilch causes all the security checking to happen, rather than using the passed
    //  in IniSpooler which might not.    See win32spl for detail of point and print.

    if ( bImpersonateOnCreate ) {

        pTempIniSpooler = pLocalIniSpooler;
    }

    if ( !ValidateObjectAccess( SPOOLER_OBJECT_SERVER,
                                SERVER_ACCESS_ADMINISTER,
                                NULL, NULL, pTempIniSpooler)) {

        return FALSE;
    }

    return ( InternalAddPrinterDriverEx( pName,
                                         Level,
                                         pDriverInfo,
                                         dwFileCopyFlags,
                                         pIniSpooler,
                                         bUseScratchDir,
                                         bImpersonateOnCreate ) );

}


/*++

SendDriverInfo7
    IN HANDLE hPipe - the handle to the pipe to send the data down.
    IN LPDRIVER_INFO_7 pDriverInfo7 - contains info to send

Sends the Flags and the Driver info 7 information across the named pipe.

    Sending sequence: 1. Size of string to come for Driver name - there must be a driver name.
                      2. Driver name
                      3. Size of string to come for inf name - if there is no inf name, send 0 and jump to 5
                      4. inf name
                      5. Size of string to come for source name - if there is no source name, send 0 and complete
                      6. Source name

--*/
BOOL
SendDriverInfo7(
    HANDLE hPipe,
    LPDRIVER_INFO_7 pDriverInfo7
    )
{
    DWORD dwLength = wcslen(pDriverInfo7->pszDriverName);
    DWORD dwDontCare;
    DWORD dwLastError = ERROR_SUCCESS;
    OVERLAPPED Ov;

    ZeroMemory( &Ov,sizeof(Ov));

    if ( !(Ov.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) )
    {
        return FALSE;
    }

    //
    // Ensure that we have a connection at the other end.
    //
    if( !ConnectNamedPipe( hPipe, &Ov ))
    {
        dwLastError = GetLastError();
        if(!( dwLastError == ERROR_PIPE_CONNECTED || dwLastError == ERROR_IO_PENDING ))
        {
            if ( Ov.hEvent )
                CloseHandle(Ov.hEvent);
            return FALSE;
        }
    }

    //
    // Wait to connect as long as we're not connected already.
    //
    if( dwLastError != ERROR_PIPE_CONNECTED )
    {
        if( WaitForSingleObject(Ov.hEvent, gdwServerInstallTimeOut) == WAIT_TIMEOUT )
        {
            CancelIo(hPipe);
            WaitForSingleObject(Ov.hEvent, INFINITE);
        }

        if( !GetOverlappedResult(hPipe, &Ov, &dwDontCare, FALSE) )
        {
            if ( Ov.hEvent )
                CloseHandle(Ov.hEvent);
            return FALSE;
        }
    }

    if ( Ov.hEvent )
        CloseHandle(Ov.hEvent);

    //
    // Write the length of the Driver Name.
    //
    if(!WriteOverlapped( hPipe, &dwLength, sizeof(dwLength), &dwDontCare ))
        return FALSE;

    //
    // Write the driver name
    //
    if(!WriteOverlapped( hPipe, pDriverInfo7->pszDriverName, dwLength*sizeof(WCHAR), &dwDontCare ))
        return FALSE;

    if(pDriverInfo7->pszInfName)
    {
        dwLength = wcslen(pDriverInfo7->pszInfName);
        //
        // Write the length of the inf name.
        //
        if(!WriteOverlapped( hPipe, &dwLength, sizeof(dwLength), &dwDontCare ))
            return FALSE;

        //
        // Write the inf name
        //
        if(!WriteOverlapped( hPipe, pDriverInfo7->pszInfName, dwLength*sizeof(WCHAR), &dwDontCare ))
            return FALSE;

    }
    else
    {
        //
        // Write a 0 to say no inf name
        //
        dwLength = 0;
        if(!WriteOverlapped( hPipe, &dwLength, sizeof(dwLength), &dwDontCare ))
            return FALSE;
    }

    if(pDriverInfo7->pszInstallSourceRoot)
    {
        dwLength = wcslen(pDriverInfo7->pszInstallSourceRoot);
        //
        // Write the length of the install source root.
        //
        if(!WriteOverlapped( hPipe, &dwLength, sizeof(dwLength), &dwDontCare ))
            return FALSE;

        //
        // Write the install source root
        //
        if(!WriteOverlapped( hPipe, pDriverInfo7->pszInstallSourceRoot, dwLength*sizeof(WCHAR), &dwDontCare ))
            return FALSE;
    }
    else
    {
        //
        // Write a 0 to say no install source path.
        //
        dwLength = 0;
        if(!WriteOverlapped( hPipe, &dwLength, sizeof(dwLength), &dwDontCare ))
            return FALSE;
    }

    return TRUE;
}


DWORD
GetPipeName(
    OUT LPWSTR *ppszPipe
    )
{
    LPCWSTR pszPrefix = L"\\\\.\\pipe\\SRVINST";
    DWORD   Error     = ERROR_INVALID_PARAMETER;
    
    if (ppszPipe) 
    {
        WCHAR ProcID[MAX_DWORD_LENGTH];
        WCHAR ThreadID[MAX_DWORD_LENGTH];
        
        *ppszPipe = NULL;

        _itow( GetCurrentProcessId(), ProcID, 10 );
        _itow( GetCurrentThreadId(), ThreadID, 10 );

        Error = StrCatAlloc(ppszPipe, pszPrefix, ProcID, ThreadID, NULL);
    }

    return Error;
}


/*++

Description:

    This function creates a process for a driver to be installed in and launches an entry point
    from ntprint.dll to install the driver inside that process.  This install will take a driver info 7
    struct and do an inf based install with the information in that structure.
    
Arguments:

    pDriverInfo7 -- driver_info_7 structure

Returns:

    TRUE on success; FALSE otherwise
    The function sets the last error in case of failure

Notes:

    If the driver info pszInfName field is anything other than NULL, this call will fail.

--*/
BOOL
InternalINFInstallDriver(
    LPDRIVER_INFO_7 pDriverInfo7
)
{
    DWORD     Error          = ERROR_INVALID_PARAMETER;  
    LPWSTR    pszPipe        = NULL;
    
    //
    // Passing with an inf name is not supported.
    //
    if (!pDriverInfo7->pszInfName &&
        (Error = GetPipeName(&pszPipe)) == ERROR_SUCCESS)
    {
        LPWSTR  pszCmdString   = NULL;
        HANDLE  hPipe          = INVALID_HANDLE_VALUE;
        LPCWSTR pszRundllName  = L"rundll32.exe"; 
        LPCWSTR pszRundllArgs  = L"rundll32.exe ntprint.dll,ServerInstall 0 ";
        LPWSTR  pszRundllPath  = NULL;

        //
        // We use FILE_FLAG_FIRST_PIPE_INSTANCE to make sure we are the creator of the pipe.
        // Otherwise a malicious process could create the pipe first and exploit the
        // spooler connecting to it. CreateNamedPipe will fail with access denied if the
        // pipe was already created.
        //
        hPipe = CreateNamedPipe(pszPipe,
                                PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,
                                PIPE_TYPE_BYTE,
                                PIPE_UNLIMITED_INSTANCES,
                                1024,
                                1024,
                                NMPWAIT_USE_DEFAULT_WAIT,
                                NULL); 
        
        Error = hPipe != INVALID_HANDLE_VALUE ? ERROR_SUCCESS : GetLastError();
        
        if (Error == ERROR_SUCCESS && 
            (Error = StrCatAlloc(&pszCmdString, 
                                 pszRundllArgs, 
                                 pszPipe, 
                                 NULL)) == ERROR_SUCCESS &&
            (Error = StrCatSystemPath(pszRundllName,
                                      kSystemDir,
                                      &pszRundllPath)) == ERROR_SUCCESS)
        {
            DWORD               dwDontCare;
            PROCESS_INFORMATION ProcInfo;
            STARTUPINFO         StartupInfo = {0};

            StartupInfo.cb = sizeof(StartupInfo);
            
            //
            //  Now do the Process creation and wait for install to complete.
            //
            if (CreateProcess(pszRundllPath, 
                              pszCmdString, 
                              NULL, NULL, FALSE, CREATE_NEW_PROCESS_GROUP, NULL, NULL, 
                              &StartupInfo, 
                              &ProcInfo))
            {
                if (SendDriverInfo7(hPipe, pDriverInfo7))
                {
                    DWORD ReadError;

                    //
                    // Error receives the return code from the add driver operation
                    // performed by the rundll process. ReadError indicates if 
                    // ReadOverlapped succeeded. 
                    //
                    if ((ReadError = ReadOverlapped(hPipe, 
                                                    &Error, 
                                                    sizeof(Error), 
                                                    &dwDontCare)) != ERROR_SUCCESS)
                    {
                        Error = ReadError;
                    }

                    DisconnectNamedPipe(hPipe);
                }
                else
                {
                    Error = GetLastError();
                }

                CloseHandle(ProcInfo.hProcess);
                CloseHandle(ProcInfo.hThread);
            }
            else
            {
                Error = GetLastError();
            }
        }

        if (hPipe != INVALID_HANDLE_VALUE) CloseHandle(hPipe);
        if (pszCmdString)                  FreeSplMem(pszCmdString);
        if (pszRundllPath)                 FreeSplMem(pszRundllPath);
        if (pszPipe)                       FreeSplMem(pszPipe);
    }
    
    if (Error != ERROR_SUCCESS) 
    {
        SetLastError(Error);
    }

    return Error == ERROR_SUCCESS;
}


BOOL
BuildTrueDependentFileField(
    LPWSTR              pDriverPath,
    LPWSTR              pDataFile,
    LPWSTR              pConfigFile,
    LPWSTR              pHelpFile,
    LPWSTR              pInputDependentFiles,
    LPWSTR             *ppDependentFiles
    )
{
    LPWSTR  psz, psz2;
    LPCWSTR pszFileNamePart;
    DWORD   dwSize;

    if ( !pInputDependentFiles )
        return TRUE;

    for ( psz = pInputDependentFiles, dwSize = 0 ;
          psz && *psz ; psz += wcslen(psz) + 1 ) {

        pszFileNamePart = FindFileName(psz);

        if( !pszFileNamePart ){
            break;
        }

        if ( wstrcmpEx(FindFileName(pDriverPath), pszFileNamePart, FALSE)   &&
             wstrcmpEx(FindFileName(pDataFile), pszFileNamePart, FALSE)     &&
             wstrcmpEx(FindFileName(pConfigFile), pszFileNamePart, FALSE)   &&
             wstrcmpEx(FindFileName(pHelpFile), pszFileNamePart, FALSE) ) {

            dwSize += wcslen(psz) + 1;
        }
    }

    if ( !dwSize )
        return TRUE;

    // for the last \0
    ++dwSize;
    *ppDependentFiles = AllocSplMem(dwSize*sizeof(WCHAR));
    if ( !*ppDependentFiles )
        return FALSE;

    psz  = pInputDependentFiles;
    psz2 = *ppDependentFiles;
    while ( *psz ) {

        pszFileNamePart = FindFileName(psz);

        if( !pszFileNamePart ){
            break;
        }

        if ( wstrcmpEx(FindFileName(pDriverPath), pszFileNamePart, FALSE)   &&
             wstrcmpEx(FindFileName(pDataFile), pszFileNamePart, FALSE)     &&
             wstrcmpEx(FindFileName(pConfigFile), pszFileNamePart, FALSE)   &&
             wstrcmpEx(FindFileName(pHelpFile), pszFileNamePart, FALSE) ) {

            wcscpy(psz2, psz);
            psz2 += wcslen(psz) + 1;
        }

        psz += wcslen(psz) + 1;
    }

    return TRUE;
}



DWORD
IsCompatibleDriver(
    LPWSTR  pszDriverName,
    LPWSTR  pszDeviceDriverPath,
    LPWSTR  pszEnvironment,
    DWORD   dwMajorVersion,
    DWORD   *pdwBlockingStatus
    )
/*++
Function Description: Call this function to prevent bad drivers from getting installed.
                      Check if driver is listed in printupg.inf (lists all known bad driver files ).
                      Since printupg.inf contains only driver name, this function should be called
                      only for verions 2 drivers.
                      Otherwise,it will treat a version 3 driver "DriverName" as bad,
                      if it is a bad version 2 driver.

Parameters: pszDriverName         -- driver name
            pszDeviceDriverPath   -- filename for the file that contains the device driver
            pszEnvironment        -- environment string for the driver such as "Windows NT x86"
            dwMajorVersion        -- major version of the driver
            pdwBlockingStatus     -- driver blocking status
            
Return Value: ERROR_SUCCESS if succeeded
              ERROR_INVALID_PARAMETER if invalid parameters
              GetLastError for any other errors

--*/
{
    WIN32_FIND_DATA              DeviceDriverData;
    pfPSetupIsCompatibleDriver   pfnPSetupIsCompatibleDriver;
    UINT                         uOldErrMode;
    HANDLE                       hFileExists         = INVALID_HANDLE_VALUE;
    HANDLE                       hLibrary            = NULL;
    DWORD                        LastError           = ERROR_SUCCESS;
    DWORD                        dwBlockingStatus    = BSP_PRINTER_DRIVER_OK;                       
    

    uOldErrMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    if( !pszDriverName  || !pszDeviceDriverPath  || !pszEnvironment  ||
        !*pszDriverName || !*pszDeviceDriverPath || !*pszEnvironment || !pdwBlockingStatus) {
        LastError = ERROR_INVALID_PARAMETER;
        goto End;
    }
    
    *pdwBlockingStatus    = BSP_PRINTER_DRIVER_OK;

    hFileExists = FindFirstFile( pszDeviceDriverPath, &DeviceDriverData );

    if (hFileExists == INVALID_HANDLE_VALUE) {
        LastError = GetLastError();
        goto End;
    }

    if( !(hLibrary = LoadLibrary( TEXT("ntprint.dll"))) ){
        LastError = GetLastError();
        goto End;
    }

    pfnPSetupIsCompatibleDriver = (pfPSetupIsCompatibleDriver)GetProcAddress( hLibrary, "PSetupIsCompatibleDriver" );

    if( !pfnPSetupIsCompatibleDriver){
        LastError = GetLastError();
        goto End;
    }

    //
    // NULL server name is OK since we know this is the local machine. 
    // PSetupIsCompatibleDriver uses this to determine the blocking
    // level.
    //
    if ((pfnPSetupIsCompatibleDriver)( NULL,
                                         pszDriverName,
                                         pszDeviceDriverPath,
                                         pszEnvironment,
                                         dwMajorVersion,
                                         &DeviceDriverData.ftLastWriteTime,
                                         &dwBlockingStatus,
                                         NULL)) {
        *pdwBlockingStatus = dwBlockingStatus;         
    } else {

        LastError = GetLastError();
    }
         

End:

    if( hFileExists != INVALID_HANDLE_VALUE ){
        FindClose(hFileExists);
    }

    if( hLibrary ){
        FreeLibrary( hLibrary );
    }

    SetErrorMode( uOldErrMode );

    return LastError;

}

BOOL
IsAnICMFile(
    LPCWSTR  pszFileName
    )

/*++
Function Description: Checks for ICM extension on the filename

Parameters:  pszFileName - file name

Return Values: TRUE for ICM files; FALSE otherwise
--*/

{
    DWORD   dwLen = wcslen(pszFileName);
    LPWSTR  psz   = (LPWSTR)pszFileName+dwLen-4;

    if ( dwLen > 3  &&
        ( !_wcsicmp(psz, L".ICM") || !_wcsicmp(psz, L".ICC")) )
        return TRUE;

    return FALSE;
}

BOOL
ValidateDriverInfo(
    IN  LPBYTE      pDriverInfo,
    IN  DWORD       Level,
    IN  DWORD       dwFileCopyFlags,
    IN  BOOL        bCopyFilesToClusterDisk,
    IN  PINISPOOLER pIniSpooler
    )
/*++

Routine Name:

    ValidateDriverInfo

Routine Description:

    Validates information contained in a buffer depending on level and
    file copy flags.

Arguments:

    pDriverInfo             - pointer to a buffer containing DRIVER_INFO_ data.
    Level                   - 2, 3 ,4 ,6 , 7, DRIVER_INFO_VERSION_LEVEL
    dwFileCopyFlags         - file copy flags
    bCopyFilesToClusterDisk - cluster flags
    pIniSpooler             - pointer to Spooler structure

Return Value:

    TRUE if the structure is valid.

--*/
{
    BOOL    bRetValue     = FALSE;
    DWORD   LastError     = ERROR_SUCCESS;
    LPWSTR  pszDriverName = NULL;
    LPWSTR  pszDriverPath = NULL;
    LPWSTR  pszConfigFile = NULL;
    LPWSTR  pszDataFile   = NULL;
    LPWSTR  pszEnvironment = NULL;
    LPWSTR  pszMonitorName = NULL;
    LPWSTR  pszDefaultDataType = NULL;
    DWORD   dwMajorVersion;

    PDRIVER_INFO_2  pDriver2 = NULL;
    PDRIVER_INFO_3  pDriver3 = NULL;
    PDRIVER_INFO_VERSION  pDriverVersion = NULL;

    PINIENVIRONMENT pIniEnvironment = NULL;
    PINIMONITOR pIniLangMonitor = NULL;

    try {

        if (!pDriverInfo)
        {
            LastError = ERROR_INVALID_PARAMETER;
            leave;
        }

        switch (Level)
        {
            case 2:
            {
                pDriver2        = (PDRIVER_INFO_2) pDriverInfo;
                pszDriverName   = pDriver2->pName;
                pszDriverPath   = pDriver2->pDriverPath;
                pszConfigFile   = pDriver2->pConfigFile;
                pszDataFile     = pDriver2->pDataFile;
                dwMajorVersion  = pDriver2->cVersion;

                if (pDriver2->pEnvironment && *pDriver2->pEnvironment)
                {
                    pszEnvironment = pDriver2->pEnvironment;
                }

                break;
            }
            case 3:
            case 4:
            case 6:
            {
                pDriver3            = (PDRIVER_INFO_3) pDriverInfo;
                pszDriverName       = pDriver3->pName;
                pszDriverPath       = pDriver3->pDriverPath;
                pszConfigFile       = pDriver3->pConfigFile;
                pszDataFile         = pDriver3->pDataFile;
                dwMajorVersion      = pDriver3->cVersion;
                pszMonitorName      = pDriver3->pMonitorName;
                pszDefaultDataType  = pDriver3->pDefaultDataType;

                if (pDriver3->pEnvironment && *pDriver3->pEnvironment)
                {
                    pszEnvironment = pDriver3->pEnvironment;
                }
                break;
            }

            case 7:
            {
                LPDRIVER_INFO_7 pDriverInfo7 = (LPDRIVER_INFO_7)pDriverInfo;

                if (!pDriverInfo7                               ||
                    pDriverInfo7->cbSize < sizeof(DRIVER_INFO_7)||
                    !pDriverInfo7->pszDriverName                ||
                    !*pDriverInfo7->pszDriverName               ||
                    wcslen(pDriverInfo7->pszDriverName) >= MAX_PATH)
                {
                     LastError = ERROR_INVALID_PARAMETER;
                }
                //
                // We don't want to do any more of the validation below, so leave.
                //
                leave;
                break;
            }
            case DRIVER_INFO_VERSION_LEVEL:
            {
                pDriverVersion = (LPDRIVER_INFO_VERSION)pDriverInfo;
                pszDriverName = pDriverVersion->pName;

                if (!GetFileNamesFromDriverVersionInfo(pDriverVersion,
                                                       &pszDriverPath,
                                                       &pszConfigFile,
                                                       &pszDataFile,
                                                       NULL))
                {
                    LastError = ERROR_INVALID_PARAMETER;
                    leave;
                }

                if (pDriverVersion->pEnvironment != NULL &&
                    *pDriverVersion->pEnvironment != L'\0')
                {
                    pszEnvironment = pDriverVersion->pEnvironment;
                }

                pszMonitorName      = pDriverVersion->pMonitorName;
                pszDefaultDataType  = pDriverVersion->pDefaultDataType;
                dwMajorVersion      = pDriverVersion->cVersion;
                pszDriverName       = pDriverVersion->pName;

                break;
            }
            default:
            {
                LastError = ERROR_INVALID_LEVEL;
                leave;
            }
        }

        //
        // Validate driver name, driver file, config file and data file.
        //
        if ( !pszDriverName || !*pszDriverName || wcslen(pszDriverName) >= MAX_PATH ||
             !pszDriverPath || !*pszDriverPath || wcslen(pszDriverPath) >= MAX_PATH ||
             !pszConfigFile || !*pszConfigFile || wcslen(pszConfigFile) >= MAX_PATH ||
             !pszDataFile   || !*pszDataFile   || wcslen(pszDataFile) >= MAX_PATH )
        {
            LastError = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // We don't use Scratch directory when this flag is set.
        // When APD_COPY_FROM_DIRECTORY is set, the temporay directory must
        // be on the local machine.
        // IsLocalFile checks is the file is on the same machine specified by
        // the passed in spooler.
        //
        if (dwFileCopyFlags & APD_COPY_FROM_DIRECTORY)
        {
            if (!IsLocalFile(pszDriverPath, pIniSpooler) ||
                !IsLocalFile(pszConfigFile, pIniSpooler))
            {
                LastError = ERROR_INVALID_PARAMETER;
                leave;
            }
        }

        //
        // Validate default data type (except for Win95 drivers)
        //
        if ( pszDefaultDataType &&
             *pszDefaultDataType &&
             _wcsicmp(pszEnvironment, szWin95Environment) &&
            !FindDatatype(NULL, pszDefaultDataType))
        {
           LastError = ERROR_INVALID_DATATYPE;
           leave;
        }

        //
        // Validate monitor name (except for Win95 drivers)
        //
        if ( pszMonitorName &&
             *pszMonitorName &&
             _wcsicmp(pszEnvironment, szWin95Environment))
        {
            //
            // Out driver is not a Win9x driver and it has a language monitor
            //
            if (pIniLangMonitor = FindMonitor(pszMonitorName, pLocalIniSpooler))
            {
                //
                // Check if our pIniSpooler is a cluster spooler and we need to copy the
                // language monitor file to disk. Note that FinEnvironment cannot fail.
                // The environment has been validated by now.
                //
                if (bCopyFilesToClusterDisk &&
                    (pIniEnvironment = FindEnvironment(pszEnvironment, pIniSpooler)))
                {
                    DBGMSG(DBG_CLUSTER, ("InternalAddPrinterDriverEx pIniLangMonitor = %x\n", pIniLangMonitor));

                    if ((LastError = PropagateMonitorToCluster(pIniLangMonitor->pName,
                                                               pIniLangMonitor->pMonitorDll,
                                                               pIniEnvironment->pName,
                                                               pIniEnvironment->pDirectory,
                                                               pIniSpooler)) != ERROR_SUCCESS)
                    {
                        //
                        // We failed to propagate the montior to the cluster disk. Fail the call
                        //
                        leave;
                    }
                }
             }
            else
            {
                 DBGMSG(DBG_CLUSTER, ("InternalAddPrinterDriverEx pIniLangMonitor = %x Not found\n", pIniLangMonitor));
                 LastError = ERROR_UNKNOWN_PRINT_MONITOR;
                 leave;
            }
        }

        //
        // Validate environment.
        //
        SPLASSERT(pszEnvironment != NULL);

        if (!FindEnvironment(pszEnvironment, pIniSpooler))
        {
            LastError = ERROR_INVALID_ENVIRONMENT;
            leave;
        }

    } finally {

        if (LastError != ERROR_SUCCESS)
        {
          