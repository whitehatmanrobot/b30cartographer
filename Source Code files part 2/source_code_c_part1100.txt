   KERNEL_STACK_SIZE dup (?)
P0BootStack  label byte


;
; Double fault task stack
;

MINIMUM_TSS_SIZE  EQU     TssIoMaps

        align   16

        public  _KiDoubleFaultTSS
_KiDoubleFaultTSS label byte
        db      MINIMUM_TSS_SIZE dup(0)

        public  _KiNMITSS
_KiNMITSS label byte
        db      MINIMUM_TSS_SIZE dup(0)

;
; Abios specific definitions
;

        public  _KiCommonDataArea, _KiAbiosPresent
_KiCommonDataArea       dd      0
_KiAbiosPresent         dd      0

_DATA   ends

        page ,132
        subttl  "System Startup"
INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; For processor 0, Routine Description:
;
;    This routine is called when the NT system begins execution.
;    Its function is to initialize system hardware state, call the
;    kernel initialization routine, and then fall into code that
;    represents the idle thread for all processors.
;
;    Entry state created by the boot loader:
;       A short-form IDT (0-1f) exists and is active.
;       A complete GDT is set up and loaded.
;       A complete TSS is set up and loaded.
;       Page map is set up with minimal start pages loaded
;           The lower 4Mb of virtual memory are directly mapped into
;           physical memory.
;
;           The system code (ntoskrnl.exe) is mapped into virtual memory
;           as described by its memory descriptor.
;       DS=ES=SS = flat
;       ESP->a usable boot stack
;       Interrupts OFF
;
; For processor > 0, Routine Description:
;
;   This routine is called when each additional processor begins execution.
;   The entry state for the processor is:
;       IDT, GDT, TSS, stack, selectors, PCR = all valid
;       Page directory is set to the current running directory
;       LoaderBlock - parameters for this processor
;
; Arguments:
;
;    PLOADER_PARAMETER_BLOCK LoaderBlock
;
; Return Value:
;
;    None.
;
;--
;
; Arguments for KiSystemStartupPx
;


KissLoaderBlock         equ     [ebp+8]

;
; Local variables
;

KissGdt                 equ     [ebp-4]
KissPcr                 equ     [ebp-8]
KissTss                 equ     [ebp-12]
KissIdt                 equ     [ebp-16]
KissIrql                equ     [ebp-20]
KissPbNumber            equ     [ebp-24]
KissIdleStack           equ     [ebp-28]
KissIdleThread          equ     [ebp-32]

cPublicProc _KiSystemStartup        ,1

        push    ebp
        mov     ebp, esp
        sub     esp, 32                     ; Reserve space for local variables

        mov     ebx, dword ptr KissLoaderBlock
        mov     _KeLoaderBlock, ebx         ; Get loader block param

        movzx   ecx, _KeNumberProcessors    ; get number of processors
        mov     KissPbNumber, ecx
        or      ecx, ecx                    ; Is the the boot processor?
        jnz     @f                          ; no

        ; P0 uses static memory for these
        mov     dword ptr [ebx].LpbThread,      offset _KiIdleThread0
        mov     dword ptr [ebx].LpbKernelStack, offset P0BootStack

        push    KGDT_R0_PCR                 ; P0 needs FS set
        pop     fs

        ; Save processornumber in Prcb
        mov     byte ptr fs:PcPrcbData+PbNumber, cl
@@:
        mov     eax, dword ptr [ebx].LpbThread
        mov     dword ptr KissIdleThread, eax

        mov     eax, dword ptr [ebx].LpbKernelStack
        mov     dword ptr KissIdleStack, eax

        stdCall   _KiInitializeMachineType
        cmp     byte ptr KissPbNumber, 0    ; if not p0, then
        jne     kiss_notp0                  ; skip a bunch

;
;+++++++++++++++++++++++
;
; Initialize the PCR
;

        stdCall   GetMachineBootPointers
;
; Upon return:
;   (edi) -> gdt
;   (esi) -> pcr
;   (edx) -> tss
;   (eax) -> idt
; Now, save them in our local variables
;


        mov     KissGdt, edi
        mov     KissPcr, esi
        mov     KissTss, edx
        mov     KissIdt, eax

;
;       edit TSS to be 32bits.  loader gives us a tss, but it's 16bits!
;
        lea     ecx,[edi]+KGDT_TSS      ; (ecx) -> TSS descriptor
        mov     byte ptr [ecx+5],089h   ; 32bit, dpl=0, present, TSS32, not busy

; KiInitializeTSS2(
;       Linear address of TSS
;       Linear address of TSS descriptor
;       );
        stdCall   _KiInitializeTSS2, <KissTss, ecx>

        stdCall   _KiInitializeTSS, <KissTss>

        mov     cx,KGDT_TSS
        ltr     cx


;
;   set up 32bit double fault task gate to catch double faults.
;

        mov     eax,KissIdt
        lea     ecx,[eax]+40h           ; Descriptor 8
        mov     byte ptr [ecx+5],085h   ; dpl=0, present, taskgate

        mov     word ptr [ecx+2],KGDT_DF_TSS

        lea     ecx,[edi]+KGDT_DF_TSS
        mov     byte ptr [ecx+5],089h   ; 32bit, dpl=0, present, TSS32, not busy

        mov     edx,offset FLAT:_KiDoubleFaultTSS
        mov     eax,edx
        mov     [ecx+KgdtBaseLow],ax
        shr     eax,16
        mov     [ecx+KgdtBaseHi],ah
        mov     [ecx+KgdtBaseMid],al
        mov     eax, MINIMUM_TSS_SIZE
        mov     [ecx+KgdtLimitLow],ax

; KiInitializeTSS(
;       address of double fault TSS
;       );
        stdCall   _KiInitializeTSS, <edx>

        mov     eax,cr3
        mov     [edx+TssCr3],eax

        mov     eax, offset FLAT:_KiDoubleFaultStack
        mov     dword ptr [edx+TssEsp],eax
        mov     dword ptr [edx+TssEsp0],eax

        mov     dword ptr [edx+020h],offset FLAT:_KiTrap08
        mov     dword ptr [edx+024h],0              ; eflags
        mov     word ptr [edx+04ch],KGDT_R0_CODE    ; set value for CS
        mov     word ptr [edx+058h],KGDT_R0_PCR     ; set value for FS
        mov     [edx+050h],ss
        mov     word ptr [edx+048h],KGDT_R3_DATA OR RPL_MASK ; Es
        mov     word ptr [edx+054h],KGDT_R3_DATA OR RPL_MASK ; Ds

;
;   set up 32bit NMI task gate to catch NMI faults.
;

        mov     eax,KissIdt
        lea     ecx,[eax]+10h           ; Descriptor 2
        mov     byte ptr [ecx+5],085h   ; dpl=0, present, taskgate

        mov     word ptr [ecx+2],KGDT_NMI_TSS

        lea     ecx,[edi]+KGDT_NMI_TSS
        mov     byte ptr [ecx+5],089h   ; 32bit, dpl=0, present, TSS32, not busy

        mov     edx,offset FLAT:_KiNMITSS
        mov     eax,edx
        mov     [ecx+KgdtBaseLow],ax
        shr     eax,16
        mov     [ecx+KgdtBaseHi],ah
        mov     [ecx+KgdtBaseMid],al
        mov     eax, MINIMUM_TSS_SIZE
        mov     [ecx+KgdtLimitLow],ax

        push    edx
        stdCall _KiInitializeTSS,<edx>  ; KiInitializeTSS(
                                        ;       address TSS
                                        ;       );

;
; We are using the DoubleFault stack as the DoubleFault stack and the
; NMI Task Gate stack and briefly, it is the DPC stack for the first
; processor.
;

        mov     eax,cr3
        mov     [edx+TssCr3],eax

        mov     eax, offset FLAT:_KiDoubleFaultTSS
        mov     eax, dword ptr [eax+038h]           ; get DF stack
        mov     dword ptr [edx+TssEsp0],eax         ; use it for NMI stack
        mov     dword ptr [edx+038h],eax

        mov     dword ptr [edx+020h],offset FLAT:_KiTrap02
        mov     dword ptr [edx+024h],0              ; eflags
        mov     word ptr [edx+04ch],KGDT_R0_CODE    ; set value for CS
        mov     word ptr [edx+058h],KGDT_R0_PCR     ; set value for FS
        mov     [edx+050h],ss
        mov     word ptr [edx+048h],KGDT_R3_DATA OR RPL_MASK ; Es
        mov     word ptr [edx+054h],KGDT_R3_DATA OR RPL_MASK ; Ds

        stdCall   _KiInitializePcr, <KissPbNumber,KissPcr,KissIdt,KissGdt,KissTss,KissIdleThread,offset FLAT:_KiDoubleFaultStack>

;
; set current process pointer in current thread object
;
        mov     edx, KissIdleThread
        mov     ecx, offset FLAT:_KiIdleProcess ; (ecx)-> idle process obj
        mov     [edx]+ThApcState+AsProcess, ecx ; set addr of thread's process


;
; set up PCR: Teb, Prcb pointers.  The PCR:InitialStack, and various fields
; of Prcb will be set up in _KiInitializeKernel
;

        mov     dword ptr fs:PcTeb, 0   ; PCR->Teb = 0

;
; Initialize KernelDr7 and KernelDr6 to 0.  This must be done before
; the debugger is called.
;

        mov     dword ptr fs:PcPrcbData+PbProcessorState+PsSpecialRegisters+SrKernelDr6,0
        mov     dword ptr fs:PcPrcbData+PbProcessorState+PsSpecialRegisters+SrKernelDr7,0

;
; Since the entries of Kernel IDT have their Selector and Extended Offset
; fields set up in the wrong order, we need to swap them back to the order
; which i386 recognizes.
; This is only done by the bootup processor.
;

        stdCall   _KiSwapIDT                  ; otherwise, do the work

;
;   Switch to R3 flat selectors that we want loaded so lazy segment
;   loading will work.
;
        mov     eax,KGDT_R3_DATA OR RPL_MASK    ; Set RPL = ring 3
        mov     ds,ax
        mov     es,ax

;
; Now copy our trap handlers to replace kernel debugger's handlers.
;

        mov     eax, KissIdt            ; (eax)-> Idt
        push    dword ptr [eax+40h]     ; save double fault's descriptor
        push    dword ptr [eax+44h]
        push    dword ptr [eax+10h]     ; save nmi fault's descriptor
        push    dword ptr [eax+14h]

        mov     edi,KissIdt
        mov     esi,offset FLAT:_IDT
        mov     ecx,offset FLAT:_IDTLEN ; _IDTLEN is really an abs, we use
        shr     ecx,2

        rep     movsd
        pop     dword ptr [eax+14h]     ; restore nmi fault's descriptor
        pop     dword ptr [eax+10h]
        pop     dword ptr [eax+44h]     ; restore double fault's descriptor
        pop     dword ptr [eax+40h]

ifdef QLOCK_STAT_GATHER

        EXTRNP  KiCaptureQueuedSpinlockRoutines,0,,FASTCALL

        fstCall KiCaptureQueuedSpinlockRoutines

endif

kiss_notp0:

ifndef NT_UP

;
; Let the boot processor know this processor is starting.
;

        stdCall _KiProcessorStart

endif

;
; A new processor can't come online while execution is frozen
; Take freezelock while adding a processor to the system
; NOTE: don't use SPINLOCK macro - it has debugger stuff in it
;

if NT_INST
        lea     eax, _KiFreezeExecutionLock
        stdCall _KiAcquireSpinLock, <eax>
else
@@:     test    _KiFreezeExecutionLock, 1
        jnz     short @b

        lock bts _KiFreezeExecutionLock, 0
        jc      short @b
endif


;
; Add processor to active summary, and update BroadcastMasks
;
        mov     ecx, dword ptr KissPbNumber ; mark this processor as active
        mov     byte ptr fs:PcNumber, cl
        mov     eax, 1
        shl     eax, cl                     ; our affinity bit
        mov     fs:PcSetMember, eax
        mov     fs:PcPrcbData.PbSetMember, eax

;
; Initialize the interprocessor interrupt vector and increment ready
; processor count to enable kernel debugger.
;
        stdCall   _HalInitializeProcessor, <dword ptr KissPbNumber, KissLoaderBlock>

        mov     eax, fs:PcSetMember
        or      _KeActiveProcessors, eax    ; New affinity of active processors

;
; Initialize ABIOS data structure if present.
; Note, the KiInitializeAbios MUST be called after the KeLoaderBlock is
; initialized.
;
        stdCall   _KiInitializeAbios, <dword ptr KissPbNumber>

        inc     _KeNumberProcessors         ; One more processor now active

if NT_INST
        lea     eax, _KiFreezeExecutionLock
        stdCall _KiReleaseSpinLock, <eax>
else
        xor     eax, eax                    ; release the executionlock
        mov     _KiFreezeExecutionLock, eax
endif

        cmp     byte ptr KissPbNumber, 0
        jnz     @f

; don't stop in debugger
        stdCall   _KdInitSystem, <0,_KeLoaderBlock>

if  DEVL
;
; Give the debugger an opportunity to gain control.
;

        POLL_DEBUGGER
endif   ; DEVL
@@:
        nop                             ; leave a spot for int-3 patch
;
; Set initial IRQL = HIGH_LEVEL for init
;

        mov     ecx, HIGH_LEVEL
        fstCall KfRaiseIrql
        mov     KissIrql, al
        or      _KiBootFeatureBits, KF_CMPXCHG8B ; We're committed to using

;
; Initialize ebp, esp, and argument registers for initializing the kernel.
;

        mov     ebx, KissIdleThread
        mov     edx, KissIdleStack
        mov     eax, KissPbNumber
        and     edx, NOT 3h             ; align stack to 4 byte boundary

        xor     ebp, ebp                ; (ebp) = 0.   No more stack frame
        mov     esp, edx

;
; Reserve space for idle thread stack NPX_SAVE_AREA and initialization
;

        sub     esp, NPX_FRAME_LENGTH+KTRAP_FRAME_LENGTH+KTRAP_FRAME_ALIGN
        push    CR0_EM+CR0_TS+CR0_MP    ; make space for Cr0NpxState

; arg6 - LoaderBlock
; arg5 - processor number
; arg4 - addr of prcb
; arg3 - idle thread's stack
; arg2 - addr of current thread obj
; arg1 - addr of current process obj

; initialize system data structures
; and HAL.

        stdCall    _KiInitializeKernel,<offset _KiIdleProcess,ebx,edx,dword ptr fs:PcPrcb,eax,_KeLoaderBlock>

;
; Set "shadow" priority value for Idle thread.  This will keep the Mutex
; priority boost/drop code from dropping priority on the Idle thread, and
; thus avoids leaving a bit set in the ActiveMatrix for the Idle thread when
; there should never be any such bit.
;

        mov     ebx,fs:PcPrcbData+PbCurrentThread               ; (eax)->Thread
        mov     byte ptr [ebx]+ThPriority,LOW_REALTIME_PRIORITY ; set pri.

;
; Control is returned to the idle thread with IRQL at HIGH_LEVEL. Lower IRQL
; to DISPATCH_LEVEL and set wait IRQL of idle thread.
;

        sti
        mov     ecx, DISPATCH_LEVEL
        fstCall KfLowerIrql
        mov     byte ptr [ebx]+ThWaitIrql, DISPATCH_LEVEL

;
; The following code represents the idle thread for a processor. The idle
; thread executes at IRQL DISPATCH_LEVEL and continually polls for work to
; do. Control may be given to this loop either as a result of a return from
; the system initialization routine or as the result of starting up another
; processor in a multiprocessor configuration.
;

        mov     ebx, PCR[PcSelfPcr]     ; get address of PCR

;
; In a multiprocessor system the boot processor proceeds directly into
; the idle loop. As other processors start executing, however, they do
; not directly enter the idle loop - they spin until all processors have
; been started and the boot master allows them to proceed.
;

ifndef NT_UP

@@:     cmp     _KiBarrierWait, 0       ; check if barrier set
        YIELD
        jnz     short @b                ; if nz, barrier set

endif

        push    0                       ; terminate KD traceback 0 RA.
        jmp     @KiIdleLoop@0           ; enter idle loop

stdENDP _KiSystemStartup

        page ,132
        subttl  "Set up 80387, or allow for emulation"
;++
;
; Routine Description:
;
;    This routine is called during kernel initialization once for each
;    processor.  It sets EM+TS+MP whether we are emulating or not.
;
;    If the 387 hardware exists, EM+TS+MP will all be cleared on the
;    first trap 07.  Thereafter, EM will never be seen for this thread.
;    MP+TS will only be set when an error is detected (via IRQ 13), and
;    it will be cleared by the trap 07 that will occur on the next FP
;    instruction.
;
;    If we're emulating, EM+TS+MP are all always set to ensure that all
;    FP instructions trap to the emulator (the trap 07 handler is edited
;    to point to the emulator, rather than KiTrap07).
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiSetCR0Bits ,0

        mov     eax, cr0
;
; There are two useful bits in CR0 that we want to turn on if the processor
; is a 486 or above.  (They don't exist on the 386)
;
;       CR0_AM - Alignment mask (so we can turn on alignment faults)
;
;       CR0_WP - Write protect (so we get page faults if we write to a
;                write-protected page from kernel mode)
;
        cmp     byte ptr fs:PcPrcbData.PbCpuType, 3h
        jbe     @f
;
; The processor is not a 386, (486 or greater) so we assume it is ok to
; turn on these bits.
;

        or      eax, CR0_WP

@@:
        mov     cr0, eax
        stdRET  _KiSetCR0Bits

stdENDP _KiSetCR0Bits


ifdef DBGMP
cPublicProc _KiPollDebugger,0
cPublicFpo 0,3
        push    eax
        push    ecx
        push    edx
        POLL_DEBUGGER
        pop     edx
        pop     ecx
        pop     eax
        stdRET    _KiPollDebugger
stdENDP _KiPollDebugger

endif

INIT    ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\spinlock.asm ===
TITLE   "Spin Locks"
;++
;
;  Copyright (c) 1989  Microsoft Corporation
;
;  Module Name:
;
;     spinlock.asm
;
;  Abstract:
;
;     This module implements the routines for acquiring and releasing
;     spin locks.
;
;  Author:
;
;     Bryan Willman (bryanwi) 13 Dec 89
;
;  Environment:
;
;     Kernel mode only.
;
;  Revision History:
;
;   Ken Reneris (kenr) 22-Jan-1991
;       Removed KeAcquireSpinLock macros, and made functions
;--

        PAGE

.586p

include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc

        EXTRNP  KfRaiseIrql,1,IMPORT,FASTCALL
        EXTRNP  KfLowerIrql,1,IMPORT,FASTCALL
        EXTRNP  _KeGetCurrentIrql,0,IMPORT
        EXTRNP  _KeBugCheckEx,5


_TEXT$00   SEGMENT  PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        PAGE
        SUBTTL "Acquire Kernel Spin Lock"
;++
;
;  VOID
;  KeInializeSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;
;  Routine Description:
;
;     This function initializes a SpinLock
;
;  Arguments:
;
;     SpinLock (TOS+4) - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     None.
;
;--
cPublicProc _KeInitializeSpinLock  ,1
cPublicFpo 1,0
        mov     eax, dword ptr [esp+4]
        mov     dword ptr [eax], 0
        stdRET    _KeInitializeSpinLock
stdENDP _KeInitializeSpinLock



        PAGE
        SUBTTL "Ke Acquire Spin Lock At DPC Level"

;++
;
;  VOID
;  KefAcquireSpinLockAtDpcLevel (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function acquires a kernel spin lock.
;
;     N.B. This function assumes that the current IRQL is set properly.
;        It neither raises nor lowers IRQL.
;
;  Arguments:
;
;     (ecx) SpinLock - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     None.
;
;--

align 16
cPublicFastCall KefAcquireSpinLockAtDpcLevel, 1
cPublicFpo 0, 0
if DBG
        push    ecx
        stdCall _KeGetCurrentIrql
        pop     ecx

        cmp     al, DISPATCH_LEVEL
        jl      short asld50
endif

ifdef NT_UP
        fstRET    KefAcquireSpinLockAtDpcLevel
else
;
;   Attempt to assert the lock
;

asld10: ACQUIRE_SPINLOCK    ecx,<short asld20>
        fstRET    KefAcquireSpinLockAtDpcLevel

;
;   Lock is owned, spin till it looks free, then go get it again.
;

align 4
asld20: SPIN_ON_SPINLOCK    ecx,<short asld10>

endif

if DBG
asld50: stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,eax,0,0>
        int       3                 ; help debugger backtrace.
endif

fstENDP KefAcquireSpinLockAtDpcLevel


;++
;
;  VOID
;  KeAcquireSpinLockAtDpcLevel (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;   Thunk for standard call callers
;
;--

cPublicProc _KeAcquireSpinLockAtDpcLevel, 1
cPublicFpo 1,0

ifndef NT_UP
        mov     ecx,[esp+4]         ; SpinLock

aslc10: ACQUIRE_SPINLOCK    ecx,<short aslc20>
        stdRET    _KeAcquireSpinLockAtDpcLevel

aslc20: SPIN_ON_SPINLOCK    ecx,<short aslc10>
endif
        stdRET    _KeAcquireSpinLockAtDpcLevel
stdENDP _KeAcquireSpinLockAtDpcLevel


        PAGE
        SUBTTL "Ke Release Spin Lock From Dpc Level"
;++
;
;  VOID
;  KefReleaseSpinLockFromDpcLevel (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function releases a kernel spin lock.
;
;     N.B. This function assumes that the current IRQL is set properly.
;        It neither raises nor lowers IRQL.
;
;  Arguments:
;
;     (ecx) SpinLock - Supplies a pointer to an executive spin lock.
;
;  Return Value:
;
;     None.
;
;--
align 16
cPublicFastCall KefReleaseSpinLockFromDpcLevel  ,1
cPublicFpo 0,0
ifndef NT_UP
        RELEASE_SPINLOCK    ecx
endif
        fstRET    KefReleaseSpinLockFromDpcLevel

fstENDP KefReleaseSpinLockFromDpcLevel

;++
;
;  VOID
;  KeReleaseSpinLockFromDpcLevel (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;   Thunk for standard call callers
;
;--

cPublicProc _KeReleaseSpinLockFromDpcLevel, 1
cPublicFpo 1,0
ifndef NT_UP
        mov     ecx, [esp+4]            ; (ecx) = SpinLock
        RELEASE_SPINLOCK    ecx
endif
        stdRET    _KeReleaseSpinLockFromDpcLevel
stdENDP _KeReleaseSpinLockFromDpcLevel



        PAGE
        SUBTTL "Ki Acquire Kernel Spin Lock"

;++
;
;  VOID
;  FASTCALL
;  KiAcquireSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function acquires a kernel spin lock.
;
;     N.B. This function assumes that the current IRQL is set properly.
;        It neither raises nor lowers IRQL.
;
;  Arguments:
;
;     (ecx) SpinLock - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     None.
;
;--

align 16
cPublicFastCall KiAcquireSpinLock  ,1
cPublicFpo 0,0
ifndef NT_UP

;
;   Attempt to assert the lock
;

asl10:  ACQUIRE_SPINLOCK    ecx,<short asl20>
        fstRET    KiAcquireSpinLock

;
;   Lock is owned, spin till it looks free, then go get it again.
;

align 4
asl20:  SPIN_ON_SPINLOCK    ecx,<short asl10>

else
        fstRET    KiAcquireSpinLock
endif

fstENDP KiAcquireSpinLock

        PAGE
        SUBTTL "Ki Release Kernel Spin Lock"
;++
;
;  VOID
;  FASTCALL
;  KiReleaseSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function releases a kernel spin lock.
;
;     N.B. This function assumes that the current IRQL is set properly.
;        It neither raises nor lowers IRQL.
;
;  Arguments:
;
;     (ecx) SpinLock - Supplies a pointer to an executive spin lock.
;
;  Return Value:
;
;     None.
;
;--
align 16
cPublicFastCall KiReleaseSpinLock  ,1
cPublicFpo 0,0
ifndef NT_UP

        RELEASE_SPINLOCK    ecx

endif
        fstRET    KiReleaseSpinLock

fstENDP KiReleaseSpinLock

        PAGE
        SUBTTL "Try to acquire Kernel Spin Lock"

;++
;
;  BOOLEAN
;  KeTryToAcquireSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     OUT PKIRQL     OldIrql
;     )
;
;  Routine Description:
;
;     This function attempts acquires a kernel spin lock.  If the
;     spinlock is busy, it is not acquire and FALSE is returned.
;
;  Arguments:
;
;     SpinLock (TOS+4) - Supplies a pointer to an kernel spin lock.
;     OldIrql  (TOS+8) = Location to store old irql
;
;  Return Value:
;     TRUE  - Spinlock was acquired & irql was raise
;     FALSE - SpinLock was not acquired - irql is unchanged.
;
;--

align dword
cPublicProc _KeTryToAcquireSpinLock  ,2
cPublicFpo 2,0

ifdef NT_UP
; UP Version of KeTryToAcquireSpinLock

        mov     ecx, DISPATCH_LEVEL
        fstCall KfRaiseIrql

        mov     ecx, [esp+8]        ; (ecx) -> ptr to OldIrql
        mov     [ecx], al           ; save OldIrql

        mov     eax, 1              ; Return TRUE
        stdRET    _KeTryToAcquireSpinLock

else
; MP Version of KeTryToAcquireSpinLock

        mov     edx,[esp+4]         ; (edx) -> spinlock

;
; First check the spinlock without asserting a lock
;

        TEST_SPINLOCK       edx,<short ttsl10>

;
; Spinlock looks free raise irql & try to acquire it
;

;
; raise to dispatch_level
;

        mov     ecx, DISPATCH_LEVEL
        fstCall KfRaiseIrql

        mov     edx, [esp+4]        ; (edx) -> spinlock
        mov     ecx, [esp+8]        ; (ecx) = Return OldIrql

        ACQUIRE_SPINLOCK    edx,<short ttsl20>

        mov     [ecx], al           ; save OldIrql
        mov     eax, 1              ; spinlock was acquired, return TRUE

        stdRET    _KeTryToAcquireSpinLock

ttsl10: xor     eax, eax            ; return FALSE
        YIELD
        stdRET    _KeTryToAcquireSpinLock

ttsl20:
        YIELD
        mov     cl, al              ; (cl) = OldIrql
        fstCall KfLowerIrql         ; spinlock was busy, restore irql
        xor     eax, eax            ; return FALSE
        stdRET    _KeTryToAcquireSpinLock
endif

stdENDP _KeTryToAcquireSpinLock

        PAGE
        SUBTTL "Ki Try to acquire Kernel Spin Lock"
;++
;
;  BOOLEAN
;  FASTCALL
;  KeTryToAcquireSpinLockAtDpcLevel (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function attempts acquires a kernel spin lock.  If the
;     spinlock is busy, it is not acquire and FALSE is returned.
;
;  Arguments:
;
;     SpinLock (ecx) - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     TRUE  - Spinlock was acquired
;     FALSE - SpinLock was not acquired
;
;--

align dword
cPublicFastCall KeTryToAcquireSpinLockAtDpcLevel  ,1
cPublicFpo 0, 0

;
; First check the spinlock without asserting a lock
;

ifndef NT_UP

        TEST_SPINLOCK       ecx, <short atsl20>

;
; Spinlock looks free try to acquire it.
;

        ACQUIRE_SPINLOCK    ecx, <short atsl20>

endif

        mov     eax, 1              ; spinlock was acquired, return TRUE

        fstRET  KeTryToAcquireSpinLockAtDpcLevel

ifndef NT_UP

atsl20: YIELD                       ;
        xor     eax, eax            ; return FALSE

        fstRET  KeTryToAcquireSpinLockAtDpclevel

endif

fstENDP KeTryToAcquireSpinLockAtDpcLevel

;++
;
;  BOOLEAN
;  KeTestSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function tests a kernel spin lock.  If the spinlock is
;     busy, FALSE is returned.  If not, TRUE is returned.  The spinlock
;     is never acquired.  This is provided to allow code to spin at low
;     IRQL, only raising the IRQL when there is a reasonable hope of
;     acquiring the lock.
;
;  Arguments:
;
;     SpinLock (ecx) - Supplies a pointer to a kernel spin lock.
;
;  Return Value:
;     TRUE  - Spinlock appears available
;     FALSE - SpinLock is busy
;
;--

cPublicFastCall KeTestSpinLock  ,1
        TEST_SPINLOCK       ecx,<short tso10>
        mov       eax, 1
        fstRET    KeTestSpinLock

tso10:  YIELD
        xor       eax, eax
        fstRET    KeTestSpinLock

fstENDP KeTestSpinLock

        page    ,132
        subttl  "Acquire In Stack Queued SpinLock At Dpc Level"

ifdef QLOCK_STAT_GATHER

        EXTRNP  KiQueueStatTrySucceeded,2,,FASTCALL
        EXTRNP  KiQueueStatTryFailed,1,,FASTCALL
        EXTRNP  KiQueueStatTry,1,,FASTCALL
        EXTRNP  KiQueueStatAcquireQueuedLock,1,,FASTCALL
        EXTRNP  KiQueueStatAcquireQueuedLockRTS,1,,FASTCALL
        EXTRNP  KiQueueStatTryAcquire,3,,FASTCALL
        EXTRNP  KiQueueStatReleaseQueuedLock,2,,FASTCALL
        EXTRNP  KiQueueStatAcquire,1,,FASTCALL
        EXTRNP  KiQueueStatRelease,1,,FASTCALL
        EXTRNP  KiAcquireQueuedLock,1,,FASTCALL
        EXTRNP  KiReleaseQueuedLock,1,,FASTCALL

;
; The following routines are used to wrap the actual calls to the 
; real routines which have been usurped here by patching the import
; table.
;

cPublicFastCall __cap_KeAcquireQueuedSpinLock,1
        sub     esp, 8          ; make room to save time
        push    ecx             ; save args
        rdtsc                   ; get time
        mov     [esp].4, eax    ; save low part
        mov     [esp].8, edx    ; save high part
        mov     ecx, [esp]      ; restore arg
        fstCall KiQueueStatAcquireQueuedLock
acqst:  mov     ecx, esp        ; set arg pointer for data accum
        push    eax             ; save result
        fstCall KiQueueStatAcquire
        pop     eax             ; restore result
        add     esp, 12         ; restore stack pointer
        fstRET  __cap_KeAcquireQueuedSpinLock
        fstENDP __cap_KeAcquireQueuedSpinLock

cPublicFastCall __cap_KeAcquireQueuedSpinLockRaiseToSynch,1
        sub     esp, 8          ; make room to save time
        push    ecx             ; save args
        rdtsc                   ; get time
        mov     [esp].4, eax    ; save low part
        mov     [esp].8, edx    ; save high part
        mov     ecx, [esp]      ; restore arg
        fstCall KiQueueStatAcquireQueuedLockRTS
        jmp     short acqst     ; use common code to finish
        fstENDP __cap_KeAcquireQueuedSpinLockRaiseToSynch

cPublicFastCall __cap_KeTryToAcquireQueuedSpinLockRaiseToSynch,2
        push    ecx             ; save arg
        push    SYNCH_LEVEL
tryst:  fstCall KiQueueStatTryAcquire
        push    eax             ; save result
        mov     ecx, esp
        fstCall KiQueueStatTry
        pop     eax             ; restore result
        add     esp, 4          ; drop saved arg
        or      eax, eax        ; some assembly callers expect appropriate flags
        fstRET  __cap_KeTryToAcquireQueuedSpinLockRaiseToSynch
        fstENDP __cap_KeTryToAcquireQueuedSpinLockRaiseToSynch

cPublicFastCall __cap_KeTryToAcquireQueuedSpinLock,2
        push    ecx             ; save arg
        push    DISPATCH_LEVEL
        jmp     short tryst     ; use common code to finish
        fstENDP __cap_KeTryToAcquireQueuedSpinLock

cPublicFastCall __cap_KeReleaseQueuedSpinLock,2
        push    ecx             ; save args
        mov     ecx, esp        ; set arg for stat release routine
        push    edx             ; save other arg
        fstCall KiQueueStatRelease
        pop     edx
        pop     ecx
        fstCall KiQueueStatReleaseQueuedLock
        fstRET  __cap_KeReleaseQueuedSpinLock
        fstENDP __cap_KeReleaseQueuedSpinLock

;
; KeAcquireQueuedSpinLockAtDpcLevel
; KeReleaseQueuedSpinLockFromDpcLevel
;
; These two routines are defined here in assembly code so
; as to capture the caller's address.
;

cPublicFastCall KeAcquireQueuedSpinLockAtDpcLevel,1
        sub     esp, 8          ; make room to save time
        push    ecx             ; save args
        rdtsc                   ; get time
        mov     [esp].4, eax    ; save low part
        mov     [esp].8, edx    ; save high part
        mov     ecx, [esp]      ; restore arg
        fstCall KiAcquireQueuedLock
        mov     ecx, esp
        fstCall KiQueueStatAcquire
        add     esp, 12         ; restore SP
        fstRET  KeAcquireQueuedSpinLockAtDpcLevel
        fstENDP KeAcquireQueuedSpinLockAtDpcLevel

cPublicFastCall KeReleaseQueuedSpinLockFromDpcLevel,1
        push    ecx             ; save args
        mov     ecx, esp        ; set arg for stat release routine
        fstCall KiQueueStatRelease
        pop     ecx
        fstCall KiReleaseQueuedLock
        fstRET  KeReleaseQueuedSpinLockFromDpcLevel
        fstENDP KeReleaseQueuedSpinLockFromDpcLevel

;
; KiCaptureQueuedSpinlockRoutines
;
; Replace the import table entries for the x86 HAL queued spinlock
; routines with our statistic capturing variety.
;

        EXTRNP  KeAcquireQueuedSpinLock,1,IMPORT,FASTCALL
        EXTRNP  KeAcquireQueuedSpinLockRaiseToSynch,1,IMPORT,FASTCALL
        EXTRNP  KeTryToAcquireQueuedSpinLockRaiseToSynch,2,IMPORT,FASTCALL
        EXTRNP  KeTryToAcquireQueuedSpinLock,2,IMPORT,FASTCALL
        EXTRNP  KeReleaseQueuedSpinLock,2,IMPORT,FASTCALL

cPublicFastCall KiCaptureQueuedSpinlockRoutines,0

        mov     eax, @__cap_KeAcquireQueuedSpinLock@4
        mov     [__imp_@KeAcquireQueuedSpinLock@4], eax

        mov     eax, @__cap_KeAcquireQueuedSpinLockRaiseToSynch@4
        mov     [__imp_@KeAcquireQueuedSpinLockRaiseToSynch@4], eax

        mov     eax, @__cap_KeTryToAcquireQueuedSpinLockRaiseToSynch@8
        mov     [__imp_@KeTryToAcquireQueuedSpinLockRaiseToSynch@8], eax

        mov     eax, @__cap_KeTryToAcquireQueuedSpinLock@8
        mov     [__imp_@KeTryToAcquireQueuedSpinLock@8], eax

        mov     eax, @__cap_KeReleaseQueuedSpinLock@8
        mov     [__imp_@KeReleaseQueuedSpinLock@8], eax

        fstRet  KiCaptureQueuedSpinlockRoutines
        fstENDP KiCaptureQueuedSpinlockRoutines

else

;++
;
; VOID
; FASTCALL
; KeAcquireInStackQueuedSpinLockAtDpcLevel (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function acquires the specified in stack queued spin lock at the
;    current IRQL.
;
; Arguments:
;
;    SpinLock (ecx) - Supplies the address of a spin lock.
;
;    LockHandle (edx) - Supplies the address of an in stack lock handle.
;
; Return Value:
;
;    None.
;--

align 16
cPublicFastCall KeAcquireInStackQueuedSpinLockAtDpcLevel,2
cPublicFpo 0,0

ifndef NT_UP

        xor     eax, eax                 ; set next link to NULL
        mov     [edx].LqhNext, eax       ;
        mov     [edx].LqhLock, ecx       ; set spin lock address
        lea     ecx, dword ptr [edx+LqhNext] ; compute address of lock queue
        jmp     short @KeAcquireQueuedSpinLockAtDpcLevel@4 ; finish in common code

else

        fstRET  KeAcquireInStackQueuedSpinLockAtDpcLevel

endif

fstENDP KeAcquireInStackQueuedSpinLockAtDpcLevel

        page    ,132
        subttl  "Acquire Queued SpinLock"

;++
;
; VOID
; KeAcquireQueuedSpinLockAtDpcLevel (
;     IN PKSPIN_LOCK_QUEUE QueuedLock
;     )
;
; Routine Description:
;
;    This function acquires the specified queued spinlock.
;    No change to IRQL is made, IRQL is not returned.  It is
;    expected IRQL is sufficient to avoid context switch.
;
;    Unlike the equivalent Ke versions of these routines,
;    the argument to this routine is the address of the
;    lock queue entry (for the lock to be acquired) in the
;    PRCB rather than the LockQueueNumber.  This saves us
;    a couple of instructions as the address can be calculated
;    at compile time.
;
;    NOTE: This code may be modified for use during textmode
;    setup if this is an MP kernel running with a UP HAL.
;
; Arguments:
;
;    LockQueueEntry (ecx) - Supplies the address of the queued
;                           spinlock entry in this processor's
;                           PRCB.
;
; Return Value:
;
;    None.
;
;    N.B. ecx is preserved, assembly code callers can take advantage
;    of this by avoiding setting up ecx for the call to release if
;    the caller can preserve the lock that long.
;
;--

        ; compile time assert sizeof(KSPIN_LOCK_QUEUE) == 8

.errnz  (LOCK_QUEUE_HEADER_SIZE - 8)

align 16
cPublicFastCall KeAcquireQueuedSpinLockAtDpcLevel,1
cPublicFpo 0,0

ifndef NT_UP

        ; Get address of the actual lock.

        mov     edx, [ecx].LqLock
        mov     eax, ecx                        ; save Lock Queue entry address

        ; Exchange the value of the lock with the address of this
        ; Lock Queue entry.

        xchg    [edx], eax

        cmp     eax, 0                          ; check if lock is held
        jnz     short @f                        ; jiff held

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      edx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [ecx].LqLock, edx

        ; lock has been acquired, return.

aqsl20:

endif

        fstRET  KeAcquireQueuedSpinLockAtDpcLevel

ifndef NT_UP

@@:

if DBG

        ; make sure it isn't already held by THIS processor.

        test    edx, LOCK_QUEUE_OWNER
        jz      short @f

        ; KeBugCheckEx(SPIN_LOCK_ALREADY_OWNED,
        ;             actual lock address,
        ;             my context,
        ;             previous acquirer,
        ;             2);

        stdCall _KeBugCheckEx,<SPIN_LOCK_ALREADY_OWNED,edx,ecx,eax,2>
@@:

endif
        ; The lock is already held by another processor.  Set the wait
        ; bit in this processor's Lock Queue entry, then set the next
        ; field in the Lock Queue entry of the last processor to attempt
        ; to acquire the lock (this is the address returned by the xchg
        ; above) to point to THIS processor's lock queue entry.

        or      edx, LOCK_QUEUE_WAIT            ; set lock bit
        mov     [ecx].LqLock, edx

        mov     [eax].LqNext, ecx               ; set previous acquirer's
                                                ; next field.

        ; Wait.
@@:
        test    [ecx].LqLock, LOCK_QUEUE_WAIT   ; check if still waiting
        jz      short aqsl20                    ; jif lock acquired
        YIELD                                   ; fire avoidance.
        jmp     short @b                        ; else, continue waiting

endif

fstENDP KeAcquireQueuedSpinLockAtDpcLevel

        page    ,132
        subttl  "Release In Stack Queued SpinLock From Dpc Level"
;++
;
; VOID
; FASTCALL
; KeReleaseInStackQueuedSpinLockFromDpcLevel (
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock and preserves the current
;    IRQL.
;
; Arguments:
;
;    LockHandle (ecx) - Supplies the address of a lock handle.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseInStackQueuedSpinLockFromDpcLevel,1
cPublicFpo 0,0

ifndef NT_UP

        lea     ecx, dword ptr[ecx+LqhNext] ; compute address of lock queue
        jmp     short @KeReleaseQueuedSpinLockFromDpcLevel@4 ; finish in common code

else

        fstRET  KeReleaseInStackQueuedSpinLockFromDpcLevel

endif

fstENDP KeReleaseInStackQueuedSpinLockFromDpcLevel

        page    ,132
        subttl  "Release Queued SpinLock"

;++
;
; VOID
; KeReleaseQueuedSpinLockFromDpcLevel (
;     IN PKSPIN_LOCK_QUEUE QueuedLock
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock.
;    No change to IRQL is made, IRQL is not returned.  It is
;    expected IRQL is sufficient to avoid context switch.
;
;    NOTE: This code may be modified for use during textmode
;    setup if this is an MP kernel running with a UP HAL.
;
; Arguments:
;
;    LockQueueEntry (ecx) - Supplies the address of the queued
;                           spinlock entry in this processor's
;                           PRCB.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseQueuedSpinLockFromDpcLevel,1
cPublicFpo 0,0

.errnz  (LOCK_QUEUE_OWNER - 2)           ; error if not bit 1 for btr

ifndef NT_UP


        mov     eax, ecx                        ; need in eax for cmpxchg
        mov     edx, [ecx].LqNext
        mov     ecx, [ecx].LqLock


        ; Quick check: If Lock Queue entry's Next field is not NULL,
        ; there is another waiter.  Don't bother with ANY atomic ops
        ; in this case.
        ;
        ; N.B. Careful ordering, the test will clear the CF bit and set
        ; the ZF bit appropriately if the Next Field (in EDX) is zero.
        ; The BTR will set the CF bit to the previous value of the owner
        ; bit.

        test    edx, edx

        ; Clear the "I am owner" field in the Lock entry.

        btr     ecx, 1                          ; clear owner bit

if DBG
        jnc     short rqsl90                    ; bugcheck if was not set
                                                ; tests CF
endif

        mov     [eax].LqLock, ecx               ; clear lock bit in queue entry
        jnz     short rqsl40                    ; jif another processor waits
                                                ; tests ZF

        xor     edx, edx                        ; new lock owner will be NULL
        push    eax                             ; save &PRCB->LockQueue[Number]

        ; Use compare exchange to attempt to clear the actual lock.
        ; If there are still no processors waiting for the lock when
        ; the compare exchange happens, the old contents of the lock
        ; should be the address of this lock entry (eax).

        lock cmpxchg [ecx], edx                 ; store 0 if no waiters
        pop     eax                             ; restore lock queue address
        jnz     short rqsl60                    ; jif store failed

        ; The lock has been released.  Return to caller.

endif

        fstRET  KeReleaseQueuedSpinLockFromDpcLevel

ifndef NT_UP

        ; Another processor is waiting on this lock.   Hand the lock
        ; to that processor by getting the address of its LockQueue
        ; entry, turning ON its owner bit and OFF its wait bit.

rqsl40: xor     [edx].LqLock, (LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT)

        ; Done, the other processor now owns the lock, clear the next
        ; field in my LockQueue entry (to preserve the order for entering
        ; the queue again) and return.

        mov     [eax].LqNext, 0
        fstRET  KeReleaseQueuedSpinLockFromDpcLevel

        ; We get here if another processor is attempting to acquire
        ; the lock but had not yet updated the next field in this
        ; processor's Queued Lock Next field.   Wait for the next
        ; field to be updated.

rqsl60: mov     edx, [eax].LqNext
        test    edx, edx                        ; check if still 0
        jnz     short rqsl40                    ; jif Next field now set.
        YIELD                                   ; wait a bit
        jmp     short rqsl60                    ; continue waiting

if DBG

rqsl90:
        stdCall _KeBugCheckEx,<SPIN_LOCK_NOT_OWNED,ecx,eax,0,0>
        int     3                               ; help debugger back trace.

endif

endif

fstENDP KeReleaseQueuedSpinLockFromDpcLevel

endif

        page    ,132
        subttl  "Try to Acquire Queued SpinLock"

;++
;
; LOGICAL
; KeTryToAcquireQueuedSpinLockAtRaisedIrql (
;     IN PKSPIN_LOCK_QUEUE QueuedLock
;     )
;
; Routine Description:
;
;    This function attempts to acquire the specified queued spinlock.
;    No change to IRQL is made, IRQL is not returned.  It is
;    expected IRQL is sufficient to avoid context switch.
;
;    NOTE: This code may be modified for use during textmode
;    setup if this is an MP kernel running with a UP HAL.
;
; Arguments:
;
;    LockQueueEntry (ecx) - Supplies the address of the queued
;                           spinlock entry in this processor's
;                           PRCB.
;
; Return Value:
;
;    TRUE if the lock was acquired, FALSE otherwise.
;    N.B. ZF is set if FALSE returned, clear otherwise.
;
;--


align 16
cPublicFastCall KeTryToAcquireQueuedSpinLockAtRaisedIrql,1
cPublicFpo 0,0

ifndef NT_UP

        ; Get address of Lock Queue entry

        mov     edx, [ecx].LqLock

        ; Store the Lock Queue entry address in the lock ONLY if the
        ; current lock value is 0.

        xor     eax, eax                        ; old value must be 0
        lock cmpxchg [edx], ecx
        jnz     short taqsl60

        ; Lock has been acquired.

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      edx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [ecx].LqLock, edx

ifdef QLOCK_STAT_GATHER

        mov     edx, [esp]
        fstCall KiQueueStatTrySucceeded

endif

        or      eax, 1                          ; return TRUE

        fstRET  KeTryToAcquireQueuedSpinLockAtRaisedIrql

taqsl60:

if 0

        ; note: it is not fatal if the current processor already owns the
        ; lock as this is perfectly normal - just return FALSE.

        test    edx, LOCK_QUEUE_OWNER
        jz      short @f

        stdCall _KeBugCheckEx,<SPIN_LOCK_ALREADY_OWNED, edx, ecx,0,1>
@@:

endif

        ; The lock is already held by another processor.  Indicate
        ; failure to the caller.

ifdef QLOCK_STAT_GATHER

        fstCall KiQueueStatTryFailed

endif

        xor     eax, eax                        ; return FALSE
        fstRET  KeTryToAcquireQueuedSpinLockAtRaisedIrql

        ; In the event that this is an MP kernel running with a UP
        ; HAL, the following UP version is copied over the MP version
        ; during kernel initialization.

        public  _KeTryToAcquireQueuedSpinLockAtRaisedIrqlUP
_KeTryToAcquireQueuedSpinLockAtRaisedIrqlUP:

endif

        ; UP version, always succeed.

        xor     eax, eax
        or      eax, 1
        fstRet  KeTryToAcquireQueuedSpinLockAtRaisedIrql

fstENDP KeTryToAcquireQueuedSpinLockAtRaisedIrql


_TEXT$00   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\p2w.asm ===
.286P
_TEXT   SEGMENT  WORD  PUBLIC 'CODE'
_TEXT      ENDS
_DATA   SEGMENT  WORD  PUBLIC 'DATA'
_DATA      ENDS
CONST   SEGMENT  WORD  PUBLIC 'CONST'
CONST      ENDS
_BSS    SEGMENT  WORD  PUBLIC 'BSS'
_BSS      ENDS
    DGROUP GROUP  _DATA, CONST, _BSS
    ASSUME CS:_TEXT, DS:DGROUP, ES:DGROUP, SS:DGROUP
PUBLIC  _p2w
EXTRN   _printf:NEAR

include callconv.inc        ; calling convention macros

_DATA   SEGMENT
s1      db  ' equ 0',0
s2      db  '%hX%04hXH',0ah,0
s3      db  '%hXH',0ah,0
_DATA   ends

_TEXT   segment

;
;   p2w(&ULONG which is value to print)
;
;   if ([bx+2] != 0)
;       printf(bx+2, bx, %x, %04x)
;   else
;       printf(bx, %x)

_p2w    PROC NEAR
; Line 688
        push    bp
        mov     bp, sp
        push    bx
        push    di
        push    si

        push    offset DGROUP:s1
        call    _printf
        add     sp,2

        mov     bx,[bp+4]
        cmp     word ptr [bx+2],0
        jz      p2w10

        push    [bx]
        push    [bx+2]
        push    offset DGROUP:s2
        call    _printf
        add     sp,6
        jmp     p2w20

p2w10:  push    [bx]
        push    offset DGROUP:s3
        call    _printf
        add     sp,4

p2w20:  pop     si
        pop     di
        pop     bx
        leave
        stdRET    _p2w
_p2w    ENDP

_TEXT   ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\spindbg.asm ===
if NT_INST
else
        TITLE   "Spin Locks"
;++
;
;  Copyright (c) 1989  Microsoft Corporation
;
;  Module Name:
;
;     spindbg.asm
;
;  Abstract:
;
;  Author:
;
;     Bryan Willman (bryanwi) 13 Dec 89
;
;  Environment:
;
;     Kernel mode only.
;
;  Revision History:
;
;--

        PAGE

.386p

include ks386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc


if DBG
        EXTRNP  _KeBugCheckEx,5
        EXTRNP  _KeGetCurrentIrql,0,IMPORT
ifdef DBGMP
        EXTRNP  _KiPollDebugger,0
endif
        extrn   _KeTickCount:DWORD
        extrn   _KiSpinlockTimeout:DWORD
endif


_TEXT$00   SEGMENT  DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;  VOID
;  Kii386SpinOnSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     IN ULONG       Flag
;     )
;
;  Routine Description:
;
;     This function is called on a debug build to spin on a spinlock.
;     It is invoked by the DEBUG version of SPIN_ON_SPINLOCK macro.
;
;  Warning:
;
;     Not called with C calling conventions
;     Does not destroy any register
;
;--

cPublicProc Kii386SpinOnSpinLock,2

if DBG
cPublicFpo 2,2
        push    eax
        push    ebx

        mov     eax, [esp+12]           ; (eax) = LockAddress

        mov     ebx, PCR[PcPrcbData.PbCurrentThread]
        or      ebx, 1                  ; or on busy bit
        cmp     ebx, [eax]              ; current thread the owner?
        je      short ssl_sameid        ; Yes, go abort

ssl_10:
        mov     ebx, _KeTickCount       ; Current time
        add     ebx, _KiSpinlockTimeout ; wait n ticks

ifdef DBGMP
        test    byte ptr [esp+16], 2    ; poll debugger while waiting?
        jnz     short ssl_30
endif

;
; Spin while watching KeTickCount
;

ssl_20: YIELD
        cmp     _KeTickCount, ebx       ; check current time
        jnc     short ssl_timeout       ; NC, too many ticks have gone by

        test    dword ptr [eax], 1
        jnz     short ssl_20

ssl_exit:
        pop     ebx                     ; Spinlock is not busy, return
        pop     eax
        stdRET  Kii386SpinOnSpinLock

ifdef DBGMP
;
; Spin while watching KeTickCount & poll debugger
;

ssl_30: YIELD
        cmp     _KeTickCount, ebx       ; check current time
        jnc     short ssl_timeout       ; overflowed

        stdCall _KiPollDebugger

        test    dword ptr [eax], 1
        jnz     short ssl_30

        pop     ebx                     ; Spinlock is not busy, return
        pop     eax
        stdRET  Kii386SpinOnSpinLock
endif

;
; Out of line expection conditions
;

ssl_sameid:
        test    byte ptr [esp+16], 1    ; ID check enabled?
        jz      short ssl_10            ; no, continue

        ; recursed on lock, abort

        stdCall _KeBugCheckEx,<SPIN_LOCK_ALREADY_OWNED,eax,0,0,0>

ssl_timeout:
        test    byte ptr [esp+16], 4    ; Timeout check enabled?
        jz      short ssl_10            ; no, continue

        stdCall _KeGetCurrentIrql       ; Check to see what level we're spinning at
        cmp     al, DISPATCH_LEVEL
        mov     eax, [esp+12]           ; restore eax
        jc      short ssl_10            ; if < dispatch_level, don't timeout

        test    dword ptr [eax], 1      ; Check to see if spinlock was freed
        jz      short ssl_exit

        public SpinLockSpinningForTooLong
SpinLockSpinningForTooLong:

        int 3                           ; Stop here
        jmp     short ssl_10            ; re-wait

else    ; DBG
        stdRET  Kii386SpinOnSpinLock
endif
stdENDP Kii386SpinOnSpinLock,2

_TEXT$00   ends

endif   ; NT_INST
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\procstat.asm ===
title  "Processor State Save Restore"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    procstat.asm
;
; Abstract:
;
;    This module implements procedures for saving and restoring
;    processor control state, and processor run&control state.
;    These procedures support debugging of UP and MP systems.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 30-Aug-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

        EXTRNP  _KeContextToKframes,5
        EXTRNP  _KeContextFromKframes,3
        extrn   _KeFeatureBits:DWORD

        page ,132
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        subttl  "Save Processor State"
;++
;
; KiSaveProcessorState(
;       PKTRAP_FRAME TrapFrame,
;       PKEXCEPTION_FRAME   ExceptionFrame
;       );
;
; Routine Description:
;
;    This routine saves the processor state for debugger.  When the current
;    processor receives the request of IPI_FREEZE, it saves all the registers
;    in a save area in the PRCB so the debugger can get access to them.
;
; Arguments:
;
;    TrapFrame (esp+4) - Pointer to machine trap frame
;
;    ExceptionFrame (esp+8) - Pointer to exception frame
;           (IGNORED on the x86!)
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiSaveProcessorState   ,2

        mov     eax, [esp+4]                    ; (eax) -> TrapFrame

        mov     edx, PCR[PcPrcb]                ; (edx)->PrcbData
        add     edx, PbProcessorState           ; (edx)->ProcessorState
        push    edx
;
; Copy the whole TrapFrame to our ProcessorState
;

        lea     ecx, [edx].PsContextFrame
        mov     dword ptr [ecx].CsContextFlags, CONTEXT_FULL OR CONTEXT_DEBUG_REGISTERS

; ecx - ContextFrame
; 0 - ExceptionFrame == NULL
; eax - TrapFrame
        stdCall   _KeContextFromKframes, <eax, 0, ecx>

;
; Save special registers for debugger
;

        ; TOS = PKPROCESSOR_STATE
        call    _KiSaveProcessorControlState@4

        stdRET  _KiSaveProcessorState

stdENDP _KiSaveProcessorState


        page    ,132
        subttl  "Save Processor Control State"
;++
;
; KiSaveProcessorControlState(
;       PKPROCESSOR_STATE   ProcessorState
;       );
;
; Routine Description:
;
;    This routine saves the control subset of the processor state.
;    (Saves the same information as KiSaveProcessorState EXCEPT that
;     data in TrapFrame/ExceptionFrame=Context record is NOT saved.)
;    Called by the debug subsystem, and KiSaveProcessorState()
;
;   N.B.  This procedure will save Dr7, and then 0 it.  This prevents
;         recursive hardware trace breakpoints and allows debuggers
;         to work.
;
; Arguments:
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiSaveProcessorControlState   ,1

        mov     edx, [esp+4]                    ; ProcessorState

;
; Save special registers for debugger
;
        xor     ecx,ecx

        mov     eax, cr0
        mov     [edx].PsSpecialRegisters.SrCr0, eax
        mov     eax, cr2
        mov     [edx].PsSpecialRegisters.SrCr2, eax
        mov     eax, cr3
        mov     [edx].PsSpecialRegisters.SrCr3, eax

        mov     [edx].PsSpecialRegisters.SrCr4, ecx

        test    _KeFeatureBits, KF_CR4
        jz      short @f

.586p
        mov     eax, cr4
        mov     [edx].PsSpecialRegisters.SrCr4, eax
.486p

@@:
        mov     eax,dr0
        mov     [edx].PsSpecialRegisters.SrKernelDr0,eax
        mov     eax,dr1
        mov     [edx].PsSpecialRegisters.SrKernelDr1,eax
        mov     eax,dr2
        mov     [edx].PsSpecialRegisters.SrKernelDr2,eax
        mov     eax,dr3
        mov     [edx].PsSpecialRegisters.SrKernelDr3,eax
        mov     eax,dr6
        mov     [edx].PsSpecialRegisters.SrKernelDr6,eax

        mov     eax,dr7
        mov     dr7,ecx
        mov     [edx].PsSpecialRegisters.SrKernelDr7,eax

        sgdt    fword ptr [edx].PsSpecialRegisters.SrGdtr
        sidt    fword ptr [edx].PsSpecialRegisters.SrIdtr

        str     word ptr [edx].PsSpecialRegisters.SrTr
        sldt    word ptr [edx].PsSpecialRegisters.SrLdtr

        stdRET    _KiSaveProcessorControlState

stdENDP _KiSaveProcessorControlState

        page ,132
        subttl  "Restore Processor State"
;++
;
; KiRestoreProcessorState(
;       PKTRAP_FRAME TrapFrame,
;       PKEXCEPTION_FRAME ExceptionFrame
;       );
;
; Routine Description:
;
;    This routine Restores the processor state for debugger.  When the
;    control returns from debugger (UnFreezeExecution), this function
;    restores the entire processor state.
;
; Arguments:
;
;    TrapFrame (esp+4) - Pointer to machine trap frame
;
;    ExceptionFrame (esp+8) - Pointer to exception frame
;           (IGNORED on the x86!)
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiRestoreProcessorState   ,2

        mov     eax, [esp+4]                    ; (eax) -> TrapFrame

        mov     edx, PCR[PcPrcb]                ; (edx)->PrcbData
        add     edx, PbProcessorState           ; (edx)->ProcessorState
        push    edx

;
; Copy the whole ContextFrame to TrapFrame
;

        lea     ecx, [edx].PsContextFrame
        mov     edx, [edx].PsContextFrame.CsSegCs
        and     edx, MODE_MASK

; edx - Previous mode
; ecx - ContextFrame
; 0 - ExceptionFrame == NULL
; eax - TrapFrame
        stdCall   _KeContextToKframes, <eax,0,ecx,[ecx].CsContextFlags,edx>

;
; Save special registers for debugger
;

        ; TOS = KPROCESSOR_STATE
        call    _KiRestoreProcessorControlState@4

        stdRET  _KiRestoreProcessorState

stdENDP _KiRestoreProcessorState


        page    ,132
        subttl  "Restore Processor Control State"
;++
;
; KiRestoreProcessorControlState(
;       );
;
; Routine Description:
;
;    This routine restores the control subset of the processor state.
;    (Restores the same information as KiRestoreProcessorState EXCEPT that
;     data in TrapFrame/ExceptionFrame=Context record is NOT restored.)
;    Called by the debug subsystem, and KiRestoreProcessorState()
;
; Arguments:
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiRestoreProcessorControlState,1

        mov     edx, [esp+4]                    ; (edx)->ProcessorState

;
; Restore special registers for debugger
;

        mov     eax, [edx].PsSpecialRegisters.SrCr0
        mov     cr0, eax
        mov     eax, [edx].PsSpecialRegisters.SrCr2
        mov     cr2, eax
        mov     eax, [edx].PsSpecialRegisters.SrCr3
        mov     cr3, eax

        test    _KeFeatureBits, KF_CR4
        jz      short @f

.586p
        mov     eax, [edx].PsSpecialRegisters.SrCr4
        mov     cr4, eax
.486p
@@:
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr0
        mov     dr0, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr1
        mov     dr1, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr2
        mov     dr2, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr3
        mov     dr3, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr6
        mov     dr6, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr7
        mov     dr7, eax

        lgdt    fword ptr [edx].PsSpecialRegisters.SrGdtr
        lidt    fword ptr [edx].PsSpecialRegisters.SrIdtr

;
; Force the TSS descriptor into a non-busy state, so we don't fault
; when we load the TR.
;

        mov     eax, [edx].PsSpecialRegisters.SrGdtr+2  ; (eax)->GDT base
        xor     ecx, ecx
        mov     cx,  word ptr [edx].PsSpecialRegisters.SrTr
        add     eax, 5
        add     eax, ecx                                ; (eax)->TSS Desc. Byte
        and     byte ptr [eax],NOT 2
        ltr     word ptr [edx].PsSpecialRegisters.SrTr

        lldt    word ptr [edx].PsSpecialRegisters.SrLdtr

        stdRET    _KiRestoreProcessorControlState

stdENDP _KiRestoreProcessorControlState

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\threadbg.asm ===
title  "Thread Startup"

;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    threadbg.asm
;
; Abstract:
;
;    This module implements the code necessary to startup a thread in kernel
;    mode.
;
; Author:
;
;    Bryan Willman (bryanwi) 22-Feb-1990, derived from DaveC's code.
;
; Environment:
;
;    Kernel mode only, IRQL APC_LEVEL.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

        EXTRNP   KfLowerIrql,1,IMPORT, FASTCALL
        EXTRNP   _KeBugCheck,1
        extrn   _KiServiceExit2:PROC

        page ,132
        subttl  "Thread Startup"

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; Routine Description:
;
;    This routine is called at thread startup. Its function is to call the
;    initial thread procedure. If control returns from the initial thread
;    procedure and a user mode context was established when the thread
;    was initialized, then the user mode context is restored and control
;    is transfered to user mode. Otherwise a bug check will occur.
;
;
; Arguments:
;
;   (TOS)    = SystemRoutine - address of initial system routine.
;   (TOS+4)  = StartRoutine - Initial thread routine.
;   (TOS+8)  = StartContext - Context parm for initial thread routine.
;   (TOS+12) = UserContextFlag - 0 if no user context, !0 if there is one
;   (TOS+16) = Base of KTrapFrame if and only if there's a user context.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiThreadStartup    ,1

        xor     ebx,ebx             ; clear registers
        xor     esi,esi             ;
        xor     edi,edi             ;
        xor     ebp,ebp             ;
        mov     ecx, APC_LEVEL
        fstCall KfLowerIrql         ; KeLowerIrql(APC_LEVEL)

        pop     eax                 ; (eax)->SystemRoutine
        call    eax                 ; SystemRoutine(StartRoutine, StartContext)
IFNDEF STD_CALL
        add     esp,8               ; Clear off args
ENDIF

        pop     ecx                 ; (ecx) = UserContextFlag
        or      ecx, ecx
        jz      short kits10              ; No user context, go bugcheck

        mov     ebp,esp             ; (bp) -> TrapFrame holding UserContext

        jmp     _KiServiceExit2

kits10: stdCall _KeBugCheck, <NO_USER_MODE_CONTEXT>

stdENDP _KiThreadStartup

_TEXT$00   ends
        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\timindex.asm ===
TITLE   "Compute Timer Table Index"
;++
;
; Copyright (c) 1993  Microsoft Corporation
;
; Module Name:
;
;    timindex.asm
;
; Abstract:
;
;    This module implements the code necessary to compute the timer table
;    index for a timer.
;
; Author:
;
;    David N. Cutler (davec) 19-May-1993
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        extrn  _KiTimeIncrementReciprocal:dword
        extrn  _KiTimeIncrementShiftCount:BYTE

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "Compute Timer Table Index"
;++
;
; ULONG
; KiComputeTimerTableIndex (
;    IN LARGE_INTEGER Interval,
;    IN LARGE_INTEGER CurrentTime,
;    IN PKTIMER Timer
;    )
;
; Routine Description:
;
;    This function computes the timer table index for the specified timer
;    object and stores the due time in the timer object.
;
;    N.B. The interval parameter is guaranteed to be negative since it is
;         expressed as relative time.
;
;    The formula for due time calculation is:
;
;    Due Time = Current Time - Interval
;
;    The formula for the index calculation is:
;
;    Index = (Due Time / Maximum time) & (Table Size - 1)
;
;    The time increment division is performed using reciprocal multiplication.
;
; Arguments:
;
;    Interval  - Supplies the relative time at which the timer is to
;        expire.
;
;    CurrentCount  - Supplies the current system tick count.
;
;    Timer - Supplies a pointer to a dispatch object of type timer.
;
; Return Value:
;
;    The time table index is returned as the function value and the due
;    time is stored in the timer object.
;
;--

LocalStack  equ  20

Interval    equ [esp+LocalStack+4]
CurrentTime equ [esp+LocalStack+12]
Timer       equ [esp+LocalStack+20]

cPublicProc _KiComputeTimerTableIndex ,5
        sub     esp, LocalStack
        mov     [esp+16], ebx
        mov     ebx,CurrentTime         ; get low current time
        mov     ecx,CurrentTime + 4     ; get high current time
        sub     ebx,Interval            ; subtract low parts
        sbb     ecx,Interval + 4        ; subtract high parts and borrow
        mov     eax,Timer               ; get address of timer object
        mov     [eax].TiDueTime.LiLowPart,ebx ; set low part of due time
        mov     [eax].TiDueTime.LiHighPart,ecx ; set high part of due time

;
; Compute low 32-bits of dividend times low 32-bits of divisor.
;

        mov     eax,ebx                 ; copy low 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal] ; multiply by low 32-bits of divisor
        mov     [esp+12], edx           ; save high order 32-bits of product

;
; Compute low 32-bits of dividend times high 32-bits of divisor.
;

        mov     eax,ebx                 ; copy low 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal+4] ;multiply by high 32-bits of divisor
        mov     [esp+8], eax            ; save full 64-bit product
        mov     [esp+4], edx            ;

;
; Compute high 32-bits of dividend times low 32-bits of divisor.
;

        mov     eax,ecx                 ; copy high 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal] ; multiply by low 32-bits of divisor
        mov     [esp+0], edx            ; save high 32-bits of product

;
; Compute carry out of low 64-bits of 128-bit product.
;

        xor     ebx,ebx                 ; clear carry accumlator
        add     eax,[esp]+8             ; generate carry
        adc     ebx,0                   ; accumlate carry
        add     eax,[esp]+12             ; generate carry
        adc     ebx,0                   ; accumulate carry

;
; Compute high 32-bits of dividend times high 32-bits of divisor.
;

        mov     eax,ecx                 ; copy high 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal+4] ; multiply by high 32-bits of divisor

;
; Compute high 64-bits of 128-bit product.
;

        add     eax,ebx                 ; add carry from low 64-bits
        adc     edx,0                   ; propagate carry
        add     eax,[esp]+0             ; add and generate carry
        adc     edx,0                   ; propagate carry
        add     eax,[esp]+4             ; add and generate carry
        adc     edx,0                   ; propagate carry

;
; Right shift the result by the specified shift count and mask off extra
; bits.
;

        mov     cl,[_KiTimeIncrementShiftCount] ; get shift count value
        shrd    eax,edx,cl              ; extract appropriate product bits

        mov     ebx, [esp+16]           ; restore register
        add     esp, LocalStack         ; trim stack
        and     eax,(TIMER_TABLE_SIZE-1); reduce to size of table

        stdRET    _KicomputeTimerTableIndex

stdENDP _KiComputeTimerTableIndex

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\thredini.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    thredini.c

Abstract:

    This module implements the machine dependent function to set the initial
    context and data alignment handling mode for a process or thread object.

Author:

    David N. Cutler (davec) 31-Mar-1990

Environment:

    Kernel mode only.

Revision History:

    3 April 90  bryan willman

        This version ported to 386.

--*/

#include "ki.h"

//
// The following assert macros are used to check that an input object is
// really the proper type.
//

#define ASSERT_PROCESS(E) {                    \
    ASSERT((E)->Header.Type == ProcessObject); \
}

#define ASSERT_THREAD(E) {                    \
    ASSERT((E)->Header.Type == ThreadObject); \
}

//
// Our notion of alignment is different, so force use of ours
//
#undef  ALIGN_UP
#undef  ALIGN_DOWN
#define ALIGN_DOWN(address,amt) ((ULONG)(address) & ~(( amt ) - 1))
#define ALIGN_UP(address,amt) (ALIGN_DOWN( (address + (amt) - 1), (amt) ))

//
// The function prototype for the special APC we use to set the
// hardware alignment state for a thread
//

VOID
KepSetAlignmentSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );


VOID
KiInitializeContextThread (
    IN PKTHREAD Thread,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PCONTEXT ContextFrame OPTIONAL
    )

/*++

Routine Description:

    This function initializes the machine dependent context of a thread object.

    N.B. This function does not check the accessibility of the context record.
         It is assumed the the caller of this routine is either prepared to
         handle access violations or has probed and copied the context record
         as appropriate.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to an arbitrary data structure
        which will be passed to the StartRoutine as a parameter. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    ContextFrame - Supplies an optional pointer a context frame which contains
        the initial user mode state of the thread. This parameter is specified
        if the thread is a user thread and will execute in user mode. If this
        parameter is not specified, then the Teb parameter is ignored.

Return Value:

    None.

--*/

{
    PFX_SAVE_AREA NpxFrame;
    PKSWITCHFRAME SwitchFrame;
    PKTRAP_FRAME TrFrame;
    PULONG PSystemRoutine;
    PULONG PStartRoutine;
    PULONG PStartContext;
    PULONG PUserContextFlag;
    ULONG  ContextFlags;
    CONTEXT Context2;
    PCONTEXT ContextFrame2 = NULL;
    PFXSAVE_FORMAT   PFxSaveArea;

    //
    // If a context frame is specified, then initialize a trap frame and
    // and an exception frame with the specified user mode context.
    //

    if (ARGUMENT_PRESENT(ContextFrame)) {

        RtlCopyMemory(&Context2, ContextFrame, sizeof(CONTEXT));
        ContextFrame2 = &Context2;
        ContextFlags = CONTEXT_CONTROL;

        //
        // The 80387 save area is at the very base of the kernel stack.
        //

        NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->InitialStack) -
                    sizeof(FX_SAVE_AREA)));

        //
        // Load up an initial NPX state.
        //

        if (KeI386FxsrPresent == TRUE) {
            PFxSaveArea = (PFXSAVE_FORMAT)ContextFrame2->ExtendedRegisters;
    
            PFxSaveArea->ControlWord   = 0x27f;  // like fpinit but 64bit mode
            PFxSaveArea->StatusWord    = 0;
            PFxSaveArea->TagWord       = 0;
            PFxSaveArea->ErrorOffset   = 0;
            PFxSaveArea->ErrorSelector = 0;
            PFxSaveArea->DataOffset    = 0;
            PFxSaveArea->DataSelector  = 0;
            PFxSaveArea->MXCsr         = 0x1f80; // mask all the exceptions
        } else {
            ContextFrame2->FloatSave.ControlWord   = 0x27f;  // like fpinit but 64bit mode
            ContextFrame2->FloatSave.StatusWord    = 0;
            ContextFrame2->FloatSave.TagWord       = 0xffff;
            ContextFrame2->FloatSave.ErrorOffset   = 0;
            ContextFrame2->FloatSave.ErrorSelector = 0;
            ContextFrame2->FloatSave.DataOffset    = 0;
            ContextFrame2->FloatSave.DataSelector  = 0;
        }


        if (KeI386NpxPresent) {
            ContextFrame2->FloatSave.Cr0NpxState = 0;
            NpxFrame->Cr0NpxState = 0;
            NpxFrame->NpxSavedCpu = 0;
            if (KeI386FxsrPresent == TRUE) {
                ContextFlags |= CONTEXT_EXTENDED_REGISTERS;
            } else {
                ContextFlags |= CONTEXT_FLOATING_POINT;
            }

            //
            // Threads NPX state is not in the coprocessor.
            //

            Thread->NpxState = NPX_STATE_NOT_LOADED;
            Thread->NpxIrql = PASSIVE_LEVEL;

        } else {
            NpxFrame->Cr0NpxState = CR0_EM;

            //
            // Threads NPX state is not in the coprocessor.
            // In the emulator case, do not set the CR0_EM bit as their
            // emulators may not want exceptions on FWAIT instructions.
            //

            Thread->NpxState = NPX_STATE_NOT_LOADED & ~CR0_MP;
        }

        //
        // Force debug registers off.  They won't work anyway from an
        // initial frame, debuggers must set a hard breakpoint in the target
        //

        ContextFrame2->Dr0 = 0;
        ContextFrame2->Dr1 = 0;
        ContextFrame2->Dr2 = 0;
        ContextFrame2->Dr3 = 0;
        ContextFrame2->Dr6 = 0;
        ContextFrame2->Dr7 = 0;
        ContextFrame2->ContextFlags &= ~(CONTEXT_DEBUG_REGISTERS);
#if 0
        //
        // If AutoAlignment is FALSE, we want to set the Alignment Check bit
        // in Eflags, so we will get alignment faults.
        //

        if (Thread->AutoAlignment == FALSE) {
            ContextFrame2->EFlags |= EFLAGS_ALIGN_CHECK;
        }
#endif
        //
        // If the thread is set

        TrFrame = (PKTRAP_FRAME)(((ULONG)NpxFrame - KTRAP_FRAME_LENGTH));

        //  Space for arguments to KiThreadStartup.  Order is important,
        //  Since args are passed on stack through KiThreadStartup to
        //  PStartRoutine with PStartContext as an argument.

        PUserContextFlag = (PULONG)TrFrame - 1;
        PStartContext = PUserContextFlag - 1;
        PStartRoutine = PStartContext - 1;
        PSystemRoutine = PStartRoutine - 1;

        SwitchFrame = (PKSWITCHFRAME)((PUCHAR)PSystemRoutine -
                                    sizeof(KSWITCHFRAME));

        //
        // Copy information from the specified context frame to the trap and
        // exception frames.
        //

        KeContextToKframes(TrFrame, NULL, ContextFrame2,
                           ContextFrame2->ContextFlags | ContextFlags,
                           UserMode);

        TrFrame->HardwareSegSs |= RPL_MASK;
        TrFrame->SegDs |= RPL_MASK;
        TrFrame->SegEs |= RPL_MASK;

#if DBG
        TrFrame->DbgArgMark = 0xBADB0D00;
#endif

        //
        // Tell KiThreadStartup that a user context is present.
        //

        *PUserContextFlag = 1;


        //
        // Initialize the kernel mode ExceptionList pointer
        //

        TrFrame->ExceptionList = EXCEPTION_CHAIN_END;

        //
        // Initialize the saved previous processor mode.
        //

        TrFrame->PreviousPreviousMode = UserMode;

        //
        // Set the previous mode in thread object to user.
        //

        Thread->PreviousMode = UserMode;


    } else {

        //
        // Dummy floating save area.  Kernel threads don't have or use
        // the floating point - the dummy save area is make the stacks
        // consistent.
        //

        NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->InitialStack) -
                    sizeof(FX_SAVE_AREA)));

        //
        // Load up an initial NPX state.
        //
        RtlZeroMemory((PVOID)NpxFrame, sizeof(FX_SAVE_AREA));

        if (KeI386FxsrPresent == TRUE) {
            NpxFrame->U.FxArea.ControlWord = 0x27f;//like fpinit but 64bit mode
            NpxFrame->U.FxArea.MXCsr       = 0x1f80;// mask all the exceptions
        } else {
            NpxFrame->U.FnArea.ControlWord  = 0x27f;//like fpinit but 64bit mode
            NpxFrame->U.FnArea.TagWord      = 0xffff;
        }

        //
        // Threads NPX state is not in the coprocessor.
        //

        Thread->NpxState = NPX_STATE_NOT_LOADED;

        //
        //  Space for arguments to KiThreadStartup.
        //  Order of fields in the switchframe is important,
        //  Since args are passed on stack through KiThreadStartup to
        //  PStartRoutine with PStartContext as an argument.
        //

        PUserContextFlag = (PULONG)((ULONG)NpxFrame) - 1;

        PStartContext = PUserContextFlag - 1;
        PStartRoutine = PStartContext - 1;
        PSystemRoutine = PStartRoutine - 1;

        SwitchFrame = (PKSWITCHFRAME)((PUCHAR)PSystemRoutine -
                                        sizeof(KSWITCHFRAME));


        //
        // Tell KiThreadStartup that a user context is NOT present.
        //

        *PUserContextFlag = 0;


        //
        // Set the previous mode in thread object to kernel.
        //

        Thread->PreviousMode = KernelMode;
    }

    //
    //  Set up thread start parameters.
    //  (UserContextFlag set above)
    //

    *PStartContext = (ULONG)StartContext;
    *PStartRoutine = (ULONG)StartRoutine;
    *PSystemRoutine = (ULONG)SystemRoutine;


    //
    //  Set up switch frame.  Assume the thread doesn't use the 80387;
    //  if it ever does (and there is one), these flags will get reset.
    //  Each thread starts with these same flags set, regardless of
    //  whether the hardware exists or not.
    //

    SwitchFrame->RetAddr = (ULONG)KiThreadStartup;

    SwitchFrame->Eflags = EFLAGS_INTERRUPT_MASK;

#if 0
    //
    // If AutoAlignment is FALSE, we want to set the Alignment Check bit
    // in Eflags, so we will get alignment faults.
    //

    if (Thread->AutoAlignment == FALSE) {
        SwitchFrame->Eflags |= EFLAGS_ALIGN_CHECK;
    }
#endif

    SwitchFrame->ExceptionList = (ULONG)(EXCEPTION_CHAIN_END);

    //
    // Set the initial kernel stack pointer.
    //

//DbgPrint("KiInitializeContextThread Thread %08x  SwitchFrame %08x\n", Thread, SwitchFrame);
//DbgPrint("PSystemRoutine %08x  PStartRoutine %08x  PStartContext %08x\n", *PSystemRoutine, *PStartRoutine, *PStartContext);

    Thread->KernelStack = (PVOID)SwitchFrame;
    return;
}

BOOLEAN
KeSetAutoAlignmentProcess (
    IN PKPROCESS Process,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function sets the data alignment handling mode for the specified
    process and returns the previous data alignment handling mode.

Arguments:

    Process  - Supplies a pointer to a dispatcher object of type process.

    Enable - Supplies a boolean value that determines the handling of data
        alignment exceptions for the process. A value of TRUE causes all
        data alignment exceptions to be automatically handled by the kernel.
        A value of FALSE causes all data alignment exceptions to be actually
        raised as exceptions.

Return Value:

    A value of TRUE is returned if data alignment exceptions were
    previously automatically handled by the kernel. Otherwise, a value
    of FALSE is returned.

--*/

{

    KIRQL OldIrql;
    BOOLEAN Previous;

    ASSERT_PROCESS(Process);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the previous data alignment handling mode and set the
    // specified data alignment mode.
    //

    Previous = Process->AutoAlignment;
    Process->AutoAlignment = Enable;

    //
    // Unlock dispatcher database, lower IRQL to its previous value, and
    // return the previous data alignment mode.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Previous;
}

BOOLEAN
KeSetAutoAlignmentThread (
    IN PKTHREAD Thread,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function sets the data alignment handling mode for the specified
    thread and returns the previous data alignment handling mode.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    Enable - Supplies a boolean value that determines the handling of data
        alignment exceptions for the specified thread. A value of TRUE causes
        all data alignment exceptions to be automatically handled by the kernel.
        A value of FALSE causes all data alignment exceptions to be actually
        raised as exceptions.

Return Value:

    A value of TRUE is returned if data alignment exceptions were
    previously automatically handled by the kernel. Otherwise, a value
    of FALSE is returned.

--*/

{

    BOOLEAN Previous;
    PKAPC Apc;
    PKEVENT Event;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the previous data alignment handling mode and set the
    // specified data alignment mode.
    //

    Previous = Thread->AutoAlignment;
    Thread->AutoAlignment = Enable;

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

#if 0
    Apc = ExAllocatePool(NonPagedPoolMustSucceed, sizeof(KAPC));
    Event = ExAllocatePool(NonPagedPoolMustSucceed, sizeof(KEVENT));

    KeInitializeEvent(Event, NotificationEvent, FALSE);

    if ( Thread == KeGetCurrentThread() ) {

        Apc->SystemArgument1 = Thread;
        Apc->SystemArgument2 = Event;

        KeRaiseIrql(APC_LEVEL, &Irql);
        KepSetAlignmentSpecialApc( Apc, NULL, NULL,
                                   &Apc->SystemArgument1,
                                   &Apc->SystemArgument2 );
        KeLowerIrql(Irql);
    } else {
        KeInitializeApc( Apc,
                         Thread,
                         CurrentApcEnvironment,
                         KepSetAlignmentSpecialApc,
                         NULL,
                         NULL,
                         KernelMode,
                         NULL );

        if (!KeInsertQueueApc( Apc,
                               Thread,
                               Event,
                               2 ) ) {
            //
            // We couldn't queue the APC, so we will not be able to change
            // the AutoAlignment.  Update the thread object so that it
            // stays in sync with the hardware state.
            //
#if DBG
            DbgPrint("KeSetAutoAlignmentThread: unable to change thread's context\n");
#endif
            Thread->AutoAlignment = Previous;
        }

        KeWaitForSingleObject( Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    }

    ExFreePool(Apc);
    ExFreePool(Event);
#endif

    return(Previous);
}

#if 0

VOID
KepSetAlignmentSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function updates the alignment check bit of the current thread's
    EFLAGS to reflect the AutoAlignment setting of the thread object.

Arguments:

    Apc - Supplies a pointer to the APC control object that caused entry
          into this routine.

    NormalRoutine - Supplies a pointer to a pointer to the normal routine
        function that was specifed when the APC was initialized.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1 - Supplies a pointer to a PKTHREAD

    SystemArgument2 - Supplies a pointer to a PKEVENT

Return Value:

    None.

--*/

{
    PKTHREAD Thread;
    PKEVENT Event;
    PKTRAP_FRAME TrapFrame;
    CONTEXT ContextFrame;

    Thread = *(PKTHREAD *)SystemArgument1;
    Event = *(PKEVENT *)SystemArgument2;

    ASSERT( Thread == KeGetCurrentThread() );

    //
    // Find the trap frame on the stack, so we can get the thread context
    //
    TrapFrame = (PKTRAP_FRAME)((PUCHAR)Thread->InitialStack -
                ALIGN_UP(sizeof(KTRAP_FRAME),KTRAP_FRAME_ALIGN) -
                sizeof(FX_SAVE_AREA));

    ContextFrame.ContextFlags = CONTEXT_CONTROL;

    KeContextFromKframes( TrapFrame,
                          NULL,
                          &ContextFrame );

    //
    // If AutoAlignment is TRUE, we want the processor to transparently fixup
    // all alignment faults, so we clear the Alignment Check bit.  If
    // AutoAlignment is FALSE, we set the bit, so 486 processors will
    // give us alignment faults.
    //

    if (Thread->AutoAlignment) {
        ContextFrame.EFlags &= (~EFLAGS_ALIGN_CHECK);
    } else {
        ContextFrame.EFlags |= EFLAGS_ALIGN_CHECK;
    }

    //
    // Replace the modified EFlags in the trap frame.  When the thread returns
    // to user mode, it will be running with the new alignment setting.
    //

    KeContextToKframes( TrapFrame,
                        NULL,
                        &ContextFrame,
                        CONTEXT_CONTROL,
                        KeGetPreviousMode() );

    KeSetEvent(Event,0,FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\trap.asm ===
title  "Trap Processing"
;++
;
; Copyright (c) 1989-2000  Microsoft Corporation
;
; Module Name:
;
;    trap.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process i386
;    trap conditions.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 4-Feb-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--
.586p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include i386\mi.inc
include ..\..\vdm\i386\vdm.inc
include vdmtib.inc
include fastsys.inc
        .list

FAST_BOP        equ      1


        page ,132
        extrn   _KeI386FxsrPresent:BYTE
        extrn   ExpInterlockedPopEntrySListFault:DWORD
        extrn   ExpInterlockedPopEntrySListResume:DWORD
        extrn   _KeGdiFlushUserBatch:DWORD
        extrn   _KeTickCount:DWORD
        extrn   _ExpTickCountMultiplier:DWORD
        extrn   _KiDoubleFaultTSS:dword
        extrn   _KeErrorMask:dword
        extrn   _KiNMITSS:dword
        extrn   _KeServiceDescriptorTable:dword
if DBG
        extrn   _MmInjectUserInpageErrors:dword
endif
        extrn   _KiHardwareTrigger:dword
        extrn   _KiBugCheckData:dword
        extrn   _KdpOweBreakpoint:byte
        extrn   Ki386BiosCallReturnAddress:near
        extrn   _PoHiberInProgress:byte
        extrn   _KiI386PentiumLockErrataPresent:BYTE
        EXTRNP  _KiDeliverApc,3
        EXTRNP  KfRaiseIrql,1,IMPORT,FASTCALL
        EXTRNP  KfLowerIrql,1,IMPORT,FASTCALL
        EXTRNP  _KeGetCurrentIrql,0,IMPORT
        EXTRNP  _PsConvertToGuiThread,0
        EXTRNP  _ZwUnmapViewOfSection,2

        EXTRNP  _HalHandleNMI,1,IMPORT
        EXTRNP  _HalBeginSystemInterrupt,3,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2,IMPORT
        EXTRNP  _KiDispatchException,5
        EXTRNP  _PsWatchWorkingSet,3
        extrn   _PsWatchEnabled:byte
        EXTRNP  _MmAccessFault,4
        extrn   _MmUserProbeAddress:DWORD
        EXTRNP  _KeBugCheck,1
        EXTRNP  _MmTrimProcessMemory,1
        EXTRNP  _KeBugCheckEx,5
        EXTRNP  _KeTestAlertThread,1
        EXTRNP  _KiContinue,3
        EXTRNP  _KiRaiseException,5
        EXTRNP  _Ki386DispatchOpcode,0
        EXTRNP  _VdmDispatchOpcodeV86_try,1
        EXTRNP  _VdmDispatchPageFault,3
        EXTRNP  _Ki386VdmReflectException,1
        EXTRNP  _Ki386VdmSegmentNotPresent,0
        extrn   _DbgPrint:proc
        EXTRNP  _KdSetOwedBreakpoints
        extrn   _KiFreezeFlag:dword
        EXTRNP  _Ki386CheckDivideByZeroTrap,1
        EXTRNP  _Ki386CheckDelayedNpxTrap,2
        extrn   SwapContext:near
        EXTRNP  _VdmDispatchIRQ13, 1

        EXTRNP  _VdmDispatchBop,1
        EXTRNP  _VdmFetchBop1,1
        EXTRNP  _VdmTibPass1,3
        extrn   _KeI386VdmIoplAllowed:dword
        extrn   _KeI386VirtualIntExtensions:dword
        EXTRNP  _NTFastDOSIO,2
        EXTRNP  _NtSetLdtEntries,6
        extrn   OpcodeIndex:byte
        extrn   _KeFeatureBits:DWORD
        extrn   _KeServiceDescriptorTableShadow:dword
        extrn   _KiIgnoreUnexpectedTrap07:byte

ifndef NT_UP

        EXTRNP  KiAcquireQueuedSpinLockCheckForFreeze,2,,FASTCALL
        EXTRNP  KeReleaseQueuedSpinLockFromDpcLevel,1,,FASTCALL

endif

ifdef _CAPKERN
        extrn   __CAP_SetCPU@0:PROC
        extrn   __CAP_ThreadID@0:PROC
endif

;
; Equates for exceptions which cause system fatal error
;

EXCEPTION_DIVIDED_BY_ZERO       EQU     0
EXCEPTION_DEBUG                 EQU     1
EXCEPTION_NMI                   EQU     2
EXCEPTION_INT3                  EQU     3
EXCEPTION_BOUND_CHECK           EQU     5
EXCEPTION_INVALID_OPCODE        EQU     6
EXCEPTION_NPX_NOT_AVAILABLE     EQU     7
EXCEPTION_DOUBLE_FAULT          EQU     8
EXCEPTION_NPX_OVERRUN           EQU     9
EXCEPTION_INVALID_TSS           EQU     0AH
EXCEPTION_SEGMENT_NOT_PRESENT   EQU     0BH
EXCEPTION_STACK_FAULT           EQU     0CH
EXCEPTION_GP_FAULT              EQU     0DH
EXCEPTION_RESERVED_TRAP         EQU     0FH
EXCEPTION_NPX_ERROR             EQU     010H
EXCEPTION_ALIGNMENT_CHECK       EQU     011H

;
; Exception flags
;

EXCEPT_UNKNOWN_ACCESS           EQU     0H
EXCEPT_LIMIT_ACCESS             EQU     10H

;
; Equates for some opcodes and instruction prefixes
;

IOPL_MASK                       EQU     3000H
IOPL_SHIFT_COUNT                EQU     12

;
; Debug register 6 (dr6) BS (single step) bit mask
;

DR6_BS_MASK                     EQU     4000H

;
; EFLAGS overflow bit
;

EFLAGS_OF_BIT                   EQU     4000H

;
; The mask of selecot's table indicator (ldt or gdt)
;

TABLE_INDICATOR_MASK            EQU     4

;
; Opcode for Pop SegReg and iret instructions
;

POP_DS                          EQU     1FH
POP_ES                          EQU     07h
POP_FS                          EQU     0A10FH
POP_GS                          EQU     0A90FH
IRET_OP                         EQU     0CFH
CLI_OP                          EQU     0FAH
STI_OP                          EQU     0FBH
PUSHF_OP                        EQU     9CH
POPF_OP                         EQU     9DH
INTNN_OP                        EQU     0CDH
FRSTOR_ECX                      EQU     021DD9Bh
FWAIT_OP                        EQU     09bh

;
;   Force assume into place
;

_TEXT$00   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_TEXT$00   ENDS

_DATA   SEGMENT DWORD PUBLIC 'DATA'

;
; Definitions for gate descriptors
;

GATE_TYPE_386INT        EQU     0E00H
GATE_TYPE_386TRAP       EQU     0F00H
GATE_TYPE_TASK          EQU     0500H
D_GATE                  EQU     0
D_PRESENT               EQU     8000H
D_DPL_3                 EQU     6000H
D_DPL_0                 EQU     0

;
; Definitions for present x86 trap and interrupt gate attributes
;

D_TRAP032               EQU     D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_386TRAP
D_TRAP332               EQU     D_PRESENT+D_DPL_3+D_GATE+GATE_TYPE_386TRAP
D_INT032                EQU     D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_386INT
D_INT332                EQU     D_PRESENT+D_DPL_3+D_GATE+GATE_TYPE_386INT
D_TASK                  EQU     D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_TASK

;
;       This is the protected mode interrupt descriptor table.
;

if DBG
;
; NOTE - embedded enlish messages won't fly for NLS! (OK for debug code only)
;

BadInterruptMessage db 0ah,7,7,'!!! Unexpected Interrupt %02lx !!!',0ah,00

Ki16BitStackTrapMessage  db 0ah,'Exception inside of 16bit stack',0ah,00

public KiBiosReenteredAssert
KiBiosReenteredAssert   db 0ah,'Bios has been re-entered. Not safe. ',0ah,00
endif

;
; NMI only one processor at a time.  This is handled in the kernel
; using a queued spinlock to avoid thrashing the lock in case a
; crash dump is underway.
;

KiLockNMI   dd  0

;++
;
;   DEFINE_SINGLE_EMPTY_VECTOR - helper for DEFINE_EMPTY_VECTORS
;
;--

DEFINE_SINGLE_EMPTY_VECTOR macro    number
IDTEntry    _KiUnexpectedInterrupt&number, D_INT032
_TEXT$00   SEGMENT
        public  _KiUnexpectedInterrupt&number
_KiUnexpectedInterrupt&number proc
        push    dword ptr (&number + PRIMARY_VECTOR_BASE)
        ;;  jmp     _KiUnexpectedInterruptTail        ; replaced with following jmp which will then jump
        jmp _KiAfterUnexpectedRange                   ; to the _KiUnexpectedInterruptTail location
                                                      ; in a manner suitable for BBT, which needs to treat
                                                      ; this whole set of KiUnexpectedInterrupt&number
                                                      ; vectors as DATA, meaning a relative jmp will not
                                                      ; be adjusted properly in the BBT Instrumented or
                                                      ; Optimized code.
                                                      ;

_KiUnexpectedInterrupt&number endp
_TEXT$00   ENDS

        endm

FPOFRAME macro a, b
.FPO ( a, b, 0, 0, 0, FPO_TRAPFRAME )
endm

FXSAVE_ESI  macro
    db  0FH, 0AEH, 06
endm

FXSAVE_ECX  macro
    db  0FH, 0AEH, 01
endm

FXRSTOR_ECX macro
    db  0FH, 0AEH, 09
endm

;++
;
;   DEFINE_EMPTY_VECTORS emits an IDTEntry macro (and thus and IDT entry)
;   into the data segment.  It then emits an unexpected interrupt target
;   with push of a constant into the code segment.  Labels in the code
;   segment are defined to bracket the unexpected interrupt targets so
;   that KeConnectInterrupt can correctly test for them.
;
;   Empty vectors will be defined from 30 to ff, which is the hardware
;   vector set.
;
;--

NUMBER_OF_IDT_VECTOR    EQU     0ffH

DEFINE_EMPTY_VECTORS macro

;
;   Set up
;

        empty_vector = 00H

_TEXT$00   SEGMENT
IFDEF STD_CALL
        public  _KiStartUnexpectedRange@0
_KiStartUnexpectedRange@0   equ     $
ELSE
        public  _KiStartUnexpectedRange
_KiStartUnexpectedRange     equ     $
ENDIF
_TEXT$00   ENDS

        rept (NUMBER_OF_IDT_VECTOR - (($ - _IDT)/8)) + 1

        DEFINE_SINGLE_EMPTY_VECTOR  %empty_vector
        empty_vector = empty_vector + 1

        endm    ;; rept

_TEXT$00   SEGMENT
IFDEF STD_CALL
        public  _KiEndUnexpectedRange@0
_KiEndUnexpectedRange@0     equ     $
ELSE
        public  _KiEndUnexpectedRange
_KiEndUnexpectedRange       equ     $
ENDIF


        ;; added by to handle BBT unexpected interrupt problem
        ;;
_KiAfterUnexpectedRange     equ     $               ;;  BBT
        jmp     [KiUnexpectedInterruptTail]         ;;  BBT

KiUnexpectedInterruptTail dd offset _KiUnexpectedInterruptTail   ;;  BBT

        public _KiBBTUnexpectedRange
_KiBBTUnexpectedRange     equ     $               ;;  BBT

_TEXT$00   ENDS

        endm    ;; DEFINE_EMPTY_VECTORS macro

IDTEntry macro  name,access
        dd      offset FLAT:name
        dw      access
        dw      KGDT_R0_CODE
        endm

INIT    SEGMENT DWORD PUBLIC 'CODE'

;
; The IDT table is put into the INIT code segment so the memory
; can be reclaimed afer bootup
;

ALIGN 4
                public  _IDT, _IDTLEN, _IDTEnd
_IDT            label byte

IDTEntry        _KiTrap00, D_INT032             ; 0: Divide Error
IDTEntry        _KiTrap01, D_INT032             ; 1: DEBUG TRAP
IDTEntry        _KiTrap02, D_INT032             ; 2: NMI/NPX Error
IDTEntry        _KiTrap03, D_INT332             ; 3: Breakpoint
IDTEntry        _KiTrap04, D_INT332             ; 4: INTO
IDTEntry        _KiTrap05, D_INT032             ; 5: BOUND/Print Screen
IDTEntry        _KiTrap06, D_INT032             ; 6: Invalid Opcode
IDTEntry        _KiTrap07, D_INT032             ; 7: NPX Not Available
IDTEntry        _KiTrap08, D_INT032             ; 8: Double Exception
IDTEntry        _KiTrap09, D_INT032             ; 9: NPX Segment Overrun
IDTEntry        _KiTrap0A, D_INT032             ; A: Invalid TSS
IDTEntry        _KiTrap0B, D_INT032             ; B: Segment Not Present
IDTEntry        _KiTrap0C, D_INT032             ; C: Stack Fault
IDTEntry        _KiTrap0D, D_INT032             ; D: General Protection
IDTEntry        _KiTrap0E, D_INT032             ; E: Page Fault
IDTEntry        _KiTrap0F, D_INT032             ; F: Intel Reserved

IDTEntry        _KiTrap10, D_INT032             ;10: 486 coprocessor error
IDTEntry        _KiTrap11, D_INT032             ;11: 486 alignment
IDTEntry        _KiTrap0F, D_INT032             ;12: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;13: XMMI unmasked numeric exception
IDTEntry        _KiTrap0F, D_INT032             ;14: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;15: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;16: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;17: Intel Reserved

IDTEntry        _KiTrap0F, D_INT032             ;18: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;19: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1A: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1B: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1C: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1D: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1E: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1F: Reserved for APIC

;
; Note IDTEntry 0x21 is reserved for WOW apps.
;

        rept 2AH - (($ - _IDT)/8)
IDTEntry        0, 0                            ;invalid IDT entry
        endm
IDTEntry        _KiGetTickCount,  D_INT332          ;2A: KiGetTickCount service
IDTEntry        _KiCallbackReturn,  D_INT332        ;2B: KiCallbackReturn
IDTEntry        _KiSetLowWaitHighThread,  D_INT332  ;2C: KiSetLowWaitHighThread service
IDTEntry        _KiDebugService,  D_INT332          ;2D: debugger calls
IDTEntry        _KiSystemService, D_INT332          ;2E: system service calls
IDTEntry        _KiTrap0F, D_INT032                 ;2F: Reserved for APIC

;
;   Generate per-vector unexpected interrupt entries for 30 - ff
;
        DEFINE_EMPTY_VECTORS

_IDTLEN         equ     $ - _IDT
_IDTEnd         equ     $

INIT    ends

                public  _KiUnexpectedEntrySize
_KiUnexpectedEntrySize          dd  _KiUnexpectedInterrupt1 - _KiUnexpectedInterrupt0

;
; defines all the possible instruction prefix
;

PrefixTable     label   byte
        db      0f2h                    ; rep prefix
        db      0f3h                    ; rep ins/outs prefix
        db      67h                     ; addr prefix
        db      0f0h                    ; lock prefix
        db      66h                     ; operand prefix
        db      2eh                     ; segment override prefix:cs
        db      3eh                     ; ds
        db      26h                     ; es
        db      64h                     ; fs
        db      65h                     ; gs
        db      36h                     ; ss

PREFIX_REPEAT_COUNT     EQU     11      ; Prefix table length

;
; defines all the possible IO privileged IO instructions
;

IOInstructionTable      label byte
;       db      0fah                    ; cli
;       db      0fdh                    ; sti
        db      0e4h, 0e5h, 0ech, 0edh  ; IN
        db      6ch, 6dh                ; INS
        db      0e6h, 0e7h, 0eeh, 0efh  ; OUT
        db      6eh, 6fh                ; OUTS

IO_INSTRUCTION_TABLE_LENGTH     EQU     12

;
; definition for  floating status word error mask
;

FSW_INVALID_OPERATION   EQU     1
FSW_DENORMAL            EQU     2
FSW_ZERO_DIVIDE         EQU     4
FSW_OVERFLOW            EQU     8
FSW_UNDERFLOW           EQU     16
FSW_PRECISION           EQU     32
FSW_STACK_FAULT         EQU     64
FSW_CONDITION_CODE_0    EQU     100H
FSW_CONDITION_CODE_1    EQU     200H
FSW_CONDITION_CODE_2    EQU     400H
FSW_CONDITION_CODE_3    EQU     4000H

_DATA   ENDS

_TEXT$00   SEGMENT
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        page , 132
        subttl "Macro to Handle v86 trap d"
;++
;
; Macro Description:
;
;    This macro is a fast way to handle v86 bop instructions.
;    Note, all the memory write operations in this macro are done in such a
;    way that if a page fault occurs the memory will still be in a consistent
;    state.
;
;    That is, we must process the trapped instruction in the following order:
;
;    1. Read and Write user memory
;    2. Update VDM state flags
;    3. Update trap frame
;
; Arguments:
;
;    interrupts disabled
;
; Return Value:
;
;--

FAST_V86_TRAP_6  MACRO

local   DoFastIo, a, b

BOP_FOR_FASTWRITE       EQU     4350C4C4H
BOP_FOR_FASTREAD        EQU     4250C4C4H
TRAP6_IP                EQU     32              ; 8 * 4
TRAP6_CS                EQU     36              ; 8 * 4 + 4
TRAP6_FLAGS             EQU     40              ; 8 * 4 + 8
TRAP6_SP                EQU     44              ; 8 * 4 + 12
TRAP6_SS                EQU     48              ; 8 * 4 + 16
TRAP6_ES                EQU     52
TRAP6_DS                EQU     56
TRAP6_FS                EQU     60
TRAP6_GS                EQU     64
TRAP6_EAX               EQU     28
TRAP6_EDX               EQU     20

        pushad          ;eax, ecx, edx, ebx, old esp, ebp, esi, edi
        mov     eax, KGDT_R3_DATA OR RPL_MASK
        mov     ds, ax
        mov     es, ax

ifndef NT_UP
        mov     eax, KGDT_R0_PCR
        mov     fs, ax
endif

        mov     ax, word ptr [esp+TRAP6_CS] ; [eax] = v86 user cs
        shl     eax, 4
        and     dword ptr [esp+TRAP6_IP], 0FFFFH
        add     eax, [esp+TRAP6_IP]; [eax] = addr of BOP

        ;
        ; Set the magic PCR bit indicating we are executing VDM management code
        ; so faults on potentially invalid or plain bad user addresses do
        ; not bugcheck the system.  Note both interrupts are disabled and
        ; (for performance reasons) we do not have any exception handlers
        ; set up.
        ;

        mov     dword ptr PCR[PcVdmAlert], offset FLAT:V86Trap6Recovery

        ;
        ; Fetch the actual opcode from user space.
        ;

        mov     edx, [eax]      ; [edx] = xxxxc4c4  bop + maj bop # + mi #

        cmp     edx, BOP_FOR_FASTREAD
        je      DoFastIo

        cmp     edx, BOP_FOR_FASTWRITE
        je      DoFastIo

        cmp     dx, 0c4c4h      ; Is it a bop?
        jne     V86Trap6PassThrough ; It's an error condition

        mov     eax,PCR[PcTeb]
        shr     edx, 16
        mov     eax,[eax].TeVdm

        cmp     eax, _MmUserProbeAddress     ; check if user address
        jae     V86Trap6Recovery             ; if ae, then not user address

        and     edx, 0ffh
        mov     dword ptr [eax].VtEIEvent, VdmBop
        mov     dword ptr [eax].VtEIBopNumber, edx
        mov     dword ptr [eax].VtEIInstSize, 3
        lea     eax, [eax].VtVdmContext

        ;
        ;       Save V86 state to Vdm structure
        ;

        mov     edx, [esp+TRAP6_EDX]  ; get edx

        cmp     eax, _MmUserProbeAddress     ; check if user address
        jae     V86Trap6Recovery             ; if ae, then not user address

        mov     [eax].CsEcx, ecx
        mov     [eax].CsEbx, ebx      ; Save non-volatile registers
        mov     [eax].CsEsi, esi
        mov     [eax].CsEdi, edi
        mov     ecx, [esp+TRAP6_EAX]  ; Get eax
        mov     [eax].CsEbp, ebp
        mov     [eax].CsEdx, edx
        mov     [eax].CsEax, ecx

        mov     ebx, [esp]+TRAP6_IP   ; (ebx) = user ip
        mov     ecx, [esp]+TRAP6_CS   ; (ecx) = user cs
        mov     esi, [esp]+TRAP6_SP   ; (esi) = user esp
        mov     edi, [esp]+TRAP6_SS   ; (edi) = user ss
        mov     edx, [esp]+TRAP6_FLAGS; (edx) = user eflags
        mov     [eax].CsEip, ebx
        and     esi, 0ffffh
        mov     [eax].CsSegCs, ecx
        mov     [eax].CsEsp, esi
        mov     [eax].CsSegSs, edi
        test    _KeI386VirtualIntExtensions, V86_VIRTUAL_INT_EXTENSIONS
        jz      short @f

        test    edx, EFLAGS_VIF
        jnz     short a

        and     edx, NOT EFLAGS_INTERRUPT_MASK
        jmp     short a

@@:     test    _KeI386VdmIoplAllowed, 0ffffffffh
        jnz     short a

        test    ds:FIXED_NTVDMSTATE_LINEAR, VDM_VIRTUAL_INTERRUPTS ; check interrupt
        jnz     short a

        and     edx, NOT EFLAGS_INTERRUPT_MASK
a:
        mov     [eax].CsEFlags, edx
        mov     ebx, [esp]+TRAP6_DS   ; (ebx) = user ds
        mov     ecx, [esp]+TRAP6_ES   ; (ecx) = user es
        mov     edx, [esp]+TRAP6_FS   ; (edx) = user fs
        mov     esi, [esp]+TRAP6_GS   ; (esi) = user gs
        mov     [eax].CsSegDs, ebx
        mov     [eax].CsSegEs, ecx
        mov     [eax].CsSegFs, edx
        mov     [eax].CsSegGs, esi

        ;
        ; Load Monitor context
        ;

        add     eax, VtMonitorContext - VtVdmContext ; (eax)->monitor context
        mov     ebx, [eax].CsSegSs
        mov     esi, [eax].CsEsp
        mov     edi, [eax].CsEFlags
        mov     edx, [eax].CsSegCs
        mov     ecx, [eax].CsEip
        sub     esp, 20          ; allocate stack space
        mov     [esp + 16], ebx  ; Build Iret frame (can not single step!)
        mov     [esp + 12], esi
        mov     [esp + 8], edi
        mov     [esp + 4], edx
        mov     [esp + 0], ecx
        mov     ebx, [eax].CsEbx ; We don't need to load volatile registers.
        mov     esi, [eax].CsEsi ; because monitor uses SystemCall to return
        mov     edi, [eax].CsEdi ; back to v86.  C compiler knows that
        mov     ebp, [eax].CsEbp ; SystemCall does not preserve volatile
                                 ; registers.
                                 ; fs, ds are set up already.

        ;
        ; Clear magic flag as no more potentially bogus references will be made.
        ;

        mov     dword ptr PCR[PcVdmAlert], 0

        ;
        ; Adjust Tss esp0 value and set return value to SUCCESS
        ;

        mov     ecx, PCR[PcPrcbData+PbCurrentThread]
        mov     ecx, [ecx].thInitialStack
        mov     edx, PCR[PcTss]
        sub     ecx, NPX_FRAME_LENGTH + TsV86Gs - TsHardwareSegSs
        xor     eax, eax         ; ret status = SUCCESS
        mov     [edx].TssEsp0, ecx

        mov     edx, KGDT_R3_TEB OR RPL_MASK
        mov     fs, dx
        iretd

DoFastIo:

        ;
        ; Clear magic flag as no bogus references are going to be made.
        ;

        mov     dword ptr PCR[PcVdmAlert], 0

        xor     eax, eax
        mov     edx, [esp]+TRAP6_EDX    ; Restore edx
        add     esp, 7 * 4              ; leave eax in the TsErrCode
        xchg    [esp], eax              ; Restore eax, store a zero errcode
        sub     esp, TsErrcode          ; build a trap frame
        mov     [esp].TsEbx, ebx
        mov     [esp].TsEax, eax
        mov     [esp].TsEbp, ebp
        mov     [esp].TsEsi, esi
        mov     [esp].TsEdi, edi
        mov     [esp].TsEcx, ecx
        mov     [esp].TsEdx, edx
if DBG
        mov     [esp].TsPreviousPreviousMode, -1
        mov     [esp]+TsDbgArgMark, 0BADB0D00h
endif
ifdef NT_UP
        mov     ebx, KGDT_R0_PCR
        mov     fs, bx
endif
        mov     ebp, esp
        cld
        test    byte ptr PCR[PcDebugActive], -1
        jz      short @f

        mov     ebx,dr0
        mov     esi,dr1
        mov     edi,dr2
        mov     [ebp]+TsDr0,ebx
        mov     [ebp]+TsDr1,esi
        mov     [ebp]+TsDr2,edi
        mov     ebx,dr3
        mov     esi,dr6
        mov     edi,dr7
        mov     [ebp]+TsDr3,ebx
        mov     [ebp]+TsDr6,esi
        mov     [ebp]+TsDr7,edi
        ;
        ; Load KernelDr* into processor
        ;
        mov     edi,dword ptr fs:[PcPrcb]
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr0
        mov     esi,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr1
        mov     dr0,ebx
        mov     dr1,esi
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr2
        mov     esi,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr3
        mov     dr2,ebx
        mov     dr3,esi
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr6
        mov     esi,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr7
        mov     dr6,ebx
        mov     dr7,esi
@@:
        xor     edx, edx
        mov     dx, word ptr [ebp].TsSegCs
        shl     edx, 4
        xor     ebx, ebx
        add     edx, [ebp].TsEip

        ;
        ; Set the magic PCR bit indicating we are executing VDM management code
        ; so faults on potentially invalid or plain bad user addresses do
        ; not bugcheck the system.  Note both interrupts are disabled and
        ; (for performance reasons) we do not have any exception handlers
        ; set up.
        ;

        mov     dword ptr PCR[PcVdmAlert], offset FLAT:V86Trap6Recovery

        ;
        ; Fetch the actual opcode from user space.
        ;

        mov     bl, [edx+3]             ; [bl] = minor BOP code

        ;
        ; Clear magic flag as no bogus references are going to be made.
        ;

        mov     dword ptr PCR[PcVdmAlert], 0

        ;
        ; Raise Irql to APC level before enabling interrupts.
        ;

        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql
        push    eax                     ; Save OldIrql
        sti

        push    ebx
        push    ebp                     ; (ebp)->TrapFrame
        call    _NTFastDOSIO@8
        jmp     Kt061i

V86Trap6PassThrough:

        ;
        ; Clear magic flag as no bogus references are going to be made.
        ;

        mov     dword ptr PCR[PcVdmAlert], 0

V86Trap6Recovery:
        popad
        jmp     Kt6SlowBop              ; Fall through

endm
        page , 132
        subttl "Macro to dispatch user APC"

;++
;
; Macro Description:
;
;    This macro is called before returning to user mode.  It dispatches
;    any pending user mode APCs.
;
; Arguments:
;
;    TFrame - TrapFrame
;    interrupts disabled
;
; Return Value:
;
;--

DISPATCH_USER_APC   macro   TFrame, ReturnCurrentEax
local   a, b, c
c:
        test    dword ptr [TFrame]+TsEflags, EFLAGS_V86_MASK ; is previous mode v86?
        jnz     short b                             ; if nz, yes, go check for APC
        test    byte ptr [TFrame]+TsSegCs,MODE_MASK ; is previous mode user mode?
        jz      a                                   ; No, previousmode=Kernel, jump out
b:      mov     ebx, PCR[PcPrcbData+PbCurrentThread]; get addr of current thread
        mov     byte ptr [ebx]+ThAlerted, 0         ; clear kernel mode alerted
        cmp     byte ptr [ebx]+ThApcState.AsUserApcPending, 0
        je      a                                   ; if eq, no user APC pending

        mov     ebx, TFrame
ifnb <ReturnCurrentEax>
        mov     [ebx].TsEax, eax        ; Store return code in trap frame
        mov     dword ptr [ebx]+TsSegFs, KGDT_R3_TEB OR RPL_MASK
        mov     dword ptr [ebx]+TsSegDs, KGDT_R3_DATA OR RPL_MASK
        mov     dword ptr [ebx]+TsSegEs, KGDT_R3_DATA OR RPL_MASK
        mov     dword ptr [ebx]+TsSegGs, 0
endif

;
; Save previous IRQL and set new priority level
;
        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql
        push    eax                     ; Save OldIrql

        sti                             ; Allow higher priority ints

;
; call the APC delivery routine.
;
; ebx - Trap frame
; 0 - Null exception frame
; 1 - Previous mode
;
; call APC deliver routine
;

        CAPSTART <c,_KiDeliverApc@12>
        stdCall _KiDeliverApc, <1, 0, ebx>
        CAPEND <c>

        pop     ecx                     ; (ecx) = OldIrql
        fstCall KfLowerIrql

ifnb <ReturnCurrentEax>
        mov     eax, [ebx].TsEax        ; Restore eax, just in case
endif

        cli
        jmp     b

    ALIGN 4
a:
endm


if DBG
        page ,132
        subttl "Processing Exception occurred in a 16 bit stack"
;++
;
; Routine Description:
;
;    This routine is called after an exception being detected during
;    a 16 bit stack.  The system will switch 16 stack to 32 bit
;    stack and bugcheck.
;
; Arguments:
;
;    None.
;
; Return value:
;
;    system stopped.
;
;--

align dword
        public  _Ki16BitStackException
_Ki16BitStackException proc

.FPO (2, 0, 0, 0, 0, FPO_TRAPFRAME)

        push    ss
        push    esp
        mov     eax, esp
        add     eax, fs:PcstackLimit
        mov     esp, eax
        mov     eax, KGDT_R0_DATA
        mov     ss, ax

        lea     ebp, [esp+8]
        cld
        SET_DEBUG_DATA

if DBG
        push    offset FLAT:Ki16BitStackTrapMessage
        call    _dbgPrint
        add     esp, 4
endif
        stdCall _KeBugCheck, <0F000FFFFh> ; Never return
        ret

_Ki16BitStackException endp

endif


        page    ,132
        subttl "System Service Call"
;++
;
; Routine Description:
;
;    This routine gains control when trap occurs via vector 2EH.
;    INT 2EH is reserved for system service calls.
;
;    The system service is executed by locating its routine address in
;    system service dispatch table and calling the specified function.
;    On return necessary state is restored.
;
; Arguments:
;
;    eax - System service number.
;    edx - Pointer to arguments
;
; Return Value:
;
;    eax - System service status code.
;
;--

if 0
;
;   Error and exception blocks for KiSystemService
;

Kss_ExceptionHandler:

;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.
;

        mov     eax, [esp+4]            ; (eax)-> ExceptionRecord
        mov     eax, [eax].ErExceptionCode ; (eax) = Exception code
        mov     esp, [esp+8]            ; (esp)-> ExceptionList

        pop     eax
        mov     PCR[PcExceptionList],eax

        add     esp, 4
        pop     ebp
        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     kss60           ; v86 mode => usermode

        test    dword ptr [ebp].TsSegCs, MODE_MASK ; if premode=kernel
        jnz     kss60                   ; nz, prevmode=user, go return

; raise bugcheck if prevmode=kernel
        stdCall   _KeBugCheck, <KMODE_EXCEPTION_NOT_HANDLED>
endif

;
; The specified system service number is not within range. Attempt to
; convert the thread to a GUI thread if the specified system service is
; not a base service and the thread has not already been converted to a
; GUI thread.
;

Kss_ErrorHandler:
        cmp     ecx, SERVICE_TABLE_TEST ; test if GUI service
        jne     short Kss_LimitError    ; if ne, not GUI service
        push    edx                     ; save argument registers
        push    ebx                     ;
        stdcall _PsConvertToGuiThread   ; attempt to convert to GUI thread
        or      eax, eax                ; check if service was successful
        pop     eax                     ; restore argument registers
        pop     edx                     ;
        mov     ebp, esp                ; reset trap frame address
        mov     [esi]+ThTrapFrame, ebp  ; save address of trap frame
        jz      _KiSystemServiceRepeat  ; if eq, successful conversion

;
; The conversion to a GUI thread failed. The correct return value is encoded
; in a byte table indexed by the service number that is at the end of the
; service address table. The encoding is as follows:
;
;     0 - return 0.
;    -1 - return -1.
;     1 - return status code.
;

        lea     edx, _KeServiceDescriptorTableShadow + SERVICE_TABLE_TEST ;
        mov     ecx, [edx]+SdLimit      ; get service number limit
        mov     edx, [edx]+SdBase       ; get service table base
        lea     edx, [edx][ecx*4]       ; get ending service table address
        and     eax, SERVICE_NUMBER_MASK ; isolate service number
        add     edx, eax                ; compute return value address
        movsx   eax, byte ptr [edx]     ; get status byte
        or      eax, eax                ; check for 0 or -1
        jle     Kss70                   ; if le, return value set

Kss_LimitError:                         ;
        mov     eax, STATUS_INVALID_SYSTEM_SERVICE ; set return status
        jmp     kss70                   ;

ifndef NT_UP

        ENTER_DR_ASSIST kfce_a, kfce_t,NoAbiosAssist,NoV86Assist

endif

        ENTER_DR_ASSIST kss_a, kss_t,NoAbiosAssist,NoV86Assist

;
; Fast System Call entry point
;
;   At entry:
;   EAX = service number
;   EDX = Pointer to caller's arguments
;   ECX = unused
;   ESP = 0
;
; Create a stack frame like a call to inner privilege then continue
; in KiSystemService.
;

;
; Normal entry is at KiFastCallEntry, not KiFastCallEntry2.   Entry
; is via KiFastCallEntry2 if a double fault (trap08) occured and EIP
; was KiFastCallEntry.  This happens if a single step exception occurs
; on the instruction following SYSENTER instruction because there is
; no kernel stack fot the debug exception (trap01) to run on.
;
; This is NOT a performance path.

        PUBLIC _KiFastCallEntry2
_KiFastCallEntry2:

;       Load ESP from Tss.Esp0. ints are disabled and esp is not loaded.

ifndef NT_UP

        mov     esp, KGDT_R0_PCR
        mov     fs, sp
        mov     esp, PCR[PcTss]
        mov     ecx, PCR[PcPrcbData+PbCurrentThread]

else

        mov     esp, ss:PCR[PcTss]
        mov     ecx, ss:PCR[PcPrcbData+PbCurrentThread]

endif ;; NT_UP

        mov     esp, ss:[esp].TssEsp0

        ; undo the effect of using a task switch to get here
        ; this consists of restoring CR0_TS to the correct
        ; value which depends on whether or not the current
        ; thread owns and has loaded the FP resisters.

        cmp     byte ptr [ecx].ThNpxState, NPX_STATE_LOADED
        jne     short @f

        ; thread IS current owner and NPX is loaded, clear
        ; TS bit in CR0.

        clts
@@:

        ; adjust return address in user mode to renable EFLAGS TF so
        ; single step is turned back on.

        mov     ecx, MM_SHARED_USER_DATA_VA+UsSystemCall+fscrOffset+1
        jmp     short Kfsc10

        align 16

        PUBLIC _KiFastCallEntry
_KiFastCallEntry        proc

;
;       Return to the instruction immediately following the sysenter
;       instruction which is at a known location in the shared user
;       data structure (this is so we can dynamically place the right
;       code for the processor at system init).
;

;       Load ESP from Tss.Esp0. ints are disabled and esp is not loaded.

ifndef NT_UP

        mov     ecx, KGDT_R0_PCR
        mov     fs, ecx
        mov     ecx, PCR[PcTss]

else

        mov     ecx, ss:PCR[PcTss]

endif ;; NT_UP

        mov     esp, ss:[ecx].TssEsp0
;
;       Set ecx to return address in user mode
;

        mov     ecx, MM_SHARED_USER_DATA_VA+UsSystemCall+fscrOffset
Kfsc10:
        cmp     esp, PCR[PcInitialStack]    ; Check for call from VDM
        je      Kfsc90                      ; Jif call from VDM
        push    KGDT_R3_DATA  OR RPL_MASK   ; Push user SS
        push    edx                         ; Push ESP
        add     edx, 8                      ; (edx) -> arguments
        push    EFLAGS_INTERRUPT_MASK+2     ; Push sanitized EFlags
        push    2                           ; sanitize EFlags for kernel
        popfd
        push    KGDT_R3_CODE OR RPL_MASK    ; Push user CS
        push    ecx                         ; push return address

ifndef NT_UP

        ; For the MP case, FS is already loaded above

        ENTER_SYSCALL   kfce_a, kfce_t, NoFSLoad
        jmp     _KiSystemServiceRepeat

endif ;; NT_UP

_KiFastCallEntry endp



;
; General System service entrypoint
;

        PUBLIC  _KiSystemService
_KiSystemService        proc

        ENTER_SYSCALL   kss_a, kss_t    ; set up trap frame and save state

?FpoValue = 0

;
; (eax) = Service number
; (edx) = Callers stack pointer
; (esi) = Current thread address
;
; All other registers have been saved and are free.
;
; Check if the service number within valid range
;

_KiSystemServiceRepeat:
        mov     edi, eax                ; copy system service number
        shr     edi, SERVICE_TABLE_SHIFT ; isolate service table number
        and     edi, SERVICE_TABLE_MASK ;
        mov     ecx, edi                ; save service table number
        add     edi, [esi]+ThServiceTable ; compute service descriptor address
        mov     ebx, eax                ; save system service number
        and     eax, SERVICE_NUMBER_MASK ; isolate service table offset

;
; If the specified system service number is not within range, then attempt
; to convert the thread to a GUI thread and retry the service dispatch.
;

        cmp     eax, [edi]+SdLimit      ; check if valid service
        jae     Kss_ErrorHandler        ; if ae, try to convert to GUI thread

;
; If the service is a GUI service and the GDI user batch queue is not empty,
; then call the appropriate service to flush the user batch.
;

        cmp     ecx, SERVICE_TABLE_TEST ; test if GUI service
        jne     short Kss40             ; if ne, not GUI service
        mov     ecx, PCR[PcTeb]         ; get current thread TEB address
        xor     ebx, ebx                ; get number of batched GDI calls

KiSystemServiceAccessTeb:
        or      ebx, [ecx]+TbGdiBatchCount ; may cause an inpage exception

        jz      short Kss40             ; if z, no batched calls
        push    edx                     ; save address of user arguments
        push    eax                     ; save service number
        call    [_KeGdiFlushUserBatch]  ; flush GDI user batch
        pop     eax                     ; restore service number
        pop     edx                     ; restore address of user arguments

;
; The arguments are passed on the stack. Therefore they always need to get
; copied since additional space has been allocated on the stack for the
; machine state frame.  Note that we don't check for the zero argument case -
; copy is always done regardless of the number of arguments because the
; zero argument case is very rare.
;

Kss40:  inc     dword ptr PCR[PcPrcbData+PbSystemCalls] ; system calls

if DBG
        mov     ecx, [edi]+SdCount      ; get count table address
        jecxz   Kss45                   ; if zero, table not specified
        inc     dword ptr [ecx+eax*4]   ; increment service count
Kss45:  push    dword ptr [esi]+ThApcStateIndex ; (ebp-4)
        push    dword ptr [esi]+ThKernelApcDisable ; (ebp-8)

        ;
        ; work around errata 19 which can in some cases cause an
        ; extra dword to be moved in the rep movsd below. In the DBG
        ; build, this will usually case a bugcheck 1 where ebp-8 is no longer
        ; the kernel apc disable count
        ;

        sub     esp,4


?FpoValue = ?FpoValue+3
endif

FPOFRAME ?FpoValue, 0

        mov     esi, edx                ; (esi)->User arguments
        mov     ebx, [edi]+SdNumber     ; get argument table address
        xor     ecx, ecx
        mov     cl, byte ptr [ebx+eax]  ; (ecx) = argument size
        mov     edi, [edi]+SdBase       ; get service table address
        mov     ebx, [edi+eax*4]        ; (ebx)-> service routine
        sub     esp, ecx                ; allocate space for arguments
        shr     ecx, 2                  ; (ecx) = number of argument DWORDs
        mov     edi, esp                ; (es:edi)->location to receive 1st arg
        cmp     esi, _MmUserProbeAddress ; check if user address
        jae     kss80                   ; if ae, then not user address

KiSystemServiceCopyArguments:
        rep     movsd                   ; copy the arguments to top of stack.
                                        ; Since we usually copy more than 3
                                        ; arguments.  rep movsd is faster than
                                        ; mov instructions.
if DBG
;
; Check for user mode call into system at elevated IRQL.
;

        test    byte ptr [ebp]+TsSegCs,MODE_MASK
        jz      short kss50a                  ; kernel mode, skip test
        stdCall _KeGetCurrentIrql
        or      al, al                  ; bogus irql, go bugcheck
        jnz     kss100
kss50a:

        test    _MmInjectUserInpageErrors, 2
        jz      short @f
        stdCall _MmTrimProcessMemory, <0>
        jmp     short kssdoit
@@:

        mov     eax,PCR[PcPrcbData+PbCurrentThread]
        mov     eax,[eax]+ThApcState+AsProcess
        test    dword ptr [eax]+PrFlags,0100000h ; is this a inpage-err process?
        je      short @f
        stdCall _MmTrimProcessMemory, <0>
@@:
endif

;
; Make actual call to system service
;
kssdoit:
        CAPSTARTX <_KiSystemService,ebx>
        call    ebx                     ; call system service
        CAPENDX <_KiSystemService>

kss60:

if DBG
        mov     ecx,PCR[PcPrcbData+PbCurrentThread] ; (ecx)-> Current Thread

;
; Check for return to user mode at elevated IRQL.
;
        test    byte ptr [ebp]+TsSegCs,MODE_MASK
        jz      short kss50b
        mov     esi, eax
        stdCall _KeGetCurrentIrql
        or      al, al
        jnz     kss100                  ; bogus irql, go bugcheck
        mov     eax, esi
kss50b:

;
; Check that APC state has not changed
;
        mov     edx, [ebp-4]
        cmp     dl, [ecx]+ThApcStateIndex
        jne     kss120

        mov     edx, [ebp-8]
        cmp     edx, [ecx]+ThKernelApcDisable
        jne     kss120

endif

kss61:

;
; Upon return, (eax)= status code
;

        mov     esp, ebp                ; deallocate stack space for arguments

;
; Restore old trap frame address from the current trap frame.
;

kss70:  mov     ecx, PCR[PcPrcbData+PbCurrentThread] ; get current thread address
        mov     edx, [ebp].TsEdx        ; restore previous trap frame address
        mov     [ecx].ThTrapFrame, edx  ;

;
;   System service's private version of KiExceptionExit
;   (Also used by KiDebugService)
;
;   Check for pending APC interrupts, if found, dispatch to them
;   (saving eax in frame first).
;
        public  _KiServiceExit
_KiServiceExit:

        cli                                         ; disable interrupts
        DISPATCH_USER_APC   ebp, ReturnCurrentEax

;
; Exit from SystemService
;

        EXIT_ALL    NoRestoreSegs, NoRestoreVolatile

;
; The address of the argument list is not a user address. If the previous mode
; is user, then return an access violation as the status of the system service.
; Otherwise, copy the argument list and execute the system service.
;

kss80:  test    byte ptr [ebp].TsSegCs, MODE_MASK ; test previous mode
        jz      KiSystemServiceCopyArguments ; if z, previous mode kernel
        mov     eax, STATUS_ACCESS_VIOLATION ; set service status
        jmp     kss60                   ;

;++
;
;   _KiServiceExit2 - same as _KiServiceExit BUT the full trap_frame
;       context is restored
;
;--
        public  _KiServiceExit2
_KiServiceExit2:

        cli                             ; disable interrupts
        DISPATCH_USER_APC   ebp

;
; Exit from SystemService
;

        EXIT_ALL                            ; RestoreAll




if DBG
kss100: push    PCR[PcIrql]                 ; put bogus value on stack for dbg
?FpoValue = ?FpoValue + 1
FPOFRAME ?FpoValue, 0
        mov     byte ptr PCR[PcIrql],0      ; avoid recursive trap
        cli

;
; IRQL_GT_ZERO_AT_SYSTEM_SERVICE Returning to usermode at elevated IRQL.
;
; KeBugCheckEx(IRQL_GT_ZERO_AT_SYSTEM_SERVICE,
;              System Call Handler (address of system routine),
;              Irql,
;              0,
;              0,
;              );
;
        stdCall   _KeBugCheckEx,<IRQL_GT_ZERO_AT_SYSTEM_SERVICE, ebx, eax, 0, 0>

;
; APC_INDEX_MISMATCH This is probably caused by the system call entering
; critical regions and not leaving them.   This is fatal.   Include as
; much information in the bugcheck as possible.
;
; KeBugCheckEx(APC_INDEX_MISMATCH,
;              System Call Handler (address of system routine),
;              Thread->ApcStateIndex << 8 | Saved ApcStateIndex,
;              Thread->KernelApcDisable,
;              Saved KernelApcDisable
;              );
;

kss120: mov       eax, [ebp]-4
        mov       ah,  [ecx]+ThApcStateIndex
        stdCall   _KeBugCheckEx,<APC_INDEX_MISMATCH, ebx, eax, [ecx]+ThKernelApcDisable, dword ptr [ebp]-8>

endif
        ret

;
; If the sysenter instruction was executed in 16 bit mode, generate
; an error rather than trying to process the system call.   There is
; no way to return to the correct code in user mode.
;

Kfsc90:
        push    0                           ; save VX86 Es, Ds, Fs, Gs
        push    0
        push    0
        push    0

        push    01bh                        ; save transition CS
        push    0                           ; can't know user esp
        push    EFLAGS_INTERRUPT_MASK+EFLAGS_V86_MASK+2h; eflags with VX86 set
        push    01bh                        ; CS
        push    0                           ; don't know original EIP
        jmp     _KiTrap06                   ; turn exception into illegal op.

_KiSystemService endp

;
; BBT cannot instrument code between this label and BBT_Exclude_Trap_Code_End
;
        public  _BBT_Exclude_Trap_Code_Begin
_BBT_Exclude_Trap_Code_Begin  equ     $
        int 3

;
; Fast path NtGetTickCount
;

align 16
        ENTER_DR_ASSIST kitx_a, kitx_t,NoAbiosAssist
        PUBLIC  _KiGetTickCount
_KiGetTickCount proc

        cmp     [esp+4], KGDT_R3_CODE OR RPL_MASK
        jnz     short @f

Kgtc00:
        mov     eax,dword ptr cs:[_KeTickCount]
        mul     dword ptr cs:[_ExpTickCountMultiplier]
        shrd    eax,edx,24                  ; compute resultant tick count

        iretd
@@:
        ;
        ; if v86 mode, we dont handle it
        ;

        test    dword ptr [esp+8], EFLAGS_V86_MASK
        jnz     ktgc20

        ;
        ; if kernel mode, must be get tick count
        ;

        test    [esp+4], MODE_MASK
        jz      short Kgtc00

        ;
        ; else check if the caller is USER16
        ;   if eax = ebp = 0xf0f0f0f0  it is get-tick-count
        ;   if eax = ebp = 0xf0f0f0f1  it is set-ldt-entry
        ;

        cmp     eax, ebp                ; if eax != ebp, not USER16
        jne     ktgc20

        and     eax, 0fffffff0h
        cmp     eax, 0f0f0f0f0h
        jne     ktgc20

        cmp     ebp, 0f0f0f0f0h         ; Is it user16 gettickcount?
        je      short Kgtc00            ; if z, yes


        cmp     ebp, 0f0f0f0f1h         ; If this is setldt entry
        jne     ktgc20                  ; if nz, we don't know what
                                        ; it is.

        ;
        ; The idea here is that user16 can call 32 bit api to
        ; update LDT entry without going through the penalty
        ; of DPMI.  For Daytona beta.
        ;

        push    0                       ; push dummy error code
        ENTER_TRAP      kitx_a, kitx_t
        sti

        xor     eax, eax
        mov     ebx, [ebp+TsEbx]
        mov     ecx, [ebp+TsEcx]
        mov     edx, [ebp+TsEdx]
        stdCall _NtSetLdtEntries <ebx, ecx, edx, eax, eax, eax>
        mov     [ebp+TsEax], eax
        and     dword ptr [ebp+TsEflags], 0FFFFFFFEH ; clear carry flag
        cmp     eax, 0                  ; success?
        je      short ktgc10

        or      dword ptr [ebp+TsEflags], 1 ; set carry flag
ktgc10:
        jmp     _KiExceptionExit

ktgc20:
        ;
        ; We need to *trap* this int 2a.  For exception, the eip should
        ; point to the int 2a instruction not the instruction after it.
        ;

        sub     word ptr [esp], 2
        push    0
        jmp     _KiTrap0D

_KiGetTickCount endp

        page ,132
        subttl  "Return from User Mode Callback"
;++
;
; NTSTATUS
; NtCallbackReturn (
;    IN PVOID OutputBuffer OPTIONAL,
;    IN ULONG OutputLength,
;    IN NTSTATUS Status
;    )
;
; Routine Description:
;
;    This function returns from a user mode callout to the kernel mode
;    caller of the user mode callback function.
;
;    N.B. This service uses a nonstandard calling sequence.
;
; Arguments:
;
;    OutputBuffer (ecx) - Supplies an optional pointer to an output buffer.
;
;    OutputLength (edx) - Supplies the length of the output buffer.
;
;    Status (esp + 4) - Supplies the status value returned to the caller of
;        the callback function.
;
; Return Value:
;
;    If the callback return cannot be executed, then an error status is
;    returned. Otherwise, the specified callback status is returned to
;    the caller of the callback function.
;
;    N.B. This function returns to the function that called out to user
;         mode is a callout is currently active.
;
;--

align 16
        PUBLIC  _KiCallbackReturn
_KiCallbackReturn proc

        push    fs                      ; save segment register
        push    ecx                     ; save buffer address and return status
        push    eax                     ;
        mov     ecx,KGDT_R0_PCR         ; set PCR segment number
        mov     fs,cx                   ;
        mov     eax,PCR[PcPrcbData + PbCurrentThread] ; get current thread address
        mov     ecx,[eax].ThCallbackStack ; get callback stack address
        or      ecx,ecx                 ; check if callback active
        jz      _KiCbExit               ; if z, no callback active
        mov     edi,[esp] + 4           ; set output buffer address
        mov     esi,edx                 ; set output buffer length
        mov     ebp,[esp] + 0           ; set return status

;
; N.B. The following code is entered with:
;
;    eax - The address of the current thread.
;    ecx - The callback stack address.
;    edi - The output buffer address.
;    esi - The output buffer length.
;    ebp - The callback service status.
;
; Restore the trap frame and callback stack addresses,
; store the output buffer address and length, and set the service status.
;

        cld                             ; clear the direction flag
        mov     ebx,[ecx].CuOutBf       ; get address to store output buffer
        mov     [ebx],edi               ; store output buffer address
        mov     ebx,[ecx].CuOutLn       ; get address to store output length
        mov     [ebx],esi               ; store output buffer length
        mov     esi,PCR[PcInitialStack] ; get source NPX save area address
        mov     ebx,[ecx]               ; get previous initial stack address
        mov     [eax].ThInitialStack,ebx ; restore initial stack address
        sub     ebx,NPX_FRAME_LENGTH    ; compute destination NPX save area
        test    byte ptr [eax].ThDebugActive, -1

; All we want to do is to copy ControlWord, StatusWord and TagWord from
; the source NPX save area. So we always copy first 3 dwords, irrespective
; of the fact whether the save was done using fxsave or fnsave.

        mov     edx,[esi].FpControlWord ; copy NPX state to previous frame
        mov     [ebx].FpControlWord,edx ;
        mov     edx,[esi].FpStatusWord  ;
        mov     [ebx].FpStatusWord,edx  ;
        mov     edx,[esi].FpTagWord     ;
        mov     [ebx].FpTagWord,edx     ;
        mov     edx,[esi].FpCr0NpxState ;
        mov     [ebx].FpCr0NpxState,edx ;
        mov     edx,PCR[PcTss]          ; get address of task switch segment
        mov     PCR[PcInitialStack],ebx ; restore stack check base address
        lea     ebx, [ebx]-(TsV86Gs-TsHardwareSegSs); bias missing V86 fields
        mov     [edx].TssEsp0,ebx       ; restore kernel entry stack address
        lea     esp, [ecx]+4            ; trim stack back to callback frame
        jnz     short _KiCbDebugRegs    ; restore kernel Debug Registers
_KiCbRet:
        sti                             ; enable interrupts
        pop     [eax].ThTrapFrame       ; restore current trap frame address
        pop     [eax].ThCallbackStack   ; restore callback stack address
        mov     eax,ebp                 ; set callback service status

;
; Restore nonvolatile registers, clean call parameters from stack, and
; return to callback caller.
;

        pop     edi                     ; restore nonvolatile registers
        pop     esi                     ;
        pop     ebx                     ;
        pop     ebp                     ;
        pop     edx                     ; save return address
        add     esp,8                   ; remove parameters from stack
        jmp     edx                     ; return to callback caller

;
; Restore Kernel Mode debug registers.
;

_KiCbDebugRegs:
        mov     edi, PCR[PcPrcb]
        xor     ecx, ecx                ; Make Dr7 safe
        mov     dr7, ecx
        mov     ebx, [edi].PbProcessorState.PsSpecialRegisters.SrKernelDr0
        mov     ecx, [edi].PbProcessorState.PsSpecialRegisters.SrKernelDr1
        mov     dr0, ebx
        mov     dr1, ecx
        mov     ebx, [edi].PbProcessorState.PsSpecialRegisters.SrKernelDr2
        mov     ecx, [edi].PbProcessorState.PsSpecialRegisters.SrKernelDr3
        mov     dr2, ebx
        mov     dr3, ecx
        mov     ebx, [edi].PbProcessorState.PsSpecialRegisters.SrKernelDr6
        mov     ecx, [edi].PbProcessorState.PsSpecialRegisters.SrKernelDr7
        mov     dr6, ebx
        mov     dr7, ecx
        jmp     short _KiCbRet

;
; Restore segment register, set systerm service status, and return.
;

_KiCbExit:                              ;
        add     esp, 2 * 4              ; remove saved registers from stack
        pop     fs                      ; restore segment register
        mov     eax,STATUS_NO_CALLBACK_ACTIVE ; set service status
        iretd                           ;

_KiCallbackReturn endp

;
; Fast path Nt/Zw SetLowWaitHighThread
;

        ENTER_DR_ASSIST kslwh_a, kslwh_t,NoAbiosAssist,NoV86Assist
align 16
        PUBLIC  _KiSetLowWaitHighThread
_KiSetLowWaitHighThread proc

        ENTER_SYSCALL   kslwh_a, kslwh_t ; Set up trap frame

        mov     eax,STATUS_NO_EVENT_PAIR ; set service status
        mov     edx,[ebp].TsEdx         ; restore old trap frame address
        mov     [esi].ThTrapFrame,edx   ;
        jmp     _KiServiceExit

_KiSetLowWaitHighThread endp

        page ,132
        subttl  "Common Trap Exit"



;++
;
;   KiUnexpectedInterruptTail
;
;   Routine Description:
;       This function is jumped to by an IDT entry who has no interrupt
;       handler.
;
;   Arguments:
;
;       (esp)   - Dword, vector
;       (esp+4) - Processor generated IRet frame
;
;--

        ENTER_DR_ASSIST kui_a, kui_t

        public  _KiUnexpectedInterruptTail
_KiUnexpectedInterruptTail  proc
        ENTER_INTERRUPT kui_a, kui_t, PassDwordParm

        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

        mov     ebx, [esp]      ; get vector & leave it on the stack
        sub     esp, 4          ; make space for OldIrql

; esp - ptr to OldIrql
; ebx - Vector
; HIGH_LEVEL - Irql
        stdCall   _HalBeginSystemInterrupt, <HIGH_LEVEL,ebx,esp>
        or      eax, eax
        jnz     short kui10

;
; spurious interrupt
;
        add     esp, 8
        jmp     short kee99

kui10:
if DBG
        push    dword ptr [esp+4]       ; Vector #
        push    offset FLAT:BadInterruptMessage
        call    _DbgPrint               ; display unexpected interrupt message
        add     esp, 8
endif
;
; end this interrupt
;
        INTERRUPT_EXIT

_KiUnexpectedInterruptTail  endp



;++
;
; N.B. KiExceptionExit and Kei386EoiHelper are identical and have
;      been combined.
;
;   KiExceptionExit
;
;   Routine Description:
;
;       This code is transfered to at the end of the processing for
;       an exception.  Its function is to restore machine state, and
;       continue thread execution.  If control is returning to user mode
;       and there is a user APC pending, then control is transfered to
;       the user APC delivery routine.
;
;       N.B. It is assumed that this code executes at IRQL zero or APC_LEVEL.
;          Therefore page faults and access violations can be taken.
;
;       NOTE: This code is jumped to, not called.
;
;   Arguments:
;
;       (ebp) -> base of trap frame.
;
;   Return Value:
;
;       None.
;
;--
;++
;
;   Kei386EoiHelper
;
;   Routine Description:
;
;       This code is transfered to at the end of an interrupt.  (via the
;       exit_interrupt macro).  It checks for user APC dispatching and
;       performs the exit_all for the interrupt.
;
;       NOTE: This code is jumped to, not called.
;
;   Arguments:
;
;       (esp) -> base of trap frame.
;       interrupts are disabled
;
;   Return Value:
;
;       None.
;
;--

align 4
        public  _KiExceptionExit
cPublicProc Kei386EoiHelper, 0
_KiExceptionExit:
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        cli                             ; disable interrupts
        DISPATCH_USER_APC   ebp

;
; Exit from Exception
;

kee99:

        EXIT_ALL       ,,NoPreviousMode

stdENDP Kei386EoiHelper


;
;   V86ExitHelp
;
;       Restore volatiles for V86 mode, and move seg regs
;
;   Arguments:
;
;      esp = ebp = &TrapFrame
;
;   Return Value:
;
;      None, returns to previous mode using IRETD.
;

align dword
V86ExitHelp:

        add     esp,TsEdx
        pop     edx
        pop     ecx
        pop     eax

        lea     esp, [ebp]+TsEdi        ; Skip PreMode, ExceptList and fs

        pop     edi                     ; restore non-volatiles
        pop     esi
        pop     ebx
        pop     ebp

;
; Esp MUST point to the Error Code on the stack.  Because we use it to
; store the entering esp.
;

        cmp     word ptr [esp+8], 80h   ; check for abios code segment?
        ja      AbiosExitHelp

v86eh90:

        add     esp, 4                  ; remove error code from trap frame
        iretd                           ; return

Abios_ExitHelp_Target2:

;
; End of ABIOS stack check
;
;
;   AbiosExit:
;
;       This routine remaps current 32bit stack to 16bit stack at return
;       from interrupt time and returns from interrupt.
;
;   Arguments:
;
;       (esp) -> TrapFrame
;
;   Return Value:
;
;      None, returns to previous mode using IRETD.
;      Note: May use above exit to remove error code from stack.
;


align dword
AbiosExitHelp:
        cmp     word ptr [esp+2], 0     ; (esp+2) = Low word of error code
        jz      short v86eh90
        cmp     word ptr [esp], 0       ; (esp) = High word of error code
        jnz     short v86eh90

        shr     dword ptr [esp], 16
        mov     word ptr [esp + 2], KGDT_STACK16
        lss     sp, dword ptr [esp]
        movzx   esp, sp
        iretd                           ; return

        page , 132
        subttl "trap processing"

;++
;
; Routine Description:
;
;    _KiTrapxx - protected mode trap entry points
;
;    These entry points are for internally generated exceptions,
;    such as a general protection fault.  They do not handle
;    external hardware interrupts, or user software interrupts.
;
; Arguments:
;
;    On entry the stack looks like:
;
;       [ss]
;       [esp]
;       eflags
;       cs
;       eip
;    ss:sp-> [error]
;
;    The cpu saves the previous SS:ESP, eflags, and CS:EIP on
;    the new stack if there was a privilige transition. If no
;    priviledge level transition occurred, then there is no
;    saved SS:ESP.
;
;    Some exceptions save an error code, others do not.
;
; Return Value:
;
;       None.
;
;--


        page , 132
        subttl "Macro to dispatch exception"

;++
;
; Macro Description:
;
;    This macro allocates exception record on stack, sets up exception
;    record using specified parameters and finally sets up arguments
;    and calls _KiDispatchException.
;
; Arguments:
;
;    ExcepCode - Exception code to put into exception record
;    ExceptFlags - Exception flags to put into exception record
;    ExceptRecord - Associated exception record
;    ExceptAddress - Addr of instruction which the hardware exception occurs
;    NumParms - Number of additional parameters
;    ParameterList - the additional parameter list
;
; Return Value:
;
;    None.
;
;--

DISPATCH_EXCEPTION macro ExceptCode, ExceptFlags, ExceptRecord, ExceptAddress,\
                         NumParms, ParameterList
        local de10, de20

.FPO ( ExceptionRecordSize/4+NumParms, 0, 0, 0, 0, FPO_TRAPFRAME )

; Set up exception record for raising exception

?i      =       0
        sub     esp, ExceptionRecordSize + NumParms * 4
                                        ; allocate exception record
        mov     dword ptr [esp]+ErExceptionCode, ExceptCode
                                        ; set up exception code
        mov     dword ptr [esp]+ErExceptionFlags, ExceptFlags
                                        ; set exception flags
        mov     dword ptr [esp]+ErExceptionRecord, ExceptRecord
                                        ; set associated exception record
        mov     dword ptr [esp]+ErExceptionAddress, ExceptAddress
        mov     dword ptr [esp]+ErNumberParameters, NumParms
                                        ; set number of parameters
        IRP     z, <ParameterList>
        mov     dword ptr [esp]+(ErExceptionInformation+?i*4), z
?i      =       ?i + 1
        ENDM

; set up arguments and call _KiDispatchException

        mov     ecx, esp                ; (ecx)->exception record
        mov     eax,[ebp]+TsSegCs

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jz      de10

        mov     eax,0FFFFh
de10:   and     eax,MODE_MASK

; 1 - first chance TRUE
; eax - PreviousMode
; ebp - trap frame addr
; 0 - Null exception frame
; ecx - exception record addr

; dispatchexception as appropriate
        stdCall   _KiDispatchException, <ecx, 0, ebp, eax, 1>

        mov     esp, ebp                ; (esp) -> trap frame

        ENDM

        page , 132
        subttl "dispatch exception"

;++
;
; CommonDispatchException
;
; Routine Description:
;
;    This routine allocates exception record on stack, sets up exception
;    record using specified parameters and finally sets up arguments
;    and calls _KiDispatchException.
;
;    NOTE:
;
;    The purpose of this routine is to save code space.  Use this routine
;    only if:
;    1. ExceptionRecord is NULL
;    2. ExceptionFlags is 0
;    3. Number of parameters is less or equal than 3.
;
;    Otherwise, you should use DISPATCH_EXCEPTION macro to set up your special
;    exception record.
;
; Arguments:
;
;    (eax) = ExcepCode - Exception code to put into exception record
;    (ebx) = ExceptAddress - Addr of instruction which the hardware exception occurs
;    (ecx) = NumParms - Number of additional parameters
;    (edx) = Parameter1
;    (esi) = Parameter2
;    (edi) = Parameter3
;
; Return Value:
;
;    None.
;
;--
CommonDispatchException0Args:
        xor     ecx, ecx                ; zero arguments
        call    CommonDispatchException

CommonDispatchException1Arg0d:
        xor     edx, edx                ; zero edx
CommonDispatchException1Arg:
        mov     ecx, 1                  ; one argument
        call    CommonDispatchException ; there is no return

CommonDispatchException2Args0d:
        xor     edx, edx                ; zero edx
CommonDispatchException2Args:
        mov     ecx, 2                  ; two arguments
        call    CommonDispatchException ; there is no return

      public CommonDispatchException
align dword
CommonDispatchException proc
cPublicFpo 0, ExceptionRecordLength/4
;
;       Set up exception record for raising exception
;

        sub     esp, ExceptionRecordLength
                                        ; allocate exception record
        mov     dword ptr [esp]+ErExceptionCode, eax
                                        ; set up exception code
        xor     eax, eax
        mov     dword ptr [esp]+ErExceptionFlags, eax
                                        ; set exception flags
        mov     dword ptr [esp]+ErExceptionRecord, eax
                                        ; set associated exception record
        mov     dword ptr [esp]+ErExceptionAddress, ebx
        mov     dword ptr [esp]+ErNumberParameters, ecx
                                        ; set number of parameters
        cmp     ecx, 0
        je      short de00

        lea     ebx, [esp + ErExceptionInformation]
        mov     [ebx], edx
        mov     [ebx+4], esi
        mov     [ebx+8], edi
de00:
;
; set up arguments and call _KiDispatchException
;

        mov     ecx, esp                ; (ecx)->exception record
        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jz      short de10

        mov     eax,0FFFFh
        jmp     short de20

de10:   mov     eax,[ebp]+TsSegCs
de20:   and     eax,MODE_MASK

; 1 - first chance TRUE
; eax - PreviousMode
; ebp - trap frame addr
; 0 - Null exception frame
; ecx - exception record addr

        stdCall _KiDispatchException,<ecx, 0, ebp, eax, 1>

        mov     esp, ebp                ; (esp) -> trap frame
        jmp     _KiExceptionExit

CommonDispatchException endp

        page , 132
        subttl "Macro to verify base trap frame"

;++
;
; Macro Description:
;
;   This macro verifies the base trap frame is intact.
;
;   It is possible while returning to UserMode that we take an exception.
;   Any exception which may block, such as not-present, needs to verify
;   that the base trap frame is not partially dismantled.
;
; Arguments:
;   The macro MUST be used directly after ENTER_TRAP macro
;   as it assumes all sorts of stuff about ESP!
;
; Return Value:
;
;   If the base frame was incomplete it is totally restored and the
;   return EIP of the current frame is (virtually) backed up to the
;   begining of the exit_all - the effect is that the base frame
;   will be completely exited again.  (ie, the exit_all of the base
;   frame is atomic, if it's interrupted we restore it and do it over).
;
;    None.
;
;--

VERIFY_BASE_TRAP_FRAME macro
       local    vbfdone

        mov     eax, esp
        sub     eax, PCR[PcInitialStack] ; Bias out this stack
        add     eax, KTRAP_FRAME_LENGTH ; adjust for base frame
        je      short vbfdone           ; if eq, then this is the base frame

        cmp     eax, -TsEflags          ; second frame is only this big
        jc      short vbfdone           ; is stack deeper then 2 frames?
                                        ; yes, then done
    ;
    ; Stack usage is not exactly one frame, and it's not large enough
    ; to be two complete frames; therefore, we may have a partial base
    ; frame. (unless it's a kernel thread)
    ;
    ; See if this is a kernel thread as kernel threads don't have a base
    ; frame (and therefore don't need correcting).
    ;

        mov     eax, PCR[PcTeb]
        or      eax, eax                ; Any Teb?
        jle     short vbfdone           ; Br if zero or kernel thread address

        call    KiRestoreBaseFrame

    align 4
vbfdone:
        ENDM

;++ KiRestoreBaseFrame
;
; Routine Description:
;
;   Only to be used from VERIFY_BASE_TRAP_FRAME macro.
;   Makes lots of assumptions about esp & trap frames
;
; Arguments:
;
;   Stack:
;       +-------------------------+
;       |                         |
;       |                         |
;       | Npx save area           |
;       |                         |
;       |                         |
;       +-------------------------+
;       | (possible mvdm regs)    |
;       +-------------------------+  <- fs:PcInitialStack
;       |                         |
;       | Partial base trap frame |
;       |                         |
;       |             ------------+
;       +------------/            |  <- Esp @ time of current frame. Location
;       |                         |     where base trap frame is incomplete
;       | Completed 'current'     |
;       |  trap frame             |
;       |                         |
;       |                         |
;       |                         |
;       |                         |
;       +-------------------------+  <- EBP
;       | return address (dword)  |
;       +-------------------------+  <- current ESP
;       |                         |
;       |                         |
;
; Return:
;
;   Stack:
;       +-------------------------+
;       |                         |
;       |                         |
;       | Npx save area           |
;       |                         |
;       |                         |
;       +-------------------------+
;       | (possible mvdm regs)    |
;       +-------------------------+  <- fs:PcInitialStack
;       |                         |
;       | Base trap frame         |
;       |                         |
;       |                         |
;       |                         |
;       |                         |
;       |                         |
;       +-------------------------+  <- return esp & ebp
;       |                         |
;       | Current trap frame      |
;       |                         |  EIP set to begining of
;       |                         |  exit_all code
;       |                         |
;       |                         |
;       |                         |
;       +-------------------------+  <- EBP, ESP
;       |                         |
;       |                         |
;
;--

;
; KiRestoreBaseFrame has 2 problems:
;
; 1. It reaches into the instruction stream below which may be paged out
;    and since interrupts are disabled on entry, this case is fatal.
; 2. It doesn't correctly factor the case of partial frames that are built
;    when a conversion to GUI thread is made.
;

KiRestoreBaseFrame proc
        pop     ebx                     ; Get return address
IF DBG
        mov     eax, [esp].TsEip        ; EIP of trap

    ;
    ; This code is to handle a very specific problem of a not-present
    ; fault during an exit_all.  If it's not this problem then stop.
    ;
        cmp     word ptr [eax], POP_GS
        je      short @f
        cmp     byte ptr [eax], POP_ES
        je      short @f
        cmp     byte ptr [eax], POP_DS
        je      short @f
        cmp     word ptr [eax], POP_FS
        je      short @f
        cmp     byte ptr [eax], IRET_OP
        je      short @f
        int 3
@@:
ENDIF
    ;
    ; Move current trap frame out of the way to make space for
    ; a full base trap frame
    ;
        mov     edi, PCR[PcInitialStack]
        sub     edi, KTRAP_FRAME_LENGTH + TsEFlags + 4 ; (edi) = bottom of target
        mov     esi, esp                ; (esi) = bottom of source
        mov     esp, edi                ; make space before copying the data
        mov     ebp, edi                ; update location of our trap frame
        push    ebx                     ; put return address back on stack

        mov     ecx, (TsEFlags+4)/4     ; # of dword to move
        rep     movsd                   ; Move current trap frame

    ;
    ; Part of the base frame was destroyed when the current frame was
    ; originally pushed.  Now that the current frame has been moved out of
    ; the way restore the base frame.  We know that any missing data from
    ; the base frame was reloaded into it's corrisponding registers which
    ; were then pushed into the current frame.  So we can restore the missing
    ; data from the current frame.
    ;
        mov     ecx, esi                ; Location of esp at time of fault
        mov     edi, PCR[PcInitialStack]
        sub     edi, KTRAP_FRAME_LENGTH ; (edi) = base trap frame
        mov     ebx, edi

        sub     ecx, edi                ; (ecx) = # of bytes which were
                                        ; removed from base frame before
                                        ; trap occured
IF DBG
        test    ecx, 3
        jz      short @f                ; assume dword alignments only
        int 3
@@:
ENDIF
        mov     esi, ebp                ; (esi) = current frame
        shr     ecx, 2                  ; copy in dwords
        rep     movsd
    ;
    ; The base frame is restored.  Instead of backing EIP up to the
    ; start of the interrupted EXIT_ALL, we simply move the EIP to a
    ; well known EXIT_ALL.  However, this causes a couple of problems
    ; since this exit_all restores every register whereas the original
    ; one may not.  So:
    ;
    ;   - When exiting from a system call, eax is normally returned by
    ;     simply not restoring it.  We 'know' that the current trap frame's
    ;     EAXs is always the correct one to return.  (We know this because
    ;     exit_all always restores eax (if it's going to) before any other
    ;     instruction which may cause a fault).
    ;
    ;   - Not all enter's push the PreviousPreviousMode.  Since this is
    ;     the base trap frame we know that this must be UserMode.
    ;
        mov     eax, [ebp].TsEax                    ; make sure correct
        mov     [ebx].TsEax, eax                    ; eax is in base frame
        mov     byte ptr [ebx].TsPreviousPreviousMode, 1    ; UserMode

        mov     [ebp].TsEbp, ebx
        mov     [ebp].TsEip, offset _KiServiceExit2 ; ExitAll which

                                                    ; restores everything
    ;
    ; Since we backed up Eip we need to reset some of the kernel selector
    ; values in case they were already restored by the attempted base frame pop
    ;
        mov     dword ptr [ebp].TsSegDs, KGDT_R3_DATA OR RPL_MASK
        mov     dword ptr [ebp].TsSegEs, KGDT_R3_DATA OR RPL_MASK
        mov     dword ptr [ebp].TsSegFs, KGDT_R0_PCR

    ;
    ; The backed up EIP is before interrupts were disabled.  Re-enable
    ; interrupts for the current trap frame
    ;
        or      [ebp].TsEFlags, EFLAGS_INTERRUPT_MASK

        ret

KiRestoreBaseFrame endp

        page ,132
        subttl "Divide error processing"
;++
;
; Routine Description:
;
;    Handle divide error fault.
;
;    The divide error fault occurs if a DIV or IDIV instructions is
;    executed with a divisor of 0, or if the quotient is too big to
;    fit in the result operand.
;
;    An INTEGER DIVIDED BY ZERO exception will be raised for the fault.
;    If the fault occurs in kernel mode, the system will be terminated.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction.
;    No error code is provided with the divide error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
        ENTER_DR_ASSIST kit0_a, kit0_t,NoAbiosAssist
align dword
        public  _KiTrap00
_KiTrap00       proc

        push    0                       ; push dummy error code
        ENTER_TRAP      kit0_a, kit0_t

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     Kt0040                  ; trap occured in V86 mode

        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jz      short Kt0000

        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     Kt0020
;
; Set up exception record for raising Integer_Divided_by_zero exception
; and call _KiDispatchException
;

Kt0000:

if DBG
        test    [ebp]+TsEFlags, EFLAGS_INTERRUPT_MASK   ; faulted with
        jnz     short @f                                ; interrupts disabled?

        xor     eax, eax
        mov     esi, [ebp]+TsEip        ; [esi] = faulting instruction
        stdCall _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,eax,-1,eax,esi>
@@:
endif

        sti


;
; Flat mode
;
; The intel processor raises a divide by zero exception on DIV instructions
; which overflow. To be compatible with other processors we want to
; return overflows as such and not as divide by zero's.  The operand
; on the div instruction is tested to see if it's zero or not.
;
        stdCall _Ki386CheckDivideByZeroTrap,<ebp>
        mov     ebx, [ebp]+TsEip        ; (ebx)-> faulting instruction
        jmp     CommonDispatchException0Args ; Won't return

Kt0010:
;
; 16:16 mode
;
        sti
        mov     ebx, [ebp]+TsEip        ; (ebx)-> faulting instruction
        mov     eax, STATUS_INTEGER_DIVIDE_BY_ZERO
        jmp     CommonDispatchException0Args ; never return

Kt0020:
; Check to see if this process is a vdm
        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt0010

Kt0040:
        stdCall _Ki386VdmReflectException_A, <0>

        or      al,al
        jz      short Kt0010             ; couldn't reflect, gen exception
        jmp     _KiExceptionExit

_KiTrap00       endp


        page ,132
        subttl "Debug Exception"
;++
;
; Routine Description:
;
;    Handle debug exception.
;
;    The processor triggers this exception for any of the following
;    conditions:
;
;    1. Instruction breakpoint fault.
;    2. Data address breakpoint trap.
;    3. General detect fault.
;    4. Single-step trap.
;    5. Task-switch breadkpoint trap.
;
;
; Arguments:
;
;    At entry, the values of saved CS and EIP depend on whether the
;    exception is a fault or a trap.
;    No error code is provided with the divide error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
        ENTER_DR_ASSIST kit1_a, kit1_t, NoAbiosAssist
align dword
        public  _KiTrap01
_KiTrap01       proc

; Set up machine state frame for displaying

        push    0                       ; push dummy error code
        ENTER_TRAP      kit1_a, kit1_t

;
; If caller is user mode, we want interrupts back on.
;   . all relevent state has already been saved
;   . user mode code always runs with ints on
;
; If caller is kernel mode, we want them off!
;   . some state still in registers, must prevent races
;   . kernel mode code can run with ints off
;
;

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     kit01_30                ; fault occured in V86 mode => Usermode

        test    word ptr [ebp]+TsSegCs,MODE_MASK
        jz      kit01_10

        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     kit01_30
kit01_05:
        sti
kit01_10:

;
; Set up exception record for raising single step exception
; and call _KiDispatchException
;

kit01_20:
        and     dword ptr [ebp]+TsEflags, not EFLAGS_TF
        mov     ebx, [ebp]+TsEip                ; (ebx)-> faulting instruction
        mov     eax, STATUS_SINGLE_STEP
        jmp     CommonDispatchException0Args    ; Never return

kit01_30:

; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      kit01_05

        stdCall _Ki386VdmReflectException_A, <01h>
        test    ax,0FFFFh
        jz      Kit01_20
        jmp     _KiExceptionExit

_KiTrap01       endp

        page ,132
        subttl "Nonmaskable Interrupt"
;++
;
; Routine Description:
;
;    Handle Nonmaskable interrupt.
;
;    An NMI is typically used to signal serious system conditions
;    such as bus time-out, memory parity error, and so on.
;
;    Upon detection of the NMI, the system will be terminated, ie a
;    bugcheck will be raised, no matter what previous mode is.
;
; Arguments:
;
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
;        ENTER_DR_ASSIST kit2_a, kit2_t, NoAbiosAssist
align dword
        public  _KiTrap02
_KiTrap02       proc
.FPO (1, 0, 0, 0, 0, 2)
        cli
;
; Update the TSS pointer in the PCR to point to the NMI TSS
; (which is what we're running on, or else we wouldn't be here)
;
        push    dword ptr PCR[PcTss]

        mov     eax, PCR[PcGdt]
        mov     ch, [eax+KGDT_NMI_TSS+KgdtBaseHi]
        mov     cl, [eax+KGDT_NMI_TSS+KgdtBaseMid]
        shl     ecx, 16
        mov     cx, [eax+KGDT_NMI_TSS+KgdtBaseLow]
        mov     PCR[PcTss], ecx

;
; Clear Nested Task bit in EFLAGS
;
        pushfd
        and     [esp], not 04000h
        popfd

;
; Clear the busy bit in the TSS selector
;
        mov     ecx, PCR[PcGdt]
        lea     eax, [ecx] + KGDT_NMI_TSS
        mov     byte ptr [eax+5], 089h  ; 32bit, dpl=0, present, TSS32, not busy

;
; Allow only one processor at a time to enter the NMI path.  While
; waiting, spin on a LOCAL data structure (to avoid cache thrashing
; during a crashdump which can cause the dump to hang), and poll for
; Freeze IPI requests so that the correct state for this processor
; appears in the crashdump.
;
;
; (1) make a trap frame,
; (2) acquire lock
; (3) while not lock owner
; (4)     if (IPI_FREEZE)
; (5)        KeFreezeExecutionTarget(&TrapFrame, NULL)
; (6) let the HAL have it
; (7) release lock to next in line
;
; Build trap frame from the data in the previous TSS.
;

        mov     eax, [esp]              ; get saved TSS address
        push    0                       ; build trap frame, starting with
        push    0                       ; faked V86Gs thru V86Es
        push    0
        push    0
        push    [eax].TssSs             ; copy fields from TSS to
        push    [eax].TssEsp            ; trap frame.
        push    [eax].TssEflags
        push    [eax].TssCs
        push    [eax].TssEip
        push    0
        push    [eax].TssEbp
        push    [eax].TssEbx
        push    [eax].TssEsi
        push    [eax].TssEdi
        push    [eax].TssFs
        push    PCR[PcExceptionList]
        push    -1                      ; previous mode
        push    [eax].TssEax
        push    [eax].TssEcx
        push    [eax].TssEdx
        push    [eax].TssDs
        push    [eax].TssEs
        push    [eax].TssGs
        push    0                       ; fake out the debug registers
        push    0
        push    0
        push    0
        push    0
        push    0
        push    0                       ; temp ESP
        push    0                       ; temp CS
        push    0
        push    0
        push    [eax].TssEip
        push    [eax].TssEbp
        mov     ebp, esp                ; ebp -> TrapFrame

.FPO ( 0, 0, 0, 0, 0, FPO_TRAPFRAME )

ifndef NT_UP

;
; Acquire the NMI Lock.  If it is not available, check for freeze
; execution in case another processor is trying to dump memory.
;

        lea     eax, KiLockNMI          ; build in stack queued spin lock.
        push    eax
        push    0
        mov     ecx, esp
        mov     edx, ebp
        fstCall KiAcquireQueuedSpinLockCheckForFreeze

endif

;
; This processor now owns the NMI lock.   See if the HAL will
; handle the NMI.   If the HAL does not handle it, it will NOT
; return, so if we get back here, it's handled.
;

        stdCall _HalHandleNMI,<0>

;
; We're back, therefore the Hal has dealt with the NMI.
;

ifndef NT_UP

        mov     ecx, esp                ; release queued spinlock.
        fstCall KeReleaseQueuedSpinLockFromDpcLevel

endif

        add     esp, KTRAP_FRAME_LENGTH+8 ; free trap frame and qlock

        pop     dword ptr PCR[PcTss]    ; restore PcTss

        mov     ecx, PCR[PcGdt]
        lea     eax, [ecx] + KGDT_TSS
        mov     byte ptr [eax+5], 08bh  ; 32bit, dpl=0, present, TSS32, *busy*

        pushfd                          ; Set Nested Task bit in EFLAGS
        or      [esp], 04000h           ; so iretd will do a task switch
        popfd

        iretd                           ; Return from NMI
        jmp     _KiTrap02               ; in case we NMI again

_KiTrap02       endp

        page ,132
        subttl "DebugService Breakpoint"
;++
;
; Routine Description:
;
;    Handle INT 2d DebugService
;
;    The trap is caused by an INT 2d.  This is used instead of a
;    BREAKPOINT exception so that parameters can be passed for the
;    requested debug service.  A BREAKPOINT instruction is assumed
;    to be right after the INT 2d - this allows this code to share code
;    with the breakpoint handler.
;
; Arguments:
;     eax - ServiceClass - which call is to be performed
;     ecx - Arg1 - generic first argument
;     edx - Arg2 - generic second argument
;     ebx - Arg3 - generic third argument
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kids_a, kids_t, NoAbiosAssist
align dword
        public  _KiDebugService
_KiDebugService  proc
        push    0                           ; push dummy error code
        ENTER_TRAP      kids_a, kids_t
;       sti                                 ; *NEVER sti here*

        inc     dword ptr [ebp]+TsEip
        mov     eax, [ebp]+TsEax            ; ServiceClass
        mov     ecx, [ebp]+TsEcx            ; Arg1      (already loaded)
        mov     edx, [ebp]+TsEdx            ; Arg2      (already loaded)
        jmp     KiTrap03DebugService

_KiDebugService  endp

        page ,132
        subttl "Single Byte INT3 Breakpoin"
;++
;
; Routine Description:
;
;    Handle INT 3 breakpoint.
;
;    The trap is caused by a single byte INT 3 instruction.  A
;    BREAKPOINT exception with additional parameter indicating
;    READ access is raised for this trap if previous mode is user.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the instruction immediately
;    following the INT 3 instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit3_a, kit3_t, NoAbiosAssist
align dword
        public  _KiTrap03
_KiTrap03       proc
        push    0                       ; push dummy error code
        ENTER_TRAP      kit3_a, kit3_t

        cmp     ds:_PoHiberInProgress, 0
        jnz     short kit03_01

   lock inc     ds:_KiHardwareTrigger   ; trip hardware analyzer

kit03_01:
        mov     eax, BREAKPOINT_BREAK

KiTrap03DebugService:
;
; If caller is user mode, we want interrupts back on.
;   . all relevent state has already been saved
;   . user mode code always runs with ints on
;
; If caller is kernel mode, we want them off!
;   . some state still in registers, must prevent races
;   . kernel mode code can run with ints off
;
;
; Arguments:
;     eax - ServiceClass - which call is to be performed
;     ecx - Arg1 - generic first argument
;     edx - Arg2 - generic second argument
;

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     kit03_30                ; fault occured in V86 mode => Usermode

        test    word ptr [ebp]+TsSegCs,MODE_MASK
        jz      kit03_10

        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     kit03_30

kit03_05:
        sti
kit03_10:


;
; Set up exception record and arguments for raising breakpoint exception
;

        mov     esi, ecx                ; ExceptionInfo 2
        mov     edi, edx                ; ExceptionInfo 3
        mov     edx, eax                ; ExceptionInfo 1

        mov     ebx, [ebp]+TsEip
        dec     ebx                     ; (ebx)-> int3 instruction
        mov     ecx, 3
        mov     eax, STATUS_BREAKPOINT
        call    CommonDispatchException ; Never return

kit03_30:
; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      kit03_05

        stdCall _Ki386VdmReflectException_A, <03h>
        test    ax,0FFFFh
        jz      Kit03_10

        jmp     _KiExceptionExit

_KiTrap03       endp

        page ,132
        subttl "Integer Overflow"
;++
;
; Routine Description:
;
;    Handle INTO overflow.
;
;    The trap occurs when the processor encounters an INTO instruction
;    and the OF flag is set.
;
;    An INTEGER_OVERFLOW exception will be raised for this fault.
;
;    N.B. i386 will not generate fault if only OF flag is set.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the instruction immediately
;    following the INTO instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit4_a, kit4_t, NoAbiosAssist
align dword
        public  _KiTrap04
_KiTrap04       proc

        push    0                       ; push dummy error code
        ENTER_TRAP      kit4_a, kit4_t

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     short Kt0430            ; in a vdm, reflect to vdm

        test    byte ptr [ebp]+TsSegCs,MODE_MASK
        jz      short Kt0410            ; in kernel mode, gen exception

        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     short Kt0420            ; maybe in a vdm

; Set up exception record and arguments for raising exception

Kt0410: sti
        mov     ebx, [ebp]+TsEip        ; (ebx)-> instr. after INTO
        dec     ebx                     ; (ebx)-> INTO
        mov     eax, STATUS_INTEGER_OVERFLOW
        jmp     CommonDispatchException0Args ; Never return

Kt0430:
        stdCall _Ki386VdmReflectException_A, <04h>
        test    al,0fh
        jz      Kt0410                  ; couldn't reflect, gen exception
        jmp     _KiExceptionExit

Kt0420:
; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt0410
        jmp     Kt0430

_KiTrap04       endp

        page ,132
        subttl "Bound Check fault"
;++
;
; Routine Description:
;
;    Handle bound check fault.
;
;    The bound check fault occurs if a BOUND instruction finds that
;    the tested value is outside the specified range.
;
;    For bound check fault, an ARRAY BOUND EXCEEDED exception will be
;    raised.
;    For kernel mode exception, it causes system to be terminated.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting BOUND
;    instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
        ENTER_DR_ASSIST kit5_a, kit5_t, NoAbiosAssist
align dword
        public  _KiTrap05
_KiTrap05       proc

        push    0                       ; push dummy error code
        ENTER_TRAP      kit5_a, kit5_t

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     short Kt0530            ; fault in V86 mode

        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jnz     short Kt0500            ; if nz, previous mode = user
        mov     eax, EXCEPTION_BOUND_CHECK ; (eax) = exception type
        jmp     _KiSystemFatalException ; go terminate the system


kt0500: cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     short Kt0520            ; maybe in a vdm
;
; set exception record and arguments and call _KiDispatchException
;
Kt0510: sti
        mov     ebx, [ebp]+TsEip        ; (ebx)->BOUND instruction
        mov     eax, STATUS_ARRAY_BOUNDS_EXCEEDED
        jmp     CommonDispatchException0Args ; Won't return

Kt0520:
; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt0510

Kt0530:

        stdCall _Ki386VdmReflectException_A, <05h>
        test    al,0fh
        jz      Kt0510            ; couldn't reflect, gen exception
        jmp     _KiExceptionExit

_KiTrap05       endp

        page ,132
        subttl "Invalid OP code"
;++
;
; Routine Description:
;
;    Handle invalid op code fault.
;
;    The invalid opcode fault occurs if CS:EIP point to a bit pattern which
;    is not recognized as an instruction by the x86.  This may happen if:
;
;    1. the opcode is not a valid 80386 instruction
;    2. a register operand is specified for an instruction which requires
;       a memory operand
;    3. the LOCK prefix is used on an instruction that cannot be locked
;
;    If fault occurs in USER mode:
;       an Illegal_Instruction exception will be raised
;    if fault occurs in KERNEL mode:
;       system will be terminated.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the first byte of the invalid
;    instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit6_a, kit6_t, NoAbiosAssist,, kit6_v
align dword
        public  _KiTrap06
_KiTrap06       proc


        ;
        ; KiTrap06 is performance critical for VDMs and rarely executed in
        ; native mode.  So this routine is tuned for the VDM case.
        ;

        test    dword ptr [esp]+8h,EFLAGS_V86_MASK
        jz      Kt060i

if FAST_BOP

        FAST_V86_TRAP_6
endif

Kt6SlowBop:
        push    0                       ; push dummy error code
        ENTER_TRAPV86 kit6_a, kit6_v
Kt06VMpf:

        ;
        ; If the current process is NOT a VDM just hand it an
        ; illegal instruction exception.
        ;

        mov     ecx,PCR[PcPrcbData+PbCurrentThread]
        mov     ecx,[ecx]+ThApcState+AsProcess
        cmp     dword ptr [ecx]+PrVdmObjects,0  ; if not a vdm process,
        je      Kt0635                          ; then deliver exception

        ;
        ; Raise Irql to APC level before enabling interrupts to prevent
        ; a setcontext from editing the trapframe.
        ;

        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql
        push    eax                     ; Save OldIrql
if DBG
        cmp     eax, PASSIVE_LEVEL
        je      @f
        int     3
@@:
endif
        sti

        ;
        ; Call VdmDispatchBop to try and handle the opcode immediately.
        ; If it returns FALSE (meaning too complicated for us to quickly parse)
        ; then reflect the opcode off to the ntvdm monitor to handle it.
        ;

        stdCall _VdmDispatchBop, <ebp>

        ;
        ; If the operation was processed directly above then return back now.
        ;

        test    al,0fh
        jnz     short Kt061i

        ;
        ; The operation could not be processed directly above so reflect it
        ; back to the ntvdm monitor now.
        ;

        stdCall   _Ki386VdmReflectException,<6>

        test    al,0fh
        jnz     Kt061i
        pop     ecx                     ; (TOS) = OldIrql
        fstCall KfLowerIrql
        jmp     Kt0635
Kt061i:
        pop     ecx                     ; (TOS) = OldIrql
        fstCall KfLowerIrql
        cli
        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jz      Kt062i

        ;
        ; EXIT_TRAPv86 does not exit if a user mode apc has switched
        ; the context from V86 mode to flat mode (VDM monitor context)
        ;

        EXIT_TRAPV86

Kt062i:
        jmp     _KiExceptionExit

Kt060i:

        ;
        ; Non-v86 (user or kernel) executing code arrives here for
        ; invalid opcode traps.
        ;

        push    0                       ; Push dummy error code
        ENTER_TRAP      kit6_a, kit6_t
Kt06pf:

        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jz      short Kt0635            ; if z, kernel mode - go dispatch exception

        ;
        ; UserMode. Did the fault happen in a vdm running in protected mode?
        ;

        cmp     word ptr [ebp]+TsSegCs, KGDT_R3_CODE OR RPL_MASK
        jz      short kt0605            ; normal 32-bit mode so give exception

        ;
        ; The code segment is not a normal flat 32-bit entity, so see if
        ; this process is a vdm.  If so, then try to handle it.  If not,
        ; give this process an exception.
        ;

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        jne     Kt0650

kt0605:

        ;
        ; Invalid Opcode exception could be either INVALID_LOCK_SEQUENCE or
        ; ILLEGAL_INSTRUCTION.
        ;

        mov     eax, [ebp]+TsSegCs
        mov     esi, [ebp]+TsEip

        sti

        mov     ecx, MAX_INSTRUCTION_PREFIX_LENGTH

        ;
        ; Set up an exception handler in case we fault
        ; while reading the user mode instruction.
        ;

        push    es

        push    ebp                     ; pass trapframe to handler
        push    offset FLAT:Kt6_ExceptionHandler
                                        ; set up exception registration record
        push    PCR[PcExceptionList]
        mov     PCR[PcExceptionList], esp

        ; (es:esi) -> address of faulting instruction

        mov     es, ax

@@:
        mov     al, byte ptr es:[esi]   ; (al)= instruction byte
        cmp     al, MI_LOCK_PREFIX      ; Is it a lock prefix?
        je      short Kt0640            ; Yes, raise Invalid_lock exception
        add     esi, 1
        loop    short @b                ; keep on looping

        pop     PCR[PcExceptionList]
        add     esp, 8                  ; clear stack

Kt0630:
        pop     es

        ;
        ; Set up exception record for raising Illegal instruction exception
        ;

Kt0635:
        sti
        mov     ebx, [ebp]+TsEip        ; (ebx)-> invalid instruction
        mov     eax, STATUS_ILLEGAL_INSTRUCTION
        jmp     CommonDispatchException0Args ; Won't return

;
; Set up exception record for raising Invalid lock sequence exception
;

Kt0640:
        pop     PCR[PcExceptionList]
        add     esp, 8                  ; clear stack
        pop     es

        mov     ebx, [ebp]+TsEip        ; (ebx)-> invalid instruction
        mov     eax, STATUS_INVALID_LOCK_SEQUENCE
        jmp     CommonDispatchException0Args ; Won't return

Kt0650:

        ; Raise Irql to APC level before enabling interrupts
        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql
        push    eax                                 ; SaveOldIrql
        sti

        stdCall _VdmDispatchBop, <ebp>

        test    al,0fh
        jnz     short Kt0660

        stdCall   _Ki386VdmReflectException,<6>
        test    al,0fh
        jnz      Kt0660
        pop     ecx                         ; (TOS) = OldIrql
        fstCall KfLowerIrql
        jmp      short Kt0635

Kt0660:
        pop     ecx                         ; (TOS) = OldIrql
        fstCall KfLowerIrql
        jmp     _KiExceptionExit

_KiTrap06       endp

;
;   Error and exception blocks for KiTrap06
;

Kt6_ExceptionHandler:

        ;
        ; WARNING: Here we directly unlink the exception handler from the
        ; exception registration chain.  NO unwind is performed.
        ;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        pop     PCR[PcExceptionList]
        add     esp, 4                  ; pop out except handler
        pop     ebp                     ; (ebp)-> trap frame

        test    dword ptr [ebp].TsSegCs, MODE_MASK ; if premode=kernel
        jnz     Kt0630                  ; nz, prevmode=user, go return

        ;
        ; Raise bugcheck if prevmode=kernel
        ;

        stdCall   _KeBugCheck, <KMODE_EXCEPTION_NOT_HANDLED>

        page ,132
        subttl "Coprocessor Not Avalaible"
;++
;
; Routine Description:
;
;   Handle Coprocessor not available exception.
;
;   If we are REALLY emulating the FPU, the trap 07 vector is edited
;   to point directly at the emulator's entry point.  So this code is
;   only hit when FPU hardware DOES exist.
;
;   The current thread's coprocessor state is loaded into the
;   coprocessor.  If the coprocessor has a different thread's state
;   in it (UP only) it is first saved away.  The thread is then continued.
;   Note: the thread's state may contian the TS bit - In this case the
;   code loops back to the top of the Trap07 handler.  (which is where
;   we would end up if we let the thread return to user code anyway).
;
;   If the thread's NPX context is in the coprocessor and we hit a Trap07
;   there is an NPX error which needs to be processed.  If the trap was
;   from usermode the error is dispatched.  If the trap was from kernelmode
;   the error is remembered, but we clear CR0 so the kernel code can
;   continue.  We can do this because the kernel mode code will restore
;   CR0 (and set TS) to signal a delayed error for this thread.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the first byte of the faulting
;    instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit7_a, kit7_t, NoAbiosAssist
align dword
        public  _KiTrap07
_KiTrap07       proc

        push    0                       ; push dummy error code
        ENTER_TRAP      kit7_a, kit7_t
Kt0700:
        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     ecx, PCR[PcInitialStack] ; (ecx) -> top of kernel stack
        cli                             ; don't context switch
        test    dword ptr [ecx].FpCr0NpxState,CR0_EM
        jnz     Kt07140

Kt0701: cmp     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        mov     ebx, cr0
        je      Kt0710

;
; Trap occured and this thread's NPX state is not loaded.  Load it now
; and resume the application.  If someone else's state is in the coprocessor
; (uniprocessor implementation only) then save it first.
;

        and     ebx, NOT (CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, ebx                ; allow frstor (& fnsave) to work

ifdef NT_UP
Kt0702:
        mov     edx, PCR[PcPrcbData+PbNpxThread] ; Owner of NPX state
        or      edx, edx                ; NULL?
        jz      Kt0704                  ; Yes - skip save

;
; Due to an hardware errata we need to know that the coprocessor
; doesn't generate an error condition once interrupts are disabled and
; trying to perform an fnsave which could wait for the error condition
; to be handled.
;
; The fix for this errata is that we "know" that the coprocessor is
; being used by a different thread then the one which may have caused
; the error condition.  The round trip time to swap to a new thread
; is longer then ANY floating point instruction.  We therefore know
; that any possible coprocessor error has already occured and been
; handled.
;
        mov     esi,[edx].ThInitialStack
        sub     esi, NPX_FRAME_LENGTH   ; Space for NPX_FRAME

        test    byte ptr _KeI386FxsrPresent, 1  ; Is FXSR feature present
        jz      short Kt0703a
        FXSAVE_ESI
        jmp     short Kt0703b
Kt0703a:
        fnsave  [esi]                   ; Save thread's coprocessor state
Kt0703b:
        mov     byte ptr [edx].ThNpxState, NPX_STATE_NOT_LOADED
Kt0704:
endif

;
; Load current thread's coprocessor state into the coprocessor
;
; (eax) - CurrentThread
; (ecx) - CurrentThread's NPX save area
; (ebx) - CR0
; (ebp) - trap frame
; Interrupts disabled
;

;
; frstor might generate a NPX exception if there's an error image being
; loaded.  The handler will simply set the TS bit for this context an iret.
;

        test    byte ptr _KeI386FxsrPresent, 1  ; Is FXSR feature present
        jz      short Kt0704b

ifndef NT_UP
if 0            ; FpNpxSavedCpu is broken - disable it
;
; We need not load the NPX state if
;   - PCR[PbNpxThread] matches new thread AND
;   - FpNpxSavedCpu matches the current processor

        mov     edx, PCR[PcSelfPcr]
        cmp     [edx+PcPrcbData+PbNpxThread], eax
        jne     Kt0704a

        cmp     dword ptr [ecx].FpNpxSavedCpu, edx
        jne     short Kt0704a
        jmp     short Kt0704c
Kt0704a:
        mov     dword ptr [ecx].FpNpxSavedCpu, edx ; Remember processor
endif
endif
        FXRSTOR_ECX                     ; reload NPX context
        jmp     short Kt0704c
Kt0704b:
        frstor  [ecx]                   ; reload NPX context

Kt0704c:
        mov     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        mov     PCR[PcPrcbData+PbNpxThread], eax  ; owner of coprocessors state

        sti                             ; Allow interrupts & context switches
        nop                             ; sti needs one cycle

        cmp     dword ptr [ecx].FpCr0NpxState, 0
        jz      _KiExceptionExit        ; nothing to set, skip CR0 reload

;
; Note: we have to get the CR0 value again to insure that we have the
;       correct state for TS.  We may have context switched since
;       the last move from CR0, and our npx state may have been moved off
;       of the npx.
;
        cli
if DBG
        test    dword ptr [ecx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_TS)
        jnz short Kt07dbg1
endif
        mov     ebx,CR0
        or      ebx, [ecx].FpCr0NpxState
        mov     cr0, ebx                ; restore thread's CR0 NPX state
        sti
        test    ebx, CR0_TS             ; Setting TS?  (delayed error)
        jz      _KiExceptionExit        ; No - continue

        clts
        jmp     Kt0700                  ; Dispatch delayed exception
if DBG
Kt07dbg1:    int 3
Kt07dbg2:    int 3
Kt07dbg3:    int 3
        sti
        jmp short $-2
endif

Kt0705:
;
; A Trap07 or Trap10 has occured from a ring 0 ESCAPE instruction.  This
; may occur when trying to load the coprocessors state.  These
; code paths rely on Cr0NpxState to signal a delayed error (not CR0) - we
; set CR0_TS in Cr0NpxState to get a delayed error, and make sure CR0 CR0_TS
; is not set so the R0 ESC instruction(s) can complete.
;
; (ecx) - CurrentThread's NPX save area
; (ebp) - trap frame
; Interrupts disabled
;

if DBG
        mov     eax, cr0                    ; Did we fault because some bit in CR0
        test    eax, (CR0_TS+CR0_MP+CR0_EM)
        jnz     short Kt07dbg3
endif

        or      dword ptr [ecx].FpCr0NpxState, CR0_TS   ; signal a delayed error

        cmp     dword ptr [ebp]+TsEip, Kt0704b  ; Is this fault on reload a thread's context?
        jne     short Kt0716                ; No, dispatch exception

        add     dword ptr [ebp]+TsEip, 3    ; Skip frstor ecx instruction
        jmp     _KiExceptionExit

Kt0710:
        test    ebx, CR0_TS             ; check for task switch
        jnz     Kt07150

;
; WARNING:  May enter here from the trap 10 handler.
;

Kt0715:
        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     Kt07110                 ; v86 mode

        test    byte ptr [ebp]+TsSegCs, MODE_MASK ; Is previousMode=USER?
        jz      Kt0705                  ; if z, previousmode=SYSTEM

        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     Kt07110

;
; We are about to dispatch a floating point exception to user mode.
; We need to check to see if the user's NPX instruction is supposed to
; cause an exception or not.
;
; (ecx) - CurrentThread's NPX save area
;

Kt0716: stdCall _Ki386CheckDelayedNpxTrap,<ebp,ecx>
        or      al, al
        jnz     _KiExceptionExit        ; Already handled

        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     ecx, PCR[PcInitialStack] ; (ecx) -> top of kernel stack

Kt0720:
;
; Some type of coprocessor exception has occured for the current thread.
;
; (eax) - CurrentThread
; (ecx) - CurrentThread's NPX save area
; (ebp) - TrapFrame
; Interrupts disabled
;
        mov     ebx, cr0
        and     ebx, NOT (CR0_MP+CR0_EM+CR0_TS)
        mov     cr0, ebx                ; Clear MP+TS+EM to do fnsave & fwait

;
; Save the faulting state so we can inspect the cause of the floating
; point fault
;

        test    byte ptr _KeI386FxsrPresent, 1  ; Is FXSR feature present
        jz      short Kt0725a
        FXSAVE_ECX
        jmp     short Kt0725b
Kt0725a:
        fnsave  [ecx]                   ; Save thread's coprocessor state
        fwait                           ; in case fnsave hasn't finished yet
Kt0725b:

if DBG
        test    dword ptr [ecx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_TS)
        jnz     Kt07dbg2
endif
        or      ebx, NPX_STATE_NOT_LOADED
        or      ebx,[ecx]+FpCr0NpxState ; restore this thread's CR0 NPX state
        mov     cr0, ebx                ; set TS so next ESC access causes trap

;
; Clear TS bit in Cr0NpxFlags in case it was set to trigger this trap.
;
        and     dword ptr [ecx].FpCr0NpxState, NOT CR0_TS

;
; The state is no longer in the coprocessor.  Clear ThNpxState and
; re-enable interrupts to allow context switching.
;
        mov     byte ptr [eax].ThNpxState, NPX_STATE_NOT_LOADED
        mov     dword ptr PCR[PcPrcbData+PbNpxThread], 0  ; No state in coprocessor
        sti

;
; According to the floating error priority, we test what is the cause of
; the NPX error and raise an appropriate exception.
;

        test    byte ptr _KeI386FxsrPresent, 1  ; Is FXSR feature present
        jz      short Kt0727a

        mov     ebx, [ecx] + FxErrorOffset
        movzx   eax, word ptr [ecx] + FxControlWord
        movzx   edx, word ptr [ecx] + FxStatusWord
        mov     esi, [ecx] + FxDataOffset ; (esi) = operand addr
        jmp     short Kt0727b

Kt0727a:
        mov     ebx, [ecx] + FpErrorOffset
        movzx   eax, word ptr [ecx] + FpControlWord
        movzx   edx, word ptr [ecx] + FpStatusWord
        mov     esi, [ecx] + FpDataOffset ; (esi) = operand addr

Kt0727b:

        and     eax, FSW_INVALID_OPERATION + FSW_DENORMAL + FSW_ZERO_DIVIDE + FSW_OVERFLOW + FSW_UNDERFLOW + FSW_PRECISION
        not     eax                        ; ax = mask of enabled exceptions
        and     eax, edx
        test    eax, FSW_INVALID_OPERATION ; Is it an invalid op exception?
        jz      short Kt0740               ; if z, no, go Kt0740
        test    eax, FSW_STACK_FAULT       ; Is it caused by stack fault?
        jnz     short Kt0730               ; if nz, yes, go Kt0730

; Raise Floating reserved operand exception
;

        mov     eax, STATUS_FLOAT_INVALID_OPERATION
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0730:
;
; Raise Access Violation exception for stack overflow/underflow
;

        mov     eax, STATUS_FLOAT_STACK_CHECK
        jmp     CommonDispatchException2Args0d ; Won't return

Kt0740:

; Check for floating zero divide exception

        test    eax, FSW_ZERO_DIVIDE    ; Is it a zero divide error?
        jz      short Kt0750            ; if z, no, go Kt0750

; Raise Floating divided by zero exception

        mov     eax, STATUS_FLOAT_DIVIDE_BY_ZERO
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0750:

; Check for denormal error

        test    eax, FSW_DENORMAL       ; Is it a denormal error?
        jz      short Kt0760            ; if z, no, go Kt0760

; Raise floating reserved operand exception

        mov     eax, STATUS_FLOAT_INVALID_OPERATION
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0760:

; Check for floating overflow error

        test    eax, FSW_OVERFLOW       ; Is it an overflow error?
        jz      short Kt0770            ; if z, no, go Kt0770

; Raise floating overflow exception

        mov     eax, STATUS_FLOAT_OVERFLOW
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0770:

; Check for floating underflow error

        test    eax, FSW_UNDERFLOW      ; Is it a underflow error?
        jz      short Kt0780            ; if z, no, go Kt0780

; Raise floating underflow exception

        mov     eax, STATUS_FLOAT_UNDERFLOW
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0780:

; Check for precision (IEEE inexact) error

        test    eax, FSW_PRECISION      ; Is it a precision error
        jz      short Kt07100           ; if z, no, go Kt07100

        mov     eax, STATUS_FLOAT_INEXACT_RESULT
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt07100:

; If status word does not indicate error, then something is wrong...
;
; There is a known bug on Cyrix processors, upto and including
; the MII that causes Trap07 for no real reason (INTR is asserted
; during an FP instruction and is held high too long, we end up
; in the Trap07 handler with not exception set).   Bugchecking seems
; a little heavy handed, if this is a Cyrix processor, just ignore
; the error.

        cmp     _KiIgnoreUnexpectedTrap07, 0
        jnz     _KiExceptionExit

; stop the system
        sti
        stdCall   _KeBugCheckEx, <TRAP_CAUSE_UNKNOWN, 1, eax, 0, 0>

Kt07110:
; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt0720                  ; no, dispatch exception

Kt07130:
        clts                                ; Turn off TS
        and     dword ptr [ecx]+FpCr0NpxState,NOT CR0_TS


; Reflect the exception to the vdm, the VdmHandler enables interrupts

        ; Raise Irql to APC level before enabling interrupts
        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql
        push    eax                         ; Save OldIrql
        sti

        stdCall   _VdmDispatchIRQ13, <ebp>  ; ebp - Trapframe
        test    al,0fh
        jnz     Kt07135
        pop     ecx                         ; (TOS) = OldIrql
        fstCall KfLowerIrql
        jmp     Kt0720            ; could not reflect, gen exception

Kt07135:
        pop     ecx                         ; (TOS) = OldIrql
        fstCall KfLowerIrql
        jmp     _KiExceptionExit

Kt07140:

;
; Insure that this is not an NPX instruction in the kernel. (If
; an app, such as C7, sets the EM bit after executing NPX instructions,
; the fsave in SwapContext will catch an NPX exception
;
        cmp     [ebp].TsSegCS, word ptr KGDT_R0_CODE
        je      Kt0701

;
; Check to see if it really is a VDM
;
        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt07100

; A vdm is emulating NPX instructions on a machine with an NPX.

        stdCall _Ki386VdmReflectException_A, <07h>
        test    al,0fh
        jnz     _KiExceptionExit

        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     eax, STATUS_ACCESS_VIOLATION
        mov     esi, -1
        jmp     CommonDispatchException2Args0d ; Won't return

;
; If the processor took an NMI (or other task switch) CR0_TS will have
; been set.   If this occured while the FP state was loaded it would
; appear that it is no longer valid.   This is not actually true, the
; state is perfectly valid.
;
; Sanity: make sure CR0_MP is clear, if the OS had set CR0_TS, then
; CR0_MP should also be set.
;

Kt07150:
        test    ebx, CR0_MP
        jnz short Kt07151

        clts                                ; clear CR0_TS and continue
        jmp     _KiExceptionExit

Kt07151:
        stdCall   _KeBugCheckEx, <TRAP_CAUSE_UNKNOWN, 2, ebx, 0, 0>
        jmp short Kt07151

_KiTrap07       endp


        page ,132
        subttl "Double Fault"
;++
;
; Routine Description:
;
;    Handle double exception fault.
;
;    Normally, when the processor detects an exception while trying to
;    invoke the handler for a prior exception, the two exception can be
;    handled serially.  If, however, the processor cannot handle them
;    serially, it signals the double-fault exception instead.
;
;    If double exception is detected, no matter previous mode is USER
;    or kernel, a bugcheck will be raised and the system will be terminated.
;
;    Exception:  The sysenter instruction does not use the system TSS
;    KGDT_TSS to enter the kernel.  Instead, it uses a kernel stack
;    address it reads from an MSR.   This is not actually needed, we
;    set the kernel stack address in the Fast System Call entry routine
;    (KiFastCallEntry).   If the user single steps across the sysenter
;    instruction, we will take a Trap 1 (debug exception) prior to the
;    kernel stack being set up.  As there is no-where to save the
;    previous state this will result in a double fault.  This code
;    detects that possibility and works around it.
;
; Arguments:
;
;    error code, which is always zero, is pushed on stack.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
;
; NOTE: Entry to this code stream is below at _KiTrap08.   The
;       code immediately below is out of line and branched to in
;       the event of a single stepped system call instruction.
;       The code is out of line so the updated DF TSS will still
;       be aimed at the real entry to the trap 8 handler after
;       this code has been executed.
;
; The exception occured on entry to the fast system call routine,
; clear the TF bit in EFLAGS, set eip to the modified system call
; address (which will restore TF), and make sure DS, ES, and FS are
; set to the correct kernel mode values.
;


Kt0800: mov     [eax].TssEip, _KiFastCallEntry2
        and     dword ptr [eax].TssEflags, NOT EFLAGS_TF

        mov     [eax].TssDs, KGDT_R3_DATA OR RPL_MASK
        mov     [eax].TssEs, KGDT_R3_DATA OR RPL_MASK
        mov     [eax].TssFs, KGDT_R0_PCR
        pop     eax                 ; pop error code off stack
        iretd                       ; continue in old task.



        public  _KiTrap08
_KiTrap08       proc
.FPO (0, 0, 0, 0, 0, 2)

        cli

;
; Inspect old TSS (saved state) incase this is a single stepped
; sysenter instruction.
;

        mov     eax, PCR[PcTss]
        mov     ecx, [eax]+TssEip
        cmp     ecx, _KiFastCallEntry
        je      short Kt0800

;
; Clear the busy bit in the TSS selector
;

        mov     ecx, PCR[PcGdt]
        lea     eax, [ecx] + KGDT_DF_TSS
        mov     byte ptr [eax+5], 089h  ; 32bit, dpl=0, present, TSS32, not busy

;
; Clear Nested Task bit in EFLAGS
;
        pushfd
        and     [esp], not 04000h
        popfd

;
; Get address of the double-fault TSS which we are now running on.
;
        mov     eax, PCR[PcGdt]
        mov     ch, [eax+KGDT_DF_TSS+KgdtBaseHi]
        mov     cl, [eax+KGDT_DF_TSS+KgdtBaseMid]
        shl     ecx, 16
        mov     cx, [eax+KGDT_DF_TSS+KgdtBaseLow]
;
; Update the TSS pointer in the PCR to point to the double-fault TSS
; (which is what we're running on, or else we wouldn't be here)
;
        mov     eax, PCR[PcTss]
        mov     PCR[PcTss], ecx

;
; The original machine context is in original task's TSS
;
@@:     stdCall _KeBugCheckEx,<UNEXPECTED_KERNEL_MODE_TRAP,8,eax,0,0>
        jmp     short @b        ; do not remove - for debugger

_KiTrap08       endp

        page ,132
        subttl "Coprocessor Segment Overrun"
;++
;
; Routine Description:
;
;    Handle Coprocessor Segment Overrun exception.
;
;    This exception only occurs on the 80286 (it's a trap 0d on the 80386),
;    so choke if we get here.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the aborted instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit9_a, kit9_t, NoAbiosAssist
align dword
        public  _KiTrap09
_KiTrap09       proc

        push    0                       ; push dummy error code
        ENTER_TRAP  kit9_a, kit9_t
        sti

        mov     eax, EXCEPTION_NPX_OVERRUN ; (eax) = exception type
        jmp     _KiSystemFatalException ; go terminate the system

_KiTrap09       endp

        page ,132
        subttl "Invalid TSS exception"
;++
;
; Routine Description:
;
;    Handle Invalid TSS fault.
;
;    This exception occurs if a segment exception other than the
;    not-present exception is detected when loading a selector
;    from the TSS.
;
;    If the exception is caused as a result of the kernel, device
;    drivers, or user incorrectly setting the NT bit in the flags
;    while the back-link selector in the TSS is invalid and the
;    IRET instruction being executed, in this case, this routine
;    will clear the NT bit in the trap frame and restart the iret
;    instruction.  For other causes of the fault, the user process
;    will be terminated if previous mode is user and the system
;    will stop if the exception occurs in kernel mode.  No exception
;    is raised.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code containing the segment causing the exception is provided.
;
;    NT386 does not use TSS for context switching.  So, the invalid tss
;    fault should NEVER occur.  If it does, something is wrong with
;    the kernel.  We simply shutdown the system.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kita_a, kita_t, NoAbiosAssist
align dword
        public  _KiTrap0A
_KiTrap0A       proc

        ENTER_TRAP  kita_a, kita_t

        ; We can not enable interrupt here.  If we came here because DOS/WOW
        ; iret with NT bit set, it is possible that vdm will swap the trap frame
        ; with their monitor context.  If this happen before we check the NT bit
        ; we will bugcheck.

;       sti

;
;   If the trap occur in USER mode and is caused by iret instruction with
;   OF bit set, we simply clear the OF bit and restart the iret.
;   Any other causes of Invalid TSS cause system to be shutdown.
;

        test    dword ptr [ebp]+TsEFlags, EFLAGS_V86_MASK
        jnz     short Kt0a10

        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jz      short Kt0a20

Kt0a10:
        test    dword ptr [ebp]+TsEFlags, EFLAGS_OF_BIT
        sti
        jz      short Kt0a20

        and     dword ptr [ebp]+TsEFlags, NOT EFLAGS_OF_BIT
        jmp     _KiExceptionExit                ; restart the instruction

Kt0a20:
        mov     eax, EXCEPTION_INVALID_TSS ; (eax) = trap type
        jmp     _KiSystemFatalException ; go terminate the system

_KiTrap0A       endp

        page ,132
        subttl "Segment Not Present"
;++
;
; Routine Description:
;
;    Handle Segment Not Present fault.
;
;    This exception occurs when the processor finds the P bit 0
;    when accessing an otherwise valid descriptor that is not to
;    be loaded in SS register.
;
;    The only place the fault can occur (in kernel mode) is Trap/Exception
;    exit code.  Otherwise, this exception causes system to be terminated.
;    NT386 uses flat mode, the segment not present fault in Kernel mode
;    indicates system malfunction.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code containing the segment causing the exception is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kitb_a, kitb_t, NoAbiosAssist

align dword
        public  _KiTrap0B
_KiTrap0B       proc

; Set up machine state frame for displaying

        ENTER_TRAP      kitb_a, kitb_t

;
;   Did the trap occur in a VDM?
;

        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jz      Kt0b30

        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        je      Kt0b20

Kt0b10:

; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      short Kt0b20

        ; Raise Irql to APC level before enabling interrupts
        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql
        push    eax                             ; Save OldIrql
        sti
        stdCall   _Ki386VdmSegmentNotPresent
        test    eax, 0ffffh
        jz      short Kt0b15

        pop     ecx                                ; (TOS) = OldIrql
        fstCall KfLowerIrql
        jmp     _KiExceptionExit

Kt0b15:
        pop     ecx                                ; (TOS) = OldIrql
        fstCall KfLowerIrql

Kt0b20: sti
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     esi, [ebp]+TsErrCode
        and     esi, 0FFFFh
        or      esi, RPL_MASK
        mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException2Args0d ; Won't return

Kt0b30:
;
; Check if the exception is caused by pop SegmentRegister.
; We need to deal with the case that user puts a NP selector in fs, ds, cs
; or es through kernel debugger. (kernel will trap while popping segment
; registers in trap exit code.)
; Note: We assume if the faulted instruction is pop segreg.  It MUST be
; in trap exit code.  So there MUST be a valid trap frame for the trap exit.
;

        mov     eax, [ebp]+TsEip        ; (eax)->faulted Instruction
        mov     eax, [eax]              ; (eax)= opcode of faulted instruction
        mov     edx, [ebp]+TsEbp        ; (edx)->previous trap exit trapframe

        add     edx, TsSegDs            ; [edx] = prev trapframe + TsSegDs
        cmp     al, POP_DS              ; Is it pop ds instruction?
        jz      Kt0b90                  ; if z, yes, go Kt0b90

        add     edx, TsSegEs - TsSegDs  ; [edx] = prev trapframe + TsSegEs
        cmp     al, POP_ES              ; Is it pop es instruction?
        jz      Kt0b90                  ; if z, yes, go Kt0b90

        add     edx, TsSegFs - TsSegEs  ; [edx] = prev trapframe + TsSegFs
        cmp     ax, POP_FS              ; Is it pop fs (2-byte) instruction?
        jz      Kt0b90                  ; If z, yes, go Kt0b90

        add     edx, TsSegGs - TsSegFs  ; [edx] = prev trapframe + TsSegGs
        cmp     ax, POP_GS              ; Is it pop gs (2-byte) instruction?
        jz      Kt0b90                  ; If z, yes, go Kt0b90

;
; The exception is not caused by pop instruction.  We still need to check
; if it is caused by iret (to user mode.)  Because user may have a NP
; cs and we will trap at iret in trap exit code.
;

        sti
        cmp     al, IRET_OP             ; Is it an iret instruction?
        jne     Kt0b199                 ; if ne, not iret, go bugcheck

        lea     edx, [ebp]+TsHardwareEsp ; (edx)->trapped iret frame
        test    dword ptr [edx]+4, RPL_MASK ; Check CS of iret addr
                                        ; Does the iret have ring transition?
        jz      Kt0b199                 ; if z, it's a real fault

;
; we trapped at iret while returning back to user mode. We will dispatch
; the exception back to user program.
;

        mov     ecx, (KTRAP_FRAME_LENGTH - 12) / 4
        lea     edx, [ebp]+TsErrCode
Kt0b40:
        mov     eax, [edx]
        mov     [edx+12], eax
        sub     edx, 4
        loop    Kt0b40

        add     esp, 12                 ; adjust esp and ebp
        add     ebp, 12
        jmp     Kt0b10

;        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
;        xor     edx, edx
;        mov     esi, [ebp]+TsErrCode
;        or      esi, RPL_MASK
;        and     esi, 0FFFFh
;        mov     ecx, 2
;        mov     eax, STATUS_ACCESS_VIOLATION
;        call    CommonDispatchException ; WOn't return

;
; The faulted instruction is pop seg
;

Kt0b90:
        mov     dword ptr [edx], 0      ; set the segment reg to 0 such that
                                        ; we will trap in user mode.
        jmp     Kt0d01                  ; continue in common code

Kt0b199:
        mov     eax, EXCEPTION_SEGMENT_NOT_PRESENT ; (eax) = exception type
        jmp     _KiSystemFatalException ; terminate the system

_KiTrap0B       endp

        page ,132
        subttl "Stack segment fault"
;++
;
; Routine Description:
;
;    Handle Stack Segment fault.
;
;    This exception occurs when the processor detects certain problem
;    with the segment addressed by the SS segment register:
;
;    1. A limit violation in the segment addressed by the SS (error
;       code = 0)
;    2. A limit violation in the inner stack during an interlevel
;       call or interrupt (error code = selector for the inner stack)
;    3. If the descriptor to be loaded into SS has its present bit 0
;       (error code = selector for the not-present segment)
;
;    The exception should never occur in kernel mode except when we
;    perform the iret back to user mode.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code (whose value depends on detected condition) is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kitc_a, kitc_t, NoAbiosAssist
align dword
        public  _KiTrap0C
_KiTrap0C       proc

        ENTER_TRAP kitc_a, kitc_t

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     Kt0c20

        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jz      Kt0c10

        cmp     word ptr [ebp]+TsSegCs, KGDT_R3_CODE OR RPL_MASK
        jne     Kt0c20                  ; maybe in a vdm

Kt0c00: sti
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     edx, EXCEPT_LIMIT_ACCESS; assume it is limit violation
        mov     esi, [ebp]+TsHardwareEsp; (ecx) = User Stack pointer
        cmp     word ptr [ebp]+TsErrCode, 0 ; Is errorcode = 0?
        jz      short kt0c05            ; if z, yes, go dispatch exception

        mov     esi, [ebp]+TsErrCode    ; Otherwise, set SS segment value
                                        ;   to be the address causing the fault
        mov     edx, EXCEPT_UNKNOWN_ACCESS
        or      esi, RPL_MASK
        and     esi, 0FFFFh
kt0c05: mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException2Args ; Won't return

kt0c10:

;
; Check if the exception is caused by kernel mode iret to user code.
; We need to deal with the case that user puts a bogus value in ss
; through SetContext call. (kernel will trap while iret to user code
; in trap exit code.)
; Note: We assume if the faulted instruction is iret.  It MUST be in
; trap/exception exit code.  So there MUST be a valid trap frame for
; the trap exit.
;

        mov     eax, [ebp]+TsEip        ; (eax)->faulted Instruction

        ;
        ; Note the eip is captured above before enabling interrupts to
        ; prevent a setcontext from editing a bogus eip into our trapframe.
        ;

        sti

        stdCall _VdmFetchBop1, <eax>

        ; (eax)= opcode of faulted instruction

;
; Check if the exception is caused by iret (to user mode.)
; Because user may have a NOT PRESENT ss and we will trap at iret
; in trap exit code. (If user put a bogus/not valid SS in trap frame, we
; will catch it in trap 0D handler.
;

        cmp     al, IRET_OP             ; Is it an iret instruction?
        jne     Kt0c15            ; if ne, not iret, go bugcheck

        lea     edx, [ebp]+TsHardwareEsp ; (edx)->trapped iret frame
        test    dword ptr [edx]+4, RPL_MASK ; Check CS of iret addr
                                        ; Does the iret have ring transition?
        jz      Kt0c15            ; if z, no SS involved, it's a real fault

;
; we trapped at iret while returning back to user mode. We will dispatch
; the exception back to user program.
;

        mov     ecx, (KTRAP_FRAME_LENGTH - 12) / 4
        lea     edx, [ebp]+TsErrCode
@@:
        mov     eax, [edx]
        mov     [edx+12], eax
        sub     edx, 4
        loop    @b

        add     esp, 12                 ; adjust esp and ebp
        add     ebp, 12

        ;
        ; Now, we have user mode trap frame set up
        ;

        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     edx, EXCEPT_LIMIT_ACCESS; assume it is limit violation
        mov     esi, [ebp]+TsHardwareEsp; (ecx) = User Stack pointer
        cmp     word ptr [ebp]+TsErrCode, 0 ; Is errorcode = 0?
        jz      short @f                ; if z, yes, go dispatch exception

        mov     esi, [ebp]+TsErrCode    ; Otherwise, set SS segment value
                                        ;   to be the address causing the fault
        and     esi, 0FFFFh
        mov     edx, EXCEPT_UNKNOWN_ACCESS
        or      esi, RPL_MASK
@@:
        mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException2Args ; Won't return

Kt0c15:
        mov     eax, EXCEPTION_STACK_FAULT      ; (eax) = trap type
        jmp     _KiSystemFatalException

Kt0c20:
; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt0c00

Kt0c30:
        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     short @f

        ;
        ; Raise Irql to APC level before enabling interrupt
        ;

        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql
        sti
        mov     edi, eax                           ; [edi] = OldIrql

        call    VdmFixEspEbp

        push    eax
        mov     ecx, edi
        fstCall KfLowerIrql
        cli
        pop     eax
        test    al, 0fh
        jz      short @f
        jmp     _KiExceptionExit

@@:
        stdCall _Ki386VdmReflectException_A,<0ch>
        test    al,0fh
        jz      Kt0c00
        jmp     _KiExceptionExit

_KiTrap0C       endp


        page ,132
        subttl "TrapC handler for NTVDM"
;++
;
; Routine Description:
;
;       Some protected dos games (ex, Duke3D) while running in a BIG code
;       segment with SMALL Stack segment will hit trap c with higher 16bit
;       of esp containing kernel esp higher 16 bit.  The question it should
;       not trapped because cpu should only look at sp.  So, here we try
;       to deal with this problem.
;
; Arguments:
;
;    EBP - Trap frame
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        public  VdmFixEspEbp
VdmFixEspEbp  proc

        ;
        ; First check if user SS is small.  If it is big, do nothing
        ;

        mov     eax, [ebp].TsHardwareSegSs
        lar     eax, eax                        ; [eax]= ss access right
        jnz     Vth_err

        test    eax, 400000h                    ; is SS a big segment?
        jnz     Vth_err                         ; nz, yes, do nothing

        xor     edx, edx                        ; [edx] = 0 no need to update tframe
        mov     eax, esp
        and     eax, 0ffff0000h                 ; [eax]=kernel esp higher 16bit
        mov     ecx, [ebp].TsHardwareEsp
        and     ecx, 0ffff0000h                 ; [ecx]=user esp higher 16bit
        cmp     ecx, eax                        ; are they the same
        jnz     short @f                        ; if nz, no, go check ebp

        and     dword ptr [ebp].TsHardwareEsp, 0ffffH ; zero higher 16 bit of user esp
        mov     edx, 1                          ; [edx]=1 indicates we need to update trap frame
@@:
        mov     ecx, [ebp].TsEbp
        and     ecx, 0ffff0000h                 ; [ecx]=user ebp higher 16bit
        cmp     ecx, eax                        ; are they the same as kernel's
        jnz     short @f                        ; if nz, no, go check if we need to update tframe

        and     dword ptr [ebp].TsEbp, 0ffffH   ; zero higher 16bit of user ebp
        mov     edx, 1                          ; update kernel trap frame
@@:     cmp     edx, 1                          ; do we need to update trap frame?
        jnz     short Vth_err                   ; if nz, no, do nothing

Vth_ok:

;
; copy user's cs:eip and ss:esp to vdmtib, note this needs to be done
; with proper probing and exception handling.
;

        mov     ebx, PCR[PcTeb]

        mov     eax, [ebp].TsSegCs
        mov     ecx, [ebp].TsEip
        mov     edx, [ebp].TsEbx

        stdCall _VdmTibPass1, <eax,ecx,edx>

        ; eax now points at the VDM tib (or NULL if anything went wrong)

        ;
        ; Move the vdmtib to the trap frame such that we return back to ntvdm
        ; [ebx]->vdmtib
        ;

        mov     [ebp].TsEbx, eax

;
; dispatch control to ntvdm trapc handler which will load ss:esp
; and jump to the trapped cs:eip
;

        mov     eax,PCR[PcPrcbData+PbCurrentThread]
        mov     eax,[eax]+ThApcState+AsProcess
        mov     eax,[eax]+PrVdmTrapcHandler

        mov     dword ptr [ebp].TsSegCs, KGDT_R3_CODE OR RPL_MASK
        mov     dword ptr [ebp].TsEip, eax

        mov     eax, 1
        ret

Vth_err:
        xor     eax, eax
        ret
VdmFixEspEbp endp


        page ,132
        subttl "General Protection Fault"
;++
;
; Routine Description:
;
;    Handle General protection fault.
;
;    First, check to see if the fault occured in kernel mode with
;    incorrect selector values.  If so, this is a lazy segment load.
;    Correct the selector values and restart the instruction.  Otherwise,
;    parse out various kinds of faults and report as exceptions.
;
;    All protection violations that do not cause another exception
;    cause a general exception.  If the exception indicates a violation
;    of the protection model by an application program executing a
;    previleged instruction or I/O reference, a PRIVILEGED INSTRUCTION
;    exception will be raised.  All other causes of general protection
;    fault cause a ACCESS VIOLATION exception to be raised.
;
;    If previous mode = Kernel;
;        the system will be terminated  (assuming not lazy segment load)
;    Else previous mode = USER
;        the process will be terminated if the exception was not caused
;        by privileged instruction.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code (whose value depends on detected condition) is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:FLAT

;
;   Error and exception blocks for KiTrap0d
;

Ktd_ExceptionHandler:

;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.
;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        pop     PCR[PcExceptionList]
        add     esp, 4                  ; pop out except handler
        pop     ebp                     ; (ebp)-> trap frame

        test    dword ptr [ebp].TsSegCs, MODE_MASK ; if premode=kernel
        jnz     Kt0d103                 ; nz, prevmode=user, go return

; raise bugcheck if prevmode=kernel
        stdCall   _KeBugCheck, <KMODE_EXCEPTION_NOT_HANDLED>



        ENTER_DR_ASSIST kitd_a, kitd_t, NoAbiosAssist,, kitd_v
align dword

        public  _KiTrap0D
_KiTrap0D       proc

        ;
        ; Did the trap occur in a VDM in V86 mode? Trap0d is not critical from
        ; performance point of view to native NT, but it's super critical to
        ; VDMs. So here we are doing every thing to make v86 mode most
        ; efficient.

        test    dword ptr [esp]+0ch,EFLAGS_V86_MASK
        jz      Ktdi

KtdV86Slow:
        ENTER_TRAPV86 kitd_a, kitd_v

KtdV86Slow2:
        mov     ecx,PCR[PcPrcbData+PbCurrentThread]
        mov     ecx,[ecx]+ThApcState+AsProcess
        cmp     dword ptr [ecx]+PrVdmObjects,0 ; is this a vdm process?
        jnz     short @f                        ; if nz, yes

        sti                                     ; else, enable ints
        jmp     Kt0d105                         ; and dispatch exception

@@:

        ; Raise Irql to APC level, before enabling interrupts
        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql
        push    eax                             ; Save OldIrql
        sti

        stdCall   _VdmDispatchOpcodeV86_try,<ebp>
KtdV86Exit:
        test    al,0FFh
        jnz     short Ktdi2

        stdCall   _Ki386VdmReflectException,<0dh>
        test    al,0fh
        jnz     short Ktdi2
        pop     ecx                                ; (TOS) = OldIrql
        fstCall KfLowerIrql
        jmp     Kt0d105
Ktdi2:
        pop     ecx                                ; (TOS) = OldIrql
        fstCall KfLowerIrql
        cli
        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jz      Ktdi3

        EXIT_TRAPV86
        ;
        ; EXIT_TRAPv86 does not exit if a user mode apc has switched
        ; the context from V86 mode to flat mode (VDM monitor context)
        ;

Ktdi3:
        jmp     _KiExceptionExit

Ktdi:
        ENTER_TRAP kitd_a, kitd_t

;
; DO NOT TURN INTERRUPTS ON!  If we're doing a lazy segment load,
; could be in an ISR or other code that needs ints off!
;

;
; Is this just a lazy segment load?  First make sure the exception occurred
; in kernel mode.
;

        test    dword ptr [ebp]+TsSegCs,MODE_MASK
        jnz     Kt0d02                  ; not kernel mode, go process normally

;
; Before handling kernel mode trap0d, we need to do some checks to make
; sure the kernel mode code is the one to blame.
;

if FAST_BOP
        cmp     dword ptr PCR[PcVdmAlert], 0
        jne     Kt0eVdmAlert
endif

;
; Check if the exception is caused by the handler trying to examine offending
; instruction.  If yes, we raise exception to user mode program.  This occurs
; when user cs is bogus.  Note if cs is valid and eip is bogus, the exception
; will be caught by page fault and out Ktd_ExceptionHandler will be invoked.
; Both cases, the exception is dispatched back to user mode.
;

        mov     eax, [ebp]+TsEip
        cmp     eax, offset FLAT:Kt0d03
        jbe     short Kt0d000
        cmp     eax, offset FLAT:Kt0d60
        jae     short Kt0d000

        sti
        mov     ebp, [ebp]+TsEbp        ; remove the current trap frame
        mov     esp, ebp                ; set ebp, esp to previous trap frame
        jmp     Kt0d105                 ; and dispatch exception to user mode.

;
; Check if the exception is caused by pop SegmentRegister.
; We need to deal with the case that user puts a bogus value in fs, ds,
; or es through kernel debugger. (kernel will trap while popping segment
; registers in trap exit code.)
; Note: We assume if the faulted instruction is pop segreg.  It MUST be
; in trap exit code.  So there MUST be a valid trap frame for the trap exit.
;

Kt0d000:
        mov     eax, [ebp]+TsEip        ; (eax)->faulted Instruction
        mov     eax, [eax]              ; (eax)= opcode of faulted instruction
        mov     edx, [ebp]+TsEbp        ; (edx)->previous trap exit trapframe

        add     edx, TsSegDs            ; [edx] = prev trapframe + TsSegDs
        cmp     al, POP_DS              ; Is it pop ds instruction?
        jz      Kt0d005                 ; if z, yes, go Kt0d005

        add     edx, TsSegEs - TsSegDs  ; [edx] = prev trapframe + TsSegEs
        cmp     al, POP_ES              ; Is it pop es instruction?
        jz      Kt0d005                 ; if z, yes, go Kt0d005

        add     edx, TsSegFs - TsSegEs  ; [edx] = prev trapframe + TsSegFs
        cmp     ax, POP_FS              ; Is it pop fs (2-byte) instruction?
        jz      Kt0d005                 ; If z, yes, go Kt0d005

        add     edx, TsSegGs - TsSegFs  ; [edx] = prev trapframe + TsSegGs
        cmp     ax, POP_GS              ; Is it pop gs (2-byte) instruction?
        jz      Kt0d005                 ; If z, yes, go Kt0d005

;
; The exception is not caused by pop instruction.  We still need to check
; if it is caused by iret (to user mode.)  Because user may have a bogus
; ss and we will trap at iret in trap exit code.
;

        cmp     al, IRET_OP             ; Is it an iret instruction?
        jne     Kt0d002                 ; if ne, not iret, go check lazy load

        lea     edx, [ebp]+TsHardwareEsp ; (edx)->trapped iret frame
        mov     ax, [ebp]+TsErrCode     ; (ax) = Error Code
        and     ax, NOT RPL_MASK        ; No need to do this ...
        mov     cx, word ptr [edx]+4    ; [cx] = cs selector
        and     cx, NOT RPL_MASK
        cmp     cx, ax                  ; is it faulted in CS?
        jne     short Kt0d0008          ; No

;
; Check if this is the code which we use to return to Ki386CallBios
; (see biosa.asm):
;    cs should be KGDT_R0_CODE OR RPL_MASK
;    eip should be Ki386BiosCallReturnAddress
;    esi should be the esp of function Ki386SetUpAndExitToV86Code
; (edx) -> trapped iret frame
;

        mov     eax, OFFSET FLAT:Ki386BiosCallReturnAddress
        cmp     eax, [edx]              ; [edx]= trapped eip
                                        ; Is eip what we're expecting?
        jne     short Kt0d0005          ; No, continue

        mov     eax, [edx]+4            ; (eax) = trapped cs
        cmp     ax, KGDT_R0_CODE OR RPL_MASK ; Is Cs what we're exptecting?
        jne     short Kt0d0005          ; No

        jmp     Ki386BiosCallReturnAddress ; with interrupts off

Kt0d0005:
;
; Since the CS is bogus, we cannot tell if we are going back to user mode...
;

        mov     ebx,PCR[PcPrcbData+PbCurrentThread] ; if previous mode is
        test    byte ptr [ebx]+ThPreviousMode, 0ffh ;   kernel, we bugcheck
        jz      Kt0d02

        or      word ptr [edx]+4, RPL_MASK
Kt0d0008:
        test    dword ptr [edx]+4, RPL_MASK ; Check CS of iret addr
                                        ; Does the iret have ring transition?
        jz      Kt0d02                  ; if z, no SS involed, it's a real fault

        sti

;
; we trapped at iret while returning back to user mode. We will dispatch
; the exception back to user program.
;

        mov     ecx, (KTRAP_FRAME_LENGTH - 12) / 4
        lea     edx, [ebp]+TsErrCode
Kt0d001:
        mov     eax, [edx]
        mov     [edx+12], eax
        sub     edx, 4
        loop    Kt0d001

        add     esp, 12                 ; adjust esp and ebp
        add     ebp, 12
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     esi, [ebp]+TsErrCode
        and     esi, 0FFFFh
        mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException2Args0d ; Won't return

;
; Kernel mode, first opcode byte is 0f, check for rdmsr or wrmsr instruction
;

Kt0d001a:
        shr     eax, 8
        cmp     al, 30h
        je      short Kt0d001b
        cmp     al, 32h
        jne     short Kt0d002a

Kt0d001b:
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException0Args ; Won't return

;
; The Exception is not caused by pop instruction.  Check to see
; if the instruction is a rdmsr or wrmsr
;
Kt0d002:
        cmp     al, 0fh
        je      short Kt0d001a

;
; We now check if DS and ES contain correct value.  If not, this is lazy
; segment load, we simply set them to valid selector.
;

Kt0d002a:
        cmp     word ptr [ebp]+TsSegDs, KGDT_R3_DATA OR RPL_MASK
        je      short Kt0d003

        mov     dword ptr [ebp]+TsSegDs, KGDT_R3_DATA OR RPL_MASK
        jmp     short Kt0d01

Kt0d003:
        cmp     word ptr [ebp]+TsSegEs, KGDT_R3_DATA OR RPL_MASK
        je      Kt0d02                  ; Real fault, go process it

        mov     dword ptr [ebp]+TsSegEs, KGDT_R3_DATA OR RPL_MASK
        jmp     short Kt0d01

;
; The faulted instruction is pop seg
;

Kt0d005:
        xor     eax, eax
        mov     dword ptr [edx], eax    ; set the segment reg to 0 such that
                                        ; we will trap in user mode.
Kt0d01:

        EXIT_ALL NoRestoreSegs,,NoPreviousMode  ; RETURN

;
;   Caller is not kernel mode, or DS and ES are OK.  Therefore this
;   is a real fault rather than a lazy segment load.  Process as such.
;   Since this is not a lazy segment load is now safe to turn interrupts on.
;
Kt0d02: mov     eax, EXCEPTION_GP_FAULT ; (eax) = trap type
        test    byte ptr [ebp]+TsSegCs, MODE_MASK ; Is prevmode=User?
        jz      _KiSystemFatalException ; If z, prevmode=kernel, stop...


;       preload pointer to process
        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess

;       flat or protect mode ?
        cmp     word ptr [ebp]+TsSegCs, KGDT_R3_CODE OR RPL_MASK
        jz      kt0d0201

;
; if vdm running in protected mode, handle instruction
;
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        jne     Kt0d110

        sti
        cmp     word ptr [ebp]+TsErrCode, 0 ; if errcode<>0, raise access
                                        ; violation exception
        jnz     Kt0d105                 ; if nz, raise access violation
        jmp     short Kt0d03


;
; if vdm running in flat mode, handle pop es,fs,gs by setting to Zero
;
kt0d0202:
        add     dword ptr [ebp].TsEip, 1
kt0d02021:
        mov     dword [edx], 0
        add     dword ptr [ebp].TsEip, 1
        add     dword ptr [ebp].TsHardwareEsp, 4
        jmp     _KiExceptionExit

kt0d0201:
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      short Kt0d03

        mov     eax, [ebp]+TsEip        ; (eax)->faulted Instruction
        mov     eax, [eax]              ; (eax)= opcode of faulted instruction
        mov     edx, ebp                ; (edx)-> trap frame

        add     edx, TsSegEs            ; [edx] = prev trapframe + TsSegEs
        cmp     al, POP_ES              ; Is it pop es instruction?
        jz      short Kt0d02021

@@:
        add     edx, TsSegFs - TsSegEs  ; [edx] = prev trapframe + TsSegFs
        cmp     ax, POP_FS              ; Is it pop fs (2-byte) instruction?
        jz      short kt0d0202

        add     edx, TsSegGs - TsSegFs  ; [edx] = prev trapframe + TsSegGs
        cmp     ax, POP_GS              ; Is it pop gs (2-byte) instruction?
        jz      short kt0d0202

;
; we need to determine if the trap0d was caused by privileged instruction.
; First, we need to skip all the instruction prefix bytes
;

Kt0d03: sti
        push    ds

;
; First we need to set up an exception handler to handle the case that
; we fault while reading user mode instruction.
;

        push    ebp                     ; pass trapframe to handler
        push    offset FLAT:Ktd_ExceptionHandler
                                        ; set up exception registration record
        push    PCR[PcExceptionList]
        mov     PCR[PcExceptionList], esp

        mov     esi, [ebp]+TsEip        ; (esi) -> flat address of faulting instruction
        mov     ax, [ebp]+TsSegCs
        mov     ds, ax
        mov     ecx, MAX_INSTRUCTION_LENGTH

@@:
        push    ecx                     ; save ecx for loop count
        lods    byte ptr [esi]          ; (al)= instruction byte
        mov     ecx, PREFIX_REPEAT_COUNT
        mov     edi, offset FLAT:PrefixTable ; (ES:EDI)->prefix table
        repnz   scasb                   ; search for matching (al)
        pop     ecx                     ; restore loop count
        jnz     short Kt0d10            ; (al) not a prefix byte, go kt0d10
        loop    short @b                ; go check for prefix byte again
        pop     PCR[PcExceptionList]
        add     esp, 8                  ; clear stack
        pop     ds
        jmp     Kt0635                  ; exceed max instruction length,
                                        ; raise ILLEGALINSTRUCTION exception

;
; (al) = first opcode which is NOT prefix byte
; (ds:esi)= points to the first opcode which is not prefix byte + 1
; We need to check if it is one of the privileged instructions
;

Kt0d10: cmp     al, MI_HLT              ; Is it a HLT instruction?
        je      Kt0d80                  ; if e, yes, go kt0d80

        cmp     al, MI_TWO_BYTE         ; Is it a two-byte instruction?
        jne     short Kt0d50            ; if ne, no, go check for IO inst.

        lods    byte ptr [esi]          ; (al)= next instruction byte
        cmp     al, MI_LTR_LLDT         ; Is it a LTR or LLDT ?
        jne     short Kt0d20            ; if ne, no, go kt0d20

        lods    byte ptr [esi]          ; (al)= ModRM byte of instruction
        and     al, MI_MODRM_MASK       ; (al)= bit 3-5 of ModRM byte
        cmp     al, MI_LLDT_MASK        ; Is it a LLDT instruction?
        je      Kt0d80                  ; if e, yes, go Kt0d80

        cmp     al, MI_LTR_MASK         ; Is it a LTR instruction?
        je      Kt0d80                  ; if e, yes, go Kt0d80

        jmp     Kt0d100                 ; if ne, go raise access vioalation

Kt0d20: cmp     al, MI_LGDT_LIDT_LMSW   ; Is it one of these instructions?
        jne     short Kt0d30            ; if ne, no, go check special mov inst.

        lods    byte ptr [esi]          ; (al)= ModRM byte of instruction
        and     al, MI_MODRM_MASK       ; (al)= bit 3-5 of ModRM byte
        cmp     al, MI_LGDT_MASK        ; Is it a LGDT instruction?
        je      short Kt0d80            ; if e, yes, go Kt0d80

        cmp     al, MI_LIDT_MASK        ; Is it a LIDT instruction?
        je      short Kt0d80            ; if e, yes, go Kt0d80

        cmp     al, MI_LMSW_MASK        ; Is it a LMSW instruction?
        je      short Kt0d80            ; if e, yes, go Kt0d80

        jmp     Kt0d100                 ; else, raise access violation except

Kt0d30: and     al, MI_SPECIAL_MOV_MASK ; Is it a special mov instruction?
        jnz     kt0d80                  ; if nz, yes, go raise priv instr
                                        ; (Even though the regular mov may
                                        ; have the special_mov_mask bit set,
                                        ; they are NOT 2 byte opcode instr.)
        jmp     Kt0d100                 ; else, no, raise access violation

;
; Now, we need to check if the trap 0d was caused by IO privileged instruct.
; (al) = first opcode which is NOT prefix byte
; Also note, if we come here, the instruction has 1 byte opcode (still need to
; check REP case.)
;

Kt0d50: mov     ebx, [ebp]+TsEflags     ; (ebx) = client's eflags
        and     ebx, IOPL_MASK          ;
        shr     ebx, IOPL_SHIFT_COUNT   ; (ebx) = client's IOPL
        mov     ecx, [ebp]+TsSegCs
        and     ecx, RPL_MASK           ; RPL_MASK NOT MODE_MASK!!!
                                        ; (ecx) = CPL, 1/2 of computation of
                                        ; whether IOPL applies.

        cmp     ebx,ecx                 ; compare IOPL with CPL of caller
        jge     short Kt0d100           ; if ge, not IO privileged,
                                        ;        go raise access violation

Kt0d60: cmp     al, CLI_OP              ; Is it a CLI instruction
        je      short Kt0d80            ; if e, yes. Report it.

        cmp     al, STI_OP              ; Is it a STI?
        je      short Kt0d80            ; if e, yes, report it.

        mov     ecx, IO_INSTRUCTION_TABLE_LENGTH
        mov     edi, offset FLAT:IOInstructionTable
        repnz   scasb                   ; Is it a IO instruction?
        jnz     short Kt0d100           ; if nz, not io instrct.

;
; We know the instr is an IO instr without IOPL.  But, this doesn't mean
; this is a privileged instruction exception.  We need to make sure the
; IO port access is not granted in the bit map
;


        mov     edi, fs:PcSelfPcr       ; (edi)->Pcr
        mov     esi, [edi]+PcGdt        ; (esi)->Gdt addr
        add     esi, KGDT_TSS
        movzx   ebx, word ptr [esi]     ; (ebx) = Tss limit

        mov     edx, [ebp].TsEdx        ; [edx] = port addr
        mov     ecx, edx
        and     ecx, 07                 ; [ecx] = Bit position
        shr     edx, 3                  ; [edx] = offset to the IoMap

        mov     edi, [edi]+PcTss        ; (edi)->TSS
        movzx   eax, word ptr [edi + TssIoMapBase] ; [eax] = Iomap offset
        add     edx, eax
        cmp     edx, ebx                ; is the offset addr beyond tss limit?
        ja      short Kt0d80            ; yes, no I/O priv.

        add     edi, edx                ; (edi)-> byte correspons to the port addr
        mov     edx, 1
        shl     edx, cl
        test    dword ptr [edi], edx    ; Is the bit of the port disabled?
        jz      short Kt0d100           ; if z, no, then it is access violation

Kt0d80:
        pop     PCR[PcExceptionList]
        add     esp, 8                  ; clear stack
        pop     ds
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     eax, STATUS_PRIVILEGED_INSTRUCTION
        jmp     CommonDispatchException0Args ; Won't return

;
;       NOTE    All the GP fault (except the ones we can
;               easily detect now) will cause access violation exception
;               AND, all the access violation will be raised with additional
;               parameters set to "read" and "virtual address which caused
;               the violation = unknown (-1)"
;

Kt0d100:
        pop     PCR[PcExceptionList]
        add     esp, 8                  ; clear stack
Kt0d103:
        pop     ds
Kt0d105:
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     esi, -1
        mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException2Args0d ; Won't return

Kt0d110:
        ; Raise Irql to APC level, before enabling interrupts
        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql
        push    eax                             ; Save OldIrql
        sti

        stdCall   _Ki386DispatchOpcode
        test    eax,0FFFFh
        jnz     short Kt0d120

        stdCall   _Ki386VdmReflectException,<0dh>
        test    al,0fh
        jnz     short Kt0d120
        pop     ecx                             ; (TOS) = OldIrql
        fstCall KfLowerIrql
        jmp     short Kt0d105

Kt0d120:
        pop     ecx                                ; (TOS) = OldIrql
        fstCall KfLowerIrql
        jmp     _KiExceptionExit

_KiTrap0D       endp

        page ,132
        subttl "Page faults on invalid addresses allowed in certain instances"
;++
; BOOLEAN
; FASTCALL
; KeInvalidAccessAllowed (
;    IN PVOID TrapInformation
;    )
;
;
; Routine Description:
;
;    Mm will pass a pointer to a trap frame prior to issuing a bug check on
;    a pagefault.  This routine lets Mm know if it is ok to bugcheck.  The
;    specific case we must protect are the interlocked pop sequences which can
;    blindly access memory that may have been freed and/or reused prior to the
;    access.  We don't want to bugcheck the system in these cases, so we check
;    the instruction pointer here.
;
; Arguments:
;
;    (ecx) - Trap frame pointer.  NULL means return False.
;
; Return value:
;
;    True if the invalid access should be ignored.
;    False which will usually trigger a bugcheck.
;
;--

cPublicFastCall KeInvalidAccessAllowed, 1
cPublicFpo 0,0

        cmp     ecx, 0                  ; caller gave us a trap frame?
        jne     Ktia01                  ; yes, so examine the frame
        mov     al, 0
        jmp     Ktia02                  ; no frame, go bugcheck
Ktia01:
        mov     edx, offset FLAT:ExpInterlockedPopEntrySListFault
        cmp     [ecx].TsEip, edx        ; check if fault at pop code address
        sete    al                      ; if yes, then don't bugcheck
Ktia02:
        fstRET  KeInvalidAccessAllowed

fstENDP KeInvalidAccessAllowed


;
; The following code it to fix a bug in the Pentium Proccesor dealing with
; Invalid Opcodes.
;


PentiumTest:                            ; Is this access to the write protect
                                        ; IDT page?
        test    [ebp]+TsErrCode, 04h    ; Do not allow user mode access to trap 6
        jne     NoPentiumFix            ; vector. Let page fault code deal with it
        mov     eax, PCR[PcIDT]         ; Get address of trap 6 IDT entry
        add     eax, (6 * 8)
        cmp     eax, edi                ; Is that the faulting address?
        jne     NoPentiumFix            ; No.  Back to page fault code

                                        ; Yes. We have accessed the write
                                        ; protect page of the IDT
        mov     [ebp]+TsErrCode, 0      ; Overwrite error code
        test    dword ptr [ebp]+TsEFlags, EFLAGS_V86_MASK ; Was it a VM?
        jne     Kt06VMpf                ; Yes.  Go to VM part of trap 6
        jmp     Kt06pf                  ; Not from a VM


        page ,132
        subttl "Page fault processing"
;++
;
; Routine Description:
;
;    Handle page fault.
;
;    The page fault occurs if paging is enabled and any one of the
;    conditions is true:
;
;    1. page not present
;    2. the faulting procedure does not have sufficient privilege to
;       access the indicated page.
;
;    For case 1, the referenced page will be loaded to memory and
;    execution continues.
;    For case 2, registered exception handler will be invoked with
;    appropriate error code (in most cases STATUS_ACCESS_VIOLATION)
;
;    N.B. It is assumed that no page fault is allowed during task
;    switches.
;
;    N.B. INTERRUPTS MUST REMAIN OFF UNTIL AFTER CR2 IS CAPTURED.
;
; Arguments:
;
;    Error code left on stack.
;    CR2 contains faulting address.
;    Interrupts are turned off at entry by use of an interrupt gate.
;
; Return value:
;
;    None
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
        ENTER_DR_ASSIST kite_a, kite_t, NoAbiosAssist
align dword
        public  _KiTrap0E
_KiTrap0E       proc

        ENTER_TRAP      kite_a, kite_t

if FAST_BOP
        cmp     dword ptr PCR[PcVdmAlert], 0
        jne     Kt0eVdmAlert
endif

        VERIFY_BASE_TRAP_FRAME

        mov     edi,cr2
;
; Now that everything is in a sane state check for rest of the Pentium
; Processor bug work around for illegal operands
;

        cmp     _KiI386PentiumLockErrataPresent, 0
        jne     PentiumTest              ; Check for special problems

NoPentiumFix:                            ; No.  Skip it
        sti


        test    [ebp]+TsEFlags, EFLAGS_INTERRUPT_MASK   ; faulted with
        jz      Kt0e12b                 ; interrupts disabled?
Kt0e01:

;
; call _MmAccessFault to page in the not present page.  If the cause
; of the fault is 2, _MmAccessFault will return approriate error code
;

        push    ebp                     ; set trap frame address
        mov     eax, [ebp]+TsSegCs      ; set previous mode
        and     eax, MODE_MASK          ;
        push    eax                     ;
        push    edi                     ; set virtual address of page fault
        mov     eax, [ebp]+TsErrCode    ; set load/store indicator
        shr     eax, 1                  ;
        and     eax, _KeErrorMask       ;
        push    eax                     ;

        CAPSTART <_KiTrap0E,_MmAccessFault@16>
        call    _MmAccessFault@16
        CAPEND <_KiTrap0E>

        test    eax, eax                ; check if page fault resolved
        jl      short Kt0e03            ; if l, page fault not resolved
        cmp     _PsWatchEnabled, 0      ; check if working set watch enabled
        je      short @f                ; if e, working set watch not enabled
        mov     ebx, [ebp]+TsEip        ; set exception address
        stdCall _PsWatchWorkingSet, <eax, ebx, edi> ; record working set information
@@:     cmp     _KdpOweBreakpoint, 0    ; check for owed  breakpoints
        je      _KiExceptionExit        ; if e, no owed breakpoints
        stdCall _KdSetOwedBreakpoints   ; notify the debugger
        jmp     _KiExceptionExit        ; join common code

;
; Memory management could not resolve the page fault.
;

Kt0e03: mov     ecx,PCR[PcGdt]

        ; Form Ldt Base
        movzx   ebx,byte ptr [ecx + KGDT_LDT].KgdtBaseHi
        shl     ebx,8
        or      bl,byte ptr [ecx + KGDT_LDT].KgdtBaseMid
        shl     ebx,16
        or      bx,word ptr [ecx + KGDT_LDT].KgdtBaseLow
        or      ebx,ebx                 ; check for zero
        jz      short Kt0e05            ; no ldt

        cmp     edi,ebx
        jb      short Kt0e05            ; address not in LDT

        ; Form Ldt limit
        movzx   edx,byte ptr [ecx + KGDT_LDT].KgdtLimitHi
        and     edx,000000FFh
        shl     edx,16
        or      dx,word ptr [ecx + KGDT_LDT].KgdtLimitLow
        add     ebx,edx
        cmp     edi,ebx
        jae     short Kt0e05            ; too high to be an ldt address

        sldt    cx                      ; Verify this process has an LDT
        test    ecx, 0ffffh             ; Check CX
        jz      short Kt0e05            ; If ZY, no LDT

        mov     eax, [ebp]+TsErrCode    ; (eax)= error code
        shr     eax, 1                  ; isolate read/write bit
        and     eax, _KeErrorMask       ;
        CAPSTART <_KiTrap0E,_MmAccessFault@16>
        stdCall   _MmAccessFault, <eax, edi, 0, ebp>
        CAPEND <_KiTrap0E>

        or      eax, eax                ; successful?
        jge     Kt0e10                  ; if z, yes, go exit

;
; Check to determine if the fault occured in the interlocked pop entry slist
; code. There is a case where a fault may occur in this code when the right
; set of circumstances occurs. The fault can be ignored by simply skipping
; the faulting instruction.
;

Kt0e05: mov     ecx, offset FLAT:ExpInterlockedPopEntrySListFault ; get pop code address
        cmp     [ebp].TsEip, ecx        ; check if fault at pop code address
        je      Kt0e10a                 ; if eq, skip faulting instruction

;
;   Did the fault occur in KiSystemService while copying arguments from
;   user stack to kernel stack?
;
        mov     ecx, offset FLAT:KiSystemServiceCopyArguments
        cmp     [ebp].TsEip, ecx
        je      short Kt0e06

        mov     ecx, offset FLAT:KiSystemServiceAccessTeb
        cmp     [ebp].TsEip, ecx
        jne     short Kt0e07

        mov     ecx, [ebp].TsEbp        ; (eax)->TrapFrame of SysService
        test    [ecx].TsSegCs, MODE_MASK
        jz      short Kt0e07            ; caller of SysService is k mode, we
                                        ; will let it bugcheck.
        mov     [ebp].TsEip, offset FLAT:kss61
        mov     eax, STATUS_ACCESS_VIOLATION
        mov     [ebp].TsEax, eax
        jmp     _KiExceptionExit

Kt0e06:
        mov     ecx, [ebp].TsEbp        ; (eax)->TrapFrame of SysService
        test    [ecx].TsSegCs, MODE_MASK
        jz      short Kt0e07            ; caller of SysService is k mode, we
                                        ; will let it bugcheck.
        mov     [ebp].TsEip, offset FLAT:kss60
        mov     eax, STATUS_ACCESS_VIOLATION
        mov     [ebp].TsEax, eax
        jmp     _KiExceptionExit
Kt0e07:

        mov     ecx, [ebp]+TsErrCode    ; (ecx) = error code
        shr     ecx, 1                  ; isolate read/write bit
        and     ecx, _KeErrorMask       ;
;
;   Did the fault occur in a VDM?
;

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     Kt0e7

;
;   Did the fault occur in a VDM while running in protected mode?
;

        mov     esi,PCR[PcPrcbData+PbCurrentThread]
        mov     esi,[esi]+ThApcState+AsProcess
        cmp     dword ptr [esi]+PrVdmObjects,0 ; is this a vdm process?
        je      short Kt0e9             ; z -> not vdm

        test    dword ptr [ebp]+TsSegCs, MODE_MASK
        jz      short kt0e8

        cmp     word ptr [ebp]+TsSegCs, KGDT_R3_CODE OR RPL_MASK
        jz      kt0e9                   ; z -> not vdm

Kt0e7:  mov     esi, eax
        stdCall _VdmDispatchPageFault, <ebp,ecx,edi>
        test    al,0fh                  ; returns TRUE, if success
        jnz     Kt0e11                  ; Exit,No need to call the debugger

        mov     eax, esi
        jmp     short Kt0e9

Kt0e8:
;
;   Did the fault occur in our kernel VDM support code?
;   At this point, we know:
;      . Current process is VDM process
;      . this is a unresolvable pagefault
;      . the fault occurred in kernel mode.
;

;
;   First make sure this is not pagefault at irql > 1
;   which should be bugchecked.
;

        cmp     eax, STATUS_IN_PAGE_ERROR or 10000000h
        je      Kt0e12

        cmp     word ptr [ebp]+TsSegCs, KGDT_R0_CODE ; Did fault occur in kernel?
        jnz     short Kt0e9             ; if nz, no, not ours

        cmp     PCR[PcExceptionList], EXCEPTION_CHAIN_END
        jnz     short Kt0e9             ; there is at least a handler to
                                        ; handle this exception
        mov     ebp, PCR[PcInitialStack]
        xor     ecx, ecx                ; set to fault-at-read
        sub     ebp, KTRAP_FRAME_LENGTH
        mov     esp, ebp                ; clear stack (ebp)=(esp)->User trap frame
        mov     esi, [ebp]+TsEip        ; (esi)-> faulting instruction
        jmp     Kt0e9b                  ; go dispatching the exception to user

Kt0e9:
; Set up exception record and arguments and call _KiDispatchException
        mov     esi, [ebp]+TsEip        ; (esi)-> faulting instruction

        cmp     eax, STATUS_ACCESS_VIOLATION ; dispatch access violation or
        je      short Kt0e9b                 ; or in_page_error?

        cmp     eax, STATUS_GUARD_PAGE_VIOLATION
        je      short Kt0e9b

        cmp     eax, STATUS_STACK_OVERFLOW
        je      short Kt0e9b


;
; test to see if davec's reserved status code bit is set. If so, then bugchecka
;

        cmp     eax, STATUS_IN_PAGE_ERROR or 10000000h
        je      Kt0e12                  ; bugchecka

;
; (ecx) = ExceptionInfo 1
; (edi) = ExceptionInfo 2
; (eax) = ExceptionInfo 3
; (esi) -> Exception Addr
;

        mov     edx, ecx
        mov     ebx, esi
        mov     esi, edi
        mov     ecx, 3
        mov     edi, eax
        mov     eax, STATUS_IN_PAGE_ERROR
        call    CommonDispatchException ; Won't return

Kt0e9b:
        mov     ebx, esi
        mov     edx, ecx
        mov     esi, edi
        jmp     CommonDispatchException2Args ; Won't return

.FPO ( 0, 0, 0, 0, 0, FPO_TRAPFRAME )

;
; The fault occured in the interlocked pop slist function and the faulting
; instruction should be skipped.
;

Kt0e10a:mov     ecx, offset FLAT:ExpInterlockedPopEntrySListResume ; get resume address
        mov     [ebp].TsEip, ecx        ; set continuation address

Kt0e10:

        mov     esp,ebp                 ; (esp) -> trap frame
        test    _KdpOweBreakpoint, 1    ; do we have any owed breakpoints?
        jz      _KiExceptionExit        ; No, all done

        stdCall _KdSetOwedBreakpoints   ; notify the debugger

Kt0e11: mov     esp,ebp                 ; (esp) -> trap frame
        jmp     _KiExceptionExit        ; join common code


Kt0e12:
        stdCall _KeGetCurrentIrql       ; (eax) = OldIrql
Kt0e12a:
        lock inc     ds:_KiHardwareTrigger   ; trip hardware analyzer

;
; bugcheck a, addr, irql, load/store, pc
;
        mov     ecx, [ebp]+TsErrCode    ; (ecx)= error code
        shr     ecx, 1                  ; isolate read/write bit
        and     ecx, _KeErrorMask       ;
        mov     esi, [ebp]+TsEip        ; [esi] = faulting instruction

        stdCall _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,edi,eax,ecx,esi>

Kt0e12b:

        ;
        ; In V86 mode with iopl allowed it is OK to handle
        ; a page fault with interrupts disabled
        ;

        test    dword ptr [ebp]+TsEFlags, EFLAGS_V86_MASK
        jz      short Kt0e12c

        cmp     _KeI386VdmIoplAllowed, 0
        jnz     Kt0e01

Kt0e12c:
        cmp     _KiFreezeFlag,0         ; during boot we can take
        jnz     Kt0e01                  ; 'transition faults' on the
                                        ; debugger before it's been locked

        cmp     _KiBugCheckData, 0      ; If crashed, handle trap in
        jnz     Kt0e01                  ; normal manner


        mov     eax, 0ffh               ; OldIrql = -1
        jmp     short Kt0e12a

if FAST_BOP

Kt0eVdmAlert:

        ;
        ; If a page fault occured while we are in VDM alert mode (processing
        ; v86 trap without building trap frame), we will restore all the
        ; registers and return to its recovery routine which is stored in
        ; the TsSegGs of original trap frame.
        ;

        mov     eax, PCR[PcVdmAlert]
        mov     dword ptr PCR[PcVdmAlert], 0

        mov     [ebp].TsEip, eax
        mov     esp,ebp                 ; (esp) -> trap frame
        jmp     _KiExceptionExit        ; join common code

ENDIF   ; FAST_BOP


_KiTrap0E       endp

        page ,132
        subttl "Trap0F -- Intel Reserved"
;++
;
; Routine Description:
;
;    The trap 0F should never occur.  If, however, the exception occurs in
;    USER mode, the current process will be terminated.  If the exception
;    occurs in KERNEL mode, a bugcheck will be raised.  NO registered
;    handler, if any, will be invoked to handle the exception.
;
; Arguments:
;
;    None
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kitf_a, kitf_t, NoAbiosAssist
align dword
        public  _KiTrap0F
_KiTrap0F       proc

        push    0                       ; push dummy error code
        ENTER_TRAP      kitf_a, kitf_t
        sti

        mov     eax, EXCEPTION_RESERVED_TRAP ; (eax) = trap type
        jmp     _KiSystemFatalException ; go terminate the system

_KiTrap0F       endp


        page ,132
        subttl "Coprocessor Error"

;++
;
; Routine Description:
;
;    Handle Coprocessor Error.
;
;    This exception is used on 486 or above only.  For i386, it uses
;    IRQ 13 instead.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the aborted instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit10_a, kit10_t, NoAbiosAssist

align dword
        public  _KiTrap10
_KiTrap10       proc

        push    0                       ; push dummy error code
        ENTER_TRAP      kit10_a, kit10_t

        mov     eax, PCR[PcPrcbData+PbCurrentThread]    ; Correct context for
        cmp     eax, PCR[PcPrcbData+PbNpxThread]        ; fault?
        mov     ecx, PCR[PcInitialStack]
        je      Kt0715                  ; Yes - go try to dispatch it

;
; We are in the wrong NPX context and can not dispatch the exception right now.
; Set up the target thread for a delay exception.
;
; Note: we don't think this is a possible case, but just to be safe...
;

        or      dword ptr [ecx].FpCr0NpxState, CR0_TS   ; Set for delayed error
        jmp     _KiExceptionExit

_KiTrap10       endp

        page ,132
        subttl "Alignment fault"
;++
;
; Routine Description:
;
;    Handle alignment faults.
;
;    This exception occurs when an unaligned data access is made by a thread
;    with alignment checking turned on.
;
;    The x86 will not do any alignment checking.  Only threads which have
;    the appropriate bit set in EFLAGS will generate alignment faults.
;
;    The exception will never occur in kernel mode.  (hardware limitation)
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction.
;    Error code is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit11_a, kit11_t, NoAbiosAssist
align dword
        public  _KiTrap11
_KiTrap11       proc

        ENTER_TRAP kit11_a, kit11_t
        sti

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     Kt11_01                 ; v86 mode => usermode

        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jz      Kt11_10

;
; Check to make sure that the AutoAlignment state of this thread is FALSE.
; If not, this fault occurred because the thread messed with its own EFLAGS.
; In order to "fixup" this fault, we just clear the ALIGN_CHECK bit in the
; EFLAGS and restart the instruction.  Exceptions will only be generated if
; AutoAlignment is FALSE.
;
Kt11_01:
        mov     ebx,PCR[PcPrcbData+PbCurrentThread] ; (ebx)-> Current Thread
        test    byte ptr [ebx].ThAutoAlignment, -1
        jz      kt11_00
;
; This fault was generated even though the thread had AutoAlignment set to
; TRUE.  So we fix it up by setting the correct state in his EFLAGS and
; restarting the instruction.
;
        and     dword ptr [ebp]+TsEflags, NOT EFLAGS_ALIGN_CHECK
        jmp     _KiExceptionExit

kt11_00:
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     edx, EXCEPT_LIMIT_ACCESS; assume it is limit violation
        mov     esi, [ebp]+TsHardwareEsp; (esi) = User Stack pointer
        cmp     word ptr [ebp]+TsErrCode, 0 ; Is errorcode = 0?
        jz      short kt11_05            ; if z, yes, go dispatch exception

        mov     edx, EXCEPT_UNKNOWN_ACCESS
kt11_05:
        mov     eax, STATUS_DATATYPE_MISALIGNMENT
        jmp     CommonDispatchException2Args ; Won't return

kt11_10:
;
; We should never be here, since the 486 will not generate alignment faults
; in kernel mode.
;
        mov     eax, EXCEPTION_ALIGNMENT_CHECK      ; (eax) = trap type
        jmp     _KiSystemFatalException

_KiTrap11       endp

;++
;
; Routine Description:
;
;    Handle XMMI Exception.
;;
; Arguments:
;
;    At entry, the saved CS:EIP point to the aborted instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit13_a, kit13_t, NoAbiosAssist

align dword
        public  _KiTrap13
_KiTrap13       proc

        push    0                       ; push dummy error code
        ENTER_TRAP      kit13_a, kit13_t

        mov     eax, PCR[PcPrcbData+PbNpxThread]  ; Correct context for fault?
        cmp     eax, PCR[PcPrcbData+PbCurrentThread]
        je      Kt13_10                 ; Yes - go try to dispatch it

;
;       Katmai New Instruction exceptions are precise and occur immediately.
;       if we are in the wrong NPX context, bugcheck the system.
;
        ; stop the system
        stdCall _KeBugCheckEx,<TRAP_CAUSE_UNKNOWN,13,eax,0,0>

Kt13_10:
        mov     ecx, PCR[PcInitialStack] ; (ecx) -> top of kernel stack

;
;       TrapFrame is built by ENTER_TRAP.
;       XMMI are accessible from all IA execution modes:
;       Protected Mode, Real address mode, Virtual 8086 mode
;
Kt13_15:
        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     Kt13_130                ; v86 mode

;
;       eflags.vm=0 (not v86 mode)
;
        test    byte ptr [ebp]+TsSegCs, MODE_MASK ; Is previousMode=USER?
        jz      Kt13_05                 ; if z, previousmode=SYSTEM

;
;       eflags.vm=0 (not v86 mode)
;       previousMode=USER
;
        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     Kt13_110                ; May still be a vdm...

;
;       eflags.vm=0 (not v86 mode)
;       previousMode=USER
;       Cs=00011011
;
; We are about to dispatch a XMMI floating point exception to user mode.
;
; (ebp) - Trap frame
; (ecx) - CurrentThread's NPX save area (PCR[PcInitialStack])
; (eax) - CurrentThread

; Dispatch
Kt13_20:
;
; Some type of coprocessor exception has occured for the current thread.
;
; Interrupts disabled
;
        mov     ebx, cr0
        and     ebx, NOT (CR0_MP+CR0_EM+CR0_TS)
        mov     cr0, ebx                ; Clear MP+TS+EM to do fxsave

;
; Save the faulting state so we can inspect the cause of the floating
; point fault
;
        FXSAVE_ECX

if DBG
        test    dword ptr [ecx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_TS)
        jnz     Kt13_dbg2
endif

        or      ebx, NPX_STATE_NOT_LOADED ; CR0_TS | CR0_MP
        or      ebx,[ecx]+FpCr0NpxState ; restore this thread's CR0 NPX state
        mov     cr0, ebx                ; set TS so next ESC access causes trap

;
; Clear TS bit in Cr0NpxFlags in case it was set to trigger this trap.
;
        and     dword ptr [ecx].FpCr0NpxState, NOT CR0_TS

;
; The state is no longer in the coprocessor.  Clear ThNpxState and
; re-enable interrupts to allow context switching.
;
        mov     byte ptr [eax].ThNpxState, NPX_STATE_NOT_LOADED
        mov     dword ptr PCR[PcPrcbData+PbNpxThread], 0  ; No state in coprocessor
        sti

; (eax) = ExcepCode - Exception code to put into exception record
; (ebx) = ExceptAddress - Addr of instruction which the hardware exception occurs
; (ecx) = NumParms - Number of additional parameters
; (edx) = Parameter1
; (esi) = Parameter2
; (edi) = Parameter3
        mov     ebx, [ebp].TsEip          ; Eip is from trap frame, not from FxErrorOffset
        movzx   eax, word ptr [ecx] + FxMXCsr
        mov     edx, eax
        shr     edx, 7                    ; get the mask
        not     edx
        mov     esi, 0                    ; (esi) = operand addr, addr is computed from
                                          ; trap frame, not from FxDataOffset
;
;       Exception will be handled in user's handler if there is one declared.
;
        and     eax, FSW_INVALID_OPERATION + FSW_DENORMAL + FSW_ZERO_DIVIDE + FSW_OVERFLOW + FSW_UNDERFLOW + FSW_PRECISION
        and     eax, edx
        test    eax, FSW_INVALID_OPERATION ; Is it an invalid op exception?
        jz      short Kt13_40              ; if z, no, go Kt13_40
;
; Invalid Operation Exception - Invalid arithmetic operand
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_TRAPS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_40:
; Check for floating zero divide exception
;
        test    eax, FSW_ZERO_DIVIDE    ; Is it a zero divide error?
        jz      short Kt13_50           ; if z, no, go Kt13_50
;
; Division-By-Zero Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_TRAPS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_50:
; Check for denormal error
;
        test    eax, FSW_DENORMAL       ; Is it a denormal error?
        jz      short Kt13_60           ; if z, no, go Kt13_60
;
; Denormal Operand Excpetion
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_TRAPS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_60:
; Check for floating overflow error
;
        test    eax, FSW_OVERFLOW       ; Is it an overflow error?
        jz      short Kt13_70           ; if z, no, go Kt13_70
;
; Numeric Overflow Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_FAULTS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_70:
; Check for floating underflow error
;
        test    eax, FSW_UNDERFLOW      ; Is it a underflow error?
        jz      short Kt13_80           ; if z, no, go Kt13_80
;
; Numeric Underflow Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_FAULTS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_80:
; Check for precision (IEEE inexact) error
;
        test    eax, FSW_PRECISION      ; Is it a precision error
        jz      short Kt13_100          ; if z, no, go Kt13_100
;
; Inexact-Result (Precision) Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_FAULTS
        jmp     CommonDispatchException1Arg0d ; Won't return

; Huh?
Kt13_100:
; If status word does not indicate error, then something is wrong...
; (Note: that we have done a sti, before the status is examined)
        sti
; stop the system
        stdCall _KeBugCheckEx,<TRAP_CAUSE_UNKNOWN,13,eax,0,1>

;
;       eflags.vm=0 (not v86 mode)
;       previousMode=USER
;       Cs=!00011011
;       (We should have (eax) -> CurrentThread)
;
Kt13_110:
; Check to see if this process is a vdm
        mov     ebx,PCR[PcPrcbData+PbCurrentThread] ; (ebx) -> CurrentThread
        mov     ebx,[ebx]+ThApcState+AsProcess      ; (ebx) -> CurrentProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt13_20                             ; no, dispatch exception
                                                    ; yes, drop down to v86 mode
;
;       eflags.vm=1 (v86 mode)
;
Kt13_130:
; Turn off TS
        mov     ebx,CR0
        and     ebx,NOT CR0_TS
        mov     CR0,ebx
        and     dword ptr [ecx]+FpCr0NpxState,NOT CR0_TS

;
; Reflect the exception to the vdm, the VdmHandler enables interrupts
;

        ; Raise Irql to APC level before enabling interrupts
        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql
        push    eax                     ; Save OldIrql
        sti

        stdCall   _VdmDispatchIRQ13, <ebp> ; ebp - Trapframe
        test    al,0fh
        jnz     Kt13_135
        pop     ecx                     ; (TOS) = OldIrql
        fstCall KfLowerIrql
        jmp     Kt13_20                 ; could not reflect, gen exception

Kt13_135:
        pop     ecx                     ; (TOS) = OldIrql
        fstCall KfLowerIrql
        jmp     _KiExceptionExit

;
;       eflags.vm=0 (not v86 mode)
;       previousMode=SYSTEM
;
Kt13_05:
        ; stop the system
        stdCall _KeBugCheckEx,<TRAP_CAUSE_UNKNOWN,13,0,0,2>

if DBG
Kt13_dbg1:    int 3
Kt13_dbg2:    int 3
Kt13_dbg3:    int 3
        sti
        jmp short $-2
endif

_KiTrap13       endp


        page ,132
        subttl "Coprocessor Error Handler"
;++
;
; Routine Description:
;
;    When the FPU detects an error, it raises its error line.  This
;    was supposed to be routed directly to the x86 to cause a trap 16
;    (which would actually occur when the x86 encountered the next FP
;    instruction).
;
;    However, the ISA design routes the error line to IRQ13 on the
;    slave 8259.  So an interrupt will be generated whenever the FPU
;    discovers an error.  Unfortunately, we could be executing system
;    code at the time, in which case we can't dispatch the exception.
;
;    So we force emulation of the intended behaviour.  This interrupt
;    handler merely sets TS and Cr0NpxState TS and dismisses the interrupt.
;    Then, on the next user FP instruction, a trap 07 will be generated, and
;    the exception can be dispatched then.
;
;    Note that we don't have to clear the FP exeception here,
;    since that will be done in the trap 07 handler.  The x86 will
;    generate the trap 07 before the FPU gets a chance to raise another
;    error interrupt.  We'll want to save the FPU state in the trap 07
;    handler WITH the error information.
;
;    Note the caller must clear the FPU error latch.  (this is done in
;    the hal).
;
; Arguments:
;
;    None
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING

align dword
cPublicProc _KiCoprocessorError     ,0

;
; Set TS in Cr0NpxState - the next time this thread runs an ESC
; instruction the error will be dispatched.  We also need to set TS
; in CR0 in case the owner of the NPX is currently running.
;
; Bit must be set in FpCr0NpxState before CR0.
;
        mov     eax, PCR[PcPrcbData+PbNpxThread]
        mov     eax, [eax].ThInitialStack
        sub     eax, NPX_FRAME_LENGTH   ; Space for NPX_FRAME
        or      dword ptr [eax].FpCr0NpxState, CR0_TS

        mov     eax, cr0
        or      eax, CR0_TS
        mov     cr0, eax
        stdRET    _KiCoprocessorError

stdENDP _KiCoprocessorError

;
; BBT cannot instrument code between BBT_Exclude_Trap_Code_Begin and this label
;
        public  _BBT_Exclude_Trap_Code_End
_BBT_Exclude_Trap_Code_End  equ     $
        int 3

;++
;
; VOID
; KiFlushNPXState (
;     PFLOATING_SAVE_AREA SaveArea
;     )
;
; Routine Description:
;
;   When a thread's NPX context is requested (most likely by a debugger)
;   this function is called to flush the thread's NPX context out of the
;   compressor if required.
;
; Arguments:
;
;    Pointer to a location where this function must do fnsave for the
;    current thread.
;
;    NOTE that this pointer can be NON-NULL only if KeI386FxsrPresent is
;         set (FXSR feature is present)
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING
align dword

SaveArea    equ     [esp + 20]

cPublicProc _KiFlushNPXState    ,1
cPublicFpo 1, 4

        push    esi
        push    edi
        push    ebx
        pushfd
        cli                             ; don't context switch

        mov     edi, PCR[PcSelfPcr]
        mov     esi, [edi].PcPrcbData+PbCurrentThread

        cmp     byte ptr [esi].ThNpxState, NPX_STATE_LOADED
        je      short fnpx20

fnpx00:
        ; NPX state is not loaded. If SaveArea is non-null, we need to return
        ; the saved FP state in fnsave format.

        cmp     dword ptr SaveArea, 0
        je      fnpx70

if DBG
        ;
        ; SaveArea can be NON-NULL ONLY when FXSR feature is present
        ;

        test    byte ptr _KeI386FxsrPresent, 1
        jnz     @f
        int     3
@@:
endif
        ;
        ; Need to convert the (not loaded) NPX state of the current thread
        ; to FNSAVE format into the SaveArea
        ;
        mov     ebx, cr0
        test    ebx, CR0_MP+CR0_TS+CR0_EM
        jz      short fnpx07
        and     ebx, NOT (CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, ebx                ; allow frstor (& fnsave) to work
fnpx07:
        ;
        ; If NPX state is for some other thread, save it away
        ;

        mov     eax, [edi].PcPrcbData+PbNpxThread   ; Owner of NPX state
        or      eax, eax
        jz      short fnpx10            ; no - skip save

        cmp     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        jne     short fnpx10            ; not loaded, skip save

ifndef NT_UP
if DBG
        ; This can only happen UP where the context is not unloaded on a swap
        int 3
endif
endif

        ;
        ; Save current owners NPX state
        ;

        mov     ecx, [eax].ThInitialStack
        sub     ecx, NPX_FRAME_LENGTH   ; Space for NPX_FRAME
        FXSAVE_ECX
        mov     byte ptr [eax].ThNpxState, NPX_STATE_NOT_LOADED

fnpx10:
        ;
        ; Load current thread's NPX state
        ;

        mov     ecx, [edi].PcInitialStack ; (ecx) -> top of kernel stack
        FXRSTOR_ECX                       ; reload NPX context
        mov     ecx, SaveArea
        jmp     short fnpx40

fnpx20:
        ;
        ; Current thread has NPX state in the coprocessor, flush it
        ;
        mov     ebx, cr0
        test    ebx, CR0_MP+CR0_TS+CR0_EM
        jz      short fnpx30
        and     ebx, NOT (CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, ebx                   ; allow frstor (& fnsave) to work
fnpx30:
        mov     ecx, [edi].PcInitialStack  ; (ecx) -> top of kernel stack

        test    byte ptr _KeI386FxsrPresent, 1
        jz      short fnpx40
        FXSAVE_ECX

        ; Do fnsave to SaveArea if it is non-null
        mov     ecx,  SaveArea
        jecxz   short fnpx50

fnpx40:
        fnsave  [ecx]                   ; NPX state to save area
        fwait                           ; Make sure data is in save area
fnpx50:
        xor     eax, eax
        mov     ecx, [edi+PcInitialStack]  ; (ecx) -> top of kernel stack
        mov     byte ptr [esi].ThNpxState, NPX_STATE_NOT_LOADED
        mov     [edi].PcPrcbData+PbNpxThread, eax  ; clear npx owner
;;      mov     [ecx].FpNpxSavedCpu, eax        ; clear last npx processor

        or      ebx, NPX_STATE_NOT_LOADED       ; or in new thread's cr0
        or      ebx, [ecx]+FpCr0NpxState        ; merge new thread setable state
        mov     cr0, ebx

fnpx70:
        popfd                           ; enable interrupts
        pop     ebx
        pop     edi
        pop     esi
        stdRET    _KiFlushNPXState

stdENDP _KiFlushNPXState

;++
;
; VOID
; KiSetHardwareTrigger (
;     VOID
;     )
;
; Routine Description:
;
;   This function sets KiHardwareTrigger such that an analyzer can sniff
;   for this access.   It needs to occur with a lock cycle such that
;   the processor won't speculatively read this value.   Interlocked
;   functions can't be used as in a UP build they do not use a
;   lock prefix.
;
; Arguments:
;
;    None
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING
cPublicProc _KiSetHardwareTrigger,0
   lock inc     ds:_KiHardwareTrigger   ; trip hardware analyzer
        stdRet  _KiSetHardwareTrigger
stdENDP _KiSetHardwareTrigger


        page ,132
        subttl "Processing System Fatal Exceptions"
;++
;
; Routine Description:
;
;    This routine processes the system fatal exceptions.
;    The machine state and trap type will be displayed and
;    System will be stopped.
;
; Arguments:
;
;    (eax) = Trap type
;    (ebp) -> machine state frame
;
; Return value:
;
;    system stopped.
;
;--
        assume  ds:nothing, es:nothing, ss:nothing, fs:nothing, gs:nothing

align dword
        public  _KiSystemFatalException
_KiSystemFatalException proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        stdCall _KeBugCheckEx,<UNEXPECTED_KERNEL_MODE_TRAP, eax, 0, 0, 0>
        ret

_KiSystemFatalException endp

        page
        subttl  "Continue Execution System Service"
;++
;
; NTSTATUS
; NtContinue (
;    IN PCONTEXT ContextRecord,
;    IN BOOLEAN TestAlert
;    )
;
; Routine Description:
;
;    This routine is called as a system service to continue execution after
;    an exception has occurred. Its function is to transfer information from
;    the specified context record into the trap frame that was built when the
;    system service was executed, and then exit the system as if an exception
;    had occurred.
;
;   WARNING - Do not call this routine directly, always call it as
;             ZwContinue!!!  This is required because it needs the
;             trapframe built by KiSystemService.
;
; Arguments:
;
;    KTrapFrame (ebp+0: after setup) -> base of KTrapFrame
;
;    ContextRecord (ebp+8: after setup) = Supplies a pointer to a context rec.
;
;    TestAlert (esp+12: after setup) = Supplies a boolean value that specifies
;       whether alert should be tested for the previous processor mode.
;
; Return Value:
;
;    Normally there is no return from this routine. However, if the specified
;    context record is misaligned or is not accessible, then the appropriate
;    status code is returned.
;
;--

NcTrapFrame             equ     [ebp + 0]
NcContextRecord         equ     [ebp + 8]
NcTestAlert             equ     [ebp + 12]

align dword
cPublicProc _NtContinue     ,2

        push    ebp

;
; Restore old trap frame address since this service exits directly rather
; than returning.
;

        mov     ebx, PCR[PcPrcbData+PbCurrentThread] ; get current thread address
        mov     edx, [ebp].TsEdx        ; restore old trap frame address
        mov     [ebx].ThTrapFrame, edx  ;

;
; Call KiContinue to load ContextRecord into TrapFrame.  On x86 TrapFrame
; is an atomic entity, so we don't need to allocate any other space here.
;
; KiContinue(NcContextRecord, 0, NcTrapFrame)
;

        mov     ebp,esp
        mov     eax, NcTrapFrame
        mov     ecx, NcContextRecord
        CAPSTART <_NtContinue,_KiContinue@12>
        stdCall  _KiContinue, <ecx, 0, eax>
        CAPEND   <_NtContinue>
        or      eax,eax                 ; return value 0?
        jnz     short Nc20              ; KiContinue failed, go report error

;
; Check to determine if alert should be tested for the previous processor mode.
;

        cmp     byte ptr NcTestAlert,0  ; Check test alert flag
        je      short Nc10              ; if z, don't test alert, go Nc10
        mov     al,byte ptr [ebx]+ThPreviousMode ; No need to xor eax, eax.
        CAPSTART <_NtContinue,_KeTestAlertThread@4>
        stdCall _KeTestAlertThread, <eax> ; test alert for current thread
        CAPEND   <_NtContinue>
Nc10:   CAPEND <_KiSystemService>
        pop     ebp                     ; (ebp) -> TrapFrame
        mov     esp,ebp                 ; (esp) = (ebp) -> trapframe
        jmp     _KiServiceExit2         ; common exit

Nc20:   pop     ebp                     ; (ebp) -> TrapFrame
        mov     esp,ebp                 ; (esp) = (ebp) -> trapframe
        jmp     _KiServiceExit          ; common exit

stdENDP _NtContinue

        page
        subttl  "Raise Exception System Service"
;++
;
; NTSTATUS
; NtRaiseException (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PCONTEXT ContextRecord,
;    IN BOOLEAN FirstChance
;    )
;
; Routine Description:
;
;    This routine is called as a system service to raise an exception. Its
;    function is to transfer information from the specified context record
;    into the trap frame that was built when the system service was executed.
;    The exception may be raised as a first or second chance exception.
;
;   WARNING - Do not call this routine directly, always call it as
;             ZwRaiseException!!!  This is required because it needs the
;             trapframe built by KiSystemService.
;
;   NOTE - KiSystemService will terminate the ExceptionList, which is
;          not what we want for this case, so we will fish it out of
;          the trap frame and restore it.
;
; Arguments:
;
;    TrapFrame (ebp+0: before setup) -> System trap frame for this call
;
;    ExceptionRecord (ebp+8: after setup) -> An exception record.
;
;    ContextRecord (ebp+12: after setup) -> Points to a context record.
;
;    FirstChance (ebp+16: after setup) -> Supplies a boolean value that
;       specifies whether the exception is to be raised as a first (TRUE)
;       or second chance (FALSE) exception.
;
; Return Value:
;
;    None.
;--
align dword
cPublicProc _NtRaiseException ,3
NtRaiseException:

        push    ebp

;
; Restore old trap frame address since this service exits directly rather
; than returning.
;

        mov     ebx, PCR[PcPrcbData+PbCurrentThread] ; get current thread address
        mov     edx, [ebp].TsEdx        ; restore old trap frame address
        mov     [ebx].ThTrapFrame, edx  ;

;
;   Put back the ExceptionList so the exception can be properly
;   dispatched.
;

        mov     ebp,esp                 ; [ebp+0] -> TrapFrame
        mov     ebx, [ebp+0]            ; (ebx)->TrapFrame
        mov     edx, [ebp+16]           ; (edx) = First chance indicator
        mov     eax, [ebx]+TsExceptionList ; Old exception list
        mov     ecx, [ebp+12]           ; (ecx)->ContextRecord
        mov     PCR[PcExceptionList],eax
        mov     eax, [ebp+8]            ; (eax)->ExceptionRecord

;
;   KiRaiseException(ExceptionRecord, ContextRecord, ExceptionFrame,
;           TrapFrame, FirstChance)
;

        CAPSTART <NtRaiseException,_KiRaiseException@20>
        stdCall   _KiRaiseException,<eax, ecx, 0, ebx, edx>
        CAPEND   <NtRaiseException>

        pop     ebp
        mov     esp,ebp                 ; (esp) = (ebp) -> trap frame

;
;   If the exception was handled, then the trap frame has been edited to
;   reflect new state, and we'll simply exit the system service to get
;   the effect of a continue.
;
;   If the exception was not handled, exit via KiServiceExit so the
;   return status is propagated back to the caller.
;
        or      eax, eax                ; test exception handled
        jnz     _KiServiceExit          ; if exception not handled
        jmp     _KiServiceExit2

stdENDP _NtRaiseException



        page
        subttl "Reflect Exception to a Vdm"
;++
;
;   Routine Description:
;       Local stub which reflects an exception to a VDM using
;       Ki386VdmReflectException,
;
;   Arguments:
;
;       ebp -> Trap frame
;       ss:esp + 4 = trap number
;
;   Returns
;       ret value from Ki386VdmReflectException
;       interrupts are disabled uppon return
;
cPublicProc _Ki386VdmReflectException_A, 1

        sub     esp, 4*2

        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql

        sti
        mov     [esp+4], eax                ; Save OldIrql
        mov     eax, [esp+12]               ; Pick up trap number
        mov     [esp+0], eax

        call    _Ki386VdmReflectException@4 ; pops one dword

        mov     ecx, [esp+0]                ; (ecx) = OldIrql
        mov     [esp+0], eax                ; Save return code

        fstCall KfLowerIrql

        pop     eax                         ; pops second dword
        ret     4

stdENDP _Ki386VdmReflectException_A





        page
        subttl "Fast System Call code templates"
;++
;
;   Routine Description:
;
;       One of the following sets of code will be copied to
;       SharedUserData->SystemCall to be executed for system
;       calls from user mode.
;
;       In the fast call case, if an attempt is made to single
;       step over the system call instruction, the processor
;       will double fault because no valid stack address is
;       set on which to handle the debug exception.  The double
;       fault handler will arrange to return one byte later
;       than normal allowing the following code to re-enable
;       single step mode.
;
;   Arguments:
;
;
;   Returns
;
;--

        public  _KiDefaultSystemCall, _KiDefaultSystemCallEnd
_KiDefaultSystemCall:
        lea     edx, [esp]+8        ; (edx) -> arguments
        int     2eh
        ret
_KiDefaultSystemCallEnd:

        public  _KiFastSystemCallIa32, _KiFastSystemCallIa32End
_KiFastSystemCallIa32:
        mov     edx, esp            ; (edx) -> arguments-8
        iSYSENTER
fscrr0: ret
        pushfd                      ; reset single step mode
        or      [esp], EFLAGS_TF_MASK
        popfd
        ret
_KiFastSystemCallIa32End:

        public  _KiFastSystemCallAmdK6, _KiFastSystemCallAmdK6End
_KiFastSystemCallAmdK6:
        mov     edx, esp            ; (edx) -> arguments-8
        iSYSCALL
fscrr1: ret
        pushfd                      ; reset single step mode
        or      [esp], EFLAGS_TF_MASK
        popfd
        ret
_KiFastSystemCallAmdK6End:

;
; For Fast System Call return, the EIP saved in the trap frame should
; correspond to the RET instruction in the above two syscall sequences.
; Note: It is much faster to return to the return instruction than to
; pop the return address off the stack and use that because doing so
; unbalances the call/return stack the processor uses for branch prediction.
;

fscrOffset  EQU     fscrr0-_KiFastSystemCallIa32
fscrOffset2 EQU     fscrr1-_KiFastSystemCallAmdK6
            .errnz  fscrOffset2-fscrOffset

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\trapc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    trapc.c

Abstract:

    This module contains some trap handling code written in C.
    Only by the kernel.

Author:

    Ken Reneris     6-9-93

Revision History:

--*/

#include    "ki.h"

NTSTATUS
Ki386CheckDivideByZeroTrap (
    IN  PKTRAP_FRAME    UserFrame
    );

VOID
KipWorkAroundCompiler (
    USHORT * StatusWord,
    USHORT * ControlWord
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Ki386CheckDivideByZeroTrap)
#endif


#define REG(field)          ((ULONG)(&((KTRAP_FRAME *)0)->field))
#define GETREG(frame,reg)   ((PULONG) (((ULONG) frame)+reg))[0]

typedef struct {
    UCHAR   RmDisplaceOnly;     // RM of displacment only, no base reg
    UCHAR   RmSib;              // RM of SIB
    UCHAR   RmDisplace;         // bit mask of RMs which have a displacement
    UCHAR   Disp;               // sizeof displacement (in bytes)
} KMOD, *PKMOD;

static UCHAR RM32[] = {
    /* 000 */   REG(Eax),
    /* 001 */   REG(Ecx),
    /* 010 */   REG(Edx),
    /* 011 */   REG(Ebx),
    /* 100 */   REG(HardwareEsp),
    /* 101 */   REG(Ebp),       // SIB
    /* 110 */   REG(Esi),
    /* 111 */   REG(Edi)
};

static UCHAR RM8[] = {
    /* 000 */   REG(Eax),       // al
    /* 001 */   REG(Ecx),       // cl
    /* 010 */   REG(Edx),       // dl
    /* 011 */   REG(Ebx),       // bl
    /* 100 */   REG(Eax) + 1,   // ah
    /* 101 */   REG(Ecx) + 1,   // ch
    /* 110 */   REG(Edx) + 1,   // dh
    /* 111 */   REG(Ebx) + 1    // bh
};

static KMOD MOD32[] = {
    /* 00 */     5,     4,   0x20,   4,
    /* 01 */  0xff,     4,   0xff,   1,
    /* 10 */  0xff,     4,   0xff,   4,
    /* 11 */  0xff,  0xff,   0x00,   0
} ;

static struct {
    UCHAR   Opcode1, Opcode2;   // instruction opcode
    UCHAR   ModRm, type;        // if 2nd part of opcode is encoded in ModRm
} NoWaitNpxInstructions[] = {
    /* FNINIT   */  0xDB, 0xE3, 0,  1,
    /* FNCLEX   */  0xDB, 0xE2, 0,  1,
    /* FNSTENV  */  0xD9, 0x06, 1,  1,
    /* FNSAVE   */  0xDD, 0x06, 1,  1,
    /* FNSTCW   */  0xD9, 0x07, 1,  2,
    /* FNSTSW   */  0xDD, 0x07, 1,  3,
    /* FNSTSW AX*/  0xDF, 0xE0, 0,  4,
                    0x00, 0x00, 0,  1
};


NTSTATUS
Ki386CheckDivideByZeroTrap (
    IN  PKTRAP_FRAME    UserFrame
    )
/*++

Routine Description:

    This function gains control when the x86 processor generates a
    divide by zero trap.  The x86 design generates such a trap on
    divide by zero and on division overflows.  In order to determine
    which expection code to dispatch, the divisor of the "div" or "idiv"
    instruction needs to be inspected.

Arguments:

    UserFrame - Trap frame of the divide by zero trap

Return Value:

    exception code dispatch

--*/
{
    ULONG       operandsize, operandmask, i, accum;
    PUCHAR      istream, pRM;
    UCHAR       ibyte, rm;
    PKMOD       Mod;
    BOOLEAN     fPrefix;
    NTSTATUS    status;

    status = STATUS_INTEGER_DIVIDE_BY_ZERO;

    if (UserFrame->SegCs == KGDT_R0_CODE) {
        //
        // Divide by zero exception from Kernel Mode?
        // Likely bad hardware interrupt and the device or vector table is corrupt.
        // Bugcheck NOW so we can figure out what went wrong. If we try and
        // proceed, then we'll likely fault in reading the top of user space, and then
        // double fault (page fault in the div zero handler.) -- This is a debugging
        // consideration. You can't put breakpoints on the trap labels  so this is hard to debug.
        // We cannot recover
        //
        //
        KeBugCheck (UNEXPECTED_KERNEL_MODE_TRAP);

    }


    try {

        //
        // read instruction prefixes
        //

        fPrefix = TRUE;
        pRM = RM32;
        operandsize = 4;
        operandmask = 0xffffffff;
        istream = (PUCHAR) UserFrame->Eip;
        while (fPrefix) {
            ibyte = ProbeAndReadUchar(istream);
            istream++;
            switch (ibyte) {
                case 0x2e:  // cs override
                case 0x36:  // ss override
                case 0x3e:  // ds override
                case 0x26:  // es override
                case 0x64:  // fs override
                case 0x65:  // gs override
                case 0xF3:  // rep
                case 0xF2:  // rep
                case 0xF0:  // lock
                    break;

                case 0x66:
                    // 16 bit operand override
                    operandsize = 2;
                    operandmask = 0xffff;
                    break;

                case 0x67:
                    // 16 bit address size override
                    // this is some non-flat code
                    goto try_exit;

                default:
                    fPrefix = FALSE;
                    break;
            }
        }

        //
        // Check instruction opcode
        //

        if (ibyte != 0xf7  &&  ibyte != 0xf6) {
            // this is not a DIV or IDIV opcode
            goto try_exit;
        }

        if (ibyte == 0xf6) {
            // this is a byte div or idiv
            operandsize = 1;
            operandmask = 0xff;
        }

        //
        // Get Mod R/M
        //

        ibyte = ProbeAndReadUchar (istream);
        istream++;
        Mod = MOD32 + (ibyte >> 6);
        rm  = ibyte & 7;

        //
        // put register values into accum
        //

        if (operandsize == 1  &&  (ibyte & 0xc0) == 0xc0) {
            pRM = RM8;
        }

        accum = 0;
        if (rm != Mod->RmDisplaceOnly) {
            if (rm == Mod->RmSib) {
                // get SIB
                ibyte = ProbeAndReadUchar(istream);
                istream++;
                i = (ibyte >> 3) & 7;
                if (i != 4) {
                    accum = GETREG(UserFrame, RM32[i]);
                    accum = accum << (ibyte >> 6);    // apply scaler
                }
                i = ibyte & 7;
                accum = accum + GETREG(UserFrame, RM32[i]);
            } else {
                // get register's value
                accum = GETREG(UserFrame, pRM[rm]);
            }
        }

        //
        // apply displacement to accum
        //

        if (Mod->RmDisplace & (1 << rm)) {
            if (Mod->Disp == 4) {
                i = ProbeAndReadUlong ((PULONG) istream);
            } else {
                ibyte = ProbeAndReadChar (istream);
                i = (signed long) ((signed char) ibyte);    // sign extend
            }
            accum += i;
        }

        //
        // if this is an effective address, go get the data value
        //

        if (Mod->Disp && accum) {
            switch (operandsize) {
                case 1:  accum = ProbeAndReadUchar((PUCHAR) accum);    break;
                case 2:  accum = ProbeAndReadUshort((PUSHORT) accum);  break;
                case 4:  accum = ProbeAndReadUlong((PULONG) accum);    break;
            }
        }

        //
        // accum now contains the instruction operand, see if the
        // operand was really a zero
        //

        if (accum & operandmask) {
            // operand was non-zero, must be an overflow
            status = STATUS_INTEGER_OVERFLOW;
        }

try_exit: ;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        // do nothing...
    }

    return status;
}

UCHAR
KiNextIStreamByte (
    IN  PKTRAP_FRAME UserFrame,
    IN  PUCHAR  *istream
    )
/*++

Routine Description:

    Reads the next byte from the istream pointed to by the UserFrame, and
    advances the EIP.


    Note: this function works for 32 bit code only

--*/
{
    UCHAR   ibyte;

    if (UserFrame->SegCs == KGDT_R0_CODE) {
        ibyte = **istream;
    } else {
        ibyte = ProbeAndReadUchar (*istream);
    }

    *istream += 1;
    return ibyte;
}




BOOLEAN
Ki386CheckDelayedNpxTrap (
    IN  PKTRAP_FRAME UserFrame,
    IN  PFX_SAVE_AREA NpxFrame
    )

/*++

Routine Description:

    This function gains control from the Trap07 handler.  It examines
    the user mode instruction to see if it's a NoWait NPX instruction.
    Such instructions do not generate floating point exceptions - this
    check needs to be done due to the way 80386/80387 systems are
    implemented.  Such machines will generate a floating point exception
    interrupt when the kernel performs an FRSTOR to reload the thread's
    NPX context.  If the thread's next instruction is a NoWait style
    instruction, then we clear the exception or emulate the instruction.

    AND... due to a different 80386/80387 "feature" the kernel needs
    to use FWAIT at times which can causes 80487's to generate delayed
    exceptions that can lead to the same problem described above.

Arguments:

    UserFrame - Trap frame of the exception
    NpxFrame - Thread's NpxFrame  (WARNING: does not have NpxState)

    Interrupts are disabled

Return Value:

    FALSE - Dispatch NPX exception to user mode
    TRUE - Exception handled, continue

--*/

{
    EXCEPTION_RECORD ExceptionRecord;
    UCHAR       ibyte1, ibyte2, inmodrm, status;
    USHORT      StatusWord, ControlWord, UsersWord;
    PUCHAR      istream;
    BOOLEAN     fPrefix;
    UCHAR       rm;
    PKMOD       Mod;
    ULONG       accum, i;

    status = 0;


    //
    // read instruction prefixes
    //

    fPrefix = TRUE;
    istream = (PUCHAR) UserFrame->Eip;

    try {

        while (fPrefix) {
            ibyte1 = KiNextIStreamByte (UserFrame, &istream);
            switch (ibyte1) {
                case 0x2e:  // cs override
                case 0x36:  // ss override
                case 0x3e:  // ds override
                case 0x26:  // es override
                case 0x64:  // fs override
                case 0x65:  // gs override
                    break;

                default:
                    fPrefix = FALSE;
                    break;
            }
        }

        //
        // Check for coprocessor NoWait NPX instruction
        //

        ibyte2 = KiNextIStreamByte (UserFrame, &istream);
        inmodrm = (ibyte2 >> 3) & 0x7;

        for (i=0; NoWaitNpxInstructions[i].Opcode1; i++) {
            if (NoWaitNpxInstructions[i].Opcode1 == ibyte1) {

                //
                // first opcode byte matched - check second part of opcode
                //

                if (NoWaitNpxInstructions[i].ModRm) {

                    //
                    // modrm only applies for opcode in range 0-0xbf
                    //

                    if (((ibyte2 & 0xc0) != 0xc0) &&
                        (NoWaitNpxInstructions[i].Opcode2 == inmodrm)) {

                        //
                        // This is a no-wait NPX instruction
                        //

                        status = NoWaitNpxInstructions[i].type;
                        break;
                    }

                } else {
                    if (NoWaitNpxInstructions[i].Opcode2 == ibyte2) {

                        //
                        // This is a no-wait NPX instruction
                        //

                        status = NoWaitNpxInstructions[i].type;
                        break;
                    }
                }
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        // do nothing...
    }

    if (status == 0) {
        //
        // Dispatch coprocessor exception to user mode
        //

        return FALSE;
    }

    if (status == 1) {
        //
        // Ignore pending exception, user mode instruction does not trap
        // on pending execptions and it will clear/mask the pending exceptions
        //

        _asm {
            mov     eax, cr0
            and     eax, NOT (CR0_MP+CR0_EM+CR0_TS)
            mov     cr0, eax
        }

        NpxFrame->Cr0NpxState &= ~CR0_TS;
        return TRUE;
    }

    //
    // This is either FNSTSW or FNSTCW.  Both of these instructions get
    // a value from the coprocessor without effecting the pending exception
    // state.  To do this we emulate the instructions.
    //

    //
    // Read the coprocessors Status & Control word state, then re-enable
    // interrupts.  (it's safe to context switch after that point)
    //

    //
    // NOTE: The new compiler is generating a FWAIT at the
    // entry to the try/except block if it sees inline
    // fp instructions, even if they are only control word accesses.
    // put this stuff in another function to fool it.
    //

    KipWorkAroundCompiler (&StatusWord, &ControlWord);

    if (status == 4) {
        //
        // Emulate FNSTSW AX
        //

        UserFrame->Eip = (ULONG)istream;
        UserFrame->Eax = (UserFrame->Eax & 0xFFFF0000) | StatusWord;
        return TRUE;
    }

    if (status == 2) {
        UsersWord = ControlWord;
    } else {
        UsersWord = StatusWord;
    }

    try {

        //
        // (PERFNOTE: the operand decode code should really share code with
        // KiCheckDivideByZeroTrap, but this is a late change therefore the
        // code was copied to keep the impact of the change localized)
        //

        //
        // decode Mod/RM byte
        //

        Mod = MOD32 + (ibyte2 >> 6);
        rm  = ibyte2 & 7;

        //
        // Decode the instruction's word pointer into accum
        //

        accum = 0;
        if (rm != Mod->RmDisplaceOnly) {
            if (rm == Mod->RmSib) {
                // get SIB
                ibyte1 = KiNextIStreamByte (UserFrame, &istream);
                i = (ibyte1 >> 3) & 7;
                if (i != 4) {
                    accum = GETREG(UserFrame, RM32[i]);
                    accum = accum << (ibyte1 >> 6);    // apply scaler
                }
                i = ibyte1 & 7;
                accum = accum + GETREG(UserFrame, RM32[i]);
            } else {
                // get register's value
                accum = GETREG(UserFrame, RM32[rm]);
            }
        }

        //
        // apply displacement to accum
        //

        if (Mod->RmDisplace & (1 << rm)) {
            if (Mod->Disp == 4) {
                i = (KiNextIStreamByte (UserFrame, &istream) << 0) |
                    (KiNextIStreamByte (UserFrame, &istream) << 8) |
                    (KiNextIStreamByte (UserFrame, &istream) << 16) |
                    (KiNextIStreamByte (UserFrame, &istream) << 24);
            } else {
                ibyte1 = KiNextIStreamByte (UserFrame, &istream);
                i = (signed long) ((signed char) ibyte1);    // sign extend
            }
            accum += i;
        }

        //
        // Set the word pointer
        //

        if (UserFrame->SegCs == KGDT_R0_CODE) {
            *((PUSHORT) accum) = UsersWord;
        } else {
            ProbeAndWriteUshort ((PUSHORT) accum, UsersWord);
        }
        UserFrame->Eip = (ULONG)istream;

    } except (KiCopyInformation(&ExceptionRecord,
                (GetExceptionInformation())->ExceptionRecord)) {

        //
        // Faulted addressing user's memory.
        // Set the address of the exception to the current program address
        // and raise the exception by calling the exception dispatcher.
        //

        ExceptionRecord.ExceptionAddress = (PVOID)(UserFrame->Eip);
        KiDispatchException(
            &ExceptionRecord,
            NULL,                // ExceptionFrame
            UserFrame,
            UserMode,
            TRUE
        );
    }

    return TRUE;
}

//
// Code description is above. We do this here to stop the compiler
// from putting fwait in the try/except block
//
// Read the coprocessor's Status & Control word state, then re-enable
// interrupts.  (it's safe to context switch after that point)
//
//

VOID
KipWorkAroundCompiler (
    IN PUSHORT StatusWord,
    IN PUSHORT ControlWord
    )
{
    USHORT sw;
    USHORT cw;
    
    sw = *StatusWord;
    cw = *ControlWord;

    _asm {
        mov     eax, cr0
        mov     ecx, eax
        and     eax, NOT (CR0_MP+CR0_EM+CR0_TS)
        mov     cr0, eax

        fnstsw  sw
        fnstcw  cw

        mov     cr0, ecx
        sti
    }

    *StatusWord = sw;
    *ControlWord = cw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\vdmint21.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vdmint21.c

Abstract:

    This module implements interfaces that support manipulation of i386
    int 21 entry of IDT. These entry points only exist on i386 machines.

Author:

    Shie-Lin Tzong (shielint) 26-Dec-1993

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#pragma hdrstop
#include "vdmntos.h"

#define IDT_ACCESS_DPL_USER 0x6000
#define IDT_ACCESS_TYPE_386_TRAP 0xF00
#define IDT_ACCESS_TYPE_286_TRAP 0x700
#define IDT_ACCESS_PRESENT 0x8000
#define LDT_MASK 4

//
// External Reference
//

BOOLEAN
Ki386GetSelectorParameters(
    IN USHORT Selector,
    OUT PULONG Flags,
    OUT PULONG Base,
    OUT PULONG Limit
    );

//
// Define forward referenced function prototypes.
//

VOID
Ki386LoadTargetInt21Entry (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

#define KiLoadInt21Entry() \
    KeGetPcr()->IDT[0x21] = PsGetCurrentProcess()->Pcb.Int21Descriptor

NTSTATUS
Ke386SetVdmInterruptHandler (
    PKPROCESS   Process,
    ULONG       Interrupt,
    USHORT      Selector,
    ULONG       Offset,
    BOOLEAN     Gate32
    )

/*++

Routine Description:

    The specified (software) interrupt entry of IDT will be updated to
    point to the specified handler.  For all threads which belong to the
    specified process, their execution processors will be notified to
    make the same change.

    This function only exists on i386 and i386 compatible processors.

    No checking is done on the validity of the interrupt handler.

Arguments:

    Process - Pointer to KPROCESS object describing the process for
        which the int 21 entry is to be set.

    Interrupt - The software interrupt vector which will be updated.

    Selector, offset - Specified the address of the new handler.

    Gate32 - True if the gate should be 32 bit, false otherwise

Return Value:

    NTSTATUS.

--*/

{

    KIRQL OldIrql;
    BOOLEAN LocalProcessor;
    KAFFINITY TargetProcessors;
    PKPRCB  Prcb;
    KIDTENTRY IdtDescriptor;
    ULONG Flags, Base, Limit;

    //
    // Check the validity of the request
    // 1. Currently, we support int21 redirection only
    // 2. The specified interrupt handler must be in user space.
    //

    if (Interrupt != 0x21 || Offset >= (ULONG)MM_HIGHEST_USER_ADDRESS ||
        !Ki386GetSelectorParameters(Selector, &Flags, &Base, &Limit) ){
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Initialize the contents of the IDT entry
    //

    IdtDescriptor.Offset = (USHORT)Offset;
    IdtDescriptor.Selector = Selector | RPL_MASK | LDT_MASK;
    IdtDescriptor.ExtendedOffset = (USHORT)(Offset >> 16);
    IdtDescriptor.Access = IDT_ACCESS_DPL_USER | IDT_ACCESS_PRESENT;
    if (Gate32) {
        IdtDescriptor.Access |= IDT_ACCESS_TYPE_386_TRAP;

    } else {
        IdtDescriptor.Access |= IDT_ACCESS_TYPE_286_TRAP;
    }

    //
    // Acquire the context swap lock so a context switch will not occur.
    //

    KiLockContextSwap(&OldIrql);

    //
    // Set the Ldt fields in the process object
    //

    Process->Int21Descriptor = IdtDescriptor;

    //
    // Tell all processors active for this process to reload their LDTs
    //

#if !defined(NT_UP)

    Prcb = KeGetCurrentPrcb();
    TargetProcessors = Process->ActiveProcessors & ~Prcb->SetMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        Ki386LoadTargetInt21Entry,
                        NULL,
                        NULL,
                        NULL);
    }

#endif

    KiLoadInt21Entry();

#if !defined(NT_UP)

    //
    // Wait until all of the target processors have finished reloading
    // their LDT.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    //
    // Restore IRQL and unlock the context swap lock.
    //

    KiUnlockContextSwap(OldIrql);
    return STATUS_SUCCESS;
}

#if !defined(NT_UP)


VOID
Ki386LoadTargetInt21Entry (
    IN PKIPI_CONTEXT    PacketContext,
    IN PVOID            Parameter1,
    IN PVOID            Parameter2,
    IN PVOID            Parameter3
    )
/*++

Routine Description:

    Reload local Ldt register and clear signal bit in TargetProcessor mask

Arguments:

    Argument - pointer to a ipi packet structure.
    ReadyFlag - Pointer to flag to be set once LDTR has been reloaded

Return Value:

    none.

--*/

{

    //
    // Set the int 21 entry of IDT from currently active process object
    //

    KiLoadInt21Entry();
    KiIpiSignalPacketDone(PacketContext);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\vdm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    VDM.C

Abstract:

    This module contains support routines for the x86 monitor for
    running Dos applications in V86 mode.

Author:

    Dave Hastings (daveh) 20 Mar 1991

Environment:

    The code in this module is all x86 specific.

Notes:

    In its current implementation, this code is less robust than it needs
    to be.  This will be fixed.  Specifically, parameter verification needs
    to be done. (daveh 7/15/91)

    Support for 32 bit segments (2/2/92)

Revision History:

    20-Mar-1991 daveh
        created

--*/

#include "ki.h"
#pragma hdrstop
#include "vdmntos.h"
#include "..\..\vdm\i386\vdmp.h"

#define VDM_IO_TEST 0

#if VDM_IO_TEST
VOID
TestIoHandlerStuff(
    VOID
    );
#endif

BOOLEAN
Ki386GetSelectorParameters(
    IN USHORT Selector,
    OUT PULONG Flags,
    OUT PULONG Base,
    OUT PULONG Limit
    );


BOOLEAN
Ki386VdmDispatchIo(
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Read,
    IN UCHAR InstructionSize,
    IN PKTRAP_FRAME TrapFrame
    );

BOOLEAN
Ki386VdmDispatchStringIo(
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Rep,
    IN BOOLEAN Read,
    IN ULONG Count,
    IN ULONG Address,
    IN UCHAR InstructionSize,
    IN PKTRAP_FRAME TrapFrame
    );


BOOLEAN
VdmDispatchIoToHandler(
    IN PVDM_IO_HANDLER VdmIoHandler,
    IN ULONG Context,
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Read,
    IN OUT PULONG Data
    );

BOOLEAN
VdmDispatchUnalignedIoToHandler(
    IN PVDM_IO_HANDLER VdmIoHandler,
    IN ULONG Context,
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Read,
    IN OUT PULONG Data
    );

BOOLEAN
VdmDispatchStringIoToHandler(
    IN PVDM_IO_HANDLER VdmIoHandler,
    IN ULONG Context,
    IN ULONG PortNumber,
    IN ULONG Size,
    IN ULONG Count,
    IN BOOLEAN Read,
    IN ULONG Data
    );

BOOLEAN
VdmCallStringIoHandler(
    IN PVDM_IO_HANDLER VdmIoHandler,
    IN PVOID StringIoRoutine,
    IN ULONG Context,
    IN ULONG PortNumber,
    IN ULONG Size,
    IN ULONG Count,
    IN BOOLEAN Read,
    IN ULONG Data
    );

BOOLEAN
VdmConvertToLinearAddress(
    IN ULONG SegmentedAddress,
    IN PVOID *LinearAddress
    );

VOID
KeI386VdmInitialize(
    VOID
    );

ULONG
Ki386VdmEnablePentiumExtentions(
    ULONG
    );

VOID
Ki386AdlibEmulation(
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Read,
    IN UCHAR InstructionSize,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
Ki386AdlibDirectIo (
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Read,
    IN UCHAR InstructionSize,
    IN PKTRAP_FRAME TrapFrame
    );

#pragma alloc_text(PAGE, Ki386GetSelectorParameters)
#pragma alloc_text(PAGE, Ki386VdmDispatchIo)
#pragma alloc_text(PAGE, Ki386VdmDispatchStringIo)
#pragma alloc_text(PAGE, VdmDispatchIoToHandler)
#pragma alloc_text(PAGE, VdmDispatchUnalignedIoToHandler)
#pragma alloc_text(PAGE, VdmDispatchStringIoToHandler)
#pragma alloc_text(PAGE, VdmCallStringIoHandler)
#pragma alloc_text(PAGE, VdmConvertToLinearAddress)
#pragma alloc_text(PAGE, Ki386AdlibEmulation)
#pragma alloc_text(PAGE, Ki386AdlibDirectIo)
#pragma alloc_text(INIT, KeI386VdmInitialize)

KMUTEX VdmStringIoMutex;

ULONG KeI386EFlagsAndMaskV86 = EFLAGS_USER_SANITIZE;
ULONG KeI386EFlagsOrMaskV86 = EFLAGS_INTERRUPT_MASK;
BOOLEAN KeI386VdmIoplAllowed = FALSE;
ULONG KeI386VirtualIntExtensions = 0;

BOOLEAN
Ki386GetSelectorParameters(
    IN USHORT Selector,
    OUT PULONG Flags,
    OUT PULONG Base,
    OUT PULONG Limit
    )

/*++

Routine Description:

    This routine gets information about a selector in the ldt, and
    returns it to the caller.

Arguments:

    IN USHORT Selector -- selector number for selector to return info for
    OUT PULONG Flags -- flags indicating the type of the selector.
    OUT PULONG Base -- base linear address of the selector
    OUT PULONG Limit -- limit of the selector.

Return Value:

    return-value - True if the selector is in the LDT, and present.
                    False otherwise.
Note:

    This routine should probably be somewhere else.  There are a number
    of issues to clear up with respect to selectors and the kernel, and
    after they have been cleared up, this code will be moved to its
    correct place

--*/

{

    PLDT_ENTRY Ldt,OldLdt;
    ULONG LdtLimit,OldLdtLimit,RetryCount = 0;
    PKPROCESS Process;
    BOOLEAN ReturnValue = TRUE;

    *Flags = 0;

    if ((Selector & (SELECTOR_TABLE_INDEX | DPL_USER))
        != (SELECTOR_TABLE_INDEX | DPL_USER)) {
        return FALSE;
    }


    Process = KeGetCurrentThread()->ApcState.Process;
    Ldt = (PLDT_ENTRY)((Process->LdtDescriptor.BaseLow) |
        (Process->LdtDescriptor.HighWord.Bytes.BaseMid << 16) |
        (Process->LdtDescriptor.HighWord.Bytes.BaseHi << 24));

    LdtLimit = ((Process->LdtDescriptor.LimitLow) |
        (Process->LdtDescriptor.HighWord.Bits.LimitHi << 16));

    Selector &= ~(SELECTOR_TABLE_INDEX | DPL_USER);

    //
    // Under normal circumstances, we will only execute the following loop
    // once.  If there is a bug in the user mode wow code however, the LDT
    // may change while we execute the following code.  We don't want to take
    // the Ldt mutex, because that is expensive.
    //

    do {

        RetryCount++;

        if (((ULONG)Selector >= LdtLimit) || (!Ldt)) {
            return FALSE;
        }

        try {

            if (!Ldt[Selector/sizeof(LDT_ENTRY)].HighWord.Bits.Pres) {
                *Flags = SEL_TYPE_NP;
                ReturnValue = FALSE;
            } else {

                *Base = (Ldt[Selector/sizeof(LDT_ENTRY)].BaseLow |
                    (Ldt[Selector/sizeof(LDT_ENTRY)].HighWord.Bytes.BaseMid << 16) |
                    (Ldt[Selector/sizeof(LDT_ENTRY)].HighWord.Bytes.BaseHi << 24));

                *Limit = (Ldt[Selector/sizeof(LDT_ENTRY)].LimitLow |
                    (Ldt[Selector/sizeof(LDT_ENTRY)].HighWord.Bits.LimitHi << 16));

                *Flags = 0;

                if ((Ldt[Selector/sizeof(LDT_ENTRY)].HighWord.Bits.Type & 0x18) == 0x18) {
                    *Flags |= SEL_TYPE_EXECUTE;

                    if (Ldt[Selector/sizeof(LDT_ENTRY)].HighWord.Bits.Type & 0x02) {
                        *Flags |= SEL_TYPE_READ;
                    }
                } else {
                    *Flags |= SEL_TYPE_READ;
                    if (Ldt[Selector/sizeof(LDT_ENTRY)].HighWord.Bits.Type & 0x02) {
                        *Flags |= SEL_TYPE_WRITE;
                    }
                    if (Ldt[Selector/sizeof(LDT_ENTRY)].HighWord.Bits.Type & 0x04) {
                        *Flags |= SEL_TYPE_ED;
                    }
                }

                if (Ldt[Selector/sizeof(LDT_ENTRY)].HighWord.Bits.Default_Big) {
                    *Flags |= SEL_TYPE_BIG;
                }

                if (Ldt[Selector/sizeof(LDT_ENTRY)].HighWord.Bits.Granularity) {
                    *Flags |= SEL_TYPE_2GIG;
                }
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Ldt = 0;
            LdtLimit = 0;
        }

        if (ReturnValue == FALSE) {
            break;
        }

        OldLdt = Ldt;
        OldLdtLimit = LdtLimit;

        Ldt = (PLDT_ENTRY)((Process->LdtDescriptor.BaseLow) |
            (Process->LdtDescriptor.HighWord.Bytes.BaseMid << 16) |
            (Process->LdtDescriptor.HighWord.Bytes.BaseHi << 24));

        LdtLimit = ((Process->LdtDescriptor.LimitLow) |
            (Process->LdtDescriptor.HighWord.Bits.LimitHi << 16));

    } while (((Ldt != OldLdt) || (LdtLimit != OldLdtLimit)) && (RetryCount <= 10));

    //
    // If we can't get an answer in 10 tries, we never will
    //
    if ((RetryCount > 10)) {
        ReturnValue = FALSE;
    }

    return ReturnValue;
}

BOOLEAN
Ki386VdmDispatchIo(
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Read,
    IN UCHAR InstructionSize,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine sets up the Event info for an IO event, and causes the
    event to be reflected to the Monitor.

    It is assumed that interrupts are enabled upon entry, and Irql is
    at APC level.

Arguments:

    PortNumber -- Supplies the port number the IO was done to
    Size -- Supplies the size of the IO operation.
    Read -- Indicates whether the IO operation was a read or a write.
    InstructionSize -- Supplies the size of the IO instruction in bytes.

Return Value:

    True if the io instruction will be reflected to User mode.

--*/

{
    PVDM_TIB VdmTib;
    EXCEPTION_RECORD ExceptionRecord;
    VDM_IO_HANDLER VdmIoHandler;
    ULONG Result;
    BOOLEAN Success = FALSE;
    ULONG Context;
    PVDM_PROCESS_OBJECTS pVdmObjects;

    //
    // First check if this port needs special handling
    //

    if (Size == 1) {
        pVdmObjects = PsGetCurrentProcess()->VdmObjects;
        if (pVdmObjects &&
            (pVdmObjects->AdlibAction == ADLIB_DIRECT_IO ||
             pVdmObjects->AdlibAction == ADLIB_KERNEL_EMULATION)) {

            if ((PortNumber >= pVdmObjects->AdlibPhysPortStart &&
                 PortNumber <= pVdmObjects->AdlibPhysPortEnd) ||
                (PortNumber >= pVdmObjects->AdlibVirtPortStart &&
                 PortNumber <= pVdmObjects->AdlibVirtPortEnd)) {
                if (pVdmObjects->AdlibAction == ADLIB_DIRECT_IO) {

                    //
                    // Convert virtual ports to physical porrs otherwise
                    // we don't know where we write to.
                    //

                    if (PortNumber >= pVdmObjects->AdlibVirtPortStart &&
                        PortNumber <= pVdmObjects->AdlibVirtPortEnd) {
                        PortNumber = PortNumber - pVdmObjects->AdlibVirtPortStart +
                                     pVdmObjects->AdlibPhysPortStart;
                    }
                    Ki386AdlibDirectIo (PortNumber,
                                        Size,
                                        Read,
                                        InstructionSize,
                                        TrapFrame);
                } else {
                    Ki386AdlibEmulation(PortNumber,
                                        Size,
                                        Read,
                                        InstructionSize,
                                        TrapFrame);
                }
                TrapFrame->Eip += InstructionSize;
                return TRUE;
            }
        }
    }

    Success = Ps386GetVdmIoHandler(
        PsGetCurrentProcess(),
        PortNumber & ~0x3,
        &VdmIoHandler,
        &Context
        );

    if (Success) {
        Result = TrapFrame->Eax;
        // if port is not aligned, perform unaligned IO
        // else do the io the easy way
        if (PortNumber % Size) {
            Success = VdmDispatchUnalignedIoToHandler(
                &VdmIoHandler,
                Context,
                PortNumber,
                Size,
                Read,
                &Result
                );
        } else {
            Success = VdmDispatchIoToHandler(
                &VdmIoHandler,
                Context,
                PortNumber,
                Size,
                Read,
                &Result
                );
        }
    }

    if (Success) {
        if (Read) {
            switch (Size) {
            case 4:
                TrapFrame->Eax = Result;
                break;
            case 2:
                *(PUSHORT)(&TrapFrame->Eax) = (USHORT)Result;
                break;
            case 1:
                *(PUCHAR)(&TrapFrame->Eax) = (UCHAR)Result;
                break;
            }
        }
        TrapFrame->Eip += (ULONG) InstructionSize;
        return TRUE;
    } else {
        if (!NT_SUCCESS (VdmpGetVdmTib(&VdmTib))) {
            ExceptionRecord.ExceptionCode = STATUS_ACCESS_VIOLATION;
            ExceptionRecord.ExceptionFlags = 0;
            ExceptionRecord.NumberParameters = 0;
            ExRaiseException(&ExceptionRecord);
            return FALSE;
        }
        try {
            VdmTib->EventInfo.InstructionSize = (ULONG) InstructionSize;
            VdmTib->EventInfo.Event = VdmIO;
            VdmTib->EventInfo.IoInfo.PortNumber = (USHORT)PortNumber;
            VdmTib->EventInfo.IoInfo.Size = (USHORT)Size;
            VdmTib->EventInfo.IoInfo.Read = Read;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ExceptionRecord.ExceptionCode = STATUS_ACCESS_VIOLATION;
            ExceptionRecord.ExceptionFlags = 0;
            ExceptionRecord.NumberParameters = 0;
            ExRaiseException(&ExceptionRecord);
            return FALSE;
        }
    }

    VdmEndExecution(TrapFrame, VdmTib);

    return TRUE;

}

BOOLEAN
Ki386VdmDispatchStringIo(
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Rep,
    IN BOOLEAN Read,
    IN ULONG Count,
    IN ULONG Address,
    IN UCHAR InstructionSize,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine sets up the Event info for a string IO event, and causes the
    event to be reflected to the Monitor.

    It is assumed that interrupts are enabled upon entry, and Irql is
    at APC level.

Arguments:

    PortNumber -- Supplies the port number the IO was done to
    Size -- Supplies the size of the IO operation.
    Read -- Indicates whether the IO operation was a read or a write.
    Count -- indicates the number of IO operations of Size size
    Address -- Indicates address for string io
    InstructionSize -- Supplies the size of the IO instruction in bytes.


Return Value:

    True if the io instruction will be reflected to User mode.



--*/

{
    PVDM_TIB VdmTib;
    EXCEPTION_RECORD ExceptionRecord;
    BOOLEAN Success = FALSE;
    VDM_IO_HANDLER VdmIoHandler;
    ULONG Context;

    Success = Ps386GetVdmIoHandler(
        PsGetCurrentProcess(),
        PortNumber & ~0x3,
        &VdmIoHandler,
        &Context
        );


    if (Success) {
        Success = VdmDispatchStringIoToHandler(
            &VdmIoHandler,
            Context,
            PortNumber,
            Size,
            Count,
            Read,
            Address
            );
    }

    if (Success) {
        PUSHORT pIndexRegister;
        USHORT Index;

        // WARNING no 32 bit address support

        pIndexRegister = Read ? (PUSHORT)&TrapFrame->Edi
                              : (PUSHORT)&TrapFrame->Esi;

        if (TrapFrame->EFlags & EFLAGS_DF_MASK) {
            Index = *pIndexRegister - (USHORT)(Count * Size);
            }
        else {
            Index = *pIndexRegister + (USHORT)(Count * Size);
            }

        *pIndexRegister = Index;

        if (Rep) {
            (USHORT)TrapFrame->Ecx = 0;
            }

        TrapFrame->Eip += (ULONG) InstructionSize;
        return TRUE;
    }

    if (!NT_SUCCESS (VdmpGetVdmTib(&VdmTib))) {
        ExceptionRecord.ExceptionCode = STATUS_ACCESS_VIOLATION;
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.NumberParameters = 0;
        ExRaiseException(&ExceptionRecord);
        return FALSE;
    }

    try {
        VdmTib->EventInfo.InstructionSize = (ULONG) InstructionSize;
        VdmTib->EventInfo.Event = VdmStringIO;
        VdmTib->EventInfo.StringIoInfo.PortNumber = (USHORT)PortNumber;
        VdmTib->EventInfo.StringIoInfo.Size = (USHORT)Size;
        VdmTib->EventInfo.StringIoInfo.Rep = Rep;
        VdmTib->EventInfo.StringIoInfo.Read = Read;
        VdmTib->EventInfo.StringIoInfo.Count = Count;
        VdmTib->EventInfo.StringIoInfo.Address = Address;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ExceptionRecord.ExceptionCode = STATUS_ACCESS_VIOLATION;
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.NumberParameters = 0;
        ExRaiseException(&ExceptionRecord);
        return FALSE;
    }


    VdmEndExecution(TrapFrame, VdmTib);

    return TRUE;
}

BOOLEAN
VdmDispatchIoToHandler(
    IN PVDM_IO_HANDLER VdmIoHandler,
    IN ULONG Context,
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Read,
    IN OUT PULONG Data
    )

/*++

Routine Description:

     This routine calls the handler for the IO.  If there is not a handler
     of the proper size, it will call this function for 2 io's to the next
     smaller size.  If the size was a byte, and there was no handler, FALSE
     is returned.

Arguments:

    VdmIoHandler -- Supplies a pointer to the handler table
    Context -- Supplies 32 bits of data set when the port was trapped
    PortNumber -- Supplies the port number the IO was done to
    Size -- Supplies the size of the IO operation.
    Read -- Indicates whether the IO operation was a read or a write.
    Result -- Supplies a pointer to the location to put the result

Return Value:

    True if one or more handlers were called to take care of the IO.
    False if no handler was called to take care of the IO.

--*/

{
    NTSTATUS Status;
    BOOLEAN Success1, Success2;
    USHORT FnIndex;
    UCHAR AccessType;

    // Insure that Io is aligned
    ASSERT((!(PortNumber % Size)));

    if (Read) {
        FnIndex = 0;
        AccessType = EMULATOR_READ_ACCESS;
    } else {
        FnIndex = 1;
        AccessType = EMULATOR_WRITE_ACCESS;
    }

    switch (Size) {
    case 1:
        if (VdmIoHandler->IoFunctions[FnIndex].UcharIo[PortNumber % 4]) {
            Status = (*(VdmIoHandler->IoFunctions[FnIndex].UcharIo[PortNumber % 4]))(
                Context,
                PortNumber,
                AccessType,
                (PUCHAR)Data
                );
            if (NT_SUCCESS(Status)) {
                return TRUE;
            }
        }
        // No handler for this port
        return FALSE;

    case 2:
        if (VdmIoHandler->IoFunctions[FnIndex].UshortIo[PortNumber % 2]) {
            Status = (*(VdmIoHandler->IoFunctions[FnIndex].UshortIo[PortNumber % 2]))(
                Context,
                PortNumber,
                AccessType,
                (PUSHORT)Data
                );
            if (NT_SUCCESS(Status)) {
                return TRUE;
            }
        } else {
            // Dispatch to the two uchar handlers for this ushort port
            Success1 = VdmDispatchIoToHandler(
                VdmIoHandler,
                Context,
                PortNumber,
                Size /2,
                Read,
                Data
                );

            Success2 = VdmDispatchIoToHandler(
                VdmIoHandler,
                Context,
                PortNumber + 1,
                Size / 2,
                Read,
                (PULONG)((PUCHAR)Data + 1)
                );

            return (Success1 || Success2);

        }
        return FALSE;

    case 4:
        if (VdmIoHandler->IoFunctions[FnIndex].UlongIo) {
            Status = (*(VdmIoHandler->IoFunctions[FnIndex].UlongIo))(
                Context,
                PortNumber,
                AccessType,
                Data
                );
            if (NT_SUCCESS(Status)) {
                return TRUE;
            }
        } else {
            // Dispatch to the two ushort handlers for this port
            Success1 = VdmDispatchIoToHandler(
                VdmIoHandler,
                Context,
                PortNumber,
                Size /2,
                Read,
                Data);
            Success2 = VdmDispatchIoToHandler(
                VdmIoHandler,
                Context,
                PortNumber + 2,
                Size / 2,
                Read,
                (PULONG)((PUSHORT)Data + 1)
                );

            return (Success1 || Success2);
        }
        return FALSE;
    }

    return FALSE;
}

BOOLEAN
VdmDispatchUnalignedIoToHandler(
    IN PVDM_IO_HANDLER VdmIoHandler,
    IN ULONG Context,
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Read,
    IN OUT PULONG Data
    )

/*++

Routine Description:

     This routine converts the unaligned IO to the necessary number of aligned
     IOs to smaller ports.

Arguments:

    VdmIoHandler -- Supplies a pointer to the handler table
    Context -- Supplies 32 bits of data set when the port was trapped
    PortNumber -- Supplies the port number the IO was done to
    Size -- Supplies the size of the IO operation.
    Read -- Indicates whether the IO operation was a read or a write.
    Result -- Supplies a pointer to the location to put the result

Return Value:

    True if one or more handlers were called to take care of the IO.
    False if no handler was called to take care of the IO.

--*/

{
    ULONG Offset;
    BOOLEAN Success;

    ASSERT((Size > 1));
    ASSERT((PortNumber % Size));

    Offset = 0;

    //
    //  The possible unaligned io situations are as follows.
    //
    //  1.  Uchar aligned Ulong io
    //          We have to dispatch a uchar io, a ushort io, and a uchar io
    //
    //  2.  Ushort aligned Ulong Io
    //          We have to dispatch a ushort io, and a ushort io
    //
    //  3.  Uchar aligned Ushort Io
    //          We have to dispatch a uchar io and a uchar io
    //

    // if the port is uchar aligned
    if ((PortNumber % Size) & 1) {
        Success = VdmDispatchIoToHandler(
            VdmIoHandler,
            Context,
            PortNumber,
            1,
            Read,
            Data
            );
        Offset += 1;
    // else it is ushort aligned (and therefore must be a ulong port)
    } else {
        Success = VdmDispatchIoToHandler(
            VdmIoHandler,
            Context,
            PortNumber,
            2,
            Read,
            Data
            );
        Offset += 2;
    }

    // if it is a ulong port, we know we have a ushort IO to dispatch
    if (Size == 4) {
        Success |= VdmDispatchIoToHandler(
            VdmIoHandler,
            Context,
            PortNumber + Offset,
            2,
            Read,
            (PULONG)((PUCHAR)Data + Offset)
            );
        Offset += 2;
    }

    // If we haven't dispatched the entire port, dispatch the final uchar
    if (Offset != 4) {
        Success |= VdmDispatchIoToHandler(
            VdmIoHandler,
            Context,
            PortNumber + Offset,
            1,
            Read,
            (PULONG)((PUCHAR)Data + Offset)
            );
    }

    return Success;
}

BOOLEAN
VdmDispatchStringIoToHandler(
    IN PVDM_IO_HANDLER VdmIoHandler,
    IN ULONG Context,
    IN ULONG PortNumber,
    IN ULONG Size,
    IN ULONG Count,
    IN BOOLEAN Read,
    IN ULONG Data
    )

/*++

Routine Description:

     This routine calls the handler for the IO.  If there is not a handler
     of the proper size, or the io is not aligned, it will simulate the io
     to the normal io handlers.

Arguments:

    VdmIoHandler -- Supplies a pointer to the handler table
    Context -- Supplies 32 bits of data set when the port was trapped
    PortNumber -- Supplies the port number the IO was done to
    Size -- Supplies the size of the IO operation.
    Count -- Supplies the number of IO operations.
    Read -- Indicates whether the IO operation was a read or a write.
    Data -- Supplies a segmented address at which to put the result.

Return Value:

    True if one or more handlers were called to take care of the IO.
    False if no handler was called to take care of the IO.

--*/

{
    BOOLEAN Success = FALSE;
    USHORT FnIndex;
    NTSTATUS Status;

    if (Read) {
        FnIndex = 0;
    } else {
        FnIndex = 1;
    }

    Status = KeWaitForSingleObject(
        &VdmStringIoMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    switch (Size) {
    case 1:
        Success = VdmCallStringIoHandler(
            VdmIoHandler,
            (PVOID)VdmIoHandler->IoFunctions[FnIndex].UcharStringIo[PortNumber % 4],
            Context,
            PortNumber,
            Size,
            Count,
            Read,
            Data
            );
        break;

    case 2:
        Success = VdmCallStringIoHandler(
            VdmIoHandler,
            (PVOID)VdmIoHandler->IoFunctions[FnIndex].UshortStringIo[PortNumber % 2],
            Context,
            PortNumber,
            Size,
            Count,
            Read,
            Data
            );
        break;

    case 4:
        Success = VdmCallStringIoHandler(
            VdmIoHandler,
            (PVOID)VdmIoHandler->IoFunctions[FnIndex].UlongStringIo,
            Context,
            PortNumber,
            Size,
            Count,
            Read,
            Data
            );
        break;

    }
    KeReleaseMutex(&VdmStringIoMutex, FALSE);
    return Success;
}

#define STRINGIO_BUFFER_SIZE 1024
UCHAR VdmStringIoBuffer[STRINGIO_BUFFER_SIZE];

BOOLEAN
VdmCallStringIoHandler(
    IN PVDM_IO_HANDLER VdmIoHandler,
    IN PVOID StringIoRoutine,
    IN ULONG Context,
    IN ULONG PortNumber,
    IN ULONG Size,
    IN ULONG Count,
    IN BOOLEAN Read,
    IN ULONG Data
    )

/*++

Routine Description:

    This routine actually performs the call to string io routine.  It takes
    care of buffering the user data in kernel space so that the device driver
    does not have to.  If there is not a string io function, or the io is
    misaligned, it will be simulated as a series of normal io operations

Arguments:

    StringIoRoutine -- Supplies a pointer to the string Io routine
    Context -- Supplies 32 bits of data set when the port was trapped
    PortNumber -- Supplies the number of the port to perform Io to
    Size -- Supplies the size of the io operations
    Count -- Supplies the number of Io operations in the string.
    Read -- Indicates a read operation
    Data -- Supplies a pointer to the user buffer to perform the io on.

Returns

    TRUE if a handler was called
    FALSE if not.

--*/

{
    ULONG TotalBytes,BytesDone,BytesToDo,LoopCount,NumberIo;
    PUCHAR CurrentDataPtr;
    UCHAR AccessType;
    EXCEPTION_RECORD ExceptionRecord;
    NTSTATUS Status;
    BOOLEAN Success;

    Success = VdmConvertToLinearAddress(
        Data,
        &CurrentDataPtr
        );

    if (!Success) {
        ExceptionRecord.ExceptionCode = STATUS_ACCESS_VIOLATION;
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.NumberParameters = 0;
        ExRaiseException(&ExceptionRecord);
        // Cause kernel exit, rather than Io reflection
        return TRUE;
    }


    TotalBytes = Count * Size;
    BytesDone = 0;

    if (PortNumber % Size) {
        StringIoRoutine = NULL;
    }

    if (Read) {
        AccessType = EMULATOR_READ_ACCESS;
    } else {
        AccessType = EMULATOR_WRITE_ACCESS;
    }


    // Set up try out here to avoid overhead in loop
    try {
        while (BytesDone < TotalBytes) {
            if ((BytesDone + STRINGIO_BUFFER_SIZE) > TotalBytes) {
                BytesToDo = TotalBytes - BytesDone;
            } else {
                BytesToDo = STRINGIO_BUFFER_SIZE;
            }

            ASSERT((!(BytesToDo % Size)));

            if (!Read) {
                RtlCopyMemory(VdmStringIoBuffer, CurrentDataPtr, BytesToDo);
            }

            NumberIo = BytesToDo / Size;

            if (StringIoRoutine) {
                // in order to avoid having 3 separate calls, one for each size
                // we simply cast the parameters appropriately for the
                // byte routine.

                Status = (*((PDRIVER_IO_PORT_UCHAR_STRING)StringIoRoutine))(
                    Context,
                    PortNumber,
                    AccessType,
                    VdmStringIoBuffer,
                    NumberIo
                    );

                if (NT_SUCCESS(Status)) {
                    Success |= TRUE;
                }
            } else {
                if (PortNumber % Size) {
                    for (LoopCount = 0; LoopCount < NumberIo; LoopCount++ ) {
                        Success |= VdmDispatchUnalignedIoToHandler(
                            VdmIoHandler,
                            Context,
                            PortNumber,
                            Size,
                            Read,
                            (PULONG)(VdmStringIoBuffer + LoopCount * Size)
                            );
                    }
                } else {
                    for (LoopCount = 0; LoopCount < NumberIo; LoopCount++ ) {
                        Success |= VdmDispatchIoToHandler(
                            VdmIoHandler,
                            Context,
                            PortNumber,
                            Size,
                            Read,
                            (PULONG)(VdmStringIoBuffer + LoopCount * Size)
                            );
                    }

                }
            }

            if (Read) {
                RtlCopyMemory(CurrentDataPtr, VdmStringIoBuffer, BytesToDo);
            }

            BytesDone += BytesToDo;
            CurrentDataPtr += BytesToDo;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ExceptionRecord.ExceptionCode = GetExceptionCode();
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.NumberParameters = 0;
        ExRaiseException(&ExceptionRecord);
        // Cause kernel exit, rather than Io reflection
        Success = TRUE;
    }
    return Success;

}

BOOLEAN
VdmConvertToLinearAddress(
    IN ULONG SegmentedAddress,
    OUT PVOID *LinearAddress
    )

/*++

Routine Description:

    This routine converts the specified segmented address into a linear
    address, based on processor mode in user mode.

Arguments:

    SegmentedAddress -- Supplies the segmented address to convert.
    LinearAddress -- Supplies a pointer to the destination for the
        coresponding linear address

Return Value:

    True if the address was converted.
    False otherwise

Note:

    A linear address of 0 is a valid return
--*/

{
    PKTHREAD Thread;
    PKTRAP_FRAME TrapFrame;
    BOOLEAN Success;
    ULONG Base, Limit, Flags;

    Thread = KeGetCurrentThread();
    TrapFrame = VdmGetTrapFrame(Thread);

    if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
        *LinearAddress = (PVOID)(((SegmentedAddress & 0xFFFF0000) >> 12) +
            (SegmentedAddress & 0xFFFF));
        Success = TRUE;
    } else {
        Success = Ki386GetSelectorParameters(
            (USHORT)((SegmentedAddress & 0xFFFF0000) >> 16),
            &Flags,
            &Base,
            &Limit
            );
        if (Success) {
            *LinearAddress = (PVOID)(Base + (SegmentedAddress & 0xFFFF));
        }
    }
    return Success;
}

VOID
KeI386VdmInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the vdm stuff

Arguments:

    None

Return Value:

    None
--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE RegistryHandle = NULL;
    UNICODE_STRING WorkString;
    UCHAR KeyInformation[sizeof(KEY_VALUE_BASIC_INFORMATION) + 30];
    ULONG ResultLength;

    KeInitializeMutex( &VdmStringIoMutex, MUTEX_LEVEL_VDM_IO );

    //
    // Set up and open KeyPath to wow key
    //

    RtlInitUnicodeString(
        &WorkString,
        L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Wow"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    Status = ZwOpenKey(
        &RegistryHandle,
        KEY_READ,
        &ObjectAttributes
        );

    //
    // If there is no Wow key, don't allow Vdms to run
    //
    if (!NT_SUCCESS(Status)) {
        return;
    }

    //
    // Set up for using virtual interrupt extensions if they are available
    //

    //
    // Get the Pentium Feature disable value.
    // If this value is present, don't enable vme stuff.
    //
    RtlInitUnicodeString(
        &WorkString,
        L"DisableVme"
        );

    Status = ZwQueryValueKey(
        RegistryHandle,
        &WorkString,
        KeyValueBasicInformation,
        &KeyInformation,
        sizeof(KEY_VALUE_BASIC_INFORMATION) + 30,
        &ResultLength
        );

    if (!NT_SUCCESS(Status)) {

        //
        // If we have the extensions, set the appropriate bits
        // in cr4
        //
        if (KeFeatureBits & KF_V86_VIS) {
            KiIpiGenericCall(
                Ki386VdmEnablePentiumExtentions,
                TRUE
                );
            KeI386VirtualIntExtensions = V86_VIRTUAL_INT_EXTENSIONS;
        }
    }

    //
    // If we have V86 mode int extensions, we don't want to run with
    // IOPL in v86 mode
    //
    if (!(KeI386VirtualIntExtensions & V86_VIRTUAL_INT_EXTENSIONS)) {
        //
        // Read registry to determine if Vdms will run with IOPL in v86 mode
        //

        //
        // Get the VdmIOPL value.
        //
        RtlInitUnicodeString(
            &WorkString,
            L"VdmIOPL"
            );

        Status = ZwQueryValueKey(
            RegistryHandle,
            &WorkString,
            KeyValueBasicInformation,
            &KeyInformation,
            sizeof(KEY_VALUE_BASIC_INFORMATION) + 30,
            &ResultLength
            );

        //
        // If the value exists, let Vdms run with IOPL in V86 mode
        //
        if (NT_SUCCESS(Status)) {
            //
            // KeEflagsAndMaskV86 and KeEflagsOrMaskV86 are used
            // in SANITIZE_FLAGS, and the Vdm code to make sure the
            // values in EFlags for v86 mode trap frames are acceptable
            //
            KeI386EFlagsAndMaskV86 = EFLAGS_USER_SANITIZE | EFLAGS_INTERRUPT_MASK;
            KeI386EFlagsOrMaskV86 = EFLAGS_IOPL_MASK;

            //
            // KeVdmIoplAllowed is used by the Vdm code to determine if
            // the virtual interrupt flag is in EFlags, or 40:xx
            //
            KeI386VdmIoplAllowed = TRUE;

        }
    }

    ZwClose(RegistryHandle);
}

BOOLEAN
KeVdmInsertQueueApc (
    IN PKAPC             Apc,
    IN PKTHREAD          Thread,
    IN KPROCESSOR_MODE   ApcMode,
    IN PKKERNEL_ROUTINE  KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
    IN PKNORMAL_ROUTINE  NormalRoutine OPTIONAL,
    IN PVOID             NormalContext OPTIONAL,
    IN KPRIORITY         Increment
    )

/*++

Routine Description:

    This function initializes and queues a vdm type of APC to the specified
    target thread.

    A Vdm type of APC:
       - OriginalApcEnvironment
       - will only be queued to one thread at a time
       - if UserMode Fires on the next system exit. A UserMode apc should
         not be queued if the current vdm context is not application mode.

    N.B. The delay interrupt lock must be held when this routine is called
         to ensure that no other processor attempts to queue or requeue the
         same APC.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    Thread - Supplies a pointer to a dispatcher object of type thread.

    ApcMode - Supplies the processor mode user\kernel of the Apc

    KernelRoutine - Supplies a pointer to a function that is to be
        executed at IRQL APC_LEVEL in kernel mode.

    RundownRoutine - Supplies an optional pointer to a function that is to be
        called if the APC is in a thread's APC queue when the thread terminates.

    NormalRoutine - Supplies an optional pointer to a function that is
        to be executed at IRQL 0 in the specified processor mode. If this
        parameter is not specified, then the ProcessorMode and NormalContext
        parameters are ignored.

    NormalContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the NormalRoutine parameter.

    Increment - Supplies the priority increment that is to be applied if
        queuing the APC causes a thread wait to be satisfied.


Return Value:

    If APC queuing is disabled, then a value of FALSE is returned.
    Otherwise a value of TRUE is returned.


--*/

{

    PKAPC_STATE ApcState;
    PKTHREAD ApcThread;
    KLOCK_QUEUE_HANDLE LockHandle;
    BOOLEAN Inserted;

    //
    // If the apc object not initialized, then initialize it and acquire
    // the target thread APC queue lock.
    //

    if (Apc->Type != ApcObject) {
        Apc->Type = ApcObject;
        Apc->Size = sizeof(KAPC);
        Apc->ApcStateIndex  = OriginalApcEnvironment;

    } else {

        //
        // Acquire the APC thread APC queue lock, raise IRQL to SYNCH_LEVEL,
        // and lock the dispatcher database.
        //
        // If the APC is inserted in the corresponding APC queue, and the
        // APC thread is not the same thread as the target thread, then
        // the APC is removed from its current queue, the APC pending state
        // is updated, the APC thread APC queue lock is released, and the
        // target thread APC queue lock is acquired. Otherwise, the APC
        // thread and the target thread are same thread and the APC is already
        // queued to the correct thread.
        //
        // If the APC is not inserted in an APC queue, then release the
        // APC thread APC queue lock and acquire the target thread APC queue
        // lock.
        //

        ApcThread = Apc->Thread;
        if (ApcThread) {
            KeAcquireInStackQueuedSpinLockRaiseToSynch(&ApcThread->ApcQueueLock,
                                                       &LockHandle);

            KiLockDispatcherDatabaseAtSynchLevel();
            if (Apc->Inserted) {
                if (ApcThread == Apc->Thread && Apc->Thread != Thread) {
                    Apc->Inserted = FALSE;
                    RemoveEntryList(&Apc->ApcListEntry);
                    ApcState = Apc->Thread->ApcStatePointer[Apc->ApcStateIndex];
                    if (IsListEmpty(&ApcState->ApcListHead[Apc->ApcMode]) != FALSE) {
                        if (Apc->ApcMode == KernelMode) {
                            ApcState->KernelApcPending = FALSE;

                        } else {
                            ApcState->UserApcPending = FALSE;
                        }
                    }

                } else {
                    KiUnlockDispatcherDatabaseFromSynchLevel();
                    KeReleaseInStackQueuedSpinLock(&LockHandle);
                    return TRUE;
                }
            }

            KiUnlockDispatcherDatabaseFromSynchLevel();
            KeReleaseInStackQueuedSpinLock(&LockHandle);
        }
    }

    Apc->ApcMode = ApcMode;
    Apc->Thread  = Thread;
    Apc->KernelRoutine   = KernelRoutine;
    Apc->RundownRoutine  = RundownRoutine;
    Apc->NormalRoutine   = NormalRoutine;
    Apc->SystemArgument1 = NULL;
    Apc->SystemArgument2 = NULL;
    Apc->NormalContext   = NormalContext;

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and lock
    // the dispatcher database.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // If APC queuing is enable, then attempt to queue the APC object.
    //

    if (Thread->ApcQueueable && KiInsertQueueApc(Apc, Increment)) {
        Inserted = TRUE;

        //
        // If UserMode:
        //    For vdm a UserMode Apc is only queued by a kernel mode
        //    apc which is on the current thread for the target thread.
        //    Force UserApcPending for User mode apcstate, so that
        //    the apc will fire when this thread exits the kernel.
        //

        if (ApcMode == UserMode) {
            KiBoostPriorityThread(Thread, Increment);
            Thread->ApcState.UserApcPending = TRUE;
        }

    } else {
        Inserted = FALSE;
    }

    //
    // Unlock the dispatcher database from SYNCH_LEVEL, unlock the thread APC
    // queue lock and lower IRQL to its previous value, and return whether the
    // APC object was inserted.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return Inserted;
}

#define AD_MASK             0x04    // adlib register used to control opl2

VOID
Ki386AdlibEmulation(
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Read,
    IN UCHAR InstructionSize,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine performs kernel mode adlib emulation.

    Note, here we only do SB2.0 adlib emulation.  That means the only IO ports
    that we emulatated are 0x388, 0x389 and 0x2x8 and 0x2x9.

Arguments:

    PortNumber -- Supplies the port number the IO was done to
    Size -- Supplies the size of the IO operation.
    Read -- Indicates whether the IO operation was a read or a write.
    InstructionSize -- Supplies the size of the IO instruction in bytes.

Return Value:

    None.

--*/

{
    PVDM_PROCESS_OBJECTS pVdmObjects = PsGetCurrentProcess()->VdmObjects;
    PUCHAR pData = (PUCHAR)&TrapFrame->Eax;

    if (Read) {

        //
        // Must be read status
        //

        *pData = (UCHAR)pVdmObjects->AdlibStatus;
    } else {

        //
        // Could be write adlib index register or write actual data
        //

        if ((PortNumber & 0xf) == 0x8) {

            //
            // It's adlib register select
            //

            pVdmObjects->AdlibIndexRegister = (USHORT)*pData;

        } else {

            //
            // It's adlib data write.  We don't actually write any data out.
            // But we will emulate the status change.
            //

            UCHAR data = *pData;

            if ((pVdmObjects->AdlibIndexRegister >= 0xB0 &&
                 pVdmObjects->AdlibIndexRegister <= 0xBD) ||
                 pVdmObjects->AdlibIndexRegister == AD_MASK) {

                if (pVdmObjects->AdlibIndexRegister == AD_MASK) {
                    // Look for RST and starting timers
                    if (data & 0x80) {
                        pVdmObjects->AdlibStatus = 0x00; // reset both timers
                    }
                }

                //
                // We ignore starting of timers if their interrupt
                // flag is set because the timer status will have to
                // be set again to make the status for this timer change
                //

                if ((data & 1) && !(pVdmObjects->AdlibStatus & 0x40)) {

                    //
                    // simulate immediate expiry of timer1
                    //

                    pVdmObjects->AdlibStatus |= 0xC0;
                }

                if ((data & 2) && !(pVdmObjects->AdlibStatus & 0x20)) {

                    //
                    // simulate immediate expiry of timer2
                    //

                    pVdmObjects->AdlibStatus |= 0xA0;
                }

            }

        }
    }
}

VOID
Ki386AdlibDirectIo (
    IN ULONG PortNumber,
    IN ULONG Size,
    IN BOOLEAN Read,
    IN UCHAR InstructionSize,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine performs direct IO for user mode program.

Arguments:

    PortNumber -- Supplies the port number the IO was done to
    Size -- Supplies the size of the IO operation.
    Read -- Indicates whether the IO operation was a read or a write.
    InstructionSize -- Supplies the size of the IO instruction in bytes.

Return Value:

    None.

--*/

{
    PUCHAR pData = (PUCHAR)&TrapFrame->Eax;

    if (Read) {
        *pData = READ_PORT_UCHAR((PUCHAR)PortNumber);
    } else {
        WRITE_PORT_UCHAR((PUCHAR)PortNumber, *pData);
    }
}

//
//  END of ACTIVE CODE
//

#if VDM_IO_TEST
NTSTATUS
TestIoByteRoutine(
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUCHAR Data
    )
{
    if (AccessMode & EMULATOR_READ_ACCESS) {
        *Data = Port - 400;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
TestIoWordReadRoutine(
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUSHORT Data
    )
{
    if (AccessMode & EMULATOR_READ_ACCESS) {
        *Data = Port - 200;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
TestIoWordWriteRoutine(
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUSHORT Data
    )
{
    DbgPrint("Word Write routine port # %lx, %x\n",Port,*Data);

    return STATUS_SUCCESS;
}

NTSTATUS
TestIoDwordRoutine(
    IN ULONG Port,
    IN USHORT AccessMode,
    IN OUT PULONG Data
    )
{
    if (AccessMode & EMULATOR_READ_ACCESS) {
        *Data = Port;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
TestIoStringRoutine(
    IN ULONG Port,
    IN USHORT AccessMode,
    IN OUT PSHORT Data,
    IN ULONG Count
    )
{
    ULONG i;

    if (AccessMode & EMULATOR_READ_ACCESS) {
        for (i = 0;i < Count ;i++ ) {
            Data[i] = i;
        }
    } else {
        DbgPrint("String Port Called for write port #%lx,",Port);
        for (i = 0;i < Count ;i++ ) {
            DbgPrint("%x\n",Data[i]);
        }
    }

    return STATUS_SUCCESS;
}

PROCESS_IO_PORT_HANDLER_INFORMATION IoPortHandler;
EMULATOR_ACCESS_ENTRY Entry[4];
BOOLEAN Connect = TRUE, Disconnect = FALSE;

VOID
TestIoHandlerStuff(
    VOID
    )
{
    NTSTATUS Status;

    IoPortHandler.Install = TRUE;
    IoPortHandler.NumEntries = 5L;
    IoPortHandler.EmulatorAccessEntries = Entry;

    Entry[0].BasePort = 0x400;
    Entry[0].NumConsecutivePorts = 0x30;
    Entry[0].AccessType = Uchar;
    Entry[0].AccessMode = EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS;
    Entry[0].StringSupport = FALSE;
    Entry[0].Routine = TestIoByteRoutine;

    Entry[1].BasePort = 0x400;
    Entry[1].NumConsecutivePorts = 0x18;
    Entry[1].AccessType = Ushort;
    Entry[1].AccessMode = EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS;
    Entry[1].StringSupport = FALSE;
    Entry[1].Routine = TestIoWordReadRoutine;

    Entry[2].BasePort = 0x400;
    Entry[2].NumConsecutivePorts = 0xc;
    Entry[2].AccessType = Ulong;
    Entry[2].AccessMode = EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS;
    Entry[2].StringSupport = FALSE;
    Entry[2].Routine = TestIoDwordRoutine;

    Entry[3].BasePort = 0x400;
    Entry[3].NumConsecutivePorts = 0x18;
    Entry[3].AccessType = Ushort;
    Entry[3].AccessMode = EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS;
    Entry[3].StringSupport = TRUE;
    Entry[3].Routine = TestIoStringRoutine;

     if (Connect) {
        Status = ZwSetInformationProcess(
            NtCurrentProcess(),
            ProcessIoPortHandlers,
            &IoPortHandler,
            sizeof(PROCESS_IO_PORT_HANDLER_INFORMATION)
            ) ;
        if (!NT_SUCCESS(Status)) {
            DbgBreakPoint();
        }
        Connect = FALSE;
    }

    IoPortHandler.Install = FALSE;
    if (Disconnect) {
        Status = ZwSetInformationProcess(
            NtCurrentProcess(),
            ProcessIoPortHandlers,
            &IoPortHandler,
            sizeof(PROCESS_IO_PORT_HANDLER_INFORMATION)
            );
        if (!NT_SUCCESS(Status)) {
            DbgBreakPoint();
        }
        Disconnect = FALSE;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\vdmp.h ===
#define VDM_APP_MODE            0x00000001L
#define VDM_INTERRUPT_PENDING   0x00000002L
#define VDM_STATE_CHANGE        0x00000004L
#define VDM_VIRTUAL_INTERRUPTS  0x00000200L
#define VDM_PE_MASK             0x80000000L

typedef enum _VdmEventClass {
    VdmIO,
    VdmStringIO,
    VdmMemAccess,
    VdmIntAck,
    VdmBop,
    VdmError,
    VdmIrq13
} VDMEVENTCLASS, *PVDMEVENTCLASS;

typedef struct _VdmIoInfo {
    USHORT PortNumber;
    USHORT Size;
    BOOLEAN Read;
} VDMIOINFO, *PVDMIOINFO;

typedef struct _VdmStringIoInfo {
    USHORT PortNumber;
    USHORT Size;
    BOOLEAN Read;
    ULONG Count;
    ULONG Address;
} VDMSTRINGIOINFO, *PVDMSTRINGIOINFO;

typedef ULONG VDMBOPINFO;
typedef NTSTATUS VDMERRORINFO;

typedef struct _VdmEventInfo {
    ULONG Size;
    VDMEVENTCLASS Event;
    ULONG InstructionSize;
    union {
        VDMIOINFO IoInfo;
        VDMSTRINGIOINFO StringIoInfo;
        VDMBOPINFO BopNumber;
        VDMERRORINFO ErrorStatus;
    };
} VDMEVENTINFO, *PVDMEVENTINFO;

typedef struct _Vdm_InterruptHandler {
    USHORT  CsSelector;
    ULONG   Eip;
    USHORT  SsSelector;
    ULONG   Esp;
} VDM_INTERRUPTHANDLER, *PVDM_INTERRUPTHANDLER;

typedef struct _Vdm_Tib {
    ULONG Size;
    ULONG Flags;
    VDM_INTERRUPTHANDLER VdmInterruptHandlers[255];
    CONTEXT MonitorContext;
    CONTEXT VdmContext;
    VDMEVENTINFO EventInfo;
} VDM_TIB, *PVDM_TIB;

NTSTATUS
NtStartVdmExecution(
    );

// Flags that don't belong here

#define SEL_TYPE_READ       0x00000001
#define SEL_TYPE_WRITE      0x00000002
#define SEL_TYPE_EXECUTE    0x00000004
#define SEL_TYPE_BIG        0x00000008
#define SEL_TYPE_ED         0x00000010
#define SEL_TYPE_2GIG       0x00000020
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\alignem.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    alignem.c

Abstract:

    This module implement the code necessary to emulate unaliged data
    references.

Author:

    David N. Cutler (davec) 17-Jun-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#define OPCODE_MASK      0x1EF00000000

#define LD_OP            0x08000000000 
#define LDS_OP           0x08100000000
#define LDA_OP           0x08200000000
#define LDSA_OP          0x08300000000
#define LDBIAS_OP        0x08400000000
#define LDACQ_OP         0x08500000000
#define LDCCLR_OP        0x08800000000
#define LDCNC_OP         0x08900000000
#define LDCCLRACQ_OP     0x08A00000000
#define ST_OP            0x08C00000000
#define STREL_OP         0x08D00000000

#define LD_IMM_OP        0x0A000000000 
#define LDS_IMM_OP       0x0A100000000
#define LDA_IMM_OP       0x0A200000000
#define LDSA_IMM_OP      0x0A300000000
#define LDBIAS_IMM_OP    0x0A400000000
#define LDACQ_IMM_OP     0x0A500000000
#define LDCCLR_IMM_OP    0x0A800000000
#define LDCNC_IMM_OP     0x0A900000000
#define LDCCLRACQ_IMM_OP 0x0AA00000000
#define ST_IMM_OP        0x0AC00000000
#define STREL_IMM_OP     0x0AD00000000

#define LDF_OP           0x0C000000000
#define LDFS_OP          0x0C100000000
#define LDFA_OP          0x0C200000000
#define LDFSA_OP         0x0C300000000
#define LDFCCLR_OP       0x0C800000000
#define LDFCNC_OP        0x0C900000000
#define STF_OP           0x0CC00000000

#define LDF_IMM_OP       0x0E000000000
#define LDFS_IMM_OP      0x0E100000000
#define LDFA_IMM_OP      0x0E200000000
#define LDFSA_IMM_OP     0x0E300000000
#define LDFCCLR_IMM_OP   0x0E800000000
#define LDFCNC_IMM_OP    0x0E900000000
#define STF_IMM_OP       0x0EC00000000

typedef struct _INST_FORMAT {
    union {
        struct {
            ULONGLONG qp:   6;
            ULONGLONG r1:   7;
            ULONGLONG r2:   7;
            ULONGLONG r3:   7;
            ULONGLONG x:    1;
            ULONGLONG hint: 2;
            ULONGLONG x6:   6;
            ULONGLONG m:    1;
            ULONGLONG Op:   4;
            ULONGLONG Rsv: 23; 
        } i_field;
        ULONGLONG Ulong64;
    } u;
} INST_FORMAT;

VOID
KiEmulateLoad(
    IN PVOID UnalignedAddress,
    IN ULONG OperandSize,
    IN PVOID Data
    );

VOID
KiEmulateStore(
    IN PVOID UnalignedAddress,
    IN ULONG OperandSize,
    IN PVOID Data
    );

VOID
KiEmulateLoadFloat(
    IN PVOID UnalignedAddress,
    IN ULONG OperandSize,
    IN PVOID Data
    );

VOID
KiEmulateStoreFloat(
    IN PVOID UnalignedAddress,
    IN ULONG OperandSize,
    IN PVOID Data
    );

VOID
KiEmulateLoadFloat80(
    IN PVOID UnalignedAddress, 
    OUT PVOID FloatData
    );

VOID
KiEmulateLoadFloatInt(
    IN PVOID UnalignedAddress, 
    OUT PVOID FloatData
    );

VOID
KiEmulateLoadFloat32(
    IN PVOID UnalignedAddress, 
    OUT PVOID FloatData
    );

VOID
KiEmulateLoadFloat64(
    IN PVOID UnalignedAddress, 
    OUT PVOID FloatData
    );

VOID
KiEmulateStoreFloat80(
    IN PVOID UnalignedAddress, 
    OUT PVOID FloatData
    );

VOID
KiEmulateStoreFloatInt(
    IN PVOID UnalignedAddress, 
    OUT PVOID FloatData
    );

VOID
KiEmulateStoreFloat32(
    IN PVOID UnalignedAddress, 
    OUT PVOID FloatData
    );

VOID
KiEmulateStoreFloat64(
    IN PVOID UnalignedAddress, 
    OUT PVOID FloatData
    );


BOOLEAN
KiEmulateReference (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN OUT PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to emulate an unaligned data reference to an
    address in the user part of the address space.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    A value of TRUE is returned if the data reference is successfully
    emulated. Otherwise, a value of FALSE is returned.

--*/

{

    PVOID EffectiveAddress;
    PVOID ExceptionAddress;
    KIRQL  OldIrql;
    KPROCESSOR_MODE PreviousMode;
    INST_FORMAT FaultInstruction;
    ULONGLONG Opcode;
    ULONGLONG Reg2Value;
    ULONGLONG Reg3Value;
    ULONGLONG BundleLow;
    ULONGLONG BundleHigh;
    ULONGLONG Syllable;
    ULONGLONG Data = 0;
    ULONGLONG ImmValue;
    ULONG OpSize;
    ULONG Length;
    ULONG Sor;
    ULONG Rrbgr;
    ULONG Rrbfr;
    ULONG Operand1, Operand2, Operand3;
    FLOAT128 FloatData = {0, 0};

    //
    // Must flush the RSE to synchronize the RSE and backing store contents
    //

    KiFlushRse();

    if (TrapFrame->PreviousMode == UserMode) {
        KeFlushUserRseState(TrapFrame);
    }

    //
    // Call out to profile interrupt if alignment profiling is active
    //

    if (KiProfileAlignmentFixup) {

        if (++KiProfileAlignmentFixupCount >= KiProfileAlignmentFixupInterval) {

            KeRaiseIrql(PROFILE_LEVEL, &OldIrql);
            KiProfileAlignmentFixupCount = 0;
            KeProfileInterruptWithSource(TrapFrame, ProfileAlignmentFixup);
            KeLowerIrql(OldIrql);

        }
    }

    //
    // Save the original exception address in case another exception
    // occurs.
    //

    EffectiveAddress = (PVOID) ExceptionRecord->ExceptionInformation[1]; 
    ExceptionAddress = (PVOID) TrapFrame->StIIP;

    //
    // Capture previous mode from trap frame not current thread.
    //

    PreviousMode = (KPROCESSOR_MODE) TrapFrame->PreviousMode;

    //
    // Any exception that occurs during the attempted emulation of the
    // unaligned reference causes the emulation to be aborted. The new
    // exception code and information is copied to the original exception
    // record and a value of FALSE is returned.
    //

    try {


        BundleLow = *((ULONGLONG *)ExceptionAddress);
        BundleHigh = *(((ULONGLONG *)ExceptionAddress) + 1);

        Syllable = (TrapFrame->StIPSR >> PSR_RI) & 0x3;

        switch (Syllable) {
        case 0: 
            FaultInstruction.u.Ulong64 = (BundleLow >> 5);
            break;
        case 1:
            FaultInstruction.u.Ulong64 = (BundleLow >> 46) | (BundleHigh << 18);
            break;
        case 2:
            FaultInstruction.u.Ulong64 = (BundleHigh >> 23);
        case 3: 
        default: 
            return FALSE;
        }
    
        Rrbgr = (ULONG)(TrapFrame->StIFS >> 18) & 0x7f;
        Rrbfr = (ULONG)(TrapFrame->StIFS >> 25) & 0x7f;
        Sor = (ULONG)((TrapFrame->StIFS >> 14) & 0xf) * 8;
        Operand1 = (ULONG)FaultInstruction.u.i_field.r1;
        Operand2 = (ULONG)FaultInstruction.u.i_field.r2;
        Operand3 = (ULONG)FaultInstruction.u.i_field.r3;

        if (Sor > 0) {
            if ((Operand1 >= 32) && ((Operand1-32) < Sor))
                Operand1 = 32 + (Rrbgr + Operand1 - 32) % Sor;
            if ((Operand2 >= 32) && ((Operand2-32) < Sor))
                Operand2 = 32 + (Rrbgr + Operand2 - 32) % Sor;
            if ((Operand3 >= 32) && ((Operand3-32) < Sor))
                Operand3 = 32 + (Rrbgr + Operand3 - 32) % Sor;
        }

        Opcode = FaultInstruction.u.Ulong64 & OPCODE_MASK;
        OpSize = (ULONG)FaultInstruction.u.i_field.x6 & 0x3;

        switch (Opcode) {

        //    
        // speculative and speculative advanced load
        //

        case LDS_OP:
        case LDSA_OP:    
        case LDS_IMM_OP:
        case LDSA_IMM_OP:
        case LDFS_OP:
        case LDFSA_OP:
        case LDFS_IMM_OP:

            //
            // return NaT value to the target register
            //

            TrapFrame->StIPSR |= (1i64 << PSR_ED);

            return TRUE;

        //
        // normal, advance, and check load
        //

        case LD_OP:
        case LDA_OP:
        case LDBIAS_OP:
        case LDCCLR_OP:
        case LDCNC_OP:
        case LDACQ_OP:
        case LDCCLRACQ_OP:

            if (FaultInstruction.u.i_field.x == 1) {
                
                //
                // xField must be 0
                //

                return FALSE;
            }
    
            if( PreviousMode != KernelMode ){
                ProbeForRead( EffectiveAddress,
                              1 << OpSize,
                              sizeof(UCHAR) );
            }

            KiEmulateLoad(EffectiveAddress, OpSize, &Data);
            KiSetRegisterValue( Operand1, Data, ExceptionFrame, TrapFrame );

            if (FaultInstruction.u.i_field.m == 1) {

                //
                // Update the address register (R3)
                //
                
                Reg2Value = KiGetRegisterValue( Operand2, ExceptionFrame,
                                                TrapFrame );

                Reg3Value = KiGetRegisterValue( Operand3, ExceptionFrame,
                                                TrapFrame );

                //
                // register update form
                //

                Reg3Value = Reg2Value + Reg3Value;

                KiSetRegisterValue ( Operand3, Reg3Value, 
                                     ExceptionFrame, TrapFrame);
            }

            if ((Opcode == LDACQ_OP) || (Opcode == LDCCLRACQ_OP)) {

                //
                // all future access should occur after unaligned memory access
                //

                __mf();
            }

            break;

        //
        // normal, advance, and check load
        //     immidiate updated form
        //

        case LD_IMM_OP:
        case LDA_IMM_OP:
        case LDBIAS_IMM_OP:
        case LDCCLR_IMM_OP:
        case LDCNC_IMM_OP:
        case LDACQ_IMM_OP:
        case LDCCLRACQ_IMM_OP:

            if( PreviousMode != KernelMode ){
                ProbeForRead( EffectiveAddress,
                              1 << OpSize,
                              sizeof(UCHAR) );
            }

            KiEmulateLoad(EffectiveAddress, OpSize, &Data);
            KiSetRegisterValue( Operand1, Data, ExceptionFrame, TrapFrame );

            //
            // Update the address register R3
            //

            Reg3Value = KiGetRegisterValue(Operand3, ExceptionFrame, TrapFrame);

            //
            // immediate update form
            //

            ImmValue = (FaultInstruction.u.i_field.r2 
                             + (FaultInstruction.u.i_field.x << 7));

            if (FaultInstruction.u.i_field.m == 1) {

                ImmValue = 0xFFFFFFFFFFFFFF00i64 | ImmValue;

            } 

            Reg3Value = Reg3Value + ImmValue;

            KiSetRegisterValue(Operand3, Reg3Value, ExceptionFrame, TrapFrame);
            
            if ((Opcode == LDACQ_IMM_OP) || (Opcode == LDCCLRACQ_IMM_OP)) {

                //
                // all future access should occur after unaligned memory access
                //

                __mf();
            }

            break;

        case LDF_OP:
        case LDFA_OP:
        case LDFCCLR_OP:
        case LDFCNC_OP:

            if (Operand1 >= 32) Operand1 = 32 + (Rrbfr + Operand1 - 32) % 96;
            if (Operand2 >= 32) Operand2 = 32 + (Rrbfr + Operand2 - 32) % 96;
            if (Operand3 >= 32) Operand3 = 32 + (Rrbfr + Operand3 - 32) % 96;

            if (FaultInstruction.u.i_field.x == 1) {

                //
                // floating point load pair
                //

                if (FaultInstruction.u.i_field.m == 1) {

                    //
                    // m field must be zero
                    //

                    return FALSE;
                
                }

                if( PreviousMode != KernelMode ){

                    switch (OpSize) {
                    case 0: return FALSE;
                    case 1: Length = 8; break;
                    case 2: Length = 4; break;
                    case 3: Length = 8; break;
                    default: 
                        return FALSE;
                    }

                    ProbeForRead( EffectiveAddress,
                                  Length << 1,
                                  sizeof(UCHAR) );
                }

                //
                // emulate the 1st half of the pair
                //

                KiEmulateLoadFloat(EffectiveAddress, OpSize, &FloatData);
                KiSetFloatRegisterValue( Operand1, FloatData,
                                         ExceptionFrame, TrapFrame );

                //
                // emulate the 2nd half of the pair
                //

                EffectiveAddress = (PVOID)((ULONG_PTR)EffectiveAddress + Length);

                KiEmulateLoadFloat(EffectiveAddress, OpSize, &FloatData);
                KiSetFloatRegisterValue( Operand2, FloatData,
                                         ExceptionFrame, TrapFrame );

            } else {

                //
                // floating point single load
                //

                if( PreviousMode != KernelMode ){

                    switch (OpSize) {
                    case 0: Length = 16; break;
                    case 1: Length = 8; break;
                    case 2: Length = 4; break;
                    case 3: Length = 8; break;
                    default: 
                        return FALSE;
                    }

                    ProbeForRead( EffectiveAddress,
                                  Length,
                                  sizeof(UCHAR) );
                }

                KiEmulateLoadFloat(EffectiveAddress, OpSize, &FloatData);
                KiSetFloatRegisterValue( Operand1, FloatData,
                                         ExceptionFrame, TrapFrame );

                if (FaultInstruction.u.i_field.m == 1) {
                    
                    //
                    // update the address register (R3)
                    //

                    Reg2Value = KiGetRegisterValue( Operand2,
                                                    ExceptionFrame,
                                                    TrapFrame );
                
                    Reg3Value = KiGetRegisterValue( Operand3,
                                                    ExceptionFrame,
                                                    TrapFrame );
                    //
                    // register update form
                    //
                
                    Reg3Value = Reg2Value + Reg3Value;

                    KiSetRegisterValue (Operand3, Reg3Value,
                                        ExceptionFrame, TrapFrame);
                }
            }
                
            break;

        //    
        // normal, advanced and checked floating point load 
        //    immediate updated form
        //

        case LDF_IMM_OP:
        case LDFA_IMM_OP:
        case LDFCCLR_IMM_OP:
        case LDFCNC_IMM_OP:

            if (Operand1 >= 32) Operand1 = 32 + (Rrbfr + Operand1 - 32) % 96;
            if (Operand2 >= 32) Operand2 = 32 + (Rrbfr + Operand2 - 32) % 96;
            if (Operand3 >= 32) Operand3 = 32 + (Rrbfr + Operand3 - 32) % 96;

            if (FaultInstruction.u.i_field.x == 1) {

                //
                // floating point load pair
                //

                if (FaultInstruction.u.i_field.m == 0) {

                    //
                    // m field must be one
                    //

                    return FALSE;
                
                }

                if( PreviousMode != KernelMode ){

                    switch (OpSize) {
                    case 0: return FALSE;
                    case 1: Length = 8; break;
                    case 2: Length = 8; break;
                    case 3: Length = 4; break;
                    default: 
                        return FALSE;
                    }

                    ProbeForRead( EffectiveAddress,
                                  Length << 1,
                                  sizeof(UCHAR) );
                }

                //
                // emulate the 1st half of the pair
                //

                KiEmulateLoadFloat(EffectiveAddress, OpSize, &FloatData);
                KiSetFloatRegisterValue( Operand1, FloatData,
                                         ExceptionFrame, TrapFrame );

                EffectiveAddress = (PVOID)((ULONG_PTR)EffectiveAddress + Length);

                //
                // emulate the 2nd half of the pair
                //

                KiEmulateLoadFloat(EffectiveAddress, OpSize, &FloatData);
                KiSetFloatRegisterValue( Operand2,
                                         FloatData,
                                         ExceptionFrame,
                                         TrapFrame );

                //
                // Update the address register (R3)
                //

                Reg3Value = KiGetRegisterValue( Operand3,
                                                ExceptionFrame,
                                                TrapFrame );

                //
                // immediate update form
                //

                ImmValue = Length << 1;
                
                Reg3Value = Reg3Value + ImmValue;

                KiSetRegisterValue( Operand3, Reg3Value,
                                    ExceptionFrame, TrapFrame );

            } else {
                
                //
                // floating point single load
                // 

                if( PreviousMode != KernelMode ){
                    
                    switch (OpSize) {
                    case 0: Length = 16; break;
                    case 1: Length = 8; break;
                    case 2: Length = 4; break;
                    case 3: Length = 8; break;
                    default: 
                        return FALSE;
                    }

                    ProbeForRead( EffectiveAddress,
                                  Length,
                                  sizeof(UCHAR) );
                }
                KiEmulateLoadFloat(EffectiveAddress, OpSize, &FloatData);
                KiSetFloatRegisterValue( Operand1, FloatData,
                                         ExceptionFrame, TrapFrame );

                //
                // Update the address register (R3)
                //

                Reg3Value = KiGetRegisterValue( Operand3,
                                                ExceptionFrame,
                                                TrapFrame );

                //
                // immediate update form
                //

                ImmValue = (FaultInstruction.u.i_field.r2 
                             + (FaultInstruction.u.i_field.x << 7));

                if (FaultInstruction.u.i_field.m == 1) {

                    ImmValue = 0xFFFFFFFFFFFFFF00i64 | ImmValue;

                } 

                Reg3Value = Reg3Value + ImmValue;

                KiSetRegisterValue( Operand3, Reg3Value,
                                    ExceptionFrame, TrapFrame );
            }
             
            break;


        case STREL_OP:

             __mf();

        case ST_OP:

            if (FaultInstruction.u.i_field.x == 1) {
                
                //
                // xField must be 0
                //

                return FALSE;
            }

            if (FaultInstruction.u.i_field.m == 1) {

                //
                // no register update form defined
                //

                return FALSE;
            }
    
            if( PreviousMode != KernelMode ){
                ProbeForWrite( EffectiveAddress,
                               1 << OpSize,
                               sizeof(UCHAR) );
            }

            Data = KiGetRegisterValue( Operand2, ExceptionFrame, TrapFrame );
            KiEmulateStore( EffectiveAddress, OpSize, &Data);

            break;
            
        case STREL_IMM_OP:

            __mf();

        case ST_IMM_OP:

            if( PreviousMode != KernelMode ){
                ProbeForWrite( EffectiveAddress,
                               1 << OpSize,
                               sizeof(UCHAR) );
            }

            Data = KiGetRegisterValue( Operand2, ExceptionFrame, TrapFrame );
            KiEmulateStore( EffectiveAddress, OpSize, &Data);

            //
            // update the address register (R3)
            //

            Reg3Value = KiGetRegisterValue(Operand3, ExceptionFrame, TrapFrame);

            //
            // immediate update form
            //

            ImmValue = (FaultInstruction.u.i_field.r1 
                             + (FaultInstruction.u.i_field.x << 7));

            if (FaultInstruction.u.i_field.m == 1) {

                ImmValue = 0xFFFFFFFFFFFFFF00i64 | ImmValue;

            } 

            Reg3Value = Reg3Value + ImmValue;

            KiSetRegisterValue(Operand3, Reg3Value, ExceptionFrame, TrapFrame);
            
            break;
            

        case STF_OP:    
    
            if (FaultInstruction.u.i_field.x) {

                //
                // x field must be 0 
                //

                return FALSE;
            }

            if (FaultInstruction.u.i_field.m) {

                //
                // no register update form defined
                //

                return FALSE;
            }

            if( PreviousMode != KernelMode ){

                switch (OpSize) {
                case 0: Length = 16; break;
                case 1: Length = 8; break;
                case 2: Length = 4; break;
                case 3: Length = 8; break;
                default: 
                    return FALSE;
                }
                
                ProbeForWrite( EffectiveAddress,
                               Length,
                               sizeof(UCHAR) );
            }

            if (Operand2 >= 32) Operand2 = 32 + (Rrbfr + Operand2 - 32) % 96;
            FloatData = KiGetFloatRegisterValue(Operand2,
                                                ExceptionFrame,
                                                TrapFrame);
            KiEmulateStoreFloat( EffectiveAddress, OpSize, &FloatData);

            break;
            
        case STF_IMM_OP:    

            if( PreviousMode != KernelMode ){

                switch (OpSize) {
                case 0: Length = 16; break;
                case 1: Length = 8; break;
                case 2: Length = 4; break;
                case 3: Length = 8; break;
                default: 
                    return FALSE;
                }
                
                ProbeForWrite( EffectiveAddress,
                               Length,
                               sizeof(UCHAR) );
            }

            if (Operand2 >= 32) Operand2 = 32 + (Rrbfr + Operand2 - 32) % 96;
            FloatData = KiGetFloatRegisterValue(Operand2,
                                                ExceptionFrame,
                                                TrapFrame);
            KiEmulateStoreFloat( EffectiveAddress, OpSize, &FloatData);

            //
            // update the address register (R3)
            //

            if (Operand3 >= 32) Operand3 = 32 + (Rrbfr + Operand3 - 32) % 96;
            Reg3Value = KiGetRegisterValue(Operand3, ExceptionFrame, TrapFrame);

            //
            // immediate update form
            //

            ImmValue = (FaultInstruction.u.i_field.r1 
                             + (FaultInstruction.u.i_field.x << 7));

            if (FaultInstruction.u.i_field.m == 1) {

                ImmValue = 0xFFFFFFFFFFFFFF00i64 | ImmValue;

            }

            Reg3Value = Reg3Value + ImmValue;

            KiSetRegisterValue(Operand3, Reg3Value, ExceptionFrame, TrapFrame);
            
            break;
            
        default:

            return FALSE;

        }

        //
        // advance instruction pointer
        //

        KiAdvanceInstPointer(TrapFrame);

        return TRUE;

    //
    // If an exception occurs, then copy the new exception information to the
    // original exception record and handle the exception.
    //

    } except (KiCopyInformation(ExceptionRecord,
                               (GetExceptionInformation())->ExceptionRecord)) {

        //
        // Preserve the original exception address.
        //

        ExceptionRecord->ExceptionAddress = ExceptionAddress;
    }

    //
    // Return a value of FALSE.
    //

    return FALSE;
}


VOID
KiEmulateLoad(
    IN PVOID UnalignedAddress,
    IN ULONG OperandSize,
    IN PVOID Data
    )

/*++

Routine Description:

    This routine returns the integer value stored at the unaligned
    address passed in UnalignedAddress.

Arguments:

    UnalignedAddress - Supplies a pointer to data value.

    OperandSize - Supplies the size of data to be loaded

    Data - Supplies a pointer to be filled for data
   
Return Value:

    The value at the address pointed to by UnalignedAddress.

--*/

{
    PUCHAR Source;
    PUCHAR Destination;
    ULONG i;

    Source = (PUCHAR) UnalignedAddress; 
    Destination = (PUCHAR) Data;
    OperandSize = 1 << OperandSize; 

    for (i = 0; i < OperandSize; i++) {

        *Destination++ = *Source++;

    }

    return;
}


VOID
KiEmulateStore(
    IN PVOID UnalignedAddress,
    IN ULONG OperandSize,
    IN PVOID Data
    )
/*++

Routine Description:

    This routine store the integer value at the unaligned
    address passed in UnalignedAddress.

Arguments:

    UnalignedAddress - Supplies a pointer to be stored

    OperandSize - Supplies the size of data to be storeed

    Data - Supplies a pointer to data value
   
Return Value:

    The value at the address pointed to by UnalignedAddress.

--*/
{
    PUCHAR Source;
    PUCHAR Destination;
    ULONG i;

    Source = (PUCHAR) Data; 
    Destination = (PUCHAR) UnalignedAddress;
    OperandSize = 1 << OperandSize; 

    for (i = 0; i < OperandSize; i++) {

        *Destination++ = *Source++;

    }

    return;
}


VOID
KiEmulateLoadFloat(
    IN PVOID UnalignedAddress,
    IN ULONG OperandSize,
    IN OUT PVOID Data
    )

/*++

Routine Description:

    This routine returns the floating point value stored at the unaligned
    address passed in UnalignedAddress.

Arguments:

    UnalignedAddress - Supplies a pointer to floating point data value.

    OperandSize - Supplies the size of data to be loaded

    Data - Supplies a pointer to be filled for data
   
Return Value:

    The value at the address pointed to by UnalignedAddress.

--*/

{
    FLOAT128 FloatData;

    RtlCopyMemory(&FloatData, UnalignedAddress, sizeof(FLOAT128));

    switch (OperandSize) {

    case 0:
        KiEmulateLoadFloat80(&FloatData, Data);
        return;

    case 1:
        KiEmulateLoadFloatInt(&FloatData, Data);
        return;

    case 2:
        KiEmulateLoadFloat32(&FloatData, Data);
        return;

    case 3: 
        KiEmulateLoadFloat64(&FloatData, Data);
        return;

    default:
        return;
    }
}

VOID
KiEmulateStoreFloat(
    IN PVOID UnalignedAddress,
    IN ULONG OperandSize,
    IN PVOID Data
    )

/*++

Routine Description:

    This routine stores the floating point value stored at the unaligned
    address passed in UnalignedAddress.

Arguments:

    UnalignedAddress - Supplies a pointer to be stored.

    OperandSize - Supplies the size of data to be loaded

    Data - Supplies a pointer to floating point data
   
Return Value:

    The value at the address pointed to by UnalignedAddress.

--*/

{
    FLOAT128 FloatData;
    ULONG Length;

    switch (OperandSize) {

    case 0:
        KiEmulateStoreFloat80(&FloatData, Data);
        Length = 10;
        break;

    case 1:
        KiEmulateStoreFloatInt(&FloatData, Data);
        Length = 8;
        break;

    case 2:
        KiEmulateStoreFloat32(&FloatData, Data);
        Length = 4;
        break;

    case 3: 
        KiEmulateStoreFloat64(&FloatData, Data);
        Length = 8;
        break;

    default:
        return;
    }

    RtlCopyMemory(UnalignedAddress, &FloatData, Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\allproc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    allproc.c

Abstract:

    This module allocates and intializes kernel resources required
    to start a new processor, and passes a complete processor state
    structure to the HAL to obtain a new processor.

Author:

    Bernard Lint 31-Jul-96

Environment:

    Kernel mode only.

Revision History:

    Based on MIPS original (David N. Cutler 29-Apr-1993)

--*/


#include "ki.h"

#if defined(KE_MULTINODE)

NTSTATUS
KiNotNumaQueryProcessorNode(
    IN ULONG ProcessorNumber,
    OUT PUSHORT Identifier,
    OUT PUCHAR Node
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, KiNotNumaQueryProcessorNode)
#endif

#endif

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, KeStartAllProcessors)
#pragma alloc_text(INIT, KiAllProcessorsStarted)

#endif

//
// Define macro to round up to 64-byte boundary and define block sizes.
//

#define ROUND_UP(x) ((sizeof(x) + 63) & (~63))
#define BLOCK1_SIZE (2 * (KERNEL_BSTORE_SIZE + KERNEL_STACK_SIZE) + PAGE_SIZE)
#define BLOCK2_SIZE (ROUND_UP(KPRCB) + ROUND_UP(KNODE) + ROUND_UP(ETHREAD) + 64)

#if !defined(NT_UP)

//
// Define barrier wait static data.
//

ULONG KiBarrierWait = 0;

#endif

#if defined(KE_MULTINODE)

PHALNUMAQUERYPROCESSORNODE KiQueryProcessorNode = KiNotNumaQueryProcessorNode;

//
// Statically preallocate enough KNODE structures to allow MM
// to allocate pages by node during system initialization.  As
// processors are brought online, real KNODE structures are
// allocated in the appropriate memory for the node.
//
// This statically allocated set will be deallocated once the
// system is initialized.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#endif

KNODE KiNodeInit[MAXIMUM_PROCESSORS];

#endif

extern ULONG_PTR KiUserSharedDataPage;
extern ULONG_PTR KiKernelPcrPage;

//
// Define forward referenced prototypes.
//

VOID
KiCalibratePerformanceCounter(
    VOID
    );

VOID
KiCalibratePerformanceCounterTarget (
    IN PULONG SignalDone,
    IN PVOID Count,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiOSRendezvous (
    VOID
    );

VOID
KeStartAllProcessors(
    VOID
    )

/*++

Routine Description:

    This function is called during phase 1 initialize on the master boot
    processor to start all of the other registered processors.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    ULONG_PTR MemoryBlock1;
    ULONG_PTR MemoryBlock2;
    ULONG_PTR MemoryBlock3;
    ULONG_PTR PcrAddress;
    ULONG Number;
    ULONG Count;
    PHYSICAL_ADDRESS PcrPage;
    PKPRCB Prcb;
    BOOLEAN Started;
    KPROCESSOR_STATE ProcessorState;
    UCHAR NodeNumber = 0;
    USHORT ProcessorId;
    SIZE_T ProcessorDataSize;
    PKNODE Node;
    NTSTATUS Status;
    PKPCR NewPcr;

#if defined(KE_MULTINODE)

    //
    // In the unlikely event that processor 0 is not on node
    // 0, fix it.
    //


    if (KeNumberNodes > 1) {
        Status = KiQueryProcessorNode(0,
                                      &ProcessorId,
                                      &NodeNumber);

        if (NT_SUCCESS(Status)) {

            //
            // This should never fail.
            //

            if (NodeNumber != 0) {
                KeNodeBlock[0]->ProcessorMask &= ~1I64;
                KeNodeBlock[NodeNumber]->ProcessorMask |= 1;
                KeGetCurrentPrcb()->ParentNode = KeNodeBlock[NodeNumber];
            }
            KeGetCurrentPrcb()->ProcessorId = ProcessorId;
        }
    }

#endif

    //
    // If the registered number of processors is greater than the maximum
    // number of processors supported, then only allow the maximum number
    // of supported processors.
    //

    if (KeRegisteredProcessors > MAXIMUM_PROCESSORS) {
        KeRegisteredProcessors = MAXIMUM_PROCESSORS;
    }

    //
    // Set barrier that will prevent any other processor from entering the
    // idle loop until all processors have been started.
    //

    KiBarrierWait = 1;

    //
    // Initialize the processor state that will be used to start each of
    // processors. Each processor starts in the system initialization code
    // with address of the loader parameter block as an argument.
    //

    Number = 0;
    Count = 1;
    RtlZeroMemory(&ProcessorState, sizeof(KPROCESSOR_STATE));
    ProcessorState.ContextFrame.StIIP = ((PPLABEL_DESCRIPTOR)KiOSRendezvous)->EntryPoint;
    while (Count < KeRegisteredProcessors) {

        Number++;

        if (Number >= MAXIMUM_PROCESSORS) {
            break;
        }

#if defined(KE_MULTINODE)

        Status = KiQueryProcessorNode(Number,
                                      &ProcessorId,
                                      &NodeNumber);
        if (!NT_SUCCESS(Status)) {

            //
            // No such processor, advance to next.
            //

            continue;
        }

        Node = KeNodeBlock[NodeNumber];

#endif

        //
        // Allocate a DPC stack, an idle thread kernel stack, a panic
        // stack, a PCR page, a processor block,  a kernel node structure
        // and an executive thread object. If the allocation fails, stop
        // starting processors.
        //

#if 0
        //PLJTMP: Need to investigate which pieces need to be in KSEG0
        //and allocate the other stuff per node.  plus deal with any alignment
        //padding for the size below based on roundup of BLOCK1_SIZE.
        ProcessorDataSize = BLOCK1_SIZE + BLOCK2_SIZE;

        MemoryBlock1 = (ULONG_PTR)MmAllocateIndependentPages (ProcessorDataSize,
                                                            NodeNumber);
        if ((PVOID)MemoryBlock1 == NULL) {
            break;
        }

        MemoryBlock2 = MemoryBlock1 + BLOCK1_SIZE;

        //
        // Zero the allocated memory.
        //

        RtlZeroMemory((PVOID)MemoryBlock1, ProcessorDataSize);
#else
        MemoryBlock1 = (ULONG_PTR)ExAllocatePool(NonPagedPool, BLOCK1_SIZE);
        if ((PVOID)MemoryBlock1 == NULL) {
            break;
        }

        MemoryBlock2 = (ULONG_PTR)ExAllocatePool(NonPagedPool, BLOCK2_SIZE);
        if ((PVOID)MemoryBlock2 == NULL) {
            ExFreePool((PVOID)MemoryBlock1);
            break;
        }

        //
        // Zero both blocks of allocated memory.
        //

        RtlZeroMemory((PVOID)MemoryBlock1, BLOCK1_SIZE);
        RtlZeroMemory((PVOID)MemoryBlock2, BLOCK2_SIZE);

#endif

        //
        // Set address of idle thread kernel stack in loader parameter block.
        //

        KeLoaderBlock->KernelStack = MemoryBlock1 + KERNEL_STACK_SIZE;

        //
        // Set address of panic stack in loader parameter block.
        //

        KeLoaderBlock->u.Ia64.PanicStack = MemoryBlock1 + KERNEL_BSTORE_SIZE + 
                                                          (2 * KERNEL_STACK_SIZE);

        //
        // Set the address of the processor block and executive thread in the
        // loader parameter block.
        //

        KeLoaderBlock->Prcb = MemoryBlock2;
        KeLoaderBlock->Thread = KeLoaderBlock->Prcb + ROUND_UP(KPRCB) +
                                                      ROUND_UP(KNODE);
        ((PKPRCB)KeLoaderBlock->Prcb)->Number = (UCHAR)Number;

#if defined(KE_MULTINODE)

        //
        // If this is the first processor on this node, use the
        // space allocated for KNODE as the KNODE.
        //

        if (KeNodeBlock[NodeNumber] == &KiNodeInit[NodeNumber]) {
            Node = (PKNODE)(MemoryBlock1 + ROUND_UP(KPRCB));
            *Node = KiNodeInit[NodeNumber];
            KeNodeBlock[NodeNumber] = Node;
        }

        ((PKPRCB)KeLoaderBlock->Prcb)->ParentNode = Node;
        ((PKPRCB)KeLoaderBlock->Prcb)->ProcessorId = ProcessorId;

#else

        ((PKPRCB)KeLoaderBlock->Prcb)->ParentNode = KeNodeBlock[0];

#endif


        //
        // Set the page frame of the PCR page in the loader parameter block.
        //

        PcrAddress = MemoryBlock1 + (2 * (KERNEL_BSTORE_SIZE + KERNEL_STACK_SIZE));
        PcrPage = MmGetPhysicalAddress((PVOID)PcrAddress);
        KeLoaderBlock->u.Ia64.PcrPage = PcrPage.QuadPart >> PAGE_SHIFT;
        KeLoaderBlock->u.Ia64.PcrPage2 = KiUserSharedDataPage;
        KiKernelPcrPage = KeLoaderBlock->u.Ia64.PcrPage;

        //
        // Initialize the NT page table base addresses in PCR
        //

        NewPcr = (PKPCR) PcrAddress;
        NewPcr->PteUbase = PCR->PteUbase;
        NewPcr->PteKbase = PCR->PteKbase;
        NewPcr->PteSbase = PCR->PteSbase;
        NewPcr->PdeUbase = PCR->PdeUbase;
        NewPcr->PdeKbase = PCR->PdeKbase;
        NewPcr->PdeSbase = PCR->PdeSbase;
        NewPcr->PdeUtbase = PCR->PdeUtbase;
        NewPcr->PdeKtbase = PCR->PdeKtbase;
        NewPcr->PdeStbase = PCR->PdeStbase;

        //
        // Attempt to start the next processor. If attempt is successful,
        // then wait for the processor to get initialized. Otherwise,
        // deallocate the processor resources and terminate the loop.
        //

        Started = HalStartNextProcessor(KeLoaderBlock, &ProcessorState);

        if (Started) {

            //
            //  Wait for processor to initialize in kernel,
            //  then loop for another
            //

            while (*((volatile ULONG_PTR *) &KeLoaderBlock->Prcb) != 0) {
                KeYieldProcessor();
            }

#if defined(KE_MULTINODE)

            Node->ProcessorMask |= 1I64 << Number;

#endif

        } else {

#if 0
            MmFreeIndependentPages((PVOID)MemoryBlock1, ProcessorDataSize);
#else
            ExFreePool((PVOID)MemoryBlock1);
            ExFreePool((PVOID)MemoryBlock2);
#endif
            break;

        }

        Count += 1;
    }

    //
    // All processors have been stated.
    //

    KiAllProcessorsStarted();

    //
    // Allow all processor that were started to enter the idle loop and
    // begin execution.
    //

    KiBarrierWait = 0;

#endif

    //
    // Reset and synchronize the performance counters of all processors.
    //

    KiAdjustInterruptTime (0);
    return;
}

#if !defined(NT_UP)
VOID
KiAllProcessorsStarted(
    VOID
    )

/*++

Routine Description:

    This routine is called once all processors in the system
    have been started.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG i;

#if defined(KE_MULTINODE)

    //
    // Make sure there are no references to the temporary nodes
    // used during initialization.
    //

    for (i = 0; i < KeNumberNodes; i++) {
        if (KeNodeBlock[i] == &KiNodeInit[i]) {

            //
            // No processor started on this node so no new node
            // structure has been allocated.   This is possible
            // if the node contains only memory or IO busses.  At
            // this time we need to allocate a permanent node
            // structure for the node.
            //

            KeNodeBlock[i] = ExAllocatePoolWithTag(NonPagedPool,
                                                   sizeof(KNODE),
                                                   '  eK');
            if (KeNodeBlock[i]) {
                *KeNodeBlock[i] = KiNodeInit[i];
            }
        }
    }

    for (i = KeNumberNodes; i < MAXIMUM_CCNUMA_NODES; i++) {
        KeNodeBlock[i] = NULL;
    }

#endif

    if (KeNumberNodes == 1) {

        //
        // For Non NUMA machines, Node 0 gets all processors.
        //

        KeNodeBlock[0]->ProcessorMask = KeActiveProcessors;
    }
}
#endif


#if defined(KE_MULTINODE)

NTSTATUS
KiNotNumaQueryProcessorNode(
    IN ULONG ProcessorNumber,
    OUT PUSHORT Identifier,
    OUT PUCHAR Node
    )

/*++

Routine Description:

    This routine is a stub used on non NUMA systems to provide a 
    consistent method of determining the NUMA configuration rather
    than checking for the presense of multiple nodes inline.

Arguments:

    ProcessorNumber supplies the system logical processor number.
    Identifier      supplies the address of a variable to receive
                    the unique identifier for this processor.
    NodeNumber      supplies the address of a variable to receive
                    the number of the node this processor resides on.

Return Value:

    Returns success.

--*/

{
    *Identifier = (USHORT)ProcessorNumber;
    *Node = 0;
    return STATUS_SUCCESS;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\zero.asm ===
title  "Zero memory pages using fastest means available"
;++
;
; Copyright (c) 1998  Microsoft Corporation
;
; Module Name:
;
;    zero.asm
;
; Abstract:
;
;    Zero memory pages using the fastest means available.
;
; Author:
;
;    Peter Johnston (peterj) 20-Jun-1998.
;        Critical sections of Katmai code adapted from in-line
;        assembly version by Shiv Kaushik or Intel Corp.
;
; Environment:
;
;    x86
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc
include mac386.inc
        .list

;
; Register Definitions (for instruction macros).
;

rEAX            equ     0
rECX            equ     1
rEDX            equ     2
rEBX            equ     3
rESP            equ     4
rEBP            equ     5
rESI            equ     6
rEDI            equ     7

;
; Define SIMD instructions used in this module.
;

if 0

; these remain for reference only.   In theory the stuff following
; should generate the right code.

xorps_xmm0_xmm0 macro
                db      0FH, 057H, 0C0H
                endm

movntps_edx     macro   Offset
                db      0FH, 02BH, 042H, Offset
                endm

movaps_esp_xmm0 macro
                db      0FH, 029H, 004H, 024H
                endm

movaps_xmm0_esp macro
                db      0FH, 028H, 004H, 024H
                endm

endif

xorps           macro   XMMReg1, XMMReg2
                db      0FH, 057H, 0C0H + (XMMReg1 * 8) + XMMReg2
                endm

movntps         macro   GeneralReg, Offset, XMMReg
                db      0FH, 02BH, 040H + (XmmReg * 8) + GeneralReg, Offset
                endm

sfence          macro
                db      0FH, 0AEH, 0F8H
                endm

movaps_load     macro   XMMReg, GeneralReg
                db      0FH, 028H, (XMMReg * 8) + 4, (4 * 8) + GeneralReg
                endm

movaps_store    macro   GeneralReg, XMMReg
                db      0FH, 029H, (XMMReg * 8) + 4, (4 * 8) + GeneralReg
                endm


;
; NPX Save and Restore
;

fxsave          macro   Register
                db      0FH, 0AEH, Register
                endm

fxrstor         macro   Register
                db      0FH, 0AEH, 8+Register
                endm


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; KeZeroPage(
;    PageBase
;    )
;
; Routine Description:
;
;     KeZeroPage is really just a function pointer that points at
;     either KiZeroPage or KiXMMIZeroPage depending on whether or
;     not XMMI instructions are available.
;
; Arguments:
;
;     (ecx) PageBase    Base address of page to be zeroed.
;
;
; Return Value:
;
;--


        page    ,132
        subttl  "KiXMMIZeroPageNoSave - Use XMMI to zero memory (XMMI owned)"

;++
;
; VOID
; KiXMMIZeroPageNoSave (
;     IN PVOID PageBase
;     )
;
; Routine Description:
;
;     Use XMMI to zero a page of memory 16 bytes at a time while
;     at the same time minimizing cache polution.
;
;     Note: The XMMI register set belongs to this thread.  It is neither
;     saved nor restored by this procedure.
;
; Arguments:
;
;     (ecx) PageBase    Virtual address of the base of the page to be zeroed.
;
; Return Value:
;
;     None.
;
;--

INNER_LOOP_BYTES    equ 64

cPublicFastCall KiXMMIZeroPageNoSave,1
cPublicFpo 0, 1

        xorps   0, 0                            ; zero xmm0 (128 bits)
        mov     eax, PAGE_SIZE/INNER_LOOP_BYTES ; Number of Iterations

inner:

        movntps rECX, 0,  0                     ; store bytes  0 - 15
        movntps rECX, 16, 0                     ;             16 - 31
        movntps rECX, 32, 0                     ;             32 - 47
        movntps rECX, 48, 0                     ;             48 - 63

        add     ecx, 64                         ; increment base
        dec     eax                             ; decrement loop count
        jnz     short inner

        ; Force all stores to complete before any other
        ; stores from this processor.

        sfence

ifndef SFENCE_IS_NOT_BUSTED

        ; ERRATA the next uncached write to this processor's apic 
        ; may fail unless the store pipes have drained.  sfence by
        ; itself is not enough.   Force drainage now by doing an
        ; interlocked exchange.

        xchg    [esp-4], eax

endif

        fstRET  KiXMMIZeroPageNoSave

fstENDP KiXMMIZeroPageNoSave


        page    ,132
        subttl  "KiXMMIZeroPage - Use XMMI to zero memory"

;++
;
; VOID
; KiXMMIZeroPage (
;     IN PVOID PageBase
;     )
;
; Routine Description:
;
;     Use XMMI to zero a page of memory 16 bytes at a time.  This
;     routine is a wrapper around KiXMMIZeroPageNoSave.  In this
;     case we don't have the luxury of not saving/restoring context.
;
; Arguments:
;
;     (ecx) PageBase    Virtual address of the base of the page to be zeroed.
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KiXMMIZeroPage,1
cPublicFpo 0, 2

        mov     eax, PCR[PcInitialStack]
        mov     edx, PCR[PcPrcbData+PbCurrentThread]
        push    ebp
        push    ebx
        mov     ebp, esp                        ; save stack pointer
        sub     esp, 16                         ; reserve space for xmm0
        and     esp, 0FFFFFFF0H                 ; 16 byte aligned
        cli                                     ; don't context switch
        test    [eax].FpCr0NpxState, CR0_EM     ; if FP explicitly disabled
        jnz     short kxzp90                    ; do it the old way
        cmp     byte ptr [edx].ThNpxState, NPX_STATE_LOADED
        je      short kxzp80                    ; jiff, NPX stated loaded

        ; NPX state is not loaded on this thread, it will be by
        ; the time we reenable context switching.

        mov     byte ptr [edx].ThNpxState, NPX_STATE_LOADED

        ; enable use of FP instructions

        mov     ebx, cr0
        and     ebx, NOT (CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, ebx                        ; enable NPX

ifdef NT_UP

        ; if this is a UP machine, the state might be loaded for
        ; another thread in which case it needs to be saved.

        mov     ebx, PCR[PcPrcbData+PbNpxThread]; Owner of NPX state
        or      ebx, ebx                        ; NULL?
        jz      short @f                        ; yes, skip save.

        mov     byte ptr [ebx].ThNpxState, NPX_STATE_NOT_LOADED
        mov     ebx, [ebx].ThInitialStack       ; get address of save
        sub     ebx, NPX_FRAME_LENGTH           ; area.
        fxsave  rEBX                            ; save NPX
@@:

endif

        ; Now load the NPX context for this thread.  This is because
        ; if we switch away from this thread it will get saved again
        ; in this save area and destroying it would be bad.

        fxrstor rEAX

        mov     PCR[PcPrcbData+PbNpxThread], edx

kxzp80:
        sti                                     ; reenable context switching
        movaps_store rESP, 0                    ; save xmm0
        fstCall KiXMMIZeroPageNoSave            ; zero the page
        movaps_load  0, rESP                    ; restore xmm

        ; restore stack pointer, non-volatiles and return

        mov     esp, ebp
        pop     ebx
        pop     ebp
        fstRET  KiXMMIZeroPage


        ; FP is explicitly disabled for this thread (probably a VDM
        ; thread).  Restore stack pointer, non-volatiles and jump into
        ; KiZeroPage to do the work the old fashioned way.

kxzp90:
        sti
        mov     esp, ebp
        pop     ebx
        pop     ebp
        jmp     short @KiZeroPage@4

fstENDP KiXMMIZeroPage


        page    ,132
        subttl  "KiZeroPage - Available to all X86 processors"

;++
;
; KiZeroPage(
;     PVOID PageBase
;     )
;
; Routine Description:
;
;     Generic Zero Page routine, used on processors that don't have
;     a more effecient way to zero large blocks of memory.
;     (Same as RtlZeroMemory).
;
; Arguments:
;
;     (ecx) PageBase    Base address of page to be zeroed.
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KiZeroPage,1
cPublicFpo 0, 0

        push    edi                             ; save EDI (non-volatile)
        xor     eax, eax                        ; 32 bit zero
        mov     edi, ecx                        ; setup for repsto
        mov     ecx, PAGE_SIZE/4                ; iteration count

        ; store eax, ecx times starting at edi

        rep stosd

        pop     edi                             ; restore edi and return
        fstRET  KiZeroPage

fstENDP KiZeroPage


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\apcuser.c ===
/*++

Module Name:

    apcuser.c

Abstract:

    This module implements the machine dependent code necessary to initialize
    a user mode APC.

Author:

    William K. Cheung  26-Oct-1995

    based on MIPS version by David N. Cutler (davec) 23-Apr-1990

Environment:

    Kernel mode only, IRQL APC_LEVEL.

Revision History:

--*/

#include "ki.h"
#include "kxia64.h"

VOID
KiSaveHigherFPVolatile (
    PVOID
    );

VOID
KiInitializeUserApc (
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN PKNORMAL_ROUTINE NormalRoutine,
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called to initialize the context for a user mode APC.

Arguments:

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    NormalRoutine - Supplies a pointer to the user mode APC routine.

    NormalContext - Supplies a pointer to the user context for the APC
        routine.

    SystemArgument1 - Supplies the first system supplied value.

    SystemArgument2 - Supplies the second system supplied value.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord;
    EXCEPTION_RECORD ExceptionRecord;
    LONG Length;
    ULONGLONG UserStack;
    PULONGLONG Arguments;

    //
    // Move the user mode state from the trap and exception frames to the
    // context frame.
    //

    ContextRecord.ContextFlags = CONTEXT_FULL;

    //
    // Push the user RSE state back out to user mode.
    //

    KeFlushUserRseState (TrapFrame);

    KiSaveHigherFPVolatile(GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(KeGetCurrentThread()->StackBase));
    TrapFrame->StIPSR &= ~(1i64 << PSR_MFH);

    KeContextFromKframes(TrapFrame, ExceptionFrame, &ContextRecord);

    //
    // Transfer the context information to the user stack, initialize the
    // APC routine parameters, and modify the trap frame so execution will
    // continue in user mode at the user mode APC dispatch routine.
    //
    // We build the following structure on the user stack:
    //
    //             |                               |  
    //             |-------------------------------|
    //             |                               |
    //             |   Interrupted user's          |
    //             |   stack frame                 |
    //             |                               |
    //             |                               |
    //             |-------------------------------|
    //             |   Slack Space due to the      |
    //             |   16-byte stack alignment     |
    //             | - - - - - - - - - - - - - - - |
    //             |     NormalRoutine             |
    //             |     SystemArgument2           |
    //             |     SystemArgument1           |
    //             |     NormalContext             |
    //             | - - - - - - - - - - - - - - - |
    //             |   Context Frame               |
    //             |      Filled in with state     |
    //             |      of interrupted user      |
    //             |      program                  |
    //             | - - - - - - - - - - - - - - - |
    //             |   Stack Scratch Area          |
    //             |-------------------------------|
    //             |                               |

    try {

    USHORT LocalFrameSize;
    PPLABEL_DESCRIPTOR Plabel = (PPLABEL_DESCRIPTOR) KeUserApcDispatcher;

    //
    // Compute total length of 4 arguments, context record, and
    // stack scratch area. 
    //
    // Compute the new 16-byte aligned user stack pointer.
    //

    Length = (4 * sizeof(ULONGLONG) + CONTEXT_LENGTH +
              STACK_SCRATCH_AREA + 15) & (~15);
    UserStack = (ContextRecord.IntSp & (~15)) - Length;
    Arguments = (PULONGLONG)(UserStack + STACK_SCRATCH_AREA + CONTEXT_LENGTH);

    //
    // Probe user stack area for writeability and then transfer the
    // context record to the user stack.
    //

    ProbeForWriteSmallStructure((PCHAR)UserStack, Length, sizeof(QUAD));
    RtlCopyMemory((PVOID)(UserStack+STACK_SCRATCH_AREA), 
                  &ContextRecord, sizeof(CONTEXT));

    //
    // Set the address of the user APC routine, the APC parameters, the
    // interrupt frame set, the new global pointer, and the new stack 
    // pointer in the current trap frame.  The four APC parameters are 
    // passed via the scratch registers t0 thru t3. 
    // Set the continuation address so control will be transfered to 
    // the user APC dispatcher.
    //

    *Arguments++ = (ULONGLONG)NormalContext;     // 1st argument
    *Arguments++ = (ULONGLONG)SystemArgument1;   // 2nd argument
    *Arguments++ = (ULONGLONG)SystemArgument2;   // 3rd argument
    *Arguments++ = (ULONGLONG)NormalRoutine;     // 4th argument
    *(PULONGLONG)UserStack = Plabel->GlobalPointer;  // user apc dispatcher gp

    TrapFrame->IntNats = 0;                      // sanitize integer Nats
    TrapFrame->IntSp = UserStack;                // stack pointer

    TrapFrame->StIIP = Plabel->EntryPoint;       // entry point from plabel
    TrapFrame->StIPSR &= ~(0x3ULL << PSR_RI);    // start at bundle boundary
    TrapFrame->RsPFS &= 0xffffffc000000000i64;   // set the initial frame
    TrapFrame->StIFS &= 0xffffffc000000000i64;   // set the initial frame
                                                 // size of KeUserApcDispatcher
                                                 // to be zero.
    TrapFrame->StFPSR = USER_FPSR_INITIAL;

    //
    // If an exception occurs, then copy the exception information to an
    // exception record and handle the exception.
    //

    } except (KiCopyInformation(&ExceptionRecord,
                                (GetExceptionInformation())->ExceptionRecord)) {

        //
        // Set the address of the exception to the current program address
        // and raise the exception by calling the exception dispatcher.
        //

        ExceptionRecord.ExceptionAddress = (PVOID)(TrapFrame->StIIP);
        KiDispatchException(&ExceptionRecord,
                            ExceptionFrame,
                            TrapFrame,
                            UserMode,
                            TRUE);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\callback.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    callback.c

Abstract:

    This module implements user mode call back services.

Author:

    William K. Cheung (wcheung) 30-Oct-1995

    based on David N. Cutler (davec) 29-Oct-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, KeUserModeCallback)
#pragma alloc_text (PAGE, NtW32Call)
#endif


NTSTATUS
KeUserModeCallback (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    IN PULONG OutputLength
    )

/*++

Routine Description:

    This function call out from kernel mode to a user mode function.

Arguments:

    ApiNumber - Supplies the API number.

    InputBuffer - Supplies a pointer to a structure that is copied
        to the user stack.

    InputLength - Supplies the length of the input structure.

    Outputbuffer - Supplies a pointer to a variable that receives
        the address of the output buffer.

    Outputlength - Supplies a pointer to a variable that receives
        the length of the output buffer.

Return Value:

    If the callout cannot be executed, then an error status is
    returned. Otherwise, the status returned by the callback function
    is returned.

--*/

{
    PUCALLOUT_FRAME CalloutFrame;
    ULONGLONG OldStack;
    ULONGLONG NewStack;
    ULONGLONG OldRsPFS;
    ULONGLONG OldStIFS;
    PKTRAP_FRAME TrapFrame;
    NTSTATUS Status;
    ULONG GdiBatchCount;
    ULONG Length;
    SHORT BsFrameSize;
    USHORT TearPointOffset;

    ASSERT(KeGetPreviousMode() == UserMode);
    ASSERT(KeGetCurrentThread()->ApcState.KernelApcInProgress == FALSE);
    //
    // Get the user mode stack pointer and attempt to copy input buffer
    // to the user stack.
    //

    TrapFrame = KeGetCurrentThread()->TrapFrame;
    OldStack = TrapFrame->IntSp;
    OldRsPFS = TrapFrame->RsPFS;
    OldStIFS = TrapFrame->StIFS;

    try {

        //
        // Compute new user mode stack address, probe for writability,
        // and copy the input buffer to the user stack.
        //
        // N.B. EM requires stacks to be 16-byte aligned, therefore
        //      the input length must be rounded up to a 16-byte boundary.
        //

        Length =  (InputLength + 16 - 1 + sizeof(UCALLOUT_FRAME) + STACK_SCRATCH_AREA) & ~(16 - 1);
        NewStack = OldStack - Length;
        CalloutFrame = (PUCALLOUT_FRAME)(NewStack + STACK_SCRATCH_AREA);
        ProbeForWrite((PVOID)NewStack, Length, sizeof(QUAD));
        RtlCopyMemory(CalloutFrame + 1, InputBuffer, InputLength);

        //
        // Fill in the callout arguments.
        //

        CalloutFrame->Buffer = (PVOID)(CalloutFrame + 1);
        CalloutFrame->Length = InputLength;
        CalloutFrame->ApiNumber = ApiNumber;
        CalloutFrame->IntSp = OldStack;
        CalloutFrame->RsPFS = TrapFrame->RsPFS;
        CalloutFrame->BrRp = TrapFrame->BrRp;

        //
        // Always flush out the user RSE so the debugger and
        // unwinding work across the call out.
        //

        KeFlushUserRseState (TrapFrame);


    //
    // If an exception occurs during the probe of the user stack, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Call user mode.
    //

    TrapFrame->RsPFS = 0xC000000000000000i64;
    TrapFrame->StIFS = 0x8000000000000000i64;
    TrapFrame->IntSp = NewStack;
    Status = KiCallUserMode(OutputBuffer, OutputLength);

    //
    // When returning from user mode, any drawing done to the GDI TEB
    // batch must be flushed.  If the TEB cannot be accessed then blindly
    // flush the GDI batch anyway.
    //

    GdiBatchCount = 1;

    try {
        GdiBatchCount = ((PTEB)KeGetCurrentThread()->Teb)->GdiBatchCount;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    if (GdiBatchCount > 0) {


        //
        // Some of the call back functions store a return values in the
        // stack.  The batch flush routine can sometimes overwrite these
        // values causing failures.  Add some slop in the stack to 
        // preserve these values.
        //

        TrapFrame->IntSp -= 256;

        //
        // call GDI batch flush routine
        //

        KeGdiFlushUserBatch();
    }

    TrapFrame->IntSp = OldStack;
    TrapFrame->RsPFS = OldRsPFS;
    TrapFrame->StIFS = OldStIFS;
    return Status;

}

NTSTATUS
NtW32Call (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    OUT PULONG OutputLength
    )

/*++

Routine Description:

    This function calls a W32 function.

    N.B. ************** This is a temporary service *****************

Arguments:

    ApiNumber - Supplies the API number.

    InputBuffer - Supplies a pointer to a structure that is copied to
        the user stack.

    InputLength - Supplies the length of the input structure.

    Outputbuffer - Supplies a pointer to a variable that recevies the
        output buffer address.

    Outputlength - Supplies a pointer to a variable that recevies the
        output buffer length.

Return Value:

    TBS.

--*/

{

    PVOID ValueBuffer;
    ULONG ValueLength;
    NTSTATUS Status;

    ASSERT(KeGetPreviousMode() == UserMode);

    //
    // If the current thread is not a GUI thread, then fail the service
    // since the thread does not have a large stack.
    //

    if (KeGetCurrentThread()->Win32Thread == (PVOID)&KeServiceDescriptorTable[0]) {
        return STATUS_NOT_IMPLEMENTED;
    }

    //
    // Probe the output buffer address and length for writeability.
    //

    try {
        ProbeForWriteUlong((PULONG)OutputBuffer);
        ProbeForWriteUlong(OutputLength);

    //
    // If an exception occurs during the probe of the output buffer or
    // length, then always handle the exception and return the exception
    // code as the status value.
    //

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Call out to user mode specifying the input buffer and API number.
    //

    Status = KeUserModeCallback(ApiNumber,
                                InputBuffer,
                                InputLength,
                                &ValueBuffer,
                                &ValueLength);

    //
    // If the callout is successful, then the output buffer address and
    // length.
    //

    if (NT_SUCCESS(Status)) {
        try {
            *OutputBuffer = ValueBuffer;
            *OutputLength = ValueLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return Status;
}

VOID
KiTestGdiBatchCount (
    )

/*++

Routine Description:

    This function checks the GdiBatchCount and calls KeGdiFlushUserBatch if necessary.

Arguments:

    None.
    
Return Value:

    None.
    
--*/

{
    ULONG GdiBatchCount = 1;

    try {
        GdiBatchCount = ((PTEB)KeGetCurrentThread()->Teb)->GdiBatchCount;
    } except (EXCEPTION_EXECUTE_HANDLER) {
          NOTHING;
    }

    if (GdiBatchCount > 0) {
        KeGdiFlushUserBatch();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\callout.s ===
//++
//
// Copyright (c) 1994  Microsoft Corporation
//
// Module Name:
//
//    callout.s
//
// Abstract:
//
//    This module implements the code necessary to call out from kernel
//    mode to user mode.
//
// Author:
//
//    William K. Cheung (wcheung) 30-Oct-1995
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksia64.h"

        PublicFunction(MmGrowKernelStack)
        PublicFunction(MmGrowKernelBackingStore)
        PublicFunction(KiUserServiceExit)
        PublicFunction(KiApcInterrupt)
        PublicFunction(RtlMoveMemory)

        .global     KeUserCallbackDispatcher

//++
//
// NTSTATUS
// KiCallUserMode (
//    IN PVOID *OutputBuffer,
//    IN PULONG OutputLength
//    )
//
// Routine Description:
//
//    This function calls a user mode function.
//
//    N.B. This function calls out to user mode and the NtCallbackReturn
//        function returns back to the caller of this function. Therefore,
//        the stack layout must be consistent between the two routines.
//
// Arguments:
//
//    OutputBuffer (a0) - Supplies a pointer to the variable that receivies
//        the address of the output buffer.
//
//    OutputLength (a1) - Supplies a pointer to a variable that receives
//        the length of the output buffer.
//
// Return Value:
//
//    The final status of the call out function is returned as the status
//    of the function.
//
//    N.B. This function does not return to its caller. A return to the
//        caller is executed when a NtCallbackReturn system service is
//        executed.
//
//    N.B. This function does return to its caller if a kernel stack
//         expansion is required and the attempted expansion fails.
//
//         The instruction that restores the sp (i.e. epilogue) must be
//         in the last bundle of the function.  This is a convention
//         by which this functin must abide or the stack unwinder in the
//         imagehlp DLL will not work.
//
//--


        NESTED_ENTRY(KiCallUserMode)

        .regstk  2, 8, 2, 0
        .prologue

        rT0         = t0
        rT1         = t1
        rT2         = t2
        rT3         = t3
        rT4         = t4
        rT5         = t5
        rT6         = t6
        rT7         = t7

        rpT0        = t10
        rpT1        = t11
        rpT2        = t12
        rpT3        = t13
        rpT4        = t14
        rpT5        = t15
        rpT6        = t16

        rpCurTh     = loc0
        rbsp        = loc1
        rbspInit    = loc2
        rpTF        = loc7

        //
        // following 3 register aliases are copied from trap.s
        //

        pUser     = ps1                         // mode on entry was user
        pKrnl     = ps2                         // mode on entry was kernel
        pUDbg     = ps8                         // Kernel debug Active

//
// allocate stack frame to save preserved floating point registers
//

        alloc       rT1 = ar.pfs, 2, 8, 2, 0
        mov         rT0 = ar.unat
        mov         rT2 = brp

//
// save both preserved integer and float registers
//

        add         rpT1 = -CuFrameLength+CuBrRp+STACK_SCRATCH_AREA, sp
        add         rpT2 = -CuFrameLength+CuRsPFS+STACK_SCRATCH_AREA, sp
        .fframe     CuFrameLength
        add         sp = -CuFrameLength, sp
        ;;

        .savesp     brp, CuBrRp+STACK_SCRATCH_AREA
        st8.nta     [rpT1] = rT2, CuPreds - CuBrRp          // save rp
        .savesp    ar.pfs, CuRsPFS+STACK_SCRATCH_AREA
        st8.nta     [rpT2] = rT1, CuApUNAT - CuRsPFS        // save pfs
        mov         rT3 = pr
        ;;

        .savesp     pr, CuPreds+STACK_SCRATCH_AREA
        st8.nta     [rpT1] = rT3, CuApLC - CuPreds          // save predicates
        .savesp     ar.unat, CuApUNAT+ STACK_SCRATCH_AREA
        st8.nta     [rpT2] = rT0, CuIntS0 - CuApUNAT        // save ar.unat
        mov         rT4 = ar.lc
        ;;

        .savesp     ar.lc, CuApLC+STACK_SCRATCH_AREA
        st8.nta     [rpT1] = rT4, CuIntS1 - CuApLC          // save ar.lc
        st8.spill.nta [rpT2] = s0, CuIntS2 - CuIntS0        // save s0
        mov         rT0 = bs0
        ;;
        .mem.offset 0,0
        st8.spill.nta [rpT1] = s1, CuIntS3 - CuIntS1        // save s1
        .mem.offset 8,0
        st8.spill.nta [rpT2] = s2, CuBrS0 - CuIntS2         // save s2
        mov         rT1 = bs1
        ;;

        st8.spill.nta [rpT1] = s3, CuBrS1 - CuIntS3         // save s3
        st8.nta     [rpT2] = rT0, CuBrS2 - CuBrS0           // save bs0
        mov         rT2 = bs2
        ;;

        flushrs
        mov         ar.rsc = r0                             // put RSE in lazy mode
        mov         rT6 = ar.unat
        ;;

        mov         rT5 = ar.rnat
        mov         rT3 = bs3
        ;;

        st8.nta     [rpT1] = rT1, CuBrS3 - CuBrS1           // save bs1
        st8.nta     [rpT2] = rT2, CuBrS4 - CuBrS2           // save bs2
        mov         rT4 = bs4
        ;;

        st8.nta     [rpT1] = rT3, CuRsRNAT - CuBrS3         // save bs3
        st8.nta     [rpT2] = rT4, CuIntNats - CuBrS4        // save bs4
        ;;

        st8.nta     [rpT1] = rT5, CuFltS0 - CuRsRNAT        // save rnat
        st8.nta     [rpT2] = rT6, CuFltS1 - CuIntNats       // save NaTs
        ;;

        stf.spill.nta [rpT1] = fs0, CuFltS2 - CuFltS0       // save fs0
        stf.spill.nta [rpT2] = fs1, CuFltS3 - CuFltS1       // save fs1
        mov         v0 = zero                               // set v0 to 0
        ;;

        stf.spill.nta [rpT1] = fs2, CuFltS4 - CuFltS2       // save fs2
        stf.spill.nta [rpT2] = fs3, CuFltS5 - CuFltS3       // save fs3
        ;;

        stf.spill.nta [rpT1] = fs4, CuFltS6 - CuFltS4       // save fs4
        stf.spill.nta [rpT2] = fs5, CuFltS7 - CuFltS5       // save fs5
        nop.i       0
        ;;

        stf.spill.nta [rpT1] = fs6, CuFltS8 - CuFltS6       // save fs6
        stf.spill.nta [rpT2] = fs7, CuFltS9 - CuFltS7       // save fs7
        nop.i       0
        ;;

        stf.spill.nta [rpT1] = fs8, CuFltS10 - CuFltS8      // save fs8
        stf.spill.nta [rpT2] = fs9, CuFltS11 - CuFltS9      // save fs9
        nop.i       0
        ;;

        stf.spill.nta [rpT1] = fs10, CuFltS12 - CuFltS10    // save fs10
        stf.spill.nta [rpT2] = fs11, CuFltS13 - CuFltS11    // save fs11
        nop.i       0
        ;;

        stf.spill.nta [rpT1] = fs12, CuFltS14 - CuFltS12    // save fs12
        stf.spill.nta [rpT2] = fs13, CuFltS15 - CuFltS13    // save fs13
        nop.i       0
        ;;

        stf.spill.nta [rpT1] = fs14, CuFltS16 - CuFltS14    // save fs14
        stf.spill.nta [rpT2] = fs15, CuFltS17 - CuFltS15    // save fs15
        nop.i       0
        ;;

        stf.spill.nta [rpT1] = fs16, CuFltS18 - CuFltS16    // save fs16
        stf.spill.nta [rpT2] = fs17, CuFltS19 - CuFltS17    // save fs17
        nop.i       0
        ;;

        stf.spill.nta [rpT1] = fs18, CuA0 - CuFltS18        // save fs18
        stf.spill.nta [rpT2] = fs19, CuA1 - CuFltS19        // save fs19
        nop.i       0
        ;;

        PROLOGUE_END

//
// Check if sufficient rooms are available on both the kernel
// memory stack and backing store for another system call.
// Call the MM functions to grow them if necessary.
//

        mov         rbsp = ar.bsp
        movl        loc3 = KiPcr + PcCurrentThread

        st8.nta     [rpT1] = a0
        st8.nta     [rpT2] = a1
        mov         rT2 = 0x1ff
        ;;

        add         rbspInit = 0x200, rbsp
        mov         rT0 = sp
        ;;
        andcm       rbspInit = rbspInit, rT2
        ;;

        LDPTRINC    (rpCurTh, loc3, PcStackLimit - PcCurrentThread)
        add         rT0 = -KERNEL_LARGE_STACK_COMMIT, rT0
        mov         rT1 = rbspInit
        ;;

        add         loc4 = ThStackLimit, rpCurTh
        add         loc5 = ThBStoreLimit, rpCurTh
        add         rT1 = KERNEL_LARGE_BSTORE_COMMIT, rT1
        ;;

//
// check if it is necessary to grow the kernel stack and backing store
//

        LDPTR       (rT2, loc4)                   // Get current stack limit.
        LDPTR       (rT3, loc5)                   // Get current bstore limit
        mov         out0 = sp
        ;;

        cmp.ge      ps0 = rT2, rT0
        cmp.ge      ps1 = rT1, rT3
(ps0)   br.call.spnt.many brp = MmGrowKernelStack

//
// Get expanded stack limit from thread object and set the stack limit
// in PCR if the growth of kernel stack is successful.
//

        LDPTR       (rT0, loc4)
        cmp4.ne     pt2, pt1 = zero, v0
        ;;

        nop.m       0
(pt1)   st8         [loc3] = rT0, PcBStoreLimit - PcStackLimit
(pt2)   br.spnt     Kcum10
        ;;

        mov         out0 = rbspInit
(ps1)   br.call.spnt.many brp = MmGrowKernelBackingStore
        ;;

//
// Get expanded bstore limit from thread object and set the bstore limit
// in PCR if the growth of kernel backing store is successful.
//

        LDPTR       (rT0, loc5)
        cmp4.ne     pt2, pt1 = zero, v0
        add         loc4 = ThCallbackStack - ThStackLimit, loc4
        add         loc5 = ThCallbackBStore - ThBStoreLimit, loc5
        ;;


        rPcInStack = rT0
        rPcInBStore = rT1
        rThCbStack = rT2
        rThCbBStore = rT3
        rpLabel = rT4


        PLDPTRINC   (pt1, rThCbStack,loc4, ThTrapFrame - ThCallbackStack)
(pt1)   st8         [loc3] = rT0, PcInitialStack - PcBStoreLimit
(pt2)   br.spnt     Kcum10
        ;;


//
// Get the address of the current thread and save the previous trap
// frame and callback stack addresses in the current frame.  Also
// save the new callback stack address in the thread object.
//
// Get initial and callback stack & backing store addresses
//

        ld8.nt1     rPcInStack = [loc3], PcInitialBStore - PcInitialStack
        LDPTRINC    (rpTF, loc4, ThCallbackStack - ThTrapFrame)
        add         rpT1 = @gprel(KeUserCallbackDispatcher), gp
        ;;

        ld8.nt1     rPcInBStore = [loc3], PcInitialStack-PcInitialBStore
        LDPTR       (rThCbBStore, loc5)
        add         rpT2 = CuInStack+STACK_SCRATCH_AREA, sp
        ;;

        LDPTR       (rpLabel, rpT1)
        add         rpT5 = CuInBStore+STACK_SCRATCH_AREA, sp
        add         loc6 = PcInitialBStore - PcInitialStack, loc3
        ;;

        STPTR       (loc4, sp)                       // set callback stack addr
        STPTR       (loc5, rbsp)                     // set callback bstore addr
        add         loc4 = ThInitialStack - ThCallbackStack, loc4

//
// save initial stack and backing store addresses
//

        st8.nta     [rpT2] = rPcInStack, CuCbStk - CuInStack
        st8.nta     [rpT5] = rPcInBStore, CuCbBStore - CuInBStore
        add         loc5 = ThInitialBStore - ThCallbackBStore, loc5
        ;;

//
// save callback stack and backing store addresses
//

        st8.nta     [rpT2] = rThCbStack, CuTrFrame - CuCbStk
        st8.nta     [rpT5] = rThCbBStore, CuTrStIIP - CuCbBStore
        ;;

//
// register aliases
//

        rpEntry=rT0
        rIPSR=rT1
        rIIP=rT2


        rsm         1 << PSR_I                  // disable interrupts
        ;;

        ld8.nt1     rpEntry = [rpLabel], 8      // get continuation IP
        st8.nta     [rpT2] = rpTF               // save trap frame address
        add         rpT3 = TrStIIP, rpTF
        ;;

        ld8.nt1     loc1 = [rpLabel]              // get continuation GP
        add         rpT2 = ThApcState+AsUserApcPending, rpCurTh
        ;;

        ld8         rIIP = [rpT3], TrStIPSR-TrStIIP  // get trap IIP
        ld1         rT3 = [rpT2], ThAlerted-ThApcState-AsUserApcPending
        ;;

        ld8         rIPSR = [rpT3], TrStIIP-TrStIPSR
        add         rpT1 = -ThreadStateSaveAreaLength-TrapFrameLength+TrStIPSR, sp
        cmp4.eq     pt0 = zero, rT3
        ;;

        st8         [rpT3] = rpEntry            // set trap IIP
        st8.nta     [rpT5] = rIIP               // save original IIP
        ;;

        st8         [rpT1] = rIPSR
        tbit.nz     pUDbg = rIPSR, PSR_DB       // if psr.db set, load user DRs
        st1         [rpT2] = zero               // Clear thread alearted

(pt0)   mov         gp = loc1			// Set user GP
(pt0)   br.sptk     Kcum5                       // no user apc pending,
        ;;                                      // branch to KiUserServiceExit

        FAST_ENABLE_INTERRUPTS
        mov         out1 = APC_LEVEL
        ;;
        SET_IRQL    (out1)
        ;;
        mov         out1 = rpTF
        br.call.sptk brp = KiApcInterrupt
        ;;

        FAST_DISABLE_INTERRUPTS
        SET_IRQL    (zero)
        mov         gp = loc1			// Set user GP
        ;;                                      

Kcum5:
        st8.nta     [loc4] = sp                 // reset initial stack addr
        st8.nta     [loc3] = sp                 // reset initial stack addr
        cmp4.eq     pUser, pKrnl = 0, r0        // preset predicates for
                                                // KiUserServiceExit
                                                // N.B. ps1 -- pUser
                                                //      ps2 -- pKrnl

        mov         t0 = rpTF                   // set t0 -> trap frame address
                                                // per system call convention
        st8.nta     [loc5] = rbspInit           // reset initial bstore addr
        st8.nta     [loc6] = rbspInit           // reset initial bstore addr
        br          KiUserServiceExit           // per system call convention

//
// An attempt to grow the kernel stack or backing store failed.
//

Kcum10:

        nop.m       0
        add         rpT1 = CuBrRp+STACK_SCRATCH_AREA, sp
        add         rpT2 = CuRsPFS+STACK_SCRATCH_AREA, sp
        ;;

        ld8.nt1     rT1 = [rpT1], CuPreds-CuBrRp
        ;;
        ld8.nt1     rT2 = [rpT2]
        mov         brp = rT1
        ;;

        ld8.nt1     rT3 = [rpT1]
        mov         ar.pfs = rT2
        ;;
        mov         pr = rT3, -1
        ;;

        .restore
        add         sp = CuFrameLength, sp
        nop.i       0
        br.ret.sptk.clr brp

        NESTED_EXIT(KiCallUserMode)


//++
//
// PVOID
// KeSwitchKernelStack (
//    IN PVOID StackBase,
//    IN PVOID StackLimit,
//    IN PVOID BStoreLimit
//    )
//
// Routine Description:
//
//    This function switches to the specified large kernel stack.
//
//    N.B. This function can ONLY be called when there are no variables
//        in the stack that refer to other variables in the stack, i.e.,
//        there are no pointers into the stack.
//
// Arguments:
//
//    StackBase (a0) - Supplies a pointer to the base of the new kernel
//        stack.
//
//    StackLimit (a1) - supplies a pointer to the limit of the new kernel
//        stack.
//
//    BStoreLimit (a2) - supplies a pointer to the limit of the new kernel
//        backing store.
//
// Return Value:
//
//    The old kernel stack/backing store base is returned as the function value.
//
//--


        NESTED_ENTRY(KeSwitchKernelStack)

        .regstk   3, 4, 3, 0
        .prologue

        //
        // register aliases
        //

        rpCurTh     = loc0
        rThStackBase= loc1
        rbsp        = loc2
        rT0         = t0
        rT1         = t1
        rT2         = t2
        rT3         = t3
        rT4         = t4
        rT5         = t5
        rT6         = t6
        rT7         = t7
        rpT0        = t10
        rpT1        = t11
        rpT2        = t12
        rpT3        = t13
        rpT4        = t14
        rpT5        = t15
        rpT6        = t16


        alloc       rT1 = ar.pfs, 3, 3, 3, 0
        mov         rpT3 = sp
        mov         rT0 = brp
        ;;

        mov         rbsp = ar.bsp
        movl        rpT0 = KiPcr+PcCurrentThread
        ;;

        .fframe     16
        flushrs
        add         sp = -16, sp                // allocate space for brp, pfs
        ;;

        .savepsp    brp, 0
        LDPTR       (rpCurTh, rpT0)
        st8         [rpT3] = rT0, 8     // save brp, pfs in old scratch area
        ;;

        .savepsp    ar.pfs, -8
        st8         [rpT3] = rT1
        add         rpT1 = ThStackBase, rpCurTh
        add         rpT2 = ThTrapFrame, rpCurTh
        ;;

        PROLOGUE_END

        LDPTR       (rThStackBase, rpT1)
        LDPTR       (rT2, rpT2)                 // get trap frame address
        mov         out1 = sp
        ;;

//
// relocate trap frame.
// copy memory stack and backing store.
//

        sub         rT1 = rThStackBase, rT2
        ;;
        sub         out2 = rThStackBase, sp     // compute the copy size
        sub         rT2 = a0, rT1
        ;;

        STPTR       (rpT2, rT2)                 // save new trap frame address
        sub         out0 = a0, out2
 (p0)   br.call.sptk.many brp = RtlMoveMemory
        ;;

        sub         out2 = rbsp, rThStackBase
        mov         out0 = a0
        mov         out1 = rThStackBase
        ;;

        mov         ar.rsc = r0                 // put RSE in lazy mode
        mov         rbsp = out2
 (p0)   br.call.sptk.many brp = RtlMoveMemory
        ;;

        rsm         1 << PSR_I                  // disable interrupts
        mov         rpT0 = rpCurTh
        sub         rT1 = rThStackBase, sp

        add         rpT1 = ThInitialStack, rpCurTh
        add         rpT2 = ThStackLimit, rpCurTh
        ;;

//
// interrupt disabled, then update kernel stack/bstore base,
// then switch kernel stack and backing store
//

//
// set new initial stack and stack base addresses in the kernel thread object.
// set the return value to the old stack base address.
//

        STPTRINC    (rpT1, a0, ThInitialBStore - ThInitialStack)
        STPTRINC    (rpT2, a1, ThBStoreLimit - ThStackLimit)
        add         rpT5 = 16, sp
        ;;

        STPTR       (rpT1, a0)
        STPTR       (rpT2, a2)
        add         rpT6 = 24, sp
        ;;

        add         rpT1 = ThStackBase, rpCurTh
        add         rpT2 = ThLargeStack, rpCurTh
        add         rT5 = 1, r0
        ;;

        STPTR       (rpT1, a0)                  // save new stack/bstore base
        st1         [rpT2] = rT5                // large stack indicator
        nop.i       0

        ld8         rT3 = [rpT5]                // restore return pointer
        movl        rpT3 = KiPcr+PcInitialStack
        ;;

        ld8         rT4 = [rpT6]                // restore pfs
        add         rpT4 = PcStackLimit - PcInitialStack, rpT3
        mov         v0 = rThStackBase
        ;;

//
// set new initial stack/bstore and their limits in the PCR
//

        st8         [rpT3] = a0, PcInitialBStore - PcInitialStack
        st8         [rpT4] = a1, PcBStoreLimit - PcStackLimit
        sub         sp = a0, rT1                // switch to new kernel stack
        ;;

        st8         [rpT3] = a0
        st8         [rpT4] = a2
        add         rT2 = rbsp, a0
        ;;

        alloc       rT5 = ar.pfs, 0, 0, 0, 0
        ;;
        mov         rT6 = ar.rnat
        mov         brp = rT3
        ;;

        loadrs
        ;;
        mov         ar.bspstore = rT2           // switch to new backing store
        mov         ar.pfs = rT4
        ;;

        mov         ar.rnat = rT6
        ssm         1 << PSR_I                  // enable interrupt
        .restore
        add         sp = 16, sp                 // deallocate stack frame
        ;;

        invala
        mov         ar.rsc = RSC_KERNEL
        ;;

        br.ret.sptk.clr brp

        NESTED_EXIT(KeSwitchKernelStack)


//++
//
// NTSTATUS
// NtCallbackReturn (
//    IN PVOID OutputBuffer OPTIONAL,
//    IN ULONG OutputLength,
//    IN NTSTATUS Status
//    )
//
// Routine Description:
//
//    This function returns from a user mode callout to the kernel
//    mode caller of the user mode callback function.
//
//    N.B. This function returns to the function that called out to user
//        mode and the KiCallUserMode function calls out to user mode.
//        Therefore, the stack layout must be consistent between the
//        two routines.
//
//        t0 - current trap frame address
//
// Arguments:
//
//    OutputBuffer - Supplies an optional pointer to an output buffer.
//
//    OutputLength - Supplies the length of the output buffer.
//
//    Status - Supplies the status value returned to the caller of the
//        callback function.
//
// Return Value:
//
//    If the callback return cannot be executed, then an error status is
//    returned. Otherwise, the specified callback status is returned to
//    the caller of the callback function.
//
//    N.B. This function returns to the function that called out to user
//         mode is a callout is currently active.
//
//--

        LEAF_ENTRY(NtCallbackReturn)

        .regstk     3, 1, 0, 0

        rT0         = t1
        rT1         = t2
        rT2         = t3
        rT3         = t4
        rT4         = t5
        rT5         = t6
        rT6         = t7
        rT7         = t8
        rT8         = t9
        rT9         = t10
        rpT0        = t11
        rpT1        = t12
        rpT2        = t13
        rpT3        = t14
        rpT4        = t15
        rpT5        = t16
        rpT6        = t17

        rIPSR       = t18
        rpCurTh     = t19
        rThCbStack  = t20
        rThCbBStore = t21
        rRnat       = loc0


        alloc       rT6 = ar.pfs, 3, 1, 0, 0
        movl        rpT0 = KiPcr+PcCurrentThread
        ;;

        LDPTR       (rpCurTh, rpT0)
        add         rIPSR = TrStIPSR, t0
        ;;

        ld8         rIPSR = [rIPSR]
        movl        rT1 = 1 << PSR_DB | 1 << PSR_TB | 1 << PSR_SS | 1 << PSR_LP

        add         rpT0 = ThCallbackStack, rpCurTh
        add         rpT3 = ThCallbackBStore, rpCurTh
        ;;

        LDPTR       (rThCbStack, rpT0)          // get callback stack address
        LDPTR       (rThCbBStore, rpT3)         // get callback bstore address
        and         rIPSR = rIPSR, rT1          // capture db, tb, ss, lp bits
        ;;

        cmp.eq      pt1, pt2 = zero, rThCbStack
        add         rpT1 = CuIntNats+STACK_SCRATCH_AREA, rThCbStack
        add         rpT2 = CuApLC+STACK_SCRATCH_AREA, rThCbStack
        ;;

  (pt2) ld8.nt1     rT0 = [rpT1], CuPreds - CuIntNats
  (pt1) movl        v0 = STATUS_NO_CALLBACK_ACTIVE

  (pt2) ld8.nt1     rT1 = [rpT2], CuBrRp - CuApLC
        nop.m       0
  (pt1) br.ret.sptk.clr brp
        ;;

        ld8.nt1     rT2 = [rpT1], CuRsPFS - CuPreds
        ld8.nt1     rT3 = [rpT2], CuBrS0 - CuBrRp
        mov         v0 = a2                     // set callback service status
        ;;

        ld8.nt1     rT4 = [rpT1], CuBrS1 - CuRsPFS
        ld8.nt1     rT5 = [rpT2], CuBrS2 - CuBrS0
        nop.i       0
        ;;

        mov         ar.unat = rT0
        mov         ar.lc = rT1
        nop.i       0

        ld8.nt1     rT6 = [rpT1], CuBrS3 - CuBrS1
        ld8.nt1     rT7 = [rpT2], CuBrS4 - CuBrS2
        mov         pr = rT2, -1
        ;;

        ld8.nt1     rT8 = [rpT1], CuIntS0 - CuBrS3
        ld8.nt1     rT9 = [rpT2], CuIntS1 - CuBrS4
        mov         brp = rT3
        ;;

        ld8.fill.nt1 s0 = [rpT1], CuIntS2 - CuIntS0
        ld8.fill.nt1 s1 = [rpT2], CuIntS3 - CuIntS1
        mov         ar.pfs = rT4
        ;;

        ld8.fill.nt1 s2 = [rpT1], CuApUNAT - CuIntS2
        ld8.fill.nt1 s3 = [rpT2], CuRsRNAT - CuIntS3
        mov         bs0 = rT5
        ;;

        ld8.nt1     rT0 = [rpT1], CuFltS0 - CuApUNAT
        ld8.nt1     rRnat = [rpT2], CuFltS1 - CuRsRNAT
        mov         bs1 = rT6
        ;;

        ldf.fill.nt1 fs0 = [rpT1], CuFltS2 - CuFltS0
        ldf.fill.nt1 fs1 = [rpT2], CuFltS3 - CuFltS1
        mov         bs2 = rT7
        ;;

        ldf.fill.nt1 fs2 = [rpT1], CuFltS4 - CuFltS2
        ldf.fill.nt1 fs3 = [rpT2], CuFltS5 - CuFltS3
        mov         bs3 = rT8
        ;;

        ldf.fill.nt1 fs4 = [rpT1], CuFltS6 - CuFltS4
        ldf.fill.nt1 fs5 = [rpT2], CuFltS7 - CuFltS5
        nop.i       0
        ;;

        ldf.fill.nt1 fs6 = [rpT1], CuFltS8 - CuFltS6
        ldf.fill.nt1 fs7 = [rpT2], CuFltS9 - CuFltS7
        nop.i       0
        ;;

        ldf.fill.nt1 fs8 = [rpT1], CuFltS10 - CuFltS8
        ldf.fill.nt1 fs9 = [rpT2], CuFltS11 - CuFltS9
        nop.i       0
        ;;

        ldf.fill.nt1 fs10 = [rpT1], CuFltS12 - CuFltS10
        ldf.fill.nt1 fs11 = [rpT2], CuFltS13 - CuFltS11
        nop.i       0
        ;;

        ldf.fill.nt1 fs12 = [rpT1], CuFltS14 - CuFltS12
        ldf.fill.nt1 fs13 = [rpT2], CuFltS15 - CuFltS13
        nop.i       0
        ;;

        ldf.fill.nt1 fs14 = [rpT1], CuFltS16 - CuFltS14
        ldf.fill.nt1 fs15 = [rpT2], CuFltS17 - CuFltS15
        nop.i       0
        ;;

        ldf.fill.nt1 fs16 = [rpT1], CuFltS18 - CuFltS16
        ldf.fill.nt1 fs17 = [rpT2], CuFltS19 - CuFltS17
        nop.i       0
        ;;

        ldf.fill.nt1 fs18 = [rpT1], CuA0 - CuFltS18
        ldf.fill.nt1 fs19 = [rpT2], CuA1 - CuFltS19
        nop.i       0
        ;;

        ld8.nt1     rpT5 = [rpT1], CuCbStk - CuA0       // load value of A0
        mov         ar.unat = rT0
        mov         bs4 = rT9
        ;;

        ld8.nt1     rT0 = [rpT1], CuTrFrame - CuCbStk   // load callback stack
        ld8.nt1     rpT6 = [rpT2], CuCbBStore - CuA1    // load value of A1
        add         rpT3 = ThCallbackStack, rpCurTh
        ;;

        ld8.nt1     rT1 = [rpT1], CuInStack - CuTrFrame // load trap frame addr
        ld8.nt1     rT2 = [rpT2], CuTrStIIP-CuCbBStore  // load callback bstore
        add         rpT4 = ThCallbackBStore, rpCurTh
        ;;

        ld8.nt1     rT5 = [rpT1]                // get previous initial stack
        ld8.nt1     rT4 = [rpT2], CuInBStore-CuTrStIIP  // load trap frame IIP
        add         rpT0 = ThTrapFrame, rpCurTh

        STPTR       (rpT5, a0)                  // store buffer address in A0
        st4         [rpT6] = a1                 // store buffer length in A1
        add         rpT6 = TrStIPSR, rT1

        STPTR       (rpT3, rT0)                 // restore callback stack addr
        STPTR       (rpT4, rT2)                 // restore callback bstore addr
        add         rpT3 =  ThInitialStack, rpCurTh
        ;;

        ld8.nt1     rT6 = [rpT2]                // get previous initial bstore
        ld8         rT0 = [rpT6], TrStIIP-TrStIPSR
        add         rpT5 = ThInitialBStore, rpCurTh
        ;;

        st8.nta     [rpT6] = rT4, TrStIPSR-TrStIIP  // restore trap IIP
        rsm         1 << PSR_I                  // disable interrupts
        or          rIPSR = rIPSR, rT0
        ;;

        st8         [rpT6] = rIPSR              // propagate ss, db, tb, lp bits
        movl        rpT4 = KiPcr+PcInitialStack
        ;;

        alloc       rT0 = ar.pfs, 0, 0, 0, 0
        mov         ar.rsc = r0                // put RSE in lazy mode
        mov         rT7 = rRnat
        ;;

        loadrs
        STPTR       (rpT0, rT1)                 // restore trap frame address
        nop.i       0
        ;;

        mov         ar.bspstore = rThCbBStore   // rThCbBStore
        st8.nta     [rpT4] = rT5, PcInitialBStore - PcInitialStack
        nop.i       0
        ;;

//
// restore initial stack and bstore.
//

        mov         ar.rnat = rT7
        STPTR       (rpT3, rT5)
        nop.i       0
        ;;

        mov         ar.rsc = RSC_KERNEL         // restore RSC
        st8.nta     [rpT4] = rT6
        add         sp = CuFrameLength, rThCbStack

        STPTR       (rpT5, rT6)
        ssm         1 << PSR_I                  // enable interrupts

        invala
        br.ret.sptk.clr brp

        LEAF_EXIT(NtCallbackReturn)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\clock.c ===
/*++

Module Name:

    clock.c

Abstract:

    This module implements the platform specific clock interrupt processing
    routines in for the kernel.

Author:

    Edward G. Chron (echron) 10-Apr-1996

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#include <ia64.h>
#include <ntia64.h>
#include <ntexapi.h>

VOID
KiProcessProfileList (
    IN PKTRAP_FRAME    TrFrame,
    IN KPROFILE_SOURCE Source,
    IN PLIST_ENTRY     ListHead
    );


BOOLEAN
KiChkTimerExpireSysDpc (
    IN ULONGLONG     TickCount
    )

/*++

Routine Description:

    This routine determines if it should attempt to place a timer expiration DPC
    in the system DPC list and to drive the DPC by initiating a dispatch level interrupt
    on the current processor.

    N.B. If DPC is already inserted on the DPC list, we're done.

Arguments:

    TickCount - The lower tick count, timer table hand value

Return Value:

    BOOLEAN - Set to true if Queued DPC or if DPC already Queued.

--*/

{
    BOOLEAN     ret = FALSE;    // No DPC queued, default return value.

    PLIST_ENTRY ListHead = &KiTimerTableListHead[(ULONG)TickCount%TIMER_TABLE_SIZE];
    PLIST_ENTRY NextEntry = ListHead->Flink;

    //
    // Check to see if the list is empty.
    //
    if (NextEntry != ListHead) {
        PKTIMER   Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
        ULONGLONG TimeValue = Timer->DueTime.QuadPart;
        ULARGE_INTEGER CurrentTime;

        //
        // See if timer expired.
        //

        CurrentTime.LowPart = SharedUserData->InterruptTime.LowPart;
        CurrentTime.HighPart = SharedUserData->InterruptTime.High1Time;
        if (TimeValue <= CurrentTime.QuadPart) {

            PKPRCB Prcb = KeGetCurrentPrcb();
            PKDPC  Dpc  = &KiTimerExpireDpc;

            _disable();
#if !defined(NT_UP)
            KiAcquireSpinLock(&Prcb->DpcLock);
#endif
            //
            // Insert DPC only if not already inserted.
            //
            if (Dpc->Lock == NULL) {

                //
                // Put timer expiration DPC in the system DPC list and initiate
                // a dispatch interrupt on the current processor.
                //

                Prcb->DpcCount += 1;
                Prcb->DpcQueueDepth += 1;
                Dpc->Lock = &Prcb->DpcLock;
                Dpc->SystemArgument1 = (PVOID)TickCount;
                Dpc->SystemArgument2 = 0;
                InsertTailList(&Prcb->DpcListHead, &Dpc->DpcListEntry);
                KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
            }

            ret = TRUE;

#if !defined(NT_UP)
            KiReleaseSpinLock(&Prcb->DpcLock);
#endif

            _enable();
        }
    }

    return(ret);
}


VOID
KeUpdateSystemTime (
    IN PKTRAP_FRAME TrFrame,
    IN ULONG        Increment
    )

/*++

Routine Description:

    This routine is executed on a single processor in the processor complex.
    It's function is to update the system time and to check to determine if a
    timer has expired.

    N.B. This routine is executed on a single processor in a multiprocess system.
    The remainder of the processors in the complex execute the quantum end and
    runtime update code.

Arguments:

    TrFrame   - Supplies a pointer to a trap frame.

    Increment - The time increment to be used to adjust the time slice for the next
                tick. The value is supplied in 100ns units.

Return Value:

    None.

--*/

{
    ULONG LowTime;
    LONG HighTime;
    LONG SaveTickOffset;

    //
    // Update the interrupt time in the shared region.
    //

    LowTime = SharedUserData->InterruptTime.LowPart + Increment;
    HighTime = SharedUserData->InterruptTime.High1Time + (LowTime < Increment);
    SharedUserData->InterruptTime.High2Time = HighTime;
    SharedUserData->InterruptTime.LowPart = LowTime;
    SharedUserData->InterruptTime.High1Time = HighTime;

    KiTickOffset                  -= Increment;

    SaveTickOffset = KiTickOffset;

    if ((LONG)KiTickOffset > 0)
    {
        //
        // Tick has not completed (100ns time units remain).
        //
        // Determine if a timer has expired at the current hand value.
        //

        KiChkTimerExpireSysDpc(KeTickCount.QuadPart);

    } else {

        //
        // Tick has completed, tick count set to maximum increase plus any
        // residue and system time is updated.
        //
        // Compute next tick offset.
        //

        KiTickOffset += KeMaximumIncrement;
        LowTime = SharedUserData->SystemTime.LowPart + KeTimeAdjustment;
        HighTime = SharedUserData->SystemTime.High1Time + (LowTime < KeTimeAdjustment);
        SharedUserData->SystemTime.High2Time = HighTime;
        SharedUserData->SystemTime.LowPart = LowTime;
        SharedUserData->SystemTime.High1Time = HighTime;
        ++KeTickCount.QuadPart;
        SharedUserData->TickCountLow = (ULONG)KeTickCount.QuadPart;

        //
        // Determine if a timer has expired at either the current hand value or
        // the next hand value.
        //

        if (!KiChkTimerExpireSysDpc(KeTickCount.QuadPart - 1))
            KiChkTimerExpireSysDpc(KeTickCount.QuadPart);

    }

    if (SaveTickOffset <= 0) {
        KeUpdateRunTime(TrFrame);
    }
}


VOID
KeUpdateRunTime (
    IN PKTRAP_FRAME TrFrame
    )

/*++

Routine Description:

    This routine is executed on all processors in the processor complex.
    It's function is to update the run time of the current thread, udpate the run
    time for the thread's process, and decrement the current thread's quantum.

Arguments:

    TrFrame - Supplies a pointer to a trap frame.

Return Value:

    None.

--*/

{
    KSPIN_LOCK Lock;
    PKPRCB    Prcb    = KeGetCurrentPrcb();
    PKTHREAD  Thread  = KeGetCurrentThread();
    PKPROCESS Process = Thread->ApcState.Process;

    //
    // If thread was executing in user mode:
    //    increment the thread user time.
    //    atomically increment the process user time.
    // else If the old IRQL is greater than the DPC level:
    //         increment the time executing interrupt service routines.
    //      else If the old IRQL is less than the DPC level or If a DPC is not active:
    //              increment the thread kernel time.
    //              atomically increment the process kernel time.
    //      else
    //              increment time executing DPC routines.
    //

    if (TrFrame->PreviousMode != KernelMode) {
        ++Thread->UserTime;

        // Atomic Update of Process User Time required.
        ExInterlockedIncrementLong(&Process->UserTime, &Lock);

        // Update the time spent in user mode for the current processor.
        ++Prcb->UserTime;
    } else {

        if (TrFrame->OldIrql > DISPATCH_LEVEL) {
            ++Prcb->InterruptTime;
        } else if ((TrFrame->OldIrql < DISPATCH_LEVEL) ||
                   (Prcb->DpcRoutineActive == 0)) {
            ++Thread->KernelTime;
            ExInterlockedIncrementLong(&Process->KernelTime, &Lock);
        } else {
            ++Prcb->DpcTime;
        }

        //
        // Update the time spent in kernel mode for the current processor.
        //

        ++Prcb->KernelTime;
    }

    //
    // Update the DPC request rate which is computed as the average between the
    // previous rate and the current rate.
    // Update the DPC last count with the current DPC count.
    //
    Prcb->DpcRequestRate = ((Prcb->DpcCount - Prcb->DpcLastCount) + Prcb->DpcRequestRate) >> 1;
    Prcb->DpcLastCount = Prcb->DpcCount;

    //
    // If the DPC queue depth is not zero and a DPC routine is not active.
    //      Request a dispatch interrupt.
    //      Decrement the maximum DPC queue depth.
    //      Reset the threshold counter if appropriate.
    //
    if (Prcb->DpcQueueDepth != 0 && Prcb->DpcRoutineActive == 0) {

        Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;

        // Need to request a DPC interrupt.
        KiRequestSoftwareInterrupt(DISPATCH_LEVEL);

        if (Prcb->DpcRequestRate < KiIdealDpcRate && Prcb->MaximumDpcQueueDepth > 1)
            --Prcb->MaximumDpcQueueDepth;
    } else {
        //
        // The DPC queue is empty or a DPC routine is active or a DPC interrupt
        // has been requested. Count down the adjustment threshold and if the count
        // reaches zero, then increment the maximum DPC queue depth but not above
        // the initial value. Also, reset the adjustment threshold value.
        //
        --Prcb->AdjustDpcThreshold;
        if (Prcb->AdjustDpcThreshold == 0) {
            Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;
            if (KiMaximumDpcQueueDepth != Prcb->MaximumDpcQueueDepth)
                ++Prcb->MaximumDpcQueueDepth;
        }
    }

    //
    // Decrement current thread quantum and determine if quantum end has occurred.
    //
    Thread->Quantum -= CLOCK_QUANTUM_DECREMENT;

    // Set quantum end if time expired, for any thread except idle thread.
    if (Thread->Quantum <= 0 && Thread != Prcb->IdleThread)  {

        Prcb->QuantumEnd = 1;

        // Need to request a DPC interrupt.
        KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
    }

#ifdef _MERCED_A0_
    //
    // if SignalDone of the processor prcb is set, an IPI is to be serviced
    // but the corresponding IPI may have been lost on pre-B3 processors;
    // therefore, send another IPI to workaround this problem
    //
    if (KeGetCurrentPrcb()->SignalDone != 0) {
        HalRequestIpi(PCR->SetMember);
    }
#endif //  _MERCED_A0_

}


VOID
KeProfileInterrupt (
    IN PKTRAP_FRAME TrFrame
    )
/*++

Routine Description:

    This routine is executed on all processors in the processor complex.
    The routine is entered as the result of an interrupt generated by the profile
    timer. Its function is to update the profile information for the currently
    active profile objects.

    N.B. KeProfileInterrupt is an alternate entry for backwards compatability that
         sets the source to zero (ProfileTime).

Arguments:

    TrFrame   - Supplies a pointer to a trap frame.

Return Value:

    None.

--*/

{
    KPROFILE_SOURCE Source = 0;

    KeProfileInterruptWithSource(TrFrame, Source);

    return;
}


VOID
KeProfileInterruptWithSource (
    IN PKTRAP_FRAME    TrFrame,
    IN KPROFILE_SOURCE Source
    )
/*++

Routine Description:

    This routine is executed on all processors in the processor complex.
    The routine is entered as the result of an interrupt generated by the profile
    timer. Its function is to update the profile information for the currently
    active profile objects.

    N.B. KeProfileInterruptWithSource is not currently fully implemented by any of
         the architectures.

Arguments:

    TrFrame - Supplies a pointer to a trap frame.

    Source  - Supplies the source of the profile interrupt.

Return Value:

    None.

--*/

{
    PKTHREAD  Thread  = KeGetCurrentThread();
    PKPROCESS Process = Thread->ApcState.Process;

    PERFINFO_PROFILE(TrFrame, Source);

#if !defined(NT_UP)
    KiAcquireSpinLock(&KiProfileLock);
#endif

    KiProcessProfileList(TrFrame, Source, &Process->ProfileListHead);

    KiProcessProfileList(TrFrame, Source, &KiProfileListHead);

#if !defined(NT_UP)
    KiReleaseSpinLock(&KiProfileLock);
#endif
    return;
}


VOID
KiProcessProfileList (
    IN PKTRAP_FRAME    TrFrame,
    IN KPROFILE_SOURCE Source,
    IN PLIST_ENTRY     ListHead
    )
/*++

Routine Description:

    This routine is executed on all processors in the processor complex.
    The routine is entered as the result of an interrupt generated by the profile
    timer. Its function is to update the profile information for the currently
    active profile objects.

    N.B. KeProfileInterruptWithSource is not currently fully implemented by any of
         the architectures.

Arguments:

    TrFrame  - Supplies a pointer to a trap frame.

    Source   - Supplies the source of the profile interrupt.

    ListHead - Supplies a pointer to a profile list.

Return Value:

    None.

--*/

{
    PLIST_ENTRY NextEntry = ListHead->Flink;
    PKPRCB Prcb = KeGetCurrentPrcb();

    //
    // Scan profile list and increment profile buckets as appropriate.
    //
    for (; NextEntry != ListHead; NextEntry = NextEntry->Flink) {
        PCHAR  BucketPter;
        PULONG BucketValue;

        PKPROFILE Profile = CONTAINING_RECORD(NextEntry, KPROFILE, ProfileListEntry);

        if ( (Profile->Source != Source) || ((Profile->Affinity & Prcb->SetMember) == 0) )   {
            continue;
        }

        if ( ((PVOID)TrFrame->StIIP < Profile->RangeBase) || ((PVOID)TrFrame->StIIP > Profile->RangeLimit) )  {
            continue;
        }

        BucketPter = (PCHAR)Profile->Buffer +
                     ((((PCHAR)TrFrame->StIIP - (PCHAR)Profile->RangeBase)
                     >> Profile->BucketShift) & 0xFFFFFFFC);
        BucketValue = (PULONG) BucketPter;
        (*BucketValue)++;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\apcint.s ===
//      TITLE("Asynchronous Procedure Call (APC) Interrupt")
//++
//
// Copyright (c) 1990  Microsoft Corporation
//
// Module Name:
//
//    apcint.s
//
// Abstract:
//
//    This module implements the code necessary to field and process the
//    Asynchronous Procedure Call (APC) interrupt.
//
// Author:
//
//    William K. Cheung (wcheung) 1-Nov-1995
//
// Environment:
//
//    Kernel mode only, IRQL APC_LEVEL.
//
// Revision History:
//
//    08-Feb-1996    Updated to EAS2.1
//
//--

#include "ksia64.h"

        .file "apcint.s"


//++
// Routine
//
//    VOID
//    KiApcInterrupt(PKINTERRUPT, PKTRAP_FRAME)
//
// Routine Description:
//
//    This routine is entered as the result of a software interrupt generated
//    at APC_LEVEL. Its function is to allocate an exception frame and call
//    the kernel APC delivery routine to deliver kernel mode APCs and to check
//    if a user mode APC should be delivered. If a user mode APC should be
//    delivered, then the kernel APC delivery routine constructs a context
//    frame on the user stack and alters the exception and trap frames so that
//    control will be transfered to the user APC dispatcher on return from the
//    interrupt.
//
// Arguments:
//
//    a0 - Supplies a pointer to interrupt object.
//    
//    a1 - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
//--

        .global     KiSaveExceptionFrame
        .type       KiSaveExceptionFrame, @function
        .global     KiDeliverApc
        .type       KiDeliverApc, @function


        NESTED_ENTRY(KiApcInterrupt)

        .regstk     2, 3, 3, 0
        .prologue   0xC, savedpfs

        alloc       savedpfs = ar.pfs, 2, 3, 3, 0
        mov         savedbrp = brp
        add         t0 = TrPreviousMode, a1
        ;;

        .fframe     ExceptionFrameLength
        add         sp = -ExceptionFrameLength, sp
        ld4         loc2 = [t0]                 // PreviousMode'size = 4-byte
        ;;

        PROLOGUE_END

//
// Register definitions
//

        pKern       = pt0
        pUser       = pt1

//
// Save the nonvolatile machine state so a context record can be
// properly constructed to deliver an APC to user mode if required.
//

        cmp.eq      pUser = UserMode, loc2
        add         out0 = STACK_SCRATCH_AREA, sp
(pUser) br.call.spnt brp = KiSaveExceptionFrame
        ;;

        mov         out0 = loc2
        add         out1 = STACK_SCRATCH_AREA, sp   // -> exception frame
        mov         out2 = a1                   // -> trap frame
        br.call.sptk.many brp = KiDeliverApc
        ;;

//
// deallocate exception frame and high floating pointer register save area
//

        .restore
        add         sp = ExceptionFrameLength, sp
        NESTED_RETURN

        NESTED_EXIT(KiApcInterrupt)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\context.c ===
/*++

Module Name:

    context.c

Abstract:

    This module implement the code that transfer machine state between
    context and kernel trap/exception frames.

Author:

    William K. Cheung (wcheung) 06-Mar-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
RtlpFlushRSE (
    OUT PULONGLONG BackingStore,
    OUT PULONGLONG RNat
    );

#define ALIGN_NATS(Result, Source, Start, AddressOffset, Mask)    \
    if (AddressOffset == Start) {                                       \
        Result = (ULONGLONG)Source;                                     \
    } else if (AddressOffset < Start) {                                 \
        Result = (ULONGLONG)(Source << (Start - AddressOffset));        \
    } else {                                                            \
        Result = (ULONGLONG)((Source >> (AddressOffset - Start)) |      \
                             (Source << (64 + Start - AddressOffset))); \
    }                                                                   \
    Result = Result & (ULONGLONG)Mask

#define EXTRACT_NATS(Result, Source, Start, AddressOffset, Mask)        \
    Result = (ULONGLONG)(Source & (ULONGLONG)Mask);                     \
    if (AddressOffset < Start) {                                        \
        Result = Result >> (Start - AddressOffset);                     \
    } else if (AddressOffset > Start) {                                 \
        Result = ((Result << (AddressOffset - Start)) |                 \
                  (Result >> (64 + Start - AddressOffset)));            \
    }

LONG
KeFlushRseExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN NTSTATUS *Status
    )
{

    PETHREAD Thread = PsGetCurrentThread();
    
    *Status = ExceptionPointer->ExceptionRecord->ExceptionCode;

    if (*Status == STATUS_IN_PAGE_ERROR &&
        ExceptionPointer->ExceptionRecord->NumberParameters >= 3) {
        *Status = (LONG) ExceptionPointer->ExceptionRecord->ExceptionInformation[2];
    }

    DbgPrint("KeFlushRseExceptionFilter: Exception raised in krnl-to-user bstore copy. Status = %x\n", *Status);

    return EXCEPTION_EXECUTE_HANDLER;
}

VOID
KiGetDebugContext (
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the user mode h/w debug registers from the debug register
    save area in the kernel stack to the context record.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    ContextFrame - Supplies a pointer to the context frame that receives the
        context.

Return Value:

    None.

Note:

    PSR.db must be set to activate the debug registers.

    This is used for getting user mode debug registers.

--*/

{
    PKDEBUG_REGISTERS DebugRegistersSaveArea;

    if (TrapFrame->PreviousMode == UserMode) {
        DebugRegistersSaveArea = GET_DEBUG_REGISTER_SAVEAREA();

        RtlCopyMemory(&ContextFrame->DbI0,
                      (PVOID)DebugRegistersSaveArea,
                      sizeof(KDEBUG_REGISTERS));
    }
}

VOID
KiSetDebugContext (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextFrame,
    IN KPROCESSOR_MODE PreviousMode
    )
/*++

Routine Description:

    This routine moves the debug context from the specified context frame into
    the debug registers save area in the kernel stack.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied.

    PreviousMode - Supplies the processor mode for the target context.

Return Value:

    None.

Notes:

   PSR.db must be set to activate the debug registers.

   This is used for setting up debug registers for user mode.

--*/

{
    PKDEBUG_REGISTERS DebugRegistersSaveArea;  // User mode h/w debug registers

    if (PreviousMode == UserMode) {

        DebugRegistersSaveArea = GET_DEBUG_REGISTER_SAVEAREA();

        //
        // Sanitize the debug control regs. Leave the addresses unchanged.
        //

        DebugRegistersSaveArea->DbI0 = ContextFrame->DbI0;
        DebugRegistersSaveArea->DbI1 = SANITIZE_DR(ContextFrame->DbI1,UserMode);
        DebugRegistersSaveArea->DbI2 = ContextFrame->DbI2;
        DebugRegistersSaveArea->DbI3 = SANITIZE_DR(ContextFrame->DbI3,UserMode);
        DebugRegistersSaveArea->DbI4 = ContextFrame->DbI4;
        DebugRegistersSaveArea->DbI5 = SANITIZE_DR(ContextFrame->DbI5,UserMode);
        DebugRegistersSaveArea->DbI6 = ContextFrame->DbI6;
        DebugRegistersSaveArea->DbI7 = SANITIZE_DR(ContextFrame->DbI7,UserMode);

        DebugRegistersSaveArea->DbD0 = ContextFrame->DbD0;
        DebugRegistersSaveArea->DbD1 = SANITIZE_DR(ContextFrame->DbD1,UserMode);
        DebugRegistersSaveArea->DbD2 = ContextFrame->DbD2;
        DebugRegistersSaveArea->DbD3 = SANITIZE_DR(ContextFrame->DbD3,UserMode);
        DebugRegistersSaveArea->DbD4 = ContextFrame->DbD4;
        DebugRegistersSaveArea->DbD5 = SANITIZE_DR(ContextFrame->DbD5,UserMode);
        DebugRegistersSaveArea->DbD6 = ContextFrame->DbD6;
        DebugRegistersSaveArea->DbD7 = SANITIZE_DR(ContextFrame->DbD7,UserMode);

    }
}

VOID
KeContextFromKframes (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN OUT PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified trap and exception
    frames into the specified context frame according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    ExceptionFrame - Supplies a pointer to an exception frame from which context
        should be copied into the context record.

    ContextFrame - Supplies a pointer to the context frame that receives the
        context copied from the trap and exception frames.

Return Value:

    None.

--*/

{
    ULONGLONG IntNats1, IntNats2;
    USHORT R1Offset, R4Offset;
    USHORT RNatSaveIndex;
    SHORT BsFrameSize;
    SHORT TempFrameSize;

    //
    // Set control information if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        ContextFrame->IntGp = TrapFrame->IntGp;
        ContextFrame->IntSp = TrapFrame->IntSp;
        ContextFrame->ApUNAT = TrapFrame->ApUNAT;
        ContextFrame->BrRp = TrapFrame->BrRp;
        ContextFrame->ApCCV = TrapFrame->ApCCV;
        ContextFrame->ApDCR = TrapFrame->ApDCR;

        ContextFrame->StFPSR = TrapFrame->StFPSR;
        ContextFrame->StIPSR = TrapFrame->StIPSR;
        ContextFrame->StIIP = TrapFrame->StIIP;
        ContextFrame->StIFS = TrapFrame->StIFS;


        //
        // Set RSE control states from the trap frame.
        //

        ContextFrame->RsPFS = TrapFrame->RsPFS;

        BsFrameSize = (SHORT)(TrapFrame->StIFS & PFS_SIZE_MASK);
        RNatSaveIndex = (USHORT) (TrapFrame->RsBSP >> 3) & NAT_BITS_PER_RNAT_REG;
        TempFrameSize = BsFrameSize - RNatSaveIndex;
        while (TempFrameSize > 0) {
            BsFrameSize++;
            TempFrameSize -= NAT_BITS_PER_RNAT_REG;
        }

        ContextFrame->RsBSP = TrapFrame->RsBSP - BsFrameSize * 8;
        ContextFrame->RsBSPSTORE = ContextFrame->RsBSP;
        ContextFrame->RsRSC = TrapFrame->RsRSC;
        ContextFrame->RsRNAT = TrapFrame->RsRNAT;

#if DEBUG
        DbgPrint("KeContextFromKFrames: RsRNAT = 0x%I64x\n",
                 ContextFrame->RsRNAT);
#endif // DEBUG

        //
        // Set preserved applicaton registers from exception frame.
        //

        ContextFrame->ApLC = ExceptionFrame->ApLC;
        ContextFrame->ApEC = (ExceptionFrame->ApEC >> PFS_EC_SHIFT) & PFS_EC_MASK;

        //
        // Get iA status from the application registers
        //

        ContextFrame->StFCR = __getReg(CV_IA64_AR21);
        ContextFrame->Eflag = __getReg(CV_IA64_AR24);
        ContextFrame->SegCSD = __getReg(CV_IA64_AR25);
        ContextFrame->SegSSD = __getReg(CV_IA64_AR26);
        ContextFrame->Cflag = __getReg(CV_IA64_AR27);
        ContextFrame->StFSR = __getReg(CV_IA64_AR28);
        ContextFrame->StFIR = __getReg(CV_IA64_AR29);
        ContextFrame->StFDR = __getReg(CV_IA64_AR30);

    }

    //
    // Set integer register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        ContextFrame->IntT0 = TrapFrame->IntT0;
        ContextFrame->IntT1 = TrapFrame->IntT1;
        ContextFrame->IntT2 = TrapFrame->IntT2;
        ContextFrame->IntT3 = TrapFrame->IntT3;
        ContextFrame->IntT4 = TrapFrame->IntT4;
        ContextFrame->IntV0 = TrapFrame->IntV0;
        ContextFrame->IntTeb = TrapFrame->IntTeb;
        ContextFrame->Preds = TrapFrame->Preds;

        //
        // t5 - t22
        //

        memcpy(&ContextFrame->IntT5, &TrapFrame->IntT5, 18*sizeof(ULONGLONG));

        //
        // Set branch registers from trap frame & exception frame
        //

        ContextFrame->BrT0 = TrapFrame->BrT0;
        ContextFrame->BrT1 = TrapFrame->BrT1;

        memcpy(&ContextFrame->BrS0, &ExceptionFrame->BrS0, 5*sizeof(ULONGLONG));

        //
        // Set integer registers s0 - s3 from exception frame.
        //

        ContextFrame->IntS0 = ExceptionFrame->IntS0;
        ContextFrame->IntS1 = ExceptionFrame->IntS1;
        ContextFrame->IntS2 = ExceptionFrame->IntS2;
        ContextFrame->IntS3 = ExceptionFrame->IntS3;

        //
        // Set the integer nats field in the context
        //

        R1Offset = (USHORT)((ULONG_PTR)(&TrapFrame->IntGp) >> 3) & 0x3f;
        R4Offset = (USHORT)((ULONG_PTR)(&ExceptionFrame->IntS0) >> 3) & 0x3f;

        ALIGN_NATS(IntNats1, TrapFrame->IntNats, 1, R1Offset, 0xFFFFFF0E);
        ALIGN_NATS(IntNats2, ExceptionFrame->IntNats, 4, R4Offset, 0xF0);
        ContextFrame->IntNats = IntNats1 | IntNats2;

#if DEBUG
        DbgPrint("KeContextFromKFrames: TF->IntNats = 0x%I64x, R1OffSet = 0x%x, R4Offset = 0x%x\n",
                 TrapFrame->IntNats, R1Offset, R4Offset);
        DbgPrint("KeContextFromKFrames: CF->IntNats = 0x%I64x, IntNats1 = 0x%I64x, IntNats2 = 0x%I64x\n",
                 ContextFrame->IntNats, IntNats1, IntNats2);
#endif // DEBUG

    }

    //
    // Set lower floating register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_LOWER_FLOATING_POINT) == CONTEXT_LOWER_FLOATING_POINT) {

        //
        // Set EM + ia32 FP status
        //

        ContextFrame->StFPSR = TrapFrame->StFPSR;

        //
        // Set floating registers fs0 - fs19 from exception frame.
        //

        RtlCopyIa64FloatRegisterContext(&ContextFrame->FltS0,
                                        &ExceptionFrame->FltS0,
                                        sizeof(FLOAT128) * (4));

        RtlCopyIa64FloatRegisterContext(&ContextFrame->FltS4,
                                        &ExceptionFrame->FltS4,
                                        16*sizeof(FLOAT128));

        //
        // Set floating registers ft0 - ft9 from trap frame.
        //

        RtlCopyIa64FloatRegisterContext(&ContextFrame->FltT0,
                                        &TrapFrame->FltT0,
                                        sizeof(FLOAT128) * (10));

    }

    if ((ContextFrame->ContextFlags & CONTEXT_HIGHER_FLOATING_POINT) == CONTEXT_HIGHER_FLOATING_POINT) {

        ContextFrame->StFPSR = TrapFrame->StFPSR;

        //
        // Set floating regs f32 - f127 from higher floating point save area
        //

        if (TrapFrame->PreviousMode == UserMode) {

            RtlCopyIa64FloatRegisterContext(
                &ContextFrame->FltF32,
                (PFLOAT128)GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(KeGetCurrentThread()->StackBase),
                96*sizeof(FLOAT128)
                );
        }

    }

    //
    // Get user debug registers from save area in kernel stack.
    // Note: PSR.db must be set to activate the debug registers.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_DEBUG) == CONTEXT_DEBUG) {
        KiGetDebugContext(TrapFrame, ContextFrame);
    }

    return;
}

VOID
KeContextToKframes (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextFrame,
    IN ULONG ContextFlags,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified context frame into
    the specified trap and exception frames according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that receives the volatile
        context from the context record.

    ExceptionFrame - Supplies a pointer to an exception frame that receives
        the nonvolatile context from the context record.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied into the trap and exception frames.

    ContextFlags - Supplies the set of flags that specify which parts of the
        context frame are to be copied into the trap and exception frames.

    PreviousMode - Supplies the processor mode for which the trap and exception
        frames are being built.

Return Value:

    None.

--*/

{
    USHORT R1Offset, R4Offset;
    USHORT RNatSaveIndex;
    SHORT BsFrameSize;
    SHORT TempFrameSize;

    //
    // Set control information if specified.
    //

    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        TrapFrame->IntGp = ContextFrame->IntGp;
        TrapFrame->IntSp = ContextFrame->IntSp;
        TrapFrame->ApUNAT = ContextFrame->ApUNAT;
        TrapFrame->BrRp = ContextFrame->BrRp;
        TrapFrame->ApCCV = ContextFrame->ApCCV;
        TrapFrame->ApDCR = SANITIZE_DCR(ContextFrame->ApDCR, PreviousMode);

        //
        // Set preserved applicaton registers in exception frame.
        //

        ExceptionFrame->ApLC = ContextFrame->ApLC;
        ExceptionFrame->ApEC &= ~((ULONGLONG)PFS_EC_MASK << PFS_EC_SHIFT);
        ExceptionFrame->ApEC |= ((ContextFrame->ApEC & PFS_EC_MASK) << PFS_EC_SHIFT);

        //
        // Set RSE control states in the trap frame.
        //

        TrapFrame->RsPFS = SANITIZE_PFS(ContextFrame->RsPFS, PreviousMode);

        BsFrameSize = (SHORT)(ContextFrame->StIFS & PFS_SIZE_MASK);
        RNatSaveIndex = (USHORT)((ContextFrame->RsBSP >> 3) & NAT_BITS_PER_RNAT_REG);

        TempFrameSize = RNatSaveIndex + BsFrameSize - NAT_BITS_PER_RNAT_REG;
        while (TempFrameSize >= 0) {
            BsFrameSize++;
            TempFrameSize -= NAT_BITS_PER_RNAT_REG;
        }

        TrapFrame->RsBSP = ContextFrame->RsBSP + BsFrameSize * 8;
        TrapFrame->RsBSPSTORE = TrapFrame->RsBSP;
        TrapFrame->RsRSC = ContextFrame->RsRSC;
        TrapFrame->RsRNAT = ContextFrame->RsRNAT;
        TrapFrame->EOFMarker = KTRAP_FRAME_EOF | EXCEPTION_FRAME;

#if DEBUG
        DbgPrint("KeContextToKFrames: RsRNAT = 0x%I64x\n", TrapFrame->RsRNAT);
#endif // DEBUG

        //
        // Set FPSR, IPSR, IIP, and IFS in the trap frame.
        //

        TrapFrame->StFPSR = SANITIZE_FSR(ContextFrame->StFPSR, PreviousMode);
        TrapFrame->StIPSR = SANITIZE_PSR(ContextFrame->StIPSR, PreviousMode);
        TrapFrame->StIFS  = SANITIZE_IFS(ContextFrame->StIFS, PreviousMode);
        TrapFrame->StIIP  = ContextFrame->StIIP;

        if (PreviousMode == UserMode ) {
            //
            // DebugActive controls h/w debug registers. Set if new psr.db = 1
            //

            PCR->DebugActive = KeGetCurrentThread()->DebugActive = ((TrapFrame->StIPSR & (1I64 << PSR_DB)) != 0);

            //
            // Set and sanitize iA status
            //

            __setReg(CV_IA64_AR21, SANITIZE_AR21_FCR (ContextFrame->StFCR, UserMode));
            __setReg(CV_IA64_AR24, SANITIZE_AR24_EFLAGS (ContextFrame->Eflag, UserMode));
            __setReg(CV_IA64_AR25, ContextFrame->SegCSD);
            __setReg(CV_IA64_AR26, ContextFrame->SegSSD);
            __setReg(CV_IA64_AR27, SANITIZE_AR27_CFLG (ContextFrame->Cflag, UserMode));

            __setReg(CV_IA64_AR28, SANITIZE_AR28_FSR (ContextFrame->StFSR, UserMode));
            __setReg(CV_IA64_AR29, SANITIZE_AR29_FIR (ContextFrame->StFIR, UserMode));
            __setReg(CV_IA64_AR30, SANITIZE_AR30_FDR (ContextFrame->StFDR, UserMode));
        }
    }

    //
    // Set integer registers contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        TrapFrame->IntT0 = ContextFrame->IntT0;
        TrapFrame->IntT1 = ContextFrame->IntT1;
        TrapFrame->IntT2 = ContextFrame->IntT2;
        TrapFrame->IntT3 = ContextFrame->IntT3;
        TrapFrame->IntT4 = ContextFrame->IntT4;
        TrapFrame->IntV0 = ContextFrame->IntV0;
        TrapFrame->IntTeb = ContextFrame->IntTeb;
        TrapFrame->Preds = ContextFrame->Preds;

        //
        // t5 - t22
        //

        memcpy(&TrapFrame->IntT5, &ContextFrame->IntT5, 18*sizeof(ULONGLONG));

        //
        // Set integer registers s0 - s3 in exception frame.
        //

        ExceptionFrame->IntS0 = ContextFrame->IntS0;
        ExceptionFrame->IntS1 = ContextFrame->IntS1;
        ExceptionFrame->IntS2 = ContextFrame->IntS2;
        ExceptionFrame->IntS3 = ContextFrame->IntS3;

        //
        // Set the integer nats field in the trap & exception frames
        //

        R1Offset = (USHORT)((ULONG_PTR)(&TrapFrame->IntGp) >> 3) & 0x3f;
        R4Offset = (USHORT)((ULONG_PTR)(&ExceptionFrame->IntS0) >> 3) & 0x3f;

        EXTRACT_NATS(TrapFrame->IntNats, ContextFrame->IntNats,
                     1, R1Offset, 0xFFFFFF0E);
        EXTRACT_NATS(ExceptionFrame->IntNats, ContextFrame->IntNats,
                     4, R4Offset, 0xF0);

#if DEBUG
        DbgPrint("KeContextToKFrames: TF->IntNats = 0x%I64x, ContestFrame->IntNats = 0x%I64x, R1OffSet = 0x%x\n",
                 TrapFrame->IntNats, ContextFrame->IntNats, R1Offset);
        DbgPrint("KeContextToKFrames: EF->IntNats = 0x%I64x, R4OffSet = 0x%x\n",
                 ExceptionFrame->IntNats, R4Offset);
#endif // DEBUG

        //
        // Set other branch registers in trap and exception frames
        //

        TrapFrame->BrT0 = ContextFrame->BrT0;
        TrapFrame->BrT1 = ContextFrame->BrT1;

        memcpy(&ExceptionFrame->BrS0, &ContextFrame->BrS0, 5*sizeof(ULONGLONG));

    }

    //
    // Set lower floating register contents if specified.
    //

    if ((ContextFlags & CONTEXT_LOWER_FLOATING_POINT) == CONTEXT_LOWER_FLOATING_POINT) {

        TrapFrame->StFPSR = SANITIZE_FSR(ContextFrame->StFPSR, PreviousMode);

        //
        // Set floating registers fs0 - fs19 in exception frame.
        //

        RtlCopyIa64FloatRegisterContext(&ExceptionFrame->FltS0,
                                        &ContextFrame->FltS0,
                                        sizeof(FLOAT128) * (4));

        RtlCopyIa64FloatRegisterContext(&ExceptionFrame->FltS4,
                                        &ContextFrame->FltS4,
                                        16*sizeof(FLOAT128));

        //
        // Set floating registers ft0 - ft9 in trap frame.
        //

        RtlCopyIa64FloatRegisterContext(&TrapFrame->FltT0,
                                        &ContextFrame->FltT0,
                                        sizeof(FLOAT128) * (10));

    }

    //
    // Set higher floating register contents if specified.
    //

    if ((ContextFlags & CONTEXT_HIGHER_FLOATING_POINT) == CONTEXT_HIGHER_FLOATING_POINT) {

        TrapFrame->StFPSR = SANITIZE_FSR(ContextFrame->StFPSR, PreviousMode);

        if (PreviousMode == UserMode) {

            //
            // Update the higher floating point save area (f32-f127) and
            // set the corresponding modified bit in the PSR to 1.
            //

            RtlCopyIa64FloatRegisterContext(
                (PFLOAT128)GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(KeGetCurrentThread()->StackBase),
                &ContextFrame->FltF32,
                96*sizeof(FLOAT128)
                );

            TrapFrame->StIPSR |= (1i64 << PSR_DFH);
            TrapFrame->StIPSR &= ~(1i64 << PSR_MFH);
        }

    }

    //
    // Set debug registers.
    //

    if ((ContextFlags & CONTEXT_DEBUG) == CONTEXT_DEBUG) {
        KiSetDebugContext (TrapFrame, ContextFrame, PreviousMode);
    }

    return;
}

NTSTATUS
KeFlushUserRseState (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine flushes the user rse state from the kernel backing store to the
    user backing store. The user context frame is update to reflect the new
    context state.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    None.

--*/

{
    SHORT BsFrameSize;
    SHORT RNatSaveIndex;
    SHORT Temp;
    USHORT TearPointOffset;
    ULONGLONG TopBound, BottomBound;
    ULONGLONG UserRnats1, UserRnats2;
    ULONGLONG Mask;
    ULONGLONG BspStoreReal;
    NTSTATUS Status = STATUS_SUCCESS;


    //
    // Copy user stacked registers' contents to user backing store.
    // N.B. Stack overflow could happen.
    //

    try {

        //
        // The RsBSPSTORE value may be incorrect paritcularly if the kernel debugger
        // done a set context on the thread, but the dirty register count in RSE is
        // correct.
        //

        BsFrameSize = (SHORT) (TrapFrame->RsRSC >> RSC_MBZ1);
        BspStoreReal = TrapFrame->RsBSP - BsFrameSize;

        if (BsFrameSize) {

            ULONGLONG Bsp, Rnat, KernelInitBsp;

            //
            // Copy the dirty stacked registers back into the
            // user backing store
            //

            RtlpFlushRSE(&Bsp, &Rnat);
            TearPointOffset = (USHORT) BspStoreReal & 0x1F8;

            KernelInitBsp= (PCR->InitialBStore | TearPointOffset) + BsFrameSize - 8;
            if ((KernelInitBsp | RNAT_ALIGNMENT) != ((Bsp - 8) | RNAT_ALIGNMENT)) {
                Rnat = *(PULONGLONG)(KernelInitBsp | RNAT_ALIGNMENT);
            }

            RtlCopyMemory((PVOID)(BspStoreReal),
                         (PVOID)(PCR->InitialBStore + TearPointOffset),
                         BsFrameSize);

            TopBound = (TrapFrame->RsBSP - 8) | RNAT_ALIGNMENT;
            BottomBound = BspStoreReal | RNAT_ALIGNMENT;

            RNatSaveIndex = TearPointOffset >> 3;
            Mask = (((1ULL << (NAT_BITS_PER_RNAT_REG - RNatSaveIndex)) - 1) << RNatSaveIndex);
            UserRnats1 = TrapFrame->RsRNAT & ((1ULL << RNatSaveIndex) - 1);

            if (TopBound > BottomBound) {

                //
                // user dirty stacked GR span across at least one RNAT
                // boundary; need to deposit the valid RNAT bits from
                // the trap frame into the kernel backing store.  Also,
                // the RNAT field in the trap frame has to be updated.
                //

                UserRnats2 = *(PULONGLONG)BottomBound & Mask;
                *(PULONGLONG)BottomBound = UserRnats1 | UserRnats2;
                TrapFrame->RsRNAT = Rnat;

#if DEBUG
                DbgPrint("KiFlushUserRseState 1: UserRnats1 = 0x%I64x, UserRnats2 = 0x%I64x, TF->RsRNAT = 0x%I64x\n",
                         UserRnats1, UserRnats2, TrapFrame->RsRNAT);
#endif // DEBUG

            } else {

                //
                // user stacked register region does not span across an
                // RNAT boundary; combine the RNAT fields from both the
                // trap frame and the context frame.
                //

                UserRnats2 = Rnat & Mask;
                TrapFrame->RsRNAT = UserRnats1 | UserRnats2;

#if DEBUG
                DbgPrint("KiFlushUserRseState 2: UserRnats1 = 0x%I64x, UserRnats2 = 0x%I64x, TF->RsRNAT = 0x%I64x\n",
                         UserRnats1, UserRnats2, TrapFrame->RsRNAT);
#endif // DEBUG

            }
        }

        //
        // Successfully copied to user backing store; set the user's
        // bspstore to the value of its own bsp.
        // And Zero the loadrs field of RsRSC.
        //

        TrapFrame->RsBSPSTORE = TrapFrame->RsBSP;
        TrapFrame->RsRSC = ZERO_PRELOAD_SIZE(TrapFrame->RsRSC);

    } except (KeFlushRseExceptionFilter(GetExceptionInformation(), &Status)) {

    }

    return Status;
}

VOID
KeContextToKframesSpecial (
    IN PKTHREAD Thread,
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextFrame,
    IN ULONG ContextFlags
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified context frame into
    the specified trap and exception frames according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that receives the volatile
        context from the context record.

    ExceptionFrame - Supplies a pointer to an exception frame that receives
        the nonvolatile context from the context record.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied into the trap and exception frames.

    ContextFlags - Supplies the set of flags that specify which parts of the
        context frame are to be copied into the trap and exception frames.

    PreviousMode - Supplies the processor mode for which the trap and exception
        frames are being built.

Return Value:

    None.

--*/

{
    USHORT R1Offset, R4Offset;
    USHORT RNatSaveIndex;
    SHORT BsFrameSize;
    SHORT TempFrameSize;

    //
    // Set control information if specified.
    //

    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        TrapFrame->IntGp = ContextFrame->IntGp;
        TrapFrame->IntSp = ContextFrame->IntSp;
        TrapFrame->ApUNAT = ContextFrame->ApUNAT;
        TrapFrame->BrRp = ContextFrame->BrRp;
        TrapFrame->ApCCV = ContextFrame->ApCCV;
        TrapFrame->ApDCR = SANITIZE_DCR(ContextFrame->ApDCR, UserMode);

        //
        // Set preserved applicaton registers in exception frame.
        //

        ExceptionFrame->ApLC = ContextFrame->ApLC;
        ExceptionFrame->ApEC &= ~((ULONGLONG)PFS_EC_MASK << PFS_EC_SHIFT);
        ExceptionFrame->ApEC |= ((ContextFrame->ApEC & PFS_EC_MASK) << PFS_EC_SHIFT);

        //
        // Set RSE control states in the trap frame.
        //

        TrapFrame->RsPFS = ContextFrame->RsPFS;

        BsFrameSize = (SHORT)(ContextFrame->StIFS & PFS_SIZE_MASK);
        RNatSaveIndex = (USHORT)((ContextFrame->RsBSP >> 3) & NAT_BITS_PER_RNAT_REG);

        TempFrameSize = RNatSaveIndex + BsFrameSize - NAT_BITS_PER_RNAT_REG;
        while (TempFrameSize >= 0) {
            BsFrameSize++;
            TempFrameSize -= NAT_BITS_PER_RNAT_REG;
        }

        TrapFrame->RsBSP = ContextFrame->RsBSP + BsFrameSize * 8;
        TrapFrame->RsBSPSTORE = TrapFrame->RsBSP;
        TrapFrame->RsRSC = ContextFrame->RsRSC;
        TrapFrame->RsRNAT = ContextFrame->RsRNAT;

#if DEBUG
        DbgPrint("KeContextToKFrames: RsRNAT = 0x%I64x\n", TrapFrame->RsRNAT);
#endif // DEBUG

        //
        // Set FPSR, IPSR, IIP, and IFS in the trap frame.
        //

        TrapFrame->StFPSR = SANITIZE_FSR(ContextFrame->StFPSR, UserMode);
        TrapFrame->StIPSR = SANITIZE_PSR(ContextFrame->StIPSR, UserMode);
        TrapFrame->StIFS  = SANITIZE_IFS(ContextFrame->StIFS, UserMode);
        TrapFrame->StIIP  = ContextFrame->StIIP;

        //
        // Set application registers directly
        //

        if (Thread == KeGetCurrentThread()) {
            //
            // Set and sanitize iA status
            //

            __setReg(CV_IA64_AR21, SANITIZE_AR21_FCR (ContextFrame->StFCR, UserMode));
            __setReg(CV_IA64_AR24, SANITIZE_AR24_EFLAGS (ContextFrame->Eflag, UserMode));
            __setReg(CV_IA64_AR25, ContextFrame->SegCSD);
            __setReg(CV_IA64_AR26, ContextFrame->SegSSD);
            __setReg(CV_IA64_AR27, SANITIZE_AR27_CFLG (ContextFrame->Cflag, UserMode));

            __setReg(CV_IA64_AR28, SANITIZE_AR28_FSR (ContextFrame->StFSR, UserMode));
            __setReg(CV_IA64_AR29, SANITIZE_AR29_FIR (ContextFrame->StFIR, UserMode));
            __setReg(CV_IA64_AR30, SANITIZE_AR30_FDR (ContextFrame->StFDR, UserMode));

        } else {
            PKAPPLICATION_REGISTERS AppRegs;

            AppRegs = GET_APPLICATION_REGISTER_SAVEAREA(Thread->StackBase);
            AppRegs->Ar21 = SANITIZE_AR21_FCR (ContextFrame->StFCR, UserMode);
            AppRegs->Ar24 = SANITIZE_AR24_EFLAGS (ContextFrame->Eflag, UserMode);
            AppRegs->Ar25 = ContextFrame->SegCSD;
            AppRegs->Ar26 = ContextFrame->SegSSD;
            AppRegs->Ar27 = SANITIZE_AR27_CFLG (ContextFrame->Cflag, UserMode);
            AppRegs->Ar28 = SANITIZE_AR28_FSR (ContextFrame->StFSR, UserMode);
            AppRegs->Ar29 = SANITIZE_AR29_FIR (ContextFrame->StFIR, UserMode);
            AppRegs->Ar30 = SANITIZE_AR30_FDR (ContextFrame->StFDR, UserMode);
        }
    }

    //
    // Set integer registers contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        TrapFrame->IntT0 = ContextFrame->IntT0;
        TrapFrame->IntT1 = ContextFrame->IntT1;
        TrapFrame->IntT2 = ContextFrame->IntT2;
        TrapFrame->IntT3 = ContextFrame->IntT3;
        TrapFrame->IntT4 = ContextFrame->IntT4;
        TrapFrame->IntV0 = ContextFrame->IntV0;
        TrapFrame->IntTeb = ContextFrame->IntTeb;
        TrapFrame->Preds = ContextFrame->Preds;

        //
        // t5 - t22
        //

        memcpy(&TrapFrame->IntT5, &ContextFrame->IntT5, 18*sizeof(ULONGLONG));

        //
        // Set integer registers s0 - s3 in exception frame.
        //

        ExceptionFrame->IntS0 = ContextFrame->IntS0;
        ExceptionFrame->IntS1 = ContextFrame->IntS1;
        ExceptionFrame->IntS2 = ContextFrame->IntS2;
        ExceptionFrame->IntS3 = ContextFrame->IntS3;

        //
        // Set the integer nats field in the trap & exception frames
        //

        R1Offset = (USHORT)((ULONG_PTR)(&TrapFrame->IntGp) >> 3) & 0x3f;
        R4Offset = (USHORT)((ULONG_PTR)(&ExceptionFrame->IntS0) >> 3) & 0x3f;

        EXTRACT_NATS(TrapFrame->IntNats, ContextFrame->IntNats,
                     1, R1Offset, 0xFFFFFF0E);
        EXTRACT_NATS(ExceptionFrame->IntNats, ContextFrame->IntNats,
                     4, R4Offset, 0xF0);

#if DEBUG
        DbgPrint("KeContextToKFrames: TF->IntNats = 0x%I64x, ContestFrame->IntNats = 0x%I64x, R1OffSet = 0x%x\n",
                 TrapFrame->IntNats, ContextFrame->IntNats, R1Offset);
        DbgPrint("KeContextToKFrames: EF->IntNats = 0x%I64x, R4OffSet = 0x%x\n",
                 ExceptionFrame->IntNats, R4Offset);
#endif // DEBUG

        //
        // Set other branch registers in trap and exception frames
        //

        TrapFrame->BrT0 = ContextFrame->BrT0;
        TrapFrame->BrT1 = ContextFrame->BrT1;

        memcpy(&ExceptionFrame->BrS0, &ContextFrame->BrS0, 5*sizeof(ULONGLONG));

    }

    //
    // Set lower floating register contents if specified.
    //

    if ((ContextFlags & CONTEXT_LOWER_FLOATING_POINT) == CONTEXT_LOWER_FLOATING_POINT) {

        TrapFrame->StFPSR = SANITIZE_FSR(ContextFrame->StFPSR, UserMode);

        //
        // Set floating registers fs0 - fs19 in exception frame.
        //

        RtlCopyIa64FloatRegisterContext(&ExceptionFrame->FltS0,
                                        &ContextFrame->FltS0,
                                        sizeof(FLOAT128) * (4));

        RtlCopyIa64FloatRegisterContext(&ExceptionFrame->FltS4,
                                        &ContextFrame->FltS4,
                                        16*sizeof(FLOAT128));

        //
        // Set floating registers ft0 - ft9 in trap frame.
        //

        RtlCopyIa64FloatRegisterContext(&TrapFrame->FltT0,
                                        &ContextFrame->FltT0,
                                        sizeof(FLOAT128) * (10));

    }

    //
    // Set higher floating register contents if specified.
    //

    if ((ContextFlags & CONTEXT_HIGHER_FLOATING_POINT) == CONTEXT_HIGHER_FLOATING_POINT) {

        TrapFrame->StFPSR = SANITIZE_FSR(ContextFrame->StFPSR, UserMode);

        //
        // Update the higher floating point save area (f32-f127) and
        // set the corresponding modified bit in the PSR to 1.
        //

        RtlCopyIa64FloatRegisterContext(
            (PFLOAT128)GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(Thread->StackBase),
            &ContextFrame->FltF32,
            96*sizeof(FLOAT128)
            );

        TrapFrame->StIPSR |= (1i64 << PSR_DFH);
        TrapFrame->StIPSR &= ~(1i64 << PSR_MFH);

    }

    //
    // Set debug registers.
    //

    if ((ContextFlags & CONTEXT_DEBUG) == CONTEXT_DEBUG) {
        KiSetDebugContext (TrapFrame, ContextFrame, UserMode);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\debugctx.s ===
#include "ksia64.h"

//--------------------------------------------------------------------
// Routine:
//
//       VOID
//       KiSaveEmDebugContext(
//            IN  OUT PCONTEXT  Context)
//
// Description:
//
//       This function takes the contents of the EM debug registers 
//       and saves them in the specified EM mode Context frame.
//
// Input:
//
//       a0: Context - Pointer to the EM Context frame where the debug 
//                     registers should be saved.
//
// Output:
//
//       Stores the debug registers in the target EM Context frame.
//
// Return value:
//
//       None
//
//
// N.B. The format iA mode FP registers is 80 bits and will not change.
//
//--------------------------------------------------------------------

        LEAF_ENTRY(KiSaveEmDebugContext)

        add         t1 = CxDbD0, a0              // Point at Context's DbD0
        add         t2 = CxDbI0, a0              // Point at Context's DbI0

        mov         t5 = dbr[r0]                 // Get Dbr0         
        mov         t6 = ibr[r0]                 // Get Ibr0         
        ;;

        st8         [t1] = t5, CxDbD1 - CxDbD0   // Save Dbr
        st8         [t2] = t6, CxDbI1 - CxDbI0   // Save Ibr

        add         t3 = 1, r0                   // Next is Dbr1
        add         t4 = 1, r0                   // Next is Ibr1
        ;;
         
        mov         t5 = dbr[t3]                 // Get Dbr1         
        mov         t6 = ibr[t4]                 // Get Ibr1         
        ;;

        st8         [t1] = t5, CxDbD2 - CxDbD1   // Save Dbr
        st8         [t2] = t6, CxDbI2 - CxDbI1   // Save Ibr

        add         t3 = 1, t3                   // Next is Dbr2
        add         t4 = 1, t4                   // Next is Ibr2
        ;;
         
        mov         t5 = dbr[t3]                 // Get Dbr2         
        mov         t6 = ibr[t4]                 // Get Ibr2         
        ;;

        st8         [t1] = t5, CxDbD3 - CxDbD2   // Save Dbr
        st8         [t2] = t6, CxDbI3 - CxDbI2   // Save Ibr

        add         t3 = 1, t3                   // Next is Dbr3
        add         t4 = 1, t4                   // Next is Ibr3
        ;;
         
        mov         t5 = dbr[t3]                 // Get Dbr3         
        mov         t6 = ibr[t4]                 // Get Ibr3         
        ;;

        st8         [t1] = t5, CxDbD4 - CxDbD3   // Save Dbr
        st8         [t2] = t6, CxDbI4 - CxDbI3   // Save Ibr

        add         t3 = 1, t3                   // Next is Dbr4
        add         t4 = 1, t4                   // Next is Ibr4
        ;;
         
        mov         t5 = dbr[t3]                 // Get Dbr4         
        mov         t6 = ibr[t4]                 // Get Ibr4         
        ;;

        st8         [t1] = t5, CxDbD5 - CxDbD4   // Save Dbr
        st8         [t2] = t6, CxDbI5 - CxDbI4   // Save Ibr

        add         t3 = 1, t3                   // Next is Dbr5
        add         t4 = 1, t4                   // Next is Ibr5
        ;;
         
        mov         t5 = dbr[t3]                 // Get Dbr5         
        mov         t6 = ibr[t4]                 // Get Ibr5         
        ;;

        st8         [t1] = t5, CxDbD6 - CxDbD5   // Save Dbr
        st8         [t2] = t6, CxDbI6 - CxDbI5   // Save Ibr

        add         t3 = 1, t3                   // Next is Dbr6
        add         t4 = 1, t4                   // Next is Ibr6
        ;;
         
        mov         t5 = dbr[t3]                 // Get Dbr6         
        mov         t6 = ibr[t4]                 // Get Ibr6         
        ;;

        st8         [t1] = t5, CxDbD7 - CxDbD6   // Save Dbr
        st8         [t2] = t6, CxDbI7 - CxDbI6   // Save Ibr
                                                    
        add         t3 = 1, t3                   // Next is Dbr7
        add         t4 = 1, t4                   // Next is Ibr7
        ;;
         
        mov         t5 = dbr[t3]                 // Get Dbr7         
        mov         t6 = ibr[t4]                 // Get Ibr7         
        ;;

        st8         [t1] = t5, CxFltS0 - CxDbD7  // Save Dbr
        st8         [t2] = t6, CxDbD0  - CxDbI7  // Save Ibr
        br.ret.sptk brp
        ;;

        LEAF_EXIT(KiSaveEmDebugContext)   

//--------------------------------------------------------------------
// Routine:
//
//       VOID
//       KiLoadEmDebugContext(
//          IN  PCONTEXT  Context)
//
// Description:
//
//       This function takes the values stored for the EM debug registers
//       in the specified EM mode Context frame and loads the debug registers
//       for the thread with them.
//
// Input:
//
//       a0: Context - Pointer to the EM Context frame where the debug 
//                     register contents are to be loaded from.
//
// Output:
//
//       None
//
// Return value:
//
//       None
//
// N.B. The format iA mode FP registers is 80 bits and will not change.
//
//--------------------------------------------------------------------
        LEAF_ENTRY(KiLoadEmDebugContext)

        add         t1 = CxDbD0, a0              // Point at Context's DbD0
        add         t2 = CxDbI0, a0              // Point at Context's DbI0
        ;;

        ld8         t5 = [t1], CxDbD1 - CxDbD0   // Load Value for Dbr0 
        ld8         t6 = [t2], CxDbI1 - CxDbI0   // Load Value for Ibr0
         
        ;;
        mov         dbr[r0] = t5                 // Load Dbr0            
        mov         ibr[r0] = t6                 // Load Ibr0            

        add         t3 = 1, r0                   // Start with Dbr1
        add         t4 = 1, r0                   // Start with Ibr1

        ld8         t5 = [t1], CxDbD2 - CxDbD1   // Load Value for Dbr1 
        ld8         t6 = [t2], CxDbI2 - CxDbI1   // Load Value for Ibr1
        ;;
         
        mov         dbr[t3] = t5                 // Load Dbr1            
        mov         ibr[t4] = t6                 // Load Ibr1            

        add         t3 = 2, r0                   // Start with Dbr2
        add         t4 = 2, r0                   // Start with Ibr2

        ld8         t5 = [t1], CxDbD3 - CxDbD2   // Load Value for Dbr2 
        ld8         t6 = [t2], CxDbI3 - CxDbI2   // Load Value for Ibr2
        ;;
         
        mov         dbr[t3] = t5                 // Load Dbr2            
        mov         ibr[t4] = t6                 // Load Ibr2            

        add         t3 = 3, r0                   // Start with Dbr3
        add         t4 = 3, r0                   // Start with Ibr3

        ld8         t5 = [t1], CxDbD4 - CxDbD3   // Load Value for Dbr3 
        ld8         t6 = [t2], CxDbI4 - CxDbI3   // Load Value for Ibr3
        ;;
         
        mov         dbr[t3] = t5                 // Load Dbr3            
        mov         ibr[t4] = t6                 // Load Ibr3            

        add         t3 = 4, r0                   // Start with Dbr4
        add         t4 = 4, r0                   // Start with Ibr4

        ld8         t5 = [t1], CxDbD5 - CxDbD4   // Load Value for Dbr4 
        ld8         t6 = [t2], CxDbI5 - CxDbI4   // Load Value for Ibr4
        ;;
         
        mov         dbr[t3] = t5                 // Load Dbr4            
        mov         ibr[t4] = t6                 // Load Ibr4            

        add         t3 = 5, r0                   // Start with Dbr5
        add         t4 = 5, r0                   // Start with Ibr5

        ld8         t5 = [t1], CxDbD6 - CxDbD5   // Load Value for Dbr5 
        ld8         t6 = [t2], CxDbI6 - CxDbI5   // Load Value for Ibr5
        ;;
         
        mov         dbr[t3] = t5                 // Load Dbr5            
        mov         ibr[t4] = t6                 // Load Ibr5            
                                                                 
        add         t3 = 6, r0                   // Start with Dbr6
        add         t4 = 6, r0                   // Start with Ibr6

        ld8         t5 = [t1], CxDbD7 - CxDbD6   // Load Value for Dbr6 
        ld8         t6 = [t2], CxDbI7 - CxDbI6   // Load Value for Ibr6
        ;;
         
        mov         dbr[t3] = t5                 // Load Dbr6            
        mov         ibr[t4] = t6                 // Load Ibr6            
                                                                 
        add         t3 = 7, r0                   // Start with Dbr7
        add         t4 = 7, r0                   // Start with Ibr7

        ld8         t5 = [t1], CxFltS0- CxDbD7   // Load Value for Dbr7 
        ld8         t6 = [t2], CxDbD0 - CxDbI7   // Load Value for Ibr7
        ;;
         
        mov         dbr[t3] = t5                 // Load Dbr7            
        mov         ibr[t4] = t6                 // Load Ibr7            
        br.ret.sptk brp

        LEAF_EXIT(KiLoadEmDebugContext)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\emfloat.h ===
//
// For compatibility with Ke Emulation and EFI Emulation commented out the header file.
//
// #include "EM_types.h"
// #include "EM_support.h"
// #include "EM_prototypes.h"

typedef struct _BUNDLE {
  EM_uint64_t BundleLow;
  EM_uint64_t BundleHigh;
} BUNDLE;

#ifdef WIN32_OR_WIN64
typedef struct __declspec(align(16)) _FLOAT128_TYPE {
#else
typedef struct _FLOAT128_TYPE {
#endif
     EM_uint64_t loFlt64;
     EM_uint64_t hiFlt64;
} FLOAT128_TYPE;


typedef struct fp_state_low_preserved_s {
  FLOAT128_TYPE fp_lp[4]; // f2-f5; f2=fp_lp[0], f3=fp_lp[1], ...
} FP_STATE_LOW_PRESERVED;

typedef struct fp_state_low_volatile_s {
  FLOAT128_TYPE fp_lv[10]; // f6-f15; f6=fp_lv[0], f7=fp_lv[1], ...
} FP_STATE_LOW_VOLATILE;

typedef struct fp_state_high_preserved_s {
  FLOAT128_TYPE fp_hp[16]; // f16-f31; f16=fp_hp[0], f17=fp_hp[1], ...
} FP_STATE_HIGH_PRESERVED;

typedef struct fp_state_high_volatile_s {
  FLOAT128_TYPE fp_hv[96]; // f32-f127; f32=fp_hv[0], f33=fp_hv[1], ...
} FP_STATE_HIGH_VOLATILE;

typedef struct fp_state_s {
  __int64 bitmask_low64; // f2-f63
  __int64 bitmask_high64; // f64-f127
  FP_STATE_LOW_PRESERVED *fp_state_low_preserved; // f2-f5
  FP_STATE_LOW_VOLATILE *fp_state_low_volatile; // f6-f15
  FP_STATE_HIGH_PRESERVED *fp_state_high_preserved; // f16-f31
  FP_STATE_HIGH_VOLATILE *fp_state_high_volatile; // f32-f127
} FP_STATE;

typedef struct {
  EM_int64_t retval; // r8
  EM_uint64_t err1; // r9
  EM_uint64_t err2; // r10
  EM_uint64_t err3; // r11
} PAL_RETURN;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\em_support.h ===
/******************************
Intel Confidential
******************************/

#ifndef _EM_SUPPORT_H
#define _EM_SUPPORT_H

void
fp82_EM_initialize_state(EM_state_type *ps);


/*******************************************************
Fault handlers -- Start
********************************************************/

/*******************************************************
Defines to get rid of ps in the function declaration
********************************************************/

#define fp_exception_fault(arg1) \
        fp82_fp_exception_fault(EM_state_type *ps, arg1)

#define fp_exception_trap(arg1) \
        fp82_fp_exception_trap(EM_state_type *ps, arg1)

/*******************************************************
Fault prototypes
********************************************************/
INLINE void
fp_exception_fault(EM_uint_t isr_code);
 
INLINE void
fp_exception_trap(EM_uint_t isr_code);
 
/*******************************************************
Fault handlers -- End
********************************************************/

 
/*******************************************************
GET PUT functions
********************************************************/

/*******************************************************
Defines to get rid of ps in GET PUT functions
********************************************************/

#define GETSTATE_F1(qp,f1,f3,f4,f2)         _GETSTATE_F1(EM_state_type *ps, qp,f1,f3,f4,f2)
#define PUTSTATE_F1()                     _PUTSTATE_F1(EM_state_type *ps)

#define GETSTATE_F4(qp,p1,p2,f2,f3)         _GETSTATE_F4(EM_state_type *ps, qp,p1,p2,f2,f3)
#define PUTSTATE_F4()                  _PUTSTATE_F4(EM_state_type *ps)

#define GETSTATE_F6(qp,f1,p2,f2,f3)         _GETSTATE_F6(EM_state_type *ps,qp,f1,p2,f2,f3)
#define PUTSTATE_F6()                  _PUTSTATE_F6(EM_state_type *ps)

#define GETSTATE_F7(qp,f1,p2,f3)            _GETSTATE_F7(EM_state_type *ps, qp,f1,p2,f3)
#define PUTSTATE_F7()                  _PUTSTATE_F7(EM_state_type *ps)

#define GETSTATE_F8(qp,f1,f2,f3)            _GETSTATE_F8(EM_state_type *ps, qp,f1,f2,f3)
#define PUTSTATE_F8()                     _PUTSTATE_F8(EM_state_type *ps)

#define GETSTATE_F10()              _GETSTATE_F10(EM_state_type *ps)
#define PUTSTATE_F10()                    _PUTSTATE_F10(EM_state_type *ps)

/*******************************************************
Prototypes for GET PUT functions
********************************************************/

void
GETSTATE_F1(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_fp_reg_specifier   Fr3,
   EM_fp_reg_specifier   Fr4,
   EM_fp_reg_specifier   Fr2);

void
PUTSTATE_F1();

void
GETSTATE_F4(
   EM_pred_reg_specifier Pr0,
   EM_pred_reg_specifier Pr1,
   EM_pred_reg_specifier Pr2,
   EM_fp_reg_specifier   Fr2,
   EM_fp_reg_specifier   Fr3);

void
PUTSTATE_F4();

void
GETSTATE_F6(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_pred_reg_specifier Pr2,
   EM_fp_reg_specifier   Fr2,
   EM_fp_reg_specifier   Fr3);

void
PUTSTATE_F6();

void
GETSTATE_F7(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_pred_reg_specifier Pr2,
   EM_fp_reg_specifier   Fr3);

void
PUTSTATE_F7();

void
GETSTATE_F8(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_fp_reg_specifier   Fr2,
   EM_fp_reg_specifier   Fr3);

void
PUTSTATE_F8();

void
GETSTATE_F10();

void
PUTSTATE_F10();


/******************************************************************************/
/* Define macros to make transformation to the EAS easier                     */
/******************************************************************************/

#define get_bit(val, bit) \
  ((val >> bit) &0x1)

   
/******************************************************************************/
/* Define macros to simplify access to the fp82_ functions.  This is done so  */
/*  the namespace doesn't get cluttered, while retaining convenient access.   */
/*  The FP82_NO_SHORTCUTS macro can be defined to prevent creation of these.  */
/******************************************************************************/

#ifndef FP82_NO_SHORTCUTS
#define EM_initialize_state             fp82_EM_initialize_state

#endif /* FP82_NO_SHORTCUTS */

#endif /* _EM_SUPPORT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\em_types.h ===
/******************************
Intel Confidential
******************************/

/* define the following for WindowsNT only */
#define WIN32_OR_WIN64

#ifdef WIN32_OR_WIN64
#define LX "%I64x"
#define LD "%I64d"
#else
#define LX "%Lx"
#define LD "%Ld"
#endif

/******************************************************************
Due to differences in format of the constants we need to wrap is
with a macro to help add the LL on all platforms other than NT
*******************************************************************/
#ifndef WIN32_OR_WIN64
#define CONST_FORMAT(num) num ## LL
#else
#define CONST_FORMAT(num) ((EM_uint64_t)(num))
#endif

#ifndef _EM_TYPES_H
#define _EM_TYPES_H

// Exception Codes for Emulation Traps and Faults
#define STATUS_EMULATION_FAULT   0x0E0010000
#define STATUS_EMULATION_TRAP    0x0E0020000

#define LITTLE_ENDIAN

#define MAX_REAL_GR_INDEX             1
#define MAX_REAL_FR_INDEX             128

#define EM_NUM_PR        64
#define EM_NUM_MEM        1


#ifndef INLINE
#define INLINE
#endif

#if !(defined(BIG_ENDIAN) || defined(LITTLE_ENDIAN))
    #error Endianness not established; define BIG_ENDIAN or LITTLE_ENDIAN
#endif



/***********************/
/* Basic Integer Types */
/***********************/
 
typedef int                EM_int_t;      /* 32-bit signed integer */
typedef unsigned int       EM_uint_t;     /* 32-bit unsigned integer */

typedef short              EM_short_t;    /* 16-bit signed integer */
typedef unsigned short     EM_ushort_t;   /* 16-bit unsigned integer */

typedef unsigned int       EM_boolean_t;  /* true (1) or false (0) */

#ifdef WIN32_OR_WIN64
typedef __int64            EM_int64_t;    /* 64-bit signed integer */
typedef unsigned __int64   EM_uint64_t;   /* 64-bit unsigned integer */

#else

#ifndef unix
typedef long long          EM_int64_t;    // 64-bit signed integer
typedef unsigned long long EM_uint64_t;   // 64-bit unsigned integer
#else
typedef long               EM_int64_t;    // 64-bit signed integer
typedef unsigned long      EM_uint64_t;   // 64-bit unsigned integer
#endif

#endif
 
/*******************************************************************************
FP_EXCP_xxx - Define a typedef for function pointers to override exceptions.
*****************************************************************************/

typedef void (*FP_EXCP_FAULT)(void*, EM_uint_t);
typedef void (*FP_EXCP_TRAP)(void*, EM_uint_t);
typedef void (*FP_EXCP_SPEC)(void*, EM_uint_t, EM_uint64_t);


typedef struct uint128_struct {
#ifdef BIG_ENDIAN
    EM_uint64_t hi;
    EM_uint64_t lo;
#endif
#ifdef LITTLE_ENDIAN
    EM_uint64_t lo;
    EM_uint64_t hi;
#endif
} EM_uint128_t;                          /* 128-bit unsigned integer */
 
typedef struct uint256_struct {
#ifdef BIG_ENDIAN
    EM_uint64_t hh;
    EM_uint64_t hl;
    EM_uint64_t lh;
    EM_uint64_t ll;
#endif
#ifdef LITTLE_ENDIAN
    EM_uint64_t ll;
    EM_uint64_t lh;
    EM_uint64_t hl;
    EM_uint64_t hh;
#endif
} EM_uint256_t;                          /* 256-bit unsigned integer */

/******************/
/* Support enum's */
/******************/

typedef enum {
    pr_00 =  0, pr_01 =  1, pr_02 =  2, pr_03 =  3,
    pr_04 =  4, pr_05 =  5, pr_06 =  6, pr_07 =  7,
    pr_08 =  8, pr_09 =  9, pr_10 = 10, pr_11 = 11,
    pr_12 = 12, pr_13 = 13, pr_14 = 14, pr_15 = 15,

    pr_16 = 16, pr_17 = 17, pr_18 = 18, pr_19 = 19,
    pr_20 = 20, pr_21 = 21, pr_22 = 22, pr_23 = 23,
    pr_24 = 24, pr_25 = 25, pr_26 = 26, pr_27 = 27,
    pr_28 = 28, pr_29 = 29, pr_30 = 30, pr_31 = 31,
    pr_32 = 32, pr_33 = 33, pr_34 = 34, pr_35 = 35,
    pr_36 = 36, pr_37 = 37, pr_38 = 38, pr_39 = 39,
    pr_40 = 40, pr_41 = 41, pr_42 = 42, pr_43 = 43,
    pr_44 = 44, pr_45 = 45, pr_46 = 46, pr_47 = 47,
    pr_48 = 48, pr_49 = 49, pr_50 = 50, pr_51 = 51,
    pr_52 = 52, pr_53 = 53, pr_54 = 54, pr_55 = 55,
    pr_56 = 56, pr_57 = 57, pr_58 = 58, pr_59 = 59,
    pr_60 = 60, pr_61 = 61, pr_62 = 62, pr_63 = 63
} EM_pred_reg_specifier;

typedef enum {
    gr_000 =   0, gr_001 =   1, gr_002 =   2, gr_003 =   3,
    gr_004 =   4, gr_005 =   5, gr_006 =   6, gr_007 =   7,
    gr_008 =   8, gr_009 =   9, gr_010 =  10, gr_011 =  11,
    gr_012 =  12, gr_013 =  13, gr_014 =  14, gr_015 =  15,
    gr_016 =  16, gr_017 =  17, gr_018 =  18, gr_019 =  19,
    gr_020 =  20, gr_021 =  21, gr_022 =  22, gr_023 =  23,
    gr_024 =  24, gr_025 =  25, gr_026 =  26, gr_027 =  27,
    gr_028 =  28, gr_029 =  29, gr_030 =  30, gr_031 =  31,

    gr_032 =  32, gr_033 =  33, gr_034 =  34, gr_035 =  35,
    gr_036 =  36, gr_037 =  37, gr_038 =  38, gr_039 =  39,
    gr_040 =  40, gr_041 =  41, gr_042 =  42, gr_043 =  43,
    gr_044 =  44, gr_045 =  45, gr_046 =  46, gr_047 =  47,
    gr_048 =  48, gr_049 =  49, gr_050 =  50, gr_051 =  51,
    gr_052 =  52, gr_053 =  53, gr_054 =  54, gr_055 =  55,
    gr_056 =  56, gr_057 =  57, gr_058 =  58, gr_059 =  59,
    gr_060 =  60, gr_061 =  61, gr_062 =  62, gr_063 =  63,
    gr_064 =  64, gr_065 =  65, gr_066 =  66, gr_067 =  67,
    gr_068 =  68, gr_069 =  69, gr_070 =  70, gr_071 =  71,
    gr_072 =  72, gr_073 =  73, gr_074 =  74, gr_075 =  75,
    gr_076 =  76, gr_077 =  77, gr_078 =  78, gr_079 =  79,
    gr_080 =  80, gr_081 =  81, gr_082 =  82, gr_083 =  83,
    gr_084 =  84, gr_085 =  85, gr_086 =  86, gr_087 =  87,
    gr_088 =  88, gr_089 =  89, gr_090 =  90, gr_091 =  91,
    gr_092 =  92, gr_093 =  93, gr_094 =  94, gr_095 =  95,
    gr_096 =  96, gr_097 =  97, gr_098 =  98, gr_099 =  99,
    gr_100 = 100, gr_101 = 101, gr_102 = 102, gr_103 = 103,
    gr_104 = 104, gr_105 = 105, gr_106 = 106, gr_107 = 107,
    gr_108 = 108, gr_109 = 109, gr_110 = 110, gr_111 = 111,
    gr_112 = 112, gr_113 = 113, gr_114 = 114, gr_115 = 115,
    gr_116 = 116, gr_117 = 117, gr_118 = 118, gr_119 = 119,
    gr_120 = 120, gr_121 = 121, gr_122 = 122, gr_123 = 123,
    gr_124 = 124, gr_125 = 125, gr_126 = 126, gr_127 = 127
} EM_general_register_specifier;


typedef enum {
    fr_000 =   0, fr_001 =   1, fr_002 =   2, fr_003 =   3,
    fr_004 =   4, fr_005 =   5, fr_006 =   6, fr_007 =   7,
    fr_008 =   8, fr_009 =   9, fr_010 =  10, fr_011 =  11,
    fr_012 =  12, fr_013 =  13, fr_014 =  14, fr_015 =  15,
    fr_016 =  16, fr_017 =  17, fr_018 =  18, fr_019 =  19,
    fr_020 =  20, fr_021 =  21, fr_022 =  22, fr_023 =  23,
    fr_024 =  24, fr_025 =  25, fr_026 =  26, fr_027 =  27,
    fr_028 =  28, fr_029 =  29, fr_030 =  30, fr_031 =  31,

    fr_032 =  32, fr_033 =  33, fr_034 =  34, fr_035 =  35,
    fr_036 =  36, fr_037 =  37, fr_038 =  38, fr_039 =  39,
    fr_040 =  40, fr_041 =  41, fr_042 =  42, fr_043 =  43,
    fr_044 =  44, fr_045 =  45, fr_046 =  46, fr_047 =  47,
    fr_048 =  48, fr_049 =  49, fr_050 =  50, fr_051 =  51,
    fr_052 =  52, fr_053 =  53, fr_054 =  54, fr_055 =  55,
    fr_056 =  56, fr_057 =  57, fr_058 =  58, fr_059 =  59,
    fr_060 =  60, fr_061 =  61, fr_062 =  62, fr_063 =  63,
    fr_064 =  64, fr_065 =  65, fr_066 =  66, fr_067 =  67,
    fr_068 =  68, fr_069 =  69, fr_070 =  70, fr_071 =  71,
    fr_072 =  72, fr_073 =  73, fr_074 =  74, fr_075 =  75,
    fr_076 =  76, fr_077 =  77, fr_078 =  78, fr_079 =  79,
    fr_080 =  80, fr_081 =  81, fr_082 =  82, fr_083 =  83,
    fr_084 =  84, fr_085 =  85, fr_086 =  86, fr_087 =  87,
    fr_088 =  88, fr_089 =  89, fr_090 =  90, fr_091 =  91,
    fr_092 =  92, fr_093 =  93, fr_094 =  94, fr_095 =  95,
    fr_096 =  96, fr_097 =  97, fr_098 =  98, fr_099 =  99,
    fr_100 = 100, fr_101 = 101, fr_102 = 102, fr_103 = 103,
    fr_104 = 104, fr_105 = 105, fr_106 = 106, fr_107 = 107,
    fr_108 = 108, fr_109 = 109, fr_110 = 110, fr_111 = 111,
    fr_112 = 112, fr_113 = 113, fr_114 = 114, fr_115 = 115,
    fr_116 = 116, fr_117 = 117, fr_118 = 118, fr_119 = 119,
    fr_120 = 120, fr_121 = 121, fr_122 = 122, fr_123 = 123,
    fr_124 = 124, fr_125 = 125, fr_126 = 126, fr_127 = 127
} EM_fp_reg_specifier;

typedef enum {
    mem_real_form    = 0,
    mem_integer_form = 1
} EM_mem_fr_format_type;


typedef enum {
    pc_s    = 0,
    pc_d    = 2,
    pc_sf   = 3,
    pc_none = 4,
    pc_simd = 5
} EM_opcode_pc_type;

typedef enum {
    sfS0   = 0,
    sfS1   = 1,
    sfS2   = 2,
    sfS3   = 3,
    sf_none = 4
} EM_opcode_sf_type;

typedef enum {
    fctypeUNC      = 0,
    ctype_or       = 1,
    ctype_and      = 2,
    ctype_or_andcm = 3,
    ctype_orcm     = 4,
    ctype_andcm    = 5,
    ctype_and_orcm = 6,
    ctype_none     = 7
} EM_opcode_ctype_type;

typedef enum {
    crel_eq  = 0,
    crel_ne  = 1,
    crel_lt  = 2,
    crel_le  = 3,
    crel_gt  = 4,
    crel_ge  = 5,
    crel_ltu = 6,
    crel_leu = 7,
    crel_gtu = 8,
    crel_geu = 9
} EM_opcode_crel_type;


typedef enum {
    fcrel_nm  = 0,
    fcrel_m   = 1
} EM_opcode_fcrel_type;

typedef enum {
    frelEQ    =  0,
    frelLT    =  1,
    frelLE    =  2,
    frelUNORD =  3,
    frelNEQ   =  4,
    frelNLT   =  5,
    frelNLE   =  6,
    frelORD   =  7,
    frelGT    =  8,
    frelGE    =  9,
    frelNGT   = 10,
    frelNGE   = 11
} EM_opcode_frel_type;

typedef enum {
    sf_single             = 0,
    SF_PC_RESERVED        = 1,
    sf_double             = 2,
    sf_double_extended    = 3
} EM_sf_pc_type;

typedef enum {
    rc_rn = 0,
    rc_rm = 1,
    rc_rp = 2,
    rc_rz = 3
} EM_sf_rc_type;

typedef enum {
    ar_fpsr = 0
} EM_ar_index;

typedef enum {
    high = 1,
    low  = 0
} EM_simd_hilo;

typedef enum {
    op_fcmp        = 0,
    op_fpcmp       = 1,
    op_fcvt_fx     = 2,
    op_fpcvt_fx    = 3,
    op_fcvt_fxu    = 4,
    op_fpcvt_fxu   = 5,
    op_fma         = 6,
    op_fpma        = 7,
    op_fminmax     = 8,
    op_fpminmax    = 9,
    op_fms_fnma    = 10,
    op_fpms_fpnma  = 11,
    op_frcpa       = 12,
    op_fprcpa      = 13,
    op_frsqrta     = 14,
    op_fprsqrta    = 15,
    op_fnorm       = 16,
    op_fsetc       = 17
 } EM_opcode_type;

    
typedef struct EM_limits_check_fprcpa_struct {
   EM_uint_t  hi_fr3;
   EM_uint_t  hi_fr2_or_quot;
   EM_uint_t  lo_fr3;
   EM_uint_t  lo_fr2_or_quot;
} EM_limits_check_fprcpa;

typedef struct EM_limits_check_fprsqrta_struct {
   EM_uint_t  hi;
   EM_uint_t  lo;
} EM_limits_check_fprsqrta;

/***************************/
/* Support Structure Types */
/***************************/


typedef struct trap_control_struct {
    EM_uint_t vd:1;
    EM_uint_t dd:1;
    EM_uint_t zd:1;
    EM_uint_t od:1;
    EM_uint_t ud:1;
    EM_uint_t id:1;
} EM_trap_control_type;

typedef enum {
    ss_single_24          = 24,
    ss_double_53          = 53,
    ss_double_extended_64 = 64
} EM_significand_size_type;

typedef enum {
    es_eight_bits     =  8,
    es_eleven_bits    = 11,
    es_fifteen_bits   = 15,
    es_seventeen_bits = 17
} EM_exponent_size_type;

typedef struct controls_struct {
    EM_uint_t ftz:1;
    EM_uint_t wre:1;
    EM_sf_pc_type pc;
    EM_sf_rc_type rc;
    EM_uint_t td:1;
} EM_controls_type;

typedef struct flags_struct {
    EM_uint_t v:1;
    EM_uint_t d:1;
    EM_uint_t z:1;
    EM_uint_t o:1;
    EM_uint_t un:1;
    EM_uint_t i:1;
} EM_flags_type;

typedef struct tmp_fp_env_struct {
    long                     dummy;
    EM_trap_control_type     controls;
    EM_significand_size_type ss;
    EM_exponent_size_type    es;

    EM_sf_rc_type            rc;
    EM_uint_t                ftz:1;

    EM_flags_type            flags;
    EM_flags_type            hi_flags;
    EM_flags_type            lo_flags;

    EM_uint_t                ebc:1;
    EM_uint_t                fpa:1;
    EM_uint_t                hi_fpa:1;
    EM_uint_t                lo_fpa:1;
    EM_uint_t                mdl:1;
    EM_uint_t                mdh:1;
    EM_uint_t                simd:1;

    struct em_faults_struct {
        EM_uint_t v:1;
        EM_uint_t d:1;
        EM_uint_t z:1;
        EM_uint_t swa:1;
    } em_faults;
    struct hi_faults_struct {
        EM_uint_t v:1;
        EM_uint_t d:1;
        EM_uint_t z:1;
        EM_uint_t swa:1;
    } hi_faults;
    struct lo_faults_struct {
        EM_uint_t v:1;
        EM_uint_t d:1;
        EM_uint_t z:1;
        EM_uint_t swa:1;
    } lo_faults;

    struct em_traps_struct {
        EM_uint_t o:1;
        EM_uint_t un:1;
        EM_uint_t i:1;
    } em_traps;
    struct hi_traps_struct {
        EM_uint_t o:1;
        EM_uint_t un:1;
        EM_uint_t i:1;
    } hi_traps;
    struct lo_traps_struct {
        EM_uint_t o:1;
        EM_uint_t un:1;
        EM_uint_t i:1;
    } lo_traps;
} EM_tmp_fp_env_type;

typedef struct fp_dp_struct {
    EM_uint_t sticky:1;
    EM_uint128_t significand;
    EM_uint_t exponent:19;
    EM_uint_t sign:1;
} EM_fp_dp_type;

/*************************/
/* Register Definitions */
/*************************/

typedef struct gr_reg_struct {
    EM_uint64_t value;
    EM_uint_t nat:1;
} EM_gr_reg_type;

typedef struct fp_reg_struct {
    EM_uint64_t significand;
    EM_uint_t exponent:17;
    EM_uint_t sign:1;
} EM_fp_reg_type;

typedef struct pair_fp_reg_struct {
    EM_fp_reg_type hi;
    EM_fp_reg_type lo;
} EM_pair_fp_reg_type;

typedef struct sf_struct {
    EM_controls_type controls;
    EM_flags_type    flags;
} EM_sf_type;

typedef struct cfm_struct {
#ifdef BIG_ENDIAN
    EM_uint_t reserved         :26;
    EM_uint_t rrb_pr           : 6;
    EM_uint_t sof              : 7;
    EM_uint_t sol              : 7;
    EM_uint_t sor              : 4;
    EM_uint_t rrb_gr           : 7;
    EM_uint_t rrb_fr           : 7;
#endif
#ifdef LITTLE_ENDIAN
    EM_uint_t rrb_fr           : 7;
    EM_uint_t rrb_gr           : 7;
    EM_uint_t sor              : 4;
    EM_uint_t sol              : 7;
    EM_uint_t sof              : 7;
    EM_uint_t rrb_pr           : 6;
    EM_uint_t reserved         :26;
#endif
} EM_cfm_type;

typedef struct fpsr_struct {
#ifdef BIG_ENDIAN
    EM_uint_t reserved         : 6;
    EM_uint_t sf3_flags_i      : 1;
    EM_uint_t sf3_flags_u      : 1;
    EM_uint_t sf3_flags_o      : 1;
    EM_uint_t sf3_flags_z      : 1;
    EM_uint_t sf3_flags_d      : 1;
    EM_uint_t sf3_flags_v      : 1;
    EM_uint_t sf3_controls_td  : 1;
    EM_uint_t sf3_controls_rc  : 2;
    EM_uint_t sf3_controls_pc  : 2;
    EM_uint_t sf3_controls_wre : 1;
    EM_uint_t sf3_controls_ftz : 1;
    EM_uint_t sf2_flags_i      : 1;
    EM_uint_t sf2_flags_u      : 1;
    EM_uint_t sf2_flags_o      : 1;
    EM_uint_t sf2_flags_z      : 1;
    EM_uint_t sf2_flags_d      : 1;
    EM_uint_t sf2_flags_v      : 1;
    EM_uint_t sf2_controls_td  : 1;
    EM_uint_t sf2_controls_rc  : 2;
    EM_uint_t sf2_controls_pc  : 2;
    EM_uint_t sf2_controls_wre : 1;
    EM_uint_t sf2_controls_ftz : 1;
    EM_uint_t sf1_flags_i      : 1;
    EM_uint_t sf1_flags_u      : 1;
    EM_uint_t sf1_flags_o      : 1;
    EM_uint_t sf1_flags_z      : 1;
    EM_uint_t sf1_flags_d      : 1;
    EM_uint_t sf1_flags_v      : 1;
    EM_uint_t sf1_controls_td  : 1;
    EM_uint_t sf1_controls_rc  : 2;
    EM_uint_t sf1_controls_pc  : 2;
    EM_uint_t sf1_controls_wre : 1;
    EM_uint_t sf1_controls_ftz : 1;
    EM_uint_t sf0_flags_i      : 1;
    EM_uint_t sf0_flags_u      : 1;
    EM_uint_t sf0_flags_o      : 1;
    EM_uint_t sf0_flags_z      : 1;
    EM_uint_t sf0_flags_d      : 1;
    EM_uint_t sf0_flags_v      : 1;
    EM_uint_t sf0_controls_td  : 1;
    EM_uint_t sf0_controls_rc  : 2;
    EM_uint_t sf0_controls_pc  : 2;
    EM_uint_t sf0_controls_wre : 1;
    EM_uint_t sf0_controls_ftz : 1;
    EM_uint_t traps_id         : 1;
    EM_uint_t traps_ud         : 1;
    EM_uint_t traps_od         : 1;
    EM_uint_t traps_zd         : 1;
    EM_uint_t traps_dd         : 1;
    EM_uint_t traps_vd         : 1;
#endif
#ifdef LITTLE_ENDIAN
    EM_uint_t traps_vd         : 1;
    EM_uint_t traps_dd         : 1;
    EM_uint_t traps_zd         : 1;
    EM_uint_t traps_od         : 1;
    EM_uint_t traps_ud         : 1;
    EM_uint_t traps_id         : 1;
    EM_uint_t sf0_controls_ftz : 1;
    EM_uint_t sf0_controls_wre : 1;
    EM_uint_t sf0_controls_pc  : 2;
    EM_uint_t sf0_controls_rc  : 2;
    EM_uint_t sf0_controls_td  : 1;
    EM_uint_t sf0_flags_v      : 1;
    EM_uint_t sf0_flags_d      : 1;
    EM_uint_t sf0_flags_z      : 1;
    EM_uint_t sf0_flags_o      : 1;
    EM_uint_t sf0_flags_u      : 1;
    EM_uint_t sf0_flags_i      : 1;
    EM_uint_t sf1_controls_ftz : 1;
    EM_uint_t sf1_controls_wre : 1;
    EM_uint_t sf1_controls_pc  : 2;
    EM_uint_t sf1_controls_rc  : 2;
    EM_uint_t sf1_controls_td  : 1;
    EM_uint_t sf1_flags_v      : 1;
    EM_uint_t sf1_flags_d      : 1;
    EM_uint_t sf1_flags_z      : 1;
    EM_uint_t sf1_flags_o      : 1;
    EM_uint_t sf1_flags_u      : 1;
    EM_uint_t sf1_flags_i      : 1;
    EM_uint_t sf2_controls_ftz : 1;
    EM_uint_t sf2_controls_wre : 1;
    EM_uint_t sf2_controls_pc  : 2;
    EM_uint_t sf2_controls_rc  : 2;
    EM_uint_t sf2_controls_td  : 1;
    EM_uint_t sf2_flags_v      : 1;
    EM_uint_t sf2_flags_d      : 1;
    EM_uint_t sf2_flags_z      : 1;
    EM_uint_t sf2_flags_o      : 1;
    EM_uint_t sf2_flags_u      : 1;
    EM_uint_t sf2_flags_i      : 1;
    EM_uint_t sf3_controls_ftz : 1;
    EM_uint_t sf3_controls_wre : 1;
    EM_uint_t sf3_controls_pc  : 2;
    EM_uint_t sf3_controls_rc  : 2;
    EM_uint_t sf3_controls_td  : 1;
    EM_uint_t sf3_flags_v      : 1;
    EM_uint_t sf3_flags_d      : 1;
    EM_uint_t sf3_flags_z      : 1;
    EM_uint_t sf3_flags_o      : 1;
    EM_uint_t sf3_flags_u      : 1;
    EM_uint_t sf3_flags_i      : 1;
    EM_uint_t reserved         : 6;
#endif
} EM_fpsr_type;


typedef struct psr_struct {
#ifdef BIG_ENDIAN
    EM_uint_t reserved_field_4:19;
    EM_uint_t bn:1;
    EM_uint_t ed:1;
    EM_uint_t ri:2;
    EM_uint_t ss:1;
    EM_uint_t dd:1;
    EM_uint_t da:1;
    EM_uint_t id:1;
    EM_uint_t it:1;
    EM_uint_t mc:1;
    EM_uint_t is:1;
    EM_uint_t cpl:2;
    EM_uint_t reserved_field_3:4;
    EM_uint_t rt:1;
    EM_uint_t tb:1;
    EM_uint_t lp:1;
    EM_uint_t db:1;
    EM_uint_t si:1;
    EM_uint_t di:1;
    EM_uint_t pp:1;
    EM_uint_t sp:1;
    EM_uint_t dfh:1;
    EM_uint_t dfl:1;
    EM_uint_t dt:1;
    EM_uint_t reserved_field_2:1;
    EM_uint_t pk:1;
    EM_uint_t i:1;
    EM_uint_t ic:1;
    EM_uint_t reserved_field_1:7;
    EM_uint_t mfh:1;
    EM_uint_t mfl:1;
    EM_uint_t ac:1;
    EM_uint_t up:1;
    EM_uint_t be:1;
    EM_uint_t or:1;
#endif
#ifdef LITTLE_ENDIAN
    EM_uint_t or:1;
    EM_uint_t be:1;
    EM_uint_t up:1;
    EM_uint_t ac:1;
    EM_uint_t mfl:1;
    EM_uint_t mfh:1;
    EM_uint_t reserved_field_1:7;
    EM_uint_t ic:1;
    EM_uint_t i:1;
    EM_uint_t pk:1;
    EM_uint_t reserved_field_2:1;
    EM_uint_t dt:1;
    EM_uint_t dfl:1;
    EM_uint_t dfh:1;
    EM_uint_t sp:1;
    EM_uint_t pp:1;
    EM_uint_t di:1;
    EM_uint_t si:1;
    EM_uint_t db:1;
    EM_uint_t lp:1;
    EM_uint_t tb:1;
    EM_uint_t rt:1;
    EM_uint_t reserved_field_3:4;
    EM_uint_t cpl:2;
    EM_uint_t is:1;
    EM_uint_t mc:1;
    EM_uint_t it:1;
    EM_uint_t id:1;
    EM_uint_t da:1;
    EM_uint_t dd:1;
    EM_uint_t ss:1;
    EM_uint_t ri:2;
    EM_uint_t ed:1;
    EM_uint_t bn:1;
    EM_uint_t reserved_field_4:19;
#endif
} EM_psr_type;

typedef union ar_union {
    EM_fpsr_type fpsr;
    EM_uint64_t  uint_value;
} EM_ar_type;

/*****************************/
/* memory format definitions */
/*****************************/

typedef union memory_union {
        struct int_8_struct {
            EM_int_t ivalue:8;
        } int_8;
        struct int_16_struct {
            EM_int_t ivalue:16;
        } int_16;
        struct int_32_struct {
            EM_int_t ivalue:32;
        } int_32;
        struct int_64_struct {
            EM_int64_t ivalue;
        } int_64;
        struct uint_8_struct {
            EM_uint_t uvalue:8;
        } uint_8;
        struct uint_16_struct {
            EM_uint_t uvalue:16;
        } uint_16;
        struct uint_32_struct {
            EM_uint_t uvalue:32;
        } uint_32;
        struct uint_64_struct {
            EM_uint64_t uvalue;
        } uint_64;
        struct c_float_struct {
            float fvalue;
        } c_float;
        struct c_double_struct {
            double fvalue;
        } c_double;
        struct c_long_double_struct {
            long double fvalue;
        } c_long_double;

        struct fp_single_struct {
#ifdef BIG_ENDIAN
            EM_uint_t sign:1;
            EM_uint_t exponent:8;
            EM_uint_t significand:23;
#endif
#ifdef LITTLE_ENDIAN
            EM_uint_t significand:23;
            EM_uint_t exponent:8;
            EM_uint_t sign:1;
#endif
        } fp_single;

        struct fp_double_struct {
#ifdef BIG_ENDIAN
            EM_uint_t sign:1;
            EM_uint_t exponent:11;
            EM_uint_t significand_hi:20;
            EM_uint_t significand_lo:32;
#endif
#ifdef LITTLE_ENDIAN
            EM_uint_t significand_lo:32;
            EM_uint_t significand_hi:20;
            EM_uint_t exponent:11;
            EM_uint_t sign:1;

#endif
        } fp_double;

        struct fp_double_extended_struct {
#ifdef BIG_ENDIAN
            EM_uint_t sign:1;
            EM_uint_t exponent:15;
            EM_ushort_t significand[4];
#endif
#ifdef LITTLE_ENDIAN
            EM_ushort_t significand[4];
            EM_uint_t exponent:15;
            EM_uint_t sign:1;
#endif
        } fp_double_extended;

        struct fp_spill_fill_struct {
#ifdef BIG_ENDIAN
            EM_uint_t reserved2:32;
            EM_uint_t reserved1:14;
            EM_uint_t sign:1;
            EM_uint_t exponent:17;
            EM_uint64_t significand;
#endif
#ifdef LITTLE_ENDIAN
            EM_uint64_t significand;
            EM_uint_t exponent:17;
            EM_uint_t sign:1;
            EM_uint_t reserved1:14;
            EM_uint_t reserved2:32;
#endif
        } fp_spill_fill;


        struct uint_32_pair_struct {
#ifdef BIG_ENDIAN
            EM_uint_t hi:32;
            EM_uint_t lo:32;
#endif
#ifdef LITTLE_ENDIAN
            EM_uint_t lo:32;
            EM_uint_t hi:32;
#endif
        } uint_32_pair;
        struct uint_64_pair_struct {
#ifdef BIG_ENDIAN
            EM_uint64_t hi;
            EM_uint64_t lo;
#endif
#ifdef LITTLE_ENDIAN
            EM_uint64_t lo;
            EM_uint64_t hi;
#endif
        } uint_64_pair;

} EM_memory_type;

typedef struct EM_form_struct {
  EM_boolean_t advanced_form;
  EM_boolean_t clear_form;
  EM_boolean_t double_form;
  EM_boolean_t exponent_form;

  EM_boolean_t fp82_floating_form;
  EM_boolean_t fcheck_branch_implemented;
  EM_boolean_t general_form;
  EM_boolean_t data_form;
  EM_boolean_t control_form;
  EM_boolean_t high_form;
  EM_boolean_t high_unsigned_form;

  EM_boolean_t low_form;
  EM_boolean_t mix_l_form;
  EM_boolean_t mix_r_form;
  EM_boolean_t mix_lr_form;

  EM_boolean_t neg_sign_form;
  EM_boolean_t no_clear_form;
  EM_boolean_t pack_form;

  EM_boolean_t no_base_update_form;
  EM_boolean_t immediate_base_update_form;
  EM_boolean_t register_base_update_form;

  EM_boolean_t sign_form;
  EM_boolean_t sign_exp_form;
  EM_boolean_t signed_form;
  EM_boolean_t significand_form;
  EM_boolean_t single_form;
  EM_boolean_t spill_form;
  EM_boolean_t swap_form;
  EM_boolean_t swap_nl_form;
  EM_boolean_t swap_nr_form;
  EM_boolean_t sxt_l_form;
  EM_boolean_t sxt_r_form;

  EM_boolean_t trunc_form;
  EM_boolean_t unsigned_form;
} EM_form_type;

typedef void (*EM_EXCP_FAULT)(void*, EM_uint_t);
typedef void (*EM_EXCP_TRAP)(void*, EM_uint_t);
typedef void (*EM_EXCP_SPEC)(void*, EM_uint_t, EM_uint64_t);


typedef struct EM_state_struct {
  EM_psr_type            state_PSR;
  EM_uint64_t            state_IP;
  EM_ar_type             state_AR[1];
  EM_fp_reg_type         state_FR[MAX_REAL_FR_INDEX];
  EM_gr_reg_type         state_GR[MAX_REAL_GR_INDEX];
  EM_boolean_t           state_PR[EM_NUM_PR];
  EM_memory_type         state_MEM[EM_NUM_MEM];
  EM_form_type           state_form;
  EM_uint_t              state_MERCED_RTL;
  EM_EXCP_FAULT          state_fp82_fp_exception_fault;
  EM_EXCP_TRAP           state_fp82_fp_exception_trap;
  void                   *state_user_context;
  EM_uint_t              trap_type; // 0 - fault; 1 - trap
} EM_state_type;


#endif /* _EM_TYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\ctxswap.s ===
//++
//
// Copyright (c) 1989-2000  Microsoft Corporation
//
// Component Name:
//
//    NT / KE 
//
// Module Name:
//
//    ctxswap.s
//
// Abstract:
//
//    This module implements the IA64 Process and Thread Context Swaps.
//
// Author:
//
//    David N. Cutler (davec) 5-Mar-1989
//
// Environment:
//
//    Kernel mode only
//
// Revision History:
// 
//    Bernard Lint  Jul-12-1995
//
//         Initial IA64 version
//
//--

#include "ksia64.h"

        .file     "ctxswap.s"
        .text

//
// Globals imported:
//

        .global     KiReadySummary
        .global     KiIdleSummary
        .global     KiDispatcherReadyListHead
        .global     KeTickCount
        .global     KiMasterSequence
        .global     KiMasterRid
        .global     PPerfGlobalGroupMask

        PublicFunction(KiDeliverApc)
        PublicFunction(KiSaveExceptionFrame)
        PublicFunction(KiRestoreExceptionFrame)
        PublicFunction(KiActivateWaiterQueue)
        PublicFunction(KiReadyThread)
        PublicFunction(KeFlushEntireTb)
        PublicFunction(KiQuantumEnd)
        PublicFunction(KiSyncNewRegionId)
        PublicFunction(KiCheckForSoftwareInterrupt)
        PublicFunction(KiSaveHigherFPVolatileAtDispatchLevel)
        PublicFunction(KeAcquireQueuedSpinLockAtDpcLevel)
        PublicFunction(KeReleaseQueuedSpinLockFromDpcLevel)
        PublicFunction(KeTryToAcquireQueuedSpinLockRaiseToSynch)
        PublicFunction(WmiTraceContextSwap)

#if DBG
        PublicFunction(KeBugCheckEx)
#endif // DBG


        SBTTL("Unlock Dispatcher Database")
//++
//--------------------------------------------------------------------
//
// VOID
// KiUnlockDispatcherDatabase (
//    IN KIRQL OldIrql
//    )
//
// Routine Description:
//
//    This routine is entered at synchronization level with the dispatcher
//    database locked. Its function is to either unlock the dispatcher
//    database and return or initiate a context switch if another thread
//    has been selected for execution.
//
//    N.B. A context switch CANNOT be initiated if the previous IRQL
//         is greater than or equal to DISPATCH_LEVEL.
//
//    N.B. This routine is carefully written to be a leaf function. If,
//        however, a context swap should be performed, the routine is
//        switched to a nested fucntion.
//
// Arguments:
//
//    OldIrql (a0) - Supplies the IRQL when the dispatcher database
//        lock was acquired (in low order byte, not zero extended).
//
// Return Value:
//
//    None.
//
//--------------------------------------------------------------------
//--

        NESTED_ENTRY(KiUnlockDispatcherDatabase)
        NESTED_SETUP(1,3,1,0)

//
// Register aliases
//

        rDPC      = loc2                // DPC active flag

        rpT1      = t1                  // temp pointer
        rpT2      = t2                  // temp pointer
        rpT3      = t3                  // temp pointer
        rT1       = t5                  // temp regs
        rT2       = t6
        rPrcb     = t8                  // PRCB pointer

        pNotNl    = pt2                 // true if next thread not NULL
        pIRQGE    = pt3                 // true if DISPATCH_LEVEL <= old irql
        pIRQLT    = pt4                 // true if DISPATCH_LEVEL > old irql
        pDPC      = pt5                 // true if DPC active
        pNoAPC    = pt2                 // do not dispatch APC
        pAPC      = pt9

        PROLOGUE_END

//
// Check if a thread has been scheduled to execute on the current processor
//

        movl      rPrcb = KiPcr + PcPrcb
        ;;

        LDPTR     (rPrcb, rPrcb)                // rPrcb -> PRCB
        ;;
        add       rpT1 = PbNextThread, rPrcb    // -> next thread
        add       rpT2 = PbDpcRoutineActive,rPrcb // -> DPC active flag
        ;;

        LDPTR     (v0, rpT1)                    // v0 = next thread
        ;;
        cmp.ne    pNotNl = zero, v0             // pNotNl = next thread is 0
        zxt1      a0 = a0                       // isolate old IRQL
        ;;

(pNotNl) cmp.leu.unc pIRQGE, pIRQLT = DISPATCH_LEVEL, a0
        mov       rDPC = 1                      // speculate that DPC is active
(pIRQLT) br.spnt   KxUnlockDispatcherDatabase
        ;;

//
// Case 1:
// Next thread is NULL:
// Release dispatcher database lock, restore IRQL to its previous level
// and return
//

//
// Case 2:
// A new thread has been selected to run on the current processor, but
// the new IRQL is not below dispatch level. Release the dispatcher
// lock and restore IRQL. If the current processor is
// not executing a DPC, then request a dispatch interrupt on the current
// processor.
//
// At this point pNotNl = 1 if thread not NULL, 0 if NULL
//

(pIRQGE) ld4       rDPC = [rpT2]                // rDPC.4 = DPC active flag
#if !defined(NT_UP)
        add         out0 = (LockQueueDispatcherLock * 16) + PbLockQueue, rPrcb
        br.call.sptk brp = KeReleaseQueuedSpinLockFromDpcLevel
#endif // !defined(NT_UP)
        ;;

        LOWER_IRQL(a0)
        cmp4.eq    pDPC = rDPC, zero            // pDPC = request DPC intr
        REQUEST_DISPATCH_INT(pDPC)              // request DPC interrupt

        NESTED_RETURN
        NESTED_EXIT(KiUnlockDispatcherDatabase)

//
// N.B. This routine is carefully written as a nested function.
//    Control only reaches this routine from above.
//
//    rPrcb contains the address of PRCB
//    v0 contains the next thread
//

        NESTED_ENTRY(KxUnlockDispatcherDatabase)
        PROLOGUE_BEGIN

        .regstk   1, 2, 1, 0
        alloc     t16 = ar.pfs, 1, 2, 1, 0
        .save     rp, loc0
        mov       loc0 = brp
        .fframe   SwitchFrameLength
        add       sp = -SwitchFrameLength, sp
        ;;

        .save     ar.unat, loc1
        mov       loc1 = ar.unat
        add       t0 = ExFltS19+SwExFrame+STACK_SCRATCH_AREA, sp
        add       t1 = ExFltS18+SwExFrame+STACK_SCRATCH_AREA, sp
        ;;

        .save.gf  0x0, 0xC0000
        stf.spill [t0] = fs19, ExFltS17-ExFltS19
        stf.spill [t1] = fs18, ExFltS16-ExFltS18
        ;;

        .save.gf  0x0, 0x30000
        stf.spill [t0] = fs17, ExFltS15-ExFltS17
        stf.spill [t1] = fs16, ExFltS14-ExFltS16
        mov       t10 = bs4
        ;;

        .save.gf  0x0, 0xC000
        stf.spill [t0] = fs15, ExFltS13-ExFltS15
        stf.spill [t1] = fs14, ExFltS12-ExFltS14
        mov       t11 = bs3
        ;;

        .save.gf  0x0, 0x3000
        stf.spill [t0] = fs13, ExFltS11-ExFltS13
        stf.spill [t1] = fs12, ExFltS10-ExFltS12
        mov       t12 = bs2
        ;;

        .save.gf  0x0, 0xC00
        stf.spill [t0] = fs11, ExFltS9-ExFltS11
        stf.spill [t1] = fs10, ExFltS8-ExFltS10
        mov       t13 = bs1
        ;;

        .save.gf  0x0, 0x300
        stf.spill [t0] = fs9, ExFltS7-ExFltS9
        stf.spill [t1] = fs8, ExFltS6-ExFltS8
        mov       t14 = bs0
        ;;

        .save.gf  0x0, 0xC0
        stf.spill [t0] = fs7, ExFltS5-ExFltS7
        stf.spill [t1] = fs6, ExFltS4-ExFltS6
        mov       t15 = ar.lc
        ;;

        .save.gf  0x0, 0x30
        stf.spill [t0] = fs5, ExFltS3-ExFltS5
        stf.spill [t1] = fs4, ExFltS2-ExFltS4
        ;;

        .save.f   0xC
        stf.spill [t0] = fs3, ExFltS1-ExFltS3         // save fs3
        stf.spill [t1] = fs2, ExFltS0-ExFltS2         // save fs2
        ;;

        .save.f   0x3
        stf.spill [t0] = fs1, ExBrS4-ExFltS1          // save fs1
        stf.spill [t1] = fs0, ExBrS3-ExFltS0          // save fs0
        ;;

        .save.b   0x18
        st8       [t0] = t10, ExBrS2-ExBrS4           // save bs4
        st8       [t1] = t11, ExBrS1-ExBrS3           // save bs3
        ;;

        .save.b   0x6
        st8       [t0] = t12, ExBrS0-ExBrS2           // save bs2
        st8       [t1] = t13, ExIntS2-ExBrS1          // save bs1
        ;;

        .save.b   0x1
        st8       [t0] = t14, ExIntS3-ExBrS0          // save bs0
        movl      t12 = KiPcr + PcCurrentThread
        ;;

        .save.gf  0xC, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s3, ExIntS1-ExIntS3          // save s3
        .mem.offset 8,0
        st8.spill [t1] = s2, ExIntS0-ExIntS2          // save s2
        ;;

        .save.gf  0x3, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s1, ExApLC-ExIntS1           // save s1
        .mem.offset 8,0
        st8.spill [t1] = s0, ExApEC-ExIntS0           // save s0
        ;;

        .savepsp  ar.pfs, ExceptionFrameLength-ExApEC-STACK_SCRATCH_AREA
        st8       [t1] = t16, ExIntNats-ExApEC
        mov       t4 = ar.unat                        // captured Nats of s0-s3
        mov       s0 = rPrcb

        LDPTR     (s1, t12)                           // current thread
        ;;

        .savepsp  ar.lc, ExceptionFrameLength-ExApLC-STACK_SCRATCH_AREA
        st8       [t0] = t15
        .savepsp  @priunat, ExceptionFrameLength-ExIntNats-STACK_SCRATCH_AREA
        st8       [t1] = t4                           // save Nats of s0-s3
        mov       s2 = v0

        PROLOGUE_END

        add       rpT2 = PbNextThread, s0       // -> next thread
        add       out0 = ThWaitIrql, s1         // -> previous IRQL
        ;;

        STPTRINC  (rpT2, zero,PbCurrentThread-PbNextThread)  // clear NextThread
        st1       [out0] = a0, ThIdleSwapBlock-ThWaitIrql    // save old IRQL
        mov       rpT3 = 1
        ;;

//
// Reready current thread for execution and swap context to the selected
// thread.
//
// Note:  Set IdleSwapBlock in the current thread so no idle processor
// can switch to this processor before it is removed from the current
// processor.

        STPTR     (rpT2, s2)                    // set current thread object
        st1       [out0] = rpT3, -ThIdleSwapBlock// out0 -> previous thread
        br.call.sptk brp = KiReadyThread
        ;;

        br.call.sptk brp = SwapContext
        ;;

//
// Lower IRQL, deallocate exception/switch frame.
//
// N.B. SwapContext releases the dispatcher database lock.
//
// N.B. v0 contains the kernel APC pending state on return.
//
// N.B. s2 contains the address of the new thread on return.
//

        add       rpT2 = ThWaitIrql, s2        // -> ThWaitIrql
        cmp.ne    pAPC, pNoAPC = zero, v0
        ;;

        ld1       a0 = [rpT2]                  // a0 = original wait IRQL
        ;;

(pAPC)  cmp.ne    pNoAPC = zero, a0            // APC pending and IRQL == 0
(pNoAPC) br.spnt  Kudd_Exit
        ;;

        .regstk   1, 2, 3, 0
        alloc     t16 = ar.pfs, 1, 2, 3, 0
        mov       rT2 = APC_LEVEL
        ;;

        SET_IRQL(rT2)

        mov       out0 = KernelMode
        mov       out1 = zero
        mov       out2 = zero
        br.call.sptk brp = KiDeliverApc
        ;;

//
// Lower IRQL to wait level, set return status, restore registers, and return.
//

Kudd_Exit:

        LOWER_IRQL(a0)                          // a0 = new irql

        add       out0 = STACK_SCRATCH_AREA+SwExFrame, sp
        br.call.sptk brp = KiRestoreExceptionFrame
        ;;

        add       rpT1 = ExApEC+SwExFrame+STACK_SCRATCH_AREA, sp
        ;;
        ld8       rT1 = [rpT1]
        mov       brp = loc0
        ;;

        mov       ar.unat = loc1
        nop.f     0
        mov       ar.pfs = rT1

        .restore
        add       sp = SwitchFrameLength, sp
        nop.i     0
        br.ret.sptk brp
        ;;

        NESTED_EXIT(KxUnlockDispatcherDatabase)

        SBTTL("Swap Thread")
//++
//--------------------------------------------------------------------
//
// BOOLEAN
// KiSwapContext (
//    IN PKTHREAD Thread
//    )
//
// Routine Description:
//
//       This routine saves the non-volatile registers, marshals the
//       arguments for SwapContext and calls SwapContext to perform
//       the actual thread switch.
//
// Arguments:
//
//       Thread - Supplies the address of the new thread.
//
// Return Value:
//
//       If a kernel APC is pending, then a value of TRUE is returned.
//       Otherwise, FALSE is returned.
//
// Notes:
//
//       GP valid on entry -- GP is not switched, just use kernel GP
//--------------------------------------------------------------------
//--

        NESTED_ENTRY(KiSwapContext)

//
// Register aliases
//

        pNoAPC    = pt2                         // do not dispatch APC

        rpT1      = t0                          // temp pointer
        rpT2      = t1                          // temp pointer
        rT1       = t10                         // temp regs

        PROLOGUE_BEGIN

        .regstk   1, 2, 1, 0
        alloc     t16 = ar.pfs, 1, 2, 1, 0
        .save     rp, loc0
        mov       loc0 = brp
        .fframe   SwitchFrameLength
        add       sp = -SwitchFrameLength, sp
        ;;

        .save     ar.unat, loc1
        mov       loc1 = ar.unat
        add       t0 = ExFltS19+SwExFrame+STACK_SCRATCH_AREA, sp
        add       t1 = ExFltS18+SwExFrame+STACK_SCRATCH_AREA, sp
        ;;

        .save.gf  0x0, 0xC0000
        stf.spill [t0] = fs19, ExFltS17-ExFltS19
        stf.spill [t1] = fs18, ExFltS16-ExFltS18
        ;;

        .save.gf  0x0, 0x30000
        stf.spill [t0] = fs17, ExFltS15-ExFltS17
        stf.spill [t1] = fs16, ExFltS14-ExFltS16
        mov       t10 = bs4
        ;;

        .save.gf  0x0, 0xC000
        stf.spill [t0] = fs15, ExFltS13-ExFltS15
        stf.spill [t1] = fs14, ExFltS12-ExFltS14
        mov       t11 = bs3
        ;;

        .save.gf  0x0, 0x3000
        stf.spill [t0] = fs13, ExFltS11-ExFltS13
        stf.spill [t1] = fs12, ExFltS10-ExFltS12
        mov       t12 = bs2
        ;;

        .save.gf  0x0, 0xC00
        stf.spill [t0] = fs11, ExFltS9-ExFltS11
        stf.spill [t1] = fs10, ExFltS8-ExFltS10
        mov       t13 = bs1
        ;;

        .save.gf  0x0, 0x300
        stf.spill [t0] = fs9, ExFltS7-ExFltS9
        stf.spill [t1] = fs8, ExFltS6-ExFltS8
        mov       t14 = bs0
        ;;

        .save.gf  0x0, 0xC0
        stf.spill [t0] = fs7, ExFltS5-ExFltS7
        stf.spill [t1] = fs6, ExFltS4-ExFltS6
        mov       t15 = ar.lc
        ;;

        .save.gf  0x0, 0x30
        stf.spill [t0] = fs5, ExFltS3-ExFltS5
        stf.spill [t1] = fs4, ExFltS2-ExFltS4
        ;;

        .save.f   0xC
        stf.spill [t0] = fs3, ExFltS1-ExFltS3         // save fs3
        stf.spill [t1] = fs2, ExFltS0-ExFltS2         // save fs2
        ;;

        .save.f   0x3
        stf.spill [t0] = fs1, ExBrS4-ExFltS1          // save fs1
        stf.spill [t1] = fs0, ExBrS3-ExFltS0          // save fs0
        ;;

        .save.b   0x18
        st8       [t0] = t10, ExBrS2-ExBrS4           // save bs4
        st8       [t1] = t11, ExBrS1-ExBrS3           // save bs3
        ;;

        .save.b   0x6
        st8       [t0] = t12, ExBrS0-ExBrS2           // save bs2
        st8       [t1] = t13, ExIntS2-ExBrS1          // save bs1
        ;;

        .save.b   0x1
        st8       [t0] = t14, ExIntS3-ExBrS0          // save bs0
        ;;

        .save.gf  0xC, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s3, ExIntS1-ExIntS3          // save s3
        .mem.offset 8,0
        st8.spill [t1] = s2, ExIntS0-ExIntS2          // save s2
        ;;

        .save.gf  0x3, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s1, ExApLC-ExIntS1           // save s1
        .mem.offset 8,0
        st8.spill [t1] = s0, ExApEC-ExIntS0           // save s0
        ;;

        .savepsp  ar.pfs, ExceptionFrameLength-ExApEC-STACK_SCRATCH_AREA
        st8       [t1] = t16, ExIntNats-ExApEC
        mov       t4 = ar.unat                        // captured Nats of s0-s3
        ;;

        .savepsp  ar.lc, ExceptionFrameLength-ExApLC-STACK_SCRATCH_AREA
        st8       [t0] = t15
        .savepsp  @priunat, ExceptionFrameLength-ExIntNats-STACK_SCRATCH_AREA
        st8       [t1] = t4                           // save Nats of s0-s3

        PROLOGUE_END

        //
        //  For the call to SwapContext-
        //
        //          s0                          // Prcb address
        //          s1                          // old thread address
        //          s2                          // new thread address
        //          pt0 = 1
        //

        mov         s2 = a0                     // s2 <- New Thread
        movl        rpT1 = KiPcr + PcPrcb
        ;;

        LDPTRINC  (s0, rpT1, PcCurrentThread-PcPrcb)// s0 <- Prcb
        ;;
        LDPTR     (s1, rpT1)                    // s1 <- Old Thread
        add       rpT2 = PbCurrentThread, s0
        ;;

//
// Swap context to the next thread.
//

        STPTR     (rpT2, a0)                    // Set new thread current
        cmp.eq    pt0 = zero, zero              // indicate lock context swap
        br.call.sptk brp = SwapContext          // call SwapContext(prcb, OldTh, NewTh)
        ;;

//
// Deallocate exception/switch frame.
//
// N.B. SwapContext releases the dispatcher database lock.
//
// N.B. v0 contains the kernel APC pending state on return, ie, 0 if
//      no APC pending, 1 if APC pending.   v0 will be forced to 0 if
//      the new IRQL doesn't allow APCs.
//
// N.B. KiRestoreExceptionFrame doesn't touch v0, t21 or t22.
//

        add       rpT2 = ThWaitIrql, s2        // -> ThWaitIrql
        add       rpT1 = ExApEC+SwExFrame+STACK_SCRATCH_AREA, sp
        add       out0 = STACK_SCRATCH_AREA+SwExFrame, sp
        ;;

        ld1       t21 = [rpT2]                 // t21 = original wait IRQL
        ld8       t22 = [rpT1]                 // t22 = PFS
        br.call.sptk brp = KiRestoreExceptionFrame
        ;;

        mov       brp = loc0
        cmp.ne    pNoAPC = zero, t21           // no APC if IRQL != 0
        ;;

        mov       ar.unat = loc1
        nop.f     0
        mov       ar.pfs = t22

        .restore
        add       sp = SwitchFrameLength, sp
(pNoAPC) mov      v0 = zero
        br.ret.sptk brp
        ;;

        NESTED_EXIT(KiSwapContext)

        SBTTL("Swap Context to Next Thread")
//++
//--------------------------------------------------------------------
// Routine:
//
//       SwapContext
//
// Routine Description:
//
//       This routine is called to swap context from one thread to the next.
//
// Arguments:
//
//       s0 - Address of Processor Control Block (PRCB).
//       s1 - Address of previous thread object.
//       s2 - Address of next thread object.
//
// Return value:
//
//       v0 - Kernel APC pending flag
//       s0 - Address of Processor Control Block (PRCB).
//       s1 - Address of previous thread object.
//       s2 - Address of current thread object.
//
// Note:
//       Kernel GP is not saved and restored across context switch
//
//       !!WARNING!! - Thierry. 03/01/2000.
//       Be aware that this implementation is a result of performance analysis.
//       Please consider this when you are making changes...
//
//--------------------------------------------------------------------
//--

        NESTED_ENTRY(SwapContext)

//
// Register aliases
//

        rT1       = t1                          // temp
        rT2       = t2                          // temp
        rT3       = t3                          // temp
        rNewproc  = t4                          // next process object
        rOldproc  = t5                          // previous process object
        rpThBSL   = t6                          // pointer to new thread backing store limit
        rpT1      = t7                          // temp pointer
        rpT2      = t8                          // temp pointer
        rpT3      = t9                          // temp pointer
        rAr1      = t10
        rAr2      = t11
        rAr3      = t12
        rAr4      = t13

        rNewIKS   = t14                         // new initial kernel stack
        rNewKSL   = t15                         // new kernel stack limit
        rNewBSP   = t16                         // new thread BSP/BSPSTORE
        rOldBSP   = t16                         // old thread BSP
        rOldRNAT  = t17                         // old thread RNAT
        rNewRNAT  = t17                         // new thread RNAT
        rOldSbase = t18                         // old thread kstack base

        pUsTh     = pt4                         // is user thread?
        pKrTh     = pt5                         // is user thread?
        pSave     = pt7                         // is high fp set dirty?
        pDiff     = ps4                         // if new and old process different
        pSame     = ps5                         // if new and old process same

//
// Set new thread's state to running. Note this must be done
// under the dispatcher lock so that KiSetPriorityThread sees
// the correct state.
//

        PROLOGUE_BEGIN


#if !defined(NT_UP)

        alloc     rT2 = ar.pfs, 0, 0, 4, 0
        mov       rT1 = brp                     // move from brp takes 2 cycles
        add       rpT3 = ThState, s2
        ;;

        lfetch.excl  [rpT3]
        mov       rAr1 = Running
        add       rpT2 = SwPFS+STACK_SCRATCH_AREA, sp
        ;;
 
        add         out0 = (LockQueueContextSwapLock * 16) + PbLockQueue, s0
        .savesp   ar.pfs, SwPFS+STACK_SCRATCH_AREA
        st8.nta   [rpT2] = rT2, SwRp-SwPFS     // save pfs
        ;;

        .savesp   brp, SwRp+STACK_SCRATCH_AREA
        st8.nta   [rpT2] = rT1                 // save return link
        st1.nta   [rpT3] = rAr1                // set thread state to Running
        br.call.sptk brp = KeAcquireQueuedSpinLockAtDpcLevel
        ;;

//
// Release DispatcherLock.
//

        add         out0 = (LockQueueDispatcherLock * 16) + PbLockQueue, s0
        br.call.sptk brp = KeReleaseQueuedSpinLockFromDpcLevel
        ;;

        mov       out0 = ar.fpsr                // move from ar.fpsr takes 12 cycles
        movl      rpT1 = KiPcr+PcHighFpOwner    // setup for prefetching         
        ;;
{ .mmi
        lfetch    [rpT1]
        cmp.ne    pUsTh = zero, teb             // test for ia32 save required
                                                // must not have a nop.f for next 10 cycles--
                                                // Using temporarely the explicit templating
                                                // for the next cycles.
        add       out1 = ThStackBase, s1        // move early to start access for rOldSbase
{ .mmi
        add       rpT1 = SwFPSR+STACK_SCRATCH_AREA, sp
        add       rpT2 = SwPreds+STACK_SCRATCH_AREA, sp
        nop.i     0x0
}
        ;;
{ .mmi
        ld8.nta   rOldSbase = [out1]            // speculative start early for ia32 saves
        lfetch.excl [rpT1]
        add       out2 = ThNumber, s2           // setup for prefetching           
}
{ .mmi
        mov.m     ar.rsc = r0                   // put RSE in lazy mode
        mov       rOldBSP = ar.bsp              // move from ar.bsp takes 12 cycles
        nop.i     0x0
}
        ;;
{ .mmi
        lfetch    [out2]     
        nop.m     0x0
        mov       rT1 = pr                      // move from pr takes 2 cycles
}
        ;;

{ .mmi
        flushrs
        mov       rT3 = psr.um                  // move from psr.um takes 12 cycles
        nop.i     0x0
}
        ;;
{ .mmi
        lfetch.excl  [rpT2]
        mov.m     rOldRNAT = ar.rnat            // move from ar.rnat takes 5 cycles
        add       out2 = @gprel(PPerfGlobalGroupMask), gp
}
        ;;
{ .mli
        lfetch    [out2]                              
        movl      out3 = KiPcr + PcInterruptionCount  // INTERRUPTION_LOGGING on or off, we are prefetching this line.
                                                      // If any real performance problem is detected, we will undef these lines.
}
        ;;
{ .mmi
        lfetch    [out3]      
        add       rpT3 = SwRnat+STACK_SCRATCH_AREA, sp
}
        ;;

#else  // NT_UP
        alloc     rT2 = ar.pfs, 0, 0, 4, 0
        cmp.ne    pUsTh = zero, teb             // test for ia32 save required
        ;;
        mov.m     ar.rsc = r0                   // put RSE in lazy mode
        add       out1 = ThStackBase, s1        // move early to start access for rOldSbase
        mov       out0 = ar.fpsr                // move from ar.fpsr takes 12 cycles
                                                // must not have a nop.f for next 10 cycles--
                                                // Using temporarely the explicit templating
                                                // for the next cycles.
        ;;
{ .mmi
        ld8.nta   rOldSbase = [out1]            // speculative start early for ia32 saves
        mov       rOldBSP = ar.bsp              // move from ar.bsp takes 12 cycles
        add       rpT1 = SwRp+STACK_SCRATCH_AREA, sp
}
        ;;
        flushrs
        mov       rT3 = psr.um                  // move from psr.um takes 12 cycles
        add       rpT2 = SwPFS+STACK_SCRATCH_AREA, sp
        ;;

        mov.m     rOldRNAT = ar.rnat            // move from ar.rnat takes 5 cycles
        mov       rT1 = brp                     // move from brp takes 2 cycles
        add       rpT3 = ThState, s2
        ;;

{ .mmi
        mov       rAr1 = Running
        .savesp   brp, SwRp+STACK_SCRATCH_AREA
        st8.nta   [rpT1] = rT1, SwFPSR-SwRp    // save return link
        nop.i     0x0  
}
        ;;


{ .mii
        st1.nta   [rpT3] = rAr1                 // set thread state to Running
        mov       rT1 = pr                      // move from pr takes 2 cycles
        nop.i     0x0  
}
        ;;

{ .mii
        .savesp   ar.pfs, SwPFS+STACK_SCRATCH_AREA
        st8.nta   [rpT2] = rT2, SwPreds-SwPFS   // save pfs
        add       rpT3 = SwRnat+STACK_SCRATCH_AREA, sp           
        nop.i     0x0  
}
        ;;
#endif // NT_UP
{ .mmi
        st8.nta   [rpT3] = rOldRNAT
        nop.m     0x0
        nop.i     0x0  
}
        st8       [rpT1] = out0, SwBsp-SwFPSR   // save kernel FPSR
        st8       [rpT2] = rT1                  // save preserved predicates
        ;;
        st8.nta   [rpT1] = rOldBSP
        add       rpT3 = ThKernelBStore, s1
        tbit.nz   pSave = rT3, PSR_MFH          // check mfh bit
(pUsTh) br.call.spnt brp = SwapContextIA32Save
        ;;
        st8.nta   [rpT3] = rOldBSP
(pSave) add       out0 = -ThreadStateSaveAreaLength+TsHigherFPVolatile, rOldSbase
(pSave) br.call.spnt brp = KiSaveHigherFPVolatileAtDispatchLevel
        ;;

//
// Acquire the context swap lock so the address space of the old process
// cannot be deleted and then release the dispatcher database lock.
//
// N.B. This lock is used to protect the address space until the context
//    switch has sufficiently progressed to the point where the address
//    space is no longer needed. This lock is also acquired by the reaper
//    thread before it finishes thread termination.
//

       PROLOGUE_END

//
// ***** TBD ****** Save performance counters? (user vs. kernel)
//

//
// Accumlate the total time spent in a thread.
//

#if defined(PERF_DATA)
         **** TBD  **** MIPS code

        addu    a0,sp,ExFltF20          // compute address of result
        move    a1,zero                 // set address of optional frequency
        jal     KeQueryPerformanceCounter // query performance counter
        lw      t0,ExFltF20(sp)         // get current cycle count
        lw      t1,ExFltF20 + 4(sp)     //
        lw      t2,PbStartCount(s0)     // get starting cycle count
        lw      t3,PbStartCount + 4(s0) //
        sw      t0,PbStartCount(s0)     // set starting cycle count
        sw      t1,PbStartCount + 4(s0) //
        lw      t4,EtPerformanceCountLow(s1) // get accumulated cycle count
        lw      t5,EtPerformanceCountHigh(s1) //
        subu    t6,t0,t2                // subtract low parts
        subu    t7,t1,t3                // subtract high parts
        sltu    v0,t0,t2                // generate borrow from high part
        subu    t7,t7,v0                // subtract borrow
        addu    t6,t6,t4                // add low parts
        addu    t7,t7,t5                // add high parts
        sltu    v0,t6,t4                // generate carry into high part
        addu    t7,t7,v0                // add carry
        sw      t6,EtPerformanceCountLow(s1)  // set accumulated cycle count
        sw      t7,EtPerformanceCountHigh(s1) //

#endif // defined(PERF_DATA)

//
// The following entry point is used to switch from the idle thread to
// another thread.
//

        ;;
        ALTERNATE_ENTRY(SwapFromIdle)

        alloc     rT1 = ar.pfs, 2, 0, 2, 0

//
// Check if we are tracing context swaps
//

        mov       out0 = s1     // assign out0 to old ethread pointer
        add       rpT3 = @gprel(PPerfGlobalGroupMask), gp 
        ;;

        ld8.nta   rpT3 = [rpT3] // get value of PperfGlobalGroupMask
        mov       out1 = s2     // assign out1 to new ethread pointer
        ;;

        add       rpT2 = PERF_CONTEXTSWAP_OFFSET, rpT3
        cmp.ne    pt3 = zero, rpT3  // if it's non-zero, then trace on
        ;;

(pt3)   ld4.nta   rpT2 = [rpT2]
        ;;

(pt3)   and       rpT2 = PERF_CONTEXTSWAP_FLAG, rpT2
        ;;

(pt3)   cmp.ne.unc pt4  = zero, rpT2
(pt4)   br.call.spnt brp = WmiTraceContextSwap // optimize for no tracing case
        ;;

//
// Get address of old and new process objects.
//

        add       rpT2 = ThApcState+AsProcess,s2 // -> new thread AsProcess
        add       rpT1 = ThApcState+AsProcess,s1 // -> old thread AsProcess
        ;;

        LDPTR     (rOldproc, rpT1)               // old process
        LDPTR     (rNewproc, rpT2)               // new process

#if !defined(NT_UP)

//
// In MP system,
// should a thread address is recycled and the thread is migrated to a
// processor that holds the stale values in the high fp register set,
// set KiPcr->HighFpOwner to zero (i.e. when pt4 is set to TRUE)
//

        add       rpT1 = ThNumber, s2
        movl      rpT2 = KiPcr+PcHighFpOwner
        ;;

        ld1       rT1 = [rpT1]
        ld8       rT2 = [rpT2], PcNumber-PcHighFpOwner
        add       out0 = ThIdleSwapBlock, s1
        ;;

        ld1       rT3 = [rpT2], PcHighFpOwner-PcNumber
        st1       [out0] = zero                 // clear OldThread->IdleSwapBlock
        cmp.eq    pt3 = rT2, s2
        ;;

 (pt3)  cmp.ne.unc pt4 = rT1, rT3
        ;;
 (pt4)  st8       [rpT2] = zero

#endif // !defined(NT_UP)
        ;;

        flushrs
        FAST_DISABLE_INTERRUPTS
        ;;

//
// Thierry - 03/29/2000
// It should be noticed that the performance analysis for SwapContext
// was done with INTERRUPTION_LOGGING defined as 1.
//

#define INTERRUPTION_LOGGING 1
#if defined(INTERRUPTION_LOGGING)

// For Conditional Interrupt Logging
#define ContextSwitchBit 63

         .global     KiVectorLogMask

         mov       rT3 = gp
         ;;
         movl      gp = _gp
         ;;
         add       rpT1 = @gprel(KiVectorLogMask), gp
         ;;
         ld8       rT1 = [rpT1]
         mov       gp = rT3
         ;;
         tbit.z    pt4 = rT1, ContextSwitchBit
 (pt4)   br.cond.sptk   EndOfLogging0



        movl      rpT1 = KiPcr+PcInterruptionCount
        mov       rT3 = MAX_NUMBER_OF_IHISTORY_RECORDS - 1
        cmp.ne    pDiff,pSame=rOldproc,rNewproc
        ;;
(pDiff) mov       rT1 = 0x91                    // process switch
        ld4.nt1   rT2 = [rpT1]                  // get current count
        ;;

(pSame) mov       rT1 = 0x90                    // thread switch
        add       rpT3 = 1, rT2                 // incr count
        and       rT2 = rT3, rT2                // index of current entry
        add       rpT2 = 0x1000-PcInterruptionCount, rpT1 // base of history
        ;;

        st4.nta   [rpT1] = rpT3                 // save count
        shl       rT2 = rT2, 5                  // offset of current entry
        ;;
        add       rpT2 = rpT2, rT2              // address of current entry
        ;;
        st8       [rpT2] = rT1, 8               // save switch type
        ;;
        st8       [rpT2] = s2, 8                // save new thread pointer
        ;;
        st8       [rpT2] = s1, 8                // save old thread
        ;;
        st8       [rpT2] = sp                   // save old sp
        ;;

// For Conditional Interrupt Logging
EndOfLogging0:

#endif // INTERRUPTION_LOGGING

        mov       ar.rsc = r0                   // put RSE in lazy mode
        add       rpT1 = ThInitialStack, s2
        add       rpT2 = ThKernelStack, s1
        ;;

//
// Store the kernel stack pointer in the previous thread object,
// load the new kernel stack pointer from the new thread object,
// switch backing store pointers, select new process id and swap 
// to the new process.
//

        ld8.nta   rNewIKS = [rpT1], ThKernelStack-ThInitialStack
        st8.nta   [rpT2] = sp                             // save current sp
        ;;

        ld8.nta   sp = [rpT1], ThStackLimit-ThKernelStack
        movl      rpT2 = KiPcr + PcInitialStack
        ;;

        alloc     rT1 = 0,0,0,0              // make current frame 0 size
        ld8.nta   rNewKSL = [rpT1], ThInitialBStore-ThStackLimit
        ;;

        loadrs                               // invalidate RSE and ALAT
        ld8.nta   rT1 = [rpT1], ThBStoreLimit-ThInitialBStore
        ;;

        ld8.nta   rT2 = [rpT1], ThDebugActive-ThBStoreLimit
        st8       [rpT2] = rNewIKS, PcStackLimit-PcInitialStack
        ;;
                                             // get debugger active state
        ld1.nta   rT3 = [rpT1], ThTeb-ThDebugActive
        st8       [rpT2] = rNewKSL, PcInitialBStore-PcStackLimit
        add       rpT3 = SwBsp+STACK_SCRATCH_AREA, sp
        ;;

        ld8       rNewBSP = [rpT3], SwRnat-SwBsp
        st8       [rpT2] = rT1, PcBStoreLimit-PcInitialBStore
        ;;

        ld8       rNewRNAT = [rpT3]
        st8       [rpT2] = rT2, PcDebugActive-PcBStoreLimit
        ;;
                                             // load new teb
        ld8       teb = [rpT1], ThApcState+AsKernelApcPending-ThTeb
                                             // set new debugger active state
        st1       [rpT2] = rT3, PcCurrentThread-PcDebugActive
        invala

//
// Setup PCR intial kernel BSP and BSTORE limit
//

        mov       ar.bspstore = rNewBSP      // load new bspstore
        cmp.ne    pDiff,pSame=rOldproc,rNewproc // if ne, switch process
        ;;
        mov       ar.rnat = rNewRNAT         // load new RNATs
        ;;
        mov       ar.rsc = RSC_KERNEL        // enable RSE
        ;;

//
// If the new process is not the same as the old process, then swap the
// address space to the new process.
//
// N.B. The context swap lock cannot be dropped until all references to the
//      old process address space are complete. This includes any possible
//      TB Misses that could occur referencing the new address space while
//      still executing in the old address space.
//
// N.B. The process address space swap is executed with interrupts disabled.
//

        alloc     rT1 = 0,4,2,0
        STPTR     (rpT2, s2)
        ;;

        mov       kteb = teb                    // update kernel TEB
        FAST_ENABLE_INTERRUPTS
        ld1       loc0 = [rpT1]                 // load the ApcPending flag

#if !defined(NT_UP)

//
// Release the context swap lock
// N.B. ContextSwapLock is always released in KxSwapProcess, if called
//

        add         out0 = (LockQueueContextSwapLock * 16) + PbLockQueue, s0
        add         loc1 = PcApcInterrupt-PcCurrentThread, rpT2
(pSame) br.call.sptk brp = KeReleaseQueuedSpinLockFromDpcLevel
        ;;

#else // !defined(NT_UP)

        add         loc1 = PcApcInterrupt-PcCurrentThread, rpT2
        ;;

#endif // !defined(NT_UP)

        mov       out0 = rNewproc               // set address of new process
        mov       out1 = rOldproc               // set address of old process
(pDiff) br.call.sptk brp = KxSwapProcess        // call swap address space(NewProc, OldProc)
        ;;
//
// In new address space, if changed.
//

        st1       [loc1] = loc0                 // request (or clear) APC pend.
        add       rpT1 = PbContextSwitches, s0
        add       rpT2 = ThContextSwitches, s2
        ;;

//
// If the new thread has a kernel mode APC pending, then request an APC
// interrupt.
//

        ld4       loc1 = [rpT1]
        ld4       loc2 = [rpT2]
        ;;

//
// Increment context switch counters
//

        cmp.ne    pUsTh, pKrTh = zero, teb
        add       loc1 = loc1, zero, 1
        add       loc2 = loc2, zero, 1
        ;;

        st4       [rpT1] = loc1             // increment # of context switches
        st4       [rpT2] = loc2             // increment # of context switches

        add       rpT1 = SwFPSR+STACK_SCRATCH_AREA, sp
        add       rpT2 = SwPFS+STACK_SCRATCH_AREA, sp
        ;;

        ld8       loc1 = [rpT1], SwRp-SwFPSR // restore brp and pfs
        ld8       loc2 = [rpT2], SwPreds-SwPFS
        ;;

        ld8       rT3 = [rpT1]
        ld8       rT2 = [rpT2]

        mov       v0 = loc0                     // set v0 = apc pending
(pUsTh) br.call.spnt brp = SwapContextIA32Restore
        ;;

//
// Note: at this point s0 = Prcb, s1 = previous thread, s2 = current thread
//

        mov       ar.fpsr = loc1
        mov       ar.pfs = loc2
        mov       brp = rT3

        mov       pr = rT2                      // Restore preserved preds

#if 0

//
// Thierry 03/22/2000: 
//
//      The following memory synchronization of the local processor
//      I-cache and D-cache because of I-stream modifications is not
//      required if the modifying code is written following the NT 
//      Core Team specifications:
//         - [Allocate VA]
//         - Modify the code
//         - Call FlushIntructionCache()
//                     -> calls KiSweepIcache[Range]()
//         - Execute the code.
//
//      The removal of this instruction eliminates a "> 100 cycle" stall.
//

        sync.i

#endif // 0
        ;; 
        srlz.i

        br.ret.sptk brp

        NESTED_EXIT(SwapContext)

//++
//--------------------------------------------------------------------
// Routine:
//
//       SwapContextIA32Save
//
// Routine Description:
//
//      This function saves the IA32 context on the kernel stack. 
//      Called from SwapContext.
//
// Arguments:
//
//      rOldSbase : old thread kstack base.
//
// Return value:
//
//      None.
//
// Note:
//
//      SwapContext registers context.
//
//--------------------------------------------------------------------
//--
        LEAF_ENTRY(SwapContextIA32Save)

        mov       rAr1 = ar21             // IA32 FP control register FCR
        ;;
        mov       rAr2 = ar24             // IA32 EFLAG register
        ;;
        mov       rAr3 = ar25
        ;;
        mov       rAr4 = ar26
        ;;
        //
        // we may skip saving ar27 because it cannot be modified by user code
        //
        mov       rT1  = ar30
        ;;
        mov       rT2  = ar28
        ;;
        mov       rT3  = ar29
        ;;
        // these are separated out due to cache miss potential
        add       rpT1 = -ThreadStateSaveAreaLength+TsAppRegisters+TsAr21, rOldSbase  
        add       rpT2 = -ThreadStateSaveAreaLength+TsAppRegisters+TsAr24, rOldSbase
        ;;
        st8       [rpT1] = rAr1, TsAr25-TsAr21
        st8       [rpT2] = rAr2, TsAr26-TsAr24
        ;;
        st8       [rpT1] = rAr3, TsAr29-TsAr25
        st8       [rpT2] = rAr4, TsAr28-TsAr26
        ;;
        st8       [rpT2] = rT2, TsAr30-TsAr28
        ;;
        st8       [rpT2] = rT1  
        st8       [rpT1] = rT3

        br.ret.sptk.few.clr brp
        LEAF_EXIT(SwapContextIA32Save)


//++
//--------------------------------------------------------------------
// Routine:
//
//      SwapContextIA32Restore
//
// Routine Description:
//
//      This function restores the IA32 registers context.
//      Called from SwapContext.
//
// Arguments:
//
//      s2 - Address of next thread object.
//
// Return value:
//
//      None.
//
// Note:
//
//      SwapContext registers context.
//
//--------------------------------------------------------------------
//--
        LEAF_ENTRY(SwapContextIA32Restore)

        add       rpT1 = ThStackBase, s2
        ;;
        ld8.nta   rpT1 = [rpT1]
        ;;

        add       rpT2 = -ThreadStateSaveAreaLength+TsAppRegisters+TsAr21, rpT1
        add       rpT3 = -ThreadStateSaveAreaLength+TsAppRegisters+TsAr24, rpT1
        ;;

        ld8.nta   rAr1 = [rpT2], TsAr25-TsAr21
        ld8.nta   rAr2 = [rpT3], TsAr26-TsAr24
        ;;

        ld8.nta   rAr3 = [rpT2], TsAr27-TsAr25
        ld8.nta   rAr4 = [rpT3], TsAr28-TsAr26
        ;;

        mov       ar21 = rAr1
        mov       ar24 = rAr2

        mov       ar25 = rAr3
        mov       ar26 = rAr4

        ld8.nta   rAr1 = [rpT2], TsAr29-TsAr27
        ld8.nta   rAr2 = [rpT3], TsAr30-TsAr28
        ;;

        ld8.nta   rAr3 = [rpT2]
        ld8.nta   rAr4 = [rpT3]
        ;;
        mov       ar27 = rAr1
        mov       ar28 = rAr2

        mov       ar29 = rAr3
        mov       ar30 = rAr4

        br.ret.sptk.few.clr brp
        LEAF_EXIT(SwapContextIA32Restore)


        SBTTL("Swap Process")
//++
//--------------------------------------------------------------------
//
// VOID
// KiSwapProcess (
//    IN PKPROCESS NewProcess,
//    IN PKPROCESS OldProcess
//    )
//
// Routine Description:
//
//    This function swaps the address space from one process to another by
//    assigning a new region id, if necessary, and loading the fixed entry
//    in the TB that maps the process page directory page. This routine follows
//    the PowerPC design for handling RID wrap.
//
// On entry/exit:
//
//    Interrupt enabled.
//
// Arguments:
//
//    NewProcess (a0) - Supplies a pointer to a control object of type process
//      which represents the new process that is switched to (32-bit address).
//
//    OldProcess (a1) - Supplies a pointer to a control object of type process
//      which represents the old process that is switched from (32-bit address).
//
// Return Value:
//
//    None.
//
//--------------------------------------------------------------------
//--
        NESTED_ENTRY(KiSwapProcess)
        NESTED_SETUP(2,3,3,0)

        PROLOGUE_END

//
// Register aliases
//

         rNewProc  = a0
         rOldProc  = a1

         rpCSLock  = loc2

         rpT1      = t0
         rpT2      = t1
         rProcSet  = t2
         rNewActive= t3
         rOldActive= t4
         rMasterSeq= t5
         rNewSeq   = t6
         rOldPsrL  = t7
         rVa       = t8
         rPDE0     = t9                          // PDE for page directory page 0
         rVa2      = t10
         rSessionBase = t11
         rSessionInfo = t12
         rT1       = t13
         rT2       = t14

//
// KiSwapProcess must get the context swap lock
// KxSwapProcess is called from SwapContext with the lock held
//

#if !defined(NT_UP)
        movl        rpT1 = KiPcr+PcPrcb
        ;;
        ld8         rpT1 = [rpT1]
        ;;
        add         out0 = (LockQueueContextSwapLock * 16) + PbLockQueue, rpT1
        br.call.sptk brp = KeAcquireQueuedSpinLockAtDpcLevel
        ;;
        br.sptk     Ksp_Continue
#endif // !defined(NT_UP)
        ;;

        ALTERNATE_ENTRY(KxSwapProcess)
        NESTED_SETUP(2,3,3,0)

        PROLOGUE_END
//
// Clear the processor set member number in the old process and set the
// processor member number in the new process.
//

Ksp_Continue:

#if !defined(NT_UP)

        add       rpT2 = PrActiveProcessors, rOldProc     // -> old active processor set
        movl      rpT1 = KiPcr + PcSetMember              // -> processor set member
        ;;

        ld4       rProcSet= [rpT1]                        // rProcSet.4 =  processor set member
        add       rpT1 = PrActiveProcessors, rNewProc     // -> new active processor set
        ;;

        ld4       rNewActive = [rpT1]                     // rNewActive.4 = new active processor set
        ld4       rOldActive = [rpT2]                     // rOldActive.4 = old active processor set
        ;;

        or        rNewActive = rNewActive,rProcSet        // set processor member in new set
        xor       rOldActive = rOldActive,rProcSet        // clear processor member in old set
        ;;

        st4       [rpT1] = rNewActive           // set new active processor set
        st4       [rpT2] = rOldActive           // set old active processor set

#endif // !defined(NT_UP)

//
// If the process sequence number matches the system sequence number, then
// use the process RID. Otherwise, allocate a new process RID.
//
// N.B. KiMasterRid, KiMasterSequence are changed only when holding the
//      KiContextSwapLock.
//

        add       rT2 = PrSessionMapInfo, rNewProc
        add       out0 = PrProcessRegion, rNewProc
        ;;
        ld8       out1 = [rT2]
        br.call.sptk brp = KiSyncNewRegionId
        ;;

//
// Switch address space to new process
// v0 = rRid = new process rid
//

        fwb                                     // hint to flush write buffers

        FAST_DISABLE_INTERRUPTS     

        add       rpT1 = PrDirectoryTableBase, rNewProc
        movl      rVa = KiPcr+PcPdeUtbase
        add       rpT2 = PrSessionParentBase, rNewProc
        movl      rVa2 = KiPcr+PcPdeStbase
        ;;

        ld8.nta   rPDE0 = [rpT1]                // rPDE0 = Page directory page 0
        ld8.nta   rSessionBase = [rpT2]
        ld8.nta   rVa = [rVa]
        ld8.nta   rVa2 = [rVa2]
        ;;

//
// To access IFA, ITDR registers, PSR.ic bit must be 0. Otherwise,
// it causes an illegal operation fault. While PSR.ic=0, any
// interruption can not be afforded. Make sure there will be no
// TLB miss and no interrupt coming in during this period.
//

        rsm       1 << PSR_IC                   // PSR.ic=0
        ;;

        srlz.d                                  // must serialize
        mov       rT1 = PAGE_SHIFT << IDTR_PS   // load page size field for IDTR
        ;;

        mov       cr.itir = rT1                 // set up IDTR for dirbase
        ptr.d     rVa, rT1                      // remove DTR for user space
        ;;
        mov       cr.ifa = rVa                  // set up IFA for dirbase vaddr
        mov       rT2   = DTR_UTBASE_INDEX
        ;;

        itr.d     dtr[rT2] = rPDE0              // insert PDE0 to DTR
        ;;

        ptr.d     rVa2, rT1                      // remove DTR for session
        ;;                                      // to avoid a overlapping error
        mov       cr.ifa = rVa2
        mov       rT2 = DTR_STBASE_INDEX
        ;;

        itr.d     dtr[rT2] = rSessionBase       // insert the root for session space
        ;;

        ssm       1 << PSR_IC                   // PSR.ic=1
        ;;
        srlz.i                                  // must I serialize

#if DBG

        mov     t0 = PbProcessorState+KpsSpecialRegisters+KsTrD0+(8*DTR_UTBASE_INDEX)
        movl    t3 = KiPcr + PcPrcb
        ;;

        ld8     t3 = [t3]
        mov     t1 = PbProcessorState+KpsSpecialRegisters+KsTrD0+(8*DTR_STBASE_INDEX)
        ;;

        add     t0 = t3, t0
        add     t1 = t3, t1
        ;;

        st8     [t0] = rPDE0
        st8     [t1] = rSessionBase
        ;;

#endif

        FAST_ENABLE_INTERRUPTS     

        //
        // Now make sure branch history is enabled for non wow processes
        // and disabled for wow processes
        //

        add       t1 = @gprel(KiVectorLogMask), gp
        ;;
        ld8       t1 = [t1]
        ;;
        cmp.eq    pt0 = t1, r0
(pt0)   br.cond.sptk   SkipBranchHistory

        mov     t1 = 3
        ;;
        mov     t2 = cpuid[t1]
        add     t3 = PrWow64Process, rNewProc
        ;;
        extr.u  t2 = t2, 24, 8
        ld4     t4 = [t3];
        ;;
        cmp.ne  pt1 = 7, t2
        ;;
        mov     t1 = 675
(pt1)   br.dpnt     SkipBranchHistory
        ;;
        mov     t2 = msr[t1]
        cmp.eq  pt1,pt2 = zero, t4      // Wow64 is non-zero
        ;;
(pt1)   mov t3 = 2                      // Enable the HB for ia64 procs
(pt2)   mov t3 = 256                    // Disable the HB for wow64 procs
        ;;
        dep     t2 = t3, t2, 0, 9      // Disable the HB for wow64 procs
        ;;
        mov     msr[t1] = t2;
        ;;

SkipBranchHistory:

#if !defined(NT_UP)
//
// Can now release the context swap lock
//

        movl        rpT1 = KiPcr+PcPrcb
        ;;
        ld8         rpT1 = [rpT1]
        ;;
        add         out0 = (LockQueueContextSwapLock * 16) + PbLockQueue, rpT1
        br.call.sptk brp = KeReleaseQueuedSpinLockFromDpcLevel
        ;;

#endif // !defined(NT_UP)

        NESTED_RETURN
        NESTED_EXIT(KiSwapProcess)

        SBTTL("Retire Deferred Procedure Call List")
//++
// Routine:
//
//    VOID
//    KiRetireDpcList (
//      PKPRCB Prcb,
//      )
//
// Routine Description:
//
//    This routine is called to retire the specified deferred procedure
//    call list. DPC routines are called using the idle thread (current)
//    stack.
//
//    N.B. Interrupts must be disabled on entry to this routine. Control is returned
//         to the caller with the same conditions true.
//
// Arguments:
//
//    a0 - Address of the current PRCB.
//
// Return value:
//
//    None.
//
//--

        NESTED_ENTRY(KiRetireDpcList)
        NESTED_SETUP(1,2,4,0)

        PROLOGUE_END


Krdl_Restart:

        add       t0 = PbDpcQueueDepth, a0
        add       t1 = PbDpcRoutineActive, a0
        add       t2 = PbDpcLock, a0
        ;;

        ld4       t4 = [t0]
        add       t3 = PbDpcListHead+LsFlink, a0
        ;;

Krdl_Restart2:

        cmp4.eq   pt1 = zero, t4
        st4       [t1] = t4
 (pt1)  br.spnt   Krdl_Exit
        ;;

#if !defined(NT_UP)
        ACQUIRE_SPINLOCK(t2, a0, Krdl_20)
#endif  // !defined(NT_UP)

        ld4       t4 = [t0]
        LDPTR     (t5, t3)             // -> first DPC entry
        ;;
        cmp4.eq   pt1, pt2 = zero, t4
        ;;

 (pt2)  add       t10 = LsFlink, t5
 (pt2)  add       out0 = -DpDpcListEntry, t5
 (pt1)  br.spnt   Krdl_Unlock
        ;;

        LDPTR     (t6, t10)
        add       t11 = DpDeferredRoutine, out0
        add       t12 = DpSystemArgument1, out0
        ;;

//
// Setup call to DPC routine
//
// arguments are:
//      dpc object address (out0)
//      deferred context   (out1)
//      system argument 1  (out2)
//      system argument 2  (out3)
//
// N.B. the arguments must be loaded from the DPC object BEFORE
//      the inserted flag is cleared to prevent the object being
//      overwritten before its time.
//

        ld8.nt1   t13 = [t11], DpDeferredContext-DpDeferredRoutine
        ld8.nt1   out2 = [t12], DpSystemArgument2-DpSystemArgument1
        ;;

        ld8.nt1   out1 = [t11], DpLock-DpDeferredContext
        ld8.nt1   out3 = [t12]
        add       t4 = -1, t4

        STPTRINC  (t3, t6, -LsFlink)
        ld8.nt1   t14 = [t13], 8
        add       t15 = LsBlink, t6
        ;;

        ld8.nt1   gp = [t13]
        STPTR     (t15, t3)

        STPTR     (t11, zero)
        st4       [t0] = t4

#if !defined(NT_UP)
        RELEASE_SPINLOCK(t2)             // set spin lock not owned
#endif //!defined(NT_UP)

        FAST_ENABLE_INTERRUPTS
        mov       bt0 = t14
        br.call.sptk.few.clr brp = bt0          // call DPC routine
        ;;

//
// Check to determine if any more DPCs are available to process.
//

        FAST_DISABLE_INTERRUPTS
        br        Krdl_Restart
        ;;

//
// The DPC list became empty while we were acquiring the DPC queue lock.
// Clear DPC routine active.  The race condition mentioned above doesn't
// exist here because we hold the DPC queue lock.
//

Krdl_Unlock:

#if !defined(NT_UP)
        add       t2 = PbDpcLock, a0
        ;;
        RELEASE_SPINLOCK(t2)
#endif // !defined(NT_UP)

Krdl_Exit:

        add       t0 = PbDpcQueueDepth, a0
        add       t1 = PbDpcRoutineActive, a0
        add       out0 = PbDpcInterruptRequested, a0
        ;;

        st4.nta   [t1] = zero
        st4.rel.nta [out0] = zero
        add       t2 = PbDpcLock, a0

        ld4       t4 = [t0]
        add       t3 = PbDpcListHead+LsFlink, a0
        ;;

        cmp4.eq   pt1, pt2 = zero, t4
 (pt2)  br.spnt   Krdl_Restart2
        ;;

        NESTED_RETURN
        NESTED_EXIT(KiRetireDpcList)

        SBTTL("Dispatch Interrupt")
//++
//--------------------------------------------------------------------
// Routine:
//
//     KiDispatchInterrupt
//
// Routine Description:
//
//    This routine is entered as the result of a software interrupt generated
//    at DISPATCH_LEVEL. Its function is to process the Deferred Procedure Call
//    (DPC) list, and then perform a context switch if a new thread has been
//    selected for execution on the processor.
//
//    This routine is entered at IRQL DISPATCH_LEVEL with the dispatcher
//    database unlocked. When a return to the caller finally occurs, the
//    IRQL remains at DISPATCH_LEVEL, and the dispatcher database is still
//    unlocked.
//
//    N.B. On entry to this routine the volatile states (excluding high
//         floating point register set) have been saved.
//
// On entry:
//
//    sp - points to stack scratch area.
//
// Arguments:
//
//    None
//
// Return Value:
//
//    None.
//--------------------------------------------------------------------
//--
        NESTED_ENTRY(KiDispatchInterrupt)
        PROLOGUE_BEGIN

        .regstk   0, 4, 2, 0
        alloc     t16 = ar.pfs, 0, 4, 2, 0
        .save     rp, loc0
        mov       loc0 = brp
        .fframe   SwitchFrameLength
        add       sp = -SwitchFrameLength, sp
        ;;

        .save     ar.unat, loc1
        mov       loc1 = ar.unat
        add       t0 = ExFltS19+SwExFrame+STACK_SCRATCH_AREA, sp
        add       t1 = ExFltS18+SwExFrame+STACK_SCRATCH_AREA, sp
        ;;

        .save.gf  0x0, 0xC0000
        stf.spill [t0] = fs19, ExFltS17-ExFltS19
        stf.spill [t1] = fs18, ExFltS16-ExFltS18
        ;;

        .save.gf  0x0, 0x30000
        stf.spill [t0] = fs17, ExFltS15-ExFltS17
        stf.spill [t1] = fs16, ExFltS14-ExFltS16
        mov       t10 = bs4
        ;;

        .save.gf  0x0, 0xC000
        stf.spill [t0] = fs15, ExFltS13-ExFltS15
        stf.spill [t1] = fs14, ExFltS12-ExFltS14
        mov       t11 = bs3
        ;;

        .save.gf  0x0, 0x3000
        stf.spill [t0] = fs13, ExFltS11-ExFltS13
        stf.spill [t1] = fs12, ExFltS10-ExFltS12
        mov       t12 = bs2
        ;;

        .save.gf  0x0, 0xC00
        stf.spill [t0] = fs11, ExFltS9-ExFltS11
        stf.spill [t1] = fs10, ExFltS8-ExFltS10
        mov       t13 = bs1
        ;;

        .save.gf  0x0, 0x300
        stf.spill [t0] = fs9, ExFltS7-ExFltS9
        stf.spill [t1] = fs8, ExFltS6-ExFltS8
        mov       t14 = bs0
        ;;

        .save.gf  0x0, 0xC0
        stf.spill [t0] = fs7, ExFltS5-ExFltS7
        stf.spill [t1] = fs6, ExFltS4-ExFltS6
        mov       t15 = ar.lc
        ;;

        .save.gf  0x0, 0x30
        stf.spill [t0] = fs5, ExFltS3-ExFltS5
        stf.spill [t1] = fs4, ExFltS2-ExFltS4
        ;;

        .save.f   0xC
        stf.spill [t0] = fs3, ExFltS1-ExFltS3         // save fs3
        stf.spill [t1] = fs2, ExFltS0-ExFltS2         // save fs2
        ;;

        .save.f   0x3
        stf.spill [t0] = fs1, ExBrS4-ExFltS1          // save fs1
        stf.spill [t1] = fs0, ExBrS3-ExFltS0          // save fs0
        ;;

        .save.b   0x18
        st8       [t0] = t10, ExBrS2-ExBrS4           // save bs4
        st8       [t1] = t11, ExBrS1-ExBrS3           // save bs3
        ;;

        .save.b   0x6
        st8       [t0] = t12, ExBrS0-ExBrS2           // save bs2
        st8       [t1] = t13, ExIntS2-ExBrS1          // save bs1
        ;;

        .save.b   0x1
        st8       [t0] = t14, ExIntS3-ExBrS0          // save bs0
        ;;

        .save.gf  0xC, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s3, ExIntS1-ExIntS3          // save s3
        .mem.offset 8,0
        st8.spill [t1] = s2, ExIntS0-ExIntS2          // save s2
        ;;

        .save.gf  0x3, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s1, ExApLC-ExIntS1           // save s1
        .mem.offset 8,0
        st8.spill [t1] = s0, ExApEC-ExIntS0           // save s0
        ;;

        .savepsp  ar.pfs, ExceptionFrameLength-ExApEC-STACK_SCRATCH_AREA
        st8       [t1] = t16, ExIntNats-ExApEC
        mov       t4 = ar.unat                        // captured Nats of s0-s3
        ;;

        .savepsp  ar.lc, ExceptionFrameLength-ExApLC-STACK_SCRATCH_AREA
        st8       [t0] = t15
        .savepsp  @priunat, ExceptionFrameLength-ExIntNats-STACK_SCRATCH_AREA
        st8       [t1] = t4                           // save Nats of s0-s3

        PROLOGUE_END

//
// Register aliases
//

        rPrcb     = loc2
        rKerGP    = loc3

        rpT1      = t0
        rpT2      = t1
        rT1       = t2
        rT2       = t3
        rpDPLock  = t4                          // pointer to dispatcher lock

        pNoTh     = pt1                         // No next thread to run
        pNext     = pt2                         // next thread not null
        pNull     = pt3                         // no thread available
        pOwned    = pt4                         // dispatcher lock already owned
        pNotOwned = pt5
        pQEnd     = pt6                         // quantum end request pending
        pNoQEnd   = pt7                         // no quantum end request pending

//
// Increment the dispatch interrupt count
//

        mov       rKerGP = gp                   // save gp
        movl      rPrcb = KiPcr + PcPrcb
        ;;

        LDPTR     (rPrcb, rPrcb)                 // rPrcb -> Prcb
        ;;
        add       rpT1 = PbDispatchInterruptCount, rPrcb
        ;;
        ld4       rT1 = [rpT1]
        ;;
        add       rT1 = rT1, zero, 1
        ;;
        st4       [rpT1] = rT1

// **** TBD **** use alpha optimization to first check Dpc Q depth


//
// Process the DPC list
//

Kdi_PollDpcList:

//
// Process the deferred procedure call list.
//

        FAST_ENABLE_INTERRUPTS
        ;;
        srlz.d

//
// **** TBD ***** No stack switch as in alpha, mips...
// Save current initial stack address and set new initial stack address.
//

        FAST_DISABLE_INTERRUPTS
        mov      out0 = rPrcb
        br.call.sptk brp = KiRetireDpcList
        ;;


//
// Check to determine if quantum end has occured.
//
// N.B. If a new thread is selected as a result of processing a quantum
//      end request, then the new thread is returned with the dispatcher
//      database locked. Otherwise, NULL is returned with the dispatcher
//      database unlocked.
//

        FAST_ENABLE_INTERRUPTS
        add       rpT1 = PbQuantumEnd, rPrcb
        ;;

        ld4       rT1 = [rpT1]                  // get quantum end indicator
        ;;
        cmp4.ne   pQEnd, pNoQEnd = rT1, zero    // if zero, no quantum end reqs
        mov       gp = rKerGP                   // restore gp
        ;;

(pQEnd) st4       [rpT1] = zero                 // clear quantum end indicator
(pNoQEnd) br.cond.sptk Kdi_NoQuantumEnd
(pQEnd) br.call.spnt brp = KiQuantumEnd         // call KiQuantumEnd (C code)
        ;;

        cmp4.eq   pNoTh, pNext = v0, zero       // pNoTh = no next thread
(pNoTh) br.dpnt   Kdi_Exit                      // br to exit if no next thread
(pNext) br.dpnt   Kdi_Swap                      // br to swap to next thread

//
// If no quantum end requests:
// Check to determine if a new thread has been selected for execution on
// this processor.
//

Kdi_NoQuantumEnd:
        add       rpT2 = PbNextThread, rPrcb
        ;;
        LDPTR     (rT1, rpT2)                   // rT1 = address of next thread object
        ;;

        cmp.eq    pNull = rT1, zero             // pNull => no thread selected
(pNull) br.dpnt   Kdi_Exit                      // exit if no thread selected

#if !defined(NT_UP)

//
// try to acquire the dispatcher database lock.
//

        mov       out0 = LockQueueDispatcherLock
        movl      out1 = KiPcr+PcSystemReserved+8
        br.call.sptk brp = KeTryToAcquireQueuedSpinLockRaiseToSynch
        ;;

        cmp.ne    pOwned, pNotOwned = TRUE, v0  // pOwned = 1 if not free
(pOwned) br.dpnt   Kdi_PollDpcList              // br out if owned
        ;;

#else

        mov       rT1 = SYNCH_LEVEL
        ;;
        SET_IRQL  (rT1)

#endif // !defined(NT_UP)

//
// Reread address of next thread object since it is possible for it to
// change in a multiprocessor system.
//

Kdi_Swap:

        add       rpT2 = PbNextThread, rPrcb    // -> next thread
        movl      rpT1 = KiPcr + PcCurrentThread
        ;;

        LDPTR     (s1, rpT1)                    // current thread object
        LDPTR     (s2, rpT2)                    // next thread object
        add       rpT1 = PbCurrentThread, rPrcb
        ;;


//
// Reready current thread for execution and swap context to the selected
// thread.
//
// Note:  Set IdleSwapBlock in the current thread so no idle processor
// can switch to this processor before it is removed from the current
// processor.
//

        STPTR     (rpT2, zero)                  // clear addr of next thread
        add       out0 = ThIdleSwapBlock, s1    // block swap from idle
        mov       rT1 = 1
        ;;

        STPTR     (rpT1, s2)                    // set addr of current thread
        st1       [out0] = rT1, -ThIdleSwapBlock// set addr of previous thread
        br.call.sptk brp = KiReadyThread        // call KiReadyThread(OldTh)
        ;;

        mov       s0 = rPrcb                    // setup call
        cmp.ne    pt0 = zero, zero              // no need to lock context swap
        br.call.sptk brp = SwapContext          // call SwapContext(Prcb, OldTh, NewTh)
        ;;

//
// Restore saved registers, and return.
//

        add       out0 = STACK_SCRATCH_AREA+SwExFrame, sp
        br.call.sptk brp = KiRestoreExceptionFrame
        ;;

Kdi_Exit:

        add       rpT1 = ExApEC+SwExFrame+STACK_SCRATCH_AREA, sp
        ;;
        ld8       rT1 = [rpT1]
        mov       brp = loc0
        ;;

        mov       ar.unat = loc1
        mov       ar.pfs = rT1
        .restore
        add       sp = SwitchFrameLength, sp
        br.ret.sptk brp

        NESTED_EXIT(KiDispatchInterrupt)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\em_prototypes.h ===
/******************************
Intel Confidential
******************************/

#ifndef _EM_PROTOTYPES_H
#define _EM_PROTOTYPES_H

#ifndef INLINE
#define INLINE
#endif

#if !(defined(BIG_ENDIAN) || defined(LITTLE_ENDIAN))
    #error Endianness not established; define BIG_ENDIAN or LITTLE_ENDIAN
#endif


/**********************************************/
/* Assembler Supported Instruction Prototypes */
/**********************************************/

/* Floating-point Absolute Maximum */
void
fp82_famax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

/* Floating-point Parallel Absolute Maximum */

void
fp82_fpamax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

/* Floating-point Absolute Minimum */
void
fp82_famin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Floating-point Parallel Absolute Minimum */

void
fp82_fpamin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Floating-point Compare */

void
fp82_fcmp_eq(EM_state_type *ps,
    EM_opcode_ctype_type ctype,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_pred_reg_specifier p1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fcmp_lt(EM_state_type *ps,
    EM_opcode_ctype_type ctype,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_pred_reg_specifier p1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fcmp_le(EM_state_type *ps,
    EM_opcode_ctype_type ctype,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_pred_reg_specifier p1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


void
fp82_fcmp_unord(EM_state_type *ps,
    EM_opcode_ctype_type ctype,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_pred_reg_specifier p1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Floating-point Paralel Compare */

void
fp82_fpcmp_eq(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_lt(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_le(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_unord(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_neq(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_nlt(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_nle(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_ord(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Convert Floating-point to Integer */

void
fp82_fcvt_fx(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);

void
fp82_fcvt_fx_trunc(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);

void
fp82_fcvt_fxu(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);

void
fp82_fcvt_fxu_trunc(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);


/* Parallel Convert Floating-point to Integer */

void
fp82_fpcvt_fx(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);

void
fp82_fpcvt_fx_trunc(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);

void
fp82_fpcvt_fxu(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);

void
fp82_fpcvt_fxu_trunc(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);



/* Floating-point Multiply Add */

void
fp82_fma(EM_state_type *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
    EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2);


/* Floating Point Parallel Multiply Add */
void
fp82_fpma(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
    EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2);


/* Floating-point Maximum */
void
fp82_fmax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Floating-point Parallel Maximum */
void
fp82_fpmax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

/* Floating-point Minimum */
void
fp82_fmin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Floating-point Parallel Minimum */
void
fp82_fpmin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Floating-point Multiply Subtract */
void
fp82_fms(EM_state_type *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
     EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2);


/* Floating-point Parallel Multiply Subtract */
void
fp82_fpms(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
    EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2);



/* Floating-point Negative Multiply Add */
void
fp82_fnma(EM_state_type *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
     EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2);


/* Floating-point Parallel Negative Multiply Add */

void
fp82_fpnma(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
     EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2);


/* Floating-point Reciprocal Approximation */
void
fp82_frcpa(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

/* Floating-point Parallel Reciprocal Approximation */
void
fp82_fprcpa(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

/* Floating-point Reciprocal Square Root Approximation */
void
fp82_frsqrta(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f3);


/* Floating-point Parallel Reciprocal Square Root Approximation */
void
fp82_fprsqrta(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f3);


/******************************************************************************/
/* Define macros to simplify access to the fp82_ functions.  This is done so  */
/*  the namespace doesn't get cluttered, while retaining convenient access.   */
/*  The FP82_NO_SHORTCUTS macro can be defined to prevent creation of these.  */
/******************************************************************************/

#ifndef FP82_NO_SHORTCUTS
#define famax           fp82_famax
#define fpamax          fp82_fpamax
#define famin           fp82_famin
#define fpamin          fp82_fpamin

#define fcmp_eq         fp82_fcmp_eq
#define fcmp_lt         fp82_fcmp_lt
#define fcmp_le         fp82_fcmp_le
#define fcmp_unord      fp82_fcmp_unord

#define fpcmp_eq        fp82_fpcmp_eq
#define fpcmp_lt        fp82_fpcmp_lt
#define fpcmp_le        fp82_fpcmp_le
#define fpcmp_unord     fp82_fpcmp_unord
#define fpcmp_neq       fp82_fpcmp_neq
#define fpcmp_nlt       fp82_fpcmp_nlt
#define fpcmp_nle       fp82_fpcmp_nle
#define fpcmp_ord       fp82_fpcmp_ord

#define fcvt_fx         fp82_fcvt_fx
#define fcvt_fx_trunc   fp82_fcvt_fx_trunc
#define fcvt_fxu        fp82_fcvt_fxu
#define fcvt_fxu_trunc  fp82_fcvt_fxu_trunc

#define fpcvt_fxu_trunc fp82_fpcvt_fxu_trunc
#define fpcvt_fxu       fp82_fpcvt_fxu
#define fpcvt_fx        fp82_fpcvt_fx
#define fpcvt_fx_trunc  fp82_fpcvt_fx_trunc


#define fma             fp82_fma
#define fpma            fp82_fpma
#define fmax            fp82_fmax
#define fpmax           fp82_fpmax
#define fmin            fp82_fmin
#define fpmin           fp82_fpmin
#define fms             fp82_fms
#define fpms            fp82_fpms
#define fnma            fp82_fnma
#define fpnma           fp82_fpnma
#define frcpa           fp82_frcpa
#define fprcpa          fp82_fprcpa
#define frsqrta         fp82_frsqrta
#define fprsqrta        fp82_fprsqrta

#endif /* FP82_NO_SHORTCUTS */


#endif /* _EM_PROTOTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\fehelper.c ===
/******************************
Intel Confidential
******************************/

// MACH
#include "ki.h"

#ifndef WIN32_OR_WIN64
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>
#endif

#include "fepublic.h"
#include "fehelper.h"
#include "festate.h"

// MACH #ifdef WIN32_OR_WIN64
// MACH #include <process.h>
// MACH #endif

// *************************************************************
// The functions fp_reg_read_hi() and fp_reg_read_lo()
// Take a packed floating-point register, 
// Reads the hi (or lo) part
// Returns a register-biased number with implicit made explicit.
// *************************************************************
EM_uint64_t
fp_concatenate(EM_uint_t hi_val, EM_uint_t lo_val) {
   return(  ((EM_uint64_t)hi_val <<32)
          | ((EM_uint64_t)lo_val & CONST_FORMAT(0x00000000FFFFFFFF )) );
}


EM_uint_t 
fp_extract_bits(
   EM_uint64_t  input_value, 
   unsigned int hi_bound, 
   unsigned int lo_bound)
{
EM_uint64_t value;
   if(lo_bound >63) return(0x00000000);

   value = (input_value >> lo_bound) &
           ~(CONST_FORMAT(0xFFFFFFFFFFFFFFFF) << (hi_bound - lo_bound + 1));

   return((EM_uint_t)value);
}


INLINE EM_fp_reg_type
fp_reg_read_hi(EM_uint_t freg)
{
EM_fp_reg_type tmp_freg = FR[freg];
EM_memory_type mem;

    if (freg == 0)
        return (FP_ZERO);
    else if (freg == 1) {
        return (FP_NEG_ZERO);
    }
    else {
        mem.uint_32.uvalue = (EM_uint_t)(tmp_freg.significand >> 32);
        tmp_freg = fp_mem_to_fr_format(mem, 4, 0);
        return (tmp_freg);
    }
}

INLINE EM_fp_reg_type
fp_reg_read_lo(EM_uint_t freg)
{
EM_fp_reg_type tmp_freg = FR[freg];
EM_memory_type mem;
EM_uint64_t tmp_val;
EM_uint_t   tmp32_val;

    if (freg == 0)
        return (FP_ZERO);
    else if (freg == 1) {
        return (FP_ZERO);
    }
    else {
        tmp_val = (tmp_freg.significand & CONST_FORMAT(0x00000000ffffffff));
        tmp32_val = (EM_uint_t)tmp_val;
        mem.uint_32.uvalue = tmp32_val;
        tmp_freg = fp_mem_to_fr_format(mem, 4, 0);
        return (tmp_freg);
    }
}


#undef fp_reg_read_hi
#undef fp_reg_read_lo

#define fp_reg_read_hi(f2)            fp82_reg_read_hi(ps,f2)
#define fp_reg_read_lo(f3)            fp82_reg_read_lo(ps,f3)


// ***********************************************************
// fp_fr_to_mem_format()
// ************************************************************
EM_memory_type
fp_fr_to_mem_format(
    EM_fp_reg_type freg,
    EM_uint_t      size,
    EM_uint_t      integer_form)
{
EM_memory_type tmp_mem;
EM_uint64_t    tmp_significand;

    switch(size) {
        case 4:
            tmp_mem.fp_single.sign = freg.sign;
            if (freg.exponent == 0)
                tmp_mem.fp_single.exponent = 0;
            else if ((freg.significand>>63) == 0)
                tmp_mem.fp_single.exponent = 0;
            else if (freg.exponent == FP_REG_EXP_ONES)
                tmp_mem.fp_single.exponent = FP_SGL_EXP_ONES;
            else 
                tmp_mem.fp_single.exponent    = 
                                         ((freg.exponent 
                                           >> (FP_REG_EXP_WIDTH-1) & 1) 
                                           << (FP_SGL_EXP_WIDTH-1))
                                        |( freg.exponent & FP_SGL_BIAS);

            tmp_mem.fp_single.significand =
                    (EM_uint_t)((freg.significand <<1) >>(63-22));
            break;

        case 8: /* double */
            if (integer_form)
                tmp_mem.uint_64.uvalue = freg.significand;

            else { /* !integer_form */
                tmp_mem.fp_double.sign = freg.sign;
                if (freg.exponent == 0)
                    tmp_mem.fp_double.exponent = 0;
                else if ((freg.significand>>63) == 0)
                    tmp_mem.fp_double.exponent = 0;
                else if (freg.exponent == FP_REG_EXP_ONES)
                    tmp_mem.fp_double.exponent = FP_DBL_EXP_ONES;
                else
                    tmp_mem.fp_double.exponent    = 
                                         ((freg.exponent 
                                           >> (FP_REG_EXP_WIDTH-1) & 1) 
                                           << (FP_DBL_EXP_WIDTH-1))
                                        |( freg.exponent & FP_DBL_BIAS);

                tmp_significand = 
                        (freg.significand <<1) >> (63-51);

                tmp_mem.fp_double.significand_hi = 
                  (EM_uint_t)((tmp_significand >> 32) & CONST_FORMAT( 0x00000000ffffffff));
                tmp_mem.fp_double.significand_lo = 
                  (EM_uint_t)(tmp_significand & CONST_FORMAT( 0x00000000ffffffff));
            }    
            break;

        case 10: /* double extended */
          tmp_mem.fp_double_extended.sign = freg.sign;
            if (freg.exponent == 0) {
                    /* Zero or (Pseudo-)Denormal */
                tmp_mem.fp_double_extended.exponent = 0;
            } else if (freg.exponent == FP_REG_EXP_ONES) {
                    /* Inf/NaN/NatVAL */
                tmp_mem.fp_double_extended.exponent = FP_EXT_EXP_ONES;
            } else {
                    /* Normal or Unnormal */
                    tmp_mem.fp_double_extended.exponent    = 
                                         ((freg.exponent 
                                           >> (FP_REG_EXP_WIDTH-1) & 1) 
                                           << (FP_EXT_EXP_WIDTH-1))
                                        |( freg.exponent & FP_EXT_BIAS);

            }
	    memcpy(tmp_mem.fp_double_extended.significand,
		    &freg.significand, 8);

            break;

        case 16: /* spill */
            tmp_mem.fp_spill_fill.reserved1    = 0;
            tmp_mem.fp_spill_fill.reserved2    = 0;
            tmp_mem.fp_spill_fill.sign         = freg.sign;
            tmp_mem.fp_spill_fill.exponent     = freg.exponent;
            tmp_mem.fp_spill_fill.significand  = freg.significand;
            break;
    }
    return (tmp_mem);
}


INLINE EM_memory_type
fr_to_mem4_bias_adjust(EM_fp_reg_type freg)
{
EM_memory_type tmp_mem;

   tmp_mem.fp_single.sign = freg.sign;
   if (freg.exponent == 0)
      tmp_mem.fp_single.exponent = 0;
   else if (freg.exponent == FP_REG_EXP_ONES)
      tmp_mem.fp_single.exponent = FP_SGL_EXP_ONES;
   else if ((freg.significand>>63) == 0)
      tmp_mem.fp_single.exponent = (EM_uint_t)
                                 (((EM_int_t)freg.exponent)
                                 - FP_REG_BIAS + FP_SGL_BIAS - 1);
   else
      tmp_mem.fp_single.exponent = (EM_uint_t)
                                 (((EM_int_t)freg.exponent)
                                 - FP_REG_BIAS + FP_SGL_BIAS);
      tmp_mem.fp_single.significand = (EM_uint_t) (
                    (freg.significand<<(64-62-1))>>(40+64-62-1));

    return (tmp_mem);
}




// *****************************************************
// helper functions definitions 
// *****************************************************

INLINE EM_boolean_t
fp_equal(EM_fp_reg_type fr1, EM_fp_reg_type fr2)
{
    EM_fp_dp_type fp_dp1;
    EM_fp_dp_type fp_dp2;

    if (   fp_is_nan(fr1)         || fp_is_nan(fr2)
        || fp_is_unsupported(fr1) || fp_is_unsupported(fr2) )
        return (0);

    fp_dp1 = fp_fr_to_dp(fr1);
    fp_dp2 = fp_fr_to_dp(fr2);

    if (   (fp_dp1.sign           == fp_dp2.sign          )
        && (fp_dp1.exponent       == fp_dp2.exponent      )
        && (fp_dp1.significand.hi == fp_dp2.significand.hi)
        && (fp_dp1.significand.lo == fp_dp2.significand.lo) )
        return (1);
    else if ( fp_is_zero_dp(fp_dp1) && fp_is_zero_dp(fp_dp2) )
        return (1);
    else
        return (0);
}


INLINE EM_boolean_t
fp_less_than(
   EM_fp_reg_type fr1, 
   EM_fp_reg_type fr2) 
{
EM_fp_dp_type fp_dp1;
EM_fp_dp_type fp_dp2;

    if (   fp_is_nan(fr1)         || fp_is_nan(fr2)
        || fp_is_unsupported(fr1) || fp_is_unsupported(fr2) )
        return (0);

    fp_dp1 = fp_fr_to_dp(fr1);
    fp_dp2 = fp_fr_to_dp(fr2);

    if (fp_is_neg_dp(fp_dp1) && fp_is_pos_dp(fp_dp2)) {
        if (!fp_is_zero_dp(fp_dp1) || !fp_is_zero_dp(fp_dp2) )
            return (1);             /* for non-zero's neg is lt pos */
        else
            return (0);             /* zeros are equal */
    } else if (fp_is_pos_dp(fp_dp1) && fp_is_neg_dp(fp_dp2)) {
        return (0);                 /* pos is not lt neg */
    } else if (fp_is_neg_dp(fp_dp1) && fp_is_neg_dp(fp_dp2)) {
        if (fp_dp1.exponent > fp_dp2.exponent)
            return (1);             /* fp_dp1 much less than fp_dp2 */
        else if ((fp_dp1.exponent == fp_dp2.exponent)
                && (fp_U128_gt(fp_dp1.significand, fp_dp2.significand)))
            return (1);             /* fp_dp1 just less than fp_dp2 */
        else
            return (0);
    } else if (fp_is_pos_dp(fp_dp1) && fp_is_pos_dp(fp_dp2)) {
        if (fp_dp1.exponent < fp_dp2.exponent)
                return (1);         /* fp_dp1 much less than fp_dp2 */
        else if ((fp_dp1.exponent == fp_dp2.exponent)
                && (fp_U128_lt(fp_dp1.significand, fp_dp2.significand)))
            return (1);             /* fp_dp1 just less than fp_dp2 */
        else
            return (0);
    } else {
      return (0); // MACH ADDED
    }
}

INLINE EM_boolean_t
fp_lesser_or_equal(EM_fp_reg_type fr1, EM_fp_reg_type fr2)
{
    EM_fp_dp_type fp_dp1;
    EM_fp_dp_type fp_dp2;

    if (   fp_is_nan(fr1)         || fp_is_nan(fr2)
        || fp_is_unsupported(fr1) || fp_is_unsupported(fr2) )
        return (0);

    fp_dp1 = fp_fr_to_dp(fr1);
    fp_dp2 = fp_fr_to_dp(fr2);

    if (fp_is_neg_dp(fp_dp1) && fp_is_pos_dp(fp_dp2)) {
        return (1);              /* for non-zero's and zeros's neg is le pos */
    } else if (fp_is_pos_dp(fp_dp1) && fp_is_neg_dp(fp_dp2)) {
        if (fp_is_zero_dp(fp_dp1) && fp_is_zero_dp(fp_dp2))
            return (1);          /* zero's are le */
        else
            return (0);          /* pos is not lt neg */
    } else if (fp_is_neg_dp(fp_dp1) && fp_is_neg_dp(fp_dp2)) {
        if (fp_dp1.exponent > fp_dp2.exponent)
            return (1);          /* fp_dp1 much less than fp_dp2 */
        else if ((fp_dp1.exponent == fp_dp2.exponent)
                && (fp_U128_ge(fp_dp1.significand, fp_dp2.significand)))
            return (1);          /* fp_dp1 just less than or equal fp_dp2 */
        else
            return (0);
    } else if (fp_is_pos_dp(fp_dp1) && fp_is_pos_dp(fp_dp2)) {
        if (fp_dp1.exponent < fp_dp2.exponent)
                return (1);      /* fp_dp1 much less than fp_dp2 */
        else if ((fp_dp1.exponent == fp_dp2.exponent)
                && (fp_U128_le(fp_dp1.significand, fp_dp2.significand)))
            return (1);          /* fp_dp1 just less than or equal fp_dp2 */
        else
            return (0);
    } else {
      return (0); // MACH ADDED
    }
}

INLINE EM_boolean_t
fp_unordered(EM_fp_reg_type fr1, EM_fp_reg_type fr2)
{
    if (   fp_is_nan(fr1)         || fp_is_nan(fr2)
        || fp_is_unsupported(fr1) || fp_is_unsupported(fr2) )
        return (1);
    else 
        return (0);

}

EM_uint_t
fp82_fp_decode_fault(EM_tmp_fp_env_type tmp_fp_env)
{
EM_uint_t tmp_ret = 0;

    if (!tmp_fp_env.simd) { // MACH ADDED

      if (tmp_fp_env.em_faults.swa)
          return (8);
      else if (tmp_fp_env.em_faults.v)
          return (1);
      else if (tmp_fp_env.em_faults.z)
          return (4);
      else if (tmp_fp_env.em_faults.d)
          return (2);
      else {
          tmp_ret = 0;
          return (0); // MACH ADDED
      }

   } else {

// ****************************************************
// hi_faults are recorded in the low  four bits of temp_ret.
// lo_faults are recorded in the high four bits of temp_ret.
// ****************************************************

        if (tmp_fp_env.hi_faults.swa)
            tmp_ret = 8;
        else if (tmp_fp_env.hi_faults.v)
            tmp_ret = 1;
        else if (tmp_fp_env.hi_faults.z)
            tmp_ret = 4;
        else if (tmp_fp_env.hi_faults.d)
            tmp_ret = 2;

        if (tmp_fp_env.lo_faults.swa)
            tmp_ret |= 8<<4;
        else if (tmp_fp_env.lo_faults.v)
            tmp_ret |= 1<<4;
        else if (tmp_fp_env.lo_faults.z)
            tmp_ret |= 4<<4;
        else if (tmp_fp_env.lo_faults.d)
            tmp_ret |= 2<<4;
        return (tmp_ret);
    }
}


EM_uint_t
fp82_fp_decode_trap(EM_tmp_fp_env_type tmp_fp_env)
{
EM_uint_t tmp_ret;

    if (!tmp_fp_env.simd) {
        tmp_ret  = (tmp_fp_env.ebc       <<15
                  | tmp_fp_env.fpa       <<14
                  | tmp_fp_env.em_traps.i<<13
                  | tmp_fp_env.em_traps.un<<12
                  | tmp_fp_env.em_traps.o<<11 ); // MACH
    } 
    else {
       tmp_ret = 0;
       if(tmp_fp_env.hi_traps.i || 
          tmp_fp_env.hi_traps.un || 
          tmp_fp_env.hi_traps.o ) { // MACH
       
          tmp_ret  = tmp_fp_env.hi_fpa    <<14
                   | tmp_fp_env.hi_traps.i<<13
                   | tmp_fp_env.hi_flags.i<<13
                   | tmp_fp_env.hi_traps.un<<12
                   | tmp_fp_env.hi_traps.o<<11; // MACH
       }
       
       if(tmp_fp_env.lo_traps.i || 
          tmp_fp_env.lo_traps.un || 
          tmp_fp_env.lo_traps.o ) { // MACH

          tmp_ret |= tmp_fp_env.lo_fpa    <<10
                   | tmp_fp_env.lo_traps.i<<9
                   | tmp_fp_env.lo_flags.i<<9
                   | tmp_fp_env.lo_traps.un<<8
                   | tmp_fp_env.lo_traps.o<<7; // MACH
      }
    } 
    return (tmp_ret);
}


void
fp_decode_environment(
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_tmp_fp_env_type *tmp_fp_env)
{
EM_sf_type         tmp_sf;

    if (sf == sfS0) {
        tmp_sf.controls.ftz = FPSR.sf0_controls_ftz;
        tmp_sf.controls.wre = FPSR.sf0_controls_wre;
        tmp_sf.controls.pc  = FPSR.sf0_controls_pc;
        tmp_sf.controls.rc  = FPSR.sf0_controls_rc;
        tmp_sf.controls.td  = FPSR.sf0_controls_td;
    } else if (sf == sfS1) {
        tmp_sf.controls.ftz = FPSR.sf1_controls_ftz;
        tmp_sf.controls.wre = FPSR.sf1_controls_wre;
        tmp_sf.controls.pc  = FPSR.sf1_controls_pc;
        tmp_sf.controls.rc  = FPSR.sf1_controls_rc;
        tmp_sf.controls.td  = FPSR.sf1_controls_td;
    } else if (sf == sfS2) {
        tmp_sf.controls.ftz = FPSR.sf2_controls_ftz;
        tmp_sf.controls.wre = FPSR.sf2_controls_wre;
        tmp_sf.controls.pc  = FPSR.sf2_controls_pc;
        tmp_sf.controls.rc  = FPSR.sf2_controls_rc;
        tmp_sf.controls.td  = FPSR.sf2_controls_td;
    } else if (sf == sfS3) {
        tmp_sf.controls.ftz = FPSR.sf3_controls_ftz;
        tmp_sf.controls.wre = FPSR.sf3_controls_wre;
        tmp_sf.controls.pc  = FPSR.sf3_controls_pc;
        tmp_sf.controls.rc  = FPSR.sf3_controls_rc;
        tmp_sf.controls.td  = FPSR.sf3_controls_td;
    } else {
        tmp_sf.controls.ftz = 0;
        tmp_sf.controls.wre = 1;
        tmp_sf.controls.pc  = sf_double_extended;
        tmp_sf.controls.rc  = rc_rn;
        tmp_sf.controls.td  = 1;
    }

    if (sf == sf_none) {
        tmp_fp_env->controls.vd = 0;
        tmp_fp_env->controls.dd = 0;
        tmp_fp_env->controls.zd = 0;
        tmp_fp_env->controls.od = 0;
        tmp_fp_env->controls.ud = 0;
        tmp_fp_env->controls.id = 0;

    } else if (tmp_sf.controls.td )  {
        tmp_fp_env->controls.vd = 1;
        tmp_fp_env->controls.dd = 1;
        tmp_fp_env->controls.zd = 1;
        tmp_fp_env->controls.od = 1;
        tmp_fp_env->controls.ud = 1;
        tmp_fp_env->controls.id = 1;

    } else {
        tmp_fp_env->controls.vd = FPSR.traps_vd;
        tmp_fp_env->controls.dd = FPSR.traps_dd;
        tmp_fp_env->controls.zd = FPSR.traps_zd;
        tmp_fp_env->controls.od = FPSR.traps_od;
        tmp_fp_env->controls.ud = FPSR.traps_ud;
        tmp_fp_env->controls.id = FPSR.traps_id;
    }

    if (pc == pc_none) {
        tmp_fp_env->ss = ss_double_extended_64;
        tmp_fp_env->es = es_seventeen_bits;
        tmp_fp_env->simd = 0;

    } else if (pc == pc_simd) {
        tmp_fp_env->ss = ss_single_24;
        tmp_fp_env->es = es_eight_bits;
        tmp_fp_env->simd = 1;
        if (tmp_sf.controls.wre)
            tmp_sf.controls.wre = 0;
        tmp_fp_env->hi_flags.v = 0;
        tmp_fp_env->hi_flags.d = 0;
        tmp_fp_env->hi_flags.z = 0;
        tmp_fp_env->hi_flags.o = 0;
        tmp_fp_env->hi_flags.un = 0; 
        tmp_fp_env->hi_flags.i = 0;
        tmp_fp_env->lo_flags.v = 0;
        tmp_fp_env->lo_flags.d = 0;
        tmp_fp_env->lo_flags.z = 0;
        tmp_fp_env->lo_flags.o = 0;
        tmp_fp_env->lo_flags.un = 0; 
        tmp_fp_env->lo_flags.i = 0;

    } else if (pc == pc_s) {
        tmp_fp_env->ss = ss_single_24;
        tmp_fp_env->simd = 0;
        if (tmp_sf.controls.wre)
            tmp_fp_env->es = es_seventeen_bits;
        else
            tmp_fp_env->es = es_eight_bits;

    } else if (pc == pc_d) {
        tmp_fp_env->ss = ss_double_53;
        tmp_fp_env->simd = 0;
        if (tmp_sf.controls.wre)
            tmp_fp_env->es = es_seventeen_bits;
        else
            tmp_fp_env->es = es_eleven_bits;

    } else if (pc == pc_sf) {
        tmp_fp_env->simd = 0;
        if (tmp_sf.controls.pc == sf_single)
            tmp_fp_env->ss = ss_single_24;
        else if (tmp_sf.controls.pc == sf_double)
            tmp_fp_env->ss = ss_double_53;
        else if (tmp_sf.controls.pc == sf_double_extended)
            tmp_fp_env->ss = ss_double_extended_64;

        if (tmp_sf.controls.wre)
            tmp_fp_env->es = es_seventeen_bits;
        else
            tmp_fp_env->es = es_fifteen_bits;
    }

    if (sf == sf_none) {
        tmp_fp_env->rc  = rc_rz;
        tmp_fp_env->ftz = 0;
    } else {
        tmp_fp_env->rc  = tmp_sf.controls.rc;
        tmp_fp_env->ftz = tmp_sf.controls.ftz && tmp_fp_env->controls.ud;
    }

    tmp_fp_env->flags.v       = 0;
    tmp_fp_env->flags.d       = 0;
    tmp_fp_env->flags.z       = 0;
    tmp_fp_env->flags.o       = 0;
    tmp_fp_env->flags.un       = 0; 
    tmp_fp_env->flags.i       = 0;
    tmp_fp_env->ebc           = 0;
    tmp_fp_env->mdl           = 0;
    tmp_fp_env->mdh           = 0;

    tmp_fp_env->em_faults.v   = 0;
    tmp_fp_env->em_faults.d   = 0;
    tmp_fp_env->em_faults.z   = 0;
    tmp_fp_env->em_faults.swa = 0;
    tmp_fp_env->em_traps.i    = 0;
    tmp_fp_env->em_traps.o    = 0;
    tmp_fp_env->em_traps.un    = 0; 
    tmp_fp_env->fpa           = 0;

    tmp_fp_env->hi_faults.v   = 0;
    tmp_fp_env->hi_faults.d   = 0;
    tmp_fp_env->hi_faults.z   = 0;
    tmp_fp_env->hi_faults.swa = 0;
    tmp_fp_env->hi_traps.i    = 0;
    tmp_fp_env->hi_traps.o    = 0;
    tmp_fp_env->hi_traps.un    = 0; 
    tmp_fp_env->hi_fpa        = 0;

    tmp_fp_env->lo_faults.v   = 0;
    tmp_fp_env->lo_faults.d   = 0;
    tmp_fp_env->lo_faults.z   = 0;
    tmp_fp_env->lo_faults.swa = 0;
    tmp_fp_env->lo_traps.i    = 0;
    tmp_fp_env->lo_traps.o    = 0;
    tmp_fp_env->lo_traps.un    = 0; 
    tmp_fp_env->lo_fpa        = 0;

    return;
}

#undef  fp_decode_environment
#define fp_decode_environment(arg1, arg2, arg3) \
        fp82_fp_decode_environment(ps, arg1, arg2, arg3)
      


// ****************************************************
// Returns
//   1: if a specified register is <= disabled limit and dfl is 1
//   0: if a specified register is >  disabled limit and dfh is 1
// The disabled limit is 31 after ACR106.
// *****************************************************
EM_uint_t
fp_reg_disabled(
    EM_uint_t f1,
    EM_uint_t f2,
    EM_uint_t f3,
    EM_uint_t f4)
{
EM_uint_t tmp_ret;
EM_uint_t disabled_limit;

   tmp_ret=0;
   disabled_limit = 31;

    if (    ((f1 >= 2) && (f1 <=disabled_limit) && (PSR.dfl))
        ||  ((f2 >= 2) && (f2 <=disabled_limit) && (PSR.dfl))
        ||  ((f3 >= 2) && (f3 <=disabled_limit) && (PSR.dfl))
        ||  ((f4 >= 2) && (f4 <=disabled_limit) && (PSR.dfl))
       )
        tmp_ret |= (1<<0);
    if (    ((f1 > disabled_limit) && (f1 <= 127) && (PSR.dfh))
        ||  ((f2 > disabled_limit) && (f2 <= 127) && (PSR.dfh))
        ||  ((f3 > disabled_limit) && (f3 <= 127) && (PSR.dfh))
        ||  ((f4 > disabled_limit) && (f4 <= 127) && (PSR.dfh))
       )
        tmp_ret |= (1<<1);
    return(tmp_ret);
}

INLINE EM_boolean_t
fp_is_nan_or_inf(EM_fp_reg_type tmp_res)
{
    if (fp_is_nan(tmp_res) || fp_is_inf(tmp_res))
        return (1);
    else
        return (0);
}


INLINE EM_fp_reg_type
fp_dp_to_fr(EM_fp_dp_type tmp_res)
{
    EM_fp_reg_type tmp_ret;
    /* MACH FIX CMPLR BUG tmp_ret.sign = tmp_res.sign; */
    if (tmp_res.exponent == FP_DP_EXP_ONES)
        tmp_ret.exponent = FP_REG_EXP_ONES;
    else if (tmp_res.exponent == 0)
        tmp_ret.exponent = 0;
    else 
        tmp_ret.exponent = (EM_uint_t)(((EM_int_t)tmp_res.exponent)
                                   - FP_DP_BIAS + FP_REG_BIAS);
    tmp_ret.sign = tmp_res.sign; /* MACH FIX CMPLR BUG */
    tmp_ret.significand = tmp_res.significand.hi;
    return (tmp_ret);
}


// ***************************************************************
// fp_add()
// Adds a dp value to an freg value
// Returns a dp value
// ***************************************************************
INLINE EM_fp_dp_type
fp_add(EM_fp_dp_type fp_dp, EM_fp_reg_type fr2, EM_tmp_fp_env_type tmp_fp_env)
// fp_dp has been normalized and fr2 may not be normalized 
{
    EM_fp_dp_type tmp_res;
    EM_uint256_t tmp_a, tmp_b, tmp_c;
    EM_int_t exp_diff;
    EM_uint_t normalize_count;

//     all cases which might have faulted have been screened out 
//     we still may trap on overflow, underflow and/or inexact later 

    if (fp_is_zero_dp(fp_dp) && (fp_is_zero(fr2) || fp_is_pseudo_zero(fr2))) {
        /* correctly signed zero */
        tmp_res = fp_fr_to_dp(FP_ZERO);
        if (fp_dp.sign == fr2.sign) {
            tmp_res.sign = fr2.sign;
        } else if (tmp_fp_env.rc == rc_rm) {
            tmp_res.sign = 1;
        } else {
            tmp_res.sign = 0;
        }
        return(tmp_res);
    } else if (fp_is_inf_dp(fp_dp)) {
        /* correctly signed infinity */
        return(fp_dp);
    } else if (fp_is_inf(fr2)) {
        /* correctly signed infinity */
        return(fp_fr_to_dp(fr2));
    } else if( fp_is_zero_dp(fp_dp)) {
        return(fp_fr_to_dp(fr2));
    } else if( fp_is_zero(fr2) || fp_is_pseudo_zero(fr2) ) {
        return(fp_dp);
    } else {
        /* we have non-all-zeros and non-all-ones exponents in both operands */
        exp_diff = (((EM_int_t)fp_dp.exponent) - FP_DP_BIAS )
                 - (((EM_int_t)fr2.exponent)  -  FP_REG_BIAS);

        tmp_res.sign = fp_dp.sign;

        tmp_a = fp_U128_to_U256(fp_dp.significand);
        tmp_a = fp_U256_lsh(tmp_a,64);

        tmp_b = fp_U64_to_U256(fr2.significand);
        tmp_b = fp_U256_lsh(tmp_b,128);

        if (exp_diff >= 0) {
            tmp_res.exponent = fp_dp.exponent;

            tmp_c = fp_U256_rsh(tmp_b,exp_diff);
            tmp_res.sticky = !fp_U256_eq(tmp_b,fp_U256_lsh(tmp_c,exp_diff));
            tmp_b = tmp_c;

            if(fp_dp.sign != fr2.sign) {
                /* add sticky */
                if (tmp_res.sticky)
                    tmp_b = fp_U256_inc(tmp_b);
                if (fp_dp.sign)
                    tmp_a = fp_U256_neg(tmp_a);
                if (fr2.sign)
                    tmp_b = fp_U256_neg(tmp_b);
            }
        } else {
            tmp_res.exponent = fp_dp.exponent - exp_diff;

            tmp_c = fp_U256_rsh(tmp_a,-exp_diff);
            tmp_res.sticky = !fp_U256_eq(tmp_a,fp_U256_lsh(tmp_c,-exp_diff));
            tmp_a = tmp_c;

            if(fp_dp.sign != fr2.sign) {
                /* add sticky */
                if (tmp_res.sticky)
                    tmp_a = fp_U256_inc(tmp_a);
                if (fp_dp.sign)
                    tmp_a = fp_U256_neg(tmp_a);
                if (fr2.sign)
                    tmp_b = fp_U256_neg(tmp_b);
            }
        }

        tmp_c = fp_U256_add(tmp_a, tmp_b);


        if (fp_dp.sign != fr2.sign) {
            if (tmp_c.hh != 0) {
                tmp_res.sign = 1;
                tmp_c = fp_U256_neg(tmp_c);
            } else {
                tmp_res.sign = 0;
            }
        }

        if (!fp_U256_eq(tmp_c,U256_0)) {
            normalize_count = fp_U256_lead0(tmp_c);
            tmp_res.exponent -= (normalize_count - 64);
            tmp_res.significand = fp_U256_to_U128(
                                      fp_U256_rsh(
                                          fp_U256_lsh(tmp_c, normalize_count),
                                          128
                                      )
                                  );

            if(normalize_count > 128) {
               tmp_res.sticky |= !fp_U256_eq(
                                     fp_U256_rsh(
                                         fp_U128_to_U256(tmp_res.significand),
                                         normalize_count-128
                                     ),
                                     tmp_c
                                 );
            } else {
               tmp_res.sticky |= !fp_U256_eq(
                                     fp_U256_lsh(
                                         fp_U128_to_U256(tmp_res.significand),
                                         128-normalize_count
                                     ),
                                     tmp_c
                                 );
            }

        } else {
             if (fp_dp.sign == fr2.sign)
                 tmp_res.sign = fp_dp.sign;
             else if (tmp_fp_env.rc == rc_rm)
                 tmp_res.sign = 1;
             else
                 tmp_res.sign = 0;
             tmp_res.exponent = 0;
             tmp_res.significand = U128_0;
        }
        return(tmp_res);
    }
}



// *******************************************************************
// IEEE rounds
// *******************************************************************


INLINE EM_uint_t
fp_single(EM_fp_reg_type freg)
{
EM_memory_type tmp_mem;
    tmp_mem = fp_fr_to_mem_format(freg, 4, 0);
    return (tmp_mem.uint_32.uvalue);
}

INLINE void
fp_ieee_to_hilo(
    EM_simd_hilo hilo,
    EM_tmp_fp_env_type *tmp_fp_env)
{
    if(hilo == high) {
       tmp_fp_env->hi_flags.o = tmp_fp_env->flags.o;
       tmp_fp_env->flags.o    = 0;

       tmp_fp_env->hi_flags.un = tmp_fp_env->flags.un; // MACH
       tmp_fp_env->flags.un    = 0; // MACH

       tmp_fp_env->hi_flags.i = tmp_fp_env->flags.i;
       tmp_fp_env->flags.i    = 0;


       tmp_fp_env->hi_traps.o = tmp_fp_env->em_traps.o;
       tmp_fp_env->em_traps.o = 0;

       tmp_fp_env->hi_traps.un = tmp_fp_env->em_traps.un; // MACH
       tmp_fp_env->em_traps.un = 0; // MACH

       tmp_fp_env->hi_traps.i = tmp_fp_env->em_traps.i;
       tmp_fp_env->em_traps.i = 0;

       tmp_fp_env->hi_faults.d = tmp_fp_env->em_faults.d;
       tmp_fp_env->em_faults.d = 0;

       tmp_fp_env->hi_faults.z = tmp_fp_env->em_faults.z;
       tmp_fp_env->em_faults.z = 0;

       tmp_fp_env->hi_faults.v = tmp_fp_env->em_faults.v;
       tmp_fp_env->em_faults.v = 0;

       tmp_fp_env->hi_fpa = tmp_fp_env->fpa;
       tmp_fp_env->fpa = 0;

    } else {
       tmp_fp_env->lo_flags.o = tmp_fp_env->flags.o;
       tmp_fp_env->flags.o    = 0;

       tmp_fp_env->lo_flags.un = tmp_fp_env->flags.un; // MACH
       tmp_fp_env->flags.un    = 0; // MACH

       tmp_fp_env->lo_flags.i = tmp_fp_env->flags.i;
       tmp_fp_env->flags.i    = 0;


       tmp_fp_env->lo_traps.o = tmp_fp_env->em_traps.o;
       tmp_fp_env->em_traps.o = 0;

       tmp_fp_env->lo_traps.un = tmp_fp_env->em_traps.un; // MACH
       tmp_fp_env->em_traps.un = 0; // MACH

       tmp_fp_env->lo_traps.i = tmp_fp_env->em_traps.i;
       tmp_fp_env->em_traps.i = 0;

       tmp_fp_env->lo_faults.d = tmp_fp_env->em_faults.d;
       tmp_fp_env->em_faults.d = 0;

       tmp_fp_env->lo_faults.z = tmp_fp_env->em_faults.z;
       tmp_fp_env->em_faults.z = 0;

       tmp_fp_env->lo_faults.v = tmp_fp_env->em_faults.v;
       tmp_fp_env->em_faults.v = 0;

       tmp_fp_env->lo_fpa = tmp_fp_env->fpa;
       tmp_fp_env->fpa = 0;
    }
}

EM_fp_reg_type
fp_ieee_round(
    EM_fp_dp_type      fp_dp,
    EM_tmp_fp_env_type *tmp_fp_env)
{
    const EM_uint_t FPA[64] = {
                        0,0,0,1,
                        0,0,1,1,
                        0,0,0,1,
                        0,0,1,1, /* Nearest */
                        0,0,0,0,
                        0,0,0,0,
                        0,1,1,1,
                        0,1,1,1, /* -inf */
                        0,1,1,1,
                        0,1,1,1,
                        0,0,0,0,
                        0,0,0,0, /* +inf */
                        0,0,0,0,
                        0,0,0,0,
                        0,0,0,0,
                        0,0,0,0, /* Zero */
    };

    EM_fp_reg_type tmp_rtn;
    EM_fp_dp_type  tmp_res, tmp_unbounded_round;
    EM_int_t       cnt, tmp_shift;

    EM_uint_t      e_max, e_min, 
                   tmp_unbounded_ebc = 0, tmp_unbounded_fpa = 0;

    EM_uint128_t significand_mask;
    EM_uint128_t significand_even;
    EM_uint128_t significand_round;
    EM_uint128_t significand_not_mask;
    EM_uint128_t significand_sticky;


/************************************************
SETUP
set e_max, e_min
Note that the exponents are still dp-biased.
*************************************************/
    if (tmp_fp_env->es == es_eight_bits) {
        e_max = FP_DP_BIAS + FP_SGL_BIAS;
        e_min = FP_DP_BIAS - FP_SGL_BIAS + 1;
    } else if (tmp_fp_env->es == es_eleven_bits) {
        e_max = FP_DP_BIAS + FP_DBL_BIAS;
        e_min = FP_DP_BIAS - FP_DBL_BIAS + 1;
    } else if (tmp_fp_env->es == es_fifteen_bits) {
        e_max = FP_DP_BIAS + FP_EXT_BIAS;
        e_min = FP_DP_BIAS - FP_EXT_BIAS + 1;
    } else if (tmp_fp_env->es == es_seventeen_bits) {
        e_max = FP_DP_BIAS + FP_REG_BIAS;
        e_min = FP_DP_BIAS - FP_REG_BIAS + 1;
    }

/************************************************
SETUP
set significand_mask, significand_even, significand_round
    significand_not_mask, significand_sticky
*************************************************/
   if( tmp_fp_env->ss == ss_single_24) {
        significand_mask     = U128_0xFFFFFF00000000000000000000000000;
        significand_even     = U128_0x00000100000000000000000000000000;
        significand_round    = U128_0x00000080000000000000000000000000;
        significand_not_mask = U128_0x000000FFFFFFFFFFFFFFFFFFFFFFFFFF;
        significand_sticky   = U128_0x0000007FFFFFFFFFFFFFFFFFFFFFFFFF;
    } else if( tmp_fp_env->ss == ss_double_53) {
        significand_mask     = U128_0xFFFFFFFFFFFFF8000000000000000000;
        significand_even     = U128_0x00000000000008000000000000000000;
        significand_round    = U128_0x00000000000004000000000000000000;
        significand_not_mask = U128_0x00000000000007FFFFFFFFFFFFFFFFFF;
        significand_sticky   = U128_0x00000000000003FFFFFFFFFFFFFFFFFF;
    } else if( tmp_fp_env->ss == ss_double_extended_64) {
        significand_mask     = U128_0xFFFFFFFFFFFFFFFF0000000000000000;
        significand_even     = U128_0x00000000000000010000000000000000;
        significand_round    = U128_0x00000000000000008000000000000000;
        significand_not_mask = U128_0x0000000000000000FFFFFFFFFFFFFFFF;
        significand_sticky   = U128_0x00000000000000007FFFFFFFFFFFFFFF;
    }

/***************************************************
INPUT CHECK
Inf?
****************************************************/
    if ( fp_is_inf_dp(fp_dp) ) {
        tmp_res             = fp_dp;
        tmp_res.significand = fp_U128_band(tmp_res.significand,
                                        significand_mask);
        tmp_rtn = fp_dp_to_fr(tmp_res);
        return(tmp_rtn);

/***************************************************
INPUT CHECK
Nan?
****************************************************/
   } else if ( fp_is_nan_dp(fp_dp) ) {
        tmp_res             = fp_dp;
        tmp_res.significand = fp_U128_band(tmp_res.significand,
                                        significand_mask);
        tmp_rtn = fp_dp_to_fr(tmp_res);
        return(tmp_rtn);

/***************************************************
INPUT CHECK
Zero?
****************************************************/
    } else if ( fp_is_zero_dp(fp_dp) ) {

        if (      (fp_dp.sticky) && (tmp_fp_env->rc == rc_rm) )
            tmp_rtn.sign = 1;
        else if ( (fp_dp.sticky) && (tmp_fp_env->rc != rc_rm) )
            tmp_rtn.sign = 0;
        else
            tmp_rtn.sign = fp_dp.sign;
        tmp_rtn.exponent    = fp_dp.exponent;
        tmp_rtn.significand = 0;
        return(tmp_rtn);

/******************************************************
INPUT CHECK
Answer is finite and non-zero.
*******************************************************/
    } else { 
        tmp_res.sign     = fp_dp.sign;
        tmp_res.exponent = fp_dp.exponent;
        tmp_res.sticky   = fp_dp.sticky;

/****************************************************** 
UNBOUNDED SETUP
Set cnt -- depends on rounding control, +/-, even/odd, round?, sticky?
Set sticky to be either round or sticky 
*******************************************************/
        cnt = (tmp_fp_env->rc<<4) | (fp_dp.sign<<3);
                        
        cnt |= !fp_U128_eq(U128_0, fp_U128_band(fp_dp.significand,
        /* even */                       significand_even))  << 2;
                        
        cnt |= !fp_U128_eq(U128_0, fp_U128_band(fp_dp.significand,
        /* round */                      significand_round)) << 1;
                        
        tmp_res.sticky |= !fp_U128_eq(U128_0, fp_U128_band(fp_dp.significand,
        /* sticky */                                significand_sticky));

        cnt |= tmp_res.sticky;
        tmp_res.sticky |= ((cnt&2) != 0); /* round and sticky */

/*************************************************************************
UNBOUNDED ROUNDING
If necessary, round the significand
   This is the FIRST (or UNBOUNDED) rounding
   If rounding the significand results in a carry out of
   the significand, inc exponent and set significand to 10..0
else
   mask out lower bits of significand
**************************************************************************/
        if (FPA[cnt]) {
            tmp_res.significand = fp_U128_bor(fp_dp.significand,
                                           significand_not_mask);
            tmp_res.significand = fp_U128_inc(tmp_res.significand);
            if ( fp_U128_eq(tmp_res.significand, U128_0) ) { /* carry out */
                tmp_res.exponent++;
                tmp_res.significand = U128_0x80000000000000000000000000000000;
            }
        } else {
            tmp_res.significand = fp_U128_band(fp_dp.significand,
                                            significand_mask);
        }

/*************************************************************************
UNBOUNDED ROUNDING
If significand = 0, set exponent to 0.
CAN THIS EVER HAPPEN IF tmp_res IS NORMALIZED?
**************************************************************************/
        if ( fp_U128_eq(tmp_res.significand, U128_0) ) { /* underflow -> zero */
                tmp_res.exponent = 0;
        }

/*************************************************************************
UNBOUNDED
Save the result of the FIRST ROUNDING in tmp_unbounded_round.
Then, set i flag.
**************************************************************************/        
        tmp_unbounded_round.sign            = tmp_res.sign;
        tmp_unbounded_round.significand     = tmp_res.significand;
        tmp_unbounded_round.exponent        = tmp_res.exponent;
        tmp_unbounded_round.sticky          = tmp_res.sticky;
        tmp_unbounded_fpa                   = FPA[cnt];
        
        if (  ((tmp_unbounded_round.exponent>>17)&1) 
            ^ ((tmp_unbounded_round.exponent>>16)&1) 
           )
                tmp_unbounded_ebc = 1;

        tmp_fp_env->flags.i   = tmp_res.sticky;


/************************************************************
HUGE
if HUGE, set o_flag; 
if o traps enabled, also set o_trap, ebc, fpa
   then if i_flag set, set i_trap and 
   return tmp_unbounded_round with mod17 exponent;
   the fp_dp_to_fr() mods the exponent.
   (sometimes inappropriately called the wrapped value)
else set set tmp_res to max or inf, set i_flag
   if i traps enabled, set i_trap, fpa
   return tmp_res 
*************************************************************/
        if ( tmp_res.exponent > e_max ) { /* huge */
          tmp_fp_env->flags.o = 1;

           if ( !tmp_fp_env->controls.od) {
               tmp_fp_env->ebc = tmp_unbounded_ebc;
               tmp_fp_env->fpa = tmp_unbounded_fpa;
               tmp_fp_env->em_traps.o = 1;
               if(tmp_fp_env->flags.i) {
                  tmp_fp_env->em_traps.i = 1;
               }
               return(fp_dp_to_fr(tmp_unbounded_round));      
 
          } else {
               tmp_res = fp_max_or_infinity(fp_dp.sign, tmp_fp_env,
                                            e_max, significand_mask);
               tmp_fp_env->flags.i = 1;
/****************************************************************
The IEEE standard specifies (7.5) that if you overflow without enabling
O traps, then inexact is always set. Hence, the above assignment.
*****************************************************************/

               if ( !tmp_fp_env->controls.id ) {
                   tmp_fp_env->em_traps.i = 1;
                   tmp_fp_env->fpa        = fp_is_inf_dp(tmp_res);
                   tmp_fp_env->ebc        = 0;
               }
               return(fp_dp_to_fr(tmp_res));
           }

/************************************************************
TINY
If MERCED_RTL, return unbounded, rounded result with mod17 exponent
*************************************************************/

        } else if ( tmp_res.exponent < e_min ) { /* tiny */

/************************************************************
TINY
Undo the rounding.
*************************************************************/

             tmp_res.sign     = fp_dp.sign;
             tmp_res.exponent = fp_dp.exponent;
             tmp_res.sticky   = fp_dp.sticky;

/************************************************************
TINY
Calculate the shift to bring exponent to e_min
if shift >=128 and significand is not zero, 
   set sticky and clear significand
else
   do the shift and set sticky if lost bits from significand
*************************************************************/
            tmp_shift = ((EM_int_t)e_min) - ((EM_int_t)fp_dp.exponent);
            tmp_res.exponent     += tmp_shift;

            if (tmp_shift >= 128) {
                tmp_res.sticky |= !fp_U128_eq( fp_dp.significand, U128_0);
                tmp_res.significand = U128_0;
            } else {
                tmp_res.sticky |= !fp_U128_eq( U128_0,
                                       fp_U128_lsh(
                                          fp_dp.significand,
                                          (128-tmp_shift)));
                tmp_res.significand  = fp_U128_rsh(fp_dp.significand,
                                                   tmp_shift);
            }

/****************************************************** 
TINY SETUP
Set cnt -- depends on rounding control, +/-, even/odd, round?, sticky?
Set sticky to be either round or sticky 
*******************************************************/
            cnt = (tmp_fp_env->rc<<4) | (tmp_res.sign<<3);
                            /* even */
            cnt |= !fp_U128_eq(U128_0, fp_U128_band(tmp_res.significand,
                                             significand_even))  << 2;
                            /* round */
            cnt |= !fp_U128_eq(U128_0, fp_U128_band(tmp_res.significand,
                                             significand_round)) << 1;
                            /* sticky */
            tmp_res.sticky |= !fp_U128_eq(U128_0, fp_U128_band(tmp_res.significand,
                                                        significand_sticky));
            cnt |= tmp_res.sticky;
            tmp_res.sticky |= ((cnt&2) != 0); /* round and sticky */

/*************************************************************************
TINY ROUNDING -- answer is in tmp_res
If necessary, round the significand
   This is the SECOND (as opposed to the FIRST or UNBOUNDED) rounding
   If rounding the significand results in a carry out of
   the significand, inc exponent and set significand to 10..0
else
   mask out lower bits of significand
**************************************************************************/
            if (FPA[cnt]) {
                tmp_res.significand = fp_U128_bor(tmp_res.significand,
                                               significand_not_mask);
                tmp_res.significand = fp_U128_inc(tmp_res.significand);
                if ( fp_U128_eq(tmp_res.significand, U128_0) ) { /* carry out */
                    tmp_res.exponent++;
                    tmp_res.significand =
                            U128_0x80000000000000000000000000000000;
                }
            } else {
                tmp_res.significand = fp_U128_band(tmp_res.significand,
                                                significand_mask);
            }


/******************************************************
TINY ROUNDING
If significand = 0, set exponent to 0.
Then, or in new sticky to the i flag 
*******************************************************/
           if ( fp_U128_eq(tmp_res.significand, U128_0) ) { /* underflow to 0 */
                tmp_res.exponent = 0;
            }

            tmp_fp_env->flags.i |= tmp_res.sticky;


/******************************************************
TINY
Set underflow, if inexact.
*******************************************************/
             if( tmp_fp_env->flags.i )
                 tmp_fp_env->flags.un = 1; /* tiny and inexact */ // MACH

/******************************************************
TINY
If u traps enabled, 
   set u_flag, u_trap, ebc, fpa, and possibly i_trap
   return unbounded result with mod17 exponent;
   the fp_dp_to_fr() mods the exponent.
else 
   if ftz
     set i_flag, set u_flag, clear ebc, clear fpa
     if inexact set i_trap
   else 
     if inexact trap and inexact
        set fpa, set i_trap
   set tmp_rtn (freg) to tmp_res (fp_dp).
   tmp_rtn now has the result of the SECOND rounding.
   Do not return tmp_res yet, because we may have to
   make a canonical double_ext denormal.
*******************************************************/
            tmp_fp_env->fpa        = FPA[cnt];
            if (!tmp_fp_env->controls.ud) {
                tmp_fp_env->flags.un    = 1; // MACH
                tmp_fp_env->em_traps.un = 1; // MACH
                tmp_fp_env->ebc        = tmp_unbounded_ebc;
                tmp_fp_env->fpa        = tmp_unbounded_fpa;
                tmp_fp_env->flags.i    = tmp_unbounded_round.sticky;
                if(tmp_fp_env->flags.i) {
                   tmp_fp_env->em_traps.i = 1; 
                }
                return(fp_dp_to_fr(tmp_unbounded_round));
            }
            else {
                if (tmp_fp_env->ftz) {
                   tmp_res.exponent    = 0;
                   tmp_res.significand = U128_0;
                   tmp_res.sticky      = 1;
                   tmp_fp_env->flags.i = 1;
                   tmp_fp_env->flags.un = 1; // MACH
                   tmp_fp_env->ebc     = 0;
                   tmp_fp_env->fpa     = 0;
                   if (!tmp_fp_env->controls.id) {
                      tmp_fp_env->em_traps.i = 1;
                   }
                } 
                else {
                   if (!tmp_fp_env->controls.id && tmp_fp_env->flags.i) {
                     tmp_fp_env->fpa        = FPA[cnt];
                     tmp_fp_env->em_traps.i = 1;
                   }
               }
            }

            tmp_rtn                = fp_dp_to_fr(tmp_res);

/******************************************************
TINY
if double_extended, set tmp_rtn to canonical denormal
return result of SECOND ROUNDING
*******************************************************/
            if (  (tmp_fp_env->es == es_fifteen_bits)
               && (tmp_rtn.exponent == 0x0C001)
               &&((tmp_rtn.significand & U64_0x8000000000000000) == 0) ) {
               /* canonical double-extended denormal */
                tmp_rtn.exponent = 0x00000;
            }

            return(tmp_rtn);

/******************************************************
NOT HUGE, NOT TINY
if i traps enabled and i flag, set i_trap 
set fpa
*******************************************************/
        } else { 
            if (!tmp_fp_env->controls.id && tmp_fp_env->flags.i) {
                tmp_fp_env->fpa        = tmp_unbounded_fpa;
                tmp_fp_env->em_traps.i = 1;
            }
            tmp_rtn  = fp_dp_to_fr(tmp_unbounded_round);

/******************************************************
NOT HUGE, NOT TINY
if double_extended, set tmp_rtn to canonical denormal
return result of FIRST rounding
*******************************************************/
            if (  (tmp_fp_env->es == es_fifteen_bits)
               && (tmp_rtn.exponent == 0x0C001)
               &&((tmp_rtn.significand & U64_0x8000000000000000) == 0) ) {
               /* canonical double-extended denormal */
                tmp_rtn.exponent = 0x00000;
            }

            return(tmp_rtn);
        } /* end of not huge, not tiny */
    } /* end of infinitely precise and nonzero */
}

#undef fp_ieee_round
#define fp_ieee_round(arg1, arg2)  fp82_fp_ieee_round(ps, arg1, arg2)

// *******************************************************************
// fp_ieee_round_sp()
// Takes a dp register value (which is the hi or lo of a simd)
// Rounds to single precision, setting flags
// Returns the value as a single-precision memory format value
// ********************************************************************
EM_uint_t
fp_ieee_round_sp(
    EM_fp_dp_type      fp_dp,
    EM_simd_hilo       hilo,
    EM_tmp_fp_env_type *tmp_fp_env)
{
EM_fp_reg_type fp_reg;
EM_memory_type tmp_mem;
    fp_reg = fp_ieee_round( fp_dp, tmp_fp_env);
    fp_ieee_to_hilo(hilo, tmp_fp_env);

    if( tmp_fp_env->hi_traps.un || tmp_fp_env->hi_traps.o ||
        tmp_fp_env->lo_traps.un || tmp_fp_env->lo_traps.o  ) { // MACH

       tmp_mem = fr_to_mem4_bias_adjust(fp_reg);
       return (tmp_mem.uint_32.uvalue);
    }
    else {   
     return (fp_single(fp_reg));
    }
}

#undef fp_ieee_round_sp
#define fp_ieee_round_sp(arg1, arg2, arg3) \
        fp82_fp_ieee_round_sp(ps, arg1, arg2, arg3) 


EM_fp_reg_type
fp_ieee_rnd_to_int(
    EM_fp_reg_type fr1,
    EM_tmp_fp_env_type *tmp_fp_env)
{
EM_fp_dp_type      tmp_res;
EM_tmp_fp_env_type tmp_fp_env_local;
    
    tmp_res = fp_fr_to_dp(fr1);
    memcpy ((char *)(&tmp_fp_env_local), (char *)tmp_fp_env,
        sizeof (EM_tmp_fp_env_type)); 

    if (tmp_res.exponent < FP_DP_INTEGER_EXP) {
        if (tmp_res.sign) {
            tmp_res = fp_add(tmp_res, FP_NEG_2_TO_63, *tmp_fp_env);
            tmp_res = fp_fr_to_dp(fp_ieee_round( tmp_res, tmp_fp_env));
            tmp_res = fp_add(tmp_res, FP_POS_2_TO_63, *tmp_fp_env);
            return(fp_ieee_round( tmp_res, &tmp_fp_env_local));
        } else {
            tmp_res = fp_add(tmp_res, FP_POS_2_TO_63, *tmp_fp_env);
            tmp_res = fp_fr_to_dp(fp_ieee_round( tmp_res, tmp_fp_env));
            tmp_res = fp_add(tmp_res, FP_NEG_2_TO_63, *tmp_fp_env);
            return(fp_ieee_round( tmp_res, &tmp_fp_env_local));
        }
    } else
        return (fr1);
}

#undef  fp_ieee_rnd_to_int
#define fp_ieee_rnd_to_int(arg1,arg2) \
        fp82_fp_ieee_rnd_to_int(ps, arg1, arg2)

EM_fp_reg_type
fp_ieee_rnd_to_int_sp(
    EM_fp_reg_type     fr1,
    EM_simd_hilo       hilo,
    EM_tmp_fp_env_type *tmp_fp_env)
{
EM_fp_reg_type      tmp_fix;
EM_tmp_fp_env_type  tmp_fp_env_save;

   tmp_fp_env_save  = *tmp_fp_env;
   tmp_fp_env->ss   = ss_double_extended_64;
   tmp_fp_env->es   = es_seventeen_bits;

   tmp_fix          = fp_ieee_rnd_to_int(fr1, tmp_fp_env);

   fp_ieee_to_hilo(hilo, tmp_fp_env);
   tmp_fp_env->ss   = tmp_fp_env_save.ss;
   tmp_fp_env->es   = tmp_fp_env_save.es;
   return(tmp_fix);
}


    
// ***************************************************************
// Exception fault checks
// *****************************************************************

// ****************************************************************
// fcmp_exception_fault_check()
// *****************************************************************
INLINE void
fcmp_exception_fault_check(
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3,
    EM_opcode_frel_type frel,
    EM_opcode_sf_type   sf,
    EM_tmp_fp_env_type  *tmp_fp_env)
{
EM_fp_reg_type fr2, fr3;

    fr2 = FR[f2];
    fr3 = FR[f3];

    fp_decode_environment( pc_none, sf, tmp_fp_env );

    if (fp_software_assistance_required(ps, op_fcmp, fr2, fr3)) {
        tmp_fp_env->em_faults.swa = 1;
    }

    if (fp_is_unsupported(fr2) || fp_is_unsupported(fr3)) {
        tmp_fp_env->flags.v = 1;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
        }

    } else if (fp_is_nan(fr2) || fp_is_nan(fr3)) {
        if (fp_is_snan(fr2)   || fp_is_snan(fr3)     ||
           (frel == frelLT)  || (frel == frelNLT)  ||
           (frel == frelLE)  || (frel == frelNLE)) {
           tmp_fp_env->flags.v = 1;
           if (!tmp_fp_env->controls.vd) {
              tmp_fp_env->em_faults.v = 1;
           }
        }

    } else if (fp_is_unorm(fr2) || fp_is_unorm(fr3)) {
        tmp_fp_env->flags.d = 1;
        if(!tmp_fp_env->controls.dd)
            tmp_fp_env->em_faults.d = 1;
    }

}

// ****************************************************************
// fpcmp_exception_fault_check()
// *****************************************************************
INLINE void 
fpcmp_exception_fault_check(
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3,
    EM_opcode_frel_type frel,
    EM_opcode_sf_type sf,
    EM_tmp_fp_env_type *tmp_fp_env)
{
EM_fp_reg_type      tmp_fr2 = FR[f2], tmp_fr3 = FR[f3];

    fp_decode_environment( pc_simd, sf, tmp_fp_env );

// ***********
// high
// ************
    tmp_fr2 = fp_reg_read_hi(f2);
    tmp_fr3 = fp_reg_read_hi(f3);

    if (fp_software_assistance_required(ps, op_fpcmp, tmp_fr2, tmp_fr3)) {
        tmp_fp_env->hi_faults.swa = 1;

    } else if (fp_is_nan(tmp_fr2) || fp_is_nan(tmp_fr3))  {
        if ((fp_is_snan(tmp_fr2)  || fp_is_snan(tmp_fr3)   ||
           (frel == frelLT)      || (frel == frelNLT)    ||
           (frel == frelLE)      || (frel == frelNLE))) {
              tmp_fp_env->hi_flags.v = 1;
           if (!tmp_fp_env->controls.vd) {
               tmp_fp_env->hi_faults.v = 1;
           }
       }


    } else if (fp_is_unorm(tmp_fr2) || fp_is_unorm(tmp_fr3)) {
        tmp_fp_env->hi_flags.d = 1;
        if (!tmp_fp_env->controls.dd)
            tmp_fp_env->hi_faults.d = 1;
    }
    

// ***********
// low
// ************
    tmp_fr2 = fp_reg_read_lo(f2);
    tmp_fr3 = fp_reg_read_lo(f3);

    if (fp_software_assistance_required(ps, op_fpcmp, tmp_fr2, tmp_fr3)) {
        tmp_fp_env->lo_faults.swa = 1;

    } else if (fp_is_nan(tmp_fr2) || fp_is_nan(tmp_fr3)) {
       if ((fp_is_snan(tmp_fr2)   || fp_is_snan(tmp_fr3)   ||
           (frel == frelLT)      || (frel == frelNLT)   ||
           (frel == frelLE)      || (frel == frelNLE))) {
              tmp_fp_env->lo_flags.v = 1;
           if (!tmp_fp_env->controls.vd) {
               tmp_fp_env->lo_faults.v = 1;
           }
       }


    } else if (fp_is_unorm(tmp_fr2) || fp_is_unorm(tmp_fr3)) {
        tmp_fp_env->lo_flags.d = 1;
        if (!tmp_fp_env->controls.dd)
            tmp_fp_env->lo_faults.d = 1;
    }
    return;
}

// *******************************************************************
// fcvt_exception_fault_check()
// ********************************************************************
INLINE EM_fp_reg_type
fcvt_exception_fault_check(
   EM_fp_reg_specifier f2,
   EM_opcode_sf_type sf,
   EM_boolean_t signed_form,
   EM_boolean_t trunc_form,
   EM_tmp_fp_env_type *tmp_fp_env)
{
   EM_fp_reg_type     tmp_res, fr2;
   EM_tmp_fp_env_type tmp_fp_env_local;

   fr2 = FR[f2];
   fp_decode_environment( pc_none, sf, tmp_fp_env );
   if (trunc_form)
       tmp_fp_env->rc = rc_rz;

   tmp_res          = fp_reg_read(fr2);
   memcpy ((char *)(&tmp_fp_env_local), (char *)tmp_fp_env,
       sizeof (EM_tmp_fp_env_type)); 
   tmp_res          = fp_ieee_rnd_to_int( tmp_res, &tmp_fp_env_local);

   if( signed_form && fp_software_assistance_required(ps, op_fcvt_fx, fr2)) {
       tmp_fp_env->em_faults.swa = 1;
       return (FP_ZERO);

   } else if( !signed_form  && fp_software_assistance_required(ps, op_fcvt_fxu, fr2)) {
       tmp_fp_env->em_faults.swa = 1;
       return (FP_ZERO);
   }

   if (fp_is_unsupported(fr2)) {
       tmp_fp_env->flags.v = 1;
       tmp_res             = FP_QNAN;
       if (!tmp_fp_env->controls.vd) {
           tmp_fp_env->em_faults.v = 1;
       }

   } else if (fp_is_nan(fr2)) {
       tmp_fp_env->flags.v = 1;
       if (!tmp_fp_env->controls.vd) {
           tmp_fp_env->em_faults.v = 1;
       }
       tmp_res = fp_is_snan(fr2)?fp_make_quiet_nan(fr2):fr2;

   } else if ( signed_form                                     &&
               (!fp_lesser_or_equal(FP_NEG_2_TO_63, tmp_res) ||
                !fp_less_than(tmp_res,FP_POS_2_TO_63)) ) {
             tmp_fp_env->flags.v = 1;
             tmp_res             = FP_QNAN;
             if (!tmp_fp_env->controls.vd)
                 tmp_fp_env->em_faults.v = 1;

   } else if ( !signed_form                              &&
               (!fp_lesser_or_equal(FP_ZERO, tmp_res) ||
                !fp_less_than(tmp_res,FP_POS_2_TO_64)) ) {
             tmp_fp_env->flags.v = 1;
             if (!tmp_fp_env->controls.vd)
                tmp_fp_env->em_faults.v = 1;
             tmp_res = FP_QNAN;

   } else if (fp_is_unorm(fr2)) {
       tmp_fp_env->flags.d = 1;
       if( !tmp_fp_env->controls.dd)
          tmp_fp_env->em_faults.d = 1;
   }

   return (tmp_res);
}

// *******************************************************************
// fpcvt_exception_fault_check()
// ********************************************************************
EM_pair_fp_reg_type
fpcvt_exception_fault_check(
   EM_fp_reg_specifier f2,
   EM_opcode_sf_type   sf,
   EM_boolean_t        signed_form,
   EM_boolean_t        trunc_form,
   EM_tmp_fp_env_type *tmp_fp_env)
{
EM_tmp_fp_env_type  tmp_fp_env_local;
EM_pair_fp_reg_type tmp_reg_pair;
EM_fp_reg_type      tmp_fr2 = FR[f2];

    fp_decode_environment( pc_simd, sf, tmp_fp_env );

    tmp_reg_pair.hi = FP_ZERO;
    tmp_reg_pair.lo = FP_ZERO;

    if (trunc_form)
        tmp_fp_env->rc = rc_rz;

// *************
// high
// **************
    tmp_fr2             = fp_reg_read_hi(f2);
    tmp_fp_env_local    = *tmp_fp_env;
    tmp_fp_env_local.ss = ss_double_extended_64;
    tmp_fp_env_local.es = es_seventeen_bits;
    tmp_reg_pair.hi     = fp_ieee_rnd_to_int( tmp_fr2, &tmp_fp_env_local);

    if ( signed_form &&
         fp_software_assistance_required(ps, op_fpcvt_fx, tmp_fr2)) {
        tmp_fp_env->hi_faults.swa = 1;

    } else if( !signed_form &&
               fp_software_assistance_required(ps, op_fpcvt_fxu, tmp_fr2)) {
        tmp_fp_env->hi_faults.swa = 1;

    } else if (fp_is_nan(tmp_fr2)) {
        tmp_fp_env->hi_flags.v = 1;
        tmp_reg_pair.hi = fp_is_snan(tmp_fr2)?fp_make_quiet_nan(tmp_fr2):tmp_fr2;
        if (!tmp_fp_env->controls.vd)
            tmp_fp_env->hi_faults.v = 1;


    } else if (signed_form &&
               (!fp_lesser_or_equal(FP_NEG_2_TO_31, tmp_reg_pair.hi) ||
                !fp_less_than(tmp_reg_pair.hi,FP_POS_2_TO_31)) ) {
       tmp_fp_env->hi_flags.v = 1;
       tmp_reg_pair.hi = FP_QNAN;
       if (!tmp_fp_env->controls.vd)
          tmp_fp_env->hi_faults.v = 1;

    } else if (!signed_form &&
               (!fp_lesser_or_equal(FP_ZERO, tmp_reg_pair.hi) ||
                !fp_less_than(tmp_reg_pair.hi,FP_POS_2_TO_32)) ) {
       tmp_fp_env->hi_flags.v = 1;
       tmp_reg_pair.hi = FP_QNAN;
       if (!tmp_fp_env->controls.vd)
          tmp_fp_env->hi_faults.v = 1;

    } else if (fp_is_unorm(tmp_fr2)) {
            tmp_fp_env->hi_flags.d = 1;
            if (!tmp_fp_env->controls.dd)
                tmp_fp_env->hi_faults.d = 1;
    }

// *************
// low
// **************
    tmp_fr2             = fp_reg_read_lo(f2);
    tmp_fp_env_local    = *tmp_fp_env;
    tmp_fp_env_local.ss = ss_double_extended_64;
    tmp_fp_env_local.es = es_seventeen_bits;
    tmp_reg_pair.lo     = fp_ieee_rnd_to_int( tmp_fr2, &tmp_fp_env_local);

    if ( signed_form &&
         fp_software_assistance_required(ps, op_fpcvt_fx, tmp_fr2)) {
        tmp_fp_env->lo_faults.swa = 1;

    } else if( !signed_form &&
               fp_software_assistance_required(ps, op_fpcvt_fxu, tmp_fr2)) {
        tmp_fp_env->lo_faults.swa = 1;

    } else if (fp_is_nan(tmp_fr2)) {
        tmp_fp_env->lo_flags.v = 1;
        tmp_reg_pair.lo = fp_is_snan(tmp_fr2)?fp_make_quiet_nan(tmp_fr2):tmp_fr2;
        if (!tmp_fp_env->controls.vd)
            tmp_fp_env->lo_faults.v = 1;

    } else if (signed_form &&
               (!fp_lesser_or_equal(FP_NEG_2_TO_31, tmp_reg_pair.lo) ||
                !fp_less_than(tmp_reg_pair.lo,FP_POS_2_TO_31)) ) {
        tmp_fp_env->lo_flags.v = 1;
        tmp_reg_pair.lo = FP_QNAN;
        if (!tmp_fp_env->controls.vd)
           tmp_fp_env->lo_faults.v = 1;

    } else if (!signed_form &&
               (!fp_lesser_or_equal(FP_ZERO, tmp_reg_pair.lo) ||
                !fp_less_than(tmp_reg_pair.lo,FP_POS_2_TO_32)) ) {
        tmp_fp_env->lo_flags.v = 1;
        tmp_reg_pair.lo = FP_QNAN;
        if (!tmp_fp_env->controls.vd)
           tmp_fp_env->lo_faults.v = 1;

    } else if (fp_is_unorm(tmp_fr2)) {
            tmp_fp_env->lo_flags.d = 1;
            if (!tmp_fp_env->controls.dd)
                tmp_fp_env->lo_faults.d = 1;
    }

    return (tmp_reg_pair);
}

// *******************************************************************
// fma_exception_fault_check()
// ********************************************************************
EM_fp_reg_type
fma_exception_fault_check(
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3, 
    EM_fp_reg_specifier f4,
    EM_opcode_pc_type   pc,
    EM_opcode_sf_type   sf,
    EM_tmp_fp_env_type  *tmp_fp_env)
{
    EM_fp_reg_type tmp_res;
    EM_fp_reg_type fr2, fr3, fr4;
   
// printf ("MACH DEBUG: BEGIN fma_exception_fault_check\n");
    fr2 = FR[f2];
    fr3 = FR[f3];
    fr4 = FR[f4];
// printf ("MACH DEBUG: FR2 = %x %x "LX"\n", fr2.sign, fr2.exponent, fr2.significand);
// printf ("MACH DEBUG: FR3 = %x %x "LX"\n", fr3.sign, fr3.exponent, fr3.significand);
// printf ("MACH DEBUG: FR4 = %x %x "LX"\n", fr4.sign, fr4.exponent, fr4.significand);

    fp_decode_environment( pc, sf, tmp_fp_env );

    if(f4==1 && f2==0) {
       if (fp_software_assistance_required(ps, op_fnorm, fr3, *tmp_fp_env)) {
          tmp_fp_env->em_faults.swa = 1;
          return (FP_ZERO);
       }
    } else {
       if (fp_software_assistance_required(ps, op_fma, fr2, fr3, fr4)) {
          tmp_fp_env->em_faults.swa = 1;
          return (FP_ZERO);
       }
    }

    tmp_res = FP_ZERO;

    if (fp_is_unsupported(fr2) || fp_is_unsupported(fr3) || fp_is_unsupported(fr4)) {
        tmp_fp_env->flags.v = 1;
        tmp_res = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
            return (tmp_res);
        }

    } else if (fp_is_nan(fr2) || fp_is_nan(fr3) || fp_is_nan(fr4)) {
         if (fp_is_snan(fr2) || fp_is_snan(fr3) || fp_is_snan(fr4)) {
            tmp_fp_env->flags.v = 1;
            if (!tmp_fp_env->controls.vd) 
               tmp_fp_env->em_faults.v = 1;
         }

         if (fp_is_nan(fr4))
             tmp_res = fp_is_snan(fr4)?fp_make_quiet_nan(fr4):fr4;
         else if (fp_is_nan(fr2))
             tmp_res = fp_is_snan(fr2)?fp_make_quiet_nan(fr2):fr2;
         else if (fp_is_nan(fr3))
             tmp_res = fp_is_snan(fr3)?fp_make_quiet_nan(fr3):fr3;

    } else if (( fp_is_pos_inf(fr3) && fp_is_pos_non_zero(fr4) && fp_is_neg_inf(fr2) )
            || ( fp_is_pos_inf(fr3) && fp_is_neg_non_zero(fr4) && fp_is_pos_inf(fr2) )
   
			|| ( fp_is_neg_inf(fr3) && fp_is_pos_non_zero(fr4) && fp_is_pos_inf(fr2) )
            || ( fp_is_neg_inf(fr3) && fp_is_neg_non_zero(fr4) && fp_is_neg_inf(fr2) )
 
			|| ( fp_is_pos_non_zero(fr3) && fp_is_pos_inf(fr4) && fp_is_neg_inf(fr2) )
            || ( fp_is_pos_non_zero(fr3) && fp_is_neg_inf(fr4) && fp_is_pos_inf(fr2) )

            || ( fp_is_neg_non_zero(fr3) && fp_is_pos_inf(fr4) && fp_is_pos_inf(fr2) )
            || ( fp_is_neg_non_zero(fr3) && fp_is_neg_inf(fr4) && fp_is_neg_inf(fr2) )) {

        tmp_fp_env->flags.v = 1;
        tmp_res = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
            return (tmp_res);
        }

    } else if ((fp_is_inf(fr3) && fp_is_zero(fr4)) || (fp_is_zero(fr3) && fp_is_inf(fr4))) {
        tmp_fp_env->flags.v = 1;
        tmp_res = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
            return (tmp_res);
        }

    
    } else if (fp_is_unorm(fr2) || fp_is_unorm(fr3) || fp_is_unorm(fr4)) {
// printf ("MACH DEBUG: setting the D flag in fma_exception_fault_check\n");
        tmp_fp_env->flags.d = 1;
        if(!tmp_fp_env->controls.dd) { // MACH DEBUG
// printf ("MACH DEBUG: setting the D fault in fma_exception_fault_check\n");
            tmp_fp_env->em_faults.d = 1; 
      } // MACH DEBUG
    }

    return (tmp_res);
}

// *******************************************************************
// fpma_exception_fault_check()
// ********************************************************************
EM_pair_fp_reg_type
fpma_exception_fault_check(
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3,
    EM_fp_reg_specifier f4,
    EM_opcode_sf_type   sf,
    EM_tmp_fp_env_type  *tmp_fp_env)
{
EM_pair_fp_reg_type tmp_reg_pair;
EM_fp_reg_type      tmp_fr2 = FR[f2], tmp_fr3 = FR[f3], tmp_fr4 = FR[f4];

    fp_decode_environment( pc_simd, sf, tmp_fp_env );

    tmp_reg_pair.hi = FP_ZERO;
    tmp_reg_pair.lo = FP_ZERO;

// *********
// high
// *********
    tmp_fr2 = fp_reg_read_hi(f2);
    tmp_fr3 = fp_reg_read_hi(f3);
    tmp_fr4 = fp_reg_read_hi(f4);

    if (fp_software_assistance_required(ps, op_fpma, tmp_fr2, tmp_fr3, tmp_fr4)) {
        tmp_fp_env->hi_faults.swa = 1;

    } else if (fp_is_nan(tmp_fr2) || fp_is_nan(tmp_fr3) || fp_is_nan(tmp_fr4)) {
        if (fp_is_snan(tmp_fr2) || fp_is_snan(tmp_fr3) || fp_is_snan(tmp_fr4)) {
            tmp_fp_env->hi_flags.v = 1;
            if (!tmp_fp_env->controls.vd)
                tmp_fp_env->hi_faults.v = 1;
        }

         if (fp_is_nan(tmp_fr4))
             tmp_reg_pair.hi = fp_is_snan(tmp_fr4)?fp_make_quiet_nan(tmp_fr4):tmp_fr4;
         else if (fp_is_nan(tmp_fr2))
             tmp_reg_pair.hi = fp_is_snan(tmp_fr2)?fp_make_quiet_nan(tmp_fr2):tmp_fr2;
         else if (fp_is_nan(tmp_fr3))
             tmp_reg_pair.hi = fp_is_snan(tmp_fr3)?fp_make_quiet_nan(tmp_fr3):tmp_fr3;

    } else if (( fp_is_pos_inf(tmp_fr3) && fp_is_pos_non_zero(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )
            || ( fp_is_pos_inf(tmp_fr3) && fp_is_neg_non_zero(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )

            || ( fp_is_neg_inf(tmp_fr3) && fp_is_pos_non_zero(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )
            || ( fp_is_neg_inf(tmp_fr3) && fp_is_neg_non_zero(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )

            || ( fp_is_pos_non_zero(tmp_fr3) && fp_is_pos_inf(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )
            || ( fp_is_pos_non_zero(tmp_fr3) && fp_is_neg_inf(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )

            || ( fp_is_neg_non_zero(tmp_fr3) && fp_is_pos_inf(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )
            || ( fp_is_neg_non_zero(tmp_fr3) && fp_is_neg_inf(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )) {
        tmp_fp_env->hi_flags.v = 1;
        tmp_reg_pair.hi = FP_QNAN;
        if (!tmp_fp_env->controls.vd)
            tmp_fp_env->hi_faults.v = 1;

    } else if ((fp_is_inf(tmp_fr3) && fp_is_zero(tmp_fr4))
            || (fp_is_zero(tmp_fr3) && fp_is_inf(tmp_fr4))) {
        tmp_fp_env->hi_flags.v = 1;
        tmp_reg_pair.hi = FP_QNAN;
        if (!tmp_fp_env->controls.vd)
            tmp_fp_env->hi_faults.v = 1;


    } else if (fp_is_unorm(tmp_fr2) || fp_is_unorm(tmp_fr3) || fp_is_unorm(tmp_fr4)) {

        tmp_fp_env->hi_flags.d = 1;
        if (!tmp_fp_env->controls.dd)
            tmp_fp_env->hi_faults.d = 1;
    }

// *********
// low
// **********   
    tmp_fr2 = fp_reg_read_lo(f2);
    tmp_fr3 = fp_reg_read_lo(f3);
    tmp_fr4 = fp_reg_read_lo(f4);

    if (fp_software_assistance_required(ps, op_fpma, tmp_fr2, tmp_fr3, tmp_fr4)) {
        tmp_fp_env->lo_faults.swa = 1;
    }

    if (fp_is_nan(tmp_fr2) || fp_is_nan(tmp_fr3) || fp_is_nan(tmp_fr4)) {
        if (fp_is_snan(tmp_fr2) || fp_is_snan(tmp_fr3) || fp_is_snan(tmp_fr4)) {
            tmp_fp_env->lo_flags.v = 1;
            if (!tmp_fp_env->controls.vd)
                tmp_fp_env->lo_faults.v = 1;
        }

         if (fp_is_nan(tmp_fr4))
             tmp_reg_pair.lo = fp_is_snan(tmp_fr4)?fp_make_quiet_nan(tmp_fr4):tmp_fr4;
         else if (fp_is_nan(tmp_fr2))
             tmp_reg_pair.lo = fp_is_snan(tmp_fr2)?fp_make_quiet_nan(tmp_fr2):tmp_fr2;
         else if (fp_is_nan(tmp_fr3))
             tmp_reg_pair.lo = fp_is_snan(tmp_fr3)?fp_make_quiet_nan(tmp_fr3):tmp_fr3;

    } else if (( fp_is_pos_inf(tmp_fr3) && fp_is_pos_non_zero(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )
            || ( fp_is_pos_inf(tmp_fr3) && fp_is_neg_non_zero(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )

            || ( fp_is_neg_inf(tmp_fr3) && fp_is_pos_non_zero(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )
            || ( fp_is_neg_inf(tmp_fr3) && fp_is_neg_non_zero(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )

            || ( fp_is_pos_non_zero(tmp_fr3) && fp_is_pos_inf(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )
            || ( fp_is_pos_non_zero(tmp_fr3) && fp_is_neg_inf(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )

            || ( fp_is_neg_non_zero(tmp_fr3) && fp_is_pos_inf(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )
            || ( fp_is_neg_non_zero(tmp_fr3) && fp_is_neg_inf(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )) {

        tmp_fp_env->lo_flags.v = 1;
        tmp_reg_pair.lo = FP_QNAN;
        if (!tmp_fp_env->controls.vd)
            tmp_fp_env->lo_faults.v = 1;

    } else if ((fp_is_inf(tmp_fr3) && fp_is_zero(tmp_fr4))
            || (fp_is_zero(tmp_fr3) && fp_is_inf(tmp_fr4))) {
        tmp_fp_env->lo_flags.v = 1;
        tmp_reg_pair.lo = FP_QNAN;
        if (!tmp_fp_env->controls.vd)
            tmp_fp_env->lo_faults.v = 1;

    } else if (fp_is_unorm(tmp_fr2) || fp_is_unorm(tmp_fr3) || fp_is_unorm(tmp_fr4)) {
        tmp_fp_env->lo_flags.d = 1;
        if (!tmp_fp_env->controls.dd)
            tmp_fp_env->lo_faults.d = 1;
    }

    return (tmp_reg_pair);
}


// *******************************************************************
// fpminmax_exception_fault_check()
// No return value
// If input contains a NATVAL, just return.
// Otherwise set flags appropriately so that fpsr will
// be correct or a fault taken in caller.
// ********************************************************************
INLINE void 
fpminmax_exception_fault_check(
    EM_uint_t f2,
    EM_uint_t f3,
    EM_opcode_sf_type sf,
    EM_tmp_fp_env_type *tmp_fp_env)
{
EM_fp_reg_type      tmp_fr2 = FR[f2], tmp_fr3 = FR[f3];

// MACH
    fp_decode_environment( pc_simd, sf, tmp_fp_env );

// ************
// high
// ************

    tmp_fr2 = fp_reg_read_hi(f2);
    tmp_fr3 = fp_reg_read_hi(f3);

    if (fp_software_assistance_required(ps, op_fpminmax, tmp_fr2, tmp_fr3)) {
        tmp_fp_env->hi_faults.swa = 1; 

    } else if (fp_is_nan(tmp_fr2) || fp_is_nan(tmp_fr3)) {
        tmp_fp_env->hi_flags.v = 1;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->hi_faults.v = 1;
        }

    } else if (fp_is_unorm(tmp_fr2) || fp_is_unorm(tmp_fr3)) {
        tmp_fp_env->hi_flags.d = 1;
        if (!tmp_fp_env->controls.dd) {
            tmp_fp_env->hi_faults.d = 1;
        }
    }

// ************
// low
// ************
    tmp_fr2 = fp_reg_read_lo(f2);
    tmp_fr3 = fp_reg_read_lo(f3);
 
    if (fp_software_assistance_required(ps, op_fpminmax, tmp_fr2, tmp_fr3)) {
        tmp_fp_env->lo_faults.swa = 1;

    } else if (fp_is_nan(tmp_fr2) || fp_is_nan(tmp_fr3)) {
        tmp_fp_env->lo_flags.v = 1;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->lo_faults.v = 1;
        }


    } else if (fp_is_unorm(tmp_fr2) || fp_is_unorm(tmp_fr3)) {
        tmp_fp_env->lo_flags.d = 1;
        if (!tmp_fp_env->controls.dd)
            tmp_fp_env->lo_faults.d = 1;
    }

    return;
}

// *******************************************************************
// fminmax_exception_fault_check()
// *******************************************************************
INLINE void
fminmax_exception_fault_check(
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3,
    EM_opcode_sf_type sf,
    EM_tmp_fp_env_type *tmp_fp_env)
{
EM_fp_reg_type fr2, fr3;

    fr2 = FR[f2];
    fr3 = FR[f3];

    fp_decode_environment( pc_none, sf, tmp_fp_env );

    if (fp_software_assistance_required(ps, op_fminmax, fr2, fr3)) {
        tmp_fp_env->em_faults.swa = 1;
    }

    if (fp_is_unsupported(fr2) || fp_is_unsupported(fr3)) {
        tmp_fp_env->flags.v = 1;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
        }

    } else if (fp_is_nan(fr2) || fp_is_nan(fr3)) {
        tmp_fp_env->flags.v = 1;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
        }


    } else if (fp_is_unorm(fr2) || fp_is_unorm(fr3)) {
        tmp_fp_env->flags.d = 1;
        if (!tmp_fp_env->controls.dd)
           tmp_fp_env->em_faults.d = 1;
    }

}

// *******************************************************************
// fms_fnma_()
// *******************************************************************
EM_fp_reg_type
fms_fnma_exception_fault_check(
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3, 
    EM_fp_reg_specifier f4, 
    EM_opcode_pc_type   pc,
    EM_opcode_sf_type   sf,
    EM_tmp_fp_env_type  *tmp_fp_env)
{
EM_fp_reg_type fr2, fr3, fr4;
EM_fp_reg_type tmp_res;

    fr2 = FR[f2];
    fr3 = FR[f3];
    fr4 = FR[f4];

    fp_decode_environment( pc, sf, tmp_fp_env );

    if (fp_software_assistance_required(ps, op_fms_fnma, fr2, fr3, fr4)) {
        tmp_fp_env->em_faults.swa = 1;
        return (FP_ZERO);
    }

    tmp_res = FP_ZERO;

    if (fp_is_unsupported(fr2) || fp_is_unsupported(fr3) || fp_is_unsupported(fr4)) {
        tmp_fp_env->flags.v = 1;
        tmp_res = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
            return (tmp_res);
        }

    } else if (fp_is_nan(fr2) || fp_is_nan(fr3) || fp_is_nan(fr4)) {
         if (fp_is_snan(fr2) || fp_is_snan(fr3) || fp_is_snan(fr4)) {
            tmp_fp_env->flags.v = 1;
            if (!tmp_fp_env->controls.vd)  
               tmp_fp_env->em_faults.v = 1;
         }


         if (fp_is_nan(fr4))
             tmp_res = fp_is_snan(fr4)?fp_make_quiet_nan(fr4):fr4;
         else if (fp_is_nan(fr2))
             tmp_res = fp_is_snan(fr2)?fp_make_quiet_nan(fr2):fr2;
         else if (fp_is_nan(fr3))
             tmp_res = fp_is_snan(fr3)?fp_make_quiet_nan(fr3):fr3;

    } else if (( fp_is_pos_inf(fr3) && fp_is_pos_non_zero(fr4) && fp_is_pos_inf(fr2) )
            || ( fp_is_pos_inf(fr3) && fp_is_neg_non_zero(fr4) && fp_is_neg_inf(fr2) )
            || ( fp_is_neg_inf(fr3) && fp_is_pos_non_zero(fr4) && fp_is_neg_inf(fr2) )
            || ( fp_is_neg_inf(fr3) && fp_is_neg_non_zero(fr4) && fp_is_pos_inf(fr2) )
            || ( fp_is_pos_non_zero(fr3) && fp_is_pos_inf(fr4) && fp_is_pos_inf(fr2) )
            || ( fp_is_pos_non_zero(fr3) && fp_is_neg_inf(fr4) && fp_is_neg_inf(fr2) )
            || ( fp_is_neg_non_zero(fr3) && fp_is_pos_inf(fr4) && fp_is_neg_inf(fr2) )
            || ( fp_is_neg_non_zero(fr3) && fp_is_neg_inf(fr4) && fp_is_pos_inf(fr2) )) {
        tmp_fp_env->flags.v = 1;
        tmp_res = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
            return (tmp_res);
        }

    } else if ((fp_is_inf(fr3) && fp_is_zero(fr4)) || (fp_is_zero(fr3) && fp_is_inf(fr4))) {
        tmp_fp_env->flags.v = 1;
        tmp_res = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
            return (tmp_res);
        }


    } else if (fp_is_unorm(fr2) || fp_is_unorm(fr3) || fp_is_unorm(fr4)) {
        tmp_fp_env->flags.d = 1;
        if (!tmp_fp_env->controls.dd)
           tmp_fp_env->em_faults.d = 1;
    }

    return (tmp_res);
}

// *******************************************************************
// fpms_fpnma_exception_fault_check()
// ********************************************************************
EM_pair_fp_reg_type
fpms_fpnma_exception_fault_check(
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3,
    EM_fp_reg_specifier f4,
    EM_opcode_sf_type   sf,
    EM_tmp_fp_env_type  *tmp_fp_env)
{
EM_pair_fp_reg_type tmp_reg_pair;
EM_fp_reg_type      tmp_fr2 = FR[f2], tmp_fr3 = FR[f3], tmp_fr4 = FR[f4];

    fp_decode_environment( pc_simd, sf, tmp_fp_env );

    tmp_reg_pair.hi = FP_ZERO;
    tmp_reg_pair.lo = FP_ZERO;

// ***************
// high
// ***************
    tmp_fr2 = fp_reg_read_hi(f2);
    tmp_fr3 = fp_reg_read_hi(f3);
    tmp_fr4 = fp_reg_read_hi(f4);

    if (fp_software_assistance_required(ps, op_fpms_fpnma, tmp_fr2, tmp_fr3, tmp_fr4)) {
        tmp_fp_env->hi_faults.swa = 1;

    } else if (fp_is_unsupported(tmp_fr2) || fp_is_unsupported(tmp_fr3) || fp_is_unsupported(tmp_fr4)) {
        tmp_fp_env->hi_flags.v = 1;
        tmp_reg_pair.hi        = FP_QNAN;
        if (!tmp_fp_env->controls.vd)
            tmp_fp_env->hi_faults.v = 1;

    } else if (fp_is_nan(tmp_fr2) || fp_is_nan(tmp_fr3) || fp_is_nan(tmp_fr4)) {
        if (fp_is_snan(tmp_fr2) || fp_is_snan(tmp_fr3) || fp_is_snan(tmp_fr4)) {
            tmp_fp_env->hi_flags.v = 1;
            if (!tmp_fp_env->controls.vd)
                tmp_fp_env->hi_faults.v = 1;
        }

         if (fp_is_nan(tmp_fr4))
             tmp_reg_pair.hi = fp_is_snan(tmp_fr4)?fp_make_quiet_nan(tmp_fr4):tmp_fr4;
         else if (fp_is_nan(tmp_fr2))
             tmp_reg_pair.hi = fp_is_snan(tmp_fr2)?fp_make_quiet_nan(tmp_fr2):tmp_fr2;
         else if (fp_is_nan(tmp_fr3))
             tmp_reg_pair.hi = fp_is_snan(tmp_fr3)?fp_make_quiet_nan(tmp_fr3):tmp_fr3;

    } else if (( fp_is_pos_inf(tmp_fr3) && fp_is_pos_non_zero(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )
            || ( fp_is_pos_inf(tmp_fr3) && fp_is_neg_non_zero(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )
            || ( fp_is_neg_inf(tmp_fr3) && fp_is_pos_non_zero(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )
            || ( fp_is_neg_inf(tmp_fr3) && fp_is_neg_non_zero(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )
            || ( fp_is_pos_non_zero(tmp_fr3) && fp_is_pos_inf(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )
            || ( fp_is_pos_non_zero(tmp_fr3) && fp_is_neg_inf(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )
            || ( fp_is_neg_non_zero(tmp_fr3) && fp_is_pos_inf(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )
            || ( fp_is_neg_non_zero(tmp_fr3) && fp_is_neg_inf(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )) {
        tmp_fp_env->hi_flags.v = 1;
        tmp_reg_pair.hi        = FP_QNAN;
        if (!tmp_fp_env->controls.vd)
            tmp_fp_env->hi_faults.v = 1;

    } else if ((fp_is_inf(tmp_fr3) && fp_is_zero(tmp_fr4))
            || (fp_is_zero(tmp_fr3) && fp_is_inf(tmp_fr4))) {
        tmp_fp_env->hi_flags.v = 1;
        tmp_reg_pair.hi = FP_QNAN;
        if (!tmp_fp_env->controls.vd)
            tmp_fp_env->hi_faults.v = 1;

    } else if (fp_is_unorm(tmp_fr2) || fp_is_unorm(tmp_fr3) || fp_is_unorm(tmp_fr4)) {
        tmp_fp_env->hi_flags.d = 1;
        if (!tmp_fp_env->controls.dd)
            tmp_fp_env->hi_faults.d = 1;
    }

// ***************
// low
// ***************
    tmp_fr2 = fp_reg_read_lo(f2);
    tmp_fr3 = fp_reg_read_lo(f3);
    tmp_fr4 = fp_reg_read_lo(f4);

    if (fp_software_assistance_required(ps, op_fpms_fpnma, tmp_fr2, tmp_fr3, tmp_fr4)) {
        tmp_fp_env->lo_faults.swa = 1;

    } else if (fp_is_unsupported(tmp_fr2) || fp_is_unsupported(tmp_fr3) || fp_is_unsupported(tmp_fr4)) {
        tmp_fp_env->lo_flags.v = 1;
        tmp_reg_pair.lo = FP_QNAN;
        if (!tmp_fp_env->controls.vd)
            tmp_fp_env->lo_faults.v = 1;

    } else if (fp_is_nan(tmp_fr2) || fp_is_nan(tmp_fr3) || fp_is_nan(tmp_fr4)) {
        if (fp_is_snan(tmp_fr2) || fp_is_snan(tmp_fr3) || fp_is_snan(tmp_fr4)) {
            tmp_fp_env->lo_flags.v = 1;
            if (!tmp_fp_env->controls.vd)
                tmp_fp_env->lo_faults.v = 1;
        }

         if (fp_is_nan(tmp_fr4))
             tmp_reg_pair.lo = fp_is_snan(tmp_fr4)?fp_make_quiet_nan(tmp_fr4):tmp_fr4;
         else if (fp_is_nan(tmp_fr2))
             tmp_reg_pair.lo = fp_is_snan(tmp_fr2)?fp_make_quiet_nan(tmp_fr2):tmp_fr2;
         else if (fp_is_nan(tmp_fr3))
             tmp_reg_pair.lo = fp_is_snan(tmp_fr3)?fp_make_quiet_nan(tmp_fr3):tmp_fr3;

    } else if (( fp_is_pos_inf(tmp_fr3) && fp_is_pos_non_zero(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )
            || ( fp_is_pos_inf(tmp_fr3) && fp_is_neg_non_zero(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )
            || ( fp_is_neg_inf(tmp_fr3) && fp_is_pos_non_zero(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )
            || ( fp_is_neg_inf(tmp_fr3) && fp_is_neg_non_zero(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )
            || ( fp_is_pos_non_zero(tmp_fr3) && fp_is_pos_inf(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )
            || ( fp_is_pos_non_zero(tmp_fr3) && fp_is_neg_inf(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )
            || ( fp_is_neg_non_zero(tmp_fr3) && fp_is_pos_inf(tmp_fr4)
                                     && fp_is_neg_inf(tmp_fr2) )
            || ( fp_is_neg_non_zero(tmp_fr3) && fp_is_neg_inf(tmp_fr4)
                                     && fp_is_pos_inf(tmp_fr2) )) {
        tmp_fp_env->lo_flags.v = 1;
        tmp_reg_pair.lo = FP_QNAN;
        if (!tmp_fp_env->controls.vd)
            tmp_fp_env->lo_faults.v = 1;

    } else if ((fp_is_inf(tmp_fr3) && fp_is_zero(tmp_fr4))
            || (fp_is_zero(tmp_fr3) && fp_is_inf(tmp_fr4))) {
        tmp_fp_env->lo_flags.v = 1;
        tmp_reg_pair.lo = FP_QNAN;
        if (!tmp_fp_env->controls.vd)
            tmp_fp_env->lo_faults.v = 1;

    } else if (fp_is_unorm(tmp_fr2) || fp_is_unorm(tmp_fr3) || fp_is_unorm(tmp_fr4)) {
        tmp_fp_env->lo_flags.d = 1;
        if (!tmp_fp_env->controls.dd)
            tmp_fp_env->lo_faults.d = 1;
    }

    return (tmp_reg_pair);
}



INLINE EM_fp_dp_type
fp_max_or_infinity(EM_uint_t sign, EM_tmp_fp_env_type *tmp_fp_env,
     EM_uint_t e_max, EM_uint128_t max_significand)
{
    EM_fp_dp_type tmp_res;
    tmp_res.sign = sign;

    if (tmp_fp_env->rc == rc_rm) {
        if (tmp_res.sign) {
            tmp_res.exponent    = FP_DP_EXP_ONES;
            tmp_res.significand = U128_0x80000000000000000000000000000000;
        }else {
            tmp_res.exponent    = e_max;
            tmp_res.significand = max_significand;
        }

    } else if (tmp_fp_env->rc == rc_rz) {
        tmp_res.exponent    = e_max;
        tmp_res.significand = max_significand;

    } else if (tmp_fp_env->rc == rc_rp) {
        if (tmp_res.sign) {
            tmp_res.exponent    = e_max;
            tmp_res.significand = max_significand;
        }else {
            tmp_res.exponent    = FP_DP_EXP_ONES;
            tmp_res.significand = U128_0x80000000000000000000000000000000;
        }

    } else {
        tmp_res.exponent    = FP_DP_EXP_ONES;
        tmp_res.significand = U128_0x80000000000000000000000000000000;
    }

    return(tmp_res);
}

INLINE EM_fp_dp_type
fp_mul(EM_fp_reg_type fr3, EM_fp_reg_type fr4)
{
    EM_fp_dp_type tmp_res;
    EM_int_t normalize_count;

// all cases which might have faulted have been screened out 
// we still may trap on overflow, underflow and/or inexact later

    if (fp_is_zero(fr3) || fp_is_zero(fr4)) {
            /* correctly signed zero */
        tmp_res = fp_fr_to_dp(FP_ZERO);
        tmp_res.sign = fr3.sign ^ fr4.sign;
    } else if (fp_is_inf(fr3) || fp_is_inf(fr4)) {
            /* correctly signed inf*/
        tmp_res = fp_fr_to_dp(FP_INFINITY);
        tmp_res.sign = fr3.sign ^ fr4.sign;
    } else if (fp_is_pseudo_zero(fr3) || fp_is_pseudo_zero(fr4)) {
            /* pseudo zero  if one operand is a pseudo-zero, return real zero.
               pz * NaN = Nan, but we already tested for Nan                   */
        tmp_res = fp_fr_to_dp(FP_ZERO);
        tmp_res.sign = fr3.sign ^ fr4.sign;
    } else {
            /* (un)normal * (un)normal */
        tmp_res.sign         = fr3.sign ^ fr4.sign;
        tmp_res.exponent     = (EM_uint_t)(
                                         (((EM_int_t)fr3.exponent)-FP_REG_BIAS)
                                       + (((EM_int_t)fr4.exponent)-FP_REG_BIAS)
                                       + FP_DP_BIAS);
                /* x.xxx (64-bits) * y.yyy (64-bits)
                => zz.zzzzzz (128-bits) */
        tmp_res.significand = fp_U64_x_U64_to_U128(fr3.significand,
                                                fr4.significand);
        if (fp_U128_lead0(tmp_res.significand) == 0) {
                /* 1.xxx (64-bits) * 1.yyy (64-bits)
                => 1z.zzzzzz (128-bits) */
            tmp_res.exponent += 1;
                /* 1z.zzzzzz
                => 1.zzzzzzz (128-bits) */
        } else if (fp_U128_lead0(tmp_res.significand) == 1) {
                /* 1.xxx (64-bits) * 1.yyy (64-bits)
                => 0z.zzzzzz (128-bits) */
            tmp_res.significand = fp_U128_lsh(tmp_res.significand,1);
                /* 0z.zzzzzz => z.zzzzzz0 (128-bits) */
        } else {
                /* 0.xxx (64-bits) * 0.yyy (64-bits)
                => 00.zzzzzz (128-bits) all unsigned int's */
            normalize_count = fp_U128_lead0(tmp_res.significand);
            tmp_res.exponent -= normalize_count-1;
            tmp_res.significand = fp_U128_lsh(tmp_res.significand,
                                                 normalize_count);
        }
    }
    tmp_res.sticky = 0;
    return(tmp_res);
}

INLINE EM_fp_reg_type
fp_normalize(EM_fp_reg_type freg)
{
    EM_int_t tmp_normalize_count;

    if (fp_is_nan(freg) || fp_is_inf(freg) || fp_is_normal(freg)
    || fp_is_unsupported(freg) || fp_is_zero(freg) || fp_is_natval(freg))
        return (freg);

    tmp_normalize_count = fp_U64_lead0(freg.significand);
    if (tmp_normalize_count == 64) { /* ftz pseudo-zero */
        if(freg.exponent)
            freg.exponent = 0;
        return (freg);
    } else if(freg.exponent == 1) {
        return(freg);


    } else if ((((EM_int_t)freg.exponent) - tmp_normalize_count) <= 0) {
        tmp_normalize_count = freg.exponent -1;
        freg.exponent       = 1;
        freg.significand  <<= tmp_normalize_count;
        return (freg);

    } else { /* normalize */
        freg.exponent -= tmp_normalize_count;
        freg.significand <<= tmp_normalize_count;
        return(freg);
    }
}

INLINE EM_fp_dp_type
fp_normalize_dp(EM_fp_dp_type fp_dp)
{
    EM_int_t tmp_normalize_count;

    if (fp_is_nan_dp(fp_dp) || fp_is_inf_dp(fp_dp) || fp_is_normal_dp(fp_dp)
    || fp_is_zero_dp(fp_dp))
        return (fp_dp);
    else if (fp_is_unsupported_dp(fp_dp)) /* unsupported are turned into nans */
        return (fp_fr_to_dp(FP_QNAN));
    tmp_normalize_count = fp_U128_lead0(fp_dp.significand);
    if (tmp_normalize_count == 128) { /* ftz pseudo-zero */
        if (fp_dp.exponent)
            fp_dp.exponent = 0;
        return (fp_dp);
        
    } else if ((((EM_int_t)fp_dp.exponent) - tmp_normalize_count) <= 0) {
        /* ftz register file format (pseudo-)denormals */
        fp_dp.exponent = 0;
        fp_dp.significand = U128_0;
        return (fp_dp);
    } else { /* normalize */
        fp_dp.exponent -= tmp_normalize_count;
        fp_dp.significand = fp_U128_lsh(fp_dp.significand,
                                           tmp_normalize_count);
        return(fp_dp);
    }
}


EM_fp_dp_type
fp82_fp_fr_to_dp(EM_fp_reg_type fr1)
{
    EM_fp_dp_type tmp_res;
    tmp_res.sign = fr1.sign;
    if (fr1.exponent == 0)
        tmp_res.exponent = 0;
    else if (fr1.exponent == FP_REG_EXP_ONES)
        tmp_res.exponent = FP_DP_EXP_ONES;
    else
        tmp_res.exponent = (EM_uint_t)(((EM_int_t)fr1.exponent)
                                   - FP_REG_BIAS + FP_DP_BIAS);

    tmp_res.significand.hi = fr1.significand;
    tmp_res.significand.lo = U64_0;
    tmp_res.sticky = 0;
    return(fp_normalize_dp(tmp_res));
}

// *******************************************************************
// frcpa_exception_fault_check()
// *******************************************************************
EM_fp_reg_type
frcpa_exception_fault_check(
   EM_fp_reg_specifier f2,
   EM_fp_reg_specifier f3, 
   EM_opcode_sf_type   sf,
   EM_tmp_fp_env_type  *tmp_fp_env)
{
    EM_fp_reg_type fr2, fr3;
    EM_fp_reg_type tmp_res;
    EM_int_t estimated_exponent;

    fr2 = FR[f2];
    fr3 = FR[f3];
    fp_decode_environment( pc_none, sf, tmp_fp_env );

    if (fp_software_assistance_required(ps, op_frcpa, fr2, fr3) ) {
        tmp_fp_env->em_faults.swa = 1;
        return (FP_ZERO);
    }

    tmp_res = FP_ZERO;

    if (fp_is_unsupported(fr2) || fp_is_unsupported(fr3)) {
        tmp_fp_env->flags.v = 1;
        tmp_res             = FP_QNAN;

        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
        }

    } else if (fp_is_nan(fr2) || fp_is_nan(fr3)) {
         if (fp_is_snan(fr2) || fp_is_snan(fr3)) {
             tmp_fp_env->flags.v = 1;
             if (!tmp_fp_env->controls.vd) {
                 tmp_fp_env->em_faults.v = 1;
             }
         }
         if (fp_is_nan(fr2)) {
             tmp_res = fp_is_snan(fr2)?fp_make_quiet_nan(fr2):fr2;
         } else if (fp_is_nan(fr3)) {
             tmp_res = fp_is_snan(fr3)?fp_make_quiet_nan(fr3):fr3;
         }

    } else if ( (fp_is_inf(fr2)  && fp_is_inf(fr3))
              || ( (fp_is_zero(fr2) || fp_is_pseudo_zero(fr2))
                && (fp_is_zero(fr3) || fp_is_pseudo_zero(fr3)) ) ) {
        tmp_fp_env->flags.v = 1;
        tmp_res = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
        }

    } else if (  ( ( fp_is_normal(fr2) && !fp_is_zero(fr2) )
                || ( fp_is_unorm(fr2)  && !fp_is_pseudo_zero(fr2) ) )
              && (   fp_is_zero(fr3)   ||  fp_is_pseudo_zero(fr3) ) ) {
        tmp_fp_env->flags.z = 1;
        tmp_res = FP_INFINITY;
        tmp_res.sign = fr2.sign ^ fr3.sign;
        if (!tmp_fp_env->controls.zd) {
            tmp_fp_env->em_faults.z = 1;
        }


    } else if (fp_is_unorm(fr2) || fp_is_unorm(fr3)) {
        tmp_fp_env->flags.d = 1;
        if (!tmp_fp_env->controls.dd) {
            tmp_fp_env->em_faults.d = 1;
        }
    } 
/************************************************************
This is the architecturally mandated swa fault check.

The precision of the working type is 17-bit exponent.
   fp_normalize() will normalize except in the case of a register denormal.
   In this context, fp_is_unorm() returns 1 if integer bit is 0
   and that occurs when fr3.exponent < emin.
Note that the estimated exponent is unbiased, because the bias
is subtracted out.
*************************************************************/
    if ( !fp_is_zero(fr2) && fp_is_finite(fr2) && !fp_is_pseudo_zero(fr2)
      && !fp_is_zero(fr3) && fp_is_finite(fr3) && !fp_is_pseudo_zero(fr3)
       ) {

        fr2 = fp_normalize(fp_reg_read(fr2));
        fr3 = fp_normalize(fp_reg_read(fr3));

        estimated_exponent = (EM_int_t)(fr2.exponent)
                           - (EM_int_t)(fr3.exponent);
        
	    if ( fp_is_unorm(fr3) 
          || ( fr3.exponent       >=  (FP_REG_BIAS+FP_REG_BIAS-2) )
          || ( estimated_exponent >=  ((EM_int_t)(FP_REG_BIAS)) )
          || ( estimated_exponent <= (2 - (EM_int_t)FP_REG_BIAS) )
          || ( fr2.exponent       <= (ss_double_extended_64)     )
           ) {
                 tmp_fp_env->em_faults.swa = 1; 
        }
    }
    return (tmp_res);
}

// *******************************************************************
// fprcpa_exception_fault_check()
// *******************************************************************
EM_pair_fp_reg_type
fprcpa_exception_fault_check(
   EM_fp_reg_specifier    f2,
   EM_fp_reg_specifier    f3,
   EM_opcode_sf_type      sf,
   EM_tmp_fp_env_type     *tmp_fp_env, 
   EM_limits_check_fprcpa  *limits_check)
{
EM_pair_fp_reg_type tmp_reg_pair;
EM_fp_reg_type      tmp_fr2 = FR[f2], tmp_fr3 = FR[f3];
EM_int_t            estimated_exponent;

    fp_decode_environment( pc_simd, sf, tmp_fp_env );

    tmp_reg_pair.hi = FP_ZERO;
    tmp_reg_pair.lo = FP_ZERO;

// ************
// high
// ************
    tmp_fr2 = fp_reg_read_hi(f2);
    tmp_fr3 = fp_reg_read_hi(f3);

    if (fp_software_assistance_required(ps, op_fprcpa, tmp_fr2, tmp_fr3)) {
        tmp_fp_env->hi_faults.swa = 1;

    } else if (fp_is_nan(tmp_fr2) || fp_is_nan(tmp_fr3)) {
        if (fp_is_snan(tmp_fr2) || fp_is_snan(tmp_fr3)) {
            tmp_fp_env->hi_flags.v = 1;
            if (!tmp_fp_env->controls.vd) {
                tmp_fp_env->hi_faults.v = 1;
            }
        }
        if (fp_is_nan(tmp_fr2)) {
            tmp_reg_pair.hi = fp_is_snan(tmp_fr2)
                            ? fp_make_quiet_nan(tmp_fr2) : tmp_fr2;
        } else if (fp_is_nan(tmp_fr3)) {
            tmp_reg_pair.hi = fp_is_snan(tmp_fr3)
                            ? fp_make_quiet_nan(tmp_fr3) : tmp_fr3;
        }

/*******************************************************************************
(f2 and f3 are inf) or (f2 and f3 are 0); returns qnan
********************************************************************************/
    } else if ( (fp_is_inf(tmp_fr2)  && fp_is_inf(tmp_fr3)  )
             || (fp_is_zero(tmp_fr2) && fp_is_zero(tmp_fr3) ) ) {
        tmp_fp_env->hi_flags.v = 1;
        tmp_reg_pair.hi = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->hi_faults.v = 1;
        }
/*******************************************************************************
(f2 is non-zero (normal or denormal but not inf) and f3 is zero; returns inf
The reason for the "but not inf" is because inf/0 shoudl not set the
divide-by-zero flag.
********************************************************************************/
    } else if ( !fp_is_inf(tmp_fr2) && !fp_is_zero(tmp_fr2) && fp_is_zero(tmp_fr3) ) {
        tmp_fp_env->hi_flags.z = 1;
        tmp_reg_pair.hi        = FP_INFINITY;
        tmp_reg_pair.hi.sign   = tmp_fr2.sign ^ tmp_fr3.sign;
        if (!tmp_fp_env->controls.zd) {
            tmp_fp_env->hi_faults.z = 1;
        }

    } else if (fp_is_unorm(tmp_fr2) || fp_is_unorm(tmp_fr3)) {
        tmp_fp_env->hi_flags.d = 1;
        if (!tmp_fp_env->controls.dd) {
            tmp_fp_env->hi_faults.d = 1;
        }
    } 

    if ( !fp_is_zero(tmp_fr2) && fp_is_finite(tmp_fr2)
      && !fp_is_zero(tmp_fr3) && fp_is_finite(tmp_fr3) ) {

        tmp_fr2 = fp_normalize(tmp_fr2);

        if ( fp_is_unorm(tmp_fr3) ) {
            limits_check->hi_fr3        = 1; /* recip(fr3_hi) not rep. */
            tmp_reg_pair.hi             = FP_INFINITY;  
            tmp_reg_pair.hi.sign        = tmp_fr3.sign;
            tmp_fr3                     = fp_normalize(tmp_fr3);

        } else if ( tmp_fr3.exponent >= (FP_REG_BIAS+FP_SGL_BIAS-2) ) {
            limits_check->hi_fr3        = 1; /* recip(fr3_hi) not rep. */
            tmp_reg_pair.hi             = FP_ZERO;             
            tmp_reg_pair.hi.sign        = tmp_fr3.sign;
        }

        estimated_exponent = (EM_int_t)tmp_fr2.exponent
                           - (EM_int_t)tmp_fr3.exponent;


        if (  (estimated_exponent >= (((EM_int_t)(FP_SGL_BIAS)))          )
           || (estimated_exponent <= (2-((EM_int_t)FP_SGL_BIAS))            )
           || (tmp_fr2.exponent   <= (ss_single_24+FP_REG_BIAS-FP_SGL_BIAS) )
           ) {
            limits_check->hi_fr2_or_quot = 1; /* hi est. quot. or fr2_hi */
        }
    }

// ************
// low
// ************
    tmp_fr2 = fp_reg_read_lo(f2);
    tmp_fr3 = fp_reg_read_lo(f3);

    if (fp_software_assistance_required(ps, op_fprcpa, tmp_fr2, tmp_fr3)) {
        tmp_fp_env->lo_faults.swa = 1;

    } else if (fp_is_nan(tmp_fr2) || fp_is_nan(tmp_fr3)) {
        if (fp_is_snan(tmp_fr2) || fp_is_snan(tmp_fr3)) {
            tmp_fp_env->lo_flags.v = 1;
            if (!tmp_fp_env->controls.vd) {
                tmp_fp_env->lo_faults.v = 1;
            }
        }
        if (fp_is_nan(tmp_fr2)) {
            tmp_reg_pair.lo = fp_is_snan(tmp_fr2)
                            ? fp_make_quiet_nan(tmp_fr2) : tmp_fr2;
        } else if (fp_is_nan(tmp_fr3)) {
            tmp_reg_pair.lo = fp_is_snan(tmp_fr3)
                            ? fp_make_quiet_nan(tmp_fr3) : tmp_fr3;
        }
/*******************************************************************************
(f2 and f3 are inf) or (f2 and f3 are 0); returns qnan
********************************************************************************/
   } else if ( ( fp_is_inf(tmp_fr2)  && fp_is_inf(tmp_fr3)  )
            || ( fp_is_zero(tmp_fr2) && fp_is_zero(tmp_fr3) ) ) {
        tmp_fp_env->lo_flags.v = 1;
        tmp_reg_pair.lo        = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->lo_faults.v = 1;
        }
/*******************************************************************************
(f2 is non-zero (normal or denormal but not inf) and f3 is zero; returns inf
The reason for the "but not inf" is because inf/0 should not set the
divide-by-zero flag.
********************************************************************************/
    } else if ( !fp_is_inf(tmp_fr2) && !fp_is_zero(tmp_fr2) && fp_is_zero(tmp_fr3) ) {
        tmp_fp_env->lo_flags.z = 1;
        tmp_reg_pair.lo = FP_INFINITY;
        tmp_reg_pair.lo.sign = tmp_fr2.sign ^ tmp_fr3.sign;
        if (!tmp_fp_env->controls.zd) {
            tmp_fp_env->lo_faults.z = 1;
        }

    } else if (fp_is_unorm(tmp_fr2) || fp_is_unorm(tmp_fr3)) {
        tmp_fp_env->lo_flags.d = 1;
        if (!tmp_fp_env->controls.dd) {
            tmp_fp_env->lo_faults.d = 1;
        }
    } 

    if ( !fp_is_zero(tmp_fr2) && fp_is_finite(tmp_fr2)
      && !fp_is_zero(tmp_fr3) && fp_is_finite(tmp_fr3) ) {

        tmp_fr2 = fp_normalize(tmp_fr2);

        if ( fp_is_unorm(tmp_fr3) ) {
            limits_check->lo_fr3 = 1; /* recip(fr3_lo) not rep. */
            tmp_reg_pair.lo      = FP_INFINITY;          
            tmp_reg_pair.lo.sign        = tmp_fr3.sign;
            tmp_fr3              = fp_normalize(tmp_fr3);

        } else if ( tmp_fr3.exponent >= (FP_REG_BIAS+FP_SGL_BIAS-2) ) {
            limits_check->lo_fr3 = 1; /* recip(fr3_lo) not rep. */
            tmp_reg_pair.lo      = FP_ZERO;             
            tmp_reg_pair.lo.sign        = tmp_fr3.sign;
        }

        estimated_exponent = (EM_int_t)tmp_fr2.exponent
                           - (EM_int_t)tmp_fr3.exponent;

        if (  (estimated_exponent >= (((EM_int_t)(FP_SGL_BIAS)))          )
           || (estimated_exponent <= (2-((EM_int_t)FP_SGL_BIAS))            )
           || (tmp_fr2.exponent   <= (ss_single_24+FP_REG_BIAS-FP_SGL_BIAS) )
           ) {
            limits_check->lo_fr2_or_quot = 1; /* lo est. quot. or fr2_lo */
        }
          
    }   

    return (tmp_reg_pair);
}

// *******************************************************************
// frsqrta_exception_fault_check()
// *******************************************************************
EM_fp_reg_type
frsqrta_exception_fault_check(
     EM_fp_reg_specifier f3,
     EM_opcode_sf_type   sf,
     EM_tmp_fp_env_type  *tmp_fp_env)
{
EM_fp_reg_type tmp_res, fr3;
    
    fr3 = FR[f3];
    fp_decode_environment( pc_none, sf, tmp_fp_env );

    if (fp_software_assistance_required(ps, op_frsqrta, fr3)) {
        tmp_fp_env->em_faults.swa = 1;
        return (FP_ZERO);
    }

    tmp_res = FP_ZERO;

    if (fp_is_unsupported(fr3)) {
        tmp_fp_env->flags.v = 1;
        tmp_res = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
        }

    } else if (fp_is_nan(fr3)) {
        if(fp_is_snan(fr3)){
           tmp_fp_env->flags.v = 1;
           if (!tmp_fp_env->controls.vd)  {
               tmp_fp_env->em_faults.v = 1;
           }
        }
        tmp_res = fp_is_snan(fr3)
                ? fp_make_quiet_nan(fr3) : fr3;

    } else if (fp_is_neg_inf(fr3)) {
        tmp_fp_env->flags.v = 1;
        tmp_res             = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
        }

    } else if ( fp_is_neg_non_zero(fr3) && !fp_is_pseudo_zero(fr3)) {
        tmp_fp_env->flags.v = 1;
        tmp_res             = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->em_faults.v = 1;
        }

 
    } else if (fp_is_unorm(fr3)) {
        tmp_fp_env->flags.d = 1;
        if( !tmp_fp_env->controls.dd) {
           tmp_fp_env->em_faults.d = 1;
        }
    }


    if( (fp_is_pos_non_zero(fr3) && !fp_is_pseudo_zero(fr3) )&& fp_is_finite(fr3)) {
       fr3 = fp_normalize(fp_reg_read(fr3));
       if(fr3.exponent <= ss_double_extended_64) {
          tmp_fp_env->em_faults.swa = 1; 
       } 
    }
 
    return (tmp_res);
}

// *******************************************************************
// fprsqrta_exception_fault_check()
// *******************************************************************
EM_pair_fp_reg_type
fprsqrta_exception_fault_check(
    EM_fp_reg_specifier      f3,
    EM_opcode_sf_type        sf,
    EM_tmp_fp_env_type       *tmp_fp_env, 
    EM_limits_check_fprsqrta *limits_check)
{
EM_pair_fp_reg_type tmp_reg_pair;
EM_fp_reg_type      tmp_fr3 = FR[f3];

    fp_decode_environment( pc_simd, sf, tmp_fp_env );

    tmp_reg_pair.hi = FP_ZERO;
    tmp_reg_pair.lo = FP_ZERO;

// ********
// high
// ********
    tmp_fr3 = fp_reg_read_hi(f3);
    if (fp_software_assistance_required(ps, op_fprsqrta, tmp_fr3)) {
        tmp_fp_env->hi_faults.swa = 1;

    } else if (fp_is_nan(tmp_fr3)) {
        if (fp_is_snan(tmp_fr3)) {
            tmp_fp_env->hi_flags.v = 1;
            if (!tmp_fp_env->controls.vd) {
                tmp_fp_env->hi_faults.v = 1;
            }
        }
        tmp_reg_pair.hi = fp_is_snan(tmp_fr3)
                        ? fp_make_quiet_nan(tmp_fr3) : tmp_fr3;

    } else if (fp_is_neg_inf(tmp_fr3)) {
        tmp_fp_env->hi_flags.v = 1;
        tmp_reg_pair.hi = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->hi_faults.v = 1;
        }
    } else if (fp_is_neg_non_zero(tmp_fr3)) {
        tmp_fp_env->hi_flags.v = 1;
        tmp_reg_pair.hi        = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->hi_faults.v = 1;
        }

    } else if (fp_is_unorm(tmp_fr3)) {
        tmp_fp_env->hi_flags.d = 1;
        if (!tmp_fp_env->controls.dd) {
            tmp_fp_env->hi_faults.d = 1;
        }

    } 
    if(fp_is_pos_non_zero(tmp_fr3) && fp_is_finite(tmp_fr3)) {
       tmp_fr3 = fp_normalize(tmp_fr3);
       if (tmp_fr3.exponent <= (FP_REG_BIAS - FP_SGL_BIAS + ss_single_24)) {
            limits_check->hi = 1;
       } else {
            limits_check->hi = 0;
       }
    }

// ********
// low
// ********
    tmp_fr3 = fp_reg_read_lo(f3);

    if (fp_software_assistance_required(ps, op_fprsqrta, tmp_fr3)) {
        tmp_fp_env->lo_faults.swa = 1;

    } else if (fp_is_nan(tmp_fr3)) {
        if (fp_is_snan(tmp_fr3)) {
            tmp_fp_env->lo_flags.v = 1;
            if (!tmp_fp_env->controls.vd) {
                tmp_fp_env->lo_faults.v = 1;
            }
        }
        tmp_reg_pair.lo = fp_is_snan(tmp_fr3)
                        ? fp_make_quiet_nan(tmp_fr3) : tmp_fr3;

    } else if (fp_is_neg_inf(tmp_fr3)) {
        tmp_fp_env->lo_flags.v = 1;
        tmp_reg_pair.lo = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->lo_faults.v = 1;
        }
    } else if (fp_is_neg_non_zero(tmp_fr3)) {
        tmp_fp_env->lo_flags.v = 1;
        tmp_reg_pair.lo = FP_QNAN;
        if (!tmp_fp_env->controls.vd) {
            tmp_fp_env->lo_faults.v = 1;
        }

    } else if (fp_is_unorm(tmp_fr3)) {
        tmp_fp_env->lo_flags.d = 1;
        if (!tmp_fp_env->controls.dd) {
            tmp_fp_env->lo_faults.d = 1;
        }
    }

    if(fp_is_pos_non_zero(tmp_fr3) && fp_is_finite(tmp_fr3)) {
       tmp_fr3 = fp_normalize(tmp_fr3);
       if (tmp_fr3.exponent <= (FP_REG_BIAS - FP_SGL_BIAS + ss_single_24)) {
            limits_check->lo = 1;
       } else {
            limits_check->lo = 0;
       }
    }


    return (tmp_reg_pair);
}



INLINE EM_boolean_t
fp_is_finite(EM_fp_reg_type freg)
{
    if ( fp_is_inf(freg) || fp_is_nan(freg) || fp_is_unsupported(freg) ) {
        return(0);
    } else {
        return(1);
    }
}

INLINE EM_boolean_t
fp_is_inf(EM_fp_reg_type freg)
{
    if ( (freg.exponent == FP_REG_EXP_ONES)
       &&(freg.significand == U64_0x8000000000000000) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_inf_dp(EM_fp_dp_type tmp_res)
{
    if ( (tmp_res.exponent == FP_DP_EXP_ONES)
       && fp_U128_eq(tmp_res.significand,
                      U128_0x80000000000000000000000000000000) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_nan(EM_fp_reg_type freg)
{
    if (  (freg.exponent == FP_REG_EXP_ONES)
      && ((freg.significand & U64_0x8000000000000000) != 0)
      && ((freg.significand & U64_0x7FFFFFFFFFFFFFFF) != 0) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_nan_dp(EM_fp_dp_type tmp_res)
{
    if ( (tmp_res.exponent == FP_DP_EXP_ONES)
       && fp_U128_eq(U128_0x80000000000000000000000000000000,
                  fp_U128_band(tmp_res.significand,
                            U128_0x80000000000000000000000000000000))
       && !fp_U128_eq(U128_0,
                  fp_U128_band(tmp_res.significand,
                            U128_0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
       ) {
        return (1);
    } else {
        return (0);
    }
}

INLINE EM_boolean_t
fp_is_natval(EM_fp_reg_type freg)
{
    if ( (freg.sign == 0)
     && (freg.exponent == 0x1FFFE)
     && (freg.significand == U64_0) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_neg_dp(EM_fp_dp_type tmp_res)
{
    if (tmp_res.sign) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_neg_inf(EM_fp_reg_type freg)
{
    if ( (freg.sign == 1)
      && (freg.exponent == FP_REG_EXP_ONES)
      && (freg.significand == U64_0x8000000000000000) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_neg_non_zero(EM_fp_reg_type freg)
{
    if ( (freg.sign == 1) && !fp_is_zero(freg) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_normal(EM_fp_reg_type freg)
{
    if ( (freg.exponent != 0)
      && (freg.exponent != FP_REG_EXP_ONES)
      && ((freg.significand & U64_0x8000000000000000) != 0) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_normal_dp(EM_fp_dp_type tmp_res)
{
    if ( (tmp_res.exponent != 0)
      && (tmp_res.exponent != FP_DP_EXP_ONES)
      && fp_U128_eq(U128_0x80000000000000000000000000000000,
                 fp_U128_band(tmp_res.significand,
                           U128_0x80000000000000000000000000000000))
      ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_pos_dp(EM_fp_dp_type tmp_res)
{
    if (!tmp_res.sign) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_pos_inf(EM_fp_reg_type freg)
{
    if ( (freg.sign == 0)
      && (freg.exponent == FP_REG_EXP_ONES)
      && (freg.significand == U64_0x8000000000000000) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_pos_non_zero(EM_fp_reg_type freg)
{
    if ( (freg.sign == 0) && !fp_is_zero(freg) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_pseudo_zero(EM_fp_reg_type freg)
{
    if ( (freg.exponent != 0)
      && (freg.exponent != FP_REG_EXP_ONES)
      && (freg.significand == U64_0 && !fp_is_natval (freg)) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_qnan(EM_fp_reg_type freg)
{
    if ( (freg.exponent == FP_REG_EXP_ONES)
      &&((freg.significand & U64_0xC000000000000000) == U64_0xC000000000000000) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_snan(EM_fp_reg_type freg)
{
    if ( (freg.exponent == FP_REG_EXP_ONES)
      &&((freg.significand & U64_0xC000000000000000) == U64_0x8000000000000000)
      &&((freg.significand & U64_0x3FFFFFFFFFFFFFFF) != 0) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_unorm(EM_fp_reg_type freg)
{
    if ( ( (freg.exponent != 0)
        && (freg.exponent != FP_REG_EXP_ONES)
        &&((freg.significand & U64_0x8000000000000000) == 0) )
    /* double-extended pseudo-denormal or double-extended denormal */
      || ( (freg.exponent == 0) && (freg.significand != 0) ) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_unorm_dp(EM_fp_dp_type tmp_res)
{
    if ( (tmp_res.exponent != 0)
      && (tmp_res.exponent != FP_DP_EXP_ONES)
      &&((tmp_res.significand.hi & U64_0x8000000000000000) == 0) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_unsupported(EM_fp_reg_type freg)
{    
    if (  fp_is_natval(freg) || fp_is_nan(freg)   || fp_is_inf(freg)
       || fp_is_normal(freg) || fp_is_unorm(freg) || fp_is_zero(freg) ) {
        return(0);
    } else {
        return(1);
    }
}

INLINE EM_boolean_t
fp_is_unsupported_dp(EM_fp_dp_type tmp_res)
{
    if (  fp_is_nan_dp(tmp_res)    || fp_is_inf_dp(tmp_res)
       || fp_is_normal_dp(tmp_res) || fp_is_unorm_dp(tmp_res)
       || fp_is_zero_dp(tmp_res) ) {
        return(0);
    } else {
        return(1);
    }
}

INLINE EM_boolean_t
fp_is_zero(EM_fp_reg_type freg)
{
    if ( (freg.exponent == 0) && (freg.significand == U64_0) ) {
        return(1);
    } else {
        return(0);
    }
}

INLINE EM_boolean_t
fp_is_zero_dp(EM_fp_dp_type tmp_res)
{
    if ( (tmp_res.exponent == 0) && fp_U128_eq(tmp_res.significand, U128_0) ) {
        return(1);
    } else {
        return(0);
    }
}

EM_int_t
fp82_fp_U64_lead0(EM_uint64_t value)
{
EM_int_t tmp_i, offset=0;
EM_uint64_t tmp_mask;

    if( value == U64_0) 
       return(64);

    tmp_mask = U64_0x8000000000000000;

    if( (value & U64_0xFFFFFFFF00000000) != U64_0) {

       if( (value & U64_0xFFFF000000000000) != U64_0) {

         if( (value & U64_0xFF00000000000000) != U64_0) {
            for (tmp_i=0; tmp_i<8; tmp_i++, tmp_mask>>=1) {
               if ( (value & tmp_mask) != U64_0 ) {
                  return(tmp_i);
               }
            }
         }
         else { /* 0x00FF000000000000 */
            value  <<= 8;
            offset  += 8;
            for (tmp_i=0; tmp_i<8; tmp_i++, tmp_mask>>=1) {
               if ( (value & tmp_mask) != U64_0 ) {
                  return(tmp_i + offset);
               }
            }
         }
      } 
      else { /* 0x0000FFFF00000000 */
         value   <<= 16;
         offset   += 16;
         if( (value & U64_0xFF00000000000000) != U64_0) {
            for (tmp_i=0; tmp_i<8; tmp_i++, tmp_mask>>=1) {
               if ( (value & tmp_mask) != U64_0 ) {
                  return(tmp_i + offset);
               }
            }
         }
         else {
            value  <<= 8;
            offset  += 8;
            for (tmp_i=0; tmp_i<8; tmp_i++, tmp_mask>>=1) {
               if ( (value & tmp_mask) != U64_0 ) {
                  return(tmp_i + offset);
               }
            }
         }
      }
   }
   else { /*  0x00000000 FFFFFFFF */
      value  <<= 32;
      offset  += 32;
       if( (value & U64_0xFFFF000000000000) != U64_0) {

         if( (value & U64_0xFF00000000000000) != U64_0) {
            for (tmp_i=0; tmp_i<8; tmp_i++, tmp_mask>>=1) {
               if ( (value & tmp_mask) != U64_0 ) {
                  return(tmp_i + offset);
               }
            }
         }
         else { /* 0x00000000 00FF0000 */
            value  <<= 8;
            offset  += 8;
            for (tmp_i=0; tmp_i<8; tmp_i++, tmp_mask>>=1) {
               if ( (value & tmp_mask) != U64_0 ) {
                  return(tmp_i + offset);
               }
            }
         }
      } 
      else {   /* 0x00000000 0000FFFF */
         value   <<= 16;
         offset   += 16;
         if( (value & U64_0xFF00000000000000) != U64_0) {
            for (tmp_i=0; tmp_i<8; tmp_i++, tmp_mask>>=1) {
               if ( (value & tmp_mask) != U64_0 ) {
                  return(tmp_i + offset);
               }
            }
         }
         else {
            value  <<= 8;
            offset  += 8;
            for (tmp_i=0; tmp_i<8; tmp_i++, tmp_mask>>=1) {
               if ( (value & tmp_mask) != U64_0 ) {
                  return(tmp_i + offset);
               }
            }
         }
      }
   }

   return(64); // MACH ADDED

}

EM_int_t
fp_U128_lead0(EM_uint128_t value)
{
    EM_int_t tmp_i;

    tmp_i = fp_U64_lead0(value.hi);
    if (tmp_i == 64) {
        tmp_i += fp_U64_lead0(value.lo);
    }
    return(tmp_i);
}

EM_int_t
fp82_fp_U256_lead0(EM_uint256_t value)
{
    EM_int_t tmp_i;

    tmp_i = fp_U64_lead0(value.hh);
    if (tmp_i == 64) {
        tmp_i += fp_U64_lead0(value.hl);
        if (tmp_i == 128) {
            tmp_i += fp_U64_lead0(value.lh);
            if (tmp_i == 192) {
                tmp_i += fp_U64_lead0(value.ll);
            }
        }
    }
    return(tmp_i);
}

// *******************************************************************
// fp_mem_to_fr_format()
// *******************************************************************
EM_fp_reg_type
fp_mem_to_fr_format(
    EM_memory_type mem,
    EM_uint_t      size,
    EM_uint_t      integer_form)
{

/******************************************************
integer_form = 0           floating point
integer_form = 1           simd, integer
*******************************************************/

    EM_fp_reg_type tmp_freg;
    EM_uint64_t    tmp_significand, tmp_significand_hi, tmp_significand_lo;

    switch (size) {
        case 4:/* single */
            tmp_freg.sign = mem.fp_single.sign;
            if ( (mem.fp_single.exponent    == 0)
              && (mem.fp_single.significand == 0) ) { /* zero */
                tmp_freg.exponent = 0;
            } else if (mem.fp_single.exponent == 0) { /* denormal */
                tmp_freg.exponent = (EM_uint_t)(FP_REG_BIAS - FP_SGL_BIAS + 1);
            } else if (mem.fp_single.exponent == FP_SGL_EXP_ONES) { /* Inf, NaN, NaTVal */
                tmp_freg.exponent = FP_REG_EXP_ONES;
            } else {
                tmp_freg.exponent = (EM_uint_t)
                                  (((EM_int_t)mem.fp_single.exponent)
                                  - FP_SGL_BIAS + FP_REG_BIAS);
            }
            tmp_freg.significand =
                    (((EM_uint64_t)mem.fp_single.significand)<<40)
#ifdef HPC_BUGS
                    | (((mem.fp_single.exponent != U64_0)?U64_1:U64_0)<<63);
#else
                    | (((mem.fp_single.exponent != 0)?U64_1:U64_0)<<63);
#endif

            break;

        case 8: /* double */
            if (integer_form) {
                tmp_freg.sign = 0;
                tmp_freg.significand = mem.uint_64.uvalue;
                tmp_freg.exponent    = FP_INTEGER_EXP;
            } else {
                tmp_freg.sign = mem.fp_double.sign;
                if ( (mem.fp_double.exponent    == 0)
                  && (mem.fp_double.significand_hi == 0) 
                  && (mem.fp_double.significand_lo == 0) ){    /* zero */
                    tmp_freg.exponent = 0;
                } else if (mem.fp_double.exponent == 0) {     /* denormal */
                     tmp_freg.exponent = (EM_uint_t)(FP_REG_BIAS - FP_DBL_BIAS + 1);
                } else if (mem.fp_double.exponent == FP_DBL_EXP_ONES) { /* Inf, NaN, NaTVal */
                    tmp_freg.exponent = FP_REG_EXP_ONES;
                } else {
                    tmp_freg.exponent = (EM_uint_t)
                                      (((EM_int_t)mem.fp_double.exponent)
                                      - FP_DBL_BIAS + FP_REG_BIAS);
                }
                tmp_significand_lo = ((EM_uint64_t)(mem.fp_double.significand_lo)) ;
                tmp_significand_hi = (((EM_uint64_t)(mem.fp_double.significand_hi)) << 32);
                tmp_significand = tmp_significand_lo | tmp_significand_hi;

                tmp_freg.significand =
                         (tmp_significand<<11)
#ifdef HPC_BUGS
                     | (((mem.fp_double.exponent != U64_0)?U64_1:U64_0)<<63);
#else
                     | (((mem.fp_double.exponent != 0)?U64_1:U64_0)<<63);
#endif
            }
            break;

        case 10: /* double extended */
            tmp_freg.sign = mem.fp_double_extended.sign;
            if (mem.fp_double_extended.exponent == 0) {
                    /* Zero or (Pseudo-)Denormal */
                tmp_freg.exponent = 0;
            } else if (mem.fp_double_extended.exponent == FP_EXT_EXP_ONES) {
                    /* Inf, NaN, NaTVal */
                tmp_freg.exponent = FP_REG_EXP_ONES;
            } else { /* Normal */
                tmp_freg.exponent = (EM_uint_t)
                                  (((EM_int_t)mem.fp_double_extended.exponent)
                                  - FP_EXT_BIAS + FP_REG_BIAS);
            }
	    memcpy(&tmp_freg.significand,
		    mem.fp_double_extended.significand, 8);
            break;

        case 16: /* fill */
            tmp_freg.sign        = mem.fp_spill_fill.sign;
            tmp_freg.exponent    = mem.fp_spill_fill.exponent;
            tmp_freg.significand = mem.fp_spill_fill.significand;
            break;
    }
    return (tmp_freg);
}


INLINE EM_fp_reg_type
fp_make_quiet_nan(EM_fp_reg_type freg)
{
    freg.significand |= U64_0x4000000000000000;
    return (freg);
}



EM_boolean_t
fp82_fp_raise_fault(EM_tmp_fp_env_type tmp_fp_env)
{
    if(tmp_fp_env.simd == 1) {
         if  (tmp_fp_env.lo_faults.swa || tmp_fp_env.lo_faults.v
         ||   tmp_fp_env.lo_faults.d   || tmp_fp_env.lo_faults.z 

         ||   tmp_fp_env.hi_faults.swa || tmp_fp_env.hi_faults.v 
         ||   tmp_fp_env.hi_faults.d   || tmp_fp_env.hi_faults.z )

          return(1);
    } else if ( tmp_fp_env.em_faults.swa || tmp_fp_env.em_faults.v
         ||   tmp_fp_env.em_faults.d   || tmp_fp_env.em_faults.z )
          return (1);
    return (0);
}


EM_boolean_t
fp82_fp_raise_traps(EM_tmp_fp_env_type tmp_fp_env)
{
    if(tmp_fp_env.simd == 1) {
       if   (tmp_fp_env.hi_traps.o || tmp_fp_env.hi_traps.un || tmp_fp_env.hi_traps.i
       ||    tmp_fp_env.lo_traps.o || tmp_fp_env.lo_traps.un || tmp_fp_env.lo_traps.i) // MACH
        return (1);
    } else if (tmp_fp_env.em_traps.o || tmp_fp_env.em_traps.un || tmp_fp_env.em_traps.i) // MACH
        return (1);
    return (0);
}


INLINE EM_fp_reg_type
fp_reg_read(EM_fp_reg_type freg)
{
    EM_fp_reg_type tmp_freg;
    tmp_freg = freg;
 /* insert true register file exponent for double-extended (pseudo-)denormal */
    if ((tmp_freg.exponent == 0) && (tmp_freg.significand != U64_0))
        tmp_freg.exponent=0x0C001;
    return (tmp_freg);
}



// *******************************************************************
// fp_update_fpsr()
// *******************************************************************
INLINE void
fp_update_fpsr(
    EM_opcode_sf_type  sf,
    EM_tmp_fp_env_type tmp_fp_env )
{
    if (sf == sf_none) {
        return;
    }
    else if (sf == sfS0) {

/*******************************************************************
SF0
*******************************************************************/
       if(tmp_fp_env.simd == 1) {

/* SF0 simd fault: if either hi or low is set, set the s0 flag */
         if (tmp_fp_env.hi_flags.v || tmp_fp_env.lo_flags.v) {
            SET_STATUS_FLAG(FPSR.sf0_flags_v);
         }
         if (tmp_fp_env.hi_flags.d || tmp_fp_env.lo_flags.d) {
            SET_STATUS_FLAG(FPSR.sf0_flags_d);
         }
         if (tmp_fp_env.hi_flags.z || tmp_fp_env.lo_flags.z) {
            SET_STATUS_FLAG(FPSR.sf0_flags_z);
         }

/* SF0 simd trap: if either hi or low is set, set the s0 flag 
if the flag is over or underflow, also set inexact  */
         if (tmp_fp_env.hi_flags.o || tmp_fp_env.lo_flags.o) {
            SET_STATUS_FLAG(FPSR.sf0_flags_o);
         }
         if (tmp_fp_env.hi_flags.un || tmp_fp_env.lo_flags.un) { // MACH
            SET_STATUS_FLAG(FPSR.sf0_flags_u);
         }
         if (tmp_fp_env.hi_flags.i || tmp_fp_env.lo_flags.i) {
            SET_STATUS_FLAG(FPSR.sf0_flags_i);
         }
      } /* end of simd */

      else { /* not simd */

/* SF0 non-simd fault: if tmp flag is set and s0 flag is not, set the flag */
         if (tmp_fp_env.flags.v) {
            SET_STATUS_FLAG(FPSR.sf0_flags_v);
         }
         if (tmp_fp_env.flags.d) {
// printf ("MACH DEBUG: setting the D flag in update_fpsr ()\n");
            SET_STATUS_FLAG(FPSR.sf0_flags_d);
         }
         if (tmp_fp_env.flags.z) {
            SET_STATUS_FLAG(FPSR.sf0_flags_z);
         }
   
/* SF0 non-simd trap: if tmp flag is set, set the flag.
if the flag is over or underflow, also check inexact  */
         if (tmp_fp_env.flags.o) {
            SET_STATUS_FLAG(FPSR.sf0_flags_o);
            if ( tmp_fp_env.flags.i) {
               SET_STATUS_FLAG(FPSR.sf0_flags_i);
            }
          }
          else if (tmp_fp_env.flags.un) { // MACH
             SET_STATUS_FLAG(FPSR.sf0_flags_u);
             if ( tmp_fp_env.flags.i )  {
                SET_STATUS_FLAG(FPSR.sf0_flags_i);
             }
          }
          else if (tmp_fp_env.flags.i) {
             SET_STATUS_FLAG(FPSR.sf0_flags_i);
          }
       } /* end of not simd */
    } /* end of SF0 */

/*******************************************************************
SF1
*******************************************************************/
    else if (sf == sfS1) {
        if(tmp_fp_env.simd == 1) {

/* SF1 simd fault: if either hi or low is set, set the s1 flag
*/
           if (tmp_fp_env.hi_flags.v || tmp_fp_env.lo_flags.v) {
              SET_STATUS_FLAG(FPSR.sf1_flags_v);
           }
           if (tmp_fp_env.hi_flags.d || tmp_fp_env.lo_flags.d) {
              SET_STATUS_FLAG(FPSR.sf1_flags_d);
           }
           if (tmp_fp_env.hi_flags.z || tmp_fp_env.lo_flags.z) {
              SET_STATUS_FLAG(FPSR.sf1_flags_z);
           }

/* SF1 simd trap: if either hi or low is set and the s1 flag is not, set the s1 flag 
If the flag is over or underflow, also check inexact  */
           if (tmp_fp_env.hi_flags.o || tmp_fp_env.lo_flags.o) {
              SET_STATUS_FLAG(FPSR.sf1_flags_o);
           }
           if (tmp_fp_env.hi_flags.un || tmp_fp_env.lo_flags.un) { // MACH
              SET_STATUS_FLAG(FPSR.sf1_flags_u);
           }
           if (tmp_fp_env.hi_flags.i || tmp_fp_env.lo_flags.i) {
                SET_STATUS_FLAG(FPSR.sf1_flags_i);
            }
        } /* end of simd SF1 */

        else { /* not simd SF1 */

/* SF1 non-simd fault: if tmp flag is set and s1 flag is not, set the flag 
*/
           if (tmp_fp_env.flags.v ) {
              SET_STATUS_FLAG(FPSR.sf1_flags_v);
           }
           if (tmp_fp_env.flags.d ) {
              SET_STATUS_FLAG(FPSR.sf1_flags_d);
           }
           if (tmp_fp_env.flags.z ) {
              SET_STATUS_FLAG(FPSR.sf1_flags_z);
           }
    
/* SF1 non-simd traps: if tmp flag is set and s1 flag is not, set the flag.
if the flag is over or underflow, also check inexact  */
           if ( tmp_fp_env.flags.o ) {
              SET_STATUS_FLAG(FPSR.sf1_flags_o);
              if ( tmp_fp_env.flags.i ) {
                 SET_STATUS_FLAG(FPSR.sf1_flags_i);
              }
           }
           else if (tmp_fp_env.flags.un ) { // MACH
              SET_STATUS_FLAG(FPSR.sf1_flags_u);
              if ( tmp_fp_env.flags.i ) {
                 SET_STATUS_FLAG(FPSR.sf1_flags_i);
              }
           }
           else if (tmp_fp_env.flags.i ) {
              SET_STATUS_FLAG(FPSR.sf1_flags_i);
           }
        } /*end of not simd  SF1 */
      } /* end of SF1 */

/*******************************************************************
SF2
*******************************************************************/
      else if (sf == sfS2) {
         if(tmp_fp_env.simd == 1) {

/* SF2 simd fault: if either hi or low is set and the s2 flag is not, set the s2 flag
*/
            if (tmp_fp_env.hi_flags.v || tmp_fp_env.lo_flags.v) {
               SET_STATUS_FLAG(FPSR.sf2_flags_v);
            }
            if (tmp_fp_env.hi_flags.d || tmp_fp_env.lo_flags.d) {
               SET_STATUS_FLAG(FPSR.sf2_flags_d);
            }
            if (tmp_fp_env.hi_flags.z || tmp_fp_env.lo_flags.z) {
               SET_STATUS_FLAG(FPSR.sf2_flags_z);
            }

/* SF2 simd trap: if either hi or low is set and the s2 flag is not, set the s2 flag 
If the flag is over or underflow, also check inexact  */
            if (tmp_fp_env.hi_flags.o || tmp_fp_env.lo_flags.o) {
                SET_STATUS_FLAG(FPSR.sf2_flags_o);
            }
            if (tmp_fp_env.hi_flags.un || tmp_fp_env.lo_flags.un) { // MACH
               SET_STATUS_FLAG(FPSR.sf2_flags_u);
            }
            if (tmp_fp_env.hi_flags.i || tmp_fp_env.lo_flags.i) {
                SET_STATUS_FLAG(FPSR.sf2_flags_i);
            }
         } /* end of simd SF2 */

         else { /* not simd SF2 */

/* SF2 non-simd fault: if tmp flag is set and s2 flag is not, set the flag 
*/
            if (tmp_fp_env.flags.v ) {
               SET_STATUS_FLAG(FPSR.sf2_flags_v);
            }
            if (tmp_fp_env.flags.d ) {
               SET_STATUS_FLAG(FPSR.sf2_flags_d);
            }
            if (tmp_fp_env.flags.z ) {
               SET_STATUS_FLAG(FPSR.sf2_flags_z);
            }

/* SF2 non-simd traps: if tmp flag is set and s2 flag is not, set the flag.
if the flag is over or underflow, also check inexact  */
            if ( tmp_fp_env.flags.o ) {
               SET_STATUS_FLAG(FPSR.sf2_flags_o);
               if ( tmp_fp_env.flags.i ) {
                  SET_STATUS_FLAG(FPSR.sf2_flags_i);
               }
            }
            else if (tmp_fp_env.flags.un ) { // MACH
               SET_STATUS_FLAG(FPSR.sf2_flags_u);
               if ( tmp_fp_env.flags.i ) {
                    SET_STATUS_FLAG(FPSR.sf2_flags_i);
               }
            }
            else if (tmp_fp_env.flags.i ) {
               SET_STATUS_FLAG(FPSR.sf2_flags_i);
            }
       } /* end of not simd SF2 */
    } /* end of SF2 */

/*******************************************************************
SF3
*******************************************************************/
    else if (sf == sfS3) {
       if(tmp_fp_env.simd == 1) {

/* SF3 simd fault: if either hi or low is set and the s3 flag is not, set the s3 flag
*/
          if (tmp_fp_env.hi_flags.v || tmp_fp_env.lo_flags.v) {
             SET_STATUS_FLAG(FPSR.sf3_flags_v);
          }
          if (tmp_fp_env.hi_flags.d || tmp_fp_env.lo_flags.d) {
             SET_STATUS_FLAG(FPSR.sf3_flags_d);
          }
          if (tmp_fp_env.hi_flags.z || tmp_fp_env.lo_flags.z) {
             SET_STATUS_FLAG(FPSR.sf3_flags_z);
          }

/* SF3 simd trap: if either hi or low is set and the s3 flag is not, set the s3 flag 
If the flag is over or underflow, also check inexact  */
          if (tmp_fp_env.hi_flags.o || tmp_fp_env.lo_flags.o) {
             SET_STATUS_FLAG(FPSR.sf3_flags_o);
          }
          if (tmp_fp_env.hi_flags.un || tmp_fp_env.lo_flags.un) { // MACH
             SET_STATUS_FLAG(FPSR.sf3_flags_u);
          }
          if (tmp_fp_env.hi_flags.i || tmp_fp_env.lo_flags.i) {
             SET_STATUS_FLAG(FPSR.sf3_flags_i);
          }
       } /* end of simd SF3 */

       else { /* not simd SF3 */

/* SF3 non-simd fault: if tmp flag is set and s3 flag is not, set the flag 
 */
          if (tmp_fp_env.flags.v ) {
             SET_STATUS_FLAG(FPSR.sf3_flags_v);
          }
          if (tmp_fp_env.flags.d ) {
             SET_STATUS_FLAG(FPSR.sf3_flags_d);
          }
          if (tmp_fp_env.flags.z ) {
             SET_STATUS_FLAG(FPSR.sf3_flags_z);
          }
    
/* SF3 non-simd traps: if tmp flag is set and s3 flag is not, set the flag.
if the flag is over or underflow, also check inexact  */
          if ( tmp_fp_env.flags.o ) {
             SET_STATUS_FLAG(FPSR.sf3_flags_o);
             if ( tmp_fp_env.flags.i ) {
                SET_STATUS_FLAG(FPSR.sf3_flags_i);
             }
          }
          else if (tmp_fp_env.flags.un ) { // MACH
             SET_STATUS_FLAG(FPSR.sf3_flags_u);
             if ( tmp_fp_env.flags.i ) {
                SET_STATUS_FLAG(FPSR.sf3_flags_i);
             }
          }
          else if (tmp_fp_env.flags.i ) {
             SET_STATUS_FLAG(FPSR.sf3_flags_i);
          }
       } /* end of not simd SF3 */
    } /* end of SF3 */
} /* end of fp_update_fpsr */

INLINE void
fp_update_psr(EM_uint_t dest_freg)
{
EM_uint_t disabled_limit = 31;

    if ( (dest_freg >= 2) && (dest_freg <= disabled_limit) ){
        SET_STATUS_FLAG(PSR.mfl);
    }
    else if ( (dest_freg > disabled_limit) ) {
        SET_STATUS_FLAG(PSR.mfh);
    }
}


/* EM_int64_t, EM_uint64_t, EM_uint128_t and EM_uint256_t support routines */

/* 128-bit unsigned int support routines */

EM_boolean_t
fp82_fp_U128_eq(EM_uint128_t value1, EM_uint128_t value2)
{
    if ( (value1.hi == value2.hi)
      && (value1.lo == value2.lo) )
        return (1);
    else
        return (0);
}

static INLINE EM_boolean_t
fp_U128_ge(EM_uint128_t value1, EM_uint128_t value2)
{
    if (value1.hi >  value2.hi)
        return (1);
    else if ( (value1.hi == value2.hi)
           && (value1.lo >= value2.lo) )
        return (1);
    else
        return (0);
}

static INLINE EM_boolean_t
fp_U128_gt(EM_uint128_t value1, EM_uint128_t value2)
{
    if (value1.hi > value2.hi)
        return (1);
    else if ( (value1.hi == value2.hi)
           && (value1.lo >  value2.lo) )
        return (1);
    else
        return (0);
}

static INLINE EM_boolean_t
fp_U128_le(EM_uint128_t value1, EM_uint128_t value2)
{
    if (value1.hi <  value2.hi)
        return (1);
    else if ( (value1.hi == value2.hi)
           && (value1.lo <= value2.lo) )
        return (1);
    else
        return (0);
}

EM_boolean_t
fp82_fp_U128_lt(EM_uint128_t value1, EM_uint128_t value2)
{
    if (value1.hi < value2.hi)
        return (1);
    else if ( (value1.hi == value2.hi)
           && (value1.lo <  value2.lo) )
        return (1);
    else
        return (0);
}

EM_uint128_t
fp82_fp_U128_lsh(EM_uint128_t value, EM_uint_t count)
{
EM_uint128_t tmp;

    if (count == 0) {
        return(value);
    } else if (count >= 128) {
        return (U128_0);

    } else if (count >  64) {
        tmp.lo  = U64_0;
        tmp.hi = (value.lo<<(count-64));
        return (tmp);
    } else if (count == 64) {
        tmp.lo  = U64_0;
        tmp.hi = value.lo;
        return (tmp);
    } else if (count >  0) {
        tmp.lo = (value.lo<<count);
        tmp.hi = (value.hi<<count) | (value.lo>>(64-count)) ;
        return (tmp);
    }
   return(value); // MACH ADDED
}

EM_uint128_t
fp82_fp_U128_rsh(EM_uint128_t value, EM_uint_t count)
{
EM_uint128_t tmp;

    if (count == 0) {
        return (value);
    } else if (count >= 128) {
        return (U128_0);

    } else if (count > 64) {
        tmp.lo = (value.hi>>(count-64));
        tmp.hi  = U64_0;
        return (tmp);
    } else if (count == 64) {
        tmp.lo = value.hi;
        tmp.hi  = U64_0;
        return (tmp);
    } else if (count >  0) {
        tmp.lo = (value.lo>>count) | (value.hi<<(64-count));
        tmp.hi = (value.hi>>count);
        return (tmp);
    } 
    return(U128_0); // MACH ADDED
}

EM_uint128_t
fp82_fp_U64_x_U64_to_U128(EM_uint64_t value1, EM_uint64_t value2)
{
    EM_uint128_t tmp_res;
    EM_uint64_t r0, s0, t0;
    EM_uint64_t r1, s1, t1;

    s0 = (value1<<32)>>32;
    s1 = (value1>>32);

    t0 = (value2<<32)>>32;
    t1 = (value2>>32);

#ifdef HPC_BUGS
    s0 = ((EM_uint64_t)( ( ( ((EM_int64_t)s0) << 32 ) >> 32 ) ));
    s1 = ((EM_uint64_t)( ( ( ((EM_int64_t)s1) << 32 ) >> 32 ) ));
    t0 = ((EM_uint64_t)( ( ( ((EM_int64_t)t0) << 32 ) >> 32 ) ));
    t1 = ((EM_uint64_t)( ( ( ((EM_int64_t)t1) << 32 ) >> 32 ) ));
#endif

    tmp_res.lo = s0 * t0;

#ifdef HPC_BUGS
    if(s0 & U64_0x0000000080000000)
        tmp_res.lo += t0<<32;
    if(t0 & U64_0x0000000080000000)
        tmp_res.lo += s0<<32;
#endif


    r0 = s0 * t1;

#ifdef HPC_BUGS
    if(s0 & U64_0x0000000080000000)
        r0 += t1<<32;
    if(t1 & U64_0x0000000080000000)
        r0 += s0<<32;
#endif


    r1 = s1 * t0;

#ifdef HPC_BUGS
    if(s1 & U64_0x0000000080000000)
        r1 += t0<<32;
    if(t0 & U64_0x0000000080000000)
        r1 += s1<<32;
#endif


    tmp_res.hi = s1 * t1;

#ifdef HPC_BUGS
    if(s1 & U64_0x0000000080000000)
        tmp_res.hi += t1<<32;
    if(t1 & U64_0x0000000080000000)
        tmp_res.hi += s1<<32;
#endif


    if ( (tmp_res.lo + (r0<<32)) < tmp_res.lo)
        tmp_res.hi++;

    tmp_res.lo += (r0<<32);

    if ( (tmp_res.lo + (r1<<32)) < tmp_res.lo)
        tmp_res.hi++;

    tmp_res.lo += (r1<<32);
    tmp_res.hi += (r0>>32);
    tmp_res.hi += (r1>>32);

    return (tmp_res);
}

INLINE EM_uint128_t
fp_I64_x_I64_to_I128(EM_uint64_t value1, EM_uint64_t value2)
{
    EM_uint128_t tmp_res;
    EM_uint128_t scratch;

    tmp_res = fp_U64_x_U64_to_U128(value1, value2);

    if (value1 & U64_0x8000000000000000) {
        scratch = fp_U64_to_U128(value2);
        scratch = fp_U128_lsh(scratch,64);
        scratch = fp_U128_neg(scratch);
        tmp_res = fp_U128_add(scratch, tmp_res);
    } 

    if (value2 & U64_0x8000000000000000) {
        scratch = fp_U64_to_U128(value1);
        scratch = fp_U128_lsh(scratch,64);
        scratch = fp_U128_neg(scratch);
        tmp_res = fp_U128_add(scratch, tmp_res);
    } 

    return (tmp_res);
}

EM_uint128_t
fp82_fp_U128_inc(EM_uint128_t value)
{
    EM_uint128_t tmp;
            /* add one */
    tmp.lo = value.lo + 1;
    tmp.hi = value.hi + (tmp.lo < value.lo);

    return (tmp);
}

static INLINE EM_uint128_t
fp_U128_neg(EM_uint128_t value)
{
    EM_uint128_t tmp;

            /* complement */
    value.lo = ~value.lo;
    value.hi = ~value.hi;
            /* add one */
    tmp.lo = value.lo + 1;
    tmp.hi = value.hi + (tmp.lo < value.lo);
    return (tmp);
}

EM_uint128_t
fp82_fp_U128_add(EM_uint128_t value1,
                 EM_uint128_t value2)
{
    EM_uint128_t tmp;

        /* sum  */
    value2.lo = value1.lo + value2.lo;
    value2.hi = value1.hi + value2.hi;
        /* carry */
    tmp.lo = 0;
    tmp.hi = (value2.lo < value1.lo);

        /* carry propagate adder */
    tmp.lo =  value2.lo;
    tmp.hi += value2.hi;
    return (tmp);
}

EM_uint128_t
fp82_fp_U128_bor(EM_uint128_t value1, EM_uint128_t value2)
{
    EM_uint128_t tmp_res;
    tmp_res.lo = value1.lo | value2.lo;
    tmp_res.hi = value1.hi | value2.hi;
    return (tmp_res);
}

EM_uint128_t
fp82_fp_U128_band(EM_uint128_t value1, EM_uint128_t value2)
{
    EM_uint128_t tmp_res;
    tmp_res.lo = value1.lo & value2.lo;
    tmp_res.hi = value1.hi & value2.hi;
    return (tmp_res);
}

/* 256-bit unsigned int support routines */

EM_boolean_t
fp82_fp_U256_eq(EM_uint256_t value1, EM_uint256_t value2)
{
    if ( (value1.hh == value2.hh)
      && (value1.hl == value2.hl )
      && (value1.lh == value2.lh )
      && (value1.ll == value2.ll ) )
        return (1);
    else
        return (0);
}


EM_uint256_t
fp82_fp_U256_lsh(EM_uint256_t value, EM_uint_t count)
{
EM_uint256_t tmp;
    if (count == 0) {
        return (value);
    } else if (count >= 256) {
        return (U256_0);

    } else if (count >  192) {
        tmp.ll  = U64_0;
        tmp.lh  = U64_0;
        tmp.hl  = U64_0;
        tmp.hh = (value.ll<<(count-192));
        return (tmp);
    } else if (count == 192) {
        tmp.ll  = U64_0;
        tmp.lh  = U64_0;
        tmp.hl  = U64_0;
        tmp.hh = value.ll;
        return (tmp);
    } else if (count >  128) {
        tmp.ll  = U64_0;
        tmp.lh  = U64_0;
        tmp.hl = (value.ll<<(count-128));
        tmp.hh = (value.lh<<(count-128)) | (value.ll>>(192-count));
        return (tmp);
    } else if (count == 128) {
        tmp.ll  = U64_0;
        tmp.lh  = U64_0;
        tmp.hl = value.ll;
        tmp.hh = value.lh;
        return (tmp);
    } else if (count >  64) {
        tmp.ll  = U64_0;
        tmp.lh = (value.ll<<(count-64));
        tmp.hl = (value.lh<<(count-64)) | (value.ll>>(128-count)) ;
        tmp.hh = (value.hl<<(count-64)) | (value.lh>>(128-count)) ;
        return (tmp);
    } else if (count == 64) {
        tmp.ll = 0;
        tmp.lh = value.ll;
        tmp.hl = value.lh;
        tmp.hh = value.hl;
        return (tmp);
    } else if (count >  0) {
        tmp.ll = (value.ll<<count);
        tmp.lh = (value.lh<<count) | (value.ll>>(64-count)) ;
        tmp.hl = (value.hl<<count) | (value.lh>>(64-count)) ;
        tmp.hh = (value.hh<<(count)) | (value.hl>>(64-count)) ;
        return (tmp);
    } 
    return(U256_0); // MACH ADDED

}

EM_uint256_t
fp82_fp_U256_rsh(EM_uint256_t value, EM_uint_t count)
{
EM_uint256_t tmp;
    if (count == 0) {
        return (value);
    } else if (count >= 256) {
        return (U256_0);

    } else if (count >  192) {
        tmp.ll = (value.hh>>(count-192));
        tmp.lh  = U64_0;
        tmp.hl  = U64_0;
        tmp.hh  = U64_0;
        return (tmp);
    } else if (count == 192) {
        tmp.ll = value.hh;
        tmp.lh  = U64_0;
        tmp.hl  = U64_0;
        tmp.hh  = U64_0;
        return (tmp);
    } else if (count >  128) {
        tmp.ll = (value.hl>>(count-128)) | (value.hh<<(192-count));
        tmp.lh = (value.hh>>(count-128));
        tmp.hl  = U64_0;
        tmp.hh  = U64_0;
        return (tmp);
    } else if (count == 128) {
        tmp.ll = value.hl;
        tmp.lh = value.hh;
        tmp.hl  = U64_0;
        tmp.hh  = U64_0;
        return (tmp);
    } else if (count >  64) {
        tmp.ll = (value.lh>>(count-64)) | (value.hl<<(128-count));
        tmp.lh = (value.hl>>(count-64)) | (value.hh<<(128-count));
        tmp.hl = (value.hh>>(count-64));
        tmp.hh  = U64_0;
        return (tmp);
    } else if (count == 64) {
        tmp.ll = value.lh;
        tmp.lh = value.hl;
        tmp.hl = value.hh;
        tmp.hh  = U64_0;
        return (tmp);
    } else if (count >  0) {
        tmp.ll = (value.ll>>count) | (value.lh<<(64-count));
        tmp.lh = (value.lh>>count) | (value.hl<<(64-count));
        tmp.hl = (value.hl>>count) | (value.hh<<(64-count));
        tmp.hh = (value.hh>>count);
        return (tmp);
    } 
    return(U256_0); // MACH ADDED

}

EM_uint256_t
fp82_fp_U256_inc(EM_uint256_t value)
{
    EM_uint256_t tmp;

            /* add one */
    tmp.ll = value.ll + 1;
    tmp.lh = value.lh + (tmp.ll < value.ll);
    tmp.hl = value.hl + (tmp.lh < value.lh);
    tmp.hh = value.hh + (tmp.hl < value.hl);
    return (tmp);
}

static INLINE EM_uint256_t
fp_U256_neg(EM_uint256_t value)
{
    EM_uint256_t tmp;

            /* complement */
    value.ll = ~value.ll;
    value.lh = ~value.lh;
    value.hl = ~value.hl;
    value.hh = ~value.hh;
            /* add one */
    tmp.ll = value.ll + 1;
    tmp.lh = value.lh + (tmp.ll < value.ll);
    tmp.hl = value.hl + (tmp.lh < value.lh);
    tmp.hh = value.hh + (tmp.hl < value.hl);
    return (tmp);
}

static INLINE EM_uint256_t
fp_U256_add(EM_uint256_t value1, EM_uint256_t value2)
{
    EM_uint256_t tmp;

        /* sum  */
    value2.ll = value1.ll + value2.ll;
    value2.lh = value1.lh + value2.lh;
    value2.hl = value1.hl + value2.hl;
    value2.hh = value1.hh + value2.hh;
        /* carry */
    tmp.ll = 0;
    tmp.lh = (value2.ll < value1.ll);
    tmp.hl = (value2.lh < value1.lh);
    tmp.hh = (value2.hl < value1.hl);
/*  c_out  = (value2.hh < value1.hh); */
        /* carry propagate adder */
    tmp.ll =  value2.ll;
    tmp.lh += value2.lh;
    tmp.hl += value2.hl + (tmp.lh < value2.lh);
    tmp.hh += value2.hh + (tmp.hl < value2.hl);
/*  c_out  +=             (tmp.hh < value2.hh); */
    return (tmp);
}

/* Basic Conversion Routines */

INLINE EM_uint128_t
fp_U64_to_U128(EM_uint64_t value)
{
    EM_uint128_t tmp;
    tmp.lo = value;
    tmp.hi = U64_0;
    return (tmp);
}

INLINE EM_uint64_t
fp_U128_to_U64(EM_uint128_t value)
{
    EM_uint64_t tmp;
    tmp = value.lo;
    return (tmp);
}

static INLINE EM_uint256_t
fp_U64_to_U256(EM_uint64_t value)
{
    EM_uint256_t tmp;
    tmp.ll = value;
    tmp.lh = U64_0;
    tmp.hl = U64_0;
    tmp.hh = U64_0;
    return (tmp);
}

static INLINE EM_uint64_t
fp_U256_to_U64(EM_uint256_t value)
{
    EM_uint64_t tmp;
    tmp = value.ll;
    return (tmp);
}

EM_uint256_t
fp82_fp_U128_to_U256(EM_uint128_t value)
{
    EM_uint256_t tmp;
    tmp.ll = value.lo;
    tmp.lh = value.hi;
    tmp.hl  = U64_0;
    tmp.hh  = U64_0;
    return (tmp);
}

static INLINE EM_uint128_t
fp_U256_to_U128(EM_uint256_t value)
{
    EM_uint128_t tmp;
    tmp.lo = value.ll;
    tmp.hi = value.lh;
    return (tmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\feinstr.c ===
// ******************************
// Intel Confidential
// ******************************

// ******************************
// asm mappings to instructions 
// ******************************

// MACH
#include "ki.h"

#ifndef _STDIO_H
#include <stdio.h>
#endif

#include "fepublic.h"
#include "fehelper.h"
#include "festate.h"
#include "feinstr.h"


// ******************************************************************
// Public functions
// ******************************************************************

// ******************************************************************
// fma: Floating point multiply add
// ******************************************************************
void
fp82_fma(EM_state_type *ps,
    EM_opcode_pc_type     pc,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f3,
    EM_fp_reg_specifier   f4,
    EM_fp_reg_specifier   f2)
{
    GETSTATE_F1(qp,f1,f3,f4,f2);
    _fma(ps, pc, sf, qp, f1, f3, f4, f2);
    PUTSTATE_F1(f1);
}


// ******************************************************************
// fpma: Floating point parallel multiply add
// ******************************************************************
void
fp82_fpma(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f3,
    EM_fp_reg_specifier   f4,
    EM_fp_reg_specifier   f2)
{
    GETSTATE_F1(qp,f1,f3,f4,f2);
    _fpma(ps, sf, qp, f1, f3, f4, f2);
    PUTSTATE_F1(f1);
}

// ******************************************************************
// Floating-point Multiply Subtract 
// ******************************************************************
void
fp82_fms(EM_state_type *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
    EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2)
{
    GETSTATE_F1(qp,f1,f3,f4,f2);
    _fms(ps, pc, sf, qp, f1, f3, f4, f2);
    PUTSTATE_F1(f1);
}


// ******************************************************************
// Floating-point Parallel Multiply Subtract 
// ******************************************************************
void
fp82_fpms(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
    EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2)
{
    GETSTATE_F1(qp,f1,f3,f4,f2);
    _fpms(ps, sf, qp, f1, f3, f4, f2);
    PUTSTATE_F1(f1);
}


// ******************************************************************
// Floating-point Negative Multiply Add 
// ******************************************************************
void
fp82_fnma(EM_state_type *ps,
    EM_opcode_pc_type     pc,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f3,
    EM_fp_reg_specifier   f4,
    EM_fp_reg_specifier   f2)
{
    GETSTATE_F1(qp,f1,f3,f4,f2);
    _fnma(ps, pc, sf, qp, f1, f3, f4, f2);
    PUTSTATE_F1(f1);
}

// ******************************************************************
// Floating-point Parallel Negative Multiply Add 
// ******************************************************************
void
fp82_fpnma(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f3,
    EM_fp_reg_specifier   f4,
    EM_fp_reg_specifier   f2)
{
    GETSTATE_F1(qp,f1,f3,f4,f2);
    _fpnma(ps, sf, qp, f1, f3, f4, f2);
    PUTSTATE_F1(f1);
}


// ******************************************************************
// Floating-point Compare 
// ******************************************************************
void
fp82_fcmp_eq(EM_state_type         *ps,
    EM_opcode_ctype_type  fctype,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_pred_reg_specifier p1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F4(qp,p1,p2,f2,f3);
    _fcmp(ps, frelEQ, fctype, sf, (EM_uint_t)qp,
        (EM_uint_t)p1, (EM_uint_t)p2, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F4(p1,p2);
}

void
fp82_fcmp_lt(EM_state_type *ps,
    EM_opcode_ctype_type  fctype,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_pred_reg_specifier p1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F4(qp,p1,p2,f2,f3);
    _fcmp(ps, frelLT, fctype, sf, (EM_uint_t)qp,
        (EM_uint_t)p1, (EM_uint_t)p2, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F4(p1,p2);
}

void
fp82_fcmp_le(EM_state_type *ps,
    EM_opcode_ctype_type  fctype,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_pred_reg_specifier p1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F4(qp,p1,p2,f2,f3);
    _fcmp(ps, frelLE, fctype, sf, (EM_uint_t)qp,
        (EM_uint_t)p1, (EM_uint_t)p2, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F4(p1,p2);
}

void
fp82_fcmp_unord(EM_state_type *ps,
    EM_opcode_ctype_type  fctype,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_pred_reg_specifier p1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F4(qp,p1,p2,f2,f3);
    _fcmp(ps, frelUNORD, fctype, sf, (EM_uint_t)qp,
    (EM_uint_t)p1, (EM_uint_t)p2, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F4(p1,p2);
}


// ******************************************************************
// Floating-point Reciprocal Approximation 
// ******************************************************************
void
fp82_frcpa(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F6(qp,f1,p2,f2,f3);
    _frcpa(ps, sf, qp, f1, p2, f2, f3);
    PUTSTATE_F6(f1,p2);
}

// ******************************************************************
// Floating-point Parallel Reciprocal Approximation 
// ******************************************************************
void
fp82_fprcpa(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F6(qp,f1,p2,f2,f3);
    _fprcpa(ps, sf, qp, f1, p2, f2, f3);
    PUTSTATE_F6(f1,p2);
}


// ******************************************************************
// Floating-point Reciprocal Square Root Approximation 
// ******************************************************************

void
fp82_frsqrta(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F7(qp,f1,p2,f3);
    _frsqrta(ps, sf, qp, f1, p2, f3);
    PUTSTATE_F7(f1,p2);
}

// ******************************************************************
// Floating-point Parallel Reciprocal Square Root Approximation 
// ******************************************************************
void
fp82_fprsqrta(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F7(qp,f1,p2,f3);
    _fprsqrta(ps, sf, qp, f1, p2, f3);
    PUTSTATE_F7(f1,p2);
}

// ******************************************************************
// Floating-point Minimum 
// ******************************************************************
void
fp82_fmin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fmin(ps, sf, qp, f1, f2, f3);
    PUTSTATE_F8(f1);
}

// ******************************************************************
// Floating-point Maximum 
// ******************************************************************
void
fp82_fmax(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fmax(ps, sf, qp, f1, f2, f3);
    PUTSTATE_F8(f1);
}

// ******************************************************************
// Floating-point Absolute Minimum 
// ******************************************************************
void
fp82_famin(EM_state_type         *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _famin(ps, sf, (EM_uint_t)qp, (EM_uint_t)f1, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F8(f1);
}

// ******************************************************************
// Floating-point Absolute Maximum 
// ******************************************************************
void
fp82_famax(EM_state_type         *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _famax(ps, sf, (EM_uint_t)qp, (EM_uint_t)f1, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F8(f1);
}


// ******************************************************************
// Floating-point Parallel Minimum 
// ******************************************************************
void
fp82_fpmin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fpmin(ps, sf, qp, f1, f2, f3);
    PUTSTATE_F8(f1);
}


// ******************************************************************
// Floating-point Parallel Maximum 
// ******************************************************************
void
fp82_fpmax(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fpmax(ps, sf, qp, f1, f2, f3);
    PUTSTATE_F8(f1);
}

// ******************************************************************
// Floating-point Parallel Absolute Minimum 
// ******************************************************************
void
fp82_fpamin(EM_state_type         *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fpamin(ps, sf, (EM_uint_t)qp, (EM_uint_t)f1, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F8(f1);
}


// ******************************************************************
// Floating-point Parallel Absolute Maximum 
// ******************************************************************
void
fp82_fpamax(EM_state_type         *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fpamax(ps, sf, (EM_uint_t)qp, (EM_uint_t)f1, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F8(f1);
}


// ******************************************************************
// Floating-point Parallel Compare 
// ******************************************************************
void
fp82_fpcmp_eq(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fpcmp(ps, frelEQ, sf, (EM_uint_t)qp,
          (EM_uint_t)f1, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F8(f1);
}


void
fp82_fpcmp_lt(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fpcmp(ps, frelLT, sf, (EM_uint_t)qp,
          (EM_uint_t)f1, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F8(f1);
}

void
fp82_fpcmp_le(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
   GETSTATE_F8(qp,f1,f2,f3);
   _fpcmp(ps, frelLE, sf, (EM_uint_t)qp,
          (EM_uint_t)f1, (EM_uint_t)f2, (EM_uint_t)f3);
   PUTSTATE_F8(f1);
}

void
fp82_fpcmp_unord(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fpcmp(ps, frelUNORD, sf, (EM_uint_t)qp,
          (EM_uint_t)f1, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F8(f1);
}

void
fp82_fpcmp_neq(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fpcmp(ps,
           frelNEQ,                 sf, (EM_uint_t)qp,
           (EM_uint_t)f1, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F8(f1);
}

void
fp82_fpcmp_nlt(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fpcmp(ps, frelNLT, sf, (EM_uint_t)qp,
          (EM_uint_t)f1, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F8(f1);
}

void
fp82_fpcmp_nle(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fpcmp(ps, frelNLE, sf, (EM_uint_t)qp,
          (EM_uint_t)f1, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F8(f1);
}

void
fp82_fpcmp_ord(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2,
    EM_fp_reg_specifier   f3)
{
    GETSTATE_F8(qp,f1,f2,f3);
    _fpcmp(ps, frelORD, sf, (EM_uint_t)qp,
          (EM_uint_t)f1, (EM_uint_t)f2, (EM_uint_t)f3);
    PUTSTATE_F8(f1);
}

// ******************************************************************
// Convert Floating-point to Integer 
// ******************************************************************
void
fp82_fcvt_fx(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2)
{
    GETSTATE_F10(qp,f1,f2);
    SIGNED_FORM   = 1;
    _fcvt_fx(ps, sf, (EM_uint_t)qp, (EM_uint_t)f1, (EM_uint_t)f2);
    PUTSTATE_F10(f1);
}

void
fp82_fcvt_fxu(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2)
{
    GETSTATE_F10(qp,f1,f2);
    UNSIGNED_FORM = 1;
    _fcvt_fx(ps, sf, (EM_uint_t)qp, (EM_uint_t)f1, (EM_uint_t)f2);
    PUTSTATE_F10(f1);
}


void
fp82_fcvt_fx_trunc(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2)
{

    GETSTATE_F10(qp,f1,f2);
    SIGNED_FORM   = 1;
    TRUNC_FORM    = 1;
    _fcvt_fx(ps, sf, (EM_uint_t)qp, (EM_uint_t)f1, (EM_uint_t)f2);
    PUTSTATE_F10(f1);
}


void
fp82_fcvt_fxu_trunc(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2)
{
    GETSTATE_F10(qp,f1,f2);
    TRUNC_FORM    = 1;
    UNSIGNED_FORM = 1;
    _fcvt_fx(ps, sf, (EM_uint_t)qp, (EM_uint_t)f1, (EM_uint_t)f2);
    PUTSTATE_F10(f1);
}


// ******************************************************************
// Parallel Convert Floating-point to Integer 
// ******************************************************************
void
fp82_fpcvt_fx(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2)
{
    GETSTATE_F10(qp,f1,f2);
    SIGNED_FORM   = 1;
    _fpcvt_fx(ps, sf, (EM_uint_t)qp, (EM_uint_t)f1, (EM_uint_t)f2);
    PUTSTATE_F10(f1);
}


void
fp82_fpcvt_fxu(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2)
{
    GETSTATE_F10(qp,f1,f2);
    UNSIGNED_FORM = 1;
    _fpcvt_fx(ps, sf, (EM_uint_t)qp, (EM_uint_t)f1, (EM_uint_t)f2);
    PUTSTATE_F10(f1);
}

void
fp82_fpcvt_fx_trunc(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2)
{

    GETSTATE_F10(qp,f1,f2);
    SIGNED_FORM   = 1;
    TRUNC_FORM    = 1;
    _fpcvt_fx(ps, sf, (EM_uint_t)qp, (EM_uint_t)f1, (EM_uint_t)f2);
    PUTSTATE_F10(f1);
}

void
fp82_fpcvt_fxu_trunc(EM_state_type *ps,
    EM_opcode_sf_type     sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier   f1,
    EM_fp_reg_specifier   f2)
{
    GETSTATE_F10(qp,f1,f2);
    TRUNC_FORM    = 1;
    UNSIGNED_FORM = 1;
    _fpcvt_fx(ps, sf, (EM_uint_t)qp, (EM_uint_t)f1, (EM_uint_t)f2);
    PUTSTATE_F10(f1);
}

//***************************************************************
// Instruction pages: The Underbar Routines
//***************************************************************

// ******************************************************************
// _fma
// ******************************************************************
static INLINE void
_fma(EM_state_type    *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         f3,
    EM_uint_t         f4,
    EM_uint_t         f2)
{
EM_uint_t          tmp_isrcode;
EM_fp_reg_type     tmp_default_result;
EM_tmp_fp_env_type tmp_fp_env;
EM_fp_dp_type      tmp_res;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, f4)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3]) || fp_is_natval(FR[f4])) {
         FR[f1] = NATVAL;
         fp_update_psr(f1);
      } else {
         tmp_default_result = fma_exception_fault_check(f2, f3, f4,
                              pc, sf, &tmp_fp_env);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         if (fp_is_nan_or_inf(tmp_default_result))  {
            FR[f1] = tmp_default_result;
         } else {
            tmp_res = fp_mul(fp_reg_read(FR[f3]), 
                             fp_reg_read(FR[f4]));
            if (f2 != 0)
               tmp_res = fp_add(tmp_res, fp_reg_read(FR[f2]), tmp_fp_env);
            FR[f1] = fp_ieee_round(tmp_res, &tmp_fp_env);
         }

         fp_update_fpsr(sf, tmp_fp_env);
         fp_update_psr(f1);
         if (fp_raise_traps(tmp_fp_env))
            fp_exception_trap(fp_decode_trap(tmp_fp_env));
      }
   }
/* EAS END */
}


// ******************************************************************
// _fpma 
// ******************************************************************
static INLINE void
_fpma(EM_state_type   *ps,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         f3,
    EM_uint_t         f4,
    EM_uint_t         f2)
{
EM_uint_t           tmp_isrcode, tmp_res_hi, tmp_res_lo;
EM_pair_fp_reg_type tmp_default_result_pair;
EM_tmp_fp_env_type  tmp_fp_env;
EM_fp_dp_type       tmp_res;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, f4))  
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3]) || fp_is_natval(FR[f4]))  {
         FR[f1] = NATVAL;
         fp_update_psr(f1);
      } else {
         tmp_default_result_pair = fpma_exception_fault_check(f2, 
                                   f3, f4, sf, &tmp_fp_env);

         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }
         
         if (fp_is_nan_or_inf(tmp_default_result_pair.hi)) {
            tmp_res_hi = fp_single(tmp_default_result_pair.hi);
         } else {
            tmp_res = fp_mul(fp_reg_read_hi(f3), fp_reg_read_hi(f4));                
            if (f2 != 0)
               tmp_res = fp_add(tmp_res, fp_reg_read_hi(f2), tmp_fp_env);
            tmp_res_hi = fp_ieee_round_sp(tmp_res, high, &tmp_fp_env);
         }

         if (fp_is_nan_or_inf(tmp_default_result_pair.lo)) {
            tmp_res_lo = fp_single(tmp_default_result_pair.lo);
         } else {
            tmp_res = fp_mul(fp_reg_read_lo(f3), fp_reg_read_lo(f4));                
            if (f2 != 0)
               tmp_res = fp_add(tmp_res, fp_reg_read_lo(f2), tmp_fp_env);
            tmp_res_lo = fp_ieee_round_sp(tmp_res, low, &tmp_fp_env);
         }

         FR[f1].significand = fp_concatenate(tmp_res_hi, tmp_res_lo);
         FR[f1].exponent    = FP_INTEGER_EXP;
         FR[f1].sign        = FP_SIGN_POSITIVE;

         fp_update_fpsr(sf, tmp_fp_env);
         fp_update_psr(f1);
         if (fp_raise_traps(tmp_fp_env))
            fp_exception_trap(fp_decode_trap(tmp_fp_env));
      }
   }
/* EAS END */
}


// ******************************************************************
// _fms 
// ******************************************************************
static INLINE void
_fms(EM_state_type    *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         f3,
    EM_uint_t         f4,
    EM_uint_t         f2)
{
EM_uint_t          tmp_isrcode;
EM_fp_reg_type     tmp_fr2, tmp_default_result;
EM_fp_dp_type      tmp_res;
EM_tmp_fp_env_type tmp_fp_env;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, f4)) 
            disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3]) || fp_is_natval(FR[f4])) {
         FR[f1] = NATVAL;
         fp_update_psr(f1);
      } else {
         tmp_default_result = fms_fnma_exception_fault_check(f2, f3, f4,
                              pc, sf, &tmp_fp_env);

         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         if (fp_is_nan_or_inf(tmp_default_result))  {
            FR[f1] = tmp_default_result;
         } else {
            tmp_res = fp_mul(fp_reg_read(FR[f3]), fp_reg_read(FR[f4]));
            tmp_fr2 = fp_reg_read(FR[f2]);
            tmp_fr2.sign = !tmp_fr2.sign;
            if (f2 != 0)
               tmp_res = fp_add(tmp_res, tmp_fr2, tmp_fp_env);
            FR[f1] = fp_ieee_round(tmp_res, &tmp_fp_env);
         }

         fp_update_fpsr(sf, tmp_fp_env);
         fp_update_psr(f1);
         if (fp_raise_traps(tmp_fp_env))
            fp_exception_trap(fp_decode_trap(tmp_fp_env));
      }
   }
/* EAS END */
}


// ******************************************************************
// _fpms 
// ******************************************************************
static INLINE void
_fpms(EM_state_type   *ps,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         f3,
    EM_uint_t         f4,
    EM_uint_t         f2)
{
EM_uint_t           tmp_isrcode, tmp_res_hi, tmp_res_lo;
EM_pair_fp_reg_type tmp_default_result_pair;
EM_fp_reg_type      tmp_sub;
EM_fp_dp_type       tmp_res;
EM_tmp_fp_env_type  tmp_fp_env;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, f4)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3]) || fp_is_natval(FR[f4])) {
         FR[f1] = NATVAL;
         fp_update_psr(f1);
      } else {
         tmp_default_result_pair = fpms_fpnma_exception_fault_check(f2, f3, f4,
                                   sf, &tmp_fp_env);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         if (fp_is_nan_or_inf(tmp_default_result_pair.hi))  {
            tmp_res_hi = fp_single(tmp_default_result_pair.hi);
         } else {
            tmp_res = fp_mul(fp_reg_read_hi(f3), fp_reg_read_hi(f4));
            if (f2 != 0) {
               tmp_sub      = fp_reg_read_hi(f2);
               tmp_sub.sign = !tmp_sub.sign;
               tmp_res      = fp_add(tmp_res, tmp_sub, tmp_fp_env);
            }
            tmp_res_hi = fp_ieee_round_sp(tmp_res, high, &tmp_fp_env);
         }

         if (fp_is_nan_or_inf(tmp_default_result_pair.lo))  {
            tmp_res_lo = fp_single(tmp_default_result_pair.lo);
         } else {
            tmp_res = fp_mul(fp_reg_read_lo(f3), fp_reg_read_lo(f4));
            if (f2 != 0) {
               tmp_sub      = fp_reg_read_lo(f2);
               tmp_sub.sign = !tmp_sub.sign;
               tmp_res      = fp_add(tmp_res, tmp_sub, tmp_fp_env);
            }
            tmp_res_lo = fp_ieee_round_sp(tmp_res, low, &tmp_fp_env);
         }

         FR[f1].significand = fp_concatenate(tmp_res_hi, tmp_res_lo);
         FR[f1].exponent    = FP_INTEGER_EXP;
         FR[f1].sign        = FP_SIGN_POSITIVE;

         fp_update_fpsr(sf, tmp_fp_env);
         fp_update_psr(f1);
         if (fp_raise_traps(tmp_fp_env))
            fp_exception_trap(fp_decode_trap(tmp_fp_env));
      }
   }
/* EAS END */
}


// ******************************************************************
// _fnma 
// ******************************************************************
static INLINE void
_fnma(EM_state_type   *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         f3,
    EM_uint_t         f4,
    EM_uint_t         f2)
{
EM_uint_t          tmp_isrcode;
EM_fp_reg_type     tmp_default_result;
EM_tmp_fp_env_type tmp_fp_env;
EM_fp_dp_type      tmp_res;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, f4)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3]) || fp_is_natval(FR[f4])) {
         FR[f1] = NATVAL;
         fp_update_psr(f1);
      } else {
         tmp_default_result = fms_fnma_exception_fault_check(f2, f3, f4,
                              pc, sf, &tmp_fp_env);

         if (fp_raise_fault(tmp_fp_env)) {
                fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         if (fp_is_nan_or_inf(tmp_default_result))  {
            FR[f1] = tmp_default_result;
         } else {
            tmp_res      = fp_mul(fp_reg_read(FR[f3]), fp_reg_read(FR[f4]));
            tmp_res.sign = !tmp_res.sign;
            if (f2 != 0)
               tmp_res = fp_add(tmp_res, fp_reg_read(FR[f2]), tmp_fp_env);
            FR[f1] = fp_ieee_round(tmp_res, &tmp_fp_env);
         }

         fp_update_fpsr(sf, tmp_fp_env);
         fp_update_psr(f1);
         if (fp_raise_traps(tmp_fp_env))
            fp_exception_trap(fp_decode_trap(tmp_fp_env));
      }
   }
/* EAS END */
}

// ******************************************************************
// _fpnma 
// ******************************************************************
static INLINE void
_fpnma(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         f3,
    EM_uint_t         f4,
    EM_uint_t         f2)
{
EM_uint_t           tmp_isrcode, tmp_res_hi, tmp_res_lo;
EM_pair_fp_reg_type tmp_default_result_pair;
EM_tmp_fp_env_type  tmp_fp_env;
EM_fp_dp_type       tmp_res;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, f4)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3]) || fp_is_natval(FR[f4]))  {
         FR[f1] = NATVAL;
         fp_update_psr(f1);
      } else {
         tmp_default_result_pair = fpms_fpnma_exception_fault_check(f2, f3, f4,
                                   sf, &tmp_fp_env);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         if (fp_is_nan_or_inf(tmp_default_result_pair.hi))  {
            tmp_res_hi = fp_single(tmp_default_result_pair.hi);
         } else {
            tmp_res = fp_mul(fp_reg_read_hi(f3), fp_reg_read_hi(f4));
            tmp_res.sign = !tmp_res.sign;
            if (f2 != 0)
               tmp_res = fp_add(tmp_res, fp_reg_read_hi(f2), tmp_fp_env);
            tmp_res_hi = fp_ieee_round_sp(tmp_res, high, &tmp_fp_env);
         }

         if (fp_is_nan_or_inf(tmp_default_result_pair.lo))  {
            tmp_res_lo = fp_single(tmp_default_result_pair.lo);
         } else {
            tmp_res = fp_mul(fp_reg_read_lo(f3), fp_reg_read_lo(f4));
            tmp_res.sign = !tmp_res.sign;
            if (f2 != 0)
               tmp_res = fp_add(tmp_res, fp_reg_read_lo(f2), tmp_fp_env);
            tmp_res_lo = fp_ieee_round_sp(tmp_res, low, &tmp_fp_env);
         }

         FR[f1].significand = fp_concatenate(tmp_res_hi, tmp_res_lo);
         FR[f1].exponent    = FP_INTEGER_EXP;
         FR[f1].sign        = FP_SIGN_POSITIVE;

         fp_update_fpsr(sf, tmp_fp_env);
         fp_update_psr(f1);
         if (fp_raise_traps(tmp_fp_env))
            fp_exception_trap(fp_decode_trap(tmp_fp_env));
      }
   }
/* EAS END */
}


// ******************************************************************
// _fcmp 
// ******************************************************************
static INLINE void
_fcmp(EM_state_type      *ps,
    EM_opcode_frel_type  frel,
    EM_opcode_ctype_type fctype,
    EM_opcode_sf_type    sf,
    EM_uint_t            qp,
    EM_uint_t            p1,
    EM_uint_t            p2,
    EM_uint_t            f2,
    EM_uint_t            f3)
{
EM_uint_t          tmp_isrcode;
EM_fp_reg_type     tmp_fr2, tmp_fr3;
EM_tmp_fp_env_type tmp_fp_env;
EM_boolean_t       tmp_rel;

/* EAS START */
   if (PR[qp]) {
      if(p1==p2)
         illegal_operation_fault(0);
      if (tmp_isrcode = fp_reg_disabled(f2, f3, 0, 0))
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3])) {
         PR[p1] = 0;
         PR[p2] = 0;
      } else {
         fcmp_exception_fault_check(f2, f3, frel, sf, &tmp_fp_env);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         tmp_fr2 = fp_reg_read(FR[f2]);
         tmp_fr3 = fp_reg_read(FR[f3]);

         if (frel == frelEQ)         tmp_rel = fp_equal(tmp_fr2, tmp_fr3);
         else if (frel == frelLT)    tmp_rel = fp_less_than(tmp_fr2, tmp_fr3);
         else if (frel == frelLE)    tmp_rel = fp_lesser_or_equal(tmp_fr2, tmp_fr3);
         else if (frel == frelGT)    tmp_rel = fp_less_than(tmp_fr3, tmp_fr2);
         else if (frel == frelGE)    tmp_rel = fp_lesser_or_equal(tmp_fr3, tmp_fr2);
         else if (frel == frelUNORD) tmp_rel = fp_unordered(tmp_fr2, tmp_fr3);
         else if (frel == frelNEQ)   tmp_rel = !fp_equal(tmp_fr2, tmp_fr3);
         else if (frel == frelNLT)   tmp_rel = !fp_less_than(tmp_fr2, tmp_fr3);
         else if (frel == frelNLE)   tmp_rel = !fp_lesser_or_equal(tmp_fr2, tmp_fr3);
         else if (frel == frelNGT)   tmp_rel = !fp_less_than(tmp_fr3, tmp_fr2);
         else if (frel == frelNGE)   tmp_rel = !fp_lesser_or_equal(tmp_fr3, tmp_fr2);
         else                         tmp_rel = !fp_unordered(tmp_fr2, tmp_fr3);

         PR[p1] = tmp_rel;
         PR[p2] = !tmp_rel;
         fp_update_fpsr(sf, tmp_fp_env);
      }

   } else {
      if (fctype == fctypeUNC) {
         if(p1==p2)
            illegal_operation_fault(0);
         PR[p1] = 0;
         PR[p2] = 0;
      }
   }
/* EAS END */
}

// ******************************************************************
// _frcpa 
// ******************************************************************
static INLINE void
_frcpa(EM_state_type  *ps,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         p2,
    EM_uint_t         f2,
    EM_uint_t         f3)
{
EM_uint_t          tmp_isrcode;
EM_fp_reg_type     tmp_default_result, num, den;
EM_tmp_fp_env_type tmp_fp_env;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, 0)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3]))  {
         FR[f1] = NATVAL;
         PR[p2] = 0;
      } else {
         tmp_default_result = frcpa_exception_fault_check(f2, f3, sf, &tmp_fp_env);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         if (fp_is_nan_or_inf(tmp_default_result)) {
            FR[f1] = tmp_default_result;
            PR[p2] = 0;
          
         } else {
            num          = fp_normalize(fp_reg_read(FR[f2]));
            den          = fp_normalize(fp_reg_read(FR[f3]));
            if (fp_is_inf(num) && fp_is_finite(den)) {
               FR[f1]      = FP_INFINITY;
               FR[f1].sign = num.sign ^ den.sign;
               PR[p2] = 0;

            } else if (fp_is_finite(num) && fp_is_inf(den)) {
               FR[f1]      = FP_ZERO;
               FR[f1].sign = num.sign ^ den.sign;
               PR[p2] = 0;

            } else if (fp_is_zero(num) && fp_is_finite(den)) {
               FR[f1]      = FP_ZERO;
               FR[f1].sign = num.sign ^ den.sign;
               PR[p2] = 0;

            } else {
               FR[f1]      = fp_ieee_recip(den);
               PR[p2] = 1;
            }
         }
         fp_update_fpsr(sf, tmp_fp_env);
      }
      fp_update_psr(f1);
   } else  {
        PR[p2] = 0;
   }
/* EAS END */
}

// ******************************************************************
// _fprcpa 
// ******************************************************************
static INLINE void
_fprcpa(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         p2,
    EM_uint_t         f2,
    EM_uint_t         f3)
{
EM_uint_t              tmp_isrcode, tmp_res_hi, tmp_res_lo;
EM_pair_fp_reg_type    tmp_default_result_pair;
EM_fp_reg_type         tmp_res, num, den;
EM_boolean_t           tmp_pred_hi, tmp_pred_lo;
EM_tmp_fp_env_type     tmp_fp_env;
EM_limits_check_fprcpa limits_check = {0,0,0,0};

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, 0)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3])) {
         FR[f1] = NATVAL;
         PR[p2] = 0;
      } else {
         tmp_default_result_pair = fprcpa_exception_fault_check(f2, f3, sf, 
                                      &tmp_fp_env, &limits_check);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         if (fp_is_nan_or_inf(tmp_default_result_pair.hi) || limits_check.hi_fr3) {
            tmp_res_hi  = fp_single(tmp_default_result_pair.hi);
            tmp_pred_hi = 0;

         } else {
            num          = fp_normalize(fp_reg_read_hi(f2));
            den          = fp_normalize(fp_reg_read_hi(f3));

            if (fp_is_inf(num) && fp_is_finite(den)) {
               tmp_res      = FP_INFINITY;
               tmp_res.sign = num.sign ^ den.sign;
               tmp_pred_hi = 0;

            } else if (fp_is_finite(num) && fp_is_inf(den)) {
               tmp_res      = FP_ZERO;
               tmp_res.sign = num.sign ^ den.sign;
               tmp_pred_hi = 0;

            } else if (fp_is_zero(num) && fp_is_finite(den)) {
               tmp_res      = FP_ZERO;
               tmp_res.sign = num.sign ^ den.sign;
               tmp_pred_hi = 0;
         
            } else {
               tmp_res = fp_ieee_recip(den);
               if (limits_check.hi_fr2_or_quot) {
                  tmp_pred_hi  = 0;
               } else {
                  tmp_pred_hi  = 1;
               }
            }
            tmp_res_hi = fp_single(tmp_res);
         }


         if (fp_is_nan_or_inf(tmp_default_result_pair.lo) || limits_check.lo_fr3) {
             tmp_res_lo  = fp_single(tmp_default_result_pair.lo);
             tmp_pred_lo = 0;
         } else {
            num          = fp_normalize(fp_reg_read_lo(f2));
            den          = fp_normalize(fp_reg_read_lo(f3));

            if (fp_is_inf(num) && fp_is_finite(den)) {
               tmp_res      = FP_INFINITY;
               tmp_res.sign = num.sign ^ den.sign;
               tmp_pred_lo = 0;

            } else if (fp_is_finite(num) && fp_is_inf(den)) {
               tmp_res      = FP_ZERO;
               tmp_res.sign = num.sign ^ den.sign;
               tmp_pred_lo = 0;

            } else if (fp_is_zero(num) && fp_is_finite(den)) {
               tmp_res      = FP_ZERO;
               tmp_res.sign = num.sign ^ den.sign;
               tmp_pred_lo = 0;
         
            } else {
               tmp_res = fp_ieee_recip(den);
               if (limits_check.lo_fr2_or_quot) {
                  tmp_pred_lo = 0;
               } else {
                  tmp_pred_lo = 1;
               }
           }
           tmp_res_lo = fp_single(tmp_res);
        }

        FR[f1].significand = fp_concatenate(tmp_res_hi, tmp_res_lo);
        FR[f1].exponent    = FP_INTEGER_EXP;
        FR[f1].sign        = FP_SIGN_POSITIVE;
        PR[p2]             = tmp_pred_hi && tmp_pred_lo;

        fp_update_fpsr(sf, tmp_fp_env);
     }
      fp_update_psr(f1);
   } else  {
      PR[p2] = 0; /* unconditional semantics */
   }
/* EAS END */
}

// ******************************************************************
// _frsqrta 
// ******************************************************************
static INLINE void
_frsqrta(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         p2,
    EM_uint_t         f3)
{
EM_uint_t           tmp_isrcode;
EM_fp_reg_type      tmp_default_result, tmp_fr3;
EM_tmp_fp_env_type  tmp_fp_env;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f3, 0, 0)) 
            disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f3])) {
         FR[f1] = NATVAL;
         PR[p2] = 0;
      } else {
         tmp_default_result = frsqrta_exception_fault_check(f3, sf, &tmp_fp_env);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         if (fp_is_nan_or_inf(tmp_default_result)) {
            FR[f1] = tmp_default_result;
            PR[p2] = 0;
         } else {
            tmp_fr3 = fp_normalize(fp_reg_read(FR[f3]));
            if (fp_is_zero(tmp_fr3)) {
               FR[f1] = tmp_fr3;
               PR[p2] = 0;
            } else if (fp_is_pos_inf(tmp_fr3)) {
               FR[f1] = tmp_fr3;
               PR[p2] = 0;
            } else {
               FR[f1]  = fp_ieee_recip_sqrt(tmp_fr3);
               PR[p2]  = 1;
            }
         }
         fp_update_fpsr(sf, tmp_fp_env);
      }
      fp_update_psr(f1);
   } else {
      PR[p2] = 0;
   }
/* EAS END */
}

// ******************************************************************
// _fprsqrta 
// ******************************************************************
static INLINE void
_fprsqrta(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         p2,
    EM_uint_t         f3)
{
EM_uint_t                tmp_isrcode, tmp_res_hi, tmp_res_lo;
EM_pair_fp_reg_type      tmp_default_result_pair;
EM_fp_reg_type           tmp_res, tmp_fr3;
EM_boolean_t             tmp_pred_hi, tmp_pred_lo;
EM_tmp_fp_env_type       tmp_fp_env;
EM_limits_check_fprsqrta limits_check = {0, 0}; 

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f3, 0, 0)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if( fp_is_natval(FR[f3])) {
         PR[p2]  = 0;
         FR[f1]  = NATVAL;
      } else {
         tmp_default_result_pair = fprsqrta_exception_fault_check(f3, sf,
                                   &tmp_fp_env, &limits_check);
         if(fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         if (fp_is_nan(tmp_default_result_pair.hi) ) {
            tmp_res_hi = fp_single(tmp_default_result_pair.hi);
            tmp_pred_hi = 0;
         } else {
            tmp_fr3 = fp_normalize(fp_reg_read_hi(f3));
            if (fp_is_zero(tmp_fr3)) {
               tmp_res      = FP_INFINITY;
               tmp_res.sign = tmp_fr3.sign;
               tmp_pred_hi  = 0;
            } else if (fp_is_pos_inf(tmp_fr3)) {
               tmp_res     = FP_ZERO;
               tmp_pred_hi = 0;
            } else {
               tmp_res = fp_ieee_recip_sqrt(tmp_fr3);
               if (limits_check.hi) 
                  tmp_pred_hi  = 0;
               else 
                  tmp_pred_hi  = 1;
            }
            tmp_res_hi = fp_single(tmp_res);
         }


         if (fp_is_nan(tmp_default_result_pair.lo) ) {
            tmp_res_lo  = fp_single(tmp_default_result_pair.lo);
            tmp_pred_lo = 0;
         } else {
            tmp_fr3 = fp_normalize(fp_reg_read_lo(f3));
            if (fp_is_zero(tmp_fr3)) {
               tmp_res      = FP_INFINITY;
               tmp_res.sign = tmp_fr3.sign;
               tmp_pred_lo  = 0;
            } else if (fp_is_pos_inf(tmp_fr3)) {
               tmp_res      = FP_ZERO;
               tmp_pred_lo  = 0;
            } else {
               tmp_res = fp_ieee_recip_sqrt(tmp_fr3);
               if (limits_check.lo) 
                  tmp_pred_lo = 0;
               else 
                  tmp_pred_lo = 1;
            }
         tmp_res_lo = fp_single(tmp_res);
         }

         FR[f1].significand = fp_concatenate(tmp_res_hi,tmp_res_lo);
         FR[f1].exponent    = FP_INTEGER_EXP;
         FR[f1].sign        = FP_SIGN_POSITIVE;
         PR[p2]             = tmp_pred_hi & tmp_pred_lo;
         
         fp_update_fpsr(sf, tmp_fp_env);
      }
      fp_update_psr(f1);
   } else {
      PR[p2] = 0;
   }
/* EAS END */
}


// ******************************************************************
// _fmin 
// ******************************************************************
static INLINE void
_fmin(EM_state_type   *ps,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         f2,
    EM_uint_t         f3)
{
EM_uint_t          tmp_isrcode;
EM_tmp_fp_env_type tmp_fp_env;
EM_boolean_t       tmp_bool_res;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, 0)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3])) {
         FR[f1] = NATVAL;
      } else {
         fminmax_exception_fault_check(f2, f3, sf, &tmp_fp_env);

         if (fp_raise_fault(tmp_fp_env)) {
             fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         tmp_bool_res = fp_less_than(fp_reg_read(FR[f2]), fp_reg_read(FR[f3]));
         FR[f1] = tmp_bool_res ? FR[f2] : FR[f3];

         fp_update_fpsr(sf, tmp_fp_env);
      }
      fp_update_psr(f1);
   }
/* EAS END */
}


// ******************************************************************
// _fmax 
// ******************************************************************
static INLINE void
_fmax(EM_state_type   *ps,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         f2,
    EM_uint_t         f3)
{
EM_uint_t          tmp_isrcode;
EM_tmp_fp_env_type tmp_fp_env;
EM_boolean_t       tmp_bool_res;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, 0)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3])) {
         FR[f1] = NATVAL;
      } else {
         fminmax_exception_fault_check(f2, f3, sf, &tmp_fp_env);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         tmp_bool_res = fp_less_than(fp_reg_read(FR[f3]), fp_reg_read(FR[f2]));
         FR[f1] = (tmp_bool_res ? FR[f2] : FR[f3]);

         fp_update_fpsr(sf, tmp_fp_env);
      }
      fp_update_psr(f1);
   }
/* EAS END */
}


// ******************************************************************
// _famin 
// ******************************************************************
static INLINE void
_famin(EM_state_type *ps,
   EM_opcode_sf_type sf,
   EM_uint_t         qp,
   EM_uint_t         f1,
   EM_uint_t         f2,
   EM_uint_t         f3)
{
EM_uint_t          tmp_isrcode;
EM_fp_reg_type     tmp_right, tmp_left;
EM_tmp_fp_env_type tmp_fp_env;
EM_boolean_t       tmp_bool_res;


/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, 0)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3])) {
         FR[f1] = NATVAL;
      } else {
         fminmax_exception_fault_check(f2, f3, sf, &tmp_fp_env);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         tmp_left       = fp_reg_read(FR[f2]);
         tmp_right      = fp_reg_read(FR[f3]);
         tmp_left.sign  = FP_SIGN_POSITIVE;
         tmp_right.sign = FP_SIGN_POSITIVE;
         tmp_bool_res   = fp_less_than(tmp_left, tmp_right);
         FR[f1]         = tmp_bool_res ? FR[f2] : FR[f3];

         fp_update_fpsr(sf, tmp_fp_env);
      }
      fp_update_psr(f1);
   }
/* EAS END */
}


// ******************************************************************
// _famax 
// ******************************************************************
static INLINE void
_famax(EM_state_type *ps,
   EM_opcode_sf_type sf,
   EM_uint_t         qp,
   EM_uint_t         f1,
   EM_uint_t         f2,
   EM_uint_t         f3)
{
EM_uint_t          tmp_isrcode;
EM_fp_reg_type     tmp_right, tmp_left;
EM_tmp_fp_env_type tmp_fp_env;
EM_boolean_t       tmp_bool_res;


/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, 0) ) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3])) {
         FR[f1] = NATVAL;
      } else {
         fminmax_exception_fault_check(f2, f3, sf, &tmp_fp_env);

         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         tmp_right      = fp_reg_read(FR[f2]);
         tmp_left       = fp_reg_read(FR[f3]);
         tmp_right.sign = FP_SIGN_POSITIVE;
         tmp_left.sign  = FP_SIGN_POSITIVE;
         tmp_bool_res   = fp_less_than(tmp_left, tmp_right);

         FR[f1]         = tmp_bool_res ? FR[f2] : FR[f3];
         fp_update_fpsr(sf, tmp_fp_env);
      }
   fp_update_psr(f1);
   }
/* EAS END */
}

// ******************************************************************
// _fpmin
// ******************************************************************
static INLINE void
_fpmin(EM_state_type  *ps,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         f2,
    EM_uint_t         f3)
{
EM_uint_t           tmp_isrcode, tmp_res_hi, tmp_res_lo;
EM_fp_reg_type      tmp_right, tmp_left, tmp_fr2, tmp_fr3;
EM_tmp_fp_env_type  tmp_fp_env;
EM_boolean_t        tmp_bool_res;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, 0)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2] ) || fp_is_natval(FR[f3]) )  {
         FR[f1] = NATVAL;
      } else {
         fpminmax_exception_fault_check(f2, f3, sf, &tmp_fp_env);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         tmp_fr2 = tmp_left  = fp_reg_read_hi(f2);
         tmp_fr3 = tmp_right = fp_reg_read_hi(f3);
         tmp_bool_res        = fp_less_than(tmp_left, tmp_right);
         tmp_res_hi          = fp_single(tmp_bool_res ? tmp_fr2: tmp_fr3);

         tmp_fr2 = tmp_left  = fp_reg_read_lo(f2);
         tmp_fr3 = tmp_right = fp_reg_read_lo(f3);
         tmp_bool_res        = fp_less_than(tmp_left, tmp_right);
         tmp_res_lo          = fp_single(tmp_bool_res ? tmp_fr2: tmp_fr3);

         FR[f1].significand = fp_concatenate(tmp_res_hi, tmp_res_lo);
         FR[f1].exponent    = FP_INTEGER_EXP;
         FR[f1].sign        = FP_SIGN_POSITIVE;

         fp_update_fpsr(sf, tmp_fp_env);
      }
   fp_update_psr(f1);
   }
/* EAS END */
}

// ******************************************************************
// _fpmax
// ******************************************************************
static INLINE void
_fpmax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t         qp,
    EM_uint_t         f1,
    EM_uint_t         f2,
    EM_uint_t         f3)
{
EM_uint_t           tmp_isrcode, tmp_res_hi, tmp_res_lo;
EM_fp_reg_type      tmp_right, tmp_left, tmp_fr2, tmp_fr3;
EM_tmp_fp_env_type  tmp_fp_env;
EM_boolean_t        tmp_bool_res;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, 0)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2] ) || fp_is_natval(FR[f3]) )  {
         FR[f1] = NATVAL;
      } else {
         fpminmax_exception_fault_check(f2, f3, sf, &tmp_fp_env);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         tmp_fr2 = tmp_right = fp_reg_read_hi(f2);
         tmp_fr3 = tmp_left  = fp_reg_read_hi(f3);
         tmp_bool_res        = fp_less_than(tmp_left, tmp_right);
         tmp_res_hi          = fp_single(tmp_bool_res ? tmp_fr2 : tmp_fr3);

         tmp_fr2 = tmp_right = fp_reg_read_lo(f2);
         tmp_fr3 = tmp_left  = fp_reg_read_lo(f3);
         tmp_bool_res        = fp_less_than(tmp_left, tmp_right);
         tmp_res_lo          = fp_single(tmp_bool_res ? tmp_fr2: tmp_fr3);

         FR[f1].significand = fp_concatenate(tmp_res_hi, tmp_res_lo);
         FR[f1].exponent    = FP_INTEGER_EXP;
         FR[f1].sign        = FP_SIGN_POSITIVE;
         fp_update_fpsr(sf, tmp_fp_env);
      }
      fp_update_psr(f1);
   }
/* EAS END */
}

// ******************************************************************
// _fpamin
// ******************************************************************
static INLINE void
_fpamin(EM_state_type *ps,
   EM_opcode_sf_type sf,
   EM_uint_t         qp,
   EM_uint_t         f1,
   EM_uint_t         f2,
   EM_uint_t         f3)
{
EM_uint_t           tmp_isrcode, tmp_res_hi, tmp_res_lo;
EM_fp_reg_type      tmp_right, tmp_left, tmp_fr2, tmp_fr3;
EM_tmp_fp_env_type  tmp_fp_env;
EM_boolean_t        tmp_bool_res;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, 0)) 
         disabled_fp_register_fault(tmp_isrcode,0);
         
      if (fp_is_natval(FR[f2] ) || fp_is_natval(FR[f3]) )  {
         FR[f1] = NATVAL;
      } else {
         fpminmax_exception_fault_check(f2,f3, sf, &tmp_fp_env);
         if(fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }
   

         tmp_fr2 = tmp_left  = fp_reg_read_hi(f2);
         tmp_fr3 = tmp_right = fp_reg_read_hi(f3);
         tmp_left.sign       = FP_SIGN_POSITIVE;
         tmp_right.sign      = FP_SIGN_POSITIVE;
         tmp_bool_res        = fp_less_than(tmp_left, tmp_right);
         tmp_res_hi          = fp_single(tmp_bool_res ? tmp_fr2 : tmp_fr3);


         tmp_fr2 = tmp_left  = fp_reg_read_lo(f2);
         tmp_fr3 = tmp_right = fp_reg_read_lo(f3);
         tmp_left.sign       = FP_SIGN_POSITIVE;
         tmp_right.sign      = FP_SIGN_POSITIVE;
         tmp_bool_res        = fp_less_than(tmp_left, tmp_right);
         tmp_res_lo          = fp_single(tmp_bool_res ? tmp_fr2: tmp_fr3);

         FR[f1].significand  = fp_concatenate(tmp_res_hi, tmp_res_lo);
         FR[f1].exponent    = FP_INTEGER_EXP;
         FR[f1].sign         = FP_SIGN_POSITIVE;

         fp_update_fpsr(sf, tmp_fp_env);
      }
      fp_update_psr(f1);
   }
/* EAS END */
}


// ******************************************************************
// _fpamax
// ******************************************************************
static INLINE void
_fpamax(EM_state_type *ps,
   EM_opcode_sf_type sf,
   EM_uint_t         qp,
   EM_uint_t         f1,
   EM_uint_t         f2,
   EM_uint_t         f3)
{
EM_uint_t           tmp_isrcode, tmp_res_hi, tmp_res_lo;
EM_fp_reg_type      tmp_right, tmp_left, tmp_fr2, tmp_fr3;
EM_tmp_fp_env_type  tmp_fp_env;
EM_boolean_t        tmp_bool_res;


/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, f3, 0)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2] ) || fp_is_natval(FR[f3]) )  {
         FR[f1] = NATVAL;
      } else {
         fpminmax_exception_fault_check(f2, f3, sf, &tmp_fp_env);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }


         tmp_fr2 = tmp_right = fp_reg_read_hi(f2);
         tmp_fr3 = tmp_left  = fp_reg_read_hi(f3);
         tmp_right.sign      = FP_SIGN_POSITIVE;
         tmp_left.sign       = FP_SIGN_POSITIVE;
         tmp_bool_res        = fp_less_than(tmp_left, tmp_right);
         tmp_res_hi          = fp_single(tmp_bool_res ? tmp_fr2: tmp_fr3);


         tmp_fr2 = tmp_right = fp_reg_read_lo(f2);
         tmp_fr3 = tmp_left  = fp_reg_read_lo(f3);
         tmp_right.sign      = FP_SIGN_POSITIVE;
         tmp_left.sign       = FP_SIGN_POSITIVE;
         tmp_bool_res        = fp_less_than(tmp_left, tmp_right);
         tmp_res_lo          = fp_single(tmp_bool_res ? tmp_fr2: tmp_fr3);

         FR[f1].significand = fp_concatenate(tmp_res_hi, tmp_res_lo);
         FR[f1].exponent    = FP_INTEGER_EXP;
         FR[f1].sign        = FP_SIGN_POSITIVE;

         fp_update_fpsr(sf, tmp_fp_env);
      } 
      fp_update_psr(f1);
   }
/* EAS END */
}

// ******************************************************************
// _fpcmp 
// ******************************************************************
static INLINE void
_fpcmp(EM_state_type   *ps,
   EM_opcode_frel_type frel, 
   EM_opcode_sf_type   sf,
   EM_uint_t           qp, 
   EM_uint_t           f1,
   EM_uint_t           f2,
   EM_uint_t           f3)
{
EM_uint_t           tmp_isrcode, tmp_res_hi, tmp_res_lo;
EM_fp_reg_type      tmp_fr2, tmp_fr3;
EM_tmp_fp_env_type  tmp_fp_env;
EM_boolean_t        tmp_rel;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if(tmp_isrcode = fp_reg_disabled(f1, f2,f3, 0))
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) || fp_is_natval(FR[f3]) )  {
         FR[f1] = NATVAL;
      } else {
         fpcmp_exception_fault_check(f2, f3, frel, sf, &tmp_fp_env);
   
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }
         

         tmp_fr2 = fp_reg_read_hi(f2);
         tmp_fr3 = fp_reg_read_hi(f3);

         if (frel == frelEQ)         tmp_rel = fp_equal(tmp_fr2, tmp_fr3);
         else if (frel == frelLT)    tmp_rel = fp_less_than(tmp_fr2, tmp_fr3);
         else if (frel == frelLE)    tmp_rel = fp_lesser_or_equal(tmp_fr2, tmp_fr3);
         else if (frel == frelGT)    tmp_rel = fp_less_than(tmp_fr3, tmp_fr2);
         else if (frel == frelGE)    tmp_rel = fp_lesser_or_equal(tmp_fr3, tmp_fr2);
         else if (frel == frelUNORD) tmp_rel = fp_unordered(tmp_fr2, tmp_fr3);
         else if (frel == frelNEQ)   tmp_rel = !fp_equal(tmp_fr2, tmp_fr3);
         else if (frel == frelNLT)   tmp_rel = !fp_less_than(tmp_fr2, tmp_fr3);
         else if (frel == frelNLE)   tmp_rel = !fp_lesser_or_equal(tmp_fr2, tmp_fr3);
         else if (frel == frelNGT)   tmp_rel = !fp_less_than(tmp_fr3, tmp_fr2);
         else if (frel == frelNGE)   tmp_rel = !fp_lesser_or_equal(tmp_fr3, tmp_fr2);
         else                        tmp_rel = !fp_unordered(tmp_fr2, tmp_fr3);
   
         tmp_res_hi = (tmp_rel ? 0xFFFFFFFF : 0x00000000);


         tmp_fr2 = fp_reg_read_lo(f2);
         tmp_fr3 = fp_reg_read_lo(f3);
   
         if (frel == frelEQ)         tmp_rel = fp_equal(tmp_fr2, tmp_fr3);
         else if (frel == frelLT)    tmp_rel = fp_less_than(tmp_fr2, tmp_fr3);
         else if (frel == frelLE)    tmp_rel = fp_lesser_or_equal(tmp_fr2, tmp_fr3);
         else if (frel == frelGT)    tmp_rel = fp_less_than(tmp_fr3, tmp_fr2);
         else if (frel == frelGE)    tmp_rel = fp_lesser_or_equal(tmp_fr3, tmp_fr2);
         else if (frel == frelUNORD) tmp_rel = fp_unordered(tmp_fr2, tmp_fr3);
         else if (frel == frelNEQ)   tmp_rel = !fp_equal(tmp_fr2, tmp_fr3);
         else if (frel == frelNLT)   tmp_rel = !fp_less_than(tmp_fr2, tmp_fr3);
         else if (frel == frelNLE)   tmp_rel = !fp_lesser_or_equal(tmp_fr2, tmp_fr3);
         else if (frel == frelNGT)   tmp_rel = !fp_less_than(tmp_fr3, tmp_fr2);
         else if (frel == frelNGE)   tmp_rel = !fp_lesser_or_equal(tmp_fr3, tmp_fr2);
         else                        tmp_rel = !fp_unordered(tmp_fr2, tmp_fr3);
   
         tmp_res_lo = (tmp_rel ? 0xFFFFFFFF : 0x00000000);

         FR[f1].significand = fp_concatenate(tmp_res_hi, tmp_res_lo);
         FR[f1].exponent    = FP_INTEGER_EXP;
         FR[f1].sign        = FP_SIGN_POSITIVE;

         fp_update_fpsr(sf, tmp_fp_env);
      }
      fp_update_psr(f1);
   }
/* EAS END */
}

// ******************************************************************
// _fcvt_fx
// ******************************************************************
static INLINE void
_fcvt_fx(EM_state_type *ps,
   EM_opcode_sf_type sf,
   EM_uint_t         qp,
   EM_uint_t         f1,
   EM_uint_t         f2)
{
EM_uint_t          tmp_isrcode;
EM_fp_reg_type     tmp_default_result, tmp_res;
EM_tmp_fp_env_type tmp_fp_env;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, 0, 0)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2])) {
         FR[f1] = NATVAL;
         fp_update_psr(f1);
      } else {
         tmp_default_result = fcvt_exception_fault_check(f2, sf,
                              SIGNED_FORM, TRUNC_FORM, &tmp_fp_env);

         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         if (fp_is_nan(tmp_default_result))  {
            FR[f1].significand = INTEGER_INDEFINITE;
            FR[f1].exponent    = FP_INTEGER_EXP;
            FR[f1].sign        = FP_SIGN_POSITIVE;
         } else {
            tmp_res = fp_ieee_rnd_to_int(fp_reg_read(FR[f2]), &tmp_fp_env);
            if (tmp_res.exponent)
               tmp_res.significand = fp_U64_rsh(
                           tmp_res.significand, FP_INTEGER_EXP - (EM_int_t)tmp_res.exponent);
            if (SIGNED_FORM && tmp_res.sign) 
               tmp_res.significand = (~tmp_res.significand) + 1;

            FR[f1].significand = tmp_res.significand;
            FR[f1].exponent    = FP_INTEGER_EXP;
            FR[f1].sign        = FP_SIGN_POSITIVE;
         }

         fp_update_fpsr(sf, tmp_fp_env);
         fp_update_psr(f1);
         if (fp_raise_traps(tmp_fp_env))
            fp_exception_trap(fp_decode_trap(tmp_fp_env));
      }
   }
/* EAS END */
}

// ******************************************************************
// _fpcvt_fx
// ******************************************************************
static INLINE void
_fpcvt_fx(EM_state_type     *ps,
   EM_opcode_sf_type sf,
   EM_uint_t         qp,
   EM_uint_t         f1,
   EM_uint_t         f2)
{
EM_uint_t           tmp_isrcode, tmp_res_lo, tmp_res_hi;
EM_pair_fp_reg_type tmp_default_result_pair;
EM_fp_reg_type      tmp_res;
EM_tmp_fp_env_type  tmp_fp_env;

/* EAS START */
   if (PR[qp]) {
      fp_check_target_register(f1);
      if (tmp_isrcode = fp_reg_disabled(f1, f2, 0, 0)) 
         disabled_fp_register_fault(tmp_isrcode,0);

      if (fp_is_natval(FR[f2]) )  {
         FR[f1] = NATVAL;
         fp_update_psr(f1);
      } else {
         tmp_default_result_pair = fpcvt_exception_fault_check(f2, sf, 
                                   SIGNED_FORM, TRUNC_FORM, &tmp_fp_env);
         if (fp_raise_fault(tmp_fp_env)) {
            fp_exception_fault(fp_decode_fault(tmp_fp_env));
            return; // MACH
         }

         if (fp_is_nan(tmp_default_result_pair.hi)) {
            tmp_res_hi = INTEGER_INDEFINITE_32_BIT;
         } else {
            tmp_res = fp_ieee_rnd_to_int_sp(fp_reg_read_hi(f2), high, &tmp_fp_env);
            if (tmp_res.exponent)
               tmp_res.significand = fp_U64_rsh(
                        tmp_res.significand, (FP_INTEGER_EXP - tmp_res.exponent)); 
            if (SIGNED_FORM && tmp_res.sign) 
               tmp_res.significand = (~tmp_res.significand) + 1;

            tmp_res_hi = fp_extract_bits(tmp_res.significand, 31, 0);
         }

         if (fp_is_nan(tmp_default_result_pair.lo)) {
            tmp_res_lo = INTEGER_INDEFINITE_32_BIT;
         } else {
            tmp_res = fp_ieee_rnd_to_int_sp(fp_reg_read_lo(f2), low, &tmp_fp_env);
            if (tmp_res.exponent)
               tmp_res.significand = fp_U64_rsh(
                        tmp_res.significand,(FP_INTEGER_EXP - tmp_res.exponent)); 
            if (SIGNED_FORM && tmp_res.sign) 
               tmp_res.significand = (~tmp_res.significand) + 1;

            tmp_res_lo = fp_extract_bits(tmp_res.significand, 31, 0);
         }
         FR[f1].significand = fp_concatenate(tmp_res_hi, tmp_res_lo);
         FR[f1].exponent    = FP_INTEGER_EXP;
         FR[f1].sign        = FP_SIGN_POSITIVE;

         fp_update_fpsr(sf, tmp_fp_env);
         fp_update_psr(f1);
         if (fp_raise_traps(tmp_fp_env))
            fp_exception_trap(fp_decode_trap(tmp_fp_env));
      } 
   }
/* EAS END */
}


/********** fp_ieee_recip **********/

static EM_fp_reg_type
fp_ieee_recip(
    EM_fp_reg_type den)
{
EM_uint_t      tmp_index;
EM_fp_reg_type tmp_res;

/* EAS START */
    const EM_uint_t RECIP_TABLE[256] = {
         0x3fc, 0x3f4, 0x3ec, 0x3e4, 0x3dd, 0x3d5, 0x3cd, 0x3c6,
         0x3be, 0x3b7, 0x3af, 0x3a8, 0x3a1, 0x399, 0x392, 0x38b,
         0x384, 0x37d, 0x376, 0x36f, 0x368, 0x361, 0x35b, 0x354,
         0x34d, 0x346, 0x340, 0x339, 0x333, 0x32c, 0x326, 0x320,
         0x319, 0x313, 0x30d, 0x307, 0x300, 0x2fa, 0x2f4, 0x2ee,
         0x2e8, 0x2e2, 0x2dc, 0x2d7, 0x2d1, 0x2cb, 0x2c5, 0x2bf,
         0x2ba, 0x2b4, 0x2af, 0x2a9, 0x2a3, 0x29e, 0x299, 0x293,
         0x28e, 0x288, 0x283, 0x27e, 0x279, 0x273, 0x26e, 0x269,
         0x264, 0x25f, 0x25a, 0x255, 0x250, 0x24b, 0x246, 0x241,
         0x23c, 0x237, 0x232, 0x22e, 0x229, 0x224, 0x21f, 0x21b,
         0x216, 0x211, 0x20d, 0x208, 0x204, 0x1ff, 0x1fb, 0x1f6,
         0x1f2, 0x1ed, 0x1e9, 0x1e5, 0x1e0, 0x1dc, 0x1d8, 0x1d4,
         0x1cf, 0x1cb, 0x1c7, 0x1c3, 0x1bf, 0x1bb, 0x1b6, 0x1b2,
         0x1ae, 0x1aa, 0x1a6, 0x1a2, 0x19e, 0x19a, 0x197, 0x193,
         0x18f, 0x18b, 0x187, 0x183, 0x17f, 0x17c, 0x178, 0x174,
         0x171, 0x16d, 0x169, 0x166, 0x162, 0x15e, 0x15b, 0x157,
         0x154, 0x150, 0x14d, 0x149, 0x146, 0x142, 0x13f, 0x13b,
         0x138, 0x134, 0x131, 0x12e, 0x12a, 0x127, 0x124, 0x120,
         0x11d, 0x11a, 0x117, 0x113, 0x110, 0x10d, 0x10a, 0x107,
         0x103, 0x100, 0x0fd, 0x0fa, 0x0f7, 0x0f4, 0x0f1, 0x0ee,
         0x0eb, 0x0e8, 0x0e5, 0x0e2, 0x0df, 0x0dc, 0x0d9, 0x0d6,
         0x0d3, 0x0d0, 0x0cd, 0x0ca, 0x0c8, 0x0c5, 0x0c2, 0x0bf,
         0x0bc, 0x0b9, 0x0b7, 0x0b4, 0x0b1, 0x0ae, 0x0ac, 0x0a9,
         0x0a6, 0x0a4, 0x0a1, 0x09e, 0x09c, 0x099, 0x096, 0x094,
         0x091, 0x08e, 0x08c, 0x089, 0x087, 0x084, 0x082, 0x07f,
         0x07c, 0x07a, 0x077, 0x075, 0x073, 0x070, 0x06e, 0x06b,
         0x069, 0x066, 0x064, 0x061, 0x05f, 0x05d, 0x05a, 0x058,
         0x056, 0x053, 0x051, 0x04f, 0x04c, 0x04a, 0x048, 0x045,
         0x043, 0x041, 0x03f, 0x03c, 0x03a, 0x038, 0x036, 0x033,
         0x031, 0x02f, 0x02d, 0x02b, 0x029, 0x026, 0x024, 0x022,
         0x020, 0x01e, 0x01c, 0x01a, 0x018, 0x015, 0x013, 0x011,
         0x00f, 0x00d, 0x00b, 0x009, 0x007, 0x005, 0x003, 0x001,
    };


    tmp_index            = fp_extract_bits(den.significand,62,55);
    tmp_res.significand  = ((EM_uint64_t)1 << 63) | ((EM_uint64_t)RECIP_TABLE[tmp_index] << 53);
    tmp_res.exponent     = (EM_int_t)FP_REG_EXP_ONES - 2 - (EM_int_t)den.exponent;
    tmp_res.sign         = den.sign;
    return (tmp_res);

/* EAS END */
}


/********** fp_ieee_recip_sqrt **********/

static EM_fp_reg_type
fp_ieee_recip_sqrt(
    EM_fp_reg_type root)
{
EM_uint_t tmp_index;
EM_fp_reg_type tmp_res;

/* EAS START */
    const EM_uint_t RECIP_SQRT_TABLE[256] = {
         0x1a5, 0x1a0, 0x19a, 0x195, 0x18f, 0x18a, 0x185, 0x180,
         0x17a, 0x175, 0x170, 0x16b, 0x166, 0x161, 0x15d, 0x158,
         0x153, 0x14e, 0x14a, 0x145, 0x140, 0x13c, 0x138, 0x133,
         0x12f, 0x12a, 0x126, 0x122, 0x11e, 0x11a, 0x115, 0x111,
         0x10d, 0x109, 0x105, 0x101, 0x0fd, 0x0fa, 0x0f6, 0x0f2,
         0x0ee, 0x0ea, 0x0e7, 0x0e3, 0x0df, 0x0dc, 0x0d8, 0x0d5,
         0x0d1, 0x0ce, 0x0ca, 0x0c7, 0x0c3, 0x0c0, 0x0bd, 0x0b9,
         0x0b6, 0x0b3, 0x0b0, 0x0ad, 0x0a9, 0x0a6, 0x0a3, 0x0a0,
         0x09d, 0x09a, 0x097, 0x094, 0x091, 0x08e, 0x08b, 0x088,
         0x085, 0x082, 0x07f, 0x07d, 0x07a, 0x077, 0x074, 0x071,
         0x06f, 0x06c, 0x069, 0x067, 0x064, 0x061, 0x05f, 0x05c,
         0x05a, 0x057, 0x054, 0x052, 0x04f, 0x04d, 0x04a, 0x048,
         0x045, 0x043, 0x041, 0x03e, 0x03c, 0x03a, 0x037, 0x035,
         0x033, 0x030, 0x02e, 0x02c, 0x029, 0x027, 0x025, 0x023,
         0x020, 0x01e, 0x01c, 0x01a, 0x018, 0x016, 0x014, 0x011,
         0x00f, 0x00d, 0x00b, 0x009, 0x007, 0x005, 0x003, 0x001,
         0x3fc, 0x3f4, 0x3ec, 0x3e5, 0x3dd, 0x3d5, 0x3ce, 0x3c7,
         0x3bf, 0x3b8, 0x3b1, 0x3aa, 0x3a3, 0x39c, 0x395, 0x38e,
         0x388, 0x381, 0x37a, 0x374, 0x36d, 0x367, 0x361, 0x35a,
         0x354, 0x34e, 0x348, 0x342, 0x33c, 0x336, 0x330, 0x32b,
         0x325, 0x31f, 0x31a, 0x314, 0x30f, 0x309, 0x304, 0x2fe,
         0x2f9, 0x2f4, 0x2ee, 0x2e9, 0x2e4, 0x2df, 0x2da, 0x2d5,
         0x2d0, 0x2cb, 0x2c6, 0x2c1, 0x2bd, 0x2b8, 0x2b3, 0x2ae,
         0x2aa, 0x2a5, 0x2a1, 0x29c, 0x298, 0x293, 0x28f, 0x28a,
         0x286, 0x282, 0x27d, 0x279, 0x275, 0x271, 0x26d, 0x268,
         0x264, 0x260, 0x25c, 0x258, 0x254, 0x250, 0x24c, 0x249,
         0x245, 0x241, 0x23d, 0x239, 0x235, 0x232, 0x22e, 0x22a,
         0x227, 0x223, 0x220, 0x21c, 0x218, 0x215, 0x211, 0x20e,
         0x20a, 0x207, 0x204, 0x200, 0x1fd, 0x1f9, 0x1f6, 0x1f3,
         0x1f0, 0x1ec, 0x1e9, 0x1e6, 0x1e3, 0x1df, 0x1dc, 0x1d9,
         0x1d6, 0x1d3, 0x1d0, 0x1cd, 0x1ca, 0x1c7, 0x1c4, 0x1c1,
         0x1be, 0x1bb, 0x1b8, 0x1b5, 0x1b2, 0x1af, 0x1ac, 0x1aa,
    };

        tmp_index =  (fp_extract_bits((EM_uint64_t)root.exponent,0,0) << 7) |
                     fp_extract_bits(root.significand,62,56);

        tmp_res.significand  = ((EM_uint64_t)1 << 63) |((EM_uint64_t)RECIP_SQRT_TABLE[tmp_index] << 53);
        tmp_res.exponent     = ((EM_int_t)FP_REG_EXP_HALF) - ((((EM_int_t)root.exponent) - ((EM_int_t)FP_REG_BIAS)) >> 1);
        tmp_res.sign         = FP_SIGN_POSITIVE;
        return(tmp_res);
    
/* EAS END */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\exceptn.c ===
/*++

Module Name:

    exceptn.c

Abstract:

    This module implement the code necessary to dispatch expections to the
    proper mode and invoke the exception dispatcher.

Author:

    William K. Cheung (wcheung) 10-Nov-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#include "ntfpia64.h"


#include "fedefs.h"
#include "fetypes.h"
#include "fesupprt.h"
#include "feproto.h"
#include "floatem.h"
#include "fpswa.h"

LONG
fp_emulate (
    ULONG trap_type,
    PVOID pbundle,
    ULONGLONG *pipsr,
    ULONGLONG *pfpsr,
    ULONGLONG *pisr,
    ULONGLONG *ppreds,
    ULONGLONG *pifs,
    PVOID fp_state
    );

BOOLEAN
KiEmulateFloat (
    PEXCEPTION_RECORD ExceptionRecord,
    PKEXCEPTION_FRAME ExceptionFrame,
    PKTRAP_FRAME TrapFrame
    )
{

    FLOATING_POINT_STATE FpState;
    USHORT ISRCode;
    ULONG TrapType;
    PVOID ExceptionAddress;
    BUNDLE KeBundle;

    LONG Status = -1;

    FpState.ExceptionFrame = (PVOID)ExceptionFrame;
    FpState.TrapFrame = (PVOID)TrapFrame;

    if (ExceptionRecord->ExceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS) {
        TrapType = 1;
        ExceptionAddress = (PVOID)TrapFrame->StIIP;
    } else {
        TrapType = 0;
        ExceptionAddress = (PVOID)TrapFrame->StIIPA;
    }

    try {

        KeBundle.BundleLow =(ULONGLONG)(*(PULONGLONG)ExceptionAddress);
        KeBundle.BundleHigh =(ULONGLONG)(*((PULONGLONG)ExceptionAddress + 1));
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // if an exception (memory fault) occurs, then let hardware handle it
        //
        return TRUE;
    }

    if ((Status = fp_emulate(TrapType, &KeBundle,
                      &TrapFrame->StIPSR, &TrapFrame->StFPSR, &TrapFrame->StISR,
                      &TrapFrame->Preds, &TrapFrame->StIFS, (PVOID)&FpState)) == 0) {

       //
       // Exception was handled and state modified.
       // Therefore the context frame does not need to
       // be transfered to the trap and exception frames.
       //
       // Since it was fault, PC should be advanced
       //

       if (TrapType == 1) {
           KiAdvanceInstPointer(TrapFrame);
       }

       if (TrapFrame->StIPSR & (1 << PSR_MFH)) {

           //
           // high fp set is modified; set the dfh and clear the mfh
           // to force a reload on the first access to the high fp set
           //

           TrapFrame->StIPSR &= ~(1i64 << PSR_MFH);
           TrapFrame->StIPSR |= (1i64 << PSR_DFH);
       }

       return TRUE;
    }

    if (Status == -1) {
        return FALSE;
    }

    ISRCode = (USHORT)TrapFrame->StISR;

    if (Status & 0x1) {

        ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;

        if (!(Status & 0x4)) {
            if (TrapType == 1) {

                //
                // FP Fault
                //

                if (ISRCode & 0x11) {
                    ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
                } else if (ISRCode & 0x22) {
                    ExceptionRecord->ExceptionCode = STATUS_FLOAT_DENORMAL_OPERAND;
                } else if (ISRCode & 0x44) {
                    ExceptionRecord->ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
                }

            } else {

                //
                // FP Trap
                //

                ISRCode = ISRCode >> 7;
                if (ISRCode & 0x11) {
                    ExceptionRecord->ExceptionCode = STATUS_FLOAT_OVERFLOW;
                } else if (ISRCode & 0x22) {
                    ExceptionRecord->ExceptionCode = STATUS_FLOAT_UNDERFLOW;
                } else if (ISRCode & 0x44) {
                    ExceptionRecord->ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
                }

            }
        }

        if (Status & 0x2) {

            //
            // FP Fault To Trap
            //

            KiAdvanceInstPointer(TrapFrame);
            if (!(Status & 0x4)) {
                ISRCode = ISRCode >> 7;
                if (ISRCode & 0x11) {
                    ExceptionRecord->ExceptionCode = STATUS_FLOAT_OVERFLOW;
                } else if (ISRCode & 0x22) {
                    ExceptionRecord->ExceptionCode = STATUS_FLOAT_UNDERFLOW;
                } else if (ISRCode & 0x44) {
                    ExceptionRecord->ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
                }
            } else {
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_MULTIPLE_TRAPS;
            }
        }

    }

    return FALSE;
}

typedef struct _BRL_INST {
    union {
        struct {
            ULONGLONG qp:    6;
            ULONGLONG b1:    3;
            ULONGLONG rsv0:  3;
            ULONGLONG p:     1;
            ULONGLONG imm20: 20;
            ULONGLONG wh:    2;
            ULONGLONG d:     1;
            ULONGLONG i:     1;
            ULONGLONG Op:    4;
            ULONGLONG rsv1:  23;
        } i;
        ULONGLONG Ulong64;
    } u;
} BRL_INST;

typedef struct _BRL2_INST {
    union {
        struct {
            ULONGLONG rsv0:  2;
            ULONGLONG imm39: 39;
            ULONGLONG rsv1:  23;
        } i;
        ULONGLONG Ulong64;
    } u;
} BRL0_INST;

typedef struct _FRAME_MARKER {
    union {
        struct {
            ULONGLONG sof : 7;
            ULONGLONG sol : 7;
            ULONGLONG sor : 4;
            ULONGLONG rrbgr : 7;
            ULONGLONG rrbfr : 7;
            ULONGLONG rrbpr : 6;
        } f;
        ULONGLONG Ulong64;
    } u;
} FRAME_MARKER;


BOOLEAN
KiEmulateBranchLongFault(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN OUT PKTRAP_FRAME TrapFrame
    )
/*++

Routine Description:

    This function is called to emulate a brl instruction.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    A value of TRUE is return if the brl is successfully emulated.
    Otherwise, a value of FALSE is returned.

--*/

{
    PULONGLONG BundleAddress;
    PVOID ExceptionAddress;
    ULONGLONG BundleLow;
    ULONGLONG BundleHigh;
    ULONGLONG Template;
    BRL_INST BrlInst;
    BRL0_INST BrlInst0;
    ULONGLONG NewIP;
    ULONGLONG Taken;
    FRAME_MARKER Cfm;

    BundleAddress = (PULONGLONG)TrapFrame->StIIP;
    ExceptionAddress = (PVOID) TrapFrame->StIIP;

    try {

        //
        // get the instruction bundle
        //

        BundleLow = *BundleAddress;
        BundleHigh = *(BundleAddress+1);

    } except ((KiCopyInformation(ExceptionRecord,
                               (GetExceptionInformation())->ExceptionRecord))) {
        //
        // Preserve the original exception address.
        //

        ExceptionRecord->ExceptionAddress = ExceptionAddress;

        return FALSE;
    }

    BrlInst0.u.Ulong64 = (BundleLow >> 46) | (BundleHigh << 18);
    BrlInst.u.Ulong64 = (BundleHigh >> 23);

    Template = BundleLow & 0x1f;

    if (!((Template == 4)||(Template == 5))) {

        //
        // if template does not indicate MLX, return FALSE
        //

        return FALSE;

    }

    switch (BrlInst.u.i.Op) {

    case 0xc: // brl.cond

        Taken = TrapFrame->Preds & (1i64 << BrlInst.u.i.qp);
        break;

    case 0xd: // brl.call

        Taken = TrapFrame->Preds & (1i64 << BrlInst.u.i.qp);

        if (Taken) {

            switch (BrlInst.u.i.b1) {
            case 0: TrapFrame->BrRp = TrapFrame->StIIP + 16; break;
            case 1: ExceptionFrame->BrS0 = TrapFrame->StIIP + 16; break;
            case 2: ExceptionFrame->BrS1 = TrapFrame->StIIP + 16; break;
            case 3: ExceptionFrame->BrS2 = TrapFrame->StIIP + 16; break;
            case 4: ExceptionFrame->BrS3 = TrapFrame->StIIP + 16; break;
            case 5: ExceptionFrame->BrS4 = TrapFrame->StIIP + 16; break;
            case 6: TrapFrame->BrT0 = TrapFrame->StIIP + 16; break;
            case 7: TrapFrame->BrT1 = TrapFrame->StIIP + 16; break;
            }

            TrapFrame->RsPFS = TrapFrame->StIFS & 0x3FFFFFFFFFi64;
            TrapFrame->RsPFS |= (ExceptionFrame->ApEC & (0x3fi64 << 52));
            TrapFrame->RsPFS |= (((TrapFrame->StIPSR >> PSR_CPL) & 0x3) << 62);

            Cfm.u.Ulong64  = TrapFrame->StIFS;

            Cfm.u.f.sof -= Cfm.u.f.sol;
            Cfm.u.f.sol = 0;
            Cfm.u.f.sor = 0;
            Cfm.u.f.rrbgr = 0;
            Cfm.u.f.rrbfr = 0;
            Cfm.u.f.rrbpr = 0;

            TrapFrame->StIFS = Cfm.u.Ulong64;
            TrapFrame->StIFS |= 0x8000000000000000;
        }

        break;

    default:
        return FALSE;

    }

    if (Taken) {

        NewIP = TrapFrame->StIIP +
            (((BrlInst.u.i.i<<59)|(BrlInst0.u.i.imm39<<20)|(BrlInst.u.i.imm20)) << 4);

        TrapFrame->StIIP = NewIP;

    } else {

        TrapFrame->StIIP += 16;

    }

    TrapFrame->StIPSR &= ~(3i64 << PSR_RI);


    return TRUE;
}


VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to dispatch an exception to the proper mode and
    to cause the exception dispatcher to be called.

    If the exception is a data misalignment, this is the first chance for
    handling the exception, and the current thread has enabled automatic
    alignment fixup, then an attempt is made to emulate the unaligned
    reference.

    If the exception is a floating exception (N.B. the pseudo status
    STATUS_FLOAT_STACK_CHECK is used to signify this and is converted to the
    proper code by examiningg the main status field of the floating point
    status register).

    If the exception is neither a data misalignment nor a floating point
    exception and the the previous mode is kernel, then the exception
    dispatcher is called directly to process the exception. Otherwise the
    exception record, exception frame, and trap frame contents are copied
    to the user mode stack. The contents of the exception frame and trap
    are then modified such that when control is returned, execution will
    commense in user mode in a routine which will call the exception
    dispatcher.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    PreviousMode - Supplies the previous processor mode.

    FirstChance - Supplies a boolean variable that specifies whether this
        is the first (TRUE) or second (FALSE) time that this exception has
        been processed.

Return Value:

    None.

--*/

{

    CONTEXT ContextFrame;
    EXCEPTION_RECORD ExceptionRecord1;
    PPLABEL_DESCRIPTOR Plabel;
    BOOLEAN UserApcPending;
    BOOLEAN AlignmentFaultHandled;
    BOOLEAN ExceptionWasForwarded = FALSE;
    ISR Isr;
    PSR Psr;

    //
    // If the exception is a illegal instruction, check to see if it was
    // trying to executing a brl instruction. If so, emulate the brl
    // instruction.
    //

    if (ExceptionRecord->ExceptionCode == STATUS_ILLEGAL_INSTRUCTION) {

        Isr.ull = TrapFrame->StISR;
        Psr.ull = TrapFrame->StIPSR;

        if ((Isr.sb.isr_code == ISR_ILLEGAL_OP) && (Isr.sb.isr_ei == 1)) {

            if (KiEmulateBranchLongFault(ExceptionRecord,
                                         ExceptionFrame,
                                         TrapFrame) == TRUE) {

                //
                // emulation was successful;
                //

                return;
            }
        }

    }


    //
    // If the exception is a data misalignment, the previous mode was user,
    // this is the first chance for handling the exception, and the current
    // thread has enabled automatic alignment fixup, then attempt to emulate
    // the unaligned reference.
    //

    if (ExceptionRecord->ExceptionCode == STATUS_DATATYPE_MISALIGNMENT) {

        AlignmentFaultHandled = KiHandleAlignmentFault( ExceptionRecord,
                                                        ExceptionFrame,
                                                        TrapFrame,
                                                        PreviousMode,
                                                        FirstChance,
                                                        &ExceptionWasForwarded );
        if (AlignmentFaultHandled != FALSE) {
            goto Handled2;
        }
    }

    //
    // N.B. BREAKIN_BREAKPOINT check is in KdpTrap()
    //

    //
    // If the exception is a floating point exception, then the
    // ExceptionCode was set to STATUS_FLOAT_MULTIPLE_TRAPS or
    // STATUS_FLOAT_MULTIPLE_FAULTS.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS) ||
        (ExceptionRecord->ExceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS)) {

        if (KiEmulateFloat(ExceptionRecord, ExceptionFrame, TrapFrame)) {

            //
            // Emulation is successful; continue execution
            //

            return;
        }
    }

    //
    // Move machine state from trap and exception frames to a context frame,
    // and increment the number of exceptions dispatched.
    //

    ContextFrame.ContextFlags = CONTEXT_FULL;
    KeContextFromKframes(TrapFrame, ExceptionFrame, &ContextFrame);
    KeGetCurrentPrcb()->KeExceptionDispatchCount += 1;

    //
    // Select the method of handling the exception based on the previous mode.
    //

    if (PreviousMode == KernelMode) {

        //
        // Previous mode was kernel.
        //
        // If this is the first chance, the kernel debugger is active, and
        // the exception is a kernel breakpoint, then give the kernel debugger
        // a chance to handle the exception.
        //
        // If this is the first chance and the kernel debugger is not active
        // or does not handle the exception, then attempt to find a frame
        // handler to handle the exception.
        //
        // If this is the second chance or the exception is not handled, then
        // if the kernel debugger is active, then give the kernel debugger a
        // second chance to handle the exception. If the kernel debugger does
        // not handle the exception, then bug check.
        //

        if (FirstChance != FALSE) {

            //
            // This is the first chance to handle the exception.
            //
            // Note: RtlpCaptureRnats() flushes the RSE and captures the
            //       Nat bits of stacked registers in the RSE frame at
            //       which exception happens.
            //

            RtlpCaptureRnats(&ContextFrame);
            TrapFrame->RsRNAT = ContextFrame.RsRNAT;

            //
            // If the kernel debugger is active, the exception is a breakpoint,
            // and the breakpoint is handled by the kernel debugger, then give
            // the kernel debugger a chance to handle the exception.
            //

            if ((KiDebugRoutine != NULL) &&
               (KdIsThisAKdTrap(ExceptionRecord,
                                &ContextFrame,
                                KernelMode) != FALSE)) {

                if (((KiDebugRoutine) (TrapFrame,
                                       ExceptionFrame,
                                       ExceptionRecord,
                                       &ContextFrame,
                                       KernelMode,
                                       FALSE)) != FALSE) {

                    goto Handled1;
                }
            }

            if (RtlDispatchException(ExceptionRecord, &ContextFrame) != FALSE) {
                goto Handled1;
            }
        }

        //
        // This is the second chance to handle the exception.
        //

        if (KiDebugRoutine != NULL) {
            if (((KiDebugRoutine) (TrapFrame,
                                   ExceptionFrame,
                                   ExceptionRecord,
                                   &ContextFrame,
                                   PreviousMode,
                                   TRUE)) != FALSE) {
                goto Handled1;
            }
        }

        KeBugCheckEx(KMODE_EXCEPTION_NOT_HANDLED,
                     ExceptionRecord->ExceptionCode,
                     (ULONG_PTR)ExceptionRecord->ExceptionAddress,
                     ExceptionRecord->ExceptionInformation[0],
                     ExceptionRecord->ExceptionInformation[1]);

    } else {

        //
        // Previous mode was user.
        //
        // If this is the first chance, the kernel debugger is active, the
        // exception is a kernel breakpoint, and the current process is not
        // being debugged, or the current process is being debugged, but the
        // the breakpoint is not a kernel breakpoint instruction, then give
        // the kernel debugger a chance to handle the exception.
        //
        // If this is the first chance and the current process has a debugger
        // port, then send a message to the debugger port and wait for a reply.
        // If the debugger handles the exception, then continue execution. Else
        // transfer the exception information to the user stack, transition to
        // user mode, and attempt to dispatch the exception to a frame based
        // handler. If a frame based handler handles the exception, then continue
        // execution. Otherwise, execute the raise exception system service
        // which will call this routine a second time to process the exception.
        //
        // If this is the second chance and the current process has a debugger
        // port, then send a message to the debugger port and wait for a reply.
        // If the debugger handles the exception, then continue execution. Else
        // if the current process has a subsystem port, then send a message to
        // the subsystem port and wait for a reply. If the subsystem handles the
        // exception, then continue execution. Else terminate the thread.
        //

        if (FirstChance != FALSE) {

            //
            // If the kernel debugger is active, the exception is a kernel
            // breakpoint, and the current process is not being debugged,
            // or the current process is being debugged, but the breakpoint
            // is not a kernel breakpoint instruction, then give the kernel
            // debugger a chance to handle the exception.
            //

            if ((KiDebugRoutine != NULL) &&
                (KdIsThisAKdTrap(ExceptionRecord,
                                 &ContextFrame,
                                 UserMode) != FALSE) &&
                ((PsGetCurrentProcess()->DebugPort == NULL) ||
                ((PsGetCurrentProcess()->DebugPort != NULL) &&
                ((ExceptionRecord->ExceptionInformation[0] !=
                                            BREAKPOINT_STOP) &&
                 (ExceptionRecord->ExceptionCode != STATUS_SINGLE_STEP))))) {

                if (((KiDebugRoutine) (TrapFrame,
                                       ExceptionFrame,
                                       ExceptionRecord,
                                       &ContextFrame,
                                       UserMode,
                                       FALSE)) != FALSE) {

                    goto Handled1;
                }
            }

            //
            // This is the first chance to handle the exception.
            //

            if (ExceptionWasForwarded == FALSE &&
                DbgkForwardException(ExceptionRecord, TRUE, FALSE)) {
                TrapFrame->StFPSR = SANITIZE_FSR(TrapFrame->StFPSR, UserMode);
                goto Handled2;
            }

            //
            // Transfer exception information to the user stack, transition
            // to user mode, and attempt to dispatch the exception to a frame
            // based handler.
            //
            //
            // We are running on the kernel stack now.  On the user stack, we
            // build a stack frame containing the following:
            //
            //               |                                   |
            //               |-----------------------------------|
            //               |                                   |
            //               |   User's stack frame              |
            //               |                                   |
            //               |-----------------------------------|
            //               |                                   |
            //               |   Context record                  |
            //               |                                   |
            //               |                                   |
            //               |- - - - - - - - - - - - - - - - - -|
            //               |                                   |
            //               |   Exception record                |
            //               |                                   |
            //               |- - - - - - - - - - - - - - - - - -|
            //               |   Stack Scratch Area              |
            //               |-----------------------------------|
            //               |                                   |
            //
            // This stack frame is for KiUserExceptionDispatcher, the assembly
            // langauge routine that effects transfer in user mode to
            // RtlDispatchException.  KiUserExceptionDispatcher is passed
            // pointers to the Exception Record and Context Record as
            // parameters.
            //

        repeat:
            try {

                //
                // Compute length of exception record and new aligned stack
                // address.
                //

                ULONG Length = (STACK_SCRATCH_AREA + 15 +
                                sizeof(EXCEPTION_RECORD) + sizeof(CONTEXT)) & ~(15);
                ULONGLONG UserStack = (ContextFrame.IntSp & (~15)) - Length;
                ULONGLONG ContextSlot = UserStack + STACK_SCRATCH_AREA;
                ULONGLONG ExceptSlot = ContextSlot + sizeof(CONTEXT);
                PULONGLONG PUserStack = (PULONGLONG) UserStack;

                //
                // When the exception gets dispatched to the user the 
                // user BSP state will be loaded.  Clear the preload 
                // count in the RSE so it is not reloaded after if the
                // context is reused.
                //

                ContextFrame.RsRSC = ZERO_PRELOAD_SIZE(ContextFrame.RsRSC);
               
                //
                // Probe user stack area for writeability and then transfer the
                // exception record and conext record to the user stack area.
                //

                ProbeForWrite((PCHAR)UserStack, Length, sizeof(QUAD));
                RtlCopyMemory((PVOID)ContextSlot, &ContextFrame,
                              sizeof(CONTEXT));
                RtlCopyMemory((PVOID)ExceptSlot, ExceptionRecord,
                              sizeof(EXCEPTION_RECORD));

                //
                // Set address of exception record and context record in
                // the exception frame and the new stack pointer in the
                // current trap frame.  Also set the initial frame size
                // to be zero.
                //
                // N.B. User exception dispatcher flushes the RSE
                //      and updates the BSPStore field upon entry.
                //

                TrapFrame->RsPFS = SANITIZE_PFS(TrapFrame->StIFS, UserMode);
                TrapFrame->StIFS &= 0xffffffc000000000i64;
                TrapFrame->StIPSR &= ~((0x3i64 << PSR_RI) | (0x1i64 << PSR_IS));
                TrapFrame->IntSp = UserStack;
                TrapFrame->IntNats = 0;

                //
                // reset the user FPSR so that a recursive exception will not occur.
                //

                // TrapFrame->StFPSR = USER_FPSR_INITIAL;

                ExceptionFrame->IntS0 = ExceptSlot;
                ExceptionFrame->IntS1 = ContextSlot;
                ExceptionFrame->IntNats = 0;

                //
                // Set the address and the gp of the exception routine that
                // will call the exception dispatcher and then return to the
                // trap handler.  The trap handler will restore the exception
                // and trap frame context and continue execution in the routine
                // that will call the exception dispatcher.
                //

                Plabel = (PPLABEL_DESCRIPTOR)KeUserExceptionDispatcher;
                TrapFrame->StIIP = Plabel->EntryPoint;
                TrapFrame->IntGp = Plabel->GlobalPointer;

                return;

            //
            // If an exception occurs, then copy the new exception information
            // to an exception record and handle the exception.
            //

            } except (KiCopyInformation(&ExceptionRecord1,
                               (GetExceptionInformation())->ExceptionRecord)) {

                //
                // If the exception is a stack overflow, then attempt
                // to raise the stack overflow exception. Otherwise,
                // the user's stack is not accessible, or is misaligned,
                // and second chance processing is performed.
                //

                if (ExceptionRecord1.ExceptionCode == STATUS_STACK_OVERFLOW) {
                    ExceptionRecord1.ExceptionAddress = ExceptionRecord->ExceptionAddress;
                    RtlCopyMemory((PVOID)ExceptionRecord,
                                  &ExceptionRecord1, sizeof(EXCEPTION_RECORD));
                    goto repeat;
                }
            }
        }

        //
        // This is the second chance to handle the exception.
        //

        UserApcPending = KeGetCurrentThread()->ApcState.UserApcPending;
        if (DbgkForwardException(ExceptionRecord, TRUE, TRUE)) {
            TrapFrame->StFPSR = SANITIZE_FSR(TrapFrame->StFPSR, UserMode);
            goto Handled2;

        } else if (DbgkForwardException(ExceptionRecord, FALSE, TRUE)) {
            TrapFrame->StFPSR = SANITIZE_FSR(TrapFrame->StFPSR, UserMode);
            goto Handled2;

        } else {
            ZwTerminateProcess(NtCurrentProcess(), ExceptionRecord->ExceptionCode);
            KeBugCheckEx(KMODE_EXCEPTION_NOT_HANDLED,
                         ExceptionRecord->ExceptionCode,
                         (ULONG_PTR)ExceptionRecord->ExceptionAddress,
                         ExceptionRecord->ExceptionInformation[0],
                         ExceptionRecord->ExceptionInformation[1]);
        }
    }

    //
    // Move machine state from context frame to trap and exception frames and
    // then return to continue execution with the restored state.
    //

Handled1:
    KeContextToKframes(TrapFrame, ExceptionFrame, &ContextFrame,
                       ContextFrame.ContextFlags, PreviousMode);

    //
    // Exception was handled by the debugger or the associated subsystem
    // and state was modified, if necessary, using the get state and set
    // state capabilities. Therefore the context frame does not need to
    // be transfered to the trap and exception frames.
    //

Handled2:
    return;
}

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    )

/*++

Routine Description:

    This function is called from an exception filter to copy the exception
    information from one exception record to another when an exception occurs.

Arguments:

    ExceptionRecord1 - Supplies a pointer to the destination exception record.

    ExceptionRecord2 - Supplies a pointer to the source exception record.

Return Value:

    A value of EXCEPTION_EXECUTE_HANDLER is returned as the function value.

--*/

{
    //
    // Copy one exception record to another and return value that causes
    // an exception handler to be executed.
    //

    RtlCopyMemory((PVOID)ExceptionRecord1,
                  (PVOID)ExceptionRecord2,
                  sizeof(EXCEPTION_RECORD));

    return EXCEPTION_EXECUTE_HANDLER;
}

NTSTATUS
KeRaiseUserException(
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This function causes an exception to be raised in the calling thread's user-mode
    context. It does this by editing the trap frame the kernel was entered with to
    point to trampoline code that raises the requested exception.

Arguments:

    ExceptionCode - Supplies the status value to be used as the exception
        code for the exception that is to be raised.

Return Value:

    The status value that should be returned by the caller.

--*/

{
    PKTRAP_FRAME TrapFrame;
    IA64_PFS  Ifs;

    ASSERT(KeGetPreviousMode() == UserMode);

    TrapFrame = KeGetCurrentThread()->TrapFrame;
    if (TrapFrame == NULL) {
        return ExceptionCode;
    }

    try {
        PULONGLONG IntSp;

        IntSp = (PULONGLONG) TrapFrame->IntSp;
        ProbeForWriteSmallStructure (IntSp, sizeof (*IntSp)*2, sizeof(QUAD));
        *IntSp++ = TrapFrame->BrRp;
        *IntSp   = TrapFrame->RsPFS;
        TrapFrame->StIIP = ((PPLABEL_DESCRIPTOR)KeRaiseUserExceptionDispatcher)->EntryPoint;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return (ExceptionCode);
    }


 
    //
    // Set IFS the size after the the system call.
    //

    Ifs.ull = TrapFrame->StIFS;
    Ifs.sb.pfs_sof = Ifs.sb.pfs_sof - Ifs.sb.pfs_sol;
    Ifs.sb.pfs_sol = 0;
    TrapFrame->StIFS = Ifs.ull;

    return(ExceptionCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\feinstr.h ===
// ******************************
// Intel Confidential
// ******************************

#ifndef _EM_INSTR_H
#define _EM_INSTR_H

#include "fepublic.h"

static EM_fp_reg_type
fp_ieee_recip(
    EM_fp_reg_type den);

static EM_fp_reg_type
fp_ieee_recip_sqrt(
    EM_fp_reg_type root);

// ********************************
// Instruction Pages Prototypes 
// ********************************

// Floating-point Multiply Add 
static INLINE void
_fma(EM_state_type *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f3,
    EM_uint_t f4,
    EM_uint_t f2);

// Floating-point Parallel Multiply Add 
static INLINE void
_fpma(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f3,
    EM_uint_t f4,
    EM_uint_t f2);

// Floating-point Multiply Subtract 
static INLINE void
_fms(EM_state_type *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f3,
    EM_uint_t f4,
    EM_uint_t f2);

// Floating-point Parallel Multiply Subtract 
static INLINE void
_fpms(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f3,
    EM_uint_t f4,
    EM_uint_t f2);

// Floating-point Negative Multiply Add 
static INLINE void
_fnma(EM_state_type *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f3,
    EM_uint_t f4,
    EM_uint_t f2);


// Floating-point Parallel Negative Multiply Add 
static INLINE void
_fpnma(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f3,
    EM_uint_t f4,
    EM_uint_t f2);


// Floating-point Compare 
static INLINE void
_fcmp(EM_state_type *ps,
    EM_opcode_frel_type frel,
    EM_opcode_ctype_type ctype,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t p1,
    EM_uint_t p2,
    EM_uint_t f2,
    EM_uint_t f3);

// Floating-point Reciprocal Approximation 
static INLINE void
_frcpa(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t p2,
    EM_uint_t f2,
    EM_uint_t f3);

// Floating-point Parallel Reciprocal Approximation 
static INLINE void
_fprcpa(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t p2,
    EM_uint_t f2,
    EM_uint_t f3);

// Floating-point Reciprocal Square Root Approximation 
static INLINE void
_frsqrta(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t p2,
    EM_uint_t f3);

// Floating-point Parallel Reciprocal Square Root Approximation 
static INLINE void
_fprsqrta(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t p2,
    EM_uint_t f3);

// Floating-point Minimum 
static INLINE void
_fmin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f2,
    EM_uint_t f3);

static INLINE void
_fmax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f2,
    EM_uint_t f3);

// Floating-point Absolute Minimum 
static INLINE void
_famin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f2,
    EM_uint_t f3);

// Floating-point Absolute Maximum 
static INLINE void
_famax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f2,
    EM_uint_t f3);

// Floating-point Parallel Minimum 
static INLINE void
_fpmin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f2,
    EM_uint_t f3);

// Floating-point Parallel Minimum 
static INLINE void
_fpmax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f2,
    EM_uint_t f3);


// Floating-point Parallel Absolute Minimum 
static INLINE void
_fpamin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f2,
    EM_uint_t f3);

// Floating-point Parallel Absolute Maximum 
static INLINE void
_fpamax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f2,
    EM_uint_t f3);

// Floating-point Parallel Compare 
static INLINE void
_fpcmp(EM_state_type *ps,
    EM_opcode_frel_type frel,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f2,
    EM_uint_t f3);

// Convert Floating-point to Integer 
static INLINE void
_fcvt_fx(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f2);

// Parallel Convert Floating-point to Integer 
static INLINE void
_fpcvt_fx(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_uint_t qp,
    EM_uint_t f1,
    EM_uint_t f2);

#endif

#undef GETSTATE_F1
#undef PUTSTATE_F1

#undef GETSTATE_F4
#undef PUTSTATE_F4

#undef GETSTATE_F6
#undef PUTSTATE_F6

#undef GETSTATE_F7
#undef PUTSTATE_F7

#undef GETSTATE_F8
#undef PUTSTATE_F8

#undef GETSTATE_F10
#undef PUTSTATE_F10

#define GETSTATE_F1(qp,f1,f3,f4,f2)        _GETSTATE_F1(ps, qp,f1,f3,f4,f2)
#define PUTSTATE_F1(f1)                    _PUTSTATE_F1(ps, f1)

#define GETSTATE_F4(qp,p1,p2,f2,f3)         _GETSTATE_F4(ps, qp,p1,p2,f2,f3)
#define PUTSTATE_F4(p1,p2)                  _PUTSTATE_F4(ps, p1,p2)

#define GETSTATE_F6(qp,f1,p2,f2,f3)         _GETSTATE_F6(ps,qp,f1,p2,f2,f3)
#define PUTSTATE_F6(f1,p2)                  _PUTSTATE_F6(ps,f1,p2)

#define GETSTATE_F7(qp,f1,p2,f3)            _GETSTATE_F7(ps, qp,f1,p2,f3)
#define PUTSTATE_F7(f1,p2)                  _PUTSTATE_F7(ps, f1,p2)

#define GETSTATE_F8(qp,f1,f2,f3)           _GETSTATE_F8(ps, qp,f1,f2,f3)
#define PUTSTATE_F8(f1)                    _PUTSTATE_F8(ps, f1)

#define GETSTATE_F10(qp,f1,f2)             _GETSTATE_F10(ps, qp,f1,f2)
#define PUTSTATE_F10(f1)                   _PUTSTATE_F10(ps, f1)

/***********************************************************
undefs 
************************************************************/

#undef fp_reg_disabled
#undef fp_reg_read_hi
#undef fp_reg_read_lo
#undef fp_ieee_rnd_to_int
#undef fp_ieee_rnd_to_int_sp
#undef fp_ieee_round_sp
#undef fp_ieee_round

#undef fminmax_exception_fault_check 
#undef fpminmax_exception_fault_check 
#undef fcmp_exception_fault_check
#undef fpcmp_exception_fault_check

#undef fcvt_exception_fault_check
#undef fpcvt_exception_fault_check

#undef fma_exception_fault_check
#undef fpma_exception_fault_check
#undef fms_fnma_exception_fault_check
#undef fpms_fpnma_exception_fault_check

#undef frcpa_exception_fault_check
#undef fprcpa_exception_fault_check
#undef frsqrta_exception_fault_check
#undef fprsqrta_exception_fault_check

#undef illegal_operation_fault
#undef fp_check_target_register 

#undef fp_exception_fault
#undef fp_exception_trap

#undef disabled_fp_register_fault

#undef fp_update_fpsr 
#undef fp_update_psr 

/***********************************************************
redefinitions 
************************************************************/
#define fp_reg_disabled(f1,f2,f3,f4)         fp82_fp_reg_disabled(ps, f1,f2,f3,f4)


#define fp_reg_read_hi(f2)            fp82_reg_read_hi(ps,f2)
#define fp_reg_read_lo(f3)            fp82_reg_read_lo(ps,f3)

#define fp_ieee_rnd_to_int(arg1,arg2) \
        fp82_fp_ieee_rnd_to_int(ps, arg1, arg2)
#define fp_ieee_rnd_to_int_sp(arg1,arg2, arg3) \
        fp82_fp_ieee_rnd_to_int_sp(ps, arg1, arg2, arg3)


#define fp_ieee_round_sp(arg1, arg2, arg3) \
        fp82_fp_ieee_round_sp(ps, arg1, arg2, arg3)
#define fp_ieee_round(arg1, arg2) \
        fp82_fp_ieee_round(ps, arg1, arg2)

#define fminmax_exception_fault_check(arg1, arg2, arg3, arg4) \
        fp82_fminmax_exception_fault_check(ps, arg1, arg2, arg3, arg4) 
#define fpminmax_exception_fault_check(arg1, arg2, arg3, arg4) \
        fp82_fpminmax_exception_fault_check(ps, arg1, arg2, arg3, arg4) 

#define fcmp_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fcmp_exception_fault_check(ps, arg1, arg2, arg3, arg4, arg5)
#define fpcmp_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fpcmp_exception_fault_check(ps, arg1, arg2, arg3, arg4, arg5)

#define fcvt_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fcvt_exception_fault_check(ps, arg1, arg2, arg3, arg4, arg5)
#define fpcvt_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fpcvt_exception_fault_check(ps, arg1, arg2, arg3, arg4, arg5)

#define fma_exception_fault_check(arg1, arg2, arg3, arg4, arg5, arg6) \
        fp82_fma_exception_fault_check(ps, arg1, arg2, arg3, arg4, arg5, arg6)
#define fpma_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fpma_exception_fault_check(ps, arg1, arg2, arg3, arg4, arg5)

#define fms_fnma_exception_fault_check(arg1, arg2, arg3, arg4, arg5, arg6) \
        fp82_fms_fnma_exception_fault_check(ps, arg1, arg2, arg3, arg4, arg5, arg6)

#define fpms_fpnma_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fpms_fpnma_exception_fault_check(ps, arg1, arg2, arg3, arg4, arg5)

#define frcpa_exception_fault_check(arg1, arg2, arg3, arg4) \
        fp82_frcpa_exception_fault_check(ps, arg1, arg2, arg3, arg4)

#define fprcpa_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fprcpa_exception_fault_check(ps, arg1, arg2, arg3, arg4, arg5)

#define frsqrta_exception_fault_check(arg1, arg2, arg3) \
        fp82_frsqrta_exception_fault_check(ps, arg1, arg2, arg3)

#define fprsqrta_exception_fault_check(arg1, arg2, arg3, arg4) \
        fp82_fprsqrta_exception_fault_check(ps, arg1, arg2, arg3, arg4)

#define illegal_operation_fault( NON_RS) \
        fp82_illegal_operation_fault(ps, NON_RS) 

#define fp_check_target_register( reg_specifier) \
        fp82_fp_check_target_register(ps, reg_specifier)

#define fp_exception_fault( tmp) \
        fp82_fp_exception_fault(ps, tmp) 

#define fp_exception_trap( tmp) \
        fp82_fp_exception_trap(ps, tmp) 

#define disabled_fp_register_fault(isr_code, itype) \
        fp82_disabled_fp_register_fault(ps, isr_code, itype) 

#define fp_update_fpsr(sf, tmp_env)    fp82_fp_update_fpsr(ps,sf, tmp_env)
#define fp_update_psr(dest_freg)       fp82_fp_update_psr(ps,dest_freg)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\fedefs.h ===
#define IN_KERNEL 1

#if 0
/* #define this in floatem.c, fedefs.h and EM_support.c */
#define DEBUG_UNIX
#endif



#ifdef IN_KERNEL

#define FP_EMULATION_ERROR0(string) \
              {DbgPrint(string); }
#define FP_EMULATION_ERROR1(string, arg) \
              {DbgPrint(string, arg); }
#define FP_EMULATION_ERROR2(string, arg1, arg2) \
              {DbgPrint(string, arg1, arg2); }
#define FP_EMULATION_ERROR3(string, arg1, arg2, arg3) \
              {DbgPrint(string, arg1, arg2, arg3); }
#define FP_EMULATION_ERROR4(string, arg1, arg2, arg3, arg4) \
              {DbgPrint(string, arg1, arg2, arg3, arg4); }
#define FP_EMULATION_ERROR5(string, arg1, arg2, arg3, arg4, arg5) \
              {DbgPrint(string, arg1, arg2, arg3, arg4, arg5); }
#define FP_EMULATION_ERROR6(string, arg1, arg2, arg3, arg4, arg5, arg6) \
              {DbgPrint(string, arg1, arg2, arg3, arg4, arg5, arg6); }

#define FP_EMULATION_PRINT0(string) \
              {DbgPrint(string); }
#define FP_EMULATION_PRINT1(string, arg) \
              {DbgPrint(string, arg); }
#define FP_EMULATION_PRINT2(string, arg1, arg2) \
              {DbgPrint(string, arg1, arg2); }
#define FP_EMULATION_PRINT3(string, arg1, arg2, arg3) \
              {DbgPrint(string, arg1, arg2, arg3); }
#define FP_EMULATION_PRINT4(string, arg1,arg2, arg3, arg4) \
              {DbgPrint(string, arg1, arg2, arg3, arg4); }
#define FP_EMULATION_PRINT5(string, arg1, arg2, arg3, arg4, arg5) \
              {DbgPrint(string, arg1, arg2, arg3, arg4, arg5); }
#define FP_EMULATION_PRINT6(string, arg1, arg2, arg3, arg4, arg5, arg6) \
              {DbgPrint(string, arg1, arg2, arg3, arg4, arg5, arg6); }

#define perror(string) DbgPrint(string)

#define exit(number) KeBugCheck(FP_EMULATION_ERROR)


#elif defined(unix)

#define FP_EMULATION_ERROR0(string) \
              {DbgPrint(string); }
#define FP_EMULATION_ERROR1(string, arg) \
              {DbgPrint(string, arg); }
#define FP_EMULATION_ERROR2(string, arg1, arg2) \
              {DbgPrint(string, arg1, arg2); }
#define FP_EMULATION_ERROR3(string, arg1, arg2, arg3) \
              {DbgPrint(string, arg1, arg2, arg3); }
#define FP_EMULATION_ERROR4(string, arg1, arg2, arg3, arg4) \
              {DbgPrint(string, arg1, arg2, arg3, arg4); }
#define FP_EMULATION_ERROR5(string, arg1, arg2, arg3, arg4, arg5) \
              {DbgPrint(string, arg1, arg2, arg3, arg4, arg5); }
#define FP_EMULATION_ERROR6(string, arg1, arg2, arg3, arg4, arg5, arg6) \
              {DbgPrint(string, arg1, arg2, arg3, arg4, arg5, arg6); }

#define FP_EMULATION_PRINT0(string) \
              {DbgPrint(string); }
#define FP_EMULATION_PRINT1(string, arg) \
              {DbgPrint(string, arg); }
#define FP_EMULATION_PRINT2(string, arg1, arg2) \
              {DbgPrint(string, arg1, arg2); }
#define FP_EMULATION_PRINT3(string, arg1, arg2, arg3) \
              {DbgPrint(string, arg1, arg2, arg3); }
#define FP_EMULATION_PRINT4(string, arg1,arg2, arg3, arg4) \
              {DbgPrint(string, arg1, arg2, arg3, arg4); }
#define FP_EMULATION_PRINT5(string, arg1, arg2, arg3, arg4, arg5) \
              {DbgPrint(string, arg1, arg2, arg3, arg4, arg5); }
#define FP_EMULATION_PRINT6(string, arg1, arg2, arg3, arg4, arg5, arg6) \
              {DbgPrint(string, arg1, arg2, arg3, arg4, arg5, arg6); }

#ifdef DEBUG_UNIX
#define DbgPrint printf
#else
#define DbgPrint(string)
#endif
#define KeBugCheck(FP_EMULATION_ERROR) return


#else

#define FP_EMULATION_ERROR0(string) \
              { fprintf (stderr, string); exit (1); }
#define FP_EMULATION_ERROR1(string, arg) \
             { fprintf (stderr, string, arg); \
             exit (1); }
#define FP_EMULATION_ERROR2(string, arg1, arg2) \
             { fprintf (stderr, string, arg1, arg2); \
             exit (1); }
#define FP_EMULATION_ERROR3(string, arg1, arg2, arg3) \
             { fprintf (stderr, string, arg1, arg2, arg3); \
             exit (1); }
#define FP_EMULATION_ERROR4(string, arg1, arg2, arg3, arg4) \
             { fprintf (stderr, string, arg1, arg2, arg3, arg4); \
             exit (1); }
#define FP_EMULATION_ERROR5(string, arg1, arg2, arg3, arg4, arg5) \
             { fprintf (stderr, string, arg1, arg2, arg3, arg4, arg5); \
             exit (1); }
#define FP_EMULATION_ERROR6(string, arg1, arg2, arg3, arg4, arg5, arg6) \
             { fprintf (stderr, string, arg1, arg2, arg3, arg4, arg5, arg6); \
             exit (1); }

#define FP_EMULATION_PRINT0(string) \
             { printf (string); \
             fflush (stdout); }
#define FP_EMULATION_PRINT1(string, arg) \
             { printf (string, arg); \
             fflush (stdout); }
#define FP_EMULATION_PRINT2(string, arg1, arg2) \
             { printf (string, arg1, arg2); \
             fflush (stdout); }
#define FP_EMULATION_PRINT3(string, arg1, arg2, arg3) \
             { printf (string, arg1, arg2, arg3); \
             fflush (stdout); }
#define FP_EMULATION_PRINT4(string, arg1, arg2, arg3, arg4) \
             { printf (string, arg1, arg2, arg3, arg4); \
             fflush (stdout); }
#define FP_EMULATION_PRINT5(string, arg1, arg2, arg3, arg4, arg5) \
             { printf (string, arg1, arg2, arg3, arg4, arg5); \
             fflush (stdout); }
#define FP_EMULATION_PRINT6(string, arg1, arg2, arg3, arg4, arg5, arg6) \
             { printf (string, arg1, arg2, arg3, arg4, arg5, arg6); \
             fflush (stdout); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\fehelper.h ===
/******************************
Intel Confidential
******************************/

#ifndef _EM_HELPER_H
#define _EM_HELPER_H

#include "fepublic.h"
#undef FP_QNAN
#undef FP_SNAN

/***************************************************************************
defines to get rid of ps in the prototypes and the 
definitions in EM_helper.c
***************************************************************************/

#define fp_reg_read_hi(arg1) \
        fp82_reg_read_hi(EM_state_type *ps, arg1)
#define fp_reg_read_lo(arg1) \
        fp82_reg_read_lo(EM_state_type *ps, arg1)

#define fp_decode_environment(arg1, arg2, arg3) \
        fp82_fp_decode_environment(EM_state_type *ps, arg1, arg2, arg3)

#define fp_ieee_rnd_to_int(arg1, arg2) \
        fp82_fp_ieee_rnd_to_int(EM_state_type *ps, arg1, arg2) 

#define fp_ieee_rnd_to_int_sp(arg1, arg2, arg3) \
        fp82_fp_ieee_rnd_to_int_sp(EM_state_type *ps, arg1, arg2, arg3) 

#define fp_ieee_round_sp(arg1, arg2, arg3) \
        fp82_fp_ieee_round_sp(EM_state_type *ps, arg1, arg2, arg3)

#define fp_ieee_round(arg1,arg2) \
        fp82_fp_ieee_round(EM_state_type *ps, arg1, arg2)

#define fp_reg_disabled(arg1, arg2, arg3, arg4) \
        fp82_fp_reg_disabled(EM_state_type *ps, arg1, arg2, arg3, arg4)

#define fminmax_exception_fault_check(arg1, arg2, arg3, arg4) \
        fp82_fminmax_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4)
#define fpminmax_exception_fault_check(arg1, arg2, arg3, arg4) \
        fp82_fpminmax_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4)

#define fcmp_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fcmp_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4, arg5) 
#define fpcmp_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fpcmp_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4, arg5) 

#define fcvt_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fcvt_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4, arg5) 

#define fpcvt_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fpcvt_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4, arg5) 

#define fpma_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fpma_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4, arg5) 
    
#define fma_exception_fault_check(arg1, arg2, arg3, arg4, arg5, arg6) \
        fp82_fma_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4, arg5, arg6) 

#define fms_fnma_exception_fault_check(arg1, arg2, arg3, arg4, arg5, arg6) \
        fp82_fms_fnma_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4, arg5, arg6) 

#define fpms_fpnma_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fpms_fpnma_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4, arg5) 

#define frcpa_exception_fault_check(arg1, arg2, arg3, arg4) \
        fp82_frcpa_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4) 
    
#define fprcpa_exception_fault_check(arg1, arg2, arg3, arg4, arg5) \
        fp82_fprcpa_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4, arg5) 

#define frsqrta_exception_fault_check(arg1, arg2, arg3) \
        fp82_frsqrta_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3) 
    
#define fprsqrta_exception_fault_check(arg1, arg2, arg3, arg4) \
        fp82_fprsqrta_exception_fault_check(EM_state_type *ps, arg1, arg2, arg3, arg4) 
    
#define fp_update_fpsr(arg1, arg2)     fp82_fp_update_fpsr(EM_state_type *ps, arg1, arg2)
#define fp_update_psr(arg1)            fp82_fp_update_psr(EM_state_type *ps, arg1)



/* Function Prototypes for Helper functions */

#define SET_STATUS_FLAG(status_flag) { \
   status_flag = 1; \
}

#define CLEAR_STATUS_FLAG(status_flag) { \
   status_flag = 0; \
}



// helper functions declarations 

EM_uint_t
fp_extract_bits(
   EM_uint64_t  input_value,
   unsigned int hi_bound,
   unsigned int lo_bound);

EM_uint64_t
fp_concatenate(EM_uint_t hi_val, EM_uint_t lo_val);

INLINE EM_boolean_t
fp_equal(
   EM_fp_reg_type fr1, EM_fp_reg_type fr2);

INLINE EM_boolean_t
fp_less_than(
   EM_fp_reg_type fr1, 
   EM_fp_reg_type fr2);

INLINE EM_boolean_t
fp_lesser_or_equal(
   EM_fp_reg_type fr1, EM_fp_reg_type fr2);

INLINE EM_boolean_t
fp_unordered(
   EM_fp_reg_type fr1, EM_fp_reg_type fr2);

EM_uint_t
fp82_fp_decode_fault(
   EM_tmp_fp_env_type tmp_fp_env);

EM_uint_t
fp82_fp_decode_trap(
   EM_tmp_fp_env_type tmp_fp_env);

// MACH
void
fp_decode_environment(
   EM_opcode_pc_type pc,
   EM_opcode_sf_type sf,
   EM_tmp_fp_env_type *tmp_fp_env);

EM_uint_t
fp_reg_disabled(
   EM_uint_t f1,
   EM_uint_t f2,
   EM_uint_t f3,
   EM_uint_t f4);

INLINE EM_boolean_t
fp_is_nan_or_inf(
   EM_fp_reg_type tmp_res);

INLINE EM_fp_reg_type
fp_dp_to_fr(
   EM_fp_dp_type tmp_res);

INLINE EM_fp_dp_type
fp_add(
   EM_fp_dp_type fp_dp, EM_fp_reg_type fr2, 
   EM_tmp_fp_env_type tmp_fp_env);

INLINE void
fcmp_exception_fault_check(
   EM_fp_reg_specifier f2,
   EM_fp_reg_specifier f3,
   EM_opcode_frel_type frel,
   EM_opcode_sf_type   sf,   
   EM_tmp_fp_env_type  *tmp_fp_env);

INLINE void
fpcmp_exception_fault_check(
   EM_fp_reg_specifier f2,
   EM_fp_reg_specifier f3,
   EM_opcode_frel_type frel,
   EM_opcode_sf_type   sf,
   EM_tmp_fp_env_type  *tmp_fp_env);

INLINE EM_fp_reg_type
fcvt_exception_fault_check(
   EM_fp_reg_specifier f2, 
   EM_opcode_sf_type   sf,
   EM_boolean_t        signed_form,
   EM_boolean_t        trunc_form, 
   EM_tmp_fp_env_type  *tmp_fp_env);

EM_pair_fp_reg_type
fpcvt_exception_fault_check(
   EM_fp_reg_specifier f2, 
   EM_opcode_sf_type   sf, 
   EM_boolean_t        signed_form,
   EM_boolean_t        trunc_form, 
   EM_tmp_fp_env_type  *tmp_fp_env);

EM_fp_reg_type
fma_exception_fault_check(
   EM_fp_reg_specifier f2,
   EM_fp_reg_specifier f3,
   EM_fp_reg_specifier f4,
   EM_opcode_pc_type   pc,
   EM_opcode_sf_type   sf, 
   EM_tmp_fp_env_type  *tmp_fp_env);

EM_pair_fp_reg_type
fpma_exception_fault_check(
   EM_fp_reg_specifier f2,
   EM_fp_reg_specifier f3,
   EM_fp_reg_specifier f4,
   EM_opcode_sf_type   sf,
   EM_tmp_fp_env_type *tmp_fp_env);

INLINE void
fminmax_exception_fault_check(
   EM_fp_reg_specifier f2,
   EM_fp_reg_specifier f3,
   EM_opcode_sf_type   sf,  
   EM_tmp_fp_env_type  *tmp_fp_env);


INLINE void 
fpminmax_exception_fault_check(
   EM_uint_t          f2,
   EM_uint_t          f3,
   EM_opcode_sf_type  sf,
   EM_tmp_fp_env_type *tmp_fp_env);

EM_fp_reg_type
fms_fnma_exception_fault_check(
   EM_fp_reg_specifier f2,
   EM_fp_reg_specifier f3,
   EM_fp_reg_specifier f4,
   EM_opcode_pc_type   pc,
   EM_opcode_sf_type   sf, 
   EM_tmp_fp_env_type  *tmp_fp_env);


EM_pair_fp_reg_type
fpms_fpnma_exception_fault_check(
   EM_fp_reg_specifier f2,
   EM_fp_reg_specifier f3,
   EM_fp_reg_specifier f4,
   EM_opcode_sf_type   sf,
   EM_tmp_fp_env_type  *tmp_fp_env);


INLINE EM_boolean_t
fp_flag_set_is_enabled(
   EM_uint_t flags, EM_uint_t traps);
 
INLINE EM_boolean_t
fp_flag_set_is_clear(
   EM_uint_t flags, EM_uint_t traps);

INLINE EM_fp_dp_type
fp_max_or_infinity(
   EM_uint_t sign,  EM_tmp_fp_env_type *tmp_fp_env,
   EM_uint_t e_max, EM_uint128_t       max_significand);

INLINE EM_fp_dp_type
fp_mul(
   EM_fp_reg_type fr3, EM_fp_reg_type fr4);

INLINE EM_fp_reg_type
fp_normalize(EM_fp_reg_type freg);

INLINE EM_fp_dp_type
fp_normalize_dp(EM_fp_dp_type fp_dp);

EM_fp_dp_type
fp82_fp_fr_to_dp(EM_fp_reg_type fr1);

INLINE EM_memory_type
fr_to_mem4_bias_adjust(EM_fp_reg_type freg);

EM_fp_reg_type
frcpa_exception_fault_check(
   EM_fp_reg_specifier f2,
   EM_fp_reg_specifier f3,
   EM_opcode_sf_type   sf,
   EM_tmp_fp_env_type  *tmp_fp_env);

EM_pair_fp_reg_type
fprcpa_exception_fault_check(
   EM_fp_reg_specifier     f2,
   EM_fp_reg_specifier     f3,
   EM_opcode_sf_type       sf,
   EM_tmp_fp_env_type      *tmp_fp_env, 
   EM_limits_check_fprcpa  *limits_check);

EM_fp_reg_type
frsqrta_exception_fault_check(
   EM_fp_reg_specifier f3, 
   EM_opcode_sf_type   sf,
   EM_tmp_fp_env_type  *tmp_fp_env);

EM_pair_fp_reg_type
fprsqrta_exception_fault_check(
   EM_fp_reg_specifier       f3, 
   EM_opcode_sf_type         sf,
   EM_tmp_fp_env_type        *tmp_fp_env,
   EM_limits_check_fprsqrta  *limits_check);

EM_fp_reg_type
fp_ieee_rnd_to_int(
   EM_fp_reg_type     fr1, 
   EM_tmp_fp_env_type *tmp_fp_env);

EM_fp_reg_type
fp_ieee_rnd_to_int_sp(
    EM_fp_reg_type     fr2, 
    EM_simd_hilo       hilo,
    EM_tmp_fp_env_type *tmp_fp_env);

EM_fp_reg_type
fp_ieee_round(
   EM_fp_dp_type      fp_dp,
   EM_tmp_fp_env_type *tmp_fp_env);

INLINE EM_boolean_t
fp_is_finite(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_inf(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_inf_dp(EM_fp_dp_type tmp_res);

INLINE EM_boolean_t
fp_is_nan(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_nan_dp(EM_fp_dp_type tmp_res);

INLINE EM_boolean_t
fp_is_natval(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_neg_dp(EM_fp_dp_type tmp_res);

INLINE EM_boolean_t
fp_is_neg_inf(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_neg_non_zero(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_normal(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_normal_dp(EM_fp_dp_type tmp_res);

INLINE EM_boolean_t
fp_is_pos_dp(EM_fp_dp_type tmp_res);

INLINE EM_boolean_t
fp_is_pos_inf(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_pos_non_zero(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_pseudo_zero(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_qnan(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_snan(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_unorm(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_unsupported(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_unsupported_dp(EM_fp_dp_type tmp_res);

INLINE EM_boolean_t
fp_is_zero(EM_fp_reg_type freg);

INLINE EM_boolean_t
fp_is_zero_dp(EM_fp_dp_type tmp_res);

EM_int_t
fp82_fp_U64_lead0(EM_uint64_t value);

INLINE EM_int_t
fp_U128_lead0(EM_uint128_t value);

EM_int_t
fp82_fp_U256_lead0(EM_uint256_t value);

EM_fp_reg_type
fp_mem_to_fr_format(
   EM_memory_type mem,
   EM_uint_t      size, 
   EM_uint_t      integer_form);

EM_memory_type
fp_fr_to_mem_format(
   EM_fp_reg_type freg,
   EM_uint_t      size, 
   EM_uint_t      integer_form);

INLINE EM_fp_reg_type
fp_make_quiet_nan(EM_fp_reg_type freg);

EM_boolean_t
fp82_fp_raise_fault(EM_tmp_fp_env_type tmp_fp_env);

EM_boolean_t
fp82_fp_raise_traps(EM_tmp_fp_env_type tmp_fp_env);

INLINE EM_fp_reg_type
fp_reg_read(EM_fp_reg_type freg);

INLINE EM_fp_reg_type
fp_reg_read_hi(EM_uint_t freg);

INLINE EM_fp_reg_type
fp_reg_read_lo(EM_uint_t freg);

INLINE EM_uint_t
fp_single(EM_fp_reg_type freg);

EM_uint_t
fp_ieee_round_sp(
   EM_fp_dp_type      fp_dp,
   EM_simd_hilo       hilo,
   EM_tmp_fp_env_type *tmp_fp_env);

INLINE void
fp_ieee_to_hilo(
    EM_simd_hilo       hilo,
    EM_tmp_fp_env_type *tmp_fp_env);

EM_uint_t fp82_no_bytes(char *str);

EM_uint_t fp82_not_int(char *str);

INLINE void
fp_update_fpsr(
   EM_opcode_sf_type  sf,
   EM_tmp_fp_env_type tmp_fp_env);

INLINE void
fp_update_psr(
   EM_uint_t dest_freg);

/* Basic Types Support Functions */

/* 128-bit unsigned int support routines */

EM_boolean_t
fp82_fp_U128_eq(EM_uint128_t value1, EM_uint128_t value2);

static INLINE EM_boolean_t
fp_U128_ge(EM_uint128_t value1, EM_uint128_t value2);

static INLINE EM_boolean_t
fp_U128_gt(EM_uint128_t value1, EM_uint128_t value2);

static INLINE EM_boolean_t
fp_U128_le(EM_uint128_t value1, EM_uint128_t value2);

EM_boolean_t
fp82_fp_U128_lt(EM_uint128_t value1, EM_uint128_t value2);

EM_boolean_t
fp82_ne_U128(EM_uint128_t value1, EM_uint128_t value2);

static INLINE EM_uint128_t
bld_U128(EM_uint64_t hi, EM_uint64_t lo);

EM_uint128_t
fp82_fp_U128_lsh(EM_uint128_t value, EM_uint_t count);

EM_uint128_t
fp82_fp_U128_rsh(EM_uint128_t value, EM_uint_t count);
 
EM_uint128_t
fp82_fp_U64_x_U64_to_U128(EM_uint64_t value1, EM_uint64_t value2);
 
INLINE EM_uint128_t
fp_I64_x_I64_to_I128(EM_uint64_t value1, EM_uint64_t value2);

EM_uint128_t
fp82_fp_U128_inc(EM_uint128_t value1);

static INLINE EM_uint128_t
fp_U128_neg(EM_uint128_t value);

EM_uint128_t
fp82_fp_U128_add(EM_uint128_t value1, EM_uint128_t value2);

EM_uint128_t
fp82_fp_U128_bor(EM_uint128_t value1, EM_uint128_t value2);

EM_uint128_t
fp82_fp_U128_band(EM_uint128_t value1, EM_uint128_t value2);

/* 256-bit unsigned int support routines */

EM_boolean_t
fp82_fp_U256_eq(EM_uint256_t value1, EM_uint256_t value2);

EM_boolean_t
fp82_ne_U256(EM_uint256_t value1, EM_uint256_t value2);

static INLINE EM_uint256_t
bld_U256(
   EM_uint64_t hh, EM_uint64_t hl, 
   EM_uint64_t lh, EM_uint64_t ll);

EM_uint256_t
fp82_fp_U256_lsh(EM_uint256_t value, EM_uint_t count);

EM_uint256_t
fp82_fp_U256_rsh(EM_uint256_t value, EM_uint_t count);

EM_uint256_t
fp82_fp_U256_inc(EM_uint256_t value1);

static INLINE EM_uint256_t
fp_U256_neg(EM_uint256_t value);

static INLINE EM_uint256_t
fp_U256_add(EM_uint256_t value1,
            EM_uint256_t value2);

/* Basic Conversion Routines */

INLINE EM_uint128_t
fp_U64_to_U128(EM_uint64_t value);

INLINE EM_uint64_t
fp_U128_to_U64(EM_uint128_t value);

static INLINE EM_uint256_t
fp_U64_to_U256(EM_uint64_t value);

static INLINE EM_uint64_t
fp_U256_to_U64(EM_uint256_t value);

EM_uint256_t
fp82_fp_U128_to_U256(EM_uint128_t value);

static INLINE EM_uint128_t
fp_U256_to_U128(EM_uint256_t value);

EM_boolean_t
is_reserved_field(
   EM_opcode_type    calling_instruction,
   EM_opcode_sf_type sf,
   EM_uint_t         val) ;



/* Basic Constants */

static const EM_uint64_t  U64_0                  = CONST_FORMAT( 0x0000000000000000 );
static const EM_uint64_t  U64_1                  = CONST_FORMAT( 0x0000000000000001 );
static const EM_uint64_t  U64_0x0000000080000000 = CONST_FORMAT( 0x0000000080000000 );
static const EM_uint64_t  U64_0x2000000000000000 = CONST_FORMAT( 0x2000000000000000 );
static const EM_uint64_t  U64_0x4000000000000000 = CONST_FORMAT( 0x4000000000000000 );
static const EM_uint64_t  U64_0x8000000000000000 = CONST_FORMAT( 0x8000000000000000 );
static const EM_uint64_t  U64_0xC000000000000000 = CONST_FORMAT( 0xC000000000000000 );
static const EM_uint64_t  U64_0x3FFFFFFFFFFFFFFF = CONST_FORMAT( 0x3FFFFFFFFFFFFFFF );
static const EM_uint64_t  U64_0x7FFFFFFFFFFFFFFF = CONST_FORMAT( 0x7FFFFFFFFFFFFFFF );
static const EM_uint64_t  U64_0xFFFFFF0000000000 = CONST_FORMAT( 0xFFFFFF0000000000 );
static const EM_uint64_t  U64_0xFFFFFFFFFFFFF800 = CONST_FORMAT( 0xFFFFFFFFFFFFF800 );
static const EM_uint64_t  U64_0xFFFFFFFFFFFFFFFF = CONST_FORMAT( 0xFFFFFFFFFFFFFFFF );
static const EM_uint64_t  U64_0xFFFFFFFF00000000 = CONST_FORMAT( 0xFFFFFFFF00000000 );
static const EM_uint64_t  U64_0xFFFF000000000000 = CONST_FORMAT( 0xFFFF000000000000 );
static const EM_uint64_t  U64_0xFF00000000000000 = CONST_FORMAT( 0xFF00000000000000 );


static const EM_uint128_t U128_0
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
                    };



static const EM_uint128_t U128_0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 
                    = {
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF )
                    };


static const EM_uint128_t U128_0x00000000000000000000000000003FFF 
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000003FFF ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000003FFF ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
                    };


static const EM_uint128_t U128_0x00000000000000000000000000007FFF 
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000007FFF ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000007FFF ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
                    };


static const EM_uint128_t U128_0x00000000000000000000000000004000 
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000004000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000004000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
                    };


static const EM_uint128_t U128_0x00000000000000000000000000008000 
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000008000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000008000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
                    };


static const EM_uint128_t U128_0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF8000 
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0x0000000000008000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000008000 ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
#endif
                    };


static const EM_uint128_t U128_0x40000000000000000000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x4000000000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x4000000000000000 ),
#endif
                    };


static const EM_uint128_t U128_0x00000100000000000000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000010000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000010000000000 ),
#endif
                    };


static const EM_uint128_t U128_0x00000080000000000000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000008000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000008000000000 ),
#endif
                    };


static const EM_uint128_t U128_0x00000000000008000000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000000000000800 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000000800 ),
#endif
                    };


static const EM_uint128_t U128_0x00000000000004000000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000000000000400 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000000400 ),
#endif
                    };


static const EM_uint128_t U128_0x00000000000000010000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000000000000001 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000000001 ),
#endif
                    };


static const EM_uint128_t U128_0x00000000000000008000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x8000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x8000000000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
                    };


static const EM_uint128_t U128_0x00000000000000007FFFFFFFFFFFFFFF
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x7FFFFFFFFFFFFFFF ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x7FFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
                    };


static const EM_uint128_t U128_0x0000000000000000FFFFFFFFFFFFFFFF
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
                    };


static const EM_uint128_t U128_0xFFFFFFFFFFFFFFFF0000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
#endif
                    };


static const EM_uint128_t U128_0xFFFFFFFFFFFFFFFF8000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0x8000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x8000000000000000 ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
#endif
                    };


static const EM_uint128_t U128_0x00000000000003FFFFFFFFFFFFFFFFFF
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x00000000000003FF ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0x00000000000003FF ),
#endif
                    };


static const EM_uint128_t U128_0x00000000000007FFFFFFFFFFFFFFFFFF
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x00000000000007FF ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0x00000000000007FF ),
#endif
                    };


static const EM_uint128_t U128_0xFFFFFFFFFFFFF8000000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0xFFFFFFFFFFFFF800 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFF800 ),
#endif
                    };


static const EM_uint128_t U128_0xFFFFFFFFFFFFFC000000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0xFFFFFFFFFFFFFC00 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFFC00 ),
#endif
                    };


static const EM_uint128_t U128_0x0000007FFFFFFFFFFFFFFFFFFFFFFFFF
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000007FFFFFFFFF ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0x0000007FFFFFFFFF ),
#endif
                    };


static const EM_uint128_t U128_0x000000FFFFFFFFFFFFFFFFFFFFFFFFFF
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x000000FFFFFFFFFF ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0x000000FFFFFFFFFF ),
#endif
                    };


static const EM_uint128_t U128_0xFFFFFF00000000000000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0xFFFFFF0000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0xFFFFFF0000000000 ),
#endif
                    };


static const EM_uint128_t U128_0xFFFFFF80000000000000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0xFFFFFF8000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0xFFFFFF8000000000 ),
#endif
                    };


static const EM_uint128_t U128_0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x7FFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0x7FFFFFFFFFFFFFFF ),
#endif
                    };


static const EM_uint128_t U128_0xC0000000000000000000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0xC000000000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0xC000000000000000 ),
#endif
                    };


static const EM_uint128_t U128_0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x3FFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0xFFFFFFFFFFFFFFFF ),
                        CONST_FORMAT( 0x3FFFFFFFFFFFFFFF ),
#endif
                    };


static const EM_uint128_t U128_0x80000000000000000000000000000000
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x8000000000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x8000000000000000 ),
#endif
                    };


static const EM_uint256_t U256_0
                    = {
#ifdef BIG_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
#ifdef LITTLE_ENDIAN
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
                        CONST_FORMAT( 0x0000000000000000 ),
#endif
                    };


/* Floating Sign Constants */
 
static const EM_uint_t FP_SIGN_POSITIVE = 0;
 
static const EM_uint_t FP_SIGN_NEGATIVE = 1;

/* Floating Exponent Constants */
 
static const EM_uint_t FP_SGL_BIAS       = 0x0007F;
static const EM_uint_t FP_DBL_BIAS       = 0x003FF;
static const EM_uint_t FP_EXT_BIAS       = 0x03FFF;
static const EM_uint_t FP_REG_BIAS       = 0x0FFFF;
static const EM_uint_t FP_DP_BIAS        = 0x3FFFF;
 
static const EM_uint_t FP_SGL_EXP_ONES   = 0x000FF;
static const EM_uint_t FP_DBL_EXP_ONES   = 0x007FF;
static const EM_uint_t FP_EXT_EXP_ONES   = 0x07FFF;
static const EM_uint_t FP_REG_EXP_ONES   = 0x1FFFF;
static const EM_uint_t FP_DP_EXP_ONES    = 0x7FFFF;

static const EM_uint_t FP_SGL_EXP_WIDTH  = 8;
static const EM_uint_t FP_DBL_EXP_WIDTH  = 11;
static const EM_uint_t FP_EXT_EXP_WIDTH  = 15;
static const EM_uint_t FP_REG_EXP_WIDTH  = 17;

static const EM_uint_t FP_SGL_SIGNIFICAND_WIDTH  = 23;
static const EM_uint_t FP_DBL_SIGNIFICAND_WIDTH  = 52;
static const EM_uint_t FP_EXT_SIGNIFICAND_WIDTH  = 64;
static const EM_uint_t FP_REG_SIGNIFICAND_WIDTH  = 64;

static const EM_uint_t FP_REG_EXP_HALF   = 0x0FFFE;
 
static const EM_uint_t FP_INTEGER_EXP    = 0x1003E;
 
static const EM_uint_t FP_DP_INTEGER_EXP = 0x4003E;

/* Floating Constants */
 
static const EM_fp_reg_type
    FP_ZERO            = {CONST_FORMAT( 0x0000000000000000 ), 0x00000, 0x0 }; /* 0.0 */

static const EM_fp_reg_type
    FP_NEG_ZERO            = {CONST_FORMAT( 0x0000000000000000 ), 0x00000, 0x1 }; /* -0.0 */

static const EM_fp_reg_type
    FP_HALF            = {CONST_FORMAT( 0x8000000000000000 ), 0x0FFFE, 0x0 }; /* 0.5 */
 
static const EM_fp_reg_type
    FP_ONE             = {CONST_FORMAT( 0x8000000000000000 ), 0x0FFFF, 0x0 }; /* 1.0 */

static const EM_fp_reg_type
    FP_ONE_PAIR        = {CONST_FORMAT( 0x3F8000003F800000 ), 0x1003E, 0x0 };
/* Pair of ones for SIMD non-memory ops */

static const EM_fp_reg_type
    FP_INFINITY        = {CONST_FORMAT( 0x8000000000000000 ), 0x1FFFF, 0x0 }; /* Inf */
 
static const EM_fp_reg_type
    FP_QNAN            = {CONST_FORMAT( 0xC000000000000000 ), 0x1FFFF, 0x1 }; /* QNaN Indefinite */
 
static const EM_fp_reg_type
    FP_SNAN            = {CONST_FORMAT( 0x8000000000000000 ), 0x1FFFF, 0x0 }; /* SNaN*/
 
static const EM_fp_reg_type
    FP_POS_2_TO_63     = {CONST_FORMAT( 0x8000000000000000 ), 0x1003E, 0x0 }; /* 2.0**63 */
 
static const EM_fp_reg_type
    FP_NEG_2_TO_63     = {CONST_FORMAT( 0x8000000000000000 ), 0x1003E, 0x1 }; /* -2.0**63 */
 
static const EM_fp_reg_type
    FP_POS_2_TO_64     = {CONST_FORMAT( 0x8000000000000000 ), 0x1003F, 0x0 }; /* 2.0**64 */
 
static const EM_fp_reg_type
    FP_NEG_2_TO_64     = {CONST_FORMAT( 0x8000000000000000 ), 0x1003F, 0x1 }; /* -2.0**64 */
 
static const EM_fp_reg_type
    FP_POS_2_TO_31     = {CONST_FORMAT( 0x0000000080000000 ), 0x1003E, 0x0 }; /* 2.0**31 */
 
static const EM_fp_reg_type
    FP_NEG_2_TO_31     = {CONST_FORMAT( 0x0000000080000000 ), 0x1003E, 0x1 }; /* -2.0**31 */
 
static const EM_fp_reg_type
    FP_POS_2_TO_32     = {CONST_FORMAT( 0x0000000080000000 ), 0x1003F, 0x0 }; /* 2.0**32 */
 
static const EM_fp_reg_type
    FP_NEQ_2_TO_32     = {CONST_FORMAT( 0x0000000080000000 ), 0x1003F, 0x1 }; /* -2.0**32 */
 
static const EM_fp_reg_type
    NATVAL = {CONST_FORMAT( 0x0000000000000000 ), 0x1FFFE, 0x0 }; /* NaTVal */

static const EM_uint64_t
   INTEGER_INDEFINITE = CONST_FORMAT( 0x8000000000000000 ); /* -(2**63) */

static const EM_uint_t
   INTEGER_INDEFINITE_32_BIT = 0x80000000; /* */








/******************************************************************************/
/* Define macros to simplify access to the fp82_ functions.  This is done so  */
/*  the namespace doesn't get cluttered, while retaining convenient access.   */
/*  The FP82_NO_SHORTCUTS macro can be defined to prevent creation of these.  */
/******************************************************************************/

#ifndef FP82_NO_SHORTCUTS
#define fp_U64_x_U64_to_U128         fp82_fp_U64_x_U64_to_U128
#define fp_U128_add                  fp82_fp_U128_add 
#define fp_U128_band                 fp82_fp_U128_band
#define fp_U128_bor                  fp82_fp_U128_bor
#define fp_U128_eq                   fp82_fp_U128_eq
#define fp_U256_eq                   fp82_fp_U256_eq
#define fp_U128_to_U256              fp82_fp_U128_to_U256
#define fp_U128_lt                   fp82_fp_U128_lt
#define fp_U128_inc                  fp82_fp_U128_inc
#define fp_U256_inc                  fp82_fp_U256_inc
#define fp_U128_rsh                  fp82_fp_U128_rsh
#define fp_U128_lsh                  fp82_fp_U128_lsh
#define fp_U256_rsh                  fp82_fp_U256_rsh
#define fp_U256_lsh                  fp82_fp_U256_lsh
#define fp_U256_rsh                  fp82_fp_U256_rsh
#define fp_U64_lead0                 fp82_fp_U64_lead0
#define fp_U256_lead0                fp82_fp_U256_lead0
#define fp_raise_fault               fp82_fp_raise_fault
#define fp_raise_traps               fp82_fp_raise_traps
#define fp_decode_fault              fp82_fp_decode_fault
#define fp_decode_trap               fp82_fp_decode_trap
#define fp_fr_to_dp                  fp82_fp_fr_to_dp
#endif /* FP82_NO_SHORTCUTS */

#endif /* _EM_HELPER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\fepublic.h ===
/******************************
Intel Confidential
******************************/

#ifndef _EM_PUBLIC_H
#define _EM_PUBLIC_H

// MACH
// #define IN_KERNEL

// MACH
#define LITTLE_ENDIAN

#ifndef INLINE
#define INLINE
#endif

#if !(defined(BIG_ENDIAN) || defined(LITTLE_ENDIAN))
    #error Endianness not established; define BIG_ENDIAN or LITTLE_ENDIAN
#endif


/************************/
/* System Include Files */
/************************/
 
#include <stdio.h>
#include <memory.h>
#ifndef unix
#include <setjmp.h>
#endif
 
/*********************/
/* Type Declarations */
/*********************/

#include "fetypes.h"
#include "festate.h"
#include "fesupprt.h"
#include "fehelper.h"
#include "feproto.h"

#define U64_lsh(val, bits)  ((bits) > 63 ? 0 : (EM_uint64_t)(val) << (bits))
#define fp_U64_rsh(val, bits)  ((bits) > 63 ? 0 : (EM_uint64_t)(val) >> (bits))
#define LL_SSHR(val, bits)  ((EM_uint64_t)(val) >> ((bits) > 63 ? 63 : (bits)))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\feproto.h ===
/******************************
Intel Confidential
******************************/

#ifndef _EM_PROTOTYPES_H
#define _EM_PROTOTYPES_H

#ifndef INLINE
#define INLINE
#endif

#if !(defined(BIG_ENDIAN) || defined(LITTLE_ENDIAN))
    #error Endianness not established; define BIG_ENDIAN or LITTLE_ENDIAN
#endif


/**********************************************/
/* Assembler Supported Instruction Prototypes */
/**********************************************/

/* Floating-point Absolute Maximum */
void
fp82_famax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

/* Floating-point Parallel Absolute Maximum */

void
fp82_fpamax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

/* Floating-point Absolute Minimum */
void
fp82_famin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Floating-point Parallel Absolute Minimum */

void
fp82_fpamin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Floating-point Compare */

void
fp82_fcmp_eq(EM_state_type *ps,
    EM_opcode_ctype_type ctype,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_pred_reg_specifier p1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fcmp_lt(EM_state_type *ps,
    EM_opcode_ctype_type ctype,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_pred_reg_specifier p1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fcmp_le(EM_state_type *ps,
    EM_opcode_ctype_type ctype,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_pred_reg_specifier p1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


void
fp82_fcmp_unord(EM_state_type *ps,
    EM_opcode_ctype_type ctype,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_pred_reg_specifier p1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Floating-point Paralel Compare */

void
fp82_fpcmp_eq(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_lt(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_le(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_unord(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_neq(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_nlt(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_nle(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

void
fp82_fpcmp_ord(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Convert Floating-point to Integer */

void
fp82_fcvt_fx(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);

void
fp82_fcvt_fx_trunc(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);

void
fp82_fcvt_fxu(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);

void
fp82_fcvt_fxu_trunc(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);


/* Parallel Convert Floating-point to Integer */

void
fp82_fpcvt_fx(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);

void
fp82_fpcvt_fx_trunc(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);

void
fp82_fpcvt_fxu(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);

void
fp82_fpcvt_fxu_trunc(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2);



/* Floating-point Multiply Add */

void
fp82_fma(EM_state_type *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
    EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2);


/* Floating Point Parallel Multiply Add */
void
fp82_fpma(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
    EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2);


/* Floating-point Maximum */
void
fp82_fmax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Floating-point Parallel Maximum */
void
fp82_fpmax(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

/* Floating-point Minimum */
void
fp82_fmin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Floating-point Parallel Minimum */
void
fp82_fpmin(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);


/* Floating-point Multiply Subtract */
void
fp82_fms(EM_state_type *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
     EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2);


/* Floating-point Parallel Multiply Subtract */
void
fp82_fpms(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
    EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2);



/* Floating-point Negative Multiply Add */
void
fp82_fnma(EM_state_type *ps,
    EM_opcode_pc_type pc,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
     EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2);


/* Floating-point Parallel Negative Multiply Add */

void
fp82_fpnma(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_fp_reg_specifier f3,
     EM_fp_reg_specifier f4,
    EM_fp_reg_specifier f2);


/* Floating-point Reciprocal Approximation */
void
fp82_frcpa(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

/* Floating-point Parallel Reciprocal Approximation */
void
fp82_fprcpa(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f2,
    EM_fp_reg_specifier f3);

/* Floating-point Reciprocal Square Root Approximation */
void
fp82_frsqrta(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f3);


/* Floating-point Parallel Reciprocal Square Root Approximation */
void
fp82_fprsqrta(EM_state_type *ps,
    EM_opcode_sf_type sf,
    EM_pred_reg_specifier qp,
    EM_fp_reg_specifier f1,
    EM_pred_reg_specifier p2,
    EM_fp_reg_specifier f3);


/******************************************************************************/
/* Define macros to simplify access to the fp82_ functions.  This is done so  */
/*  the namespace doesn't get cluttered, while retaining convenient access.   */
/*  The FP82_NO_SHORTCUTS macro can be defined to prevent creation of these.  */
/******************************************************************************/

#ifndef FP82_NO_SHORTCUTS
#define famax           fp82_famax
#define fpamax          fp82_fpamax
#define famin           fp82_famin
#define fpamin          fp82_fpamin

#define fcmp_eq         fp82_fcmp_eq
#define fcmp_lt         fp82_fcmp_lt
#define fcmp_le         fp82_fcmp_le
#define fcmp_unord      fp82_fcmp_unord

#define fpcmp_eq        fp82_fpcmp_eq
#define fpcmp_lt        fp82_fpcmp_lt
#define fpcmp_le        fp82_fpcmp_le
#define fpcmp_unord     fp82_fpcmp_unord
#define fpcmp_neq       fp82_fpcmp_neq
#define fpcmp_nlt       fp82_fpcmp_nlt
#define fpcmp_nle       fp82_fpcmp_nle
#define fpcmp_ord       fp82_fpcmp_ord

#define fcvt_fx         fp82_fcvt_fx
#define fcvt_fx_trunc   fp82_fcvt_fx_trunc
#define fcvt_fxu        fp82_fcvt_fxu
#define fcvt_fxu_trunc  fp82_fcvt_fxu_trunc

#define fpcvt_fxu_trunc fp82_fpcvt_fxu_trunc
#define fpcvt_fxu       fp82_fpcvt_fxu
#define fpcvt_fx        fp82_fpcvt_fx
#define fpcvt_fx_trunc  fp82_fpcvt_fx_trunc


#define fma             fp82_fma
#define fpma            fp82_fpma
#define fmax            fp82_fmax
#define fpmax           fp82_fpmax
#define fmin            fp82_fmin
#define fpmin           fp82_fpmin
#define fms             fp82_fms
#define fpms            fp82_fpms
#define fnma            fp82_fnma
#define fpnma           fp82_fpnma
#define frcpa           fp82_frcpa
#define fprcpa          fp82_fprcpa
#define frsqrta         fp82_frsqrta
#define fprsqrta        fp82_fprsqrta

#endif /* FP82_NO_SHORTCUTS */


#endif /* _EM_PROTOTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\festate.c ===
/******************************
Intel Confidential
******************************/

// MACH
#include "ki.h"

/*****************************/
/* Processor's Global State */
/*****************************/
#include "fetypes.h"

#ifdef GAMBIT

EM_uint_t              GLOBAL_MERCED_RTL=0;
oml_handles_FR_type    oml_FR_handles;
EM_uint_t              GLOBAL_EAS23     =0;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\floatem.h ===
#include "EM_types.h"
#include "EM_support.h"
#include "EM_prototypes.h"

typedef struct _BUNDLE {
  EM_uint64_t BundleLow;
  EM_uint64_t BundleHigh;
} BUNDLE;

#ifdef WIN32_OR_WIN64
typedef struct __declspec(align(16)) _FLOAT128_TYPE {
#else
typedef struct _FLOAT128_TYPE {
#endif
     EM_uint64_t loFlt64;
     EM_uint64_t hiFlt64;
} FLOAT128_TYPE;


typedef struct fp_state_low_preserved_s {
  FLOAT128_TYPE fp_lp[4]; // f2-f5; f2=fp_lp[0], f3=fp_lp[1], ...
} FP_STATE_LOW_PRESERVED;

typedef struct fp_state_low_volatile_s {
  FLOAT128_TYPE fp_lv[10]; // f6-f15; f6=fp_lv[0], f7=fp_lv[1], ...
} FP_STATE_LOW_VOLATILE;

typedef struct fp_state_high_preserved_s {
  FLOAT128_TYPE fp_hp[16]; // f16-f31; f16=fp_hp[0], f17=fp_hp[1], ...
} FP_STATE_HIGH_PRESERVED;

typedef struct fp_state_high_volatile_s {
  FLOAT128_TYPE fp_hv[96]; // f32-f127; f32=fp_hv[0], f33=fp_hv[1], ...
} FP_STATE_HIGH_VOLATILE;

typedef struct fp_state_s {
  __int64 bitmask_low64; // f2-f63
  __int64 bitmask_high64; // f64-f127
  FP_STATE_LOW_PRESERVED *fp_state_low_preserved; // f2-f5
  FP_STATE_LOW_VOLATILE *fp_state_low_volatile; // f6-f15
  FP_STATE_HIGH_PRESERVED *fp_state_high_preserved; // f16-f31
  FP_STATE_HIGH_VOLATILE *fp_state_high_volatile; // f32-f127
} FP_STATE;

typedef struct {
  EM_int64_t retval; // r8
  EM_uint64_t err1; // r9
  EM_uint64_t err2; // r10
  EM_uint64_t err3; // r11
} PAL_RETURN;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\festate.h ===
/******************************
Intel Confidential
******************************/

#ifndef _EM_STATE_H
#define _EM_STATE_H

/*****************************/
/* Processor's State */
/*****************************/

#ifndef FPSR
#define FPSR              ps->state_AR[ar_fpsr].fpsr
#endif

#ifndef FPSR_value
#define FPSR_value        ps->state_AR[ar_fpsr].uint_value
#endif

#ifndef PSR
#define PSR               ps->state_PSR
#endif

#ifndef IP
#define IP                ps->state_IP
#endif

#ifndef AR
#define AR                ps->state_AR
#endif

#ifndef FR
#define FR                ps->state_FR
#endif

#ifndef GR
#define GR                ps->state_GR
#endif

#ifndef PR
#define PR                ps->state_PR
#endif

#ifndef MEM
#define MEM               ps->state_MEM
#endif

#ifndef UM
#define UM                ps->state_PSR
#endif

#define FPSR_traps        (EM_uint_t)((ps->state_AR[ar_fpsr].uint_value>> 0)&0x3F)

#define FPSR_sf0_flags    (EM_uint_t)((ps->state_AR[ar_fpsr].uint_value>>13)&0x3F)
#define FPSR_sf1_flags    (EM_uint_t)((ps->state_AR[ar_fpsr].uint_value>>26)&0x3F)
#define FPSR_sf2_flags    (EM_uint_t)((ps->state_AR[ar_fpsr].uint_value>>39)&0x3F)
#define FPSR_sf3_flags    (EM_uint_t)((ps->state_AR[ar_fpsr].uint_value>>52)&0x3F)

#define FPSR_sf0_controls (EM_uint_t)((ps->state_AR[ar_fpsr].uint_value>> 6)&0x7F)
#define FPSR_sf1_controls (EM_uint_t)((ps->state_AR[ar_fpsr].uint_value>>19)&0x7F)
#define FPSR_sf2_controls (EM_uint_t)((ps->state_AR[ar_fpsr].uint_value>>32)&0x7F)
#define FPSR_sf3_controls (EM_uint_t)((ps->state_AR[ar_fpsr].uint_value>>45)&0x7F)

#define GENERAL_FORM           ps->state_form.general_form
#define DATA_FORM              ps->state_form.data_form
#define CONTROL_FORM           ps->state_form.control_form
#define FP82_FLOATING_FORM     ps->state_form.fp82_floating_form
#define CLEAR_FORM             ps->state_form.clear_form
#define NO_CLEAR_FORM          ps->state_form.no_clear_form

#define HIGH_UNSIGNED_FORM     ps->state_form.high_unsigned_form    
#define LOW_FORM               ps->state_form.low_form    
#define HIGH_FORM              ps->state_form.high_form    
#define NEG_SIGN_FORM          ps->state_form.neg_sign_form
#define SIGN_FORM              ps->state_form.sign_form
#define SIGN_EXP_FORM          ps->state_form.sign_exp_form
#define MIX_L_FORM             ps->state_form.mix_l_form
#define MIX_R_FORM             ps->state_form.mix_r_form
#define MIX_LR_FORM            ps->state_form.mix_lr_form
#define SXT_L_FORM             ps->state_form.sxt_l_form
#define SXT_R_FORM             ps->state_form.sxt_r_form
#define PACK_FORM              ps->state_form.pack_form
#define SWAP_FORM              ps->state_form.swap_form
#define SWAP_NL_FORM           ps->state_form.swap_nl_form
#define SWAP_NR_FORM           ps->state_form.swap_nr_form
#define SIGNED_FORM            ps->state_form.signed_form
#define TRUNC_FORM             ps->state_form.trunc_form
#define UNSIGNED_FORM          ps->state_form.unsigned_form

#define SINGLE_FORM            ps->state_form.single_form
#define DOUBLE_FORM            ps->state_form.double_form
#define EXPONENT_FORM          ps->state_form.exponent_form
#define SIGNIFICAND_FORM       ps->state_form.significand_form

#define NO_BASE_UPDATE_FORM                ps->state_form.no_base_update_form
#define REGISTER_BASE_UPDATE_FORM          ps->state_form.register_base_update_form
#define IMMEDIATE_BASE_UPDATE_FORM         ps->state_form.immediate_base_update_form

#define FCHECK_BRANCH_IMPLEMENTED ps->state_form.fcheck_branch_implemented

/*
The following concern software assistance. For an implementation-determined
software assistance fault or trap to occur (when encountering
denormals MERCED_RTL must be 1. An architecturally-mandated swa
can still occur when MERCED_RTL is 0. Such an assist occurs in frcpa and
fprcpa.
*/

#define MERCED_RTL ps->state_MERCED_RTL

#endif /* _EM_STATE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\fesupprt.c ===
// ******************************
// Intel Confidential
// ******************************


#include <stdarg.h>
#include "ki.h"
#include "fedefs.h"

// MACH
#ifndef IN_KERNEL
extern void RaiseException ();
#endif

#include <assert.h>
#include <stdarg.h>
#include <stddef.h>
#ifndef unix
#include <string.h>
#endif

// MACH #ifdef WIN32_OR_WIN64
// MACH #include <process.h>
// MACH #endif

#include "fepublic.h"
#include "fehelper.h"
#include "fesupprt.h"

void fp82_default_fp_exception_fault(void *ps, EM_uint_t isrcode);
void fp82_default_fp_exception_trap(void *ps, EM_uint_t isr_code);

#define RESTORE_CONSTANTS {                   \
   FR[0]       = FP_ZERO;                     \
   FR[1]       = FP_ONE;                      \
   PR[0]       = 1;                           \
   GR[0].value = 0;                           \
   GR[0].nat   = 0;                           \
}


// ***************************************************************
// GET/PUT F1
// ***************************************************************
void
GETSTATE_F1(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1, 
   EM_fp_reg_specifier   Fr3, 
   EM_fp_reg_specifier   Fr4, 
   EM_fp_reg_specifier   Fr2)  {

}

void
PUTSTATE_F1(
   EM_fp_reg_specifier Fr1) {

   RESTORE_CONSTANTS;                   
}

// ***************************************************************
// GET/PUT F4
// ***************************************************************
void
GETSTATE_F4(
   EM_pred_reg_specifier Pr0,
   EM_pred_reg_specifier Pr1,
   EM_pred_reg_specifier Pr2,
   EM_fp_reg_specifier   Fr2,
   EM_fp_reg_specifier   Fr3)  {
}

void
PUTSTATE_F4(
   EM_pred_reg_specifier Pr1,
   EM_pred_reg_specifier Pr2) {

    RESTORE_CONSTANTS;                   
}

// ***************************************************************
// GET/PUT F6
// ***************************************************************
void
GETSTATE_F6(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_pred_reg_specifier Pr2,
   EM_fp_reg_specifier   Fr2,
   EM_fp_reg_specifier   Fr3)  {
}

void
PUTSTATE_F6(
   EM_fp_reg_specifier   Fr1,
   EM_pred_reg_specifier Pr2) {

    RESTORE_CONSTANTS;                   
}


// ***************************************************************
// GET/PUT F7
// ***************************************************************
void
GETSTATE_F7(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_pred_reg_specifier Pr2,
   EM_fp_reg_specifier   Fr3)  {
}


void
PUTSTATE_F7(
   EM_fp_reg_specifier   Fr1,
   EM_pred_reg_specifier Pr2) {

    RESTORE_CONSTANTS;                   
}

// ***************************************************************
// GET/PUT F8
// ***************************************************************
void
GETSTATE_F8(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_fp_reg_specifier   Fr2, 
   EM_fp_reg_specifier   Fr3)  {
}

void
PUTSTATE_F8(
   EM_fp_reg_specifier   Fr1) {

   RESTORE_CONSTANTS;                   
}

// ***************************************************************
// GET/PUT F10
// ***************************************************************
void
GETSTATE_F10(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_fp_reg_specifier   Fr2)  {

    SIGNED_FORM   = 0;
    TRUNC_FORM    = 0;
    UNSIGNED_FORM = 0;
}

void
PUTSTATE_F10(
   EM_fp_reg_specifier   Fr1)  {

   RESTORE_CONSTANTS;      
}


void fp82_default_fp_exception_fault(void *vps, EM_uint_t isr_code) {
EM_state_type *ps;
   ps = (EM_state_type *)vps;
   ps->state_MERCED_RTL &= ~0xffff0000;
   ps->state_MERCED_RTL |= (isr_code << 16);
   ps->trap_type = 1; // fault
}


void fp82_default_fp_exception_trap(void *vps, EM_uint_t isr_code) {
EM_state_type *ps;
   ps = (EM_state_type *)vps;
   ps->state_MERCED_RTL &= ~0xffff0000;
   ps->state_MERCED_RTL |= (isr_code << 16);
   ps->trap_type = 0; // trap
}


/*************************************************************
fp82_EM_initialize_state()
*************************************************************/
void
fp82_EM_initialize_state(EM_state_type *ps) {
    EM_int_t i;

    PSR.be                = 0;
    PSR.dfl               = 0;
    PSR.dfh               = 0;
    PSR.mfl               = 0;
    PSR.mfh               = 0;

    FPSR.traps_vd         = 1;
    FPSR.traps_dd         = 1;
    FPSR.traps_zd         = 1;
    FPSR.traps_od         = 1;
    FPSR.traps_ud         = 1;
    FPSR.traps_id         = 1;

    FPSR.sf0_controls_ftz = 0;
    FPSR.sf0_controls_wre = 1;
    FPSR.sf0_controls_pc  = sf_double_extended;
    FPSR.sf0_controls_rc  = rc_rn;
    FPSR.sf0_controls_td  = 0;
    FPSR.sf0_flags_v      = 0;
    FPSR.sf0_flags_d      = 0;
    FPSR.sf0_flags_z      = 0;
    FPSR.sf0_flags_o      = 0;
    FPSR.sf0_flags_u      = 0;
    FPSR.sf0_flags_i      = 0;
 
    FPSR.sf1_controls_ftz = 0;
    FPSR.sf1_controls_wre = 1;
    FPSR.sf1_controls_pc  = sf_double_extended;
    FPSR.sf1_controls_rc  = rc_rn;
    FPSR.sf1_controls_td  = 0;
    FPSR.sf1_flags_v      = 0;
    FPSR.sf1_flags_d      = 0;
    FPSR.sf1_flags_z      = 0;
    FPSR.sf1_flags_o      = 0;
    FPSR.sf1_flags_u      = 0;
    FPSR.sf1_flags_i      = 0;

    FPSR.sf2_controls_ftz = 0;
    FPSR.sf2_controls_wre = 1;
    FPSR.sf2_controls_pc  = sf_double_extended;
    FPSR.sf2_controls_rc  = rc_rn;
    FPSR.sf2_controls_td  = 0;
    FPSR.sf2_flags_v      = 0;
    FPSR.sf2_flags_d      = 0;
    FPSR.sf2_flags_z      = 0;
    FPSR.sf2_flags_o      = 0;
    FPSR.sf2_flags_u      = 0;
    FPSR.sf2_flags_i      = 0;

    FPSR.sf3_controls_ftz = 0;
    FPSR.sf3_controls_wre = 1;
    FPSR.sf3_controls_pc  = sf_double_extended;
    FPSR.sf3_controls_rc  = rc_rn;
    FPSR.sf3_controls_td  = 0;
    FPSR.sf3_flags_v      = 0;
    FPSR.sf3_flags_d      = 0;
    FPSR.sf3_flags_z      = 0;
    FPSR.sf3_flags_o      = 0;
    FPSR.sf3_flags_u      = 0;
    FPSR.sf3_flags_i      = 0;
    FPSR.reserved         = 0;

    PR[0] = 1;
    for (i=1;i<EM_NUM_PR;i++)
        PR[i] = 0;

    ps->state_MERCED_RTL = 0;

    FR[0] = FP_ZERO;
    FR[1] = FP_ONE;

    for (i=2;i<MAX_REAL_FR_INDEX;i++)
        FR[i] = FP_ZERO;

    for (i=0;i<MAX_REAL_GR_INDEX;i++) {
        GR[i].value = 0;
        GR[i].nat   = 0;
    }

    ps->state_fp82_fp_exception_fault = fp82_default_fp_exception_fault;
    ps->state_fp82_fp_exception_trap = fp82_default_fp_exception_trap;
}


/* Other EM ISA helper functions */
 
EM_boolean_t
fp82_fp_software_assistance_required(EM_state_type *ps, 
    EM_opcode_type calling_instruction, ...)
{
    return(0);
}



INLINE void
disabled_fp_register_fault(EM_uint_t isr_code, EM_uint_t itype)
{
#ifdef IN_KERNEL
    FP_EMULATION_ERROR0 ("disabled_fp_register_fault () Internal Error\n");
#else
    printf ("disabled_fp_register_fault () Internal Error\n");
    exit (1);
#endif
}


INLINE void
fp_exception_fault(EM_uint_t isr_code)
{

    PR[0]       = 1;
    GR[0].value = 0;
    GR[0].nat   = 0;
    FR[0]       = FP_ZERO;
    FR[1]       = FP_ONE;

    ps->state_fp82_fp_exception_fault((EM_state_type *)ps, isr_code);

}

INLINE void
fp_exception_trap(EM_uint_t isr_code)
{

    isr_code |= 0x00000001;

    ps->state_fp82_fp_exception_trap((EM_state_type *)ps, isr_code);

}


INLINE void
illegal_operation_fault(EM_uint_t non_rs)
{
#ifdef IN_KERNEL
    FP_EMULATION_ERROR0 ("illegal_operation_fault () Internal Error\n");
#else
    printf ("illegal_operation_fault () Internal Error\n");
    exit (1);
#endif
}

INLINE void
check_target_register(EM_uint_t reg_specifier, EM_uint_t itype)
{
  if(reg_specifier == 0) {
#ifdef IN_KERNEL
    FP_EMULATION_ERROR0 ("fp_check_target_register () Internal Error\n");
#else
    printf ("fp_check_target_register () Internal Error\n");
    exit (1);
#endif
  }
}

void
fp_check_target_register(EM_uint_t reg_specifier)
{
  if( (reg_specifier == 0) || (reg_specifier == 1) ){
#ifdef IN_KERNEL
    FP_EMULATION_ERROR0 ("fp_check_target_register () Internal Error\n")
#else
    printf ("fp_check_target_register () Internal Error\n");
    exit (1);
#endif
  }
}


INLINE void
reserved_register_field_fault(EM_uint_t val)
{
#ifdef IN_KERNEL
    FP_EMULATION_ERROR0 ("reserved_register_field_fault () Internal Error\n")
#else
    printf ("reserved_register_field_fault () Internal Error\n");
    exit (1);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\flush.c ===
/*++

Module Name:

    flush.c

Abstract:

    This module implements IA64 machine dependent kernel functions to flush
    the data and instruction caches and to flush I/O buffers.

Author:

    07-Mar-1996
    
    Bernard Lint
    M. Jayakumar (Muthurajan.Jayakumar@intel.com)


Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#include "kxia64.h"

//
// PROBE_VISIBILITY_PAL_SUPPORT flag is one time write (RESET) only and multiple time read
// only flag. It is used to check to see if the processor needs PAL_SUPPORT for VISIBILITY // in prefetches. Once the check is made, this flag optimizes such that further checks are // eliminated.
//
 
ULONG ProbePalVisibilitySupport=1;
ULONG NeedPalVisibilitySupport=1;
extern KSPIN_LOCK KiCacheFlushLock;
//
// Define forward referenced prototyes.
//

VOID
KiSweepDcacheTarget (
    IN PULONG SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiSweepIcacheTarget (
    IN PULONG SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiFlushIoBuffersTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Mdl,
    IN PVOID ReadOperation,
    IN PVOID DmaOperation
    );

VOID
KiSyncCacheTarget(
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

ULONG_PTR
KiSyncMC_DrainTarget(
    );


ULONG_PTR
KiSyncMC_Drain(
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG Length
    );

ULONG_PTR
KiSyncPrefetchVisibleTarget(
    );

ULONG_PTR
KiSyncPrefetchVisible (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG Length
    );




VOID
KiSyncCacheTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++
Routine Description:

    This function synchronizes the I-fetch pipeline. Typically this routine will be
    executed by every processor in the system in response to an IPI after the cache
    is flushed. Each processor executing RFI while leaving the IPI produces the
    serialization effect that is required after isync to make sure that further
    instruction prefetches wait till the ISYNC completes.

Arguements:

    SignalDone Supplies a pointer to a variable that is cleared when the
    requested operation has been performed.

    Parameter1 - Parameter3 - Not used.

Return Value:

    Nothing.
--*/
{

#if !defined(NT_UP)

    __synci();
    KiIpiSignalPacketDone(SignalDone);

#endif
    return;

}

VOID
KeSweepIcache (
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes the instruction cache on all processors that are
    currently running threads which are children of the current process or
    flushes the instruction cache on all processors in the host configuration.

    N.B. Although PowerPC maintains cache coherency across processors, we
    use the flash invalidate function (h/w) for I-Cache sweeps which doesn't
    maintain coherency so we still do the MP I-Cache flush in s/w.   plj.

Arguments:

    AllProcessors - Supplies a boolean value that determines which instruction
        caches are flushed.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    KAFFINITY TargetProcessors;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

#if !defined(NT_UP)
    // 
    // Acquire cache flush spinlock
    // Cache flush is not MP safe yet
    //
    KeAcquireSpinLock(&KiCacheFlushLock, &OldIrql);

#endif

    HalSweepIcache();

#if !defined(NT_UP)

    //
    // Compute the set of target processors and send the sweep parameters
    // to the target processors, if any, for execution.
    //

    TargetProcessors = KeActiveProcessors & PCR->NotMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiSweepIcacheTarget,
                        NULL,
                        NULL,
                        NULL);
    }


    //
    // Wait until all target processors have finished sweeping their
    // instruction caches.
    //


    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Lower IRQL to its previous level and return.
    //

    KeReleaseSpinLock(&KiCacheFlushLock, OldIrql);

#endif

    return;
}

VOID
KiSweepIcacheTarget (
    IN PULONG SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for sweeping the instruction cache on
    target processors.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Parameter1 - Parameter3 - Not used.

Return Value:

    None.

--*/

{

    //
    // Sweep the instruction cache on the current processor and clear
    // the sweep instruction cache packet address to signal the source
    // to continue.
    //

#if !defined(NT_UP)

    HalSweepIcache();

    KiIpiSignalPacketDone(SignalDone);

#endif

    return;
}

VOID
KeSweepDcache (
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes the data cache on all processors that are currently
    running threads which are children of the current process or flushes the
    data cache on all processors in the host configuration.

    N.B. PowerPC maintains cache coherency across processors however
    in this routine, the range of addresses being flushed is unknown
    so we must still broadcast the request to the other processors.

Arguments:

    AllProcessors - Supplies a boolean value that determines which data
        caches are flushed.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    KAFFINITY TargetProcessors;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

#if !defined(NT_UP)
    // 
    // Acquire cache flush spinlock
    // Cache flush is not MP safe yet
    //
    KeAcquireSpinLock(&KiCacheFlushLock, &OldIrql);

#endif

    HalSweepDcache();

#if !defined(NT_UP)

    //
    // Compute the set of target processors and send the sweep parameters
    // to the target processors, if any, for execution.
    //

    TargetProcessors = KeActiveProcessors & PCR->NotMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiSweepDcacheTarget,
                        NULL,
                        NULL,
                        NULL);
    }


    //
    // Wait until all target processors have finished sweeping their
    // data caches.
    //


    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Lower IRQL to its previous level and return.
    //

    KeReleaseSpinLock(&KiCacheFlushLock, OldIrql);

#endif

    return;
}

VOID
KiSweepDcacheTarget (
    IN PULONG SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for sweeping the data cache on target
    processors.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Parameter1 - Parameter3 - Not used.

Return Value:

    None.

--*/

{

    //
    // Sweep the data cache on the current processor and clear the sweep
    // data cache packet address to signal the source to continue.
    //

#if !defined(NT_UP)

    HalSweepDcache();
    KiIpiSignalPacketDone(SignalDone);

#endif

    return;
}



ULONG_PTR
KiSyncMC_DrainTarget(
    )

/*++

Routine Description:

    This is the target function for issuing PAL_MC_DRAIN to drain
    prefetches, demand references and pending fc cache line evictions on the
    target CPU it executes.

Argument:

    None


Return Value:

   Returns the status from the function HalCallPal

--*/

{
    ULONG_PTR Status;

    //
    // Call HalCallPal to drain.
    //

    Status = HalCallPal(PAL_MC_DRAIN,
        0,
        0,
        0,
        0,
        0,
        0,
        0);

    ASSERT(Status == PAL_STATUS_SUCCESS);

    return Status;

}


VOID
KeSweepCacheRange (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG Length
    )

/*++

Routine Description:

    This function is used to flush a range of virtual addresses from both the
    instruction and data cache on all processors in the system.

    Irrespective of the length of the range, it should not call SweepIcache
    or SweepDcache. This is because SweepDcache will only sweep D cache and
    not the I cache and Vice versa. Since the caller of KeSweepCacheRange assumes
    both the caches are being swept, one cannot call SweepIcache or SweepDcache
    in trying to optimize.


    Arguments:

    AllProcessors - Not used

    BaseAddress - Supplies a pointer to the base of the range that is flushed.

    Length - Supplies the length of the range that is flushed if the base
        address is specified.

    Return Value:

        None.


--*/

{
     KIRQL OldIrql;
     KAFFINITY TargetProcessors;

    //
    // We will not raise IRQL to synchronization level so that we can allow
    // a context switch in between Flush Cache. FC need not run in the same processor
    // throughout. It can be context switched. So no binding is done to any processor.
    //
    //

    HalSweepCacheRange(BaseAddress,Length);

    ASSERT(KeGetCurrentIrql() <= KiSynchIrql);

    //
    // Raise IRQL to synchronization level to prevent a context switch.
    //

#if !defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

    //
    // Compute the set of target processors and send the sync parameters
    // to the target processors, if any, for execution.
    //

    TargetProcessors = KeActiveProcessors & PCR->NotMember;
    if (TargetProcessors != 0) {
    KiIpiSendPacket(TargetProcessors,
                    KiSyncCacheTarget,
                    NULL,
                    NULL,
                    NULL);
    }

#endif

    //
    // Synchronize the Instruction Prefetch pipe in the local processor.
    //

    __synci();
    __isrlz();

    //
    // Wait until all target processors have finished sweeping the their
    // data cache.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Lower IRQL to its previous level and return.
    //

    KeLowerIrql(OldIrql);

#endif

    return;

}

VOID
KeSweepIcacheRange (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN SIZE_T Length
    )

/*++

Routine Description:

    This function is used to flush a range of virtual addresses from the
    primary instruction cache on all processors in the host configuration.

     If the length of the range is greater than the size of the
    instruction cache, then one can call HalSweepIcache which calls
    SAL to flush the entire cache. Since SAL does not take care of MP
    flushing, HalSweepIcache has to use IPI mechanism to execute SAL
    flush from each processor. We need to weight the overhead of all these
    versus using HalSweepIcacheRange and avoiding IPI mechanism since
    HalSweepIcacheRange uses fc instruction and fc instruction takes care of MP.

Arguments:

    AllProcessors -  Not used

    BaseAddress - Supplies a pointer to the base of the range that is flushed.

    Length - Supplies the length of the range that is flushed if the base
        address is specified.

Return Value:

    None.

    Note:  For performance reason, we may update KeSweepIcacheRange to do the following:
           if the range asked to sweep is very large, we may call KeSweepIcache to flush
           the full cache.



--*/

{
    KIRQL OldIrql;
    KAFFINITY TargetProcessors;

    //
    // We will not raise IRQL to synchronization level so that we can allow
    // a context switch in between Flush Cache. FC need not run in the same processor
    // throughout. It can be context switched. So no binding is done to any processor.
    //
    //

    HalSweepIcacheRange(BaseAddress,Length);

    ASSERT(KeGetCurrentIrql() <= KiSynchIrql);

    //
    // Raise IRQL to synchronization level to prevent a context switch.
    //

#if !defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

    //
    // Compute the set of target processors and send the sync parameters
    // to the target processors, if any, for execution.
    //

    TargetProcessors = KeActiveProcessors & PCR->NotMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
            KiSyncCacheTarget,
            NULL,
            NULL,
            NULL);
    }

#endif

    //
    // Synchronize the Instruction Prefetch pipe in the local processor.
    //

    __synci();
    __isrlz();

    //
    // Wait until all target processors have finished sweeping the their
    // data cache.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Lower IRQL to its previous level and return.
    //

    KeLowerIrql(OldIrql);

#endif

    return;


}

VOID
KeSweepCurrentIcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    )

/*++

Routine Description:

    This function is used to flush a range of virtual addresses from the
    primary instruction cache on the current processor.

    This is used by the kernel debugger for flushing the i-cache after
    modifying memory in case the instruction stream is changed.
   
    To avoid calling SAL during phase 0 we use "fc" instead of the SAL cache
    flush call.

Arguments:

    BaseAddress - Supplies a pointer to the base of the range that is flushed.

    Length - Supplies the length of the range that is flushed if the base
        address is specified.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    HalSweepIcacheRange(BaseAddress,Length);
    
    //
    // Synchronize the Instruction Prefetch pipe in the local processor.
    //

    __synci();
    __isrlz();

    KeLowerIrql(OldIrql);

    return;
}



VOID
KeSweepDcacheRange (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG Length
    )

/*++

Routine Description:

    This function is used to flush a range of virtual addresses from the
    primary data cache on all processors in the host configuration.

     If the length of the range is greater than the size of the
    data cache, then one can call HalSweepDcache which calls
    SAL to flush the entire cache. Since SAL does not take care of MP
    flushing, HalSweepDcache has to use IPI mechanism to execute SAL
    flush from each processor. We need to weight the overhead of all these
    versus using HalSweepDcacheRange and avoiding IPI mechanism since
    HalSweepDcacheRange uses fc instruction and fc instruction takes care of MP.

Arguments:

    AllProcessors -  Not used

    BaseAddress - Supplies a pointer to the base of the range that is flushed.

    Length - Supplies the length of the range that is flushed if the base
        address is specified.

Return Value:

    None.

    Note:  For performance reason, we may update KeSweepDcacheRange to do the following:
           if the range asked to sweep is very large, we may call KeSweepDcache to flush
           the full cache.



--*/

{
    KIRQL OldIrql;
    KAFFINITY TargetProcessors;

    //
    // We will not raise IRQL to synchronization level so that we can allow
    // a context switch in between Flush Cache. FC need not run in the same processor
    // throughout. It can be context switched. So no binding is done to any processor.
    //
    //

    HalSweepDcacheRange(BaseAddress,Length);

    ASSERT(KeGetCurrentIrql() <= KiSynchIrql);

    //
    // Raise IRQL to synchronization level to prevent a context switch.
    //

#if !defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

    //
    // Compute the set of target processors and send the sync parameters
    // to the target processors, if any, for execution.
    //

    TargetProcessors = KeActiveProcessors & PCR->NotMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
            KiSyncCacheTarget,
            NULL,
            NULL,
            NULL);
    }

#endif

    //
    // Synchronize the Instruction Prefetch pipe in the local processor.
    //

    __synci();
    __isrlz();

    //
    // Wait until all target processors have finished sweeping the their
    // data cache.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Lower IRQL to its previous level and return.
    //

    KeLowerIrql(OldIrql);

#endif

    return;


}

ULONG_PTR
KiSyncMC_Drain (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG Length
    )

/*++

Routine Description:

    KiSyncMC_Drain issues  PAL_MC_DRAIN to drain either prefetches, demand references
    or pending fc cache line evictions to all the processors in the system.
    DrainTypePointer points to the variable, DrainType, which determines the type of
    drain to be performed. This is typically used when changing the memory attribute
    from WB to UC.

Arguments:

    AllProcessors - All processors in the system.

    BaseAddress - Supplies a pointer to the base of the range that is to be drained.

    Length - Supplies the length of the range that is drained for the base
        address specified.

Return Value:

    Note:  This is used when changing attributes of WB pages to UC pages.


--*/

{
    ULONG_PTR Status;
    //
    // KiIpiGenericCall returns ULONG_PTR as the function value of the specified function
    //

    Status = (KiIpiGenericCall (
                (PKIPI_BROADCAST_WORKER)KiSyncMC_DrainTarget,
                (ULONG_PTR)NULL)
                );

    ASSERT(Status == PAL_STATUS_SUCCESS);

    return Status;


}

ULONG_PTR
KiSyncPrefetchVisibleTarget(
    )

/*++

Routine Description:

    This is the target function for issuing PAL_PREFETCH VISIBILITY 
    on the target CPU it executes.

Argument:

    Not used.


Return Value:

   Returns the status from the function HalCallPal

--*/

{
    ULONG_PTR Status;

    //
    // Call HalCallPal to drain.
    //

    Status = HalCallPal(PAL_PREFETCH_VISIBILITY,
        0,
        0,
        0,
        0,
        0,
        0,
        0);


    ASSERT(Status != PAL_STATUS_ERROR);

    return Status;

}



ULONG_PTR
KiSyncPrefetchVisible (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG Length
    )

/*++

Routine Description:

    KiSyncPrefetchVisible issues  PAL_PREFETCH_VISIBILITY to cause the processor to make
    all pending prefetches visible to subsequent fc instructions; or does nothing, on 
    processor implementations which does not require PAL support for disabling prefetch 
    in the architectural sequence. On processors that require PAL support for this
    sequence, the actions performed by this procedure may include any or all
    of the following (or none, as long as the processor guarantees that 
    prefetches that were issued prior to this call are not resident in the 
    processor's caches after the architected sequence is complete.
    This is typically used when changing the memory attribute from WB to UC.

Arguments:

    AllProcessors - All processors in the system.

    BaseAddress - Supplies a pointer to the base of the range that is to be drained.

    Length - Supplies the length of the range that is drained for the base
        address specified.

Return Value:

    Status of the PAL CALL
      0  Success
      1  Call not needed
      -3 Error returned
    
    Note:  This is used when changing attributes of WB pages to UC pages.


--*/

{
    ULONG_PTR Status;
    
    switch (ProbePalVisibilitySupport) {
        case 0: 
            if (NeedPalVisibilitySupport == 0)
               Status = PAL_STATUS_SUPPORT_NOT_NEEDED;
            else {
               Status = (KiIpiGenericCall (
                            (PKIPI_BROADCAST_WORKER)KiSyncPrefetchVisibleTarget,
                            (ULONG_PTR)NULL)
                            );
            }
            break;

        case 1:
            Status = KiSyncPrefetchVisibleTarget();
   
            ASSERT(Status != PAL_STATUS_ERROR);
   
            ProbePalVisibilitySupport = 0;

            if (Status == PAL_STATUS_SUPPORT_NOT_NEEDED) {
                NeedPalVisibilitySupport = 0;
                Status = PAL_STATUS_SUPPORT_NOT_NEEDED;
            } else {
                Status = (KiIpiGenericCall (
                            (PKIPI_BROADCAST_WORKER)KiSyncPrefetchVisibleTarget,
                            (ULONG_PTR)NULL)
                            );
            }
            break;
        default:
            Status = PAL_STATUS_ERROR;
            break;
    }
            
    ASSERT(Status != PAL_STATUS_ERROR);
            
    return Status;

}



VOID
KeSweepCacheRangeWithDrain (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG Length
    )

/*++

Routine Description:

    This function is used to drain prefetches,demand references followed by flushing
    the cache followed by draining pending fc cache line evictions to a specified range
    address in all processors in the system.


Arguments:

    AllProcessors -  All processors in the system.

    BaseAddress - Supplies a pointer to the base of the range that is flushed and drained.

    Length - Supplies the length of the range that is flushed and drained for the base
        address is specified.

Return Value:

    None.

    Note:  This is used when changing attributes of WB pages to UC pages.

--*/

{
    ULONG_PTR Status;

    Status = KiSyncPrefetchVisible(
                 AllProcessors,
                 BaseAddress,
                 Length
                 );

    ASSERT(Status != PAL_STATUS_ERROR);
    
    KeSweepCacheRange (
        AllProcessors,
        BaseAddress,
        Length
        );

    Status = KiSyncMC_Drain (
                 AllProcessors,
                 BaseAddress,
                 Length
                 );

    ASSERT(Status == PAL_STATUS_SUCCESS);

    return;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\fesupprt.h ===
/******************************
Intel Confidential
******************************/

#ifndef _EM_SUPPORT_H
#define _EM_SUPPORT_H

void
fp82_EM_initialize_state(EM_state_type *ps);


EM_boolean_t
fp82_fp_software_assistance_required(EM_state_type *, 
    EM_opcode_type, ...);


/*******************************************************
Fault handlers -- Start
********************************************************/

/*******************************************************
Defines to get rid of ps in the function declaration
********************************************************/

#define disabled_fp_register_fault(arg1, arg2) \
        fp82_disabled_fp_register_fault(EM_state_type *ps, arg1, arg2)

#define fp_exception_fault(arg1) \
        fp82_fp_exception_fault(EM_state_type *ps, arg1)

#define fp_exception_trap(arg1) \
        fp82_fp_exception_trap(EM_state_type *ps, arg1)

#define illegal_operation_fault(arg1) \
        fp82_illegal_operation_fault(EM_state_type *ps, arg1)

#define check_target_register(arg1, arg2) \
        fp82_check_target_register(EM_state_type *ps, arg1, arg2)

#define fp_check_target_register(arg1) \
        fp82_fp_check_target_register(EM_state_type *ps, arg1)

/*******************************************************
Fault prototypes
********************************************************/
INLINE void
disabled_fp_register_fault(EM_uint_t isr_code, EM_uint_t itype);
 
INLINE void
fp_exception_fault(EM_uint_t isr_code);
 
INLINE void
fp_exception_trap(EM_uint_t isr_code);
 
INLINE void
illegal_operation_fault(EM_uint_t non_rs);

INLINE void
check_target_register(EM_uint_t reg_specifier, EM_uint_t itype);

void
fp_check_target_register(EM_uint_t reg_specifier);

/*******************************************************
Fault handlers -- End
********************************************************/

 
/*******************************************************
GET PUT functions
********************************************************/

/*******************************************************
Defines to get rid of ps in GET PUT functions
********************************************************/

#define GETSTATE_F1(qp,f1,f3,f4,f2)         _GETSTATE_F1(EM_state_type *ps, qp,f1,f3,f4,f2)
#define PUTSTATE_F1(f1)                     _PUTSTATE_F1(EM_state_type *ps, f1)

#define GETSTATE_F4(qp,p1,p2,f2,f3)         _GETSTATE_F4(EM_state_type *ps, qp,p1,p2,f2,f3)
#define PUTSTATE_F4(p1,p2)                  _PUTSTATE_F4(EM_state_type *ps, p1,p2)

#define GETSTATE_F6(qp,f1,p2,f2,f3)         _GETSTATE_F6(EM_state_type *ps,qp,f1,p2,f2,f3)
#define PUTSTATE_F6(f1,p2)                  _PUTSTATE_F6(EM_state_type *ps,f1,p2)

#define GETSTATE_F7(qp,f1,p2,f3)            _GETSTATE_F7(EM_state_type *ps, qp,f1,p2,f3)
#define PUTSTATE_F7(f1,p2)                  _PUTSTATE_F7(EM_state_type *ps, f1,p2)

#define GETSTATE_F8(qp,f1,f2,f3)            _GETSTATE_F8(EM_state_type *ps, qp,f1,f2,f3)
#define PUTSTATE_F8(f1)                     _PUTSTATE_F8(EM_state_type *ps, f1)

#define GETSTATE_F10(qp,f1,f2)              _GETSTATE_F10(EM_state_type *ps, qp,f1,f2)
#define PUTSTATE_F10(f1)                    _PUTSTATE_F10(EM_state_type *ps, f1)

/*******************************************************
Prototypes for GET PUT functions
********************************************************/

void
GETSTATE_F1(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_fp_reg_specifier   Fr3,
   EM_fp_reg_specifier   Fr4,
   EM_fp_reg_specifier   Fr2);

void
PUTSTATE_F1(
   EM_fp_reg_specifier Fr1);

void
GETSTATE_F4(
   EM_pred_reg_specifier Pr0,
   EM_pred_reg_specifier Pr1,
   EM_pred_reg_specifier Pr2,
   EM_fp_reg_specifier   Fr2,
   EM_fp_reg_specifier   Fr3);

void
PUTSTATE_F4(
   EM_pred_reg_specifier Pr1,
   EM_pred_reg_specifier Pr2);

void
GETSTATE_F6(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_pred_reg_specifier Pr2,
   EM_fp_reg_specifier   Fr2,
   EM_fp_reg_specifier   Fr3);

void
PUTSTATE_F6(
   EM_fp_reg_specifier   Fr1,
   EM_pred_reg_specifier Pr2);

void
GETSTATE_F7(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_pred_reg_specifier Pr2,
   EM_fp_reg_specifier   Fr3);

void
PUTSTATE_F7(
   EM_fp_reg_specifier   Fr1,
   EM_pred_reg_specifier Pr2);

void
GETSTATE_F8(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_fp_reg_specifier   Fr2,
   EM_fp_reg_specifier   Fr3);

void
PUTSTATE_F8(
   EM_fp_reg_specifier   Fr1);

void
GETSTATE_F10(
   EM_pred_reg_specifier Pr0,
   EM_fp_reg_specifier   Fr1,
   EM_fp_reg_specifier   Fr2);

void
PUTSTATE_F10(
   EM_fp_reg_specifier   Fr1);


/******************************************************************************/
/* Define macros to make transformation to the EAS easier                     */
/******************************************************************************/

#define get_bit(val, bit) \
  ((val >> bit) &0x1)

   
/******************************************************************************/
/* Define macros to simplify access to the fp82_ functions.  This is done so  */
/*  the namespace doesn't get cluttered, while retaining convenient access.   */
/*  The FP82_NO_SHORTCUTS macro can be defined to prevent creation of these.  */
/******************************************************************************/

#ifndef FP82_NO_SHORTCUTS
#define EM_initialize_state             fp82_EM_initialize_state

#define fp_software_assistance_required fp82_fp_software_assistance_required
#endif /* FP82_NO_SHORTCUTS */

#endif /* _EM_SUPPORT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\floatem.c ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1996  Intel Corporation

Module Name:

    floatem.c

Abstract:

    This module implements IA64 machine dependent floating point emulation
    functions to support the IEEE floating point standard.

Author:

    Marius Cornea-Hasegan  Sep-96

Environment:

    Kernel mode only.

Revision History:
 
    Modfied  Jan. 97, Jan 98, Jun 98 (new API)

--*/

#include "ki.h"
#include "ntfpia64.h"
#include "floatem.h"


extern LONG
HalFpEmulate (
    ULONG   trap_type,
    BUNDLE  *pBundle,
    ULONGLONG *pipsr,
    ULONGLONG *pfpsr,
    ULONGLONG *pisr,
    ULONGLONG *ppreds,
    ULONGLONG *pifs,
    FP_STATE  *fp_state
    );


#define ALL_FP_REGISTERS_SAVED 0xFFFFFFFFFFFFFFFFi64

int
fp_emulate (
    int trap_type,
    BUNDLE *pbundle,
    EM_int64_t *pipsr,
    EM_int64_t *pfpsr,
    EM_int64_t *pisr,
    EM_int64_t *ppreds,
    EM_int64_t *pifs,
    void *fp_state
    )
{
    //
    // Pointer to old Floating point state FLOATING_POINT_STATE
    //

    FLOATING_POINT_STATE     *Ptr0FPState;
    PKEXCEPTION_FRAME         LocalExceptionFramePtr;
    PKTRAP_FRAME              LocalTrapFramePtr;
    FP_STATE FpState;
    KIRQL OldIrql;
    BOOLEAN LessThanAPC;
    int  Status;

    Ptr0FPState = (PFLOATING_POINT_STATE) fp_state;

    LocalExceptionFramePtr = (PKEXCEPTION_FRAME) (Ptr0FPState->ExceptionFrame);
    LocalTrapFramePtr      = (PKTRAP_FRAME)      (Ptr0FPState->TrapFrame);

    FpState.bitmask_low64           = ALL_FP_REGISTERS_SAVED;
    FpState.bitmask_high64          = ALL_FP_REGISTERS_SAVED;

    (FLOAT128 *)FpState.fp_state_low_preserved   = &(LocalExceptionFramePtr->FltS0);
    (FLOAT128 *)FpState.fp_state_low_volatile    = &(LocalTrapFramePtr->FltT0);
    (FLOAT128 *)FpState.fp_state_high_preserved  = &(LocalExceptionFramePtr->FltS4);

    (FLOAT128 *)FpState.fp_state_high_volatile  = (PFLOAT128)GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(KeGetCurrentThread()->StackBase);

    if (KeGetCurrentIrql() < APC_LEVEL) {
       LessThanAPC = 1;
    } else {
       LessThanAPC = 0;
    }

    if (LessThanAPC)  {
       KeRaiseIrql (APC_LEVEL, &OldIrql);
    }

    Status = HalFpEmulate(trap_type,
                          pbundle,
                          pipsr,
                          pfpsr,
                          pisr,
                          ppreds,
                          pifs,
                          &FpState
                          );
    if (LessThanAPC) {
       KeLowerIrql (OldIrql);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\fetypes.h ===
/******************************
Intel Confidential
******************************/

// MACH
/* define the following for WindowsNT only */
#define WIN32_OR_WIN64

#ifdef WIN32_OR_WIN64
#define LX "%I64x"
#define LD "%I64d"
#else
#define LX "%Lx"
#define LD "%Ld"
#endif

/******************************************************************
Due to differences in format of the constants we need to wrap is
with a macro to help add the LL on all platforms other than NT
*******************************************************************/
#ifndef WIN32_OR_WIN64
#define CONST_FORMAT(num) num ## LL
#else
#define CONST_FORMAT(num) ((EM_uint64_t)(num))
#endif

#ifndef _EM_TYPES_H
#define _EM_TYPES_H

// MACH
// Exception Codes for Emulation Traps and Faults
#define STATUS_EMULATION_FAULT   0x0E0010000
#define STATUS_EMULATION_TRAP    0x0E0020000

// MACH
#define LITTLE_ENDIAN

#define MAX_REAL_GR_INDEX             1
#define MAX_REAL_FR_INDEX             128

#define EM_NUM_PR        64
#define EM_NUM_MEM        1


#ifndef INLINE
#define INLINE
#endif

#if !(defined(BIG_ENDIAN) || defined(LITTLE_ENDIAN))
    #error Endianness not established; define BIG_ENDIAN or LITTLE_ENDIAN
#endif



/***********************/
/* Basic Integer Types */
/***********************/
 
typedef int                EM_int_t;      /* 32-bit signed integer */
typedef unsigned int       EM_uint_t;     /* 32-bit unsigned integer */

typedef short              EM_short_t;    /* 16-bit signed integer */
typedef unsigned short     EM_ushort_t;   /* 16-bit unsigned integer */

typedef unsigned int       EM_boolean_t;  /* true (1) or false (0) */

#ifdef WIN32_OR_WIN64
typedef __int64            EM_int64_t;    /* 64-bit signed integer */
typedef unsigned __int64   EM_uint64_t;   /* 64-bit unsigned integer */

#else

// MACH
#ifndef unix
typedef long long          EM_int64_t;    // 64-bit signed integer
typedef unsigned long long EM_uint64_t;   // 64-bit unsigned integer
#else
// MACH: for SCO UNIX
typedef long               EM_int64_t;    // 64-bit signed integer
typedef unsigned long      EM_uint64_t;   // 64-bit unsigned integer
#endif

#endif
 
/*******************************************************************************
FP_EXCP_xxx - Define a typedef for function pointers to override exceptions.
*****************************************************************************/

typedef void (*FP_EXCP_FAULT)(void*, EM_uint_t);
typedef void (*FP_EXCP_TRAP)(void*, EM_uint_t);
typedef void (*FP_EXCP_SPEC)(void*, EM_uint_t, EM_uint64_t);


typedef struct uint128_struct {
#ifdef BIG_ENDIAN
    EM_uint64_t hi;
    EM_uint64_t lo;
#endif
#ifdef LITTLE_ENDIAN
    EM_uint64_t lo;
    EM_uint64_t hi;
#endif
} EM_uint128_t;                          /* 128-bit unsigned integer */
 
typedef struct uint256_struct {
#ifdef BIG_ENDIAN
    EM_uint64_t hh;
    EM_uint64_t hl;
    EM_uint64_t lh;
    EM_uint64_t ll;
#endif
#ifdef LITTLE_ENDIAN
    EM_uint64_t ll;
    EM_uint64_t lh;
    EM_uint64_t hl;
    EM_uint64_t hh;
#endif
} EM_uint256_t;                          /* 256-bit unsigned integer */

/******************/
/* Support enum's */
/******************/

typedef enum {
    pr_00 =  0, pr_01 =  1, pr_02 =  2, pr_03 =  3,
    pr_04 =  4, pr_05 =  5, pr_06 =  6, pr_07 =  7,
    pr_08 =  8, pr_09 =  9, pr_10 = 10, pr_11 = 11,
    pr_12 = 12, pr_13 = 13, pr_14 = 14, pr_15 = 15,

    pr_16 = 16, pr_17 = 17, pr_18 = 18, pr_19 = 19,
    pr_20 = 20, pr_21 = 21, pr_22 = 22, pr_23 = 23,
    pr_24 = 24, pr_25 = 25, pr_26 = 26, pr_27 = 27,
    pr_28 = 28, pr_29 = 29, pr_30 = 30, pr_31 = 31,
    pr_32 = 32, pr_33 = 33, pr_34 = 34, pr_35 = 35,
    pr_36 = 36, pr_37 = 37, pr_38 = 38, pr_39 = 39,
    pr_40 = 40, pr_41 = 41, pr_42 = 42, pr_43 = 43,
    pr_44 = 44, pr_45 = 45, pr_46 = 46, pr_47 = 47,
    pr_48 = 48, pr_49 = 49, pr_50 = 50, pr_51 = 51,
    pr_52 = 52, pr_53 = 53, pr_54 = 54, pr_55 = 55,
    pr_56 = 56, pr_57 = 57, pr_58 = 58, pr_59 = 59,
    pr_60 = 60, pr_61 = 61, pr_62 = 62, pr_63 = 63
} EM_pred_reg_specifier;

typedef enum {
    gr_000 =   0, gr_001 =   1, gr_002 =   2, gr_003 =   3,
    gr_004 =   4, gr_005 =   5, gr_006 =   6, gr_007 =   7,
    gr_008 =   8, gr_009 =   9, gr_010 =  10, gr_011 =  11,
    gr_012 =  12, gr_013 =  13, gr_014 =  14, gr_015 =  15,
    gr_016 =  16, gr_017 =  17, gr_018 =  18, gr_019 =  19,
    gr_020 =  20, gr_021 =  21, gr_022 =  22, gr_023 =  23,
    gr_024 =  24, gr_025 =  25, gr_026 =  26, gr_027 =  27,
    gr_028 =  28, gr_029 =  29, gr_030 =  30, gr_031 =  31,

    gr_032 =  32, gr_033 =  33, gr_034 =  34, gr_035 =  35,
    gr_036 =  36, gr_037 =  37, gr_038 =  38, gr_039 =  39,
    gr_040 =  40, gr_041 =  41, gr_042 =  42, gr_043 =  43,
    gr_044 =  44, gr_045 =  45, gr_046 =  46, gr_047 =  47,
    gr_048 =  48, gr_049 =  49, gr_050 =  50, gr_051 =  51,
    gr_052 =  52, gr_053 =  53, gr_054 =  54, gr_055 =  55,
    gr_056 =  56, gr_057 =  57, gr_058 =  58, gr_059 =  59,
    gr_060 =  60, gr_061 =  61, gr_062 =  62, gr_063 =  63,
    gr_064 =  64, gr_065 =  65, gr_066 =  66, gr_067 =  67,
    gr_068 =  68, gr_069 =  69, gr_070 =  70, gr_071 =  71,
    gr_072 =  72, gr_073 =  73, gr_074 =  74, gr_075 =  75,
    gr_076 =  76, gr_077 =  77, gr_078 =  78, gr_079 =  79,
    gr_080 =  80, gr_081 =  81, gr_082 =  82, gr_083 =  83,
    gr_084 =  84, gr_085 =  85, gr_086 =  86, gr_087 =  87,
    gr_088 =  88, gr_089 =  89, gr_090 =  90, gr_091 =  91,
    gr_092 =  92, gr_093 =  93, gr_094 =  94, gr_095 =  95,
    gr_096 =  96, gr_097 =  97, gr_098 =  98, gr_099 =  99,
    gr_100 = 100, gr_101 = 101, gr_102 = 102, gr_103 = 103,
    gr_104 = 104, gr_105 = 105, gr_106 = 106, gr_107 = 107,
    gr_108 = 108, gr_109 = 109, gr_110 = 110, gr_111 = 111,
    gr_112 = 112, gr_113 = 113, gr_114 = 114, gr_115 = 115,
    gr_116 = 116, gr_117 = 117, gr_118 = 118, gr_119 = 119,
    gr_120 = 120, gr_121 = 121, gr_122 = 122, gr_123 = 123,
    gr_124 = 124, gr_125 = 125, gr_126 = 126, gr_127 = 127
} EM_general_register_specifier;


typedef enum {
    fr_000 =   0, fr_001 =   1, fr_002 =   2, fr_003 =   3,
    fr_004 =   4, fr_005 =   5, fr_006 =   6, fr_007 =   7,
    fr_008 =   8, fr_009 =   9, fr_010 =  10, fr_011 =  11,
    fr_012 =  12, fr_013 =  13, fr_014 =  14, fr_015 =  15,
    fr_016 =  16, fr_017 =  17, fr_018 =  18, fr_019 =  19,
    fr_020 =  20, fr_021 =  21, fr_022 =  22, fr_023 =  23,
    fr_024 =  24, fr_025 =  25, fr_026 =  26, fr_027 =  27,
    fr_028 =  28, fr_029 =  29, fr_030 =  30, fr_031 =  31,

    fr_032 =  32, fr_033 =  33, fr_034 =  34, fr_035 =  35,
    fr_036 =  36, fr_037 =  37, fr_038 =  38, fr_039 =  39,
    fr_040 =  40, fr_041 =  41, fr_042 =  42, fr_043 =  43,
    fr_044 =  44, fr_045 =  45, fr_046 =  46, fr_047 =  47,
    fr_048 =  48, fr_049 =  49, fr_050 =  50, fr_051 =  51,
    fr_052 =  52, fr_053 =  53, fr_054 =  54, fr_055 =  55,
    fr_056 =  56, fr_057 =  57, fr_058 =  58, fr_059 =  59,
    fr_060 =  60, fr_061 =  61, fr_062 =  62, fr_063 =  63,
    fr_064 =  64, fr_065 =  65, fr_066 =  66, fr_067 =  67,
    fr_068 =  68, fr_069 =  69, fr_070 =  70, fr_071 =  71,
    fr_072 =  72, fr_073 =  73, fr_074 =  74, fr_075 =  75,
    fr_076 =  76, fr_077 =  77, fr_078 =  78, fr_079 =  79,
    fr_080 =  80, fr_081 =  81, fr_082 =  82, fr_083 =  83,
    fr_084 =  84, fr_085 =  85, fr_086 =  86, fr_087 =  87,
    fr_088 =  88, fr_089 =  89, fr_090 =  90, fr_091 =  91,
    fr_092 =  92, fr_093 =  93, fr_094 =  94, fr_095 =  95,
    fr_096 =  96, fr_097 =  97, fr_098 =  98, fr_099 =  99,
    fr_100 = 100, fr_101 = 101, fr_102 = 102, fr_103 = 103,
    fr_104 = 104, fr_105 = 105, fr_106 = 106, fr_107 = 107,
    fr_108 = 108, fr_109 = 109, fr_110 = 110, fr_111 = 111,
    fr_112 = 112, fr_113 = 113, fr_114 = 114, fr_115 = 115,
    fr_116 = 116, fr_117 = 117, fr_118 = 118, fr_119 = 119,
    fr_120 = 120, fr_121 = 121, fr_122 = 122, fr_123 = 123,
    fr_124 = 124, fr_125 = 125, fr_126 = 126, fr_127 = 127
} EM_fp_reg_specifier;

typedef enum {
    mem_real_form    = 0,
    mem_integer_form = 1
} EM_mem_fr_format_type;


typedef enum {
    pc_s    = 0,
    pc_d    = 2,
    pc_sf   = 3,
    pc_none = 4,
    pc_simd = 5
} EM_opcode_pc_type;

typedef enum {
    sfS0   = 0,
    sfS1   = 1,
    sfS2   = 2,
    sfS3   = 3,
    sf_none = 4
} EM_opcode_sf_type;

typedef enum {
    fctypeUNC      = 0,
    ctype_or       = 1,
    ctype_and      = 2,
    ctype_or_andcm = 3,
    ctype_orcm     = 4,
    ctype_andcm    = 5,
    ctype_and_orcm = 6,
    ctype_none     = 7
} EM_opcode_ctype_type;

typedef enum {
    crel_eq  = 0,
    crel_ne  = 1,
    crel_lt  = 2,
    crel_le  = 3,
    crel_gt  = 4,
    crel_ge  = 5,
    crel_ltu = 6,
    crel_leu = 7,
    crel_gtu = 8,
    crel_geu = 9
} EM_opcode_crel_type;


typedef enum {
    fcrel_nm  = 0,
    fcrel_m   = 1
} EM_opcode_fcrel_type;

typedef enum {
    frelEQ    =  0,
    frelLT    =  1,
    frelLE    =  2,
    frelUNORD =  3,
    frelNEQ   =  4,
    frelNLT   =  5,
    frelNLE   =  6,
    frelORD   =  7,
    frelGT    =  8,
    frelGE    =  9,
    frelNGT   = 10,
    frelNGE   = 11
} EM_opcode_frel_type;

typedef enum {
    sf_single             = 0,
    SF_PC_RESERVED        = 1,
    sf_double             = 2,
    sf_double_extended    = 3
} EM_sf_pc_type;

typedef enum {
    rc_rn = 0,
    rc_rm = 1,
    rc_rp = 2,
    rc_rz = 3
} EM_sf_rc_type;

typedef enum {
    ar_fpsr = 0
} EM_ar_index;

typedef enum {
    high = 1,
    low  = 0
} EM_simd_hilo;

typedef enum {
    op_fcmp        = 0,
    op_fpcmp       = 1,
    op_fcvt_fx     = 2,
    op_fpcvt_fx    = 3,
    op_fcvt_fxu    = 4,
    op_fpcvt_fxu   = 5,
    op_fma         = 6,
    op_fpma        = 7,
    op_fminmax     = 8,
    op_fpminmax    = 9,
    op_fms_fnma    = 10,
    op_fpms_fpnma  = 11,
    op_frcpa       = 12,
    op_fprcpa      = 13,
    op_frsqrta     = 14,
    op_fprsqrta    = 15,
    op_fnorm       = 16,
    op_fsetc       = 17
 } EM_opcode_type;

    
typedef struct EM_limits_check_fprcpa_struct {
   EM_uint_t  hi_fr3;
   EM_uint_t  hi_fr2_or_quot;
   EM_uint_t  lo_fr3;
   EM_uint_t  lo_fr2_or_quot;
} EM_limits_check_fprcpa;

typedef struct EM_limits_check_fprsqrta_struct {
   EM_uint_t  hi;
   EM_uint_t  lo;
} EM_limits_check_fprsqrta;

/***************************/
/* Support Structure Types */
/***************************/


typedef struct trap_control_struct {
    EM_uint_t vd:1;
    EM_uint_t dd:1;
    EM_uint_t zd:1;
    EM_uint_t od:1;
    EM_uint_t ud:1;
    EM_uint_t id:1;
} EM_trap_control_type;

typedef enum {
    ss_single_24          = 24,
    ss_double_53          = 53,
    ss_double_extended_64 = 64
} EM_significand_size_type;

typedef enum {
    es_eight_bits     =  8,
    es_eleven_bits    = 11,
    es_fifteen_bits   = 15,
    es_seventeen_bits = 17
} EM_exponent_size_type;

typedef struct controls_struct {
    EM_uint_t ftz:1;
    EM_uint_t wre:1;
    EM_sf_pc_type pc;
    EM_sf_rc_type rc;
    EM_uint_t td:1;
} EM_controls_type;

typedef struct flags_struct {
    EM_uint_t v:1;
    EM_uint_t d:1;
    EM_uint_t z:1;
    EM_uint_t o:1;
    EM_uint_t un:1; // MACH
    EM_uint_t i:1;
} EM_flags_type;

typedef struct tmp_fp_env_struct { // MACH
    long                     dummy;
    EM_trap_control_type     controls;
    EM_significand_size_type ss;
    EM_exponent_size_type    es;

    EM_sf_rc_type            rc;
    EM_uint_t                ftz:1;

    EM_flags_type            flags;
    EM_flags_type            hi_flags;
    EM_flags_type            lo_flags;

    EM_uint_t                ebc:1;
    EM_uint_t                fpa:1;
    EM_uint_t                hi_fpa:1;
    EM_uint_t                lo_fpa:1;
    EM_uint_t                mdl:1;
    EM_uint_t                mdh:1;
    EM_uint_t                simd:1;

    struct em_faults_struct {
        EM_uint_t v:1;
        EM_uint_t d:1;
        EM_uint_t z:1;
        EM_uint_t swa:1;
    } em_faults;
    struct hi_faults_struct {
        EM_uint_t v:1;
        EM_uint_t d:1;
        EM_uint_t z:1;
        EM_uint_t swa:1;
    } hi_faults;
    struct lo_faults_struct {
        EM_uint_t v:1;
        EM_uint_t d:1;
        EM_uint_t z:1;
        EM_uint_t swa:1;
    } lo_faults;

    struct em_traps_struct {
        EM_uint_t o:1;
        EM_uint_t un:1; // MACH
        EM_uint_t i:1;
    } em_traps;
    struct hi_traps_struct {
        EM_uint_t o:1;
        EM_uint_t un:1; // MACH
        EM_uint_t i:1;
    } hi_traps;
    struct lo_traps_struct {
        EM_uint_t o:1;
        EM_uint_t un:1; // MACH
        EM_uint_t i:1;
    } lo_traps;
} EM_tmp_fp_env_type;

typedef struct fp_dp_struct {
    EM_uint_t sticky:1;
    EM_uint128_t significand;
    EM_uint_t exponent:19;
    EM_uint_t sign:1;
} EM_fp_dp_type;

/*************************/
/* Register Definitions */
/*************************/

typedef struct gr_reg_struct {
    EM_uint64_t value;
    EM_uint_t nat:1;
} EM_gr_reg_type;

typedef struct fp_reg_struct {
    EM_uint64_t significand;
    EM_uint_t exponent:17;
    EM_uint_t sign:1;
} EM_fp_reg_type;

typedef struct pair_fp_reg_struct {
    EM_fp_reg_type hi;
    EM_fp_reg_type lo;
} EM_pair_fp_reg_type;

typedef struct sf_struct {
    EM_controls_type controls;
    EM_flags_type    flags;
} EM_sf_type;

typedef struct cfm_struct {
#ifdef BIG_ENDIAN
    EM_uint_t reserved         :26;
    EM_uint_t rrb_pr           : 6;
    EM_uint_t sof              : 7;
    EM_uint_t sol              : 7;
    EM_uint_t sor              : 4;
    EM_uint_t rrb_gr           : 7;
    EM_uint_t rrb_fr           : 7;
#endif
#ifdef LITTLE_ENDIAN
    EM_uint_t rrb_fr           : 7;
    EM_uint_t rrb_gr           : 7;
    EM_uint_t sor              : 4;
    EM_uint_t sol              : 7;
    EM_uint_t sof              : 7;
    EM_uint_t rrb_pr           : 6;
    EM_uint_t reserved         :26;
#endif
} EM_cfm_type;

typedef struct fpsr_struct {
#ifdef BIG_ENDIAN
    EM_uint_t reserved         : 6;
    EM_uint_t sf3_flags_i      : 1;
    EM_uint_t sf3_flags_u      : 1;
    EM_uint_t sf3_flags_o      : 1;
    EM_uint_t sf3_flags_z      : 1;
    EM_uint_t sf3_flags_d      : 1;
    EM_uint_t sf3_flags_v      : 1;
    EM_uint_t sf3_controls_td  : 1;
    EM_uint_t sf3_controls_rc  : 2;
    EM_uint_t sf3_controls_pc  : 2;
    EM_uint_t sf3_controls_wre : 1;
    EM_uint_t sf3_controls_ftz : 1;
    EM_uint_t sf2_flags_i      : 1;
    EM_uint_t sf2_flags_u      : 1;
    EM_uint_t sf2_flags_o      : 1;
    EM_uint_t sf2_flags_z      : 1;
    EM_uint_t sf2_flags_d      : 1;
    EM_uint_t sf2_flags_v      : 1;
    EM_uint_t sf2_controls_td  : 1;
    EM_uint_t sf2_controls_rc  : 2;
    EM_uint_t sf2_controls_pc  : 2;
    EM_uint_t sf2_controls_wre : 1;
    EM_uint_t sf2_controls_ftz : 1;
    EM_uint_t sf1_flags_i      : 1;
    EM_uint_t sf1_flags_u      : 1;
    EM_uint_t sf1_flags_o      : 1;
    EM_uint_t sf1_flags_z      : 1;
    EM_uint_t sf1_flags_d      : 1;
    EM_uint_t sf1_flags_v      : 1;
    EM_uint_t sf1_controls_td  : 1;
    EM_uint_t sf1_controls_rc  : 2;
    EM_uint_t sf1_controls_pc  : 2;
    EM_uint_t sf1_controls_wre : 1;
    EM_uint_t sf1_controls_ftz : 1;
    EM_uint_t sf0_flags_i      : 1;
    EM_uint_t sf0_flags_u      : 1;
    EM_uint_t sf0_flags_o      : 1;
    EM_uint_t sf0_flags_z      : 1;
    EM_uint_t sf0_flags_d      : 1;
    EM_uint_t sf0_flags_v      : 1;
    EM_uint_t sf0_controls_td  : 1;
    EM_uint_t sf0_controls_rc  : 2;
    EM_uint_t sf0_controls_pc  : 2;
    EM_uint_t sf0_controls_wre : 1;
    EM_uint_t sf0_controls_ftz : 1;
    EM_uint_t traps_id         : 1;
    EM_uint_t traps_ud         : 1;
    EM_uint_t traps_od         : 1;
    EM_uint_t traps_zd         : 1;
    EM_uint_t traps_dd         : 1;
    EM_uint_t traps_vd         : 1;
#endif
#ifdef LITTLE_ENDIAN
    EM_uint_t traps_vd         : 1;
    EM_uint_t traps_dd         : 1;
    EM_uint_t traps_zd         : 1;
    EM_uint_t traps_od         : 1;
    EM_uint_t traps_ud         : 1;
    EM_uint_t traps_id         : 1;
    EM_uint_t sf0_controls_ftz : 1;
    EM_uint_t sf0_controls_wre : 1;
    EM_uint_t sf0_controls_pc  : 2;
    EM_uint_t sf0_controls_rc  : 2;
    EM_uint_t sf0_controls_td  : 1;
    EM_uint_t sf0_flags_v      : 1;
    EM_uint_t sf0_flags_d      : 1;
    EM_uint_t sf0_flags_z      : 1;
    EM_uint_t sf0_flags_o      : 1;
    EM_uint_t sf0_flags_u      : 1;
    EM_uint_t sf0_flags_i      : 1;
    EM_uint_t sf1_controls_ftz : 1;
    EM_uint_t sf1_controls_wre : 1;
    EM_uint_t sf1_controls_pc  : 2;
    EM_uint_t sf1_controls_rc  : 2;
    EM_uint_t sf1_controls_td  : 1;
    EM_uint_t sf1_flags_v      : 1;
    EM_uint_t sf1_flags_d      : 1;
    EM_uint_t sf1_flags_z      : 1;
    EM_uint_t sf1_flags_o      : 1;
    EM_uint_t sf1_flags_u      : 1;
    EM_uint_t sf1_flags_i      : 1;
    EM_uint_t sf2_controls_ftz : 1;
    EM_uint_t sf2_controls_wre : 1;
    EM_uint_t sf2_controls_pc  : 2;
    EM_uint_t sf2_controls_rc  : 2;
    EM_uint_t sf2_controls_td  : 1;
    EM_uint_t sf2_flags_v      : 1;
    EM_uint_t sf2_flags_d      : 1;
    EM_uint_t sf2_flags_z      : 1;
    EM_uint_t sf2_flags_o      : 1;
    EM_uint_t sf2_flags_u      : 1;
    EM_uint_t sf2_flags_i      : 1;
    EM_uint_t sf3_controls_ftz : 1;
    EM_uint_t sf3_controls_wre : 1;
    EM_uint_t sf3_controls_pc  : 2;
    EM_uint_t sf3_controls_rc  : 2;
    EM_uint_t sf3_controls_td  : 1;
    EM_uint_t sf3_flags_v      : 1;
    EM_uint_t sf3_flags_d      : 1;
    EM_uint_t sf3_flags_z      : 1;
    EM_uint_t sf3_flags_o      : 1;
    EM_uint_t sf3_flags_u      : 1;
    EM_uint_t sf3_flags_i      : 1;
    EM_uint_t reserved         : 6;
#endif
} EM_fpsr_type;


typedef struct psr_struct {
#ifdef BIG_ENDIAN
    EM_uint_t reserved_field_4:19;
    EM_uint_t bn:1;
    EM_uint_t ed:1;
    EM_uint_t ri:2;
    EM_uint_t ss:1;
    EM_uint_t dd:1;
    EM_uint_t da:1;
    EM_uint_t id:1;
    EM_uint_t it:1;
    EM_uint_t mc:1;
    EM_uint_t is:1;
    EM_uint_t cpl:2;
    EM_uint_t reserved_field_3:4;
    EM_uint_t rt:1;
    EM_uint_t tb:1;
    EM_uint_t lp:1;
    EM_uint_t db:1;
    EM_uint_t si:1;
    EM_uint_t di:1;
    EM_uint_t pp:1;
    EM_uint_t sp:1;
    EM_uint_t dfh:1;
    EM_uint_t dfl:1;
    EM_uint_t dt:1;
    EM_uint_t reserved_field_2:1;
    EM_uint_t pk:1;
    EM_uint_t i:1;
    EM_uint_t ic:1;
    EM_uint_t reserved_field_1:7;
    EM_uint_t mfh:1;
    EM_uint_t mfl:1;
    EM_uint_t ac:1;
    EM_uint_t up:1;
    EM_uint_t be:1;
    EM_uint_t or:1;
#endif
#ifdef LITTLE_ENDIAN
    EM_uint_t or:1;
    EM_uint_t be:1;
    EM_uint_t up:1;
    EM_uint_t ac:1;
    EM_uint_t mfl:1;
    EM_uint_t mfh:1;
    EM_uint_t reserved_field_1:7;
    EM_uint_t ic:1;
    EM_uint_t i:1;
    EM_uint_t pk:1;
    EM_uint_t reserved_field_2:1;
    EM_uint_t dt:1;
    EM_uint_t dfl:1;
    EM_uint_t dfh:1;
    EM_uint_t sp:1;
    EM_uint_t pp:1;
    EM_uint_t di:1;
    EM_uint_t si:1;
    EM_uint_t db:1;
    EM_uint_t lp:1;
    EM_uint_t tb:1;
    EM_uint_t rt:1;
    EM_uint_t reserved_field_3:4;
    EM_uint_t cpl:2;
    EM_uint_t is:1;
    EM_uint_t mc:1;
    EM_uint_t it:1;
    EM_uint_t id:1;
    EM_uint_t da:1;
    EM_uint_t dd:1;
    EM_uint_t ss:1;
    EM_uint_t ri:2;
    EM_uint_t ed:1;
    EM_uint_t bn:1;
    EM_uint_t reserved_field_4:19;
#endif
} EM_psr_type;

typedef union ar_union {
    EM_fpsr_type fpsr;
    EM_uint64_t  uint_value;
} EM_ar_type;

/*****************************/
/* memory format definitions */
/*****************************/

typedef union memory_union {
        struct int_8_struct {
            EM_int_t ivalue:8;
        } int_8;
        struct int_16_struct {
            EM_int_t ivalue:16;
        } int_16;
        struct int_32_struct {
            EM_int_t ivalue:32;
        } int_32;
        struct int_64_struct {
            EM_int64_t ivalue;
        } int_64;
        struct uint_8_struct {
            EM_uint_t uvalue:8;
        } uint_8;
        struct uint_16_struct {
            EM_uint_t uvalue:16;
        } uint_16;
        struct uint_32_struct {
            EM_uint_t uvalue:32;
        } uint_32;
        struct uint_64_struct {
            EM_uint64_t uvalue;
        } uint_64;
        struct c_float_struct {
            float fvalue;
        } c_float;
        struct c_double_struct {
            double fvalue;
        } c_double;
        struct c_long_double_struct {
            long double fvalue;
        } c_long_double;

        struct fp_single_struct {
#ifdef BIG_ENDIAN
            EM_uint_t sign:1;
            EM_uint_t exponent:8;
            EM_uint_t significand:23;
#endif
#ifdef LITTLE_ENDIAN
            EM_uint_t significand:23;
            EM_uint_t exponent:8;
            EM_uint_t sign:1;
#endif
        } fp_single;

        struct fp_double_struct {
#ifdef BIG_ENDIAN
            EM_uint_t sign:1;
            EM_uint_t exponent:11;
            EM_uint_t significand_hi:20;
            EM_uint_t significand_lo:32;
#endif
#ifdef LITTLE_ENDIAN
            EM_uint_t significand_lo:32;
            EM_uint_t significand_hi:20;
            EM_uint_t exponent:11;
            EM_uint_t sign:1;

#endif
        } fp_double;

        struct fp_double_extended_struct {
#ifdef BIG_ENDIAN
            EM_uint_t sign:1;
            EM_uint_t exponent:15;
            EM_ushort_t significand[4];
#endif
#ifdef LITTLE_ENDIAN
            EM_ushort_t significand[4];
            EM_uint_t exponent:15;
            EM_uint_t sign:1;
#endif
        } fp_double_extended;

        struct fp_spill_fill_struct {
#ifdef BIG_ENDIAN
            EM_uint_t reserved2:32;
            EM_uint_t reserved1:14;
            EM_uint_t sign:1;
            EM_uint_t exponent:17;
            EM_uint64_t significand;
#endif
#ifdef LITTLE_ENDIAN
            EM_uint64_t significand;
            EM_uint_t exponent:17;
            EM_uint_t sign:1;
            EM_uint_t reserved1:14;
            EM_uint_t reserved2:32;
#endif
        } fp_spill_fill;


        struct uint_32_pair_struct {
#ifdef BIG_ENDIAN
            EM_uint_t hi:32;
            EM_uint_t lo:32;
#endif
#ifdef LITTLE_ENDIAN
            EM_uint_t lo:32;
            EM_uint_t hi:32;
#endif
        } uint_32_pair;
        struct uint_64_pair_struct {
#ifdef BIG_ENDIAN
            EM_uint64_t hi;
            EM_uint64_t lo;
#endif
#ifdef LITTLE_ENDIAN
            EM_uint64_t lo;
            EM_uint64_t hi;
#endif
        } uint_64_pair;

} EM_memory_type;

typedef struct EM_form_struct {
  EM_boolean_t advanced_form;
  EM_boolean_t clear_form;
  EM_boolean_t double_form;
  EM_boolean_t exponent_form;

  EM_boolean_t fp82_floating_form;
  EM_boolean_t fcheck_branch_implemented;
  EM_boolean_t general_form;
  EM_boolean_t data_form;
  EM_boolean_t control_form;
  EM_boolean_t high_form;
  EM_boolean_t high_unsigned_form;

  EM_boolean_t low_form;
  EM_boolean_t mix_l_form;
  EM_boolean_t mix_r_form;
  EM_boolean_t mix_lr_form;

  EM_boolean_t neg_sign_form;
  EM_boolean_t no_clear_form;
  EM_boolean_t pack_form;

  EM_boolean_t no_base_update_form;
  EM_boolean_t immediate_base_update_form;
  EM_boolean_t register_base_update_form;

  EM_boolean_t sign_form;
  EM_boolean_t sign_exp_form;
  EM_boolean_t signed_form;
  EM_boolean_t significand_form;
  EM_boolean_t single_form;
  EM_boolean_t spill_form;
  EM_boolean_t swap_form;
  EM_boolean_t swap_nl_form;
  EM_boolean_t swap_nr_form;
  EM_boolean_t sxt_l_form;
  EM_boolean_t sxt_r_form;

  EM_boolean_t trunc_form;
  EM_boolean_t unsigned_form;
} EM_form_type;

typedef void (*EM_EXCP_FAULT)(void*, EM_uint_t);
typedef void (*EM_EXCP_TRAP)(void*, EM_uint_t);
typedef void (*EM_EXCP_SPEC)(void*, EM_uint_t, EM_uint64_t);


typedef struct EM_state_struct {
  EM_psr_type            state_PSR;
  EM_uint64_t            state_IP;
  EM_ar_type             state_AR[1];
  EM_fp_reg_type         state_FR[MAX_REAL_FR_INDEX];
  EM_gr_reg_type         state_GR[MAX_REAL_GR_INDEX];
  EM_boolean_t           state_PR[EM_NUM_PR];
  EM_memory_type         state_MEM[EM_NUM_MEM];
  EM_form_type           state_form;
  EM_uint_t              state_MERCED_RTL;
  EM_EXCP_FAULT          state_fp82_fp_exception_fault;
  EM_EXCP_TRAP           state_fp82_fp_exception_trap;
  void                   *state_user_context;
  EM_uint_t              trap_type; // 0 - fault; 1 - trap
} EM_state_type;


#endif /* _EM_TYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\flush2.c ===
/*++

Module Name:

    flush2.c

Abstract:

    This module implements IA64 version of KeFlushIoBuffers.

    N.B. May be implemented as a macro.

Author:

    07-July-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"


VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    )
/*++

Routine Description:

   This function flushes the I/O buffer specified by the memory descriptor
   list from the data cache on the processor which executes.

Arugements:

   Mdl - Supplies a pointer to a memory descriptor list that describes the
       I/O buffer location.

   ReadOperation - Supplies a boolean value that determines whether the I/O
       operation is a read into memory.

   DmaOperation - Supplies a boolean value that deternines whether the I/O
       operation is a DMA operation.

Return Value:

   None.

--*/
{
    KIRQL  OldIrql;
    ULONG  Length, PartialLength, Offset;
    PFN_NUMBER  PageFrameIndex;
    PPFN_NUMBER Page;
    PVOID CurrentVAddress = 0;

    ASSERT(KeGetCurrentIrql() <=  KiSynchIrql);

    //
    // If the operation is a DMA operation, then check if the flush
    // can be avoided because the host system supports the right set
    // of cache coherency attributes. Otherwise, the flush can also
    // be avoided if the operation is a programmed I/O and not a page
    // read.
    //

    if (DmaOperation != FALSE) {
        if (ReadOperation != FALSE ) {

        //
        // Yes, it is a DMA operation, and yes, it is a read. IA64
        // I-Caches DO snoop for DMA cycles.
        //
            return;
        } else {
             //
             // It is a DMA Write operation
             //
             __mf();
             return;
        }

    } else if ((Mdl->MdlFlags & MDL_IO_PAGE_READ) == 0) {
        //
        // It is a PIO operation and it is not Page in operation
        //
        return;
    } else if (ReadOperation != FALSE) {

        //
        // It is a PIO operation, it is Read operation and is Page in
        // operation.
        // We need to sweep the cache.
        // Sweeping the range covered by the mdl will be broadcast to the
        // other processors by the h/w coherency mechanism.
        //
        // Raise IRQL to synchronization level to prevent a context switch.
        //

        OldIrql = KeRaiseIrqlToSynchLevel();

        //
        // Compute the number of pages to flush and the starting MDL page
        // frame address.
        //

        Length = Mdl->ByteCount;

        if ( !Length ) {
            return;
        }
        Offset = Mdl->ByteOffset;
        PartialLength = PAGE_SIZE - Offset;
        if (PartialLength > Length) {
            PartialLength = Length;
        }

        Page = (PPFN_NUMBER)(Mdl + 1);
        PageFrameIndex = *Page;
        CurrentVAddress = ((PVOID)(KSEG3_BASE
                          | ((ULONG_PTR)(PageFrameIndex) << PAGE_SHIFT)
                          | Offset));

        //
        // Region 4 maps 1:1 Virtual address to physical address
        //

        HalSweepIcacheRange (
            CurrentVAddress,
            PartialLength
            );

        Page++;
        Length -= PartialLength;

        if (Length) {
            PartialLength = PAGE_SIZE;
            do {
                PageFrameIndex = *Page;
                CurrentVAddress = ((PVOID)(KSEG3_BASE
                    | ((ULONG_PTR)(PageFrameIndex) << PAGE_SHIFT)
                    | Offset));

                if (PartialLength > Length) {
                    PartialLength = Length;
                }

                HalSweepIcacheRange (
                    CurrentVAddress,
                    PartialLength
                    );

                Page++;

                Length -= PartialLength;
            } while (Length != 0);
        }

    //
    // Synchronize the Instruction Prefetch pipe in the local processor.
    //

    __synci();
    __isrlz();

    //
    // Lower IRQL to its previous level and return.
    //
   
    KeLowerIrql(OldIrql);
    return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\flushtb.c ===
/*++

Module Name:

    flushtb.c

Abstract:

    This module implement machine dependent functions to flush the
    translation buffer and synchronize PIDs in an MP system.

Author:

    Koichi Yamada 2-Jan-95

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

extern KSPIN_LOCK KiTbBroadcastLock;

#define _x256mb (1024*1024*256)

#define KiFlushSingleTbGlobal(Invalid, Va) __ptcga((__int64)Va, PAGE_SHIFT << 2)

#define KiFlushSingleTbLocal(Invalid, va) __ptcl((__int64)va, PAGE_SHIFT << 2)

#define KiTbSynchronizeGlobal() { __mf(); __isrlz(); }

#define KiTbSynchronizeLocal() {  __isrlz(); }

#define KiFlush2gbTbGlobal(Invalid) \
  { \
    __ptcga((__int64)0, 28 << 2); \
    __ptcg((__int64)_x256mb, 28 << 2); \
    __ptcg((__int64)_x256mb*2,28 << 2); \
    __ptcg((__int64)_x256mb*3, 28 << 2); \
    __ptcg((__int64)_x256mb*4, 28 << 2); \
    __ptcg((__int64)_x256mb*5, 28 << 2); \
    __ptcg((__int64)_x256mb*6, 28 << 2); \
    __ptcg((__int64)_x256mb*7, 28 << 2); \
  }

#define KiFlush2gbTbLocal(Invalid) \
  { \
    __ptcl((__int64)0, 28 << 2); \
    __ptcl((__int64)_x256mb, 28 << 2); \
    __ptcl((__int64)_x256mb*2,28 << 2); \
    __ptcl((__int64)_x256mb*3, 28 << 2); \
    __ptcl((__int64)_x256mb*4, 28 << 2); \
    __ptcl((__int64)_x256mb*5, 28 << 2); \
    __ptcl((__int64)_x256mb*6, 28 << 2); \
    __ptcl((__int64)_x256mb*7, 28 << 2); \
  }

//
// flag to perform the IPI based TLB shootdown
//

BOOLEAN KiIpiTbShootdown = TRUE;

VOID
KiAttachRegion(
    IN PKPROCESS Process
    );

VOID
KiDetachRegion(
    VOID
    );


//
// Define forward referenced prototypes.
//

VOID
KiFlushEntireTbTarget (
    IN PULONG SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiFlushForwardProgressTbBuffer(
    KAFFINITY TargetProcessors
    );

VOID
KiFlushForwardProgressTbBufferLocal(
    VOID
    );

KiPurgeTranslationCache (
    ULONGLONG Base,
    ULONGLONG Stride1,
    ULONGLONG Stride2,
    ULONGLONG Count1,
    ULONGLONG Count2
    );

extern IA64_PTCE_INFO KiIA64PtceInfo;

VOID
KeFlushCurrentTb (
    VOID
    )
{
    KiPurgeTranslationCache( 
        KiIA64PtceInfo.PtceBase, 
        KiIA64PtceInfo.PtceStrides.Strides1, 
        KiIA64PtceInfo.PtceStrides.Strides2, 
        KiIA64PtceInfo.PtceTcCount.Count1, 
        KiIA64PtceInfo.PtceTcCount.Count2);
}



VOID
KeFlushEntireTb (
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes the entire translation buffer (TB) on all
    processors that are currently running threads which are children
    of the current process or flushes the entire translation buffer
    on all processors in the host configuration.

Arguments:

    Invalid - Supplies a boolean value that specifies the reason for
        flushing the translation buffer.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

Return Value:

    None.


--*/

{

    KIRQL OldIrql;
    KAFFINITY TargetProcessors;

#if defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

#else

    KiLockContextSwap(&OldIrql);
    TargetProcessors = KeActiveProcessors & PCR->NotMember;
    KiSetTbFlushTimeStampBusy();
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushEntireTbTarget,
                        NULL,
                        NULL,
                        NULL);
    }

    if (PsGetCurrentProcess()->Wow64Process != NULL) {
        KiFlushForwardProgressTbBufferLocal();
    }

#endif

    KeFlushCurrentTb();

    //
    // flush ALAT
    //

    __invalat();

    //
    // Wait until all target processors have finished.
    //

#if defined(NT_UP)

    InterlockedIncrement((PLONG)&KiTbFlushTimeStamp);
    KeLowerIrql(OldIrql);

#else

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    KiClearTbFlushTimeStampBusy();
    KiUnlockContextSwap(OldIrql);

#endif

    return;
}



VOID
KiFlushEntireTbTarget (
    IN PULONG SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for flushing the entire TB.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Parameter1 - Parameter3 - Not used.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    //
    // Flush the entire TB on the current processor.
    //

    KiIpiSignalPacketDone(SignalDone);

    KiFlushForwardProgressTbBufferLocal();

    KeFlushCurrentTb();

    //
    // flush ALAT
    //

    __invalat();

#endif

    return;
}

#if !defined(NT_UP)

VOID
KiFlushMultipleTbTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Number,
    IN PVOID Virtual,
    IN PVOID Process
    )

/*++

Routine Description:

    This is the target function for flushing multiple TB entries.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Number - Supplies the number of TB entries to flush.

    Virtual - Supplies a pointer to an array of virtual addresses that
        are within the pages whose translation buffer entries are to be
        flushed.

    Process - Supplies a KPROCESS pointer which needs TB be flushed.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Limit;
    BOOLEAN SameProcess = FALSE;

    Limit = (ULONG)((ULONG_PTR)Number);

    //
    // Flush the specified virtual address for the TB on the current
    // processor.
    //

    KiFlushForwardProgressTbBufferLocal();

    if (Process == (PKPROCESS)PCR->Pcb) {
        SameProcess = TRUE;
    } else {
        KiAttachRegion((PKPROCESS)Process);
    }

    for (Index = 0; Index < Limit; Index += 1) {
        KiFlushSingleTbLocal((BOOLEAN)Invalid, ((PVOID *)(Virtual))[Index]);
    }

#ifdef MI_ALTFLG_FLUSH2G
    if (((PEPROCESS)Process)->Flags & PS_PROCESS_FLAGS_WOW64_SPLIT_PAGES) {
        ASSERT (((PEPROCESS)Process)->Wow64Process != NULL);
        KiFlush2gbTbLocal(Invalid);
    }
#endif

    if (SameProcess != TRUE) {
        KiDetachRegion();
    }

    KiIpiSignalPacketDone(SignalDone);

    __invalat();

    KiTbSynchronizeLocal();
}
#endif

VOID
KeFlushMultipleTb (
    IN ULONG Number,
    IN PVOID *Virtual,
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors,
    IN PHARDWARE_PTE *PtePointer OPTIONAL,
    IN HARDWARE_PTE PteValue
    )

/*++

Routine Description:

    This function flushes multiple entries from the translation buffer
    on all processors that are currently running threads which are
    children of the current process or flushes multiple entries from
    the translation buffer on all processors in the host configuration.

    N.B. The specified translation entries on all processors in the host
         configuration are always flushed since PowerPC TB is tagged by
         VSID and translations are held across context switch boundaries.

Arguments:

    Number - Supplies the number of TB entries to flush.

    Virtual - Supplies a pointer to an array of virtual addresses that
        are within the pages whose translation buffer entries are to be
        flushed.

    Invalid - Supplies a boolean value that specifies the reason for
        flushing the translation buffer.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

    PtePointer - Supplies an optional pointer to an array of pointers to
       page table entries that receive the specified page table entry
       value.

    PteValue - Supplies the the new page table entry value.

Return Value:

    None.

--*/

{

    ULONG Index;
    PKPRCB Prcb;
    KAFFINITY TargetProcessors;
    KIRQL OldIrql;
    PVOID Wow64Process;
    PEPROCESS Process;
    BOOLEAN Flush2gb = FALSE;

#if defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

#else

    KiLockContextSwap(&OldIrql);

#endif

    Process = PsGetCurrentProcess();
    Wow64Process = Process->Wow64Process;

#ifdef MI_ALTFLG_FLUSH2G
    if (Process->Flags & PS_PROCESS_FLAGS_WOW64_SPLIT_PAGES) {
        ASSERT (Wow64Process != NULL);
        Flush2gb = TRUE;
    }
#endif

    //
    // If a page table entry address array is specified, then set the
    // specified page table entries to the specific value.
    //

#if !defined(NT_UP)

    TargetProcessors = KeActiveProcessors;
    TargetProcessors &= PCR->NotMember;

    if (TargetProcessors != 0) {

        //
        // Acquire a global lock. Only one processor at a time can issue
        // a PTC.G operation.
        //

        if (KiIpiTbShootdown == TRUE) {

            for (Index = 0; Index < Number; Index += 1) {
                if (ARGUMENT_PRESENT(PtePointer)) {
                    *PtePointer[Index] = PteValue;
                }
            }

            KiIpiSendPacket(TargetProcessors,
                            KiFlushMultipleTbTarget,
                            (PVOID)(ULONG_PTR)Number,
                            (PVOID)Virtual,
                            (PVOID)PsGetCurrentProcess());

            if (Wow64Process != NULL) {
                KiFlushForwardProgressTbBufferLocal();
            }

            //
            // Flush the specified entries from the TB on the current processor.
            //

            for (Index = 0; Index < Number; Index += 1) {
                KiFlushSingleTbLocal(Invalid, Virtual[Index]);
            }

            //
            // flush ALAT
            //

            __invalat();

            KiIpiStallOnPacketTargets(TargetProcessors);

            KiTbSynchronizeLocal();

        } else {

            KiAcquireSpinLock(&KiTbBroadcastLock);

            for (Index = 0; Index < Number; Index += 1) {
                if (ARGUMENT_PRESENT(PtePointer)) {
                    *PtePointer[Index] = PteValue;
                }

                //
                // Flush the specified TB on each processor. Hardware automatically
                // perform broadcasts if MP.
                //

                KiFlushSingleTbGlobal(Invalid, Virtual[Index]);
            }

            if (Wow64Process != NULL) {
                KiFlushForwardProgressTbBuffer(TargetProcessors);
            }

            if (Flush2gb == TRUE) {
                KiFlush2gbTbGlobal(Invalid);
            }

            //
            // Wait for the broadcast to be complete.
            //

            KiTbSynchronizeGlobal();

            KiReleaseSpinLock(&KiTbBroadcastLock);

        }

    }
    else {

        for (Index = 0; Index < Number; Index += 1) {
            if (ARGUMENT_PRESENT(PtePointer)) {
                *PtePointer[Index] = PteValue;
            }

            //
            // Flush the specified TB on the local processor.  No broadcast is
            // performed.
            //

            KiFlushSingleTbLocal(Invalid, Virtual[Index]);
        }

        if (Wow64Process != NULL) {
            KiFlushForwardProgressTbBufferLocal();
        }

        if (Flush2gb == TRUE) {
            KiFlush2gbTbLocal(Invalid);
        }

        KiTbSynchronizeLocal();
    }

    KiUnlockContextSwap(OldIrql);

#else

    for (Index = 0; Index < Number; Index += 1) {
        if (ARGUMENT_PRESENT(PtePointer)) {
           *PtePointer[Index] = PteValue;
        }

        //
        // Flush the specified TB on the local processor.  No broadcast is
        // performed.
        //

        KiFlushSingleTbLocal(Invalid, Virtual[Index]);
    }

    if (Wow64Process != NULL) {
        KiFlushForwardProgressTbBufferLocal();
    }

    if (Flush2gb == TRUE) {
        KiFlush2gbTbLocal(Invalid);
    }

    KiTbSynchronizeLocal();

    KeLowerIrql(OldIrql);

#endif

    return;
}

#if !defined(NT_UP)

VOID
KiFlushSingleTbTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Virtual,
    IN PKPROCESS Process,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for flushing a single TB entry.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Virtual - Supplies a virtual address that is within the page whose
        translation buffer entry is to be flushed.

    RequestPacket - Supplies a pointer to a flush single TB packet address.

    Process - Supplies a KPROCESS pointer which needs TB be flushed.

    Parameter3 - Not used.

Return Value:

    None.

--*/

{
    BOOLEAN SameProcess = FALSE;

    //
    // Flush a single entry from the TB on the current processor.
    //

    KiFlushForwardProgressTbBufferLocal();

    if (Process == (PKPROCESS)PCR->Pcb) { 
        SameProcess = TRUE;
    } else {
        KiAttachRegion((PKPROCESS)Process);
    }

    KiFlushSingleTbLocal(TRUE, Virtual);

#ifdef MI_ALTFLG_FLUSH2G
    if (((PEPROCESS)Process)->Flags & PS_PROCESS_FLAGS_WOW64_SPLIT_PAGES) {
        ASSERT (((PEPROCESS)Process)->Wow64Process != NULL);
        KiFlush2gbTbLocal(Invalid);
    }
#endif

    if (SameProcess != TRUE) {
        KiDetachRegion();
    }

    KiIpiSignalPacketDone(SignalDone);

    __invalat();

    KiTbSynchronizeLocal();

    return;
}
#endif

HARDWARE_PTE
KeFlushSingleTb (
    IN PVOID Virtual,
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors,
    IN PHARDWARE_PTE PtePointer,
    IN HARDWARE_PTE PteValue
    )

/*++

Routine Description:

    This function flushes a single entry from the translation buffer
    on all processors that are currently running threads which are
    children of the current process or flushes a single entry from
    the translation buffer on all processors in the host configuration.

    N.B. The specified translation entry on all processors in the host
         configuration is always flushed since PowerPC TB is tagged by
         VSID and translations are held across context switch boundaries.

Arguments:

    Virtual - Supplies a virtual address that is within the page whose
        translation buffer entry is to be flushed.

    Invalid - Supplies a boolean value that specifies the reason for
        flushing the translation buffer.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

    PtePointer - Supplies a pointer to the page table entry which
        receives the specified value.

    PteValue - Supplies the the new page table entry value.

Return Value:

    The previous contents of the specified page table entry is returned
    as the function value.

--*/

{

    HARDWARE_PTE OldPte;
    PKPRCB Prcb;
    KAFFINITY TargetProcessors;
    KIRQL OldIrql;
    PEPROCESS Process;
    PVOID Wow64Process;
    BOOLEAN Flush2gb = FALSE;

#if defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

#else

    KiLockContextSwap(&OldIrql);

#endif

    Process = (PEPROCESS)PsGetCurrentProcess();
    Wow64Process = Process->Wow64Process;

#ifdef MI_ALTFLG_FLUSH2G

    if (Process->Flags & PS_PROCESS_FLAGS_WOW64_SPLIT_PAGES) {
        ASSERT (((PEPROCESS)Process)->Wow64Process != NULL);
        Flush2gb = TRUE;
    }
#endif

    //
    // Capture the previous contents of the page table entry and set the
    // page table entry to the new value.
    //

    OldPte = *PtePointer;
    *PtePointer = PteValue;

#if !defined(NT_UP)

    TargetProcessors = KeActiveProcessors;
    TargetProcessors &= PCR->NotMember;

    if (TargetProcessors != 0) {

        if (KiIpiTbShootdown == TRUE) {

            KiIpiSendPacket(TargetProcessors,
                            KiFlushSingleTbTarget,
                            (PVOID)Virtual,
                            (PVOID)PsGetCurrentProcess(),
                            NULL);

            if (Wow64Process != NULL) {
                KiFlushForwardProgressTbBufferLocal();
            }

            KiFlushSingleTbLocal(Invalid, Virtual);

            //
            // flush ALAT
            //

            __invalat();

            KiIpiStallOnPacketTargets(TargetProcessors);

        } else {

            //
            // Flush the specified TB on each processor. Hardware automatically
            // perform broadcasts if MP.
            //

            KiAcquireSpinLock(&KiTbBroadcastLock);

            KiFlushSingleTbGlobal(Invalid, Virtual);

            if (Wow64Process != NULL) {
                KiFlushForwardProgressTbBuffer(TargetProcessors);
            }

            if (Flush2gb) {
                KiFlush2gbTbGlobal(Invalid);
            }

            KiTbSynchronizeGlobal();

            KiReleaseSpinLock(&KiTbBroadcastLock);
        }
    }
    else {

        //
        // Flush the specified TB on the local processor.  No broadcast is
        // performed.
        //

        KiFlushSingleTbLocal(Invalid, Virtual);

        if (Wow64Process != NULL) {
            KiFlushForwardProgressTbBufferLocal();
        }

        if (Flush2gb == TRUE) {
            KiFlush2gbTbLocal(Invalid);
        }

        KiTbSynchronizeLocal();

    }

    KiUnlockContextSwap(OldIrql);

#else

    //
    // Flush the specified entry from the TB on the local processor.
    //

    KiFlushSingleTbLocal(Invalid, Virtual);

    if (Wow64Process != NULL) {
        KiFlushForwardProgressTbBufferLocal();
    }

    if (Flush2gb == TRUE) {
        KiFlush2gbTbLocal(Invalid);
    }

    KiTbSynchronizeLocal();

    KeLowerIrql(OldIrql);

#endif

    //
    // Return the previous page table entry value.
    //

    return OldPte;
}

VOID
KiFlushForwardProgressTbBuffer(
    KAFFINITY TargetProcessors
    )
{
    PKPRCB Prcb;
    ULONG BitNumber;
    PKPROCESS CurrentProcess;
    PKPROCESS TargetProcess;
    PKPCR Pcr;
    ULONG i;
    PVOID Va;
    volatile ULONGLONG *PointerPte;

    CurrentProcess = KeGetCurrentThread()->ApcState.Process;

    //
    // Flush the ForwardProgressTb buffer on the current processor
    //

    for (i = 0; i < MAXIMUM_FWP_BUFFER_ENTRY; i += 1) {

        Va = (PVOID)PCR->ForwardProgressBuffer[i*2];
        PointerPte = &PCR->ForwardProgressBuffer[(i*2)+1];

        if (*PointerPte != 0) {
            *PointerPte = 0;
            KiFlushSingleTbGlobal(Invalid, Va);
        }

    }

    //
    // Flush the ForwardProgressTb buffer on all the processors
    //

    while (TargetProcessors != 0) {

        KeFindFirstSetLeftAffinity(TargetProcessors, &BitNumber);
        ClearMember(BitNumber, TargetProcessors);
        Prcb = KiProcessorBlock[BitNumber];

        Pcr = KSEG_ADDRESS(Prcb->PcrPage);

        TargetProcess = (PKPROCESS)Pcr->Pcb;

        if (TargetProcess == CurrentProcess) {

            for (i = 0; i < MAXIMUM_FWP_BUFFER_ENTRY; i += 1) {

                Va = (PVOID)Pcr->ForwardProgressBuffer[i*2];
                PointerPte = &Pcr->ForwardProgressBuffer[(i*2)+1];

                if (*PointerPte != 0) {
                    *PointerPte = 0;
                    KiFlushSingleTbGlobal(Invalid, Va);
                }
            }
        }
    }
}

VOID
KiFlushForwardProgressTbBufferLocal(
    VOID
    )
{
    ULONG i;
    PVOID Va;
    volatile ULONGLONG *PointerPte;

    //
    // Flush the ForwardProgressTb buffer on the current processor
    //

    for (i = 0; i < MAXIMUM_FWP_BUFFER_ENTRY; i += 1) {

        Va = (PVOID)PCR->ForwardProgressBuffer[i*2];
        PointerPte = &PCR->ForwardProgressBuffer[(i*2)+1];

        if (*PointerPte != 0) {
            *PointerPte = 0;
            KiFlushSingleTbLocal(Invalid, Va);
        }

    }
}

VOID
KeSynchronizeMemoryAccess (
    VOID
    )

/*++

Routine Description:

    This function synchronizes memory access across all processors in the
    host configuration.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // BUGBUG : This needs to be fleshed out with real code.
    //

    return;
}

LONG KeTempTimeStamp;

ULONG
KeReadMbTimeStamp (
    VOID
    )
{
    //
    // BUGBUG : This needs to be fleshed out with real code.
    //

    return (ULONG) InterlockedIncrement (&KeTempTimeStamp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\fpswa.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    fpswa.h
    
Abstract:

    EFI driver wrapper for FPSWA

Revision History

--*/

// #include "efi.h"
// #include "efilib.h"

//
// First define PAL_RETURN
//
// typedef int PAL_RETURN;

//
// Global ID for fpswa driver & protocol
//



#define EFI_INTEL_FPSWA     \
    { 0xc41b6531, 0x97b9, 0x11d3, 0x9a, 0x29, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

#define EFI_INTEL_FPSWA_REVISION    0x00010000

//
//
//

typedef 
PAL_RETURN
(*EFI_FPSWA) (
    IN unsigned int     TrapType,
    IN OUT BUNDLE       *pBundle,
    IN OUT UINT64       *pipsr,
    IN OUT UINT64       *pfsr,
    IN OUT UINT64       *pisr,
    IN OUT UINT64       *ppreds,
    IN OUT UINT64       *pifs,
    IN OUT FP_STATE     *fp_state
    );


typedef struct _FPSWA_INTERFACE {
    UINT32      Revision;
    UINT32      Reserved;
    EFI_FPSWA   Fpswa;    
} FPSWA_INTERFACE;

//
// Prototypes
//

// PAL_RETURN
// fp_emulate (
//   IN unsigned int             TrapType,
//   IN OUT BUNDLE               *pBundle,
//   IN OUT UINT64               *pipsr,
//   IN OUT UINT64               *pfsr,
//   IN OUT UINT64               *pisr,
//   IN OUT UINT64               *ppreds,
//   IN OUT UINT64               *pifs,
//   IN OUT FP_STATE             *fp_state
//   );

//
// Globals
//

// extern EFI_GUID FpswaId;
// extern FPSWA_INTERFACE FpswaInterface;
// extern EFI_EVENT       FpswaEvent;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\ia32def.h ===
/*++

Module Name:

   iA32DEF.H

Abstract:

   This file defines iA32 macros for iA32Trap.c and Opcode Emulation use

Author:


Environment:

   Kernel mode only.

Revision History:

--*/

#define KERNELONLY  1
// #include ks386.inc
// #include callconv.inc                    // calling convention macros
// #include i386\kimacro.inc
// #include mac386.inc
// #include i386\mi.inc


//
// Equates for exceptions which cause system fatal error
//

#define EXCEPTION_DIVIDED_BY_ZERO       0
#define EXCEPTION_DEBUG                 1
#define EXCEPTION_NMI                   2
#define EXCEPTION_INT3                  3
#define EXCEPTION_BOUND_CHECK           5
#define EXCEPTION_INVALID_OPCODE        6
#define EXCEPTION_NPX_NOT_AVAILABLE     7
#define EXCEPTION_DOUBLE_FAULT          8
#define EXCEPTION_NPX_OVERRUN           9
#define EXCEPTION_INVALID_TSS           0x0A
#define EXCEPTION_SEGMENT_NOT_PRESENT   0x0B
#define EXCEPTION_STACK_FAULT           0x0C
#define EXCEPTION_GP_FAULT              0x0D
#define EXCEPTION_RESERVED_TRAP         0x0F
#define EXCEPTION_NPX_ERROR             0x010
#define EXCEPTION_ALIGNMENT_CHECK       0x011

#define BREAKPOINT_BREAK                0x00
//
// Exception flags
//

#define EXCEPT_UNKNOWN_ACCESS           0
#define EXCEPT_LIMIT_ACCESS             0x10

//
// page fault read/write mask
//

#define ERR_0E_STORE                    2

//
// Debug register 6 (dr6) BS (single step) bit mask
//

#define DR6_BS_MASK                     0x4000

//
// EFLAGS single step bit
//

#define EFLAGS_TF_BIT                   0x100
#define EFLAGS_OF_BIT                   0x4000

//
// The mask of selecot's table indicator (ldt or gdt)
//

#define TABLE_INDICATOR_MASK            4

//
// Opcode for Pop SegReg and iret instructions
//

#define POP_DS                          0x01F
#define POP_ES                          0x07
#define POP_FS                          0x0A10F
#define POP_GS                          0x0A90F
#define IRET_OP                         0x0CF
#define CLI_OP                          0x0FA
#define STI_OP                          0x0FB
#define PUSHF_OP                        0x09C
#define POPF_OP                         0x09D
#define INTNN_OP                        0x00CD
#define FRSTOR_ECX                      0x0021DD9B
#define FWAIT_OP                        0x009b


#define GATE_TYPE_386INT        0x0E00
#define GATE_TYPE_386TRAP       0x0F00
#define GATE_TYPE_TASK          0x0500
#define D_GATE                  0
#define D_PRESENT               0x08000
#define D_DPL_3                 0x06000
#define D_DPL_0                 0

//
// Definitions for present 386 trap and interrupt gate attributes
//

#define D_TRAP032               D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_386TRAP
#define D_TRAP332               D_PRESENT+D_DPL_3+D_GATE+GATE_TYPE_386TRAP
#define D_INT032                D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_386INT
#define D_INT332                D_PRESENT+D_DPL_3+D_GATE+GATE_TYPE_386INT
#define D_TASK                  D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_TASK

//
// Bit patterns for Intercept_Code or Trap_Code,
// patterns used in IIM on IA32 trap
//
#define TRAPCODE_TB             0x0004         // taken branch trap
#define TRAPCODE_SS             0x0008         // single step trap
#define TRAPCODE_B0             0x0010         // Data breakpoint trap
#define TRAPCODE_B1             0x0020
#define TRAPCODE_B2             0x0040
#define TRAPCODE_B3             0x0080

#define INTERCEPT_OS            0x0002         // Operand size
#define INTERCEPT_AS            0x0004         // Address size
#define INTERCEPT_LP            0x0008         // Lock Prefix
#define INTERCEPT_RP            0x0010         // REP prefix
#define INTERCEPT_NP            0x0020         // REPNE prefix
#define INTERCEPT_SP            0x0040         // Segment prefix
#define INTERCEPT_SEG           0x0380         // Segment valuse
#define INTERCEPT_0F            0x0400         // 0F opcode series

#define HARDWARE_VM             0x0800         // VM86 mode
#define HARDWARE_RM             0x1000         // Real Mode
#define HARDWARE_PM             0x2000         // Protect Mode
#define HARDWARE_SS             0x4000         // Stack size, 32 or 16 bits
#define HARDWARE_UR             0x8000         // User or privileged mode


#define MI_SMSW                         0x01
#define MI_SMSW_REGOP                   0x20
//
// Following MI_*** definitions are created from MI386.INC
//
#define MAX_INSTRUCTION_LENGTH          15
#define MAX_INSTRUCTION_PREFIX_LENGTH   4
#define MI_LOCK_PREFIX                  0x0F0
#define MI_REPNE_PREFIX                 0x0F2
#define MI_REP_PREFIX                   0x0F3
#define MI_SEGCS_PREFIX                 0x02E
#define MI_SEGSS_PREFIX                 0x036
#define MI_SEGDS_PREFIX                 0x03E
#define MI_SEGES_PREFIX                 0x026
#define MI_SEGFS_PREFIX                 0x064
#define MI_SEGGS_PREFIX                 0x065
#define MI_OPERANDSIZE_PREFIX           0x066
#define MI_ADDRESSOVERRIDE_PREFIX       0x067
#define MI_TWO_BYTE                     0x0F
#define MI_HLT                          0x0F4
#define MI_LTR_LLDT                     0
#define MI_LGDT_LIDT_LMSW               0x01
#define MI_MODRM_MASK                   0x38
#define MI_LLDT_MASK                    0x10
#define MI_LTR_MASK                     0x18
#define MI_LGDT_MASK                    0x10
#define MI_LIDT_MASK                    0x18
#define MI_LMSW_MASK                    0x30
#define MI_SPECIAL_MOV_MASK             0x20
#define MI_REP_INS_OUTS                 0x0F3
#define MI_MIN_INS_OUTS                 0x06C
#define MI_MAX_INS_OUTS                 0x06F
#define MI_LMSW_OPCODE                  0x001 // second byte of lmsw
#define MI_CLTS_OPCODE                  0x006 // second byte of clts
#define MI_GET_CRx_OPCODE               0x020 // mov r32,CRx
#define MI_SET_CRx_OPCODE               0x022 // mov CRx,r32
#define MI_GET_TRx_OPCODE               0x024 // mov r32,TRx
#define MI_SET_TRx_OPCODE               0x026 // mov TRx,r32
#define MI_REGMASK                      0x038 // REG field mask
#define MI_REGSHIFT                     0x3    // REG field shift
#define MI_REGLMSW                      0x030 // REG field for lmsw
#define MI_MODMASK                      0x0C0 // MOD field mask
#define MI_MODSHIFT                     0x6    // MOD field shift
#define MI_MODMOVSPEC                   0x0C0 // MOD field for mov to/from special
#define MI_MODNONE                      0
#define MI_RMMASK                       0x007 // RM field mask
#define MI_RMBP                         0x006 // RM value for bp reg
#define MI_RMSIB                        0x004 // RM value for sib

#define MI_SIB_BASEMASK                 0x007 // SIB BASE field mask
#define MI_SIB_BASENONE                 0x005
#define MI_SIB_BASESHIFT                0

#define MI_SIB_INDEXMASK                0x038
#define MI_SIB_INDEXSHIFT               3
#define MI_SIB_INDEXNONE                0x020

#define MI_SIB_SSMASK                   0x0c0
#define MI_SIB_SSSHIFT                  0x6


//
// definition for  floating status word error mask
//

#define FSW_INVALID_OPERATION   0x0001
#define FSW_DENORMAL            0x0002
#define FSW_ZERO_DIVIDE         0x0004
#define FSW_OVERFLOW            0x0008
#define FSW_UNDERFLOW           0x0010
#define FSW_PRECISION           0x0020
#define FSW_STACK_FAULT         0x0040
#define FSW_ERROR_SUMMARY       0x0080
#define FSW_CONDITION_CODE_0    0x0100
#define FSW_CONDITION_CODE_1    0x0200
#define FSW_CONDITION_CODE_2    0x0400
#define FSW_CONDITION_CODE_3    0x4000

#define FSW_ERR_MASK            (FSW_INVALID_OPERATION | FSW_DENORMAL | FSW_ZERO_DIVIDE | FSW_OVERFLOW | FSW_UNDERFLOW | FSW_PRECISION | FSW_STACK_FAULT)

//
// Definitions of the shifts to get to the katmai status and control
// Once the bits are shifted, they are in the same place as the
// 387 status and control, so the masks above work as well
// See the IA64 Application Architecture (Vol 1) for where the
// bit shift values come from
//
#define KATMAI_SHIFT_CONTROL    39
#define KATMAI_SHIFT_STATUS     32


#define CPL_STATE(SegCs)   (SegCs & RPL_MASK)

// Use the IIPA since that points to the start of the ia32 instruction
#define EIP(frame)  ((ULONG) (frame)->StIIPA & 0xffffffff)
#define ESP(frame)  ((ULONG) (frame)->IntSp & 0xffffffff)
#define ECX(frame)  ((ULONG) (frame)->IntT2 & 0xffffffff)
#define EDX(frame)  ((ULONG) (frame)->IntT3 & 0xffffffff)

#define ISRCode(frame) ((USHORT) ((frame)->StISR) & 0xffff)
#define ISRVector(frame) ((UCHAR) ((frame)->StISR >> 16) & 0xff)


//
// Helpers for instruction decoding
//

BOOLEAN
KiIa32Compute32BitEffectiveAddress (
    IN PKTRAP_FRAME Frame,
    IN OUT PUCHAR *InstAddr,
    OUT PUINT_PTR Addr,
    OUT PBOOLEAN RegisterMode
    );

NTSTATUS
KiIa32InterceptUnalignedLock (
    IN PKTRAP_FRAME TrapFrame
    );

NTSTATUS
KiIa32ValidateInstruction (
    IN PKTRAP_FRAME TrapFrame
    );


//
// The following register indices are valid only if called through
// GetX86Reg (...)
//

#define IA32_REG_EAX    0
#define IA32_REG_ECX    1
#define IA32_REG_EDX    2
#define IA32_REG_EBX    3
#define IA32_REG_ESP    4
#define IA32_REG_EBP    5
#define IA32_REG_ESI    6
#define IA32_REG_EDI    7

#define IA32_DISP_NONE  0x00
#define IA32_DISP8      0x01
#define IA32_DISP16     0x02

//
// x86 Eflags register layout
//

typedef union _IA32_EFLAGS
{

    ULONGLONG Value;

    struct
    {
        ULONGLONG cf   : 1;
        ULONGLONG v1   : 1;
        ULONGLONG pf   : 1;
        ULONGLONG v2   : 1;
        ULONGLONG af   : 1;
        ULONGLONG v3   : 1;
        ULONGLONG zf   : 1;
        ULONGLONG sf   : 1;
        ULONGLONG tf   : 1;
        ULONGLONG ifl  : 1;
        ULONGLONG df   : 1;
        ULONGLONG of   : 1;
        ULONGLONG iopl : 2;
        ULONGLONG nt   : 1;
        ULONGLONG v4   : 1;
        ULONGLONG rf   : 1;
        ULONGLONG vm   : 1;
        ULONGLONG ac   : 1;
        ULONGLONG vif  : 1;
        ULONGLONG vip  : 1;
        ULONGLONG id   : 1;
    } u;

} IA32_EFLAGS, *PIA32_EFLAGS;


//
// Eflags bits to update
//

#define IA32_EFLAGS_CF  0x0001
#define IA32_EFLAGS_SF  0x0002
#define IA32_EFLAGS_OF  0x0004
#define IA32_EFLAGS_PF  0x0008 
#define IA32_EFLAGS_ZF  0x0010
#define IA32_EFLAGS_AF  0x0020


//
// Operand size
//

typedef enum _IA32_OPERAND_SIZE
{
    OPERANDSIZE_NONE,
    OPERANDSIZE_ONEBYTE,
    OPERANDSIZE_TWOBYTES,
    OPERANDSIZE_FOURBYTES

} IA32_OPERAND_SIZE;

typedef enum _IA32_OPCODE_PARAMETERS
{
    IA32_PARAM_RM8_IMM8,
    IA32_PARAM_RM_IMM,
    IA32_PARAM_RM_IMM8SIGN,
    IA32_PARAM_RM8_R,
    IA32_PARAM_RM_R,
    IA32_PARAM_R_RM8,
    IA32_PARAM_R_RM,
    IA32_PARAM_RM8,
    IA32_PARAM_RM,
    IA32_PARAM_SEGREG_RM8,
    IA32_PARAM_SEGREG_RM

} IA32_OPCODE_PARAMETERS;


//
//   Opcode decription
//
typedef struct _IA32_OPCODE_DESCRIPTION
{

    //
    //   1st, 2nd and 3rd byte. The 3rd byte is actually the /Reg bits
    //

    UCHAR Byte1;
    UCHAR Byte2;
    UCHAR Byte3;
    union 
    {
        UCHAR Value;
        struct 
        {
            UCHAR Bytes     : 4;
            UCHAR RegOpcode : 4;
        } m;
    } Count;

    //
    //   Parameter of this opcode
    //

    UCHAR Type;

    //
    //   Opcode
    //

    UCHAR Opcode;

} IA32_OPCODE_DESCRIPTION, *PIA32_OPCODE_DESCRIPTION;

//
//   Specific data structure to represent the lock-prefixed instruction
//   operands and immediates.
//

typedef struct _IA32_OPERAND
{    
    ULONG_PTR v;
    BOOLEAN RegisterMode;
} IA32_OPERAND, *PIA32_OPERAND;

typedef union _IA32_PREFIX
{
    ULONG Value;

    struct _IA32_PREFIX_BITS
    {
        ULONG Lock            : 1;
        ULONG RepNe           : 1;
        ULONG Rep             : 1;
        ULONG CsOverride      : 1;
        ULONG SsOverride      : 1;
        ULONG DsOverride      : 1;
        ULONG EsOverride      : 1;
        ULONG FsOverride      : 1;
        ULONG GsOverride      : 1;
        ULONG SizeOverride    : 1;
        ULONG AddressOverride : 1;
    } b;

} IA32_PREFIX, *PIA32_PREFIX;

typedef struct _IA32_INSTRUCTION
{
    
    //
    // Instruction EIP
    //

    PCHAR Eip;

    //
    // Instruction description
    //

    PIA32_OPCODE_DESCRIPTION Description;

    //
    // Eflags
    //

    IA32_EFLAGS Eflags;


    //
    // Instruction opcode
    //

    UCHAR Opcode;

    //
    // Operands size and mask
    //

    UCHAR OperandSize;
    ULONG OperandMask;

    //
    // Instruction operands
    //

    IA32_OPERAND Operand1;
    IA32_OPERAND Operand2;

    //
    // Instruction prefixes
    //
    
    IA32_PREFIX Prefix;


} IA32_INSTRUCTION, *PIA32_INSTRUCTION;


#if defined(IADBG)
ULONG IA32Debug = 0x000fffff;

#define IA32_DEBUG_INTERCEPTION 0x00000001
#define IA32_DEBUG_EXCEPTION    0x00000002
#define IA32_DEBUG_INTERRUPT    0x00000004

#define IA32_DEBUG_DIVIDE       0x00000010
#define IA32_DEBUG_DEBUG        0x00000020
#define IA32_DEBUG_OVERFLOW     0x00000040
#define IA32_DEBUG_BOUND        0x00000080
#define IA32_DEBUG_INSTRUCTION  0x00000100
#define IA32_DEBUG_NODEVICE     0x00000200
#define IA32_DEBUG_NOTPRESENT   0x00000400
#define IA32_DEBUG_STACK        0x00000800
#define IA32_DEBUG_GPFAULT      0x00001000
#define IA32_DEBUG_FPFAULT      0x00002000
#define IA32_DEBUG_ALIGNMENT    0x00004000
#define IA32_DEBUG_GATE         0x00008000
#define IA32_DEBUG_BREAK        0x00010000
#define IA32_DEBUG_INTNN        0x00020000
#define IA32_DEBUG_FLAG         0x00040000
#define IA32_DEBUG_LOCK         0x00080000
//
// define debug macro
//
#define IF_IA32TRAP_DEBUG( ComponentFlag ) \
    if (IA32Debug & (IA32_DEBUG_ ## ComponentFlag))
    

#else // IADBG

#define IF_IA32TRAP_DEBUG( ComponentFlag ) if (FALSE)

#endif // IADBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\fpmisc.s ===
#include "ksia64.h"

//++
//
// VOID
// run_fms (
//    IN ULONGLONG *fpsr,
//    OUT FLOAT128 *fr1, 
//    IN FLOAT128 *fr2, 
//    IN FLOAT128 *fr3, 
//    IN FLOAT128 *fr4
//    )
//
// Routine Description:
//
//    This function runs FMS operation with the specified inputs and FPSR.
//
//--
  LEAF_ENTRY(run_fms)
  alloc r31=ar.pfs,5,2,0,0  // r32, r33, r34, r35, r36, r37, r38

  ARGPTR  (r32)
  ARGPTR  (r33)
  ARGPTR  (r34)
  ARGPTR  (r35)
  ARGPTR  (r36)

  // &fpsr is in r32
  // &fr1 (output) is in r33
  // &fr2 (input) is in r34
  // &fr3 (input) is in r35
  // &fr4 (input) is in r36

  // save old FPSR in r37
  mov r37 = ar40
  nop.i 0;;

  // load new fpsr in r38
  ld8 r38 = [r32];;
  // set new value of FPSR
  mov ar40 = r38
  nop.i 0;;

  // load first input argument into f8
  ldf.fill f8 = [r34]
  // load second input argument into f9
  ldf.fill f9 = [r35]
  nop.i 0;;

  // load third input argument into f10
  ldf.fill f10 = [r36]
  nop.m 0
  nop.i 0;;

  nop.m 0
  (p0) fms.s0 f11 = f8, f9, f10 // f11 = f8 * f9 - f10
  nop.i 0;;

  // store result
  stf.spill [r33] = f11
  // save new FPSR in r38
  mov r38 = ar40
  nop.i 0;;

  // store new fpsr from r38
  st8 [r32] = r38
  // restore FPSR
  mov ar40 = r37
  nop.i 0;;

  nop.m 0
  nop.i 0

  // return
  LEAF_RETURN

  LEAF_EXIT(run_fms)      

//++
//
// VOID
// thmF (
//    IN ULONGLONG *fpsr,
//    OUT FLOAT128 *fr1, 
//    IN FLOAT128 *fr2, 
//    IN FLOAT128 *fr3
//    )
//
// Routine Description:
//
//--
  LEAF_ENTRY(thmF)

  alloc r31=ar.pfs,4,4,0,0  // r32, r33, r34, r35, r36, r37, r38, r39

  ARGPTR  (r32)
  ARGPTR  (r33)
  ARGPTR  (r34)
  ARGPTR  (r35)

  // &fpsr is in r32 
  // &a is in r33 
  // &b is in r34 
  // &div is in r35 (the address of the divide result)

  // save old FPSR in r36
  mov r36 = ar40
  // save predicates in r37
  mov r37 = pr;;

  // load new fpsr in r39
  ld8 r39 = [r32];;
  // set new value of FPSR
  mov ar40 = r39
  nop.i 0;;

  nop.m 0
  // clear predicates
  movl r38 = 0x0000000000000001;;

  nop.m 0
  // load clear predicates from r38
  mov pr = r38,0x1ffff
  nop.i 0;;

  // load a, the first argument, in f6
  ldf.fill f6 = [r33]
  // load b, the second argument, in f7
  ldf.fill f7 = [r34]
  nop.i 0;;

  nop.m 0
  // Step (1)
  // y0 = 1 / b in f8
  frcpa.s0 f8,p2=f6,f7
  nop.i 0;;

  nop.m 0
  // Step (2)
  // e0 = 1 - b * y0 in f9
  (p2) fnma.s1 f9=f7,f8,f1
  nop.i 0

  nop.m 0
  // Step (10)
  // q0 = a * y0 in f10
  (p2) fma.s1 f10=f6,f8,f0
  nop.i 0;;

  nop.m 0
  // Step (3)
  // y1 = y0 + e0 * y0 in f8
  (p2) fma.s1 f8=f9,f8,f8
  nop.i 0

  nop.m 0
  // Step (4)
  // e1 = e0 * e0 in f9
  (p2) fma.s1 f9=f9,f9,f0
  nop.i 0

  nop.m 0
  // Step (11)
  // r0 = a - b * q0 in f11
  (p2) fnma.s1 f11=f7,f10,f6
  nop.i 0;;

  nop.m 0
  // Step (5)
  // y2 = y1 + e1 * y1 in f8
  (p2) fma.s1 f8=f8,f9,f8
  nop.i 0;;

  nop.m 0
  // Step (6)
  // e2 = 1 - b * y2 in f9
  (p2) fnma.s1 f9=f7,f8,f1
  nop.i 0;;

  nop.m 0
  // Step (7)
  // y3 = y2 + e2 * y2 in f8
  (p2) fma.s1 f8=f8,f9,f8
  nop.i 0;;

  nop.m 0
  // Step (8)
  // e3 = 1 - b * y3 in f9
  (p2) fnma.s1 f9=f7,f8,f1
  nop.i 0

  nop.m 0
  // Step (12)
  // q1 = q0 + r0 * y3 in f10
  (p2) fma.s1 f10=f11,f8,f10
  nop.i 0;;

  nop.m 0
  // Step (9)
  // y4 = y3 + e3 * y3 in f8
  (p2) fma.s1 f8=f8,f9,f8
  nop.i 0

  nop.m 0
  // Step (13)
  // r1 = a - b * q1 in f11
  (p2) fnma.s1 f11=f7,f10,f6
  nop.i 0;;

  nop.m 0
  // Step (14)
  // q2 = q1 + r1 * y4 in f8
  (p2) fma.s0 f8=f11,f8,f10
  nop.i 0;;

  // save new FPSR in r39
  mov r39 = ar40;;
  // store new fpsr from r39
  st8 [r32] = r39
  // restore predicates from r37
  mov pr = r37,0x1ffff;;

  // store result
  stf.spill [r35]=f8
  // restore FPSR
  mov ar40 = r36
  // return
  LEAF_RETURN

  LEAF_EXIT(thmF)

//++
//
// VOID
// thmL (
//    IN ULONGLONG *fpsr,
//    OUT FLOAT128 *fr1, 
//    IN FLOAT128 *fr2
//    )
//
// Routine Description:
//
//--
  LEAF_ENTRY(thmL)

  alloc	r31=ar.pfs,3,5,0,0  // r32, r33, r34, r35, r36, r37, r38, r39

  ARGPTR  (r32)
  ARGPTR  (r33)
  ARGPTR  (r34)

  // &fpsr is in r32 
  // &a is in r33 
  // &sqrt is in r34 (the address of the sqrt result)

  // save old FPSR in r35
  mov r35 = ar40
  // save predicates in r36
  mov r36 = pr;;

  // load new fpsr in r38
  ld8 r38 = [r32];;
  // set new value of FPSR
  mov ar40 = r38
  nop.i 0;;

  nop.m 0
  // clear predicates
  movl r37 = 0x0000000000000001;;

  nop.m 0
  // load clear predicates from r37
  mov pr = r37,0x1ffff
  nop.i 0;;

  // load the argument a in f6
  ldf.fill f6 = [r33]
  nop.m 0
  nop.i 0;;

  nop.m 0
  // Step (1)
  // y0 = 1/sqrt(a) in f8
  frsqrta.s0 f8,p2=f6
  nop.i 0;;

  nop.m 0
  // Step (2)
  // load 1/2 in f7; h = 1/2 * a in f9
  (p2) movl r39 = 0x0fffe;;

  (p2) setf.exp f7 = r39
  nop.i 0;;

  nop.m 0
  (p2) fma.s1 f9=f7,f6,f0
  nop.i 0;;

  nop.m 0
  // Step (3)
  // t1 = y0 * y0 in f10
  (p2) fma.s1 f10=f8,f8,f0
  nop.i 0;;

  nop.m 0
  // Step (4)
  // t2 = 1/2 - t1 * h in f10
  (p2) fnma.s1 f10=f10,f9,f7
  nop.i 0;;

  nop.m 0
  // Step (5)
  // y1 = y0 + t2 * y0 in f8
  (p2) fma.s1 f8=f10,f8,f8
  nop.i 0;;

  nop.m 0
  // Step (6)
  // t3 = y1 * h in f10
  (p2) fma.s1 f10=f8,f9,f0
  nop.i 0;;

  nop.m 0
  // Step (7)
  // t4 = 1/2 - t3 * y1 in f10
  (p2) fnma.s1 f10=f10,f8,f7
  nop.i 0;;

  nop.m 0
  // Step (8)
  // y2 = y1 + t4 * y1 in f8
  (p2) fma.s1 f8=f10,f8,f8
  nop.i 0;;

  nop.m 0
  // Step (9)
  // S = a * y2 in f10
  (p2) fma.s1 f10=f6,f8,f0
  nop.i 0;;

  nop.m 0
  // Step (10)
  // t5 = y2 * h in f9
  (p2) fma.s1 f9=f8,f9,f0
  nop.i 0;;

  nop.m 0
  // Step (11)
  // H = 1/2 * y2 in f11
  (p2) fma.s1 f11=f7,f8,f0
  nop.i 0;;

  nop.m 0
  // Step (13)
  // t6 = 1/2 - t5 * y2 in f7
  (p2) fnma.s1 f7=f9,f8,f7
  nop.i 0;;

  nop.m 0
  // Step (12)
  // d = a - S * S in f8
  (p2) fnma.s1 f8=f10,f10,f6
  nop.i 0;;

  nop.m 0
  // Step (14)
  // S1 = S + d * H in f8
  (p2) fma.s1 f8=f8,f11,f10
  nop.i 0;;

  nop.m 0
  // Step (15)
  // H1 = H + t6 * h in f7
  (p2) fma.s1 f7=f11,f7,f11
  nop.i 0;;

  nop.m 0
  // Step (16)
  // d1 = a - S1 * S1 in f6
  (p2) fnma.s1 f6=f8,f8,f6
  nop.i 0;;

  nop.m 0
  // Step (17)
  // R = S1 + d1 * H1 in f8
  (p2) fma.s0 f8=f6,f7,f8
  nop.i 0;;

  // save new FPSR in r38
  mov r38 = ar40;;
  // store new fpsr from r38
  st8 [r32] = r38
  // restore predicates from r36
  mov pr = r36,0x1ffff;;

  // store result
  stf.spill [r34]=f8
  // restore FPSR
  mov ar40 = r35
  // return
  LEAF_RETURN
  
  LEAF_EXIT(thmL)


//++
//
// VOID
// KiEmulateLoadFloat80(
//    IN PVOID UnalignedAddress, 
//    OUT PVOID FloatData
//    );
//
//-- 

  LEAF_ENTRY(KiEmulateLoadFloat80)

  ARGPTR(a0)
  ARGPTR(a1)

  ldfe           ft0 = [a0]       
  ;;
  stf.spill      [a1] = ft0
       
  LEAF_RETURN
  LEAF_EXIT(KiEmulateLoadFloat80) 


//++
//
// VOID
// KiEmulateLoadFloatInt(
//    IN PVOID UnalignedAddress, 
//    OUT PVOID FloatData
//    );
//
//-- 

  LEAF_ENTRY(KiEmulateLoadFloatInt)

  ARGPTR(a0)
  ARGPTR(a1)

  ldf8          ft0 = [a0]       
  ;;
  stf.spill      [a1] = ft0
       
  LEAF_RETURN
  LEAF_EXIT(KiEmulateLoadFloatInt) 

//++
//
// VOID
// KiEmulateLoadFloat32(
//    IN PVOID UnalignedAddress, 
//    OUT PVOID FloatData
//    );
//
//-- 

  LEAF_ENTRY(KiEmulateLoadFloat32)

  ARGPTR(a0)
  ARGPTR(a1)

  ldfs           ft0 = [a0]       
  ;;
  stf.spill      [a1] = ft0
       
  LEAF_RETURN
  LEAF_EXIT(KiEmulateLoadFloat32) 

//++
//
// VOID
// KiEmulateLoadFloat64(
//    IN PVOID UnalignedAddress, 
//    OUT PVOID FloatData
//    );
//
//-- 

  LEAF_ENTRY(KiEmulateLoadFloat64)

  ARGPTR(a0)
  ARGPTR(a1)

  ldfd          ft0 = [a0]       
  ;;
  stf.spill      [a1] = ft0
       
  LEAF_RETURN
  LEAF_EXIT(KiEmulateLoadFloat64) 



//++
//
// VOID
// KiEmulateStoreFloat80(
//    IN PVOID UnalignedAddress, 
//    OUT PVOID FloatData
//    );
//
//-- 

  LEAF_ENTRY(KiEmulateStoreFloat80)

  ARGPTR(a0)
  ARGPTR(a1)

  ldf.fill      ft0 = [a1]       
  ;;
  stfe          [a0] = ft0
       
  LEAF_RETURN
  LEAF_EXIT(KiEmulateStoreFloat80) 


//++
//
// VOID
// KiEmulateStoreFloatInt(
//    IN PVOID UnalignedAddress, 
//    OUT PVOID FloatData
//    );
//
//-- 

  LEAF_ENTRY(KiEmulateStoreFloatInt)

  ARGPTR(a0)
  ARGPTR(a1)

  ldf.fill      ft0 = [a1]       
  ;;
  stfd          [a0] = ft0
       
  LEAF_RETURN
  LEAF_EXIT(KiEmulateStoreFloatInt) 

//++
//
// VOID
// KiEmulateStoreFloat32(
//    IN PVOID UnalignedAddress, 
//    OUT PVOID FloatData
//    );
//
//-- 

  LEAF_ENTRY(KiEmulateStoreFloat32)

  ARGPTR(a0)
  ARGPTR(a1)

  ldf.fill           ft0 = [a1]       
  ;;
  stfs               [a0] = ft0
       
  LEAF_RETURN
  LEAF_EXIT(KiEmulateStoreFloat32) 

//++
//
// VOID
// KiEmulateStoreFloat64(
//    IN PVOID UnalignedAddress, 
//    OUT PVOID FloatData
//    );
//
//-- 

  LEAF_ENTRY(KiEmulateStoreFloat64)

  ARGPTR(a0)
  ARGPTR(a1)

  ldf.fill          ft0 = [a1]       
  ;;
  stfd              [a0] = ft0
       
  LEAF_RETURN
  LEAF_EXIT(KiEmulateStoreFloat64)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\getsetrg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    getsetrg.c

Abstract:

    This module implement the code necessary to get and set register values.
    These routines are used during the emulation of unaligned data references
    and floating point exceptions.

Author:

    David N. Cutler (davec) 17-Jun-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#include "ntfpia64.h"



ULONGLONG
KiGetRegisterValue (
    IN ULONG Register,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to get the value of a register from the specified
    exception or trap frame.

Arguments:

    Register - Supplies the number of the register whose value is to be
        returned. Integer registers are specified as 0 - 31 and floating
        registers are specified as 32 - 63.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    The value of the specified register is returned as the function value.

--*/

{
    //
    // Dispatch on the register number.
    //

    if (Register == 0) {
        return 0;
    } else if (Register <= 3) {
        Register -= 1;
        return ( *(&TrapFrame->IntGp + Register) );
    } else if (Register <= 7) {
        Register -= 4;
        return ( *(&ExceptionFrame->IntS0 + Register) );
    } else if (Register <= 31) {
        Register -= 8;
        return ( *(&TrapFrame->IntV0 + Register) );
    }
    
    //
    // Register is the stacked register
    //
    //   (R32 - R127)
    //

    {
        PULONGLONG UserBStore, KernelBStore;
        ULONG SizeOfCurrentFrame;

        SizeOfCurrentFrame = (ULONG)(TrapFrame->StIFS & 0x7F);
        Register = Register - 32;

        if (TrapFrame->PreviousMode == UserMode) {

            //
            // PreviousMode is user
            //

            UserBStore = (PULONGLONG) TrapFrame->RsBSP; 

            do {

                UserBStore = UserBStore - 1;
                
                SizeOfCurrentFrame = SizeOfCurrentFrame - 1;

                if (((ULONG_PTR) UserBStore & 0x1F8) == 0x1F8) {
                    
                    //
                    // Adjust Bsp, by skipping RNAT
                    //

                    UserBStore = UserBStore - 1;
                }

            } while (Register < SizeOfCurrentFrame); 

            return (*UserBStore);

        } else {

            //
            // PreviousMode is kernel
            //

            KernelBStore = (ULONGLONG *) TrapFrame->RsBSP;

            do {

                KernelBStore = KernelBStore - 1;

                SizeOfCurrentFrame = SizeOfCurrentFrame - 1;

                if (((ULONG_PTR) KernelBStore & 0x1F8) == 0x1F8) {
                    
                    //
                    // Adjust UserBsp, by skipping RNAT
                    //

                    KernelBStore = KernelBStore -1;
                }
                
            } while (Register < SizeOfCurrentFrame); 
            
            return (*KernelBStore);
        }
    }
}   

#define GET_NAT_OFFSET(addr) (USHORT)(((ULONG_PTR) (addr) >> 3) & 0x3F)
#define CLEAR_NAT_BIT(Nats, Offset)  Nats &= ~((ULONGLONG)1i64 << Offset)
#define GET_NAT(Nats, addr) (UCHAR)((Nats >> GET_NAT_OFFSET(addr)) & 1)


VOID
KiSetRegisterValue (
    IN ULONG Register,
    IN ULONGLONG Value,
    OUT PKEXCEPTION_FRAME ExceptionFrame,
    OUT PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to set the value of a register in the specified
    exception or trap frame.

Arguments:

    Register - Supplies the number of the register whose value is to be
        stored. Integer registers are specified as 0 - 31 and floating
        registers are specified as 32 - 63.

    Value - Supplies the value to be stored in the specified register.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    None.

--*/

{
    USHORT NatBitOffset;
    PULONGLONG UserBStore, KernelBStore, RnatAddress;
    ULONG SizeOfCurrentFrame;

    //
    // Dispatch on the register number.
    //

    if (Register == 0) {
        return;
    } else if (Register < 32) {
        if ((Register <= 3) || (Register >= 8)) {
            Register -= 1;
            *(&TrapFrame->IntGp + Register) = Value;
            NatBitOffset = GET_NAT_OFFSET(&TrapFrame->IntGp + Register);
            CLEAR_NAT_BIT(TrapFrame->IntNats, NatBitOffset);
        } else if ((Register >= 4) && (Register <= 7)) {
            Register -= 4;
            *(&ExceptionFrame->IntS0 + Register) = Value;
            NatBitOffset = GET_NAT_OFFSET(&ExceptionFrame->IntS0 + Register);
            CLEAR_NAT_BIT(ExceptionFrame->IntNats, NatBitOffset);
        }
        return;
    }

    //
    // Register is the stacked register
    //
    //   (R32 - R127)
    //

    RnatAddress = NULL;
    SizeOfCurrentFrame = (ULONG)(TrapFrame->StIFS & 0x7F);
    Register = Register - 32;

    if (TrapFrame->PreviousMode == UserMode) {

        //
        // PreviousMode is user
        //

        UserBStore = (PULONGLONG) TrapFrame->RsBSP; 

        do {

            UserBStore = UserBStore - 1;
                
            SizeOfCurrentFrame = SizeOfCurrentFrame - 1;

            if (((ULONG_PTR) UserBStore & 0x1F8) == 0x1F8) {
                    
                //
                // Adjust Bsp, by skipping RNAT
                //

                RnatAddress = UserBStore;
                UserBStore = UserBStore - 1;
            }

        } while (Register < SizeOfCurrentFrame); 

        *UserBStore = Value;
        NatBitOffset = GET_NAT_OFFSET(UserBStore);
        if (RnatAddress == NULL) {
            CLEAR_NAT_BIT(TrapFrame->RsRNAT, NatBitOffset);
        } else {
            CLEAR_NAT_BIT(*RnatAddress, NatBitOffset);
        }
            
    } else {

        //
        // PreviousMode is kernel
        //

        ULONGLONG OriginalRsc, BspStore, Rnat;

        //
        // put RSE in lazy mode
        //

        OriginalRsc = __getReg(CV_IA64_RsRSC);
        __setReg(CV_IA64_RsRSC, RSC_KERNEL_DISABLED);

        KernelBStore = (ULONGLONG *) TrapFrame->RsBSP;

        do {

            KernelBStore = KernelBStore - 1;

            SizeOfCurrentFrame = SizeOfCurrentFrame - 1;

            if (((ULONG_PTR) KernelBStore & 0x1F8) == 0x1F8) {
                    
                //
                // Adjust UserBsp, by skipping RNAT
                //

                KernelBStore = KernelBStore -1;
            }
                
        } while (Register < SizeOfCurrentFrame); 
            
        *KernelBStore = Value;
        NatBitOffset = GET_NAT_OFFSET(KernelBStore);
        RnatAddress = (PULONGLONG)((ULONGLONG)KernelBStore | RNAT_ALIGNMENT);

        //
        // disable interrupt and read bspstore & rnat
        //

        _disable();
        BspStore = __getReg(CV_IA64_RsBSPSTORE);
        Rnat = __getReg(CV_IA64_RsRNAT);

        if ((ULONGLONG)RnatAddress == ((ULONGLONG)BspStore | RNAT_ALIGNMENT)) {
             CLEAR_NAT_BIT(Rnat, NatBitOffset);   
            __setReg(CV_IA64_RsRNAT, Rnat);
        } else {
             CLEAR_NAT_BIT(*RnatAddress, NatBitOffset);
        }

        //
        // enable interrupt and restore RSC setting
        //
       
        _enable();
        __setReg(CV_IA64_RsRSC, OriginalRsc);
    }
}


FLOAT128
KiGetFloatRegisterValue (
    IN ULONG Register,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    )

{
    if (Register == 0) {
        FLOAT128 t = {0ULL,0ULL};
        return t;
    } else if (Register == 1) {
        FLOAT128 t = {0x8000000000000000ULL,0x000000000000FFFFULL}; // low,high
        return t;
    } else if (Register <= 5) {
        Register -= 2;
        return ( *(&ExceptionFrame->FltS0 + Register) );
    } else if (Register <= 15) {
        Register -= 6;
        return ( *(&TrapFrame->FltT0 + Register) );
    } else if (Register <= 31) {
        Register -= 16;
        return ( *(&ExceptionFrame->FltS4 + Register) );
    } else {
        PKHIGHER_FP_VOLATILE HigherVolatile;

        HigherVolatile = GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(KeGetCurrentThread()->StackBase);
        Register -= 32;
        return ( *(&HigherVolatile->FltF32 + Register) );
    }
}


VOID
KiSetFloatRegisterValue (
    IN ULONG Register,
    IN FLOAT128 Value,
    OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    OUT struct _KTRAP_FRAME *TrapFrame
    )

{
    if (Register <= 1) {
        return;
    } else if (Register <= 5) {
        Register -= 2;
        *(&ExceptionFrame->FltS0 + Register) = Value;
        return;
    } else if (Register <= 15) {
        Register -= 6;
        *(&TrapFrame->FltT0 + Register) = Value;
        return;
    } else if (Register <= 31) {
        Register -= 16;
        *(&ExceptionFrame->FltS4 + Register) = Value;
        return;
    } else {
        PKHIGHER_FP_VOLATILE HigherVolatile;

        HigherVolatile = GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(KeGetCurrentThread()->StackBase);
        Register -= 32;
        *(&HigherVolatile->FltF32 + Register) = Value;
        TrapFrame->StIPSR &= ~(1i64 << PSR_MFH);
        TrapFrame->StIPSR |= (1i64 << PSR_DFH);
        return;
    }
}

VOID
__cdecl
KeSaveStateForHibernate(
    IN PKPROCESSOR_STATE ProcessorState
    )
/*++

Routine Description:

    Saves all processor-specific state that must be preserved
    across an S4 state (hibernation).

Arguments:

    ProcessorState - Supplies the KPROCESSOR_STATE where the
        current CPU's state is to be saved.

Return Value:

    None.

--*/

{
    //
    // BUGBUG John Vert (jvert) 4/30/1998
    //  someone needs to implement this and probably put it in a more 
    //  appropriate file.
    
}


FLOAT128
get_fp_register (
    IN ULONG Register,
    IN PVOID FpState
    )
{
    return(KiGetFloatRegisterValue (
               Register, 
               ((PFLOATING_POINT_STATE)FpState)->ExceptionFrame,
               ((PFLOATING_POINT_STATE)FpState)->TrapFrame
               ));
}

VOID
set_fp_register (
    IN ULONG Register,
    IN FLOAT128 Value,
    IN PVOID FpState
    )
{
    KiSetFloatRegisterValue (
        Register, 
        Value,
        ((PFLOATING_POINT_STATE)FpState)->ExceptionFrame,
        ((PFLOATING_POINT_STATE)FpState)->TrapFrame
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\ia32emul.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ia32emul.c

Abstract:

    This module implements an x86 instruction decoder and emulator.
    
Author:

    Samer Arafeh (samera) 30-Oct-2000

Environment:

    Kernel mode only.

Revision History:

--*/


#include "ki.h"
#include "ia32def.h"
#include "wow64t.h"


#if DBG
BOOLEAN KiIa32InstructionEmulationDbg = 0;
#endif

#define KiIa32GetX86Eflags(efl)  efl.Value = __getReg(CV_IA64_AR24)
#define KiIa32SetX86Eflags(efl)  __setReg(CV_IA64_AR24, efl.Value)

#define IA32_GETEFLAGS_CF(efl)    (efl & 0x01UI64)

//
// Ia32 instruction handlers
//

NTSTATUS
KiIa32InstructionAdc (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    );

NTSTATUS
KiIa32InstructionAdd (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    );

NTSTATUS
KiIa32InstructionArithmeticBitwiseHelper (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    );

NTSTATUS
KiIa32InstructionBitTestHelper (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    );

NTSTATUS
KiIa32InstructionOneParamHelper (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    );

NTSTATUS
KiIa32InstructionXadd (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    );

NTSTATUS
KiIa32InstructionXchg (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    );

NTSTATUS
KiIa32InstructionCmpXchg (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    );

NTSTATUS
KiIa32InstructionCmpXchg8b (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    );

NTSTATUS
KiIa32InstructionMoveSeg (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    );

//  
//   Opcode Ids
//

typedef enum _IA32_OPCODE
{
    Ia32_Adc,
    Ia32_Add,
    Ia32_And,
    Ia32_Bt,
    Ia32_Btc,
    Ia32_Btr,
    Ia32_Bts,
    Ia32_Cmpxchg,
    Ia32_Cmpxchg8b,
    Ia32_Dec,
    Ia32_Inc,
    Ia32_Neg,
    Ia32_Not,
    Ia32_Or,
    Ia32_Sbb,
    Ia32_Sub,
    Ia32_Xadd,
    Ia32_Xchg,
    Ia32_Xor,
    Ia32_MovToSeg,
    
    //
    // This needs always to be the last element
    //

    Ia32_LastOpcode

} IA32_OPCODE;


//
//   Array of Ia32 instruction handlers
//   NOTE : The following table must be in sync with the above enum.
//

typedef NTSTATUS (*IA32_INSTRUCTION_HANDLER) (PKTRAP_FRAME, PIA32_INSTRUCTION);
IA32_INSTRUCTION_HANDLER KiIa32InstructionHandler [] =
{
    KiIa32InstructionAdc,
    KiIa32InstructionAdd,
    KiIa32InstructionArithmeticBitwiseHelper,
    KiIa32InstructionBitTestHelper,
    KiIa32InstructionBitTestHelper,
    KiIa32InstructionBitTestHelper,
    KiIa32InstructionBitTestHelper,
    KiIa32InstructionCmpXchg,
    KiIa32InstructionCmpXchg8b,
    KiIa32InstructionOneParamHelper,
    KiIa32InstructionOneParamHelper,
    KiIa32InstructionOneParamHelper,
    KiIa32InstructionOneParamHelper,
    KiIa32InstructionArithmeticBitwiseHelper,
    KiIa32InstructionAdc,
    KiIa32InstructionAdd,
    KiIa32InstructionXadd,
    KiIa32InstructionXchg,
    KiIa32InstructionArithmeticBitwiseHelper,
    KiIa32InstructionMoveSeg,
    NULL
};

#if DBG
PCHAR KiIa32InstructionHandlerNames [] =
{
    "KiIa32InstructionAdc",
    "KiIa32InstructionAdd",
    "KiIa32InstructionAnd",
    "KiIa32InstructionBt",
    "KiIa32InstructionBtc",
    "KiIa32InstructionBtr",
    "KiIa32InstructionBts",
    "KiIa32InstructionCmpXchg",
    "KiIa32InstructionCmpXchg8b",
    "KiIa32InstructionDec",
    "KiIa32InstructionInc",
    "KiIa32InstructionNeg",
    "KiIa32InstructionNot",
    "KiIa32InstructionOr",
    "KiIa32InstructionSbb",
    "KiIa32InstructionSub",
    "KiIa32InstructionXadd",
    "KiIa32InstructionXchg",
    "KiIa32InstructionXor",
    "KiIa32InstructionMoveSeg",
    NULL,
};
#endif


IA32_OPCODE_DESCRIPTION OpcodesDescription[] =
{
    //
    //   Adc
    //

    // Adc r/m8, imm8
    {
        0x80, 0x00, 0x02, 0x11, IA32_PARAM_RM8_IMM8, Ia32_Adc
    },
    // Adc r/m, imm
    {
        0x81, 0x00, 0x02, 0x11, IA32_PARAM_RM_IMM, Ia32_Adc
    },
    // Adc r/m, imm8 (sign)
    {
        0x83, 0x00, 0x02, 0x11, IA32_PARAM_RM_IMM8SIGN, Ia32_Adc
    },
    // Adc r/m8, r8
    {
        0x10, 0x00, 0x00, 0x01, IA32_PARAM_RM8_R, Ia32_Adc
    },
    // Adc r/m, r
    {
        0x11, 0x00, 0x00, 0x01, IA32_PARAM_RM_R, Ia32_Adc
    },
    // Adc r, r/m8
    {
        0x12, 0x00, 0x00, 0x01, IA32_PARAM_R_RM8, Ia32_Adc
    },
    // Adc r, r/m
    {
        0x13, 0x00, 0x00, 0x01, IA32_PARAM_R_RM, Ia32_Adc
    },

    //
    //   Add
    //

    // Add r/m8, imm8
    {
        0x80, 0x00, 0x00, 0x11, IA32_PARAM_RM8_IMM8, Ia32_Add
    },
    // Add r/m, imm
    {
        0x81, 0x00, 0x00, 0x11, IA32_PARAM_RM_IMM, Ia32_Add
    },
    // Add r/m, imm8 (sign)
    {
        0x83, 0x00, 0x00, 0x11, IA32_PARAM_RM_IMM8SIGN, Ia32_Add
    },
    // Add r/m8, r8
    {
        0x00, 0x00, 0x00, 0x01, IA32_PARAM_RM8_R, Ia32_Add
    },
    // Add r/m, r
    {
        0x01, 0x00, 0x00, 0x01, IA32_PARAM_RM_R, Ia32_Add
    },
    // Add r, r/m8
    {
        0x02, 0x00, 0x00, 0x01, IA32_PARAM_R_RM8, Ia32_Add
    },
    // Add r, r/m
    {
        0x03, 0x00, 0x00, 0x01, IA32_PARAM_R_RM, Ia32_Add
    },


    //
    // And
    //

    // And r/m8, imm8
    {
        0x80, 0x00, 0x04, 0x11, IA32_PARAM_RM8_IMM8, Ia32_And
    },
    // And r/m, imm
    {
        0x81, 0x00, 0x04, 0x11, IA32_PARAM_RM_IMM, Ia32_And
    },
    // And r/m, imm8
    {
        0x83, 0x00, 0x04, 0x11, IA32_PARAM_RM_IMM8SIGN, Ia32_And
    },
    // And r/m8, r8
    {
        0x20, 0x00, 0x00, 0x01, IA32_PARAM_RM8_R, Ia32_And
    },
    // And rm, r
    {
        0x21, 0x00, 0x00, 0x01, IA32_PARAM_RM_R, Ia32_And
    },
    // And r8, r/m8
    {
        0x22, 0x00, 0x00, 0x01, IA32_PARAM_R_RM8, Ia32_And
    },
    // And r, r/m
    {
        0x23, 0x00, 0x00, 0x01, IA32_PARAM_R_RM, Ia32_And
    },


    //
    // Or
    //

    // Or r/m8, imm8
    {
        0x80, 0x00, 0x01, 0x11, IA32_PARAM_RM8_IMM8, Ia32_Or
    },
    // Or r/m, imm
    {
        0x81, 0x00, 0x01, 0x11, IA32_PARAM_RM_IMM, Ia32_Or
    },
    // Or r/m, imm8
    {
        0x83, 0x00, 0x01, 0x11, IA32_PARAM_RM_IMM8SIGN, Ia32_Or
    },
    // Or r/m8, r8
    {
        0x08, 0x00, 0x00, 0x01, IA32_PARAM_RM8_R, Ia32_Or
    },
    // Or rm, r
    {
        0x09, 0x00, 0x00, 0x01, IA32_PARAM_RM_R, Ia32_Or
    },
    // Or r8, r/m8
    {
        0x0a, 0x00, 0x00, 0x01, IA32_PARAM_R_RM8, Ia32_Or
    },
    // Or r, r/m
    {
        0x0b, 0x00, 0x00, 0x01, IA32_PARAM_R_RM, Ia32_Or
    },

    //
    // Xor
    //

    // Xor r/m8, imm8
    {
        0x80, 0x00, 0x06, 0x11, IA32_PARAM_RM8_IMM8, Ia32_Xor
    },
    // Xor r/m, imm
    {
        0x81, 0x00, 0x06, 0x11, IA32_PARAM_RM_IMM, Ia32_Xor
    },
    // Xor r/m, imm8
    {
        0x83, 0x00, 0x06, 0x11, IA32_PARAM_RM_IMM8SIGN, Ia32_Xor
    },
    // Xor r/m8, r8
    {
        0x30, 0x00, 0x00, 0x01, IA32_PARAM_RM8_R, Ia32_Xor
    },
    // Xor rm, r
    {
        0x31, 0x00, 0x00, 0x01, IA32_PARAM_RM_R, Ia32_Xor
    },
    // Xor r8, r/m8
    {
        0x32, 0x00, 0x00, 0x01, IA32_PARAM_R_RM8, Ia32_Xor
    },
    // Xor r, r/m
    {
        0x33, 0x00, 0x00, 0x01, IA32_PARAM_R_RM, Ia32_Xor
    },

    //
    // Inc
    //

    // Inc r/m8
    {
        0xfe, 0x00, 0x00, 0x11, IA32_PARAM_RM8, Ia32_Inc
    },
    // Inc r/m
    {
        0xff, 0x00, 0x00, 0x11, IA32_PARAM_RM, Ia32_Inc
    },

    //
    // Dec
    //

    // Dec r/m8
    {
        0xfe, 0x00, 0x01, 0x11, IA32_PARAM_RM8, Ia32_Dec
    },
    // Dec r/m
    {
        0xff, 0x00, 0x01, 0x11, IA32_PARAM_RM, Ia32_Dec
    },

    //
    // Xchg
    //

    // Xchg r/m8, r
    {
        0x86, 0x00, 0x00, 0x01, IA32_PARAM_RM8_R, Ia32_Xchg
    },
    // Xchg r/m, r
    {
        0x87, 0x00, 0x00, 0x01, IA32_PARAM_RM_R, Ia32_Xchg
    },


    //
    // Cmpxchg
    //

    // Cmpxchg r/m8, r
    {
        0x0f, 0xb0, 0x00, 0x02, IA32_PARAM_RM8_R, Ia32_Cmpxchg
    },
    // Cmpxchg r/m, r
    {
        0x0f, 0xb1, 0x00, 0x02, IA32_PARAM_RM_R, Ia32_Cmpxchg
    },

    //
    // Cmpxchg8b
    //

    // Cmpxchg8b m64
    {
        0x0f, 0xc7, 0x01, 0x12, IA32_PARAM_RM, Ia32_Cmpxchg8b
    },

    //
    // Xadd
    //

    // Xadd r/m8, r
    {
        0x0f, 0xc0, 0x00, 0x02, IA32_PARAM_RM8_R, Ia32_Xadd
    },
    // Xadd r/m, r
    {
        0x0f, 0xc1, 0x00, 0x02, IA32_PARAM_RM_R, Ia32_Xadd
    },


    //
    // Neg
    //

    // Neg r/m8
    {
        0xf6, 0x00, 0x03, 0x11, IA32_PARAM_RM8, Ia32_Neg
    },
    // Neg r/m
    {
        0xf7, 0x00, 0x03, 0x11, IA32_PARAM_RM, Ia32_Neg
    },

    //
    // Not
    //

    // Not r/m8
    {
        0xf6, 0x00, 0x02, 0x11, IA32_PARAM_RM8, Ia32_Not
    },
    // Not r/m
    {
        0xf7, 0x00, 0x02, 0x11, IA32_PARAM_RM, Ia32_Not
    },

    //
    // Bt (Bit Test)
    //

    // Bt r/m, r
    {
        0x0f, 0xa3, 0x00, 0x02, IA32_PARAM_RM_R, Ia32_Bt
    },
    // Bt r/m, imm8
    {
        0x0f, 0xba, 0x04, 0x12, IA32_PARAM_RM_IMM8SIGN, Ia32_Bt
    },

    //
    // Btc
    //

    // Btc r/m, r
    {
        0x0f, 0xbb, 0x00, 0x02, IA32_PARAM_RM_R, Ia32_Btc
    },
    // Btc r/m, imm8
    {
        0x0f, 0xba, 0x07, 0x12, IA32_PARAM_RM_IMM8SIGN, Ia32_Btc
    },

    //
    // Btr
    //

    // Btr r/m, r
    {
        0x0f, 0xb3, 0x00, 0x02, IA32_PARAM_RM_R, Ia32_Btr
    },
    // Btr r/m, imm8
    {
        0x0f, 0xba, 0x06, 0x12, IA32_PARAM_RM_IMM8SIGN, Ia32_Btr
    },

    //
    // Bts
    //

    // Bts r/m, r
    {
        0x0f, 0xab, 0x00, 0x02, IA32_PARAM_RM_R, Ia32_Bts
    },
    // Bts r/m, imm8
    {
        0x0f, 0xba, 0x05, 0x12, IA32_PARAM_RM_IMM8SIGN, Ia32_Bts
    },

    //
    //   Sub
    //

    // Sub r/m8, imm8
    {
        0x80, 0x00, 0x05, 0x11, IA32_PARAM_RM8_IMM8, Ia32_Sub
    },
    // Sub r/m, imm
    {
        0x81, 0x00, 0x05, 0x11, IA32_PARAM_RM_IMM, Ia32_Sub
    },
    // Sub r/m, imm8 (sign)
    {
        0x83, 0x00, 0x05, 0x11, IA32_PARAM_RM_IMM8SIGN, Ia32_Sub
    },
    // Sub r/m8, r8
    {
        0x28, 0x00, 0x00, 0x01, IA32_PARAM_RM8_R, Ia32_Sub
    },
    // Sub r/m, r
    {
        0x29, 0x00, 0x00, 0x01, IA32_PARAM_RM_R, Ia32_Sub
    },
    // Sub r, r/m8
    {
        0x2a, 0x00, 0x00, 0x01, IA32_PARAM_R_RM8, Ia32_Sub
    },
    // Sub r, r/m
    {
        0x2b, 0x00, 0x00, 0x01, IA32_PARAM_R_RM, Ia32_Sub
    },

    //
    //   Sbb
    //

    // Sbb r/m8, imm8
    {
        0x80, 0x00, 0x03, 0x11, IA32_PARAM_RM8_IMM8, Ia32_Sbb
    },
    // Sbb r/m, imm
    {
        0x81, 0x00, 0x03, 0x11, IA32_PARAM_RM_IMM, Ia32_Sbb
    },
    // Sbb r/m, imm8 (sign)
    {
        0x83, 0x00, 0x03, 0x11, IA32_PARAM_RM_IMM8SIGN, Ia32_Sbb
    },
    // Sbb r/m8, r8
    {
        0x18, 0x00, 0x00, 0x01, IA32_PARAM_RM8_R, Ia32_Sbb
    },
    // Sbb r/m, r
    {
        0x19, 0x00, 0x00, 0x01, IA32_PARAM_RM_R, Ia32_Sbb
    },
    // Sbb r, r/m8
    {
        0x1a, 0x00, 0x00, 0x01, IA32_PARAM_R_RM8, Ia32_Sbb
    },
    // Sbb r, r/m
    {
        0x1b, 0x00, 0x00, 0x01, IA32_PARAM_R_RM, Ia32_Sbb
    },


    //
    //   Mov 
    //

    // Mov seg-reg, r/m8
    {
        0x8e, 0x00, 0x00, 0x01, IA32_PARAM_SEGREG_RM8, Ia32_MovToSeg
    },

    // Mov seg-reg, r/m
    {
        0x8e, 0x00, 0x00, 0x01, IA32_PARAM_SEGREG_RM, Ia32_MovToSeg
    },

};

//
// Fast mutex that will serialize access to the instruction 
// emulator when the lock prefix is set.
//

FAST_MUTEX KiIa32MisalignedLockFastMutex;

#define KiIa32AcquireMisalignedLockFastMutex()   ExAcquireFastMutex(&KiIa32MisalignedLockFastMutex)
#define KiIa32ReleaseMisalignedLockFastMutex()   ExReleaseFastMutex(&KiIa32MisalignedLockFastMutex)


//
// This table contains the offset into the KTRAP_FRAME
// for the appropriate register. This table is based on the
// needs of the x86 instruction R/M bits
//

const ULONG RegOffsetTable[8] = 
{
    FIELD_OFFSET(KTRAP_FRAME, IntV0),           // EAX
    FIELD_OFFSET(KTRAP_FRAME, IntT2),           // ECX
    FIELD_OFFSET(KTRAP_FRAME, IntT3),           // EDX
    FIELD_OFFSET(KTRAP_FRAME, IntT4),           // EBX
    FIELD_OFFSET(KTRAP_FRAME, IntSp),           // ESP
    FIELD_OFFSET(KTRAP_FRAME, IntTeb),          // EBP
    FIELD_OFFSET(KTRAP_FRAME, IntT5),           // ESI
    FIELD_OFFSET(KTRAP_FRAME, IntT6)            // EDI
};




ULONG_PTR GetX86RegOffset (
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG RegisterBase
    )

/*++

Routine Description:
    
    Retreives the offset into the aliased ia64 register for the ia32 register
    inside the trap frame.
    
Arguments:

    TrapFrame - Pointer to TrapFrame on the stack.
    
    RegisterBase - Register number to retrieve the offset for.
    
Return Value:
    
    Address of ia64 alias register for the ia32 register.

--*/

{
    return (ULONG_PTR)((PCHAR)TrapFrame + RegOffsetTable[RegisterBase]);
}


ULONG GetX86Reg (
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG RegisterBase
    )
/*++

Routine Description:
    
    Retreives the ia32 register value.
    
Arguments:

    TrapFrame - Pointer to TrapFrame on the stack.
    
    RegisterBase - Register number to retrieve the value for.
    
Return Value:
    
    Ia32 register context.

--*/

{
    return (ULONG)(*(PULONG_PTR)GetX86RegOffset(TrapFrame, RegisterBase));
}



NTSTATUS 
KiIa32InitializeLockFastMutex (
    VOID
    )

/*++

Routine Description:
    
    Initializes the misaligned lock fast mutex. Used to serialize
    access if the r/m address is misaligned. 
    
Arguments:

    None.
    
Return Value:
    
    NTSTATUS.

--*/

{
    ExInitializeFastMutex (&KiIa32MisalignedLockFastMutex);
    return STATUS_SUCCESS;
}


LONG
KiIa32ComputeSIBAddress(
    IN PKTRAP_FRAME Frame,
    IN LONG Displacement,
    IN UCHAR Sib,
    IN UCHAR ModRm
    )
/*++

Routine Description:
    
    Compute an effective address based on the SIB bytes in an instruction
    using the register values in the trap frame
    
Arguments:

    Frame - Pointer to iA32 TrapFrame in the stack.

    Displacement - The value of the displacement byte. If no displacement, this
        value should be passed in as zero.

    Sib - The sib byte that is causing all the trouble.
    
    ModRm - ModRm instruction value

Return Value:
    
    The effective address to use for the memory operation

--*/

{
    LONG Base;
    LONG Index;
    LONG Scale;
    
    //
    // First get the base address that we will be using
    //

    if ((Sib & MI_SIB_BASEMASK) == 5) 
    {
        //
        // Handle the special case where we don't use EBP for the base
        //

        //
        // EBP is an implicit reg-base if the Mod is not zero.
        //
        if ((ModRm >> MI_MODSHIFT) != 0) {
            Base = GetX86Reg (Frame, IA32_REG_EBP);
        } else {
            Base = 0;
        }
    }
    else 
    {
        Base = GetX86Reg (Frame, (Sib & MI_SIB_BASEMASK) >> MI_SIB_BASESHIFT);
    }

    //
    // Now get the Index
    //

    if ((Sib & MI_SIB_INDEXMASK) == MI_SIB_INDEXNONE) 
    {
        //
        // Handle the special case where we don't have an index
        //

        Index = 0;
    }
    else 
    {
        Index = GetX86Reg (Frame, (Sib & MI_SIB_INDEXMASK) >> MI_SIB_INDEXSHIFT);
    }

    Scale = 1 << ((Sib & MI_SIB_SSMASK) >> MI_SIB_SSSHIFT);

    return (Base + (Index * Scale) + Displacement);
}


BOOLEAN
KiIa32Compute32BitEffectiveAddress(
    IN PKTRAP_FRAME Frame,
    IN OUT PUCHAR *InstAddr,
    OUT PUINT_PTR Addr,
    OUT PBOOLEAN RegisterMode
    )

/*++

Routine Description:
    
    Compute an effective address based on bytes in memory and the register 
    values passed in via the ia64 stack frame. The addressing mode is assumed to
    be 32-bit.
    
Arguments:

    Frame        - Pointer to iA32 TrapFrame in the stack

    InstAddr     - Pointer to the first byte after the opcode.

    Addr         - Effective address.
    
    RegisterMode - Indicates whether the effective address is inside a register or memory.

Return Value:
    
    Returns TRUE if able to compute the EA, else returns FALSE.

Note:
    
    Does not verify permission on an Effective Address. It only computes the
    value and lets someone else worry if the process should have access to
    that memory location.

--*/

{

    UNALIGNED ULONG * UlongAddress;
    UCHAR ModRm;
    UCHAR Sib = 0;
    LONG UNALIGNED *DisplacementPtr;
    BOOLEAN ReturnCode = TRUE;


    //
    // This needs to be a signed value. Start off assuming no displacement
    //

    LONG Displacement = 0;

    try 
    {

        ModRm = *(*InstAddr)++;
  
        //
        // handle the register case first
        //

        if ((ModRm >> MI_MODSHIFT) == 3) 
        {
            
            //
            // yup, we have a register - the easy case...
            //

            *Addr = GetX86RegOffset (Frame, ModRm & MI_RMMASK);
            *RegisterMode = TRUE;
            return ReturnCode;
        }
        
        *RegisterMode = FALSE;

        //
        // See if we have a SIB
        //

        if ((ModRm & MI_RMMASK) == 4) 
        {
            Sib = *(*InstAddr)++;
        }

        //
        // Now decode the destination bits
        //

        switch (ModRm >> MI_MODSHIFT) 
        {
        case 0:
            
            //
            // We have an indirect through a register
            //

            switch (ModRm & MI_RMMASK) 
            {
            case 4:
                
                //
                // Deal with the SIB
                //

                *Addr = KiIa32ComputeSIBAddress (Frame, Displacement, Sib, ModRm);
                break;

            case 5:
                
                //
                // We have a 32-bit indirect...
                //

                UlongAddress = (UNALIGNED ULONG *)*InstAddr;
                *Addr = *UlongAddress;
                *InstAddr = (PUCHAR) (UlongAddress + 1);
                break;
                    
            default:
                
                //
                // The default case is get the address from the register
                //

                *Addr = GetX86Reg (Frame, (ModRm & MI_RMMASK));
                break;
            }
            break;

        case 1:

            //
            // we have an 8 bit displacement, so grab the next byte
            //
                
            Displacement = (signed char) (*(*InstAddr)++);
            if ((ModRm & MI_RMMASK) == 4) 
            {
                //
                // Have a SIB, so do that
                //

                *Addr = KiIa32ComputeSIBAddress (Frame, Displacement, Sib, ModRm);
            }
            else 
            {
                //
                // No SIB, life is easy
                //
                *Addr = GetX86Reg (Frame, (ModRm & MI_RMMASK)) + Displacement;
            }
            break;
            
        case 2:
            //
            // we have a 32-bit displacement, so grab the next 4 bytes
            //
            
            DisplacementPtr = (PLONG) (*InstAddr);
            Displacement = *DisplacementPtr++;
            *InstAddr = (PUCHAR)DisplacementPtr;
            
            if ((ModRm & MI_RMMASK) == 4) 
            {
                //
                // Have a SIB, so do that
                //
                
                *Addr = KiIa32ComputeSIBAddress (Frame, Displacement, Sib, ModRm);
            }
            else 
            {
                //
                // No SIB, life is easy
                //

                *Addr = GetX86Reg (Frame, (ModRm & MI_RMMASK)) + Displacement;
            }
            break;

            
        default:
                
            //
            // we should have handled case 3 (register access)
            // before getting here...
            //

            ReturnCode = FALSE;
            break;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) 
    {
        ReturnCode = FALSE;

#if DBG
        if (KiIa32InstructionEmulationDbg)
        {
            DbgPrint("KE: KiIa32Compute32BitEffectiveAddress - Exception %lx\n", 
                     GetExceptionCode());
        }
#endif
    }
    
    //
    // Make sure the address stays within 4GB range
    //
    if (ReturnCode == TRUE) {

        *Addr = (*Addr & 0x000000007fffffffI64);
    }

    return ReturnCode;
}


BOOLEAN
KiIa32Compute16BitEffectiveAddress (
    IN PKTRAP_FRAME Frame,
    IN OUT PUCHAR *InstAddr,
    OUT PUINT_PTR Addr,
    OUT PBOOLEAN RegisterMode
    )
    
/*++

Routine Description:
    
    Compute an effective address based on bytes in memory and
    the register values passed in via the ia64 stack frame. The addressing
    mode is assumed to be 16-bit.
    
Arguments:

    Frame - Pointer to iA32 TrapFrame in the stack.
    
    InstAddr - Pointer to the first byte after the opcode.
    
    Addr - Effective address.
    
    RegisterMode - Indicates whether the effective address is inside a register or memory.

Return Value:
    
    Returns TRUE if able to compute the EA, else returns FALSE.

Note:
    
    Does not verify permission on an Effective Address. It only computes the
    value and lets someone else worry if the process should have access to
    that memory location.

--*/

{
    UCHAR ModRm;
    UCHAR DisplacementType = IA32_DISP_NONE;
    USHORT UNALIGNED *Disp16;
    LONG EffectiveAddress = 0;
    BOOLEAN ReturnCode = TRUE;
    
    
    try 
    {
        //
        // Read in the Mod/Rm and increment the instruction address
        //

        ModRm = *(*InstAddr)++;

        *RegisterMode = FALSE;

        //
        // First pass
        //

        switch (ModRm >> MI_MODSHIFT)
        {
        case 0:
            if ((ModRm & MI_RMMASK) == 6)
            {
                Disp16 = (USHORT UNALIGNED *) InstAddr;
                *Addr = *Disp16;
                *InstAddr = (*InstAddr + 2);
                return ReturnCode;
            }

            DisplacementType = IA32_DISP_NONE;
            break;
        
        case 1:
            DisplacementType = IA32_DISP8;
            break;

        case 2:
            DisplacementType = IA32_DISP16;
            break;

        case 3:
            *Addr = GetX86RegOffset (Frame, ModRm & MI_RMMASK);
            *RegisterMode = TRUE;
            return ReturnCode;
        }

        //
        // Second pass
        //

        switch (ModRm & MI_RMMASK)
        {
        case 0:
            EffectiveAddress = (GetX86Reg(Frame, IA32_REG_EBX) & 0xffff) +
                               (GetX86Reg(Frame, IA32_REG_ESI) & 0xffff) ;
            break;
        case 1:
            EffectiveAddress = (GetX86Reg(Frame, IA32_REG_EBX) & 0xffff) +
                               (GetX86Reg(Frame, IA32_REG_EDI) & 0xffff) ;
            break;
        case 2:
            EffectiveAddress = (GetX86Reg(Frame, IA32_REG_EBP) & 0xffff) +
                               (GetX86Reg(Frame, IA32_REG_ESI) & 0xffff) ;
            break;
        case 3:
            EffectiveAddress = (GetX86Reg(Frame, IA32_REG_EBP) & 0xffff) +
                               (GetX86Reg(Frame, IA32_REG_EDI) & 0xffff) ;
            break;
        case 4:
            EffectiveAddress = (GetX86Reg(Frame, IA32_REG_ESI) & 0xffff);
            break;
        case 5:
            EffectiveAddress = (GetX86Reg(Frame, IA32_REG_EDI) & 0xffff);
            break;
        case 6:
            EffectiveAddress = (GetX86Reg(Frame, IA32_REG_EBP) & 0xffff);
            break;
        case 7:
            EffectiveAddress = (GetX86Reg(Frame, IA32_REG_EBX) & 0xffff);
            break;
        }

        //
        // Read the displacement, if any
        //

        if (DisplacementType != IA32_DISP_NONE)
        {
            switch (DisplacementType)
            {
            case IA32_DISP8:
                {
                    EffectiveAddress += (LONG) (**InstAddr);
                    *InstAddr = *InstAddr + 1;
                }
                break;

            case IA32_DISP16:
                {
                    Disp16 = (USHORT UNALIGNED *) InstAddr;
                    EffectiveAddress += (LONG) *Disp16;
                    *InstAddr = *InstAddr + 2;
                }
                break;

            default:
#if DBG
                DbgPrint("KE: KiIa32Compute16BitEffectiveAddress - Invalid displacement type %lx\n",
                         DisplacementType);
#endif
                ReturnCode = FALSE;
                break;
            }
        }

        *Addr = EffectiveAddress;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
#if DBG
        if (KiIa32InstructionEmulationDbg)
        {
            DbgPrint("KE: KiIa32Compute16BitEffectiveAddress - Exception %lx\n",
                     GetExceptionCode());
        }
#endif
        ReturnCode = FALSE;
    }

    //
    // Make sure the address stays within 4GB range
    //
    if (ReturnCode == TRUE) {

        *Addr = (*Addr & 0x000000007fffffffI64);
    }

    return ReturnCode;
}


NTSTATUS
KiIa32UpdateFlags (
    IN PIA32_INSTRUCTION Instruction,
    IN ULONGLONG Operand1,
    IN ULONGLONG Result,
    IN ULONG Ia32Eflags
    )

/*++

Routine Description:
    
    Updates the Ia32 specified eflags according to the result value.
    
Arguments:

    Instruction - Pointer to the instruction being processed.
    
    Operand1 - First operand (value) of the instruction being emulated.
    
    Result - Result value.
    
    Ia32Eflags - Specific flags to update based on the result value.
    
Return Value:
    
    NTSTATUS

--*/

{
    ULONGLONG Temp = 0;
    IA32_EFLAGS Eflags = Instruction->Eflags;

    
    //
    // Sanitize the destination value.
    //

    Result = (Result & MAXULONG);

    if ((Ia32Eflags & IA32_EFLAGS_CF) != 0)
    {
        if (Result > Instruction->OperandMask)
        {
            Eflags.u.cf = 1;
        }
        else
        {
            Eflags.u.cf = 0;
        }
    }

    if ((Ia32Eflags & IA32_EFLAGS_OF) != 0)
    {
        if (((Operand1 & Result) & 0x80000000UI64) != 0)
        {
            Eflags.u.of = 1;
        }
        else
        {
            Eflags.u.of = 0;
        }
    }

    if ((Ia32Eflags & IA32_EFLAGS_SF) != 0)
    {
        switch (Instruction->OperandSize)
        {      
        case 0xff:
            Temp = 0x80UI64;
            break;

        case 0xffff:
            Temp = 0x8000UI64;
            break;

        case 0xffffffff:
            Temp = 0x80000000UI64;
            break;
        }

        if (Result & Temp)
        {
            Eflags.u.sf = 1;
        }
        else
        {
            Eflags.u.sf = 0;
        }
    }

    if ((Ia32Eflags & IA32_EFLAGS_ZF) != 0)
    {
        if (Result == 0)
        {
            Eflags.u.zf = 1;
        }
        else
        {
            Eflags.u.zf = 0;
        }
    }

    if ((Ia32Eflags & IA32_EFLAGS_AF) != 0)
    {
        Eflags.u.af = (((Operand1 ^ Result) >> 4) & 0x01UI64);
    }
    
    //
    // This needs to be the last one as it modifies the 'Result'
    //

    if ((Ia32Eflags & IA32_EFLAGS_PF) != 0)
    {
        Result = Result & Instruction->OperandMask;

        Temp = 0;
        while (Result)
        {
            Result = (Result & (Result - 1));
            Temp++;
        }

        if ((Temp & 0x01UI64) == 0)
        {
            Eflags.u.pf = 1;
        }
        else
        {
            Eflags.u.pf = 1;
        }
    }

    //
    // Reset reserved values.
    //

    Eflags.u.v1 = 1;
    Eflags.u.v2 = 0;
    Eflags.u.v3 = 0;
    Eflags.u.v4 = 0;

    //
    // Sanitize the flags
    //

    Eflags.Value = SANITIZE_AR24_EFLAGS (Eflags.Value, UserMode);

    Instruction->Eflags = Eflags;

    return STATUS_SUCCESS;
}


NTSTATUS
KiIa32UpdateResult (
    IN PIA32_INSTRUCTION Instruction,
    IN PIA32_OPERAND DestinationOperand,
    IN ULONGLONG Result
    )

/*++

Routine Description:
    
    Writes the result value taking into consideration operand size. 
    
Arguments:

    Instruction - Pointer to the instruction being processed.
    
    DestinationOperand - Operand to receive the result.
    
    Result - Result value to write
    
Return Value:
    
    NTSTATUS

--*/

{
    UNALIGNED USHORT *UshortPtr;
    UNALIGNED ULONG *UlongPtr;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    //
    //  Update results according to operand size
    //

    try 
    {
        if (DestinationOperand->RegisterMode == FALSE)
        {
            if (DestinationOperand->v > MM_MAX_WOW64_ADDRESS)
            {
                return STATUS_ACCESS_VIOLATION;
            }
        }

        switch (Instruction->OperandSize)
        {
        case OPERANDSIZE_ONEBYTE:
            *(PUCHAR)DestinationOperand->v = (UCHAR)Result;
            break;

        case OPERANDSIZE_TWOBYTES:
            UshortPtr = (UNALIGNED USHORT *) DestinationOperand->v;
            *UshortPtr = (USHORT)Result;
            break;

        case OPERANDSIZE_FOURBYTES:
            UlongPtr =(UNALIGNED ULONG *) DestinationOperand->v;
            *UlongPtr = (ULONG)Result;
            break;

        default:
#if DBG
            if (KiIa32InstructionEmulationDbg)
            {
                DbgPrint("KE: KiIa32UpdateResult() - Invalid operand size  - %lx - %p\n",
                         Instruction->OperandSize, Instruction);
            }
#endif
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode ();

#if DBG
        DbgPrint("KE: KiIa32UpdateResult - Exception %lx - %p\n",
                 NtStatus, Instruction);
#endif
    }

    return NtStatus;

}


NTSTATUS
KiIa32ReadOperand1 (
    IN PIA32_INSTRUCTION Instruction,
    OUT PULONGLONG Operand1
    )

/*++

Routine Description:
    
    Reads the first (destination) operand of an instruction.
    
Arguments:

    Instruction - Pointer to the instruction being processed.
    
    Operand1 - Buffer to receive the operand value.
    
Return Value:
    
    NTSTATUS

--*/

{
    UNALIGNED ULONG *UlongPtr;
    UNALIGNED USHORT *UshortPtr;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    try 
    {
        switch (Instruction->Description->Type)
        {
        case IA32_PARAM_RM_IMM8SIGN:
        case IA32_PARAM_RM_IMM:
        case IA32_PARAM_RM_R:
        case IA32_PARAM_R_RM8:
        case IA32_PARAM_R_RM:
        case IA32_PARAM_RM:
        case IA32_PARAM_SEGREG_RM:
            if (Instruction->OperandSize == OPERANDSIZE_TWOBYTES)
            {
                UshortPtr = (UNALIGNED USHORT *) Instruction->Operand1.v;
                *Operand1 = (ULONGLONG) *UshortPtr;
            }
            else
            {
                UlongPtr = (UNALIGNED ULONG *) Instruction->Operand1.v;
                *Operand1 = (ULONGLONG) *UlongPtr;
            }
            break;

        case IA32_PARAM_RM8_IMM8:
        case IA32_PARAM_RM8_R:
        case IA32_PARAM_RM8:
        case IA32_PARAM_SEGREG_RM8:
            *Operand1 = (ULONGLONG) (*(PUCHAR)Instruction->Operand1.v);
            break;

        default:
#if DBG
            if (KiIa32InstructionEmulationDbg)
            {
                DbgPrint("KE: KiIa32ReadRm - Invalid opcode type %lx - %p\n",
                          Instruction->Description->Type, Instruction);
            }
            NtStatus = STATUS_UNSUCCESSFUL;
#endif
            break;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode ();
#if DBG
        DbgPrint("KE: KiIa32ReadOperand1 - Exception %lx - %p\n",
                 NtStatus, Instruction);
#endif
    }

    return NtStatus;
}


NTSTATUS
KiIa32ReadOperand2 (
    IN PIA32_INSTRUCTION Instruction,
    OUT PULONGLONG Operand2
    )

/*++

Routine Description:
    
    Reads the second (source) operand of an instruction.
    
Arguments:

    Instruction - Pointer to the instruction being processed.
    
    Operand1 - Buffer to receive the operand value.
    
Return Value:
    
    NTSTATUS

--*/

{
    UNALIGNED ULONG *UlongPtr;
    UNALIGNED USHORT *UshortPtr;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    
    try 
    {
        switch (Instruction->Description->Type)
        {
        case IA32_PARAM_RM8_IMM8:
        case IA32_PARAM_RM_IMM8SIGN:
            *Operand2 = (UCHAR)Instruction->Operand2.v;
            break;

        case IA32_PARAM_RM_IMM:
            *Operand2 = Instruction->Operand2.v & Instruction->OperandMask;
            break;

        case IA32_PARAM_RM8_R:
        case IA32_PARAM_R_RM8:
            *Operand2 = (ULONGLONG)(*(PUCHAR)Instruction->Operand2.v);
            break;

        case IA32_PARAM_RM_R:
        case IA32_PARAM_R_RM:
            if (Instruction->OperandSize == OPERANDSIZE_TWOBYTES)
            {
                UshortPtr = (UNALIGNED USHORT *) Instruction->Operand2.v;
                *Operand2 = (ULONGLONG) *UshortPtr;
            }
            else
            {
                UlongPtr = (UNALIGNED ULONG *) Instruction->Operand2.v;
                *Operand2 = (ULONGLONG) *UlongPtr;
            }
            break;

        case IA32_PARAM_SEGREG_RM8:
        case IA32_PARAM_SEGREG_RM:
            break;

        default:
#if DBG
        if (KiIa32InstructionEmulationDbg)
        {
            DbgPrint("KE: KiIa32ReadOperand2 - Invalid type %lx - %p\n",
                      Instruction->Description->Type, Instruction);
        }
        NtStatus = STATUS_UNSUCCESSFUL;
#endif
            break;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode ();
#if DBG
        DbgPrint("KE: KiIa32ReadOperand2 - Exception %lx - %p\n",
                 NtStatus, Instruction);
#endif
    }

    return NtStatus;
}


NTSTATUS
KiIa32InstructionAddWithIncrement (
    IN PIA32_INSTRUCTION Instruction,
    IN ULONG Increment
    )

/*++

Routine Description:
    
    Common routine implementing Ia32 add, adc, sub and sbb instructions.
    
Arguments:

    Instruction - Pointer to the instruction being processed.
    
    Increment - Specifies the carry value.
    
Return Value:
    
    NTSTATUS

--*/

{
    ULONGLONG UlongDst;
    ULONGLONG UlongSrc;
    ULONGLONG Operand1;
    UCHAR Imm8;
    char SignImm8;
    BOOLEAN Subtract;
    NTSTATUS NtStatus;

    
    switch (Instruction->Description->Opcode)
    {
    case Ia32_Add:
    case Ia32_Adc:
        Subtract = FALSE;
        break;

    case Ia32_Sub:
    case Ia32_Sbb:
        Subtract = TRUE;
        break;

    default:
#if DBG
        if (KiIa32InstructionEmulationDbg)
        {
            DbgPrint("KE: KiIa32InstructionAddWithIncrement - Invalid opcode %lx - %p\n",
                      Instruction->Description->Opcode, Instruction);
        }
#endif
        return STATUS_UNSUCCESSFUL;
        break;

    }

    NtStatus = KiIa32ReadOperand1 (Instruction, &UlongDst);

    if (NT_SUCCESS (NtStatus))
    {
        Operand1 = UlongDst;

        NtStatus = KiIa32ReadOperand2 (Instruction, &UlongSrc);

        if (NT_SUCCESS (NtStatus))
        {
            switch (Instruction->Description->Type)
            {
            case IA32_PARAM_RM_IMM8SIGN:
                SignImm8 = (char) UlongSrc;
                if (Subtract)
                    UlongDst = (UlongDst - (Increment + SignImm8));
                else
                    UlongDst = UlongDst + Increment + SignImm8;
                break;

            case IA32_PARAM_RM8_IMM8:
                Imm8 = (UCHAR) UlongSrc;
                if (Subtract)
                    UlongDst = (UlongDst - (Increment + Imm8));
                else
                    UlongDst = UlongDst + Increment + Imm8;
                break;

            case IA32_PARAM_RM_IMM:
            default:
                if (Subtract)
                    UlongDst = (UlongDst - (Increment + UlongSrc));
                else
                    UlongDst = UlongDst + Increment + UlongSrc;
                break;
            }

            //
            //  Update results according to operand size
            //

            NtStatus = KiIa32UpdateResult (
                           Instruction,
                           &Instruction->Operand1,
                           UlongDst
                           );

            //
            // Eflags update
            //
  
            if (NT_SUCCESS (NtStatus))
            {
                KiIa32UpdateFlags (
                    Instruction,
                    Operand1,
                    UlongDst,
                    (IA32_EFLAGS_CF | IA32_EFLAGS_SF | IA32_EFLAGS_OF | 
                     IA32_EFLAGS_PF | IA32_EFLAGS_ZF | IA32_EFLAGS_AF)
                    );
            }
        }
    }

    return NtStatus;
}


NTSTATUS
KiIa32InstructionAdc (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Adc instruction handler.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to the instruction being processed.
    
Return Value:
    
    NTSTATUS

--*/

{
    return KiIa32InstructionAddWithIncrement (
               Instruction,
               (ULONG)Instruction->Eflags.u.cf);

    UNREFERENCED_PARAMETER (TrapFrame);
}


NTSTATUS
KiIa32InstructionAdd (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Add instruction handler.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to the instruction being processed.
    
Return Value:
    
    NTSTATUS

--*/

{
    return KiIa32InstructionAddWithIncrement (
               Instruction,
               0);

    UNREFERENCED_PARAMETER (TrapFrame);
}


NTSTATUS
KiIa32InstructionArithmeticBitwiseHelper (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    And, Or & Xor instructions handler.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to the instruction being processed.
    
Return Value:
    
    NTSTATUS

--*/

{
    ULONGLONG UlongDst;
    ULONGLONG UlongSrc;
    ULONGLONG Operand1;
    NTSTATUS NtStatus;

    
    NtStatus = KiIa32ReadOperand1 (Instruction, &UlongDst);

    if (NT_SUCCESS (NtStatus))
    {
        Operand1 = UlongDst;

        NtStatus = KiIa32ReadOperand2 (Instruction, &UlongSrc);

        if (NT_SUCCESS (NtStatus))
        {
            switch (Instruction->Description->Opcode)
            {
            case Ia32_And:
                UlongDst = UlongDst & UlongSrc;
                break;

            case Ia32_Or:
                UlongDst = UlongDst | UlongSrc;
                break;

            case Ia32_Xor:
                UlongDst = UlongDst ^ UlongSrc;
                break;

            default:
#if DBG      
                NtStatus = STATUS_UNSUCCESSFUL;
                if (KiIa32InstructionEmulationDbg)
                {
                    DbgPrint("KE: KiIa32InstructionBitwiseHelper - Invalid operation %lx - %p\n", 
                             Instruction->Description->Opcode, Instruction);
                }
#endif
                break;
            }

            if (NT_SUCCESS (NtStatus))
            {
                NtStatus = KiIa32UpdateResult (
                               Instruction,
                               &Instruction->Operand1,
                               UlongDst
                               );

                if (NT_SUCCESS (NtStatus))
                {
                    NtStatus = KiIa32UpdateFlags (
                                   Instruction,
                                   Operand1,
                                   UlongDst,
                                   (IA32_EFLAGS_SF | IA32_EFLAGS_PF | IA32_EFLAGS_ZF)
                                   );

                    Instruction->Eflags.u.cf = 0;
                    Instruction->Eflags.u.of = 0;
                }
            }
        }
    }

    return NtStatus;

    UNREFERENCED_PARAMETER (TrapFrame);
}


NTSTATUS
KiIa32InstructionBitTestHelper (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Bt, Bts, Btr & Btc instructions handler.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to the instruction being processed.
    
Return Value:
    
    NTSTATUS

--*/

{
    ULONGLONG UlongDst;
    ULONGLONG UlongSrc;
    ULONGLONG BitTestResult;
    NTSTATUS NtStatus;



    NtStatus = KiIa32ReadOperand2 (Instruction, &UlongSrc);

    if (NT_SUCCESS (NtStatus))
    {
        if (Instruction->Operand2.RegisterMode == TRUE)
        {
            if (Instruction->Prefix.b.AddressOverride == 1)
            {
                Instruction->Operand1.v += ((UlongSrc >> 4) << 1);
                UlongSrc &= 0x0f;
            }
            else
            {
                Instruction->Operand1.v += ((UlongSrc >> 5) << 2);
                UlongSrc &= 0x1f;
            }
        }
        
        NtStatus = KiIa32ReadOperand1 (Instruction, &UlongDst);

        if (NT_SUCCESS (NtStatus))
        {
        
            BitTestResult = (UlongDst & (1 << UlongSrc));
  
            if (BitTestResult)
            {
                Instruction->Eflags.u.cf = 1;
            }
            else
            {
                Instruction->Eflags.u.cf = 0;
            }
        
            switch (Instruction->Description->Opcode)
            {
            case Ia32_Btc:
                UlongDst ^= (1 << UlongSrc);
                break;

            case Ia32_Btr:
                UlongDst &= (~(1 << UlongSrc));
                break;

            case Ia32_Bts:
                UlongDst |= (1 << UlongSrc);
                break;
            }

            NtStatus = KiIa32UpdateResult (
                           Instruction,
                           &Instruction->Operand1,
                           UlongDst
                           );
        }
    }

    return NtStatus;

    UNREFERENCED_PARAMETER (TrapFrame);
}


NTSTATUS
KiIa32InstructionOneParamHelper (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Inc, Dec, Neg & Not instructions handler.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to the instruction being processed.
    
Return Value:
    
    NTSTATUS

--*/

{
    UCHAR Opcode;
    ULONG FlagsAffected = 0;
    ULONGLONG UlongDst;
    ULONGLONG UlongSrc;
    NTSTATUS NtStatus;

    
    NtStatus = KiIa32ReadOperand1 (
                   Instruction,
                   &UlongDst
                   );

    if (NT_SUCCESS (NtStatus))
    {

        UlongSrc = UlongDst;
        Opcode = Instruction->Description->Opcode;

        switch (Opcode)
        {
        case Ia32_Inc:
            UlongDst += 1;
            break;

        case Ia32_Dec:
            UlongDst -= 1;
            break;

        case Ia32_Neg:
            UlongDst = -(LONGLONG)UlongDst;
            break;

        case Ia32_Not:
            UlongDst = ~UlongDst;
            break;
        }

        NtStatus = KiIa32UpdateResult (
                       Instruction,
                       &Instruction->Operand1,
                       UlongDst
                       );

        if (NT_SUCCESS (NtStatus))
        {

            switch (Opcode)
            {
            case Ia32_Inc:
            case Ia32_Dec:
                FlagsAffected = (IA32_EFLAGS_SF | IA32_EFLAGS_PF | 
                                 IA32_EFLAGS_ZF);

                break;

            case Ia32_Neg:
                if (UlongDst == 0)
                    Instruction->Eflags.u.cf = 0;
                else
                    Instruction->Eflags.u.cf = 1;

                FlagsAffected = (IA32_EFLAGS_SF | IA32_EFLAGS_PF | 
                                 IA32_EFLAGS_ZF | IA32_EFLAGS_AF | IA32_EFLAGS_OF);
                break;
            }


            if (FlagsAffected != 0)
            {
                NtStatus = KiIa32UpdateFlags (
                               Instruction,
                               UlongSrc,
                               UlongDst,
                               FlagsAffected
                               );
            }
        }
    }

    return NtStatus;

    UNREFERENCED_PARAMETER (TrapFrame);
}


NTSTATUS
KiIa32InstructionXadd (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Xadd instruction handler.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to the instruction being processed.
    
Return Value:
    
    NTSTATUS

--*/

{
    ULONGLONG UlongDst;
    ULONGLONG UlongSrc;
    ULONGLONG Operand1;
    ULONGLONG Temp;
    NTSTATUS NtStatus;

    
    NtStatus = KiIa32ReadOperand1 (Instruction, &UlongDst);

    if (NT_SUCCESS (NtStatus))
    {
        Operand1 = UlongDst;

        NtStatus = KiIa32ReadOperand2 (Instruction, &UlongSrc);

        if (NT_SUCCESS (NtStatus))
        {
            Temp = UlongDst;
            UlongDst += UlongSrc;

            NtStatus = KiIa32UpdateResult (
                           Instruction,
                           &Instruction->Operand1,
                           UlongDst
                           );

            if (NT_SUCCESS (NtStatus))
            {
                NtStatus = KiIa32UpdateResult (
                               Instruction,
                               &Instruction->Operand2,
                               Temp
                               );

                if (NT_SUCCESS (NtStatus))
                {
                    NtStatus = KiIa32UpdateFlags (
                                   Instruction,
                                   Operand1,
                                   UlongDst,
                                   (IA32_EFLAGS_CF | IA32_EFLAGS_SF | IA32_EFLAGS_PF | 
                                    IA32_EFLAGS_ZF | IA32_EFLAGS_OF | IA32_EFLAGS_AF)
                                   );
                }
            }
        }
    }
    
    return NtStatus;

    UNREFERENCED_PARAMETER (TrapFrame);
}


NTSTATUS
KiIa32InstructionXchg (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Xchg instruction handler.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to the instruction being processed.
    
Return Value:
    
    NTSTATUS

--*/

{
    ULONGLONG UlongDst;
    ULONGLONG UlongSrc;
    NTSTATUS NtStatus;

    
    NtStatus = KiIa32ReadOperand1 (Instruction, &UlongDst);

    if (NT_SUCCESS (NtStatus))
    {
        NtStatus = KiIa32ReadOperand2 (Instruction, &UlongSrc);

        if (NT_SUCCESS (NtStatus))
        {
            NtStatus = KiIa32UpdateResult (
                           Instruction,
                           &Instruction->Operand1,
                           UlongSrc
                           );

            if (NT_SUCCESS (NtStatus))
            {
                NtStatus = KiIa32UpdateResult (
                               Instruction,
                               &Instruction->Operand2,
                               UlongDst
                               );
            }
        }
    }
    
    return NtStatus;

    UNREFERENCED_PARAMETER (TrapFrame);
}


NTSTATUS
KiIa32InstructionCmpXchg (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Cmpxchg instruction handler.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to the instruction being processed.
    
Return Value:
    
    NTSTATUS

--*/

{
    ULONGLONG UlongDst;
    ULONGLONG UlongSrc;
    ULONGLONG Accumulator;
    IA32_OPERAND AccumulatorOperand;
    NTSTATUS NtStatus;


    NtStatus = KiIa32ReadOperand1 (Instruction, &UlongDst);

    if (NT_SUCCESS (NtStatus))
    {
        NtStatus = KiIa32ReadOperand2 (Instruction, &UlongSrc);

        if (NT_SUCCESS (NtStatus))
        {
            Accumulator = GetX86Reg (TrapFrame, IA32_REG_EAX);
            Accumulator &= Instruction->OperandMask;

            if (Accumulator == UlongDst)
            {
                Instruction->Eflags.u.zf = 1;

                NtStatus = KiIa32UpdateResult (
                               Instruction,
                               &Instruction->Operand1,
                               UlongSrc
                               );
            }
            else
            {
                Instruction->Eflags.u.zf = 0;

                AccumulatorOperand.RegisterMode = TRUE;
                AccumulatorOperand.v = GetX86RegOffset (TrapFrame, IA32_REG_EAX);

                NtStatus = KiIa32UpdateResult (
                               Instruction,
                               &AccumulatorOperand,
                               UlongDst
                               );
            }


            if (NT_SUCCESS (NtStatus))
            {
                NtStatus = KiIa32UpdateFlags (
                               Instruction,
                               UlongDst,
                               UlongDst,
                               (IA32_EFLAGS_CF | IA32_EFLAGS_SF | 
                                IA32_EFLAGS_PF | IA32_EFLAGS_OF | 
                                IA32_EFLAGS_AF)
                               );
            }
        }
    }

    return NtStatus;
}


NTSTATUS
KiIa32InstructionCmpXchg8b (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Cmpxchg8b instruction handler.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to the instruction being processed.
    
Return Value:
    
    NTSTATUS

--*/

{
    UNALIGNED ULONGLONG *UlongDst;
    UNALIGNED ULONGLONG *UlongSrc;
    ULONGLONG EdxEax;


    EdxEax = GetX86Reg (TrapFrame, IA32_REG_EDX);
    EdxEax <<= 32;
    EdxEax |= GetX86Reg (TrapFrame, IA32_REG_EAX);

    UlongDst = (PULONGLONG)Instruction->Operand1.v;

    if (*UlongDst == EdxEax)
    {
        Instruction->Eflags.u.zf = 1;

        *UlongDst = ((((ULONGLONG) GetX86Reg (TrapFrame, IA32_REG_ECX)) << 32) | 
                      ((ULONGLONG) GetX86Reg (TrapFrame, IA32_REG_EBX)));

    }
    else
    {
        Instruction->Eflags.u.zf = 0;

        UlongSrc = (PULONGLONG) GetX86RegOffset (TrapFrame, IA32_REG_EDX);
        *UlongSrc = ((*UlongDst) >> 32);

        UlongSrc = (PULONGLONG) GetX86RegOffset (TrapFrame, IA32_REG_EAX);
        *UlongSrc = ((*UlongDst) & 0xffffffff);
    }
    
    return STATUS_SUCCESS;
}


NTSTATUS
KiIa32InstructionMoveSeg (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Mov Seg-Reg instruction handler.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to the instruction being processed.
    
Return Value:
    
    NTSTATUS

--*/

{
    return STATUS_NOT_IMPLEMENTED;

    UNREFERENCED_PARAMETER (TrapFrame);
    UNREFERENCED_PARAMETER (Instruction);
}


NTSTATUS
KiIa32LocateInstruction (
    IN PKTRAP_FRAME TrapFrame,
    OUT PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Searches the OpcodeDescription table for matching instruction. Fills any relevant
    prefix values inside the Instruction structure.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to an Instruction structure to receive the opcode description.
    
Return Value:
    
    NTSTATUS

--*/

{
    BOOLEAN PrefixLoop;
    BOOLEAN Match;
    UCHAR ByteValue;
    UCHAR ByteBuffer[4];
    PUCHAR RegOpcodeByte;
    PIA32_OPCODE_DESCRIPTION OpcodeDescription;
    ULONG Count;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    
    PrefixLoop = TRUE;

    while (PrefixLoop)
    {
        try
        {
            ByteValue = ProbeAndReadUchar ((PUCHAR)Instruction->Eip);
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            NtStatus = GetExceptionCode();
            break;
        }

        switch (ByteValue)
        {
        case MI_LOCK_PREFIX:
            Instruction->Prefix.b.Lock = 1;
            break;
        case MI_REPNE_PREFIX:
            Instruction->Prefix.b.RepNe = 1;
            break;
        case MI_REP_PREFIX:
            Instruction->Prefix.b.Rep = 1;
            break;
        case MI_SEGCS_PREFIX:
            Instruction->Prefix.b.CsOverride = 1;
            break;
        case MI_SEGSS_PREFIX:
            Instruction->Prefix.b.SsOverride = 1;
            break;
        case MI_SEGDS_PREFIX:
            Instruction->Prefix.b.DsOverride = 1;
            break;
        case MI_SEGES_PREFIX:
            Instruction->Prefix.b.EsOverride = 1;
            break;
        case MI_SEGFS_PREFIX:
            Instruction->Prefix.b.FsOverride = 1;
            break;
        case MI_SEGGS_PREFIX:
            Instruction->Prefix.b.GsOverride = 1;
            break;
        case MI_OPERANDSIZE_PREFIX:
            Instruction->Prefix.b.SizeOverride = 1;
            break;
        case MI_ADDRESSOVERRIDE_PREFIX:
            Instruction->Prefix.b.AddressOverride = 1;
            break;

        default:
            PrefixLoop = FALSE;
            break;
        }

        if (PrefixLoop == TRUE)
        {
            Instruction->Eip++;
        }
    }

    try 
    {
        RtlCopyMemory(ByteBuffer, Instruction->Eip, sizeof (ByteBuffer));
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode();
    }

    if (NT_SUCCESS (NtStatus))
    {
        //
        // Locate the opcode
        //
        
        Match = FALSE;
        OpcodeDescription = OpcodesDescription;
        Count = (sizeof (OpcodesDescription) / sizeof (IA32_OPCODE_DESCRIPTION));
        while (Count != 0)
        {
            Count--;
            if (OpcodeDescription->Byte1 == ByteBuffer[0])
            {
                Match = TRUE;
                if (OpcodeDescription->Count.m.Bytes == 2)
                {
                    RegOpcodeByte = &ByteBuffer[2];
                    if (OpcodeDescription->Byte2 != ByteBuffer[1])
                    {
                        Match = FALSE;
                    }
                }
                else
                {
                    RegOpcodeByte = &ByteBuffer[1];
                }

                if ((Match == TRUE) && 
                    (OpcodeDescription->Count.m.RegOpcode))
                {
                    if (OpcodeDescription->Byte3 != ((*RegOpcodeByte & MI_REGMASK) >> MI_REGSHIFT))
                    {
                        Match = FALSE;
                    }
                }

                if (Match == TRUE)
                {
                    break;
                }
            }
            OpcodeDescription++;
        }

        if (Match != TRUE)
        {
#if DBG
            if (KiIa32InstructionEmulationDbg)
            {
                DbgPrint("KE: KiIa32LocateInstruction - Unable to locate instruction %p\n",
                         Instruction);
            }
#endif
            NtStatus = STATUS_UNSUCCESSFUL;
        }

        if (NT_SUCCESS (NtStatus))
        {
            Instruction->Description = OpcodeDescription;
            Instruction->Eip += OpcodeDescription->Count.m.Bytes;
        }
    }

    return NtStatus;

    UNREFERENCED_PARAMETER (TrapFrame);
}


NTSTATUS
KiIa32DecodeInstruction (
    IN PKTRAP_FRAME TrapFrame,
    OUT PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Decodes the instruction prefixes and operands.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to an Instruction structure to receive the opcode description.
    
Return Value:
    
    NTSTATUS

--*/

{
    UCHAR InstructionType;
    UCHAR ModRm;
    UNALIGNED USHORT *UnalignedUshort;
    UNALIGNED ULONG *UnalignedUlong;
    IA32_OPERAND Temp;
    BOOLEAN ReturnCode;
    NTSTATUS NtStatus;


    //
    // Check instruction pointer validity
    //

    if (TrapFrame->StIIP > MM_MAX_WOW64_ADDRESS) {
        return STATUS_ACCESS_VIOLATION;
    }

    //
    // Initialize the instruction pointer
    //

    Instruction->Eip = (PCHAR) TrapFrame->StIIP;
    KiIa32GetX86Eflags (Instruction->Eflags);

    //
    // Locate a description for the instruction
    //

    NtStatus = KiIa32LocateInstruction (TrapFrame, Instruction);

    if (NT_SUCCESS (NtStatus))
    {
        //
        // Let's parse the arguments
        //
        
        InstructionType = Instruction->Description->Type;
        switch (InstructionType)
        {
        case IA32_PARAM_RM8_IMM8:
        case IA32_PARAM_RM8_R:
        case IA32_PARAM_R_RM8:
        case IA32_PARAM_RM8:
        case IA32_PARAM_SEGREG_RM8:
            Instruction->OperandSize = OPERANDSIZE_ONEBYTE;
            Instruction->OperandMask = 0xff;
            break;

        case IA32_PARAM_RM_IMM:
        case IA32_PARAM_RM_IMM8SIGN:
        case IA32_PARAM_RM_R:
        case IA32_PARAM_R_RM:
        case IA32_PARAM_RM:
            if (Instruction->Prefix.b.SizeOverride)
            {
                Instruction->OperandSize = OPERANDSIZE_TWOBYTES;
                Instruction->OperandMask = 0xffff;
            }
            else
            {
                Instruction->OperandSize = OPERANDSIZE_FOURBYTES;
                Instruction->OperandMask = 0xffffffff;
            }
            break;

            break;
        
        case IA32_PARAM_SEGREG_RM:
            Instruction->OperandSize = OPERANDSIZE_TWOBYTES;
            Instruction->OperandMask = 0xffff;
            break;

        default:
#if DBG
            if (KiIa32InstructionEmulationDbg)
            {
                DbgPrint("KE: KiIa32DecodeInstruction - Invalid Instruction type %lx, %p\n",
                          Instruction->Description->Type, Instruction);
            }
#endif
            return STATUS_UNSUCCESSFUL;
            break;
        }

        try 
        {
            ModRm = ProbeAndReadUchar ((PUCHAR)Instruction->Eip);
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            return GetExceptionCode();
        }

        //
        // Eip should be pointing now at the bytes following the opcode
        //

        if (Instruction->Prefix.b.AddressOverride == 0)
        {
            ReturnCode = KiIa32Compute32BitEffectiveAddress (
                             TrapFrame,
                             (PUCHAR *)&Instruction->Eip,
                             &Instruction->Operand1.v,
                             &Instruction->Operand1.RegisterMode
                             );
        }
        else
        {
            ReturnCode = KiIa32Compute16BitEffectiveAddress (
                             TrapFrame,
                             (PUCHAR *)&Instruction->Eip,
                             &Instruction->Operand1.v,
                             &Instruction->Operand1.RegisterMode
                             );
        }

        if (ReturnCode != TRUE)
        {
            NtStatus = STATUS_UNSUCCESSFUL;
        }

        if (Instruction->Prefix.b.FsOverride)
        {
            try
            {
                Instruction->Operand1.v += (ULONGLONG)NtCurrentTeb32();
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                NtStatus = GetExceptionCode ();
#if DBG
                if (KiIa32InstructionEmulationDbg)
                {
                    DbgPrint("KE: KiIa32DecodeInstruction - Exception while reading NtCurrentTeb32() - %p\n",
                             Instruction);
                }
#endif
            }
        }

        //
        // Read in more args
        //

        if (NT_SUCCESS (NtStatus))
        {
            switch (InstructionType)
            {
            case IA32_PARAM_RM8_IMM8:
            case IA32_PARAM_RM_IMM8SIGN:
                try 
                {
                    Instruction->Operand2.v = (ULONG_PTR) ProbeAndReadUchar ((PUCHAR)Instruction->Eip);
                    Instruction->Eip += 1;
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    NtStatus = GetExceptionCode();
                }
                break;

            case IA32_PARAM_RM_IMM:
                try 
                {
                    if (Instruction->OperandSize == OPERANDSIZE_TWOBYTES)
                    {
                        UnalignedUshort = (UNALIGNED USHORT *) Instruction->Eip;
                        Instruction->Operand2.v = (ULONG_PTR) *UnalignedUshort;
                        Instruction->Eip += sizeof (USHORT);
                    }
                    else
                    {
                        UnalignedUlong = (UNALIGNED ULONG *) Instruction->Eip;
                        Instruction->Operand2.v = (ULONG_PTR) *UnalignedUlong;
                        Instruction->Eip += sizeof (ULONG);
                    }
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    NtStatus = GetExceptionCode();
                }
                break;

            case IA32_PARAM_RM8_R:
            case IA32_PARAM_R_RM8:
            case IA32_PARAM_RM_R:
            case IA32_PARAM_R_RM:
                Instruction->Operand2.v = GetX86RegOffset (
                                              TrapFrame,
                                              (ModRm & MI_REGMASK) >> MI_REGSHIFT);
                Instruction->Operand2.RegisterMode = TRUE;
                break;

            case IA32_PARAM_RM8:
            case IA32_PARAM_RM:
            case IA32_PARAM_SEGREG_RM8:
            case IA32_PARAM_SEGREG_RM:
                break;

            default:
                NtStatus = STATUS_UNSUCCESSFUL;
#if DBG
                DbgPrint("KE: KiIa32DecodeInstruction - Invalid instruction type %lx - %p\n",
                         InstructionType, Instruction);
#endif
                break;

            }

            //
            // Adjust operands order
            //

            if (NT_SUCCESS (NtStatus))
            {
                switch (InstructionType)
                {
                case IA32_PARAM_R_RM8:
                case IA32_PARAM_R_RM:
                    Temp = Instruction->Operand2;
                    Instruction->Operand2 = Instruction->Operand1;
                    Instruction->Operand1 = Temp;
                    break;
                }
            }
        }
    }

    return NtStatus;
}


NTSTATUS
KiIa32ExecuteInstruction (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Executes the instruction handler.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to the instruction being processed.
    
Return Value:
    
    NTSTATUS

--*/

{
    NTSTATUS NtStatus;

#if DBG
    if (KiIa32InstructionEmulationDbg)
    {
        DbgPrint("KE: KiIa32ExecuteInstruction - Calling %s %lx, %lx. Instruction = %p\n",
                 KiIa32InstructionHandlerNames[Instruction->Description->Opcode],
                 Instruction->Operand1.v,
                 Instruction->Operand2.v,
                 Instruction);
    }
#endif

    NtStatus = KiIa32InstructionHandler[Instruction->Description->Opcode] (
                   TrapFrame,
                   Instruction
                   );

    //
    //  If all is good...
    //

    if (NT_SUCCESS (NtStatus))
    {
        TrapFrame->StIIP = (ULONGLONG) Instruction->Eip;
        KiIa32SetX86Eflags (Instruction->Eflags);
    }

    return NtStatus;
}


NTSTATUS
KiIa32EmulateInstruction (
    IN PKTRAP_FRAME TrapFrame,
    IN PIA32_INSTRUCTION Instruction
    )

/*++

Routine Description:
    
    Emulates the instruction and emulates the lock prefix, if any.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
    Instruction - Pointer to the instruction being processed.
    
Return Value:
    
    NTSTATUS

--*/

{
    NTSTATUS NtStatus;


    //
    //   Acquire the lock mutex
    //

    if (Instruction->Prefix.b.Lock)
    {
        if (ExAcquireRundownProtection (&PsGetCurrentThread()->RundownProtect) == FALSE)
        {
            return STATUS_UNSUCCESSFUL;
        }

        KiIa32AcquireMisalignedLockFastMutex ();
    }

    try
    {
        NtStatus = KiIa32ExecuteInstruction (TrapFrame, Instruction);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode();
    }
    
    //
    //   Release the lock mutex
    //

    if (Instruction->Prefix.b.Lock)
    {
        KiIa32ReleaseMisalignedLockFastMutex ();

        ExReleaseRundownProtection (&PsGetCurrentThread()->RundownProtect);
    }

    return NtStatus;
}


NTSTATUS
KiIa32InterceptUnalignedLock (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:
    
    Handles misaligned lock interception raised by the iVE.
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
Return Value:
    
    NTSTATUS

--*/

{
    NTSTATUS NtStatus;
    IA32_INSTRUCTION Instruction;


    RtlZeroMemory (&Instruction, sizeof (Instruction));

    //
    // Decode the faulting instruction
    //

    NtStatus = KiIa32DecodeInstruction (TrapFrame, &Instruction);

    if (NT_SUCCESS (NtStatus))
    {

        //
        // xchg instruction asserts the lock by default
        //

        if (Instruction.Description->Opcode == Ia32_Xchg)
        {
            Instruction.Prefix.b.Lock = 1;
        }

        //
        // Execute the x86 instruction by emulating its behaviour
        //

        NtStatus = KiIa32EmulateInstruction (TrapFrame, &Instruction);

    }

    if (NtStatus == STATUS_UNSUCCESSFUL)
    {
        NtStatus = STATUS_PRIVILEGED_INSTRUCTION;
    }

    return NtStatus;
}


NTSTATUS
KiIa32ValidateInstruction (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:
    
    This routine valiates the instruction that we trapped for. Currently,
    the following instructions are checked:
    
    - mov ss, r/m : the register/memory is validated to contain
      a valid stack-selector value.
      
    NOTE: This routine is only called for trap instructions (i.e. IIP is incremented
          after the fault).
    
Arguments:

    TrapFrame - Pointer to TrapFrame.
    
Return Value:
    
    NTSTATUS

--*/

{
    NTSTATUS NtStatus;
    IA32_INSTRUCTION Instruction;
    ULONGLONG UlongSrc;
    ULONGLONG StIIP;


    RtlZeroMemory (&Instruction, sizeof (Instruction));

    //
    // Adjust the instruction 
    //
    StIIP = TrapFrame->StIIP;
    TrapFrame->StIIP = TrapFrame->StIIPA;

    //
    // Decode the faulting instruction
    //

    NtStatus = KiIa32DecodeInstruction (TrapFrame, &Instruction);

    if (NT_SUCCESS (NtStatus))
    {

        //
        // Parse the opcode here
        //

        switch (Instruction.Description->Opcode)
        {
        case Ia32_MovToSeg:
            {
                //
                // Validate the stack-selector being loaded
                //

                NtStatus = KiIa32ReadOperand1 (&Instruction, &UlongSrc);
                
                if (NT_SUCCESS (NtStatus)) {
                    
                    //
                    // If not a valid selector value
                    //

                    if ((UlongSrc != 0x23) &&
                        (UlongSrc != 0x1b) &&
                        (UlongSrc != 0x3b)) {
                        
                        NtStatus = STATUS_ILLEGAL_INSTRUCTION;
                    }
                }

            }
            break;

        default:
            NtStatus = STATUS_ILLEGAL_INSTRUCTION;
            break;
        }

    } else {
        NtStatus = STATUS_ILLEGAL_INSTRUCTION;
    }

    //
    // Restore the saved IIP
    //

    if (NT_SUCCESS (NtStatus)) {
        TrapFrame->StIIP = StIIP;
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\iafptrap.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    iafptrap.c

Abstract:

    This is based on the i386 trapc.c module with very minor changes.
    It would be nice if there wasn't so much duplicate code so that
    fixes to that file would carry over to this one...
    
    This module contains some trap handling code written in C.
    Only by the kernel.

Author:

    Ken Reneris     6-9-93

Revision History:

--*/

#include    "ki.h"
#include    "ia32def.h"

NTSTATUS
Ki386CheckDivideByZeroTrap (
    IN  PKTRAP_FRAME    UserFrame
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Ki386CheckDivideByZeroTrap)
#endif


#define REG(field)          ((ULONG_PTR)(&((KTRAP_FRAME *)0)->field))
#define GETREG(frame,reg)   ((PULONG) (((ULONG_PTR) frame)+reg))[0]

typedef struct {
    UCHAR   RmDisplaceOnly;     // RM of displacment only, no base reg
    UCHAR   RmSib;              // RM of SIB
    UCHAR   RmDisplace;         // bit mask of RMs which have a displacement
    UCHAR   Disp;               // sizeof displacement (in bytes)
} KMOD, *PKMOD;

static ULONG_PTR RM32[] = {
    /* 000 */   REG(IntV0),         // EAX
    /* 001 */   REG(IntT2),         // ECX
    /* 010 */   REG(IntT3),         // EDX
    /* 011 */   REG(IntT4),         // EBX
    /* 100 */   REG(IntSp),         // ESP
    /* 101 */   REG(IntTeb),        // EBP
    /* 110 */   REG(IntT5),         // ESI
    /* 111 */   REG(IntT6)          // EDI
};

static KMOD MOD32[] = {
    /* 00 */     5,     4,   0x20,   4,
    /* 01 */  0xff,     4,   0xff,   1,
    /* 10 */  0xff,     4,   0xff,   4,
    /* 11 */  0xff,  0xff,   0x00,   0
} ;

static struct {
    UCHAR   Opcode1, Opcode2;   // instruction opcode
    UCHAR   ModRm, type;        // if 2nd part of opcode is encoded in ModRm
} NoWaitNpxInstructions[] = {
    /* FNINIT   */  0xDB, 0xE3, 0,  1,
    /* FNCLEX   */  0xDB, 0xE2, 0,  1,
    /* FNSTENV  */  0xD9, 0x06, 1,  1,
    /* FNSAVE   */  0xDD, 0x06, 1,  1,
    /* FNSTCW   */  0xD9, 0x07, 1,  2,
    /* FNSTSW   */  0xDD, 0x07, 1,  3,
    /* FNSTSW AX*/  0xDF, 0xE0, 0,  4,
                    0x00, 0x00, 0,  1
};


NTSTATUS
Ki386CheckDivideByZeroTrap (
    IN  PKTRAP_FRAME    UserFrame
    )
/*++

Routine Description:

    This function gains control when the x86 processor generates a
    divide by zero trap.  The x86 design generates such a trap on
    divide by zero and on division overflows.  In order to determine
    which expection code to dispatch, the divisor of the "div" or "idiv"
    instruction needs to be inspected.

Arguments:

    UserFrame - Trap frame of the divide by zero trap

Return Value:

    exception code dispatch

--*/
{
    ULONG       operandsize, operandmask, i;
    ULONG_PTR   accum;
    PUCHAR      istream;
    UCHAR       ibyte, rm;
    PKMOD       Mod;
    BOOLEAN     fPrefix;
    NTSTATUS    status;
    BOOLEAN     fHighRm8;

    status = STATUS_INTEGER_DIVIDE_BY_ZERO;
    fHighRm8 = FALSE;

    try {

        //
        // read instruction prefixes
        //

        fPrefix = TRUE;
        operandsize = 4;
        operandmask = 0xffffffff;
        istream = (PUCHAR) (ULONG_PTR) EIP(UserFrame);
        while (fPrefix) {
            ibyte = ProbeAndReadUchar(istream);
            istream++;
            switch (ibyte) {
                case 0x2e:  // cs override
                case 0x36:  // ss override
                case 0x3e:  // ds override
                case 0x26:  // es override
                case 0x64:  // fs override
                case 0x65:  // gs override
                case 0xF3:  // rep
                case 0xF2:  // rep
                case 0xF0:  // lock
                    break;

                case 0x66:
                    // 16 bit operand override
                    operandsize = 2;
                    operandmask = 0xffff;
                    break;

                case 0x67:
                    // 16 bit address size override
                    // this is some non-flat code
                    goto try_exit;

                default:
                    fPrefix = FALSE;
                    break;
            }
        }

        //
        // Check instruction opcode
        //

        if (ibyte != 0xf7  &&  ibyte != 0xf6) {
            // this is not a DIV or IDIV opcode
            goto try_exit;
        }

        if (ibyte == 0xf6) {
            // this is a byte div or idiv
            operandsize = 1;
            operandmask = 0xff;
        }

        //
        // Get Mod R/M
        //

        ibyte = ProbeAndReadUchar (istream);
        istream++;
        Mod = MOD32 + (ibyte >> 6);
        rm  = ibyte & 7;

        //
        // put register values into accum
        //

        if (operandsize == 1  &&  (ibyte & 0xc0) == 0xc0) {
            if ((rm & 4) != 0) {
                fHighRm8 = TRUE;
            }
        }

        accum = 0;
        if (rm != Mod->RmDisplaceOnly) {
            if (rm == Mod->RmSib) {
                // get SIB
                ibyte = ProbeAndReadUchar(istream);
                istream++;
                i = (ibyte >> 3) & 7;
                if (i != 4) {
                    accum = GETREG(UserFrame, RM32[i]);
                    accum = accum << (ibyte >> 6);    // apply scaler
                }
                i = ibyte & 7;
                accum = accum + GETREG(UserFrame, RM32[i]);
            } else {
                //
                // get register's value
                //
                if (fHighRm8 == TRUE) {
                    accum = GETREG(UserFrame, RM32[rm & 3]);
                    accum = accum >> 8;
                } else {
                    accum = GETREG(UserFrame, RM32[rm]);
                }
            }
        }

        //
        // apply displacement to accum
        //

        if (Mod->RmDisplace & (1 << rm)) {
            if (Mod->Disp == 4) {
                i = ProbeAndReadUlong ((PULONG) istream);
            } else {
                ibyte = ProbeAndReadChar (istream);
                i = (signed long) ((signed char) ibyte);    // sign extend
            }
            accum += i;
        }

        //
        // if this is an effective address, go get the data value
        //

        if (Mod->Disp) {
            switch (operandsize) {
                case 1:  accum = ProbeAndReadUchar((PUCHAR) accum);    break;
                case 2:  accum = ProbeAndReadUshort((PUSHORT) accum);  break;
                case 4:  accum = ProbeAndReadUlong((PULONG) accum);    break;
            }
        }

        //
        // accum now contains the instruction operand, see if the
        // operand was really a zero
        //

        if (accum & operandmask) {
            // operand was non-zero, must be an overflow
            status = STATUS_INTEGER_OVERFLOW;
        }

try_exit: ;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        // do nothing...
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\ia32trap.c ===
/*++

Module Name:
        
    ia32trap.c

Abstract:

    This module contains iA32 trap handling code.
    Only used by kernel.

    Fault can ONLY be initiated from user mode code.  There is no support
    for iA32 code in the kernel mode.

    For common pratice, we always return to the caller (lower level fault
    handler) and have the system do a normal ia64 exception dispatch. The
    wow64 code takes that exception and passes it back to the ia32 code
    as needed.

Revision History:

    1  Feb.  1999             Initial Version
    
    16 Feb.  2000    SamerA   Don't break on POPF/POPFD instructions and 
                              alignment faults for Wow64 processes.

    17 Oct.  2000    v-cspira Fix the emulation of smsw to handle the SIB byte
    
    31 Oct.  2000    SamerA   Ia32 Lock prefix emulation.

    25 Sep.  2001    SamerA   Stack-Selector (SS) Load instruction emulation.

--*/

// Get all the iadebugging stuff for now.
#define IADBG   1

#include "ki.h"
#include "ia32def.h"



VOID
KiIA32CommonArgs (
    IN PKTRAP_FRAME Frame,
    IN ULONG ExceptionCode,
    IN PVOID ExceptionAddress,
    IN ULONG_PTR Argument0,
    IN ULONG_PTR Argument1,
    IN ULONG_PTR Argument2
    )
/*++

Routine Description
    This routine sets up the ExceptionFrame 

Arguments:
    Frame - Supply a pointer to an iA32 TrapFrame

    ExceptionCode - Supplies a Exception Code

    ExceptionAddress - Supplies a pointer to user exception address

    Argument0, Argument1, Argument2 - Possible ExceptionInformation

Return:
    Nothing
--*/
{
    PEXCEPTION_RECORD ExceptionRecord;

    ExceptionRecord = (PEXCEPTION_RECORD)&Frame->ExceptionRecord;

    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->ExceptionCode = ExceptionCode;
    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionAddress = ExceptionAddress;
    ExceptionRecord->NumberParameters = 5;
       
    ExceptionRecord->ExceptionInformation[0] = Argument0;
    ExceptionRecord->ExceptionInformation[1] = Argument1;
    ExceptionRecord->ExceptionInformation[2] = Argument2;
    ExceptionRecord->ExceptionInformation[3] = (ULONG_PTR)Frame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = (ULONG_PTR)Frame->StISR;
}

BOOLEAN
KiIA32ExceptionDivide(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:
    iA-32_Exception(Divide) - fault

    Handle divide error fault.

    Called from iA32_Exception() with 
        ISR.vector : 0

    The divide error fault occurs if a DIV or IDIV instructions is
    executed with a divisor of 0, or if the quotient is too big to
    fit in the result operand.

    An INTEGER DIVIDED BY ZERO exception will be raised for the fault.
    The Faults can only come from user mode.

Arguments:
    Frame - Supply a pointer to an iA32 TrapFrame

Return value:

--*/
{
    // 
    // Setup exception and back to caller
    //

    KiIA32CommonArgs(Frame,
                     Ki386CheckDivideByZeroTrap(Frame),
                     (PVOID) (ULONG_PTR) EIP(Frame),
                     0, 0, 0);
    return TRUE;
}

BOOLEAN
KiIA32ExceptionDebug(
    IN PKTRAP_FRAME Frame
    )
/*++
Routine Description:
    iA-32_Exception(Debug)

    Called from iA32_Exception() with
        ISR.Vector = 1

    Depend on ISR.Code
       0:  It is Code BreakPoint Trap
       TrapCode:  Can be Concurrent Single Step | 
                  Taken Branch | Data BreakPoint Trap
       Handler needs to decode ISR.Code to distinguish
    Note: EFlag isn't saved yet, so write directly to ar.24

Arguments:
    Frame - Supply a pointer to an iA32 TrapFrame

Return Value:
    No return

--*/
{
    ULONGLONG EFlag;

#if defined(IADBG)
    IF_IA32TRAP_DEBUG( DEBUG )
       DbgPrint( "IA32 Debug: Eip %x\n", EIP(Frame) );
#endif // IADBG
    // Turn off the TF bit
    EFlag = __getReg(CV_IA64_AR24);
    EFlag &= ~EFLAGS_TF_BIT;
    __setReg(CV_IA64_AR24, EFlag);

    KiIA32CommonArgs(Frame,
                     STATUS_WX86_SINGLE_STEP,
                     (PVOID) (ULONG_PTR) EIP(Frame),
                     0, 0, 0);
    return TRUE;
}

BOOLEAN
KiIA32ExceptionBreak(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:
    iA-32_Exception(Break) - Trap

    BreakPoint instruction (INT 3) trigged a trap.
    Note: EFlag isn't saved yet, so write directly to ar.24
Arguments:
    Frame - Supply a pointer to an iA32 TrapFrame

Return Value:

--*/
{
    ULONGLONG EFlag;

#if defined(IADBG)
    IF_IA32TRAP_DEBUG( BREAK )
       DbgPrint( "IA32 Break: Eip %x\n", EIP(Frame) );
#endif // IADBG
    // Turn off the TF bit
    EFlag = __getReg(CV_IA64_AR24);
    EFlag &= ~EFLAGS_TF_BIT;
    __setReg(CV_IA64_AR24, EFlag);

    KiIA32CommonArgs(Frame,
                     STATUS_WX86_BREAKPOINT,
                     (PVOID) (ULONG_PTR) EIP(Frame),
                     BREAKPOINT_BREAK,
                     ECX(Frame),
                     EDX(Frame));
    return TRUE;
}

BOOLEAN
KiIA32ExceptionOverflow(
    IN PKTRAP_FRAME Frame
    )
/*++
Routine Description:
    iA-32_Exception(Overflow) - Trap
       ISR.Vector = 4

    Handle INTO overflow

    Eip - point to the address that next to the one causing INTO 

    Occurres when INTO instruction as well as EFlags.OF is ON
    Trap only initiated from user mode

Arguments:
    Frame - Supply a pointer to an iA32 TrapFrame

Return Value:

--*/
{
#if defined(IADBG)
    IF_IA32TRAP_DEBUG( OVERFLOW )
       DbgPrint( "IA32 OverFlow: Eip %x\n", EIP(Frame) );
#endif // IADBG

    //
    // All error, generate exception and Eip point to INTO instruction
    //

    KiIA32CommonArgs(Frame,
                     STATUS_INTEGER_OVERFLOW,
                     (PVOID) (ULONG_PTR) (EIP(Frame) - 1),
                     0, 0, 0);
    return TRUE;
}


BOOLEAN
KiIA32ExceptionBound(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:
    iA-32_Exception(Bound) - Fault
    
    Handle Bound check fault
    ISR.Vector = 5
    Eip - point to BOUND instruction

    The bound check fault occurs if a BOUND instruction finds that
    the tested value is outside the specified range.

    For bound check fault, an ARRAY BOUND EXCEEDED exception will be raised.

Arguments:
    Frame - Supply a pointer to an iA32 TrapFrame

Return Value:

--*/
{
#if defined(IADBG)
    IF_IA32TRAP_DEBUG( BOUND )
       DbgPrint( "IA32 Bound: Eip %x\n", EIP(Frame) );
#endif // IADBG
    //
    // All error, generate exception with Eip point to BOUND instruction
    //
    KiIA32CommonArgs(Frame,
                     STATUS_ARRAY_BOUNDS_EXCEEDED,
                     (PVOID) (ULONG_PTR) EIP(Frame),
                     0, 0, 0);
    return TRUE;
}


ULONG
IA32EmulateSmsw(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:
    
    Emulate the SMSW instruction
    
Arguments:

    Frame:  Pointer to iA32 TrapFrame in the stack

Return Value:
    Exception code

--*/
{
    ULONG Code;
    PUCHAR InstAddr;
    UINT_PTR EffectiveAddress;
    PUSHORT toAddr;             // SMSW deals with 16 bits all the time...
    BOOLEAN RegisterMode;
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Get the code for the prefix bytes that have already been grabbed
    // and placed into the IIM
    //
    Code = ISRCode(Frame);

    //
    // The operand size is always 16 for this instruction. We don't care about
    // overrides as the segment registers all contain the same thing.
    //

    //
    // Find the instruction in memory and point the Effective Address
    // at the byte after the opcode
    // Inst Address is start of ia32 inst + length of prefix + number of
    // bytes in opcode
    //
    InstAddr = (PUCHAR) (Frame->StIIP + ((Code >> 12) & 0xf) + 2);

    if (!KiIa32Compute32BitEffectiveAddress(Frame, &InstAddr, &EffectiveAddress, &RegisterMode)) {
        status = STATUS_ACCESS_VIOLATION;
    }
    
    if (NT_SUCCESS(status)) {
    
        //
        // The adress given to us hasn't been checked for user-space
        // validity, so check it now
        //

        toAddr = (PUSHORT) EffectiveAddress;
    
        try {
            
            //
            // Make sure we can write to the address
            //
            if (RegisterMode == FALSE) {
                ProbeForWriteSmallStructure(toAddr, sizeof(SHORT), 2);
            }
            
            //
            // and do the write
            //

            *toAddr = (SHORT) (__getReg(CV_IA64_AR27) & 0xffff);
        } 
        except (EXCEPTION_EXECUTE_HANDLER) {
            
            //
            // return the exception
            //

            status = GetExceptionCode();
        }

        if (NT_SUCCESS(status)) {
        
            //
            // the store worked, so update the IIP so we can continue
            // executing
            //

            Frame->StIIP = (UINT_PTR) InstAddr;
        }
    }

    return status;
}


ULONG
IA32CheckOpcode(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:
    
    To identify the Opcode violation state
    
Arguments:

    Frame:  Pointer to iA32 TrapFrame in the stack

Return Value:
    Exception code

--*/
{
    ULONG i;
    UCHAR OpCodeByte0;
    UCHAR OpCodeByte1;
    UCHAR OpCodeByte2;
	
	
    OpCodeByte0 = (UCHAR) Frame->StIIM & 0xff;
    OpCodeByte1 = (UCHAR) (Frame->StIIM >> 8) & 0xff;
    OpCodeByte2 = (UCHAR) (Frame->StIIM >> 16) & 0xff;

    switch (OpCodeByte0) {
       case MI_HLT:
            return (STATUS_PRIVILEGED_INSTRUCTION);
            break;

       case MI_TWO_BYTE:
            if ((OpCodeByte1 == MI_SMSW)
                && ((OpCodeByte2 & MI_MODRM_MASK) == MI_SMSW_REGOP)) {
                //
                // We have the SMSW instruction
                // So now need to emulate it...
                //
                return (IA32EmulateSmsw(Frame));
            }
            else if ((OpCodeByte1 == MI_LTR_LLDT) || 
               (OpCodeByte2 == MI_LGDT_LIDT_LMSW)) {

               OpCodeByte2 &= MI_MODRM_MASK;      // get bit 3-5 of ModRM byte

               if (OpCodeByte2==MI_LLDT_MASK || OpCodeByte2==MI_LTR_MASK ||
                   OpCodeByte2==MI_LGDT_MASK || OpCodeByte2==MI_LIDT_MASK || 
                   OpCodeByte2==MI_LMSW_MASK) {
                   return (STATUS_PRIVILEGED_INSTRUCTION);
               } else  {
                   return (STATUS_ACCESS_VIOLATION);
               }

            } else {
                if (OpCodeByte1 & MI_SPECIAL_MOV_MASK) {
                    //
                    // mov may have special_mov_mask
                    // but they are not 2 bytes OpCode
                    //
                    return (STATUS_PRIVILEGED_INSTRUCTION);
                } else {
                    //
                    // Do we need to further check if it is INVD, INVLPG ... ?
                    //
                    return (STATUS_ACCESS_VIOLATION);
                }
            }
            break;

        default:
            //
            // All other 
            //
            return (STATUS_ILLEGAL_INSTRUCTION);
            break;
	}
}

BOOLEAN
KiIA32InterceptInstruction(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:
    iA-32_Exception(InstructionIntercept Opcode)

    Program entry for either
       1. IA-32 Invalid Opcode Fault #6, or
       2. IA-32 interceptions(Inst)

    Execution of unimplemented IA-32 opcodes, illegal opcodes or sensitive 
    privileged IA32 operating system instructions results this interception.

    Possible Opcodes:
        Privileged Opcodes: CLTS, HLT, INVD, INVLPG, LIDT, LMSW, LTR, 
                            mov to/from CRs, DRs
                            RDMSR, RSM, SMSW, WBINVD, WRMSR

Arguments:

    Frame - Supply a pointer to an iA32 TrapFrame

Return Value:

--*/
{
    NTSTATUS status;

#if defined(IADBG)
    IF_IA32TRAP_DEBUG( INSTRUCTION )
       DbgPrint( "IA32 Instruction: Eip %x\n", EIP(Frame) );
#endif // IADBG

    status =  IA32CheckOpcode(Frame);
    switch (status) {
        case STATUS_PRIVILEGED_INSTRUCTION:
            KiIA32CommonArgs(Frame,
                             STATUS_PRIVILEGED_INSTRUCTION,
                             (PVOID) (ULONG_PTR) EIP(Frame),
                             0, 0, 0);
            break;

        case STATUS_ACCESS_VIOLATION:    
            KiIA32CommonArgs(Frame,
                             STATUS_ACCESS_VIOLATION,
                             (PVOID) (ULONG_PTR) EIP(Frame),
                             0, -1, 0);
            break; 

        case STATUS_ILLEGAL_INSTRUCTION:
            KiIA32CommonArgs(Frame,
                             STATUS_ILLEGAL_INSTRUCTION,
                             (PVOID) (ULONG_PTR) EIP(Frame),
                             0, -1, 0);
            break;

        case STATUS_SUCCESS:
            //
            // This means the OpCode was dealt with, so let the code continue
            //
            return FALSE;

        default:
            KiIA32CommonArgs(Frame,
                             status,
                             (PVOID) (ULONG_PTR) EIP(Frame),
                             0, -1, 0);
            break;
    }

    return TRUE;
}

BOOLEAN
KiIA32ExceptionNoDevice(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:

    iA-32_Exception(Coprocessor Not Available) - fault

    This routine is called from iA32_Exception() with
         ISR.Vector = 7

    Note:
        At this time, the AR registers have not been saved. This
        includes, CFLAGS (AR.27), EFLAGS (AR.24), FCR (AR.21),
        FSR (AR.28), FIR (AR.29) and FDR (AR.30).

        Not handling MMX and KNI exceptions yet.

Arguments:

    Frame - iA32 TrapFrame that was saved in the memory stack

Return Value:

--*/
{
    ULONG i;
    ULONG ErrorCode;
    ULONG FirOffset, FdrOffset;
    ULONG FpState[2];
    ULONGLONG FcrRegister, FsrRegister;
	
#if defined(IADBG)
    IF_IA32TRAP_DEBUG( NODEVICE )
       DbgPrint( "IA32 NoDevice: Eip %x\n", EIP(Frame) );
#endif // IADBG

    FcrRegister = __getReg(CV_IA64_AR21);
    FsrRegister = __getReg(CV_IA64_AR28);
    FirOffset = (ULONG) (__getReg(CV_IA64_AR29) & 0xFFFFFFFF);
    FdrOffset = (ULONG) (__getReg(CV_IA64_AR30) & 0xFFFFFFFF);

    //
    // According to the floating error priority, 
    // we test what is the cause of the NPX error 
    // and raise an appropriate exception
    //
    FpState[0] = (ULONG) (~(FcrRegister &
                (FSW_INVALID_OPERATION | FSW_DENORMAL | 
                 FSW_ZERO_DIVIDE | FSW_OVERFLOW | 
                 FSW_UNDERFLOW | FSW_PRECISION)) &
                 (FsrRegister & FSW_ERR_MASK));

    //
    // Now that we have the 387 FP error state, get the Katmai error state
    // The trick here is that the state is in the same registers as the FP
    // state and the bit posisitons are in the same relative location
    // so just need to shift the bits and then do the same 
    //

    FpState[1] = (ULONG) (~((FcrRegister >> KATMAI_SHIFT_CONTROL) &
                (FSW_INVALID_OPERATION | FSW_DENORMAL | 
                 FSW_ZERO_DIVIDE | FSW_OVERFLOW | 
                 FSW_UNDERFLOW | FSW_PRECISION)) & 
                 ((FsrRegister >> KATMAI_SHIFT_STATUS) & FSW_ERR_MASK));

    //
    // Now check for the faults (that the mask says is OK)
    //
    // FpState[0] is 387 faults
    // FpSatte[1] is Katmai faults
    //

    ErrorCode = 0;

    for (i = 0; i < 2; i++) {
        if (FpState[i] & FSW_INVALID_OPERATION) {

            if (FpState[i] & FSW_STACK_FAULT) {
                KiIA32CommonArgs(Frame,
                                 STATUS_FLOAT_STACK_CHECK,
                                 (PVOID) (ULONG_PTR) FirOffset,
                                 0, FdrOffset, 0);
                return TRUE;
            } else {
                KiIA32CommonArgs(Frame,
                                 STATUS_FLOAT_INVALID_OPERATION,
                                 (PVOID) (ULONG_PTR) FirOffset,
                                 0, 0, 0);
                return TRUE;
            }
        
        } else {
    
            if (FpState[i] & FSW_ZERO_DIVIDE) {
                ErrorCode = STATUS_FLOAT_DIVIDE_BY_ZERO; 
                break;
            }
            else if (FpState[i] & FSW_DENORMAL) {
                ErrorCode = STATUS_FLOAT_INVALID_OPERATION; 
                break;
            }
            else if (FpState[i] & FSW_OVERFLOW) {
                ErrorCode = STATUS_FLOAT_OVERFLOW; 
                break;
            }
            else if (FpState[i] & FSW_UNDERFLOW) {
                ErrorCode = STATUS_FLOAT_UNDERFLOW; 
                break;
            }
            else if (FpState[i] & FSW_PRECISION) {
                ErrorCode = STATUS_FLOAT_INEXACT_RESULT; 
                break;
            }
        }
    }

    //
    // If we get here, we either have the error code, or
    // we went through everything and saw nothing
    //
    if (ErrorCode) {
            KiIA32CommonArgs(Frame,
                             ErrorCode,
                             (PVOID) (ULONG_PTR) FirOffset,
                             0, 0, 0);
            return TRUE;
    }

    //
    // FpState[] indicates no error, then something is wrong
    // Panic the system !!!
    //
    // KeBugCheckEx(TRAP_CAUSE_UNKNOWN, (ULONG_PTR)Frame, 0, 0, 2);
    //
    // Turns out there is a bug in the chip and it can cause an fp fault even
    // with a masked fp exception...  So, don't bug check, count it
    // as non-error and reset the fsr.es bit to try and avoid getting this
    // exception in the future.
    //

#if defined(IADBG)
    DbgPrint( "IA32 Debug: Saw FP exception when FP exceptions are masked. Reseting fsr.es bit\n");
#endif // IADBG

    
    FsrRegister &= ~((ULONGLONG) FSW_ERROR_SUMMARY);
    __setReg(CV_IA64_AR28, FsrRegister);

    return FALSE;
}

BOOLEAN
KiIA32ExceptionSegmentNotPresent(
    IN PKTRAP_FRAME Frame
	)
/*++

Routine Description:
    iA-32_Exception(Not Present) - fault

    Handle Segment Not Present fault.
        ISR.Vector = 11

    This exception occurs when the processor finds the P bit 0
    when accessing an otherwise valid descriptor that is not to
    be loaded in SS register.

Arguments:

    Frame - iA32 TrapFrame that was saved in the memory stack

Return Value:

--*/
{
    KIRQL OldIrql;
    USHORT ErrorCode;

#if defined(IADBG)
    IF_IA32TRAP_DEBUG( NOTPRESENT )
       DbgPrint( "IA32 NotPresent: Eip %x\n", EIP(Frame) );
#endif // IADBG

    //
    // Generate Exception for all other errors
    //

    KiIA32CommonArgs(Frame,
                     STATUS_ACCESS_VIOLATION,
                     (PVOID) (ULONG_PTR) EIP(Frame),
                     0, ISRCode(Frame) | RPL_MASK, 0);
    return TRUE;
}

BOOLEAN
KiIA32ExceptionStack(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:
    iA-32_Exception(Stack) - fault

    ISR.Vector = 12

    This exception occurs when the processor detects certain problem
    with the segment addressed by the SS segment register:

    1. A limit violation in the segment addressed by the SS (error
       code = 0)
    2. A limit vioalation in the inner stack during an interlevel
       call or interrupt (error code = selector for the inner stack)
    3. If the descriptor to be loaded into SS has its present bit 0
       (error code = selector for the not-present segment)

    The exception only occurred from user mode

Arguments:

    Frame - iA32 TrapFrame that was saved in the memory stack

Return Value:

--*/
{
    USHORT Code;

#if defined(IADBG)
    IF_IA32TRAP_DEBUG( STACK )
       DbgPrint( "IA32 Stack: Eip %x\n", EIP(Frame) );
#endif // IADBG

    //
    // Dispatch Exception to user
    //
   
    Code = ISRCode(Frame);

    //
    // Code may contain the faulting selector
    //
    KiIA32CommonArgs(Frame,
                     STATUS_ACCESS_VIOLATION,
                     (PVOID) (ULONG_PTR) EIP(Frame),
                      Code ? (Code | RPL_MASK) :  ESP(Frame),
                      Code ? EXCEPT_UNKNOWN_ACCESS : EXCEPT_LIMIT_ACCESS,
                      0);
    return TRUE;
}

BOOLEAN
KiIA32ExceptionInvalidOp(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:
    iA-32_Exception(Invalid Opcode) - fault

    PKTRAP_FRAME Frame
	   Eip	: virtual iA-32 instruction address
	   ISR.vector : 6

    Note: 
        Only MMX and KNI instructions can cause this fault based
        on values in CR0 and CR4

Arguments:

    Frame - iA32 TrapFrame that was saved in the memory stack

Return Value:
--*/
{
#if defined(IADBG)
    IF_IA32TRAP_DEBUG( INSTRUCTION )
       DbgPrint( "IA32 Invalid Opcode: Eip %x\n", EIP(Frame) );
#endif // IADBG

    KiIA32CommonArgs(Frame,
        STATUS_ILLEGAL_INSTRUCTION,
        (PVOID) (ULONG_PTR) EIP(Frame),
        0, 0, 0);
    return TRUE;
}

BOOLEAN
KiIA32ExceptionGPFault(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:
    iA-32_Exception(General Protection) - fault

    PKTRAP_FRAME Frame
	   Eip	: virtual iA-32 instruction address
	   ISR.vector : 13
	   ISR.code   : ErrorCode

    Note: 
        Previlidged instructions are intercepted, 
           see KiIA32InterceptInstruction

Arguments:

    Frame - iA32 TrapFrame that was saved in the memory stack

Return Value:

--*/
{
    UCHAR OpCode;
    NTSTATUS Status;

#if defined(IADBG)
    IF_IA32TRAP_DEBUG( GPFAULT )
       DbgPrint( "IA32 GpFault: Eip %x\n", EIP(Frame) );
#endif // IADBG

    try {
        ProbeForReadSmallStructure((VOID *)Frame->StIIP, sizeof(UCHAR), sizeof(UCHAR));
        OpCode = *(UCHAR *)Frame->StIIP;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        OpCode = 0xcc;
    }
    // This table comes from the IOInstructionTable in i386\trap.asm
    switch (OpCode) {
    case CLI_OP:
    case STI_OP:
    case 0xe4: case 0xe5: case 0xec: case 0xed:     // IN
    case 0x6c: case 0x6d:                           // INS
    case 0xe6: case 0xe7: case 0xee: case 0xef:     // OUT
    case 0x6e: case 0x6f:                           // OUTS
        Status = STATUS_PRIVILEGED_INSTRUCTION;
        break;

    default:
        Status = STATUS_ACCESS_VIOLATION;
        break;
    }

    
    KiIA32CommonArgs(Frame,
                     Status,
                     (PVOID) (ULONG_PTR) EIP(Frame),
                     0, 0, 0);
    return TRUE;
}



BOOLEAN
KiIA32ExceptionKNI(
    IN PKTRAP_FRAME Frame
    )
/*++

iA32_Exception(KNI) - Fault

   Unmasked KNI IA32 Error.
   ISR.Vector = 19

--*/
{
#if defined(IADBG)
    IF_IA32TRAP_DEBUG( FPFAULT )
       DbgPrint( "IA32 KNI Fault: Eip %x\n", EIP(Frame) );
#endif // IADBG
    return(KiIA32ExceptionNoDevice(Frame));
}


BOOLEAN
KiIA32ExceptionFPFault(
    IN PKTRAP_FRAME Frame
    )
/*++

iA32_Exception(Floating Point) - Fault

   Handle Coprocessor Error.
   ISR.Vector = 16

   This exception is used on 486 or above only.  For i386, it uses
   IRQ 13 instead. 
 
   JMPE instruction should flush all FP delayed exception, and the traps 
   will goto Device Not Available trap

--*/
{
#if defined(IADBG)
    IF_IA32TRAP_DEBUG( FPFAULT )
       DbgPrint( "IA32 FpFault: Eip %x\n", EIP(Frame) );
#endif // IADBG
    return(KiIA32ExceptionNoDevice(Frame));
}


BOOLEAN
KiIA32ExceptionAlignmentFault(
    IN PKTRAP_FRAME Frame
    )
/*++

iA32_Exception(Alignment Check) - fault

   Handle alignment faults.
   ISR.Vector = 17

   This exception occurs when an unaligned data access is made by a thread
   with alignment checking turned on.

   This fault occurred when unaligned access on EM PSR.AC is ON
   Note that iA32 EFLAFS.AC, CR0.AM and CPL!=3 does not unmask the fault.

   So, for now, let the ia64 alignment handler handle this...

--*/
{
    PPSR IntPSR;

#if defined(IADBG)
    IF_IA32TRAP_DEBUG( ALIGNMENT )
       DbgPrint( "IA32 Alignment: Eip %x\n", EIP(Frame) );
#endif // IADBG

    //
    // Win32 x86 apps don't expect any alignment faults, so
    // let's mask them out.
    //
    IntPSR = (PPSR)&Frame->StIPSR;
    IntPSR->sb.psr_ac = 0;

    return FALSE;
}


BOOLEAN
KiIA32InterruptVector(
    IN PKTRAP_FRAME Frame
    )
/*++

iA32_Interrupt(Vector #) - trap

   Handle INTnn trap

   Under EM system mode, iA32 INT instruction forces a mandatory iA-32 
   interrupt trap through iA-32 Interrupt(SoftWare Interrupt)

--*/
{
#if defined(IADBG)
    IF_IA32TRAP_DEBUG( INTNN )
       DbgPrint( "IA32 Intnn: Eip %x INT 0x%xH\n", EIP(Frame), ISRVector(Frame));
#endif // IADBG
    KiIA32CommonArgs(Frame,
        STATUS_PRIVILEGED_INSTRUCTION,
        (PVOID) (ULONG_PTR) EIP(Frame),
        0, 0, 0);
    return TRUE;
}


BOOLEAN
KiIA32InterceptGate(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:

    iA32_Intercept(Gate) - trap

    If an iA32 control transfer is initiated through a GDT or LDT descriptor
    that results in an either a promotion of privilege level (interlevel Call
    or Jump Gate and IRET) or an iA32 task switch (TSS segment or Gate), 
    the intercept trap is generated.

    Possible instructions intercepted:
        CALL, RET, IRET, IRETD and JMP

    Handling
        No CaLL, RET, JMP, IRET, IRETD are allowed in any mode, 
           STATUS_ACCESS_VIOLATION is returned

Arguments:
    Frame - iA32 TrapFrame that was saved in the memory stack

Return Value:

--*/
{
#if defined(IADBG)
    IF_IA32TRAP_DEBUG( GATE )
       DbgPrint( "IA32 Gate: Eip %x GateSelector %x OpcodeId %x\n",
                 EIP(Frame),
                 (ULONG) (Frame->StIFA & 0xff),
                 (ULONG) (ISRCode(Frame) >> 14));
#endif // IADBG

    //
    // all error fall through here
    //
    KiIA32CommonArgs(Frame,
        STATUS_ILLEGAL_INSTRUCTION,
        (PVOID) (ULONG_PTR) EIP(Frame),
        0, 0, 0);
    return TRUE;
}

/*++

iA32_intercept(System Flag) - trap

   Possible Causes:
	1. if CFLAG.ii==1 and EFLAG.if changes state
	2. Generated after either EFLAG.ac, tf or rf changes state
	   if no IOPL or CPL to modify bits then no interception.
	3. if CFLG.nm==1 then successful execution of IRET also intercepted

   Possible instructions:
       CLI, POPF, POFD, STI and IRET

   Currently, we set both CFLAG.ii and nm to 0, so that we will only possiblly 
   get case #2.  But in EM/NT, it should always come from user land which
   we hard-set EFLAG.IOPL to 0, so there if we do get case #2, then it is user
   play around EFLAG.IOPL through JMPE.  We should fail it.

--*/

BOOLEAN
KiIA32InterceptSystemFlag(
    IN PKTRAP_FRAME Frame
    )
{
    NTSTATUS NtStatus;
#if defined(IADBG)
    IF_IA32TRAP_DEBUG( FLAG )
       DbgPrint( "IA32 FLAG: Eip %x Old EFlag: %x OpcodeId %x\n", 
                 EIP(Frame),
                 (ULONG) (Frame->StIIM & 0xff),
                 (ULONG) (ISRCode(Frame) >> 14));
#endif // IADBG

    //
    // Don't trap on POPF/POPFD instructions from ia32 code.
    // Allow Eflags.TF and/or Eflags.AC to be changed.
    //
    if ((ISRCode(Frame) >> 14) == 2)
    {
        return FALSE;
    }

    //
    // Validate the instruction.
    //
    NtStatus = KiIa32ValidateInstruction (Frame);

    if (NT_SUCCESS (NtStatus))
    {
        return FALSE;
    }

    KiIA32CommonArgs(
        Frame,
        NtStatus,        
        (PVOID) (ULONG_PTR) EIP(Frame),
        0, 0, 0);

    return TRUE;
}


BOOLEAN
KiIA32InterceptLock(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:
    iA32_Intercept(Lock) - trap

    Lock intercepts occurred if platform or firmware code has disabled locked
    transactions and atomic memory update requires a processor external 
    indication

Arguments:
    Frame - Point to iA32 TrapFrame

Return:

--*/
{
    NTSTATUS NtStatus;

#if defined(IADBG)
    IF_IA32TRAP_DEBUG( LOCK )
       DbgPrint( "IA32 LOCK: Eip %x\n", EIP(Frame) );
#endif // IADBG

    //
    // Emulate the lock prefix
    //

    NtStatus = KiIa32InterceptUnalignedLock (Frame);
    
    if (!NT_SUCCESS (NtStatus)) {
        
        KiIA32CommonArgs(
            Frame,
            NtStatus,
            (PVOID) (ULONG_PTR) EIP(Frame),
            0, 
            0, 
            0
            );
    }

    return (!NT_SUCCESS (NtStatus));
}

BOOLEAN
KiIA32ExceptionPanic(
    IN PKTRAP_FRAME Frame
    )
{
    //
    // Panic the system 
    //

    KeBugCheckEx(TRAP_CAUSE_UNKNOWN, 
                 (ULONG_PTR)Frame, 
                 ISRVector(Frame), 
                 0, 0);
    // Should never get here...
    return FALSE;
}
    


CONST BOOLEAN (*KiIA32ExceptionDispatchTable[])(PKTRAP_FRAME) = {
    KiIA32ExceptionDivide,
    KiIA32ExceptionDebug,
    KiIA32ExceptionPanic,
    KiIA32ExceptionBreak,
    KiIA32ExceptionOverflow,
    KiIA32ExceptionBound,
    KiIA32ExceptionInvalidOp,
    KiIA32ExceptionNoDevice,
    KiIA32ExceptionPanic,
    KiIA32ExceptionPanic,
    KiIA32ExceptionPanic,
    KiIA32ExceptionSegmentNotPresent,
    KiIA32ExceptionStack,
    KiIA32ExceptionGPFault,
    KiIA32ExceptionPanic,
    KiIA32ExceptionPanic,
    KiIA32ExceptionFPFault,
    KiIA32ExceptionAlignmentFault,
    KiIA32ExceptionPanic,
    KiIA32ExceptionKNI
};

CONST BOOLEAN (*KiIA32InterceptionDispatchTable[])(PKTRAP_FRAME) = {
    KiIA32InterceptInstruction,
    KiIA32InterceptGate,
    KiIA32InterceptSystemFlag,
    KiIA32ExceptionPanic,
    KiIA32InterceptLock
};

BOOLEAN
KiIA32InterceptionVectorHandler(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:

    KiIA32InterceptionVectorHandler

    Called by first label KiIA32InterceptionVector() to handle further iA32 
    interception processing.
   
Arguments:

    Frame - iA32 TrapFrame that was saved in the memory stack

Return Value:
    TRUE - go to dispatch exception
    FALSE - Exception was handled, do an RFI

--*/
{
#if defined(IADBG)
    IF_IA32TRAP_DEBUG( INTERCEPTION )
       DbgPrint("IA32 Interception: ISRVector %x Frame %x\n", ISRVector(Frame), Frame);
#endif // IADBG

    ASSERT(UserMode == Frame->PreviousMode);

    //
    // Make sure we have an entry in the table for this interception
    //
    if (ISRVector(Frame) <= (sizeof(KiIA32InterceptionDispatchTable) / sizeof(PVOID))) 
        return (*KiIA32InterceptionDispatchTable[ISRVector(Frame)])(Frame);
    else
        return (KiIA32ExceptionPanic(Frame));
}

BOOLEAN
KiIA32ExceptionVectorHandler(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:

    KiIA32ExceptionVectorHandler

    Called by first label KiIA32ExceptionVector() to handle further iA32 
    interception processing.
   
Arguments:

    Frame - iA32 TrapFrame that was saved in the memory stack

Return Value:
    TRUE - go to dispatch exception
    FALSE - Exception was handled, do an RFI

--*/
{
#if defined(IADBG)
    IF_IA32TRAP_DEBUG( EXCEPTION )
       DbgPrint("IA32 Exception: ISRVector %x Frame %x\n", ISRVector(Frame), Frame);
#endif // IADBG

    ASSERT(UserMode == Frame->PreviousMode);
    //
    // Make sure we have an entry in the table for this exception
    //
    if (ISRVector(Frame) <= (sizeof(KiIA32ExceptionDispatchTable) / sizeof(PVOID))) 
        return (*KiIA32ExceptionDispatchTable[ISRVector(Frame)])(Frame);
    else
        return(KiIA32ExceptionPanic(Frame));
}

BOOLEAN
KiIA32InterruptionVectorHandler(
    IN PKTRAP_FRAME Frame
    )
/*++

Routine Description:

    KiIA32InterruptionVectorHandler

    Called by first label KiIA32InterruptionVector() to handle further iA32 
    interruption processing. Only get here on INT xx instructions
   
Arguments:

    Frame - iA32 TrapFrame that was saved in the memory stack

Return Value:
    TRUE - go to dispatch exception
    FALSE - Exception was handled, do an RFI

--*/
{
#if defined(IADBG)
    IF_IA32TRAP_DEBUG( INTERRUPT )
       DbgPrint("IA32 Interruption: ISRVector %x Frame %x\n", ISRVector(Frame), Frame);
#endif // IADBG

    ASSERT(UserMode == Frame->PreviousMode);

    //
    // Follow the ia32 way of INT xx as an Access Violation
    //
    // INT 3 should be handled via a debug exception and should
    // never get here...
    //
    ASSERT(3 != ISRVector(Frame));
    
    KiIA32CommonArgs(Frame,
                     STATUS_ACCESS_VIOLATION,
                     (PVOID) (ULONG_PTR) EIP(Frame),
                     0, 0, 0);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\initkr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    initkr.c

Abstract:

    This module contains the code to initialize the kernel data structures
    and to initialize the idle thread, its process, and the processor control
    block.

Author:

    Bernard Lint 8-Aug-1996

Environment:

    Kernel mode only.

Revision History:

    Based on MIPS version (David N. Cutler (davec) 11-Apr-1990)
--*/

#include "ki.h"


//
// Put all code for kernel initialization in the INIT section. It will be
// deallocated by memory management when phase 1 initialization is completed.
//

VOID
KiInitializeProcessorIds(
   IN PKPRCB Prcb
   );

ULONG
KiGetFeatureBits(
   IN  PKPRCB Prcb
   );

VOID
FASTCALL
KiZeroPage (
    PVOID PageBase
    );

#if defined(ALLOC_PRAGMA)

#pragma alloc_text(INIT, KiGetFeatureBits)
#pragma alloc_text(INIT, KiInitializeProcessorIds)
#pragma alloc_text(INIT, KiInitializeKernel)
#pragma alloc_text(INIT, KiInitMachineDependent)

#endif

KE_ZERO_PAGE_ROUTINE KeZeroPage = KiZeroPage;
KE_ZERO_PAGE_ROUTINE KeZeroPageFromIdleThread = KiZeroPage;

//
// KiTbBroadcastLock - This is the spin lock that prevents the other processors
// from issuing PTC.G (TB purge broadcast) operations.
//

KSPIN_LOCK KiTbBroadcastLock;

//
// KiMasterRidLock - This is the spin lock that prevents the other processors
// from updating KiMasterRid.
//

KSPIN_LOCK KiMasterRidLock;

//
// KiCacheFlushLock - This is the spin lock that ensures cache flush is only
// done on one processor at a time. (SAL cache flush not yet MP safe).
//

KSPIN_LOCK KiCacheFlushLock;

//
// KiUserSharedDataPage - This holds the page number of UserSharedDataPage for
// MP boot
//

ULONG_PTR KiUserSharedDataPage;

//
// KiKernelPcrPage - This holds the page number of per-processor PCR page for
// MP boot
//

ULONG_PTR KiKernelPcrPage = 0i64;

//
// VHPT configuation variables
//

IA64_VM_SUMMARY1 KiIA64VmSummary1;
IA64_VM_SUMMARY2 KiIA64VmSummary2;
IA64_PTCE_INFO KiIA64PtceInfo;
ULONG_PTR KiIA64PtaContents;
ULONG_PTR KiIA64PtaHpwEnabled = 1;
ULONG_PTR KiIA64VaSign;
ULONG_PTR KiIA64VaSignedFill;
ULONG_PTR KiIA64PtaBase;
ULONG_PTR KiIA64PtaSign;
ULONG KiIA64ImpVirtualMsb;
extern ULONG KiMaximumRid;

//
// KiExceptionDeferralMode - This holds the mode for the exception deferral
//  policy
//

ULONG KiExceptionDeferralMode;

//
// Initial DCR value
//

ULONGLONG KiIA64DCR = DCR_INITIAL;

//
// KiVectorLogMask - bitmap for enable/disable the interruption logging
//

LONGLONG KiVectorLogMask;


ULONG
KiGetFeatureBits(
   PKPRCB Prcb
   )
/*++

  Routine Description:

      This function returns the NT Feature Bits supported by the specified
      processor control block.

  Arguments:

      Prcb - Supplies a pointer to a processor control block for the specified
             processor.

  Return Value:

      None.

  Comments:

      This function is called after the initialization of the IA64 processor
      control block ProcessorFeatureBits field and after HalInitializeProcessor().

--*/

{
    // WARNING: NT system wide feature bits is a 32-bit type.
    ULONG features = (ULONG) Prcb->ProcessorFeatureBits;

    //
    // Check for Long Branch instruction support.
    //

    if ( features & 0x1 )  {
       features |= KF_BRL;
    }

    return features;

} // KiGetFeatureBits()



VOID
KiInitializeProcessorIds(
    IN PKPRCB Prcb
    )
/*++

Routine Description:

    This function is called early in the initialization of the kernel
    to initialize the processor indentification registers located
    in the processor control block.
    This function is called for each processor and should be called b
    before the HAL is called.

Arguments:

    Prcb - Supplies a pointer to a processor control block for the specified
           processor.

Return Value:

    None.

Comments:

    This function simply deals with IA64 architected CPUID registers.

--*/

{
    ULONGLONG val;

    // IA64 architected CPUID3: Version information.
    // BUGBUG - thierry 02/01/00.
    // NT!Ke and NT!Config are expecting non-zeroed processor model and revision.
    // The current A* steppings have these values zeroed.
    // Increment these values by 1, until we are getting B steppings.

    val = __getReg( CV_IA64_CPUID3 );
    Prcb->ProcessorModel    = (ULONG)(((val >> 16) & 0xFF) + 1);
    Prcb->ProcessorRevision = (ULONG)(((val >> 8 ) & 0xFF) + 1);
    Prcb->ProcessorFamily   = (ULONG) ((val >> 24) & 0xFF);
    Prcb->ProcessorArchRev  = (ULONG) ((val >> 32) & 0xFF);

    // IA64 architected CPUID0 & CPUID1: Vendor Information.

    val = __getReg( CV_IA64_CPUID0 );
    strncpy(  Prcb->ProcessorVendorString   , (PUCHAR)&val, 8 );
    val = __getReg( CV_IA64_CPUID1 );
    strncpy( &Prcb->ProcessorVendorString[8], (PUCHAR)&val, 8 );

    // IA64 architected CPUID2: Processor Serial Number.

    Prcb->ProcessorSerialNumber = __getReg( CV_IA64_CPUID2 );

    // IA64 architected CPUID4: General Features / Capability bits.

    Prcb->ProcessorFeatureBits = __getReg( CV_IA64_CPUID4 );

    return;

} // KiInitializeProcessorIds()

#if defined(_MERCED_A0_)
VOID
KiProcessorWorkAround(
    );

VOID
KiSwitchToLogVector(
    VOID
     );

extern BOOLEAN KiIpiTbShootdown;

ULONGLONG KiConfigFlag;

//
// Process the boot loader configuration flags.
//

VOID
KiProcessorConfigFlag(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    PUCHAR ConfigFlag;
    ULONG ConfigFlagValue=0;
    ULONGLONG Cpuid3;
    ULONGLONG ItaniumId;

    Cpuid3 = __getReg( CV_IA64_CPUID3 );

    ConfigFlag = strstr(LoaderBlock->LoadOptions, "CONFIGFLAG");
    if (ConfigFlag != NULL) {

        ConfigFlag = strstr(ConfigFlag, "=");
        if (ConfigFlag != NULL) {
            ConfigFlagValue = atol(ConfigFlag+1);
        }

    } else {

        //
        // Set the recommened ConfigFlagValue for Itanium, B1/B2
        // if there is no CONFIGFLAG keyword
        //

        ItaniumId = 0xFFFFFF0000I64 & Cpuid3;

        if (ItaniumId == 0x0007000000) {

            switch (Cpuid3) {
            case 0x0007000004: // Itanium, A stepping
            case 0x0007000104: // Itanium, B0 stepping
                ConfigFlagValue = 0;
                break;
            case 0x0007000204: // Itanium, B1 stepping
            case 0x0007000304: // Itanium, B2 stepping
                ConfigFlagValue = 1054;
                break;
            case 0x0007000404: // Itanium, B3 stepping
            case 0x0007000504: // Itanium, B4 stepping
                ConfigFlagValue = 19070;
                break;
            case 0x0007000604: // Itanium, C0 or later stepping
                ConfigFlagValue = 11135;
                break;
            default:
                ConfigFlagValue = 43903;            
            }
        }
    }

    //
    // Save config flag value.
    //

    KiConfigFlag = ConfigFlagValue;

    //
    // do the processor MSR workarounds
    //

    KiProcessorWorkAround(ConfigFlagValue);

    //
    // For Conditional Interrupt Logging
    // switch to shadow IVT depending on ConfigFlag
    //

    if (ConfigFlagValue & (1 << DISABLE_INTERRUPTION_LOG)) {
        KiVectorLogMask = 0;
    } else {

        //
        // By default disable logging of:
        //  KiAltInstTlbVectorBit 3
        //  KiAltDataTlbVectorBit 4
        //

        KiVectorLogMask = 0xffffffffffffffffI64;
        KiSwitchToLogVector();
    }

    //
    // check to see if the VHPT walker should be disabled
    //

    if (ConfigFlagValue & (1 << DISABLE_VHPT_WALKER)) {
        KiIA64PtaHpwEnabled = 0;
    }

}
#endif


VOID
KiInitializeKernel (
    IN PKPROCESS Process,
    IN PKTHREAD Thread,
    IN PVOID IdleStack,
    IN PKPRCB Prcb,
    IN CCHAR Number,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function gains control after the system has been bootstrapped and
    before the system has been initialized. Its function is to initialize
    the kernel data structures, initialize the idle thread and process objects,
    initialize the processor control block, call the executive initialization
    routine, and then return to the system startup routine. This routine is
    also called to initialize the processor specific structures when a new
    processor is brought on line.

Arguments:

    Process - Supplies a pointer to a control object of type process for
        the specified processor.

    Thread - Supplies a pointer to a dispatcher object of type thread for
        the specified processor.

    IdleStack - Supplies a pointer the base of the real kernel stack for
        idle thread on the specified processor.

    Prcb - Supplies a pointer to a processor control block for the specified
        processor.

    Number - Supplies the number of the processor that is being
        initialized.

    LoaderBlock - Supplies a pointer to the loader parameter block.

Return Value:

    None.

--*/

{
    LONG Index;
    KIRQL OldIrql;
    ULONG featureBits;
    ULONG_PTR DirectoryTableBase[2];

#if defined(_MERCED_A0_)
    KiProcessorConfigFlag(LoaderBlock);
#endif

    //
    // Perform Processor Identification Registers update.
    //
    // This has to be done before HalInitializeProcessor to offer
    // a possibility for the HAL to look at them.
    //

    KiInitializeProcessorIds( Prcb );

    //
    // Perform platform dependent processor initialization.
    //

    HalInitializeProcessor(Number, LoaderBlock);

    //
    // Save the address of the loader parameter block.
    //

    KeLoaderBlock = LoaderBlock;

    //
    // Initialize the processor block.
    //

    Prcb->MinorVersion = PRCB_MINOR_VERSION;
    Prcb->MajorVersion = PRCB_MAJOR_VERSION;
    Prcb->BuildType = 0;

#if DBG

    Prcb->BuildType |= PRCB_BUILD_DEBUG;

#endif

#if defined(NT_UP)

    Prcb->BuildType |= PRCB_BUILD_UNIPROCESSOR;

#endif

    Prcb->CurrentThread = Thread;
    Prcb->NextThread = (PKTHREAD)NULL;
    Prcb->IdleThread = Thread;
    Prcb->Number = Number;
    Prcb->SetMember = AFFINITY_MASK(Number);
    Prcb->PcrPage = LoaderBlock->u.Ia64.PcrPage;

    //
    // initialize the per processor lock queue entry for implemented locks.
    //

    KiInitQueuedSpinLocks(Prcb, Number);

    //
    // Initialize the interprocessor communication packet.
    //

#if !defined(NT_UP)

    Prcb->TargetSet = 0;
    Prcb->WorkerRoutine = NULL;
    Prcb->RequestSummary = 0;
    Prcb->IpiFrozen = 0;

#if NT_INST

    Prcb->IpiCounts = &KiIpiCounts[Number];

#endif

#endif

    Prcb->MaximumDpcQueueDepth = KiMaximumDpcQueueDepth;
    Prcb->MinimumDpcRate = KiMinimumDpcRate;
    Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;

    //
    // Initialize DPC listhead and lock.
    //

    InitializeListHead(&Prcb->DpcListHead);
    KeInitializeSpinLock(&Prcb->DpcLock);

    //
    // Set address of processor block.
    //

    KiProcessorBlock[Number] = Prcb;

    //
    // Initialize processors PowerState
    //

    PoInitializePrcb (Prcb);

    //
    // Set global processor architecture, level and revision.  The
    // latter two are the least common denominator on an MP system.
    //

    KeProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;

    if ((KeProcessorLevel == 0) ||
        (KeProcessorLevel > (USHORT) Prcb->ProcessorModel)) {
        KeProcessorLevel = (USHORT) Prcb->ProcessorModel;
    }

    if ((KeProcessorRevision == 0) ||
        (KeProcessorRevision > (USHORT) Prcb->ProcessorRevision)) {
        KeProcessorRevision = (USHORT) Prcb->ProcessorRevision;
    }

    //
    // Initialize the address of the bus error routines / machine check
    //
    // **** TBD

    //
    // Initialize the idle thread initial kernel stack and limit address value.
    //

    PCR->InitialStack = (ULONGLONG)IdleStack;
    PCR->InitialBStore = (ULONGLONG)IdleStack;
    PCR->StackLimit = (ULONGLONG)((ULONG_PTR)IdleStack - KERNEL_STACK_SIZE);
    PCR->BStoreLimit = (ULONGLONG)((ULONG_PTR)IdleStack + KERNEL_BSTORE_SIZE);

    //
    //  Initialize pointers to the SAL event resource structures.
    //

    PCR->OsMcaResourcePtr = (PSAL_EVENT_RESOURCES) &PCR->OsMcaResource;
    PCR->OsInitResourcePtr = (PSAL_EVENT_RESOURCES) &PCR->OsInitResource;

    //
    // Initialize all interrupt vectors to transfer control to the unexpected
    // interrupt routine.
    //
    // N.B. This interrupt object is never actually "connected" to an interrupt
    //      vector via KeConnectInterrupt. It is initialized and then connected
    //      by simply storing the address of the dispatch code in the interrupt
    //      vector.
    //

    if (Number == 0) {

        //
        // Set default node.  Used in non-multinode systems and in
        // multinode systems until the node topology is available.
        //

        extern KNODE KiNode0;

        KeNodeBlock[0] = &KiNode0;

#if defined(KE_MULTINODE)

        for (Index = 1; Index < MAXIMUM_CCNUMA_NODES; Index++) {

            extern KNODE KiNodeInit[];

            //
            // Set temporary node.
            //

            KeNodeBlock[Index] = &KiNodeInit[Index];
        }

#endif

        Prcb->ParentNode = KeNodeBlock[0];
        KeNodeBlock[0]->ProcessorMask = Prcb->SetMember;

        //
        // Initialize system wide FeatureBits with BSP processor feature bits.
        //

        KeFeatureBits = KiGetFeatureBits( Prcb ) ;

        //
        // Initialize the Tb Broadcast spinlock.
        //

        KeInitializeSpinLock(&KiTbBroadcastLock);

        //
        // Initialize the Master Rid spinlock.
        //

        KeInitializeSpinLock(&KiMasterRidLock);

        //
        // Initialize the cache flush spinlock.
        //

        KeInitializeSpinLock(&KiCacheFlushLock);

        //
        // Initial the address of the interrupt dispatch routine.
        //

        KxUnexpectedInterrupt.DispatchAddress = KiUnexpectedInterrupt;

        //
        // Copy the interrupt dispatch function descriptor into the interrupt
        // object.
        //

        for (Index = 0; Index < DISPATCH_LENGTH; Index += 1) {
            KxUnexpectedInterrupt.DispatchCode[Index] =
                *(((PULONG)(KxUnexpectedInterrupt.DispatchAddress))+Index);
        }

        //
        // Set the default DMA I/O coherency attributes.  IA64
        // architecture dictates that the D-Cache is fully coherent.
        //

        KiDmaIoCoherency = DMA_READ_DCACHE_INVALIDATE | DMA_WRITE_DCACHE_SNOOP;

        //
        // Set KiSharedUserData for MP boot
        //

        KiUserSharedDataPage = LoaderBlock->u.Ia64.PcrPage2;

        //
        // Get implementatoin specific VM info
        //

        KiIA64VmSummary1 = LoaderBlock->u.Ia64.ProcessorConfigInfo.VmSummaryInfo1;
        KiIA64VmSummary2 = LoaderBlock->u.Ia64.ProcessorConfigInfo.VmSummaryInfo2;
        KiIA64PtceInfo = LoaderBlock->u.Ia64.ProcessorConfigInfo.PtceInfo;
        KiMaximumRid = ((ULONG)1 << KiIA64VmSummary2.RidSize) - 1;

        //
        // Initialize the VHPT variables
        //

        KiIA64ImpVirtualMsb = (ULONG)KiIA64VmSummary2.ImplVaMsb;
        KiIA64VaSign = (ULONGLONG)1 << KiIA64ImpVirtualMsb;
        KiIA64PtaSign = KiIA64VaSign >> (PAGE_SHIFT - PTE_SHIFT);
        KiIA64VaSignedFill =
            (ULONGLONG)((LONGLONG)VRN_MASK >> (60-KiIA64ImpVirtualMsb)) & ~VRN_MASK;
        KiIA64PtaBase =
            (ULONGLONG)((LONGLONG)(VRN_MASK|KiIA64VaSignedFill)
                        >> (PAGE_SHIFT - PTE_SHIFT)) & ~VRN_MASK;

        KiIA64PtaContents =
            KiIA64PtaBase |
            ((KiIA64ImpVirtualMsb - PAGE_SHIFT + PTE_SHIFT + 1) <<  PS_SHIFT) |
            KiIA64PtaHpwEnabled;

        //
        // enable the VHPT
        //

        __setReg(CV_IA64_ApPTA, KiIA64PtaContents);
        __isrlz();

        //
        // Set up the NT page base addresses
        //

        PCR->PteUbase = UADDRESS_BASE | KiIA64PtaBase;
        PCR->PteKbase = KADDRESS_BASE | KiIA64PtaBase;
        PCR->PteSbase = SADDRESS_BASE | KiIA64PtaBase;
        PCR->PdeUbase = PCR->PteUbase | (PCR->PteUbase >> (PTI_SHIFT-PTE_SHIFT));
        PCR->PdeKbase = PCR->PteKbase | (PCR->PteKbase >> (PTI_SHIFT-PTE_SHIFT));
        PCR->PdeSbase = PCR->PteSbase | (PCR->PteSbase >> (PTI_SHIFT-PTE_SHIFT));
        PCR->PdeUtbase = PCR->PteUbase | (PCR->PdeUbase >> (PTI_SHIFT-PTE_SHIFT));
        PCR->PdeKtbase = PCR->PteKbase | (PCR->PdeKbase >> (PTI_SHIFT-PTE_SHIFT));
        PCR->PdeStbase = PCR->PteSbase | (PCR->PdeSbase >> (PTI_SHIFT-PTE_SHIFT));

    }
    else   {

        //
        // Mask off feature bits that are not supported on all processors.
        //

        KeFeatureBits &= KiGetFeatureBits( Prcb );

    }

    //
    // Point to UnexpectedInterrupt function pointer
    //

    for (Index = 0; Index < MAXIMUM_VECTOR; Index += 1) {
        PCR->InterruptRoutine[Index] =
                    (PKINTERRUPT_ROUTINE)(&KxUnexpectedInterrupt.DispatchCode);
    }

    //
    // Initialize the profile count and interval.
    //

    PCR->ProfileCount = 0;
    PCR->ProfileInterval = 0x200000;

    //
    // Initialize the passive release, APC, and DPC interrupt vectors.
    //

    PCR->InterruptRoutine[0] = KiPassiveRelease;
    PCR->InterruptRoutine[APC_VECTOR] = KiApcInterrupt;
    PCR->InterruptRoutine[DISPATCH_VECTOR] = KiDispatchInterrupt;

    //
    // N.B. Reserve levels, not vectors
    //

    PCR->ReservedVectors = (1 << PASSIVE_LEVEL) | (1 << APC_LEVEL) | (1 << DISPATCH_LEVEL);

    //
    // Initialize the set member for the current processor, set IRQL to
    // APC_LEVEL, and set the processor number.
    //

    KeLowerIrql(APC_LEVEL);
    PCR->SetMember = AFFINITY_MASK(Number);
    PCR->NotMember = ~PCR->SetMember;
    PCR->Number = Number;

    //
    // Set the initial stall execution scale factor. This value will be
    // recomputed later by the HAL.
    //

    PCR->StallScaleFactor = 50;

    //
    // Set address of process object in thread object.
    //

    Thread->ApcState.Process = Process;
    PCR->Pcb = (PVOID)Process;

    //
    // Initialize the idle process region id.  Session ids are initialized
    // in memory management.
    //

    Process->ProcessRegion.RegionId = START_PROCESS_RID;
    Process->ProcessRegion.SequenceNumber = START_SEQUENCE;

    //
    // Set the appropriate member in the active processors set.
    //

    KeActiveProcessors |= AFFINITY_MASK(Number);

    //
    // Set the number of processors based on the maximum of the current
    // number of processors and the current processor number.
    //

    if ((Number + 1) > KeNumberProcessors) {
        KeNumberProcessors = (CCHAR)(Number + 1);
    }

    //
    // If the initial processor is being initialized, then initialize the
    // per system data structures.
    //

    if (Number == 0) {

        Prcb->RestartBlock = NULL;

        //
        // Initialize the kernel debugger.
        //

        if (KdInitSystem(0, LoaderBlock) == FALSE) {
            KeBugCheck(PHASE0_INITIALIZATION_FAILED);
        }

        //
        // Initialize processor block array.
        //

        for (Index = 1; Index < MAXIMUM_PROCESSORS; Index += 1) {
            KiProcessorBlock[Index] = (PKPRCB)NULL;
        }

        //
        // Perform architecture independent initialization.
        //

        KiInitSystem();

        //
        // Initialize idle thread process object and then set:
        //
        //      1. all the quantum values to the maximum possible.
        //      2. the process in the balance set.
        //      3. the active processor mask to the specified processor.
        //

        DirectoryTableBase[0] = 0;
        DirectoryTableBase[1] = 0;

        KeInitializeProcess(Process,
                            (KPRIORITY)0,
                            (KAFFINITY)(-1),
                            &DirectoryTableBase[0],
                            FALSE);

        Process->ThreadQuantum = MAXCHAR;

    }

    // Update processor features.
    // This assumes an iVE exists or other ability to emulate the ia32
    // instruction set at the ability of the iVE on Merced (Itanium).
    //

    SharedUserData->ProcessorFeatures[PF_RDTSC_INSTRUCTION_AVAILABLE] = TRUE;
    SharedUserData->ProcessorFeatures[PF_COMPARE_EXCHANGE_DOUBLE] = TRUE;
    SharedUserData->ProcessorFeatures[PF_MMX_INSTRUCTIONS_AVAILABLE] = TRUE;
    SharedUserData->ProcessorFeatures[PF_XMMI_INSTRUCTIONS_AVAILABLE] = TRUE;


    //
    //
    // Initialize idle thread object and then set:
    //
    //      1. the initial kernel stack to the specified idle stack.
    //      2. the next processor number to the specified processor.
    //      3. the thread priority to the highest possible value.
    //      4. the state of the thread to running.
    //      5. the thread affinity to the specified processor.
    //      6. the specified processor member in the process active processors
    //          set.
    //

    KeInitializeThread(Thread, (PVOID)((ULONG_PTR)IdleStack - PAGE_SIZE),
                       (PKSYSTEM_ROUTINE)KeBugCheck,
                       (PKSTART_ROUTINE)NULL,
                       (PVOID)NULL, (PCONTEXT)NULL, (PVOID)NULL, Process);

    Thread->InitialStack = IdleStack;
    Thread->InitialBStore = IdleStack;
    Thread->StackBase = IdleStack;
    Thread->StackLimit = (PVOID)((ULONG_PTR)IdleStack - KERNEL_STACK_SIZE);
    Thread->BStoreLimit = (PVOID)((ULONG_PTR)IdleStack + KERNEL_BSTORE_SIZE);
    Thread->NextProcessor = Number;
    Thread->Priority = HIGH_PRIORITY;
    Thread->State = Running;
    Thread->Affinity = AFFINITY_MASK(Number);
    Thread->WaitIrql = DISPATCH_LEVEL;

    //
    // If the current processor is 0, then set the appropriate bit in the
    // active summary of the idle process.
    //

    if (Number == 0) {
        Process->ActiveProcessors |= AFFINITY_MASK(Number);
    }

    //
    // Execute the executive initialization.
    //

    try {
        ExpInitializeExecutive(Number, LoaderBlock);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KeBugCheck (PHASE0_EXCEPTION);
    }

#if 0
    if (Number == 0) {
        RUNTIME_FUNCTION LocalEntry;
        PRUNTIME_FUNCTION FunctionTable, FunctionEntry = NULL;
        ULONGLONG ControlPc;
        ULONG SizeOfExceptionTable;
        ULONG Size;
        LONG High;
        LONG Middle;
        LONG Low;
        extern VOID KiNormalSystemCall(VOID);

        FunctionTable = (PRUNTIME_FUNCTION)RtlImageDirectoryEntryToData(
                            (PVOID) PsNtosImageBase,
                            TRUE,
                            IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                            &SizeOfExceptionTable);

        if (FunctionTable != NULL) {

            Low = 0;
            High = (SizeOfExceptionTable / sizeof(RUNTIME_FUNCTION)) - 1;
            ControlPc = ((PPLABEL_DESCRIPTOR)KiNormalSystemCall)->EntryPoint - (ULONG_PTR)PsNtosImageBase;

            while (High >= Low) {

                Middle = (Low + High) >> 1;
                FunctionEntry = &FunctionTable[Middle];

                if (ControlPc < FunctionEntry->BeginAddress) {
                    High = Middle - 1;
                } else if (ControlPc >= FunctionEntry->EndAddress) {
                    Low = Middle + 1;
                } else {
                    break;
                }
            }
        }

        LocalEntry = *FunctionEntry;
        ControlPc = MM_EPC_VA - ((PPLABEL_DESCRIPTOR)KiNormalSystemCall)->EntryPoint;
        LocalEntry.BeginAddress += (ULONG)ControlPc;
        LocalEntry.EndAddress += (ULONG)ControlPc;
        Size = SizeOfExceptionTable - (ULONG)((ULONG_PTR)FunctionEntry - (ULONG_PTR)FunctionTable) - sizeof(RUNTIME_FUNCTION);

        RtlMoveMemory((PVOID)FunctionEntry, (PVOID)(FunctionEntry+1), Size);
        FunctionEntry = (PRUNTIME_FUNCTION)((ULONG_PTR)FunctionTable + SizeOfExceptionTable - sizeof(RUNTIME_FUNCTION));
        *FunctionEntry = LocalEntry;
    }
#endif // 0

    //
    // check for the exception deferral mode
    //

    if (KiExceptionDeferralMode != 0) {
        KiIA64DCR = 0x0000000000007e05;
    }

    //
    // initialize the DCR deferral bits
    //

    __setReg(CV_IA64_ApDCR, KiIA64DCR);

    //
    // If the initial processor is being initialized, then compute the
    // timer table reciprocal value and reset the PRCB values for the
    // controllable DPC behavior in order to reflect any registry
    // overrides.
    //

    if (Number == 0) {
        KiTimeIncrementReciprocal = KiComputeReciprocal((LONG)KeMaximumIncrement,
                                                        &KiTimeIncrementShiftCount);

        Prcb->MaximumDpcQueueDepth = KiMaximumDpcQueueDepth;
        Prcb->MinimumDpcRate = KiMinimumDpcRate;
        Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;
    }

    //
    // Raise IRQL to dispatch level and set the priority of the idle thread
    // to zero. This will have the effect of immediately causing the phase
    // one initialization thread to get scheduled for execution. The idle
    // thread priority is then set to the lowest realtime priority. This is
    // necessary so that mutexes aquired at DPC level do not cause the active
    // matrix to get corrupted.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    KeSetPriorityThread(Thread, (KPRIORITY)0);
    Thread->Priority = LOW_REALTIME_PRIORITY;

    //
    // Raise IRQL to the highest level.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

#if !defined(NT_UP)

    //
    // Indicate boot complete on secondary processor
    //

    LoaderBlock->Prcb = 0;

    //
    // If the current processor is not 0, then set the appropriate bit in
    // idle summary.
    //

    if (Number != 0) {
        KiIdleSummary |= AFFINITY_MASK(Number);
    }

#endif

    return;
}


BOOLEAN
KiInitMachineDependent (
    VOID
    )

/*++

Routine Description:

    This function performs machine-specific initialization by querying the HAL.

    N.B. This function is only called during phase1 initialization.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if initialization is successful. Otherwise,
    a value of FALSE is returned.

--*/

{
    HAL_PLATFORM_INFORMATION PlatformInfo;
    HAL_PROCESSOR_SPEED_INFORMATION ProcessorSpeedInfo;
    NTSTATUS Status;
    BOOLEAN  UseFrameBufferCaching;
    ULONG    Size;

    //
    // check to see if we should switch to PTC.G-based TB shootdown
    //

    Status = HalQuerySystemInformation(HalPlatformInformation,
                                       sizeof(PlatformInfo),
                                       &PlatformInfo,
                                       &Size);
    if (NT_SUCCESS(Status) &&
        (PlatformInfo.PlatformFlags & HAL_PLATFORM_DISABLE_PTCG)) {
        //
        // Will continue not to use PTC.G
        //
    }
    else {
        //
        // Use PTC.G if processor support is there.
        //

        if (KiConfigFlag & (1 << ENABLE_TB_BROADCAST)) {
            KiIpiTbShootdown = FALSE;
        }
    }

    //
    // If the HAL indicates write combining is not supported, drop it.
    //

    Status = HalQuerySystemInformation(HalFrameBufferCachingInformation,
                                       sizeof(UseFrameBufferCaching),
                                       &UseFrameBufferCaching,
                                       &Size);

    if (NT_SUCCESS(Status) && (UseFrameBufferCaching == FALSE)) {

        //
        // Hal says don't use.
        //

        NOTHING;
    }
    else {
        MmEnablePAT ();
    }

    //
    // Ask HAL for Processor Speed
    //

    Status = HalQuerySystemInformation(HalProcessorSpeedInformation,
                                       sizeof(ProcessorSpeedInfo),
                                       &ProcessorSpeedInfo,
                                       &Size);
    if (NT_SUCCESS(Status)) {
        PKPRCB   Prcb;
        ULONG    i;

        //
        // Put the Processor Speed into the Prcb structure so others
        // can reference it later.
        //
        for (i = 0; i < (ULONG)KeNumberProcessors; i++ ) {
            Prcb = KiProcessorBlock[i];
            Prcb->MHz = (USHORT)ProcessorSpeedInfo.ProcessorSpeed;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\intsup.s ===
//      TITLE("Interrupt Object Support Routines")
//++
//
// Module Name:
//
//    intsup.s
//
// Abstract:
//
//    This module implements the code necessary to support interrupt objects.
//    It contains the interrupt dispatch code and the code template that gets
//    copied into an interrupt object.
//
// Author:
//
//    Bernard Lint 20-Nov-1995
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//    Based on MIPS version (David N. Cutler (davec) 2-Apr-1990)
//
//--

#include "ksia64.h"
//
        SBTTL("Synchronize Execution")
//++
//
// BOOLEAN
// KeSynchronizeExecution (
//    IN PKINTERRUPT Interrupt,
//    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
//    IN PVOID SynchronizeContext
//    )
//
// Routine Description:
//
//    This function synchronizes the execution of the specified routine with the
//    execution of the service routine associated with the specified interrupt
//    object.
//
// Arguments:
//
//    Interrupt (a0) - Supplies a pointer to a control object of type interrupt.
//
//    SynchronizeRoutine (a1) - Supplies a pointer to a function whose execution
//       is to be synchronized with the execution of the service routine associated
//       with the specified interrupt object.
//
//    SynchronizeContext (a2) - Supplies a pointer to an arbitrary data structure
//       which is to be passed to the function specified by the SynchronizeRoutine
//       parameter.
//
// Return Value:
//
//    The value returned by the SynchronizeRoutine function is returned as the
//    function value.
//
//--

        NESTED_ENTRY(KeSynchronizeExecution)
        NESTED_SETUP(3,4,1,0)
        add       t2 = InSynchronizeIrql, a0    // -> sync IRQL
        ;;

        PROLOGUE_END

//
// Register aliases for entire procedure
//

        rOldIrql  = loc2                        // saved IRQL value
        rpSpinLock= loc3                        // address of spin lock

//
// Raise IRQL to the synchronization level and acquire the associated
// spin lock.
//

        ld8.nt1   t1 = [a1], PlGlobalPointer-PlEntryPoint
        ld1.nt1   t3 = [t2], InActualLock-InSynchronizeIrql
        mov       out0 = a2                     // get synchronize context
        ;;

#if !defined(NT_UP)

        ld8.nt1   rpSpinLock = [t2]             // get address of spin lock

#endif // !defined(NT_UP)

        SWAP_IRQL (t3)                          // raise IRQL

#if !defined(NT_UP)

        ACQUIRE_SPINLOCK(rpSpinLock, rpSpinLock, Kse10)

#endif // !defined(NT_UP)

//
// Call specified routine passing the specified context parameter.
//

        ld8.nt1   gp = [a1]
        mov       bt0 = t1                      // setup br
        mov       rOldIrql = v0
        br.call.sptk.many brp = bt0             // call routine

//
// Release spin lock, lower IRQL to its previous level, and return the value
// returned by the specified routine.
//

#if !defined(NT_UP)

        RELEASE_SPINLOCK(rpSpinLock)

#endif // !defined(NT_UP)

        SET_IRQL(rOldIrql)                      // lower IRQL to previous level
        NESTED_RETURN
        NESTED_EXIT(KeSynchronizeExecution)
//
        SBTTL("Chained Dispatch")
//++
//
// Routine Description:
//
//    This routine is entered as the result of an interrupt being generated
//    via a vector that is connected to more than one interrupt object. Its
//    function is to walk the list of connected interrupt objects and call
//    each interrupt service routine. If the mode of the interrupt is latched,
//    then a complete traversal of the chain must be performed. If any of the
//    routines require saving the volatile floating point machine state, then
//    it is only saved once.
//
//    N.B. On entry to this routine only the volatile integer registers have
//       been saved. Also the volatile lower floating point registers saved.
//
//    N.B. gp will be destroyed by the interrupt service routine; if this code
//         uses the gp of this module after the call, then it must save and
//         restore gp.
//
// Arguments:
//
//    a0 - Supplies a function pointer to the ISR (in the interrupt object
//         dispatch code).
//
//    a1 - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(KiChainedDispatch)
        NESTED_SETUP(2,8,2,0)
        .save     pr, loc7
        mov       loc7 = pr

        PROLOGUE_END

//
// Register aliases
//

        rpSpinLock = loc2                       // pointer to spinlock
        rMode     = loc3                        // interrupt mode (level sensitive)
        rpEntry   = loc4                        // current list entry
        rIrql     = loc5                        // source interrupt IRQL
        rSirql    = loc6                        // new interrupt IRQL
        rpI1      = t0                          // temp pointer
        rpI2      = t1                          // temp pointer
        rpFptr    = t2                          // pointer to ISR fptr
        rpCtxt    = t3                          // pointer to service context
        rFptr     = t4                          // ISR fptr

        pLoop1    = pt1                         // do another loop
        pLoop2    = pt2                         // do another loop
        pNEqual   = ps0                         // true if source IRQL != sync IRQL

//
// Initialize loop variables.
//

        add       out0 = -InDispatchCode, a0    // out0 -> interrupt object
        ;;
        add       rpEntry = InInterruptListEntry, out0   // set addr of listhead
        add       rpI1 = InMode, out0           // -> mode of interrupt
        add       rpI2 = InIrql, out0           // -> interrupt source IRQL
        ;;

        ld1.nt1   rMode = [rpI1]                // get mode of interrupt
        ld1.nt1   rIrql = [rpI2]                // get interrupt source IRQL

//
// Walk the list of connected interrupt objects and call the respective
// interrupt service routines.
//
// Raise IRQL to synchronization level if synchronization level is not
// equal to the interrupt source level.
//

Kcd_Loop:
        add       rpI1 = InSynchronizeIrql, out0
        ;;
        ld1       rSirql = [rpI1], InActualLock-InSynchronizeIrql
        ;;

        cmp.ne    pNEqual = rIrql, rSirql       // if ne, IRQL levels are
                                                // not the same
        ;;
        PSET_IRQL(pNEqual, rSirql)              // raise to synchronization IRQL

//
//
// Acquire the service routine spin lock and call the service routine.
//

#if !defined(NT_UP)

        ld8.nt1   rpSpinLock = [rpI1]           // get address of spin lock

        ACQUIRE_SPINLOCK(rpSpinLock, rpSpinLock, Kcd_Lock)

#endif // !defined(NT_UP)

        add       rpFptr = InServiceRoutine, out0        // pointer to fptr
        add       rpCtxt = InServiceContext, out0 // pointer to service context
        ;;
        LDPTR     (rFptr, rpFptr)               // get fptr
        LDPTR     (out1, rpCtxt)                // get service context
        ;;
        ld8.nt1   t5 = [rFptr], PlGlobalPointer-PlEntryPoint
        ;;
        ld8.nt1   gp = [rFptr]
        mov       bt0 = t5                      // set br address
        br.call.sptk brp = bt0                  // call ISR

//
// Release the service routine spin lock.
//

#if !defined(NT_UP)

        RELEASE_SPINLOCK(rpSpinLock)

#endif

//
// Lower IRQL to the interrupt source level if synchronization level is not
// the same as the interrupt source level.
//

        PSET_IRQL(pNEqual,rIrql)

//
// Get next list entry and check for end of loop.
//

        add       rpI1 = LsFlink, rpEntry        // -> next entry
        ;;
        LDPTR     (rpEntry, rpI1)                // -> next interrupt object
        ;;

//
// Loop if (1) interrrupt not handled and not end of list or
//      if (2) interrupt handled, and not level sensistive, and not end of list
//

        cmp4.eq   pLoop1 = zero, zero            // initialize pLoop1
        cmp4.eq   pLoop2 = zero, zero            // initialize pLoop2
        add       out0 = InDispatchCode-InInterruptListEntry, rpEntry  // -> ISR if done
        ;;

        cmp4.eq.and pLoop1 = zero, v0            // if eq, interrupt not handled
        cmp.ne.and  pLoop1, pLoop2 = a0, out0   // if ne, not end of list
        ;;
        add       out0 = -InInterruptListEntry, rpEntry  // -> next interrupt object
(pLoop1) br.dptk   Kcd_Loop                      // loop to handle next enrty
        ;;

        cmp4.ne.and pLoop2 = zero, v0            // if ne, interrupt handled
        cmp4.ne.and pLoop2 = zero, rMode         // if ne, not level sensitive
(pLoop2) br.dptk   Kcd_Loop                      // loop to handle next enrty
        ;;

//
// Either the interrupt is level sensitive and has been handled or the end of
// the interrupt object chain has been reached.
//

        mov       pr = loc7, -2
        NESTED_RETURN
        NESTED_EXIT(KiChainedDispatch)

        SBTTL("Interrupt Dispatch - Raise IRQL")
//++
//
// Routine Description:
//
//    This routine is entered as the result of an interrupt being generated
//    via a vector that is connected to an interrupt object. Its function is
//    to directly call the specified interrupt service routine.
//
//    N.B. On entry to this routine only the volatile integer registers have
//       been saved. Also volatile lower floating point registers saved.
//
//    N.B. This routine raises the interrupt level to the synchronization
//       level specified in the interrupt object.
//
//    N.B. gp will be destroyed by the interrupt service routine; if this code
//         uses the gp of this module after the call, then it must save and
//         restore gp.
//
// Arguments:
//
//    a0 - Supplies a function pointer to the ISR (in the interrupt object
//         dispatch code).
//
//    a1 - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(KiInterruptDispatchRaise)
        NESTED_SETUP(2,4,2,0)

        PROLOGUE_END

//
// Register aliases
//

        rpSpinLock = loc2
        rSirql    = loc3                        // sync IRQL

//
// Raise IRQL to synchronization level.
//

        add       t1 = InSynchronizeIrql-InDispatchCode, a0
        add       t2 = InActualLock-InDispatchCode, a0
        add       out0 = -InDispatchCode, a0    // out0 -> interrupt object
        ;;

        ld1.nt1   rSirql = [t1], InActualLock-InSynchronizeIrql
#if !defined(NT_UP)
        ld8.nt1   rpSpinLock = [t2]             // get address of spin lock
#endif // !defined(NT_UP)
        add       t5 = InServiceRoutine, out0   // pointer to fptr
        ;;

        ld8.nt1   t5 = [t5]                     // get function pointer
        SET_IRQL  (rSirql)                      // raise to synchronization IRQL
        add       t3 = InServiceContext, out0   // pointer to service context
        ;;

        ld8.nt1   t6 = [t5], PlGlobalPointer-PlEntryPoint
        ld8.nt1   out1 = [t3]                   // get service context

//
//
// Acquire the service routine spin lock and call the service routine.
//

#if !defined(NT_UP)

        ACQUIRE_SPINLOCK(rpSpinLock, rpSpinLock, Kidr_Lock)

#endif // !defined(NT_UP)
        ;;

        ld8.nt1   gp = [t5]
        mov       bt0 = t6                      // set br address
        br.call.sptk brp = bt0                  // call ISR
        ;;

//
// Release the service routine spin lock.
//

#if !defined(NT_UP)

        RELEASE_SPINLOCK(rpSpinLock)

#endif // !defined(NT_UP)

//
// IRQL lowered to the previous level in the external handler.
//

        NESTED_RETURN
        NESTED_EXIT(KiInterruptDispatchRaise)
//
        SBTTL("Interrupt Dispatch - Same IRQL")
//++
//
// Routine Description:
//
//    This routine is entered as the result of an interrupt being generated
//    via a vector that is connected to an interrupt object. Its function is
//    to directly call the specified interrupt service routine.
//
//    N.B. On entry to this routine only the volatile integer registers have
//       been saved. Also the volatile lower float point registers.
//
//    N.B. gp will be destroyed by the interrupt service routine; if this code
//         uses the gp of this module after the call, then it must save and
//         restore gp.
//
// Arguments:
//
//    a0 - Supplies a function pointer to the ISR (in the interrupt object
//         dispatch code).
//
//    a1 - Supplies a pointer to a trap frame..
//
// Return Value:
//
//    None.
//
//--

#if defined(NT_UP)

        LEAF_ENTRY(KiInterruptDispatchSame)

        alloc     t3 = ar.pfs, 2, 0, 0, 0
        add       a0 = -InDispatchCode, a0      // a0 points to interrupt object
        ;;
        add       t2 = InServiceRoutine, a0     // -> service routine fptr
        add       t1 = InServiceContext, a0     // -> service context
        ;;
        ld8.nt1   t2 = [t2]                     // service routine fptr
        ld8.nt1   a1 = [t1]                     // service context
        ;;
        ld8.nt1   t5 = [t2], PlGlobalPointer-PlEntryPoint
        ;;
        ld8.nt1   gp = [t2]
        mov       bt0 = t5
        br.sptk.many bt0                        // branch to service routine

//
// N.B.: Return to trap handler from ISR.
//

        LEAF_EXIT(KiInterruptDispatchSame)
#else

        NESTED_ENTRY(KiInterruptDispatchSame)
        NESTED_SETUP(2,3,2,0)

        PROLOGUE_END

//
// Register aliases
//

        rpSpinLock = loc2

//
//
// Acquire the service routine spin lock and call the service routine.
//

        add       out0 = -InDispatchCode, a0    // -> interrupt object
        ;;
        add       t7 = InServiceRoutine, out0   // addr of function pointer
        add       t1 = InActualLock, out0       // pointer to address of lock
        ;;

        ld8.nt1   t7 = [t7]                     // get function pointer
        ld8.nt1   rpSpinLock = [t1], InServiceContext-InActualLock
        add       t6 = InServiceContext, out0
        ;;

        ACQUIRE_SPINLOCK(rpSpinLock, rpSpinLock, Kids_Lock)

        ld8.nt1   t5 = [t7], PlGlobalPointer-PlEntryPoint
        ld8.nt1   out1 = [t1]                   // get service context
        ;;
        ld8.nt1   gp = [t7]
        mov       bt0 = t5                      // set br address
        br.call.sptk.many brp = bt0             // call ISR
        ;;

//
// Release the service routine spin lock.
//

        RELEASE_SPINLOCK(rpSpinLock)

        NESTED_RETURN

        NESTED_EXIT(KiInterruptDispatchSame)
#endif   // !defined(NT_UP)

        SBTTL("Disable Interrupts")
//++
//
// BOOLEAN
// KeDisableInterrupts (
//    VOID
//    )
//
// Routine Description:
//
//    This function disables interrupts and returns whether interrupts
//    were previously enabled.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    A boolean value that determines whether interrupts were previously
//    enabled (TRUE) or disabled(FALSE).
//
//--

        LEAF_ENTRY(KeDisableInterrupts)

        DISABLE_INTERRUPTS(t0)                  // t0 = previous state
        ;;
        tbit.nz   pt0, pt1 = t0, PSR_I          // pt0 = 1, if enabled; pt1 = 1 if disabled
        ;;

(pt0)   mov       v0 = TRUE                     // set return value -- TRUE if enabled
(pt1)   mov       v0 = FALSE                    // FALSE if disabled

        LEAF_RETURN
        LEAF_EXIT(KeDisableInterrupts)

//++
//
// VOID
// KiPassiveRelease (
//    VOID
//    )
//
// Routine Description:
//
//    This function is called when an interrupt has been passively released.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiPassiveRelease)

        LEAF_RETURN
        LEAF_EXIT(KiPassiveRelease)


        SBTTL("Unexpected Interrupt")
//++
//
// Routine Description:
//
//    This routine is entered as the result of an interrupt being generated
//    via a vector that is not connected to an interrupt object. Its function
//    is to report the error and dismiss the interrupt.
//
//    N.B. On entry to this routine only the volatile integer registers have
//       been saved. Also the volatile lower float point registers.
//
// Arguments:
//
//    a0 - Supplies a function pointer to the ISR (in the interrupt object
//         dispatch code).
//
//    a1 - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiUnexpectedInterrupt)

        LEAF_RETURN
        LEAF_EXIT(KiUnexpectedInterrupt)


        LEAF_ENTRY(KiFloatingDispatch)

        LEAF_RETURN
        LEAF_EXIT(KiFloatingDispatch)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\irql2.s ===
//      TITLE("Get Interrupt Request Level")
//++
//
// Module Name:
//
//    irql2.s
//
// Abstract:
//
//    This module implements the code to read the tpr register and convert
//    the result to Interrupt Request Level (IRQL).
//
//
// Author:
//
//    William K. Cheung (wcheung)
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksia64.h"

         .file    "irql2.s"

//++
//
// KIRQL
// KeGetCurrentIrql(
//      VOID
//      )
//
// Routine Description:
//
//    This function returns the current irql of the processor.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    Current processor irql.
//
//--

        LEAF_ENTRY(KeGetCurrentIrql)

        GET_IRQL(v0)
        
        LEAF_RETURN
        LEAF_EXIT(KeGetCurrentIrql)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\intobj.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    intobj.c

Abstract:

    This module implements the kernel interrupt object. Functions are provided
    to initialize, connect, and disconnect interrupt objects.

Author:

    David N. Cutler (davec) 3-Apr-1990

Environment:

    Kernel mode only.

Revision History:


--*/

#include "ki.h"

VOID
KeInitializeInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN PKSPIN_LOCK SpinLock OPTIONAL,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KIRQL SynchronizeIrql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector,
    IN CCHAR ProcessorNumber,
    IN BOOLEAN FloatingSave
    )

/*++

Routine Description:

    This function initializes a kernel interrupt object. The service routine,
    service context, spin lock, vector, IRQL, Synchronized IRQL, and floating
    context save flag are initialized.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

    ServiceRoutine - Supplies a pointer to a function that is to be
        executed when an interrupt occurs via the specified interrupt
        vector.

    ServiceContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the ServiceRoutine parameter.

    SpinLock - Supplies an optional pointer to an executive spin lock.

    Vector - Supplies the index of the entry in the Interrupt Dispatch Table
        that is to be associated with the ServiceRoutine function.

    Irql - Supplies the request priority of the interrupting source.

    SynchronizeIrql - The request priority that the interrupt should be
        synchronized with.

    InterruptMode - Supplies the mode of the interrupt; LevelSensitive or
        Latched.

    ShareVector - Supplies a boolean value that specifies whether the
        vector can be shared with other interrupt objects or not.  If FALSE
        then the vector may not be shared, if TRUE it may be.
        Latched.

    ProcessorNumber - Supplies the number of the processor to which the
        interrupt will be connected.

    FloatingSave - Supplies a boolean value that determines whether the
        floating point registers and pipe line are to be saved before calling
        the ServiceRoutine function.

Return Value:

    None.

--*/

{

    LONG Index;

    //
    // Initialize standard control object header.
    //

    Interrupt->Type = InterruptObject;
    Interrupt->Size = sizeof(KINTERRUPT);

    //
    // Initialize the address of the service routine, the service context,
    // the address of the spin lock, the address of the actual spin lock
    // that will be used, the vector number, the IRQL of the interrupting
    // source, the Synchronized IRQL of the interrupt object, the interrupt
    // mode, the processor number, and the floating context save flag.
    //

    Interrupt->ServiceRoutine = ServiceRoutine; // function pointer
    Interrupt->ServiceContext = ServiceContext;

    if (ARGUMENT_PRESENT(SpinLock)) {
        Interrupt->ActualLock = SpinLock;

    } else {
        Interrupt->SpinLock = 0;
        Interrupt->ActualLock = &Interrupt->SpinLock;
    }

    Interrupt->Vector = Vector;
    Interrupt->Irql = Irql;
    Interrupt->SynchronizeIrql = SynchronizeIrql;
    Interrupt->Mode = InterruptMode;
    Interrupt->ShareVector = ShareVector;
    Interrupt->Number = ProcessorNumber;
    Interrupt->FloatingSave = FloatingSave;

    //
    // Set the connected state of the interrupt object to FALSE.
    //

    Interrupt->Connected = FALSE;
    return;
}

BOOLEAN
KeConnectInterrupt (
    IN PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function connects an interrupt object to the interrupt vector
    specified by the interrupt object. If the interrupt object is already
    connected, or an attempt is made to connect to an interrupt that cannot
    be connected, then a value of FALSE is returned. Else the specified
    interrupt object is connected to the interrupt vector, the connected
    state is set to TRUE, and TRUE is returned as the function value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is already connected or an attempt is made to
    connect to an interrupt vector that cannot be connected, then a value
    of FALSE is returned. Else a value of TRUE is returned.

--*/

{

    BOOLEAN Connected;
    PKINTERRUPT Interruptx;
    KIRQL Irql;
    CHAR Number;
    KIRQL OldIrql;
    ULONG Vector;
    UCHAR IDTEntry;

    //
    // If the interrupt object is already connected, the interrupt vector
    // number is invalid, an attempt is being made to connect to a vector
    // that cannot be connected, the interrupt request level is invalid,
    // the processor number is invalid, of the interrupt vector is less
    // than or equal to the highest level and it not equal to the specified
    // IRQL, then do not connect the interrupt object. Else connect interrupt
    // object to the specified vector and establish the proper interrupt
    // dispatcher.
    //

    Connected = FALSE;
    Irql = Interrupt->Irql;
    Number = Interrupt->Number;
    Vector = Interrupt->Vector;
    IDTEntry = HalVectorToIDTEntry(Vector);

    if ((((IDTEntry >= MAXIMUM_VECTOR) || (Irql > HIGH_LEVEL) ||
       ((IDTEntry <= HIGH_LEVEL) &&
       ((((1 << IDTEntry) & PCR->ReservedVectors) != 0) || (IDTEntry != Irql))) ||
       (Number >= KeNumberProcessors))) == FALSE) {

        //
        // Set system affinity to the specified processor.
        //

        KeSetSystemAffinityThread(AFFINITY_MASK(Number));

        //
        // Raise IRQL to dispatcher level and lock dispatcher database.
        //

        KiLockDispatcherDatabase(&OldIrql);

        //
        // If the specified interrupt vector is not connected, then
        // connect the interrupt vector to the interrupt object dispatch
        // code, establish the dispatcher address, and set the new
        // interrupt mode and enable masks. Else if the interrupt is
        // already chained, then add the new interrupt object at the end
        // of the chain. If the interrupt vector is not chained, then
        // start a chain with the previous interrupt object at the front
        // of the chain. The interrupt mode of all interrupt objects in
        // a chain must be the same.
        //

        if (Interrupt->Connected == FALSE) {
            if (PCR->InterruptRoutine[IDTEntry] ==
                (PKINTERRUPT_ROUTINE)(&KxUnexpectedInterrupt.DispatchCode)) {
                Connected = TRUE;
                Interrupt->Connected = TRUE;
                if (Interrupt->FloatingSave != FALSE) {
                    Interrupt->DispatchAddress = KiFloatingDispatch;

                } else {
                    if (Interrupt->Irql == Interrupt->SynchronizeIrql) {
                        Interrupt->DispatchAddress =
                                    (PKINTERRUPT_ROUTINE)KiInterruptDispatchSame;

                    } else {
                        Interrupt->DispatchAddress =
                                    (PKINTERRUPT_ROUTINE)KiInterruptDispatchRaise;
                    }
                }

                //
                // Copy the plabel for the Dispatch routine into DispatchCode.  
                // This will be used by KiExternalInterruptHandler to 
                // dispatch the interrupt.
                //


                RtlMoveMemory(Interrupt->DispatchCode, 
                              Interrupt->DispatchAddress, 
                              DISPATCH_LENGTH*4);

                PCR->InterruptRoutine[IDTEntry] =
                            (PKINTERRUPT_ROUTINE)(&Interrupt->DispatchCode);

                HalEnableSystemInterrupt(Vector, Irql, Interrupt->Mode);

            } else {
                Interruptx = CONTAINING_RECORD(PCR->InterruptRoutine[IDTEntry],
                                               KINTERRUPT,
                                               DispatchCode[0]);

                if (Interrupt->Mode == Interruptx->Mode) {
                    Connected = TRUE;
                    Interrupt->Connected = TRUE;
                    ASSERT (Irql <= KiSynchIrql);
                    if (Interruptx->DispatchAddress != KiChainedDispatch) {
                        InitializeListHead(&Interruptx->InterruptListEntry);
                        Interruptx->DispatchAddress = KiChainedDispatch;
        
                        RtlMoveMemory(Interruptx->DispatchCode, 
                                      Interruptx->DispatchAddress,
                                      DISPATCH_LENGTH*4);
                    }

                    InsertTailList(&Interruptx->InterruptListEntry,
                                   &Interrupt->InterruptListEntry);
                }
            }
        }

        //
        // Unlock dispatcher database and lower IRQL to its previous value.
        //

        KiUnlockDispatcherDatabase(OldIrql);

        //
        // Set system affinity back to the original value.
        //

        KeRevertToUserAffinityThread();
    }

    //
    // Return whether interrupt was connected to the specified vector.
    //

    return Connected;
}

BOOLEAN
KeDisconnectInterrupt (
    IN PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function disconnects an interrupt object from the interrupt vector
    specified by the interrupt object. If the interrupt object is not
    connected, then a value of FALSE is returned. Else the specified interrupt
    object is disconnected from the interrupt vector, the connected state is
    set to FALSE, and TRUE is returned as the function value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is not connected, then a value of FALSE is
    returned. Else a value of TRUE is returned.

--*/

{

    BOOLEAN Connected;
    PKINTERRUPT Interruptx;
    PKINTERRUPT Interrupty;
    KIRQL Irql;
    KIRQL OldIrql;
    ULONG Vector;
    UCHAR IDTEntry;

    //
    // Set system affinity to the specified processor.
    //

    KeSetSystemAffinityThread(AFFINITY_MASK(Interrupt->Number));

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the interrupt object is connected, then disconnect it from the
    // specified vector.
    //

    Connected = Interrupt->Connected;
    if (Connected != FALSE) {
        Irql = Interrupt->Irql;
        Vector = Interrupt->Vector;
        IDTEntry = HalVectorToIDTEntry(Vector);

        //
        // If the specified interrupt vector is not connected to the chained
        // interrupt dispatcher, then disconnect it by setting its dispatch
        // address to the unexpected interrupt routine. Else remove the
        // interrupt object from the interrupt chain. If there is only
        // one entry remaining in the list, then reestablish the dispatch
        // address.
        //

        Interruptx = CONTAINING_RECORD(PCR->InterruptRoutine[IDTEntry],
                                       KINTERRUPT,
                                       DispatchCode[0]);

        if (Interruptx->DispatchAddress ==
                                (PKINTERRUPT_ROUTINE)KiChainedDispatch) {
            ASSERT (Irql <= KiSynchIrql);
            if (Interrupt == Interruptx) {
                Interruptx = CONTAINING_RECORD(Interruptx->InterruptListEntry.Flink,
                                               KINTERRUPT, InterruptListEntry);
                Interruptx->DispatchAddress =
                                (PKINTERRUPT_ROUTINE)KiChainedDispatch;

                RtlMoveMemory(Interruptx->DispatchCode, 
                              Interruptx->DispatchAddress,
                              DISPATCH_LENGTH*4);

                PCR->InterruptRoutine[IDTEntry] =
                                (PKINTERRUPT_ROUTINE)(&Interruptx->DispatchCode);
            }

            RemoveEntryList(&Interrupt->InterruptListEntry);
            Interrupty = CONTAINING_RECORD(Interruptx->InterruptListEntry.Flink,
                                           KINTERRUPT,
                                           InterruptListEntry);

            if (Interruptx == Interrupty) {
                if (Interrupty->FloatingSave != FALSE) {
                    Interrupty->DispatchAddress = KiFloatingDispatch;

                } else {
                    if (Interrupty->Irql == Interrupty->SynchronizeIrql) {
                        Interrupty->DispatchAddress =
                                    (PKINTERRUPT_ROUTINE)KiInterruptDispatchSame;

                    } else {
                        Interrupty->DispatchAddress =
                                    (PKINTERRUPT_ROUTINE)KiInterruptDispatchRaise;
                    }
                }

                //
                // Copy the plabel for the Dispatch routine into DispatchCode.
                // This will be used by KiExternalInterruptHandler to 
                // dispatch the interrupt.
                //

                RtlMoveMemory(Interrupty->DispatchCode, 
                              Interrupty->DispatchAddress,
                              DISPATCH_LENGTH*4);

                PCR->InterruptRoutine[IDTEntry] =
                               (PKINTERRUPT_ROUTINE)(&Interrupty->DispatchCode);
                }

        } else {
            HalDisableSystemInterrupt(Vector, Irql);
            PCR->InterruptRoutine[IDTEntry] =
                    (PKINTERRUPT_ROUTINE)(&KxUnexpectedInterrupt.DispatchCode);
        }

        Interrupt->Connected = FALSE;
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Set system affinity back to the original value.
    //

    KeRevertToUserAffinityThread();
    
    //
    // Return whether interrupt was disconnected from the specified vector.
    //

    return Connected;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\irql.s ===
//      TITLE("Manipulate Interrupt Request Level")
//++
//
// Module Name:
//
//    irql.s
//
// Abstract:
//
//    This module implements the code necessary to lower and raise the current
//    Interrupt Request Level (IRQL).
//
//
// Author:
//
//    William K. Cheung (wcheung) 05-Oct-1995
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//    08-Feb-1996    Updated to EAS2.1
//
//--

#include "ksia64.h"

         .file    "irql.s"

//
// Globals
//

        PublicFunction(KiCheckForSoftwareInterrupt)

//++
//
// VOID
// KiLowerIrqlSpecial (
//    KIRQL NewIrql
//    )
//
// Routine Description:
//
//    This function lowers the current IRQL to the specified value.
//    Does not check for software interrupts. For use within the software interupt
//    dispatch code.
//
// Arguments:
//
//    NewIrql (a0) - Supplies the new IRQL value.
//
// Return Value:
//
//    None.
//
// N.B. The IRQL is being lowered.  Therefore, it is not necessary to
//      do a data serialization after the TPR is updated unless it is
//      very critical to accept interrupts of lower priorities as soon
//      as possible.  The TPR change will take into effect eventually.
//
//--

        LEAF_ENTRY(KiLowerIrqlSpecial)

        SET_IRQL(a0)
        LEAF_RETURN

        LEAF_EXIT(KiLowerIrqlSpecial)

//++
//
// VOID
// KiLowerIrqlSoftwareInterruptPending(
//   IN TEMP_REG NewIrql
//   )
//
// Routine Description:
//
//   This function is entered directly from a LEAF function that is
//   lowering IRQL before it exits when there is a software interrupt
//   pending that will fire as a result of lowering IRQL.
//
//   In this special case, we need to promote to a nested entry in
//   order to process the simulated interrupt.
//
//   Return is directly to the caller of the leaf function.
//
//   This routine is entered with interrupts disabled, this is a
//   side effect of the code that branched here needing interrupts
//   disabled while checking and lowering.
//
// Arguments:
//
//   NewIrql    - Because we are branched to from a leaf routine,
//                the argument must be passed in non-windowed
//                register t22 (r31).
//
// Return Value:
//
//   None.
//
//--
        NESTED_ENTRY(KiLowerIrqlSoftwareInterruptPending)
        NESTED_SETUP(0,3,1,0)
        PROLOGUE_END
        mov         out0 = t22
        ssm         1 << PSR_I
        ;;
        br.call.spnt brp = KiCheckForSoftwareInterrupt;;

        NESTED_RETURN
        NESTED_EXIT(KiLowerIrqlSoftwareInterruptPending)

//++
//
// VOID
// KeLowerIrql (
//    KIRQL NewIrql
//    )
//
// Routine Description:
//
//    This function lowers the current IRQL to the specified value.
//
// Arguments:
//
//    NewIrql (a0) - Supplies the new IRQL value.
//
// Return Value:
//
//    None.
//
// N.B. The IRQL is being lowered.  Therefore, it is not necessary to
//      do a data serialization after the TPR is updated unless it is
//      very critical to accept interrupts of lower priorities as soon
//      as possible.  The TPR change will take into effect eventually.
//
//--

        LEAF_ENTRY(KeLowerIrql)

        //
        // KIRQL is a byte, extend to 64 bits.
        //

        zxt1        a0 = a0
        ;;

        //
        // If lowering below DISPATCH_LEVEL, check for pending
        // software interrupts that could run now.
        //
        // This needs to be done with interrupts disabled to
        // avoid the case where an interrupt is set pending
        // while we check but before IRQL is actually lowered.
        //

        cmp.gtu     pt0 = DISPATCH_LEVEL, a0
        movl        t21 = KiPcr+PcSoftwareInterruptPending;;
(pt0)   rsm         1 << PSR_I
(pt0)   ld2         t21 = [t21]
        mov         t22 = a0;;
(pt0)   cmp.ltu.unc pt1, pt2 = a0, t21

        //
        // If a software interrupt would fire now, branch directly
        // to KiLowerIrqlSoftwareInterruptPending which will promote
        // to a NESTED routine, handle the interrupt, lower IRQL and
        // return directly to the caller.
        //

(pt1)   br.spnt KiLowerIrqlSoftwareInterruptPending

        //
        // Didn't have an interrupt pending, lower IRQL and return.
        //

        SET_IRQL(a0)

        //
        // Enable interrupts and return.
        //

        ssm         1 << PSR_I

        LEAF_RETURN

        LEAF_EXIT(KeLowerIrql)

//++
//
// VOID
// KeRaiseIrql (
//    KIRQL NewIrql,
//    PKIRQL OldIrql
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to the specified value and returns
//    the old IRQL value.
//
// Arguments:
//
//    NewIrql (a0) - Supplies the new IRQL value.
//
//    OldIrql (a1) - Supplies a pointer to a variable that recieves the old
//       IRQL value.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeRaiseIrql)

//
// Register aliases
//

        rOldIrql    = t3

        GET_IRQL    (rOldIrql)
        SET_IRQL    (a0)                        // Raise IRQL
        ;;
        st1         [a1] = rOldIrql             // return old IRQL value
        LEAF_RETURN

        LEAF_EXIT(KeRaiseIrql)

//++
//
// KIRQL
// KfRaiseIrql (
//    KIRQL NewIrql
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to the specified value and returns
//    the old IRQL value.
//
// Arguments:
//
//    NewIrql (a0) - Supplies the new IRQL value.
//
// Return Value:
//
//    Old Irql value.
//
//--

        LEAF_ENTRY(KfRaiseIrql)


        GET_IRQL    (r8)                        // Put old IRQL in return register.
        SET_IRQL    (a0)                        // Raise IRQL
        LEAF_RETURN

        LEAF_EXIT(KfRaiseIrql)

//++
//
// KIRQL
// KeRaiseIrqlToDpcLevel (
//    VOID
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to DISPATCH_LEVEL and returns
//    the old IRQL value.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    Old IRQL value
//
//--

        LEAF_ENTRY(KeRaiseIrqlToDpcLevel)
//
// Register aliases
//

        rNewIrql = t0

        mov         rNewIrql = DISPATCH_LEVEL
        GET_IRQL(v0)
        ;;

        SET_IRQL    (rNewIrql)                  // Raise IRQL

        LEAF_RETURN
        LEAF_EXIT(KeRaiseIrqlToDpcLevel)

//++
//
// KIRQL
// KeRaiseIrqlToSynchLevel (
//    VOID
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to SYNCH_LEVEL and returns
//    the old IRQL value.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    Old IRQL value
//
//--

        LEAF_ENTRY(KeRaiseIrqlToSynchLevel)

//
// Register aliases
//

        rNewIrql = t0

        mov         rNewIrql = SYNCH_LEVEL
        GET_IRQL(v0)
        ;;

        SET_IRQL    (rNewIrql)                  // Raise IRQL
        LEAF_RETURN

        LEAF_EXIT(KeRaiseIrqlToSynchLevel)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\intsupc.c ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1998  Intel Corporation

Module Name:

    intsupc.c

Abstract:

    This module implements ruotines for interrupt support.

Author:

    Bernard Lint 5-May-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
KiLowerIrqlSpecial(KIRQL);

VOID
KiDispatchSoftwareInterrupt (
    KIRQL Irql
    )

/*++

Routine Description:

    Dispatch pending software interrupt

Arguments:

    Irql (a0) - Software interrupt to dispatch

Return Value:

    None.

Notes:

    Interrupts disabled on entry/return.
    The function is only called by KiCheckForSoftwareInterrupt that passes an
    Irql value of APC_LEVEL or DISPATCH_LEVEL.


--*/

{
    PKPRCB Prcb = KeGetCurrentPrcb();

    KiLowerIrqlSpecial(Irql); // set IRQL

    if (Irql == APC_LEVEL) {

        PCR->ApcInterrupt = 0;

        _enable();

        //
        // Dispatch APC Interrupt via direct call to KiDeliverApc
        //

        KiDeliverApc(KernelMode,NULL,NULL);

        _disable();

    } else {

        PCR->DispatchInterrupt = 0;

        _enable();

        //
        // Dispatch DPC Interrupt
        //

        KiDispatchInterrupt();

        _disable();

    }
}

VOID
KiCheckForSoftwareInterrupt (
    KIRQL RequestIrql
    )

/*++

Routine Description:

    Check for and dispatch pending software interrupts

Arguments:

    Irql (a0) - New, lower IRQL

Return Value:

    None.

Notes:

    Caller must check IRQL has dropped below s/w IRQL level

--*/

{
    BOOLEAN InterruptState;

    InterruptState = KeDisableInterrupts();

    if (RequestIrql == APC_LEVEL) {

        //
        // Dispatch only DPC requests
        //

        while (PCR->DispatchInterrupt) {
            KiDispatchSoftwareInterrupt(DISPATCH_LEVEL);
        }

    } else {

        //
        // Dispatch either APC or DPC
        //

        while (PCR->SoftwareInterruptPending) {
            KIRQL Irql;

            if (PCR->DispatchInterrupt) {
                Irql = DISPATCH_LEVEL;
            } else {
                Irql = APC_LEVEL;
            }
            KiDispatchSoftwareInterrupt(Irql);
        }
    }

    //
    // Lower IRQL to the requested level, restore interrupts and
    // return.
    //

    KiLowerIrqlSpecial(RequestIrql);
    KeEnableInterrupts(InterruptState);
}

VOID
KiRequestSoftwareInterrupt (
    KIRQL RequestIrql
    )

/*++

Routine Description:

   This function requests a software interrupt at the specified IRQL
   level.

Arguments:

   RequestIrql (a0) - Supplies the request IRQL value.

Return Value:

   None.

--*/

{
    KIRQL Irql;

#if DEBUG
    if ((RequestIrql < APC_LEVEL) || (RequestIrql > DISPATCH_LEVEL))
        KeBugCheckEx(INVALID_SOFTWARE_INTERRUPT, RequestIrql, 0, 0, 0);
#endif

    ((PUCHAR)&PCR->SoftwareInterruptPending)[RequestIrql-APC_LEVEL] = 1;

    Irql = KeGetCurrentIrql();
    if (Irql < RequestIrql) {
        KeLowerIrql (Irql);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\ivtlog.s ===
// shadow IVT
// logs and then branches to the original vector code at KiIvtBase
//
#include "ksia64.h"

// For Conditional Interrupt Logging

#define KiVhptTransVectorBit  0
#define KiInstTlbVectorBit 1
#define KiDataTlbVectorBit 2
#define KiAltInstTlbVectorBit 3
#define KiAltDataTlbVectorBit 4
#define KiNestedTlbVectorBit 5
#define KiInstKeyMissVectorBit 6
#define KiDataKeyMissVectorBit 7
#define KiDirtyBitVectorBit 8
#define KiInstAccessBitVectorBit 9
#define KiDataAccessBitVectorBit 10
#define KiBreakVectorBit 11
#define KiExternalInterruptVectorBit 12
#define KiPageNotPresentVectorBit 13
#define KiKeyPermVectorBit 14
#define KiInstAccessRightsVectorBit 15
#define KiDataAccessRightsVectorBit 16
#define KiGeneralExceptionsVectorBit 17
#define KiDisabledFpRegisterVectorBit 18
#define KiNatConsumptionVectorBit 19
#define KiSpeculationVectorBit 20
#define KiDebugFaultVectorBit 21
#define KiUnalignedFaultVectorBit 22
#define KiFloatFaultVectorBit 23
#define KiFloatTrapVectorBit 24
#define KiLowerPrivilegeVectorBit 25
#define KiTakenBranchVectorBit 26
#define KiSingleStepVectorBit 27
#define KiIA32ExceptionVectorBit 28
#define KiIA32InterceptionVectorBit 29
#define KiIA32InterruptionVectorBit 30

// #define UserSystemcallBit 61
// #define ExternalInterruptBit 62
// #define ContextSwitchBit 63

// reserve bit 13 in ConfigFlag to indicate which IVT to use
#define DISABLE_TRACE_LOG  13


         .file "ivtilog.s"
         .explicit

        .global KiVectorLogMask

#define  VECTOR_ENTRY(Offset, Name, Extra0)                 \
        .##global Name;                                     \
        .##type Name,@function;                             \
        .##org Offset;                                      \
        .##global Name##ILog;                               \
        .##proc   Name##ILog;                               \
                                                            \
Name##ILog::                                               ;\
        mov    h30 = pr                                    ;\
        mov    h27 = gp                                    ;\
        ;;                                                 ;\
        movl   gp = _gp                                    ;\
        ;;                                                 ;\
        add    h28 = @gprel(KiVectorLogMask), gp             ;\
        ;;                                                 ;\
        ld8    h29 = [h28]                                 ;\
        ;;                                                 ;\
        mov    gp = h27                                    ;\
        ;;                                                 ;\
        tbit.z pt1 = h29, Name##Bit                        ;\
(pt1)   br.cond.sptk Name##ILogEnd                         ;\
        ;;                                                 ;\
                                                            \
        mov       h28 = cr.iip                             ;\
        movl      h25 = KiPcr+PcInterruptionCount          ;\
        ;;                                                 ;\
        mov       h29 = cr.ipsr                            ;\
        ld4.nt1   h26 = [h25]                              ;\
        mov       h24 = MAX_NUMBER_OF_IHISTORY_RECORDS - 1 ;\
        ;;                                                 ;\
        add       h27 = 1, h26                             ;\
        and       h26 = h24, h26                           ;\
        add       h24 = 0x1000-PcInterruptionCount, h25    ;\
        ;;                                                 ;\
        st4.nta   [h25] = h27                              ;\
        shl       h26 = h26, 5                             ;\
        ;;                                                 ;\
        add       h27 = h26, h24                           ;\
        mov       h31 = (Offset >> 8)                      ;\
        ;;                                                 ;\
        st8       [h27] = h31, 8                           ;\
        ;;                                                 ;\
        st8       [h27] = h28, 8                           ;\
        mov       h31 = Extra0                             ;\
        ;;                                                 ;\
        st8       [h27] = h29, 8                           ;\
        ;;                                                 ;\
        st8       [h27] = h31;                             ;\
                                                            \
Name##ILogEnd::                                            ;\
                                                            \
        mov       pr  = h30, -1                            ;\
        br.sptk   Name

#define VECTOR_EXIT(Name)                       \
        .##endp   Name##ILog

#define  VECTOR_ENTRY_HB_DUMP(Offset, Name, Extra0)         \
        .##global Name;                                     \
        .##type Name,@function;                             \
        .##org Offset;                                      \
        .##global Name##ILog;                               \
        .##proc   Name##ILog;                               \
                                                            \
Name##ILog::                                                \
        /* h30 = pr */                                     ;\
        /* b0 = Name##ILogStart */                         ;\
        /* h29 = cpuid3 */                                 ;\
        /* h28 =  b0 */                                    ;\
{       .mmi                                               ;\
        mov    ar.k1 = h24                                 ;\
        mov    ar.k2 = h25                                 ;\
        nop.i  0                                           ;\
}                                                          ;\
{       .mmi                                               ;\
        mov    ar.k4 = h27                                 ;\
        mov    ar.k5 = h28                                 ;\
        nop.i  0                                           ;\
}                                                          ;\
{       .mii                                               ;\
        mov    h29 = 3                                     ;\
        mov    h30 = pr                                    ;\
        mov    h28 = b0;;                                  ;\
}                                                          ;\
{       .mli                                               ;\
        mov    h29 = cpuid[h29]                            ;\
        movl   h31 = Name##ILogStart;;                     ;\
}                                                          ;\
{       .mii                                               ;\
        mov    h26 =  675                                  ;\
        mov    b0  = h31    /* set return address */       ;\
        extr.u h24 = h29, 24, 8 ;;                         ;\
}                                                          ;\
{       .mib                                               ;\
        nop.m  0                                           ;\
        cmp.ne pt0 = 7, h24                                ;\
(pt0)   br.cond.spnt Name##ILogStart                       ;\
}                                                          ;\
{       .mmi                                               ;\
        mov    h27 =  msr[h26] ;;                          ;\
        nop.m  0                                           ;\
        tbit.nz pt2 = r27, 8  /* skip if HB is disabled */ ;\
}                                                          ;\
{       .mib                                               ;\
        nop.m 0                                            ;\
        dep    h27 = 1, r27, 8, 1   /* disable HB */       ;\
(pt2)   br.cond.spnt Name##ILogStart ;;                    ;\
}                                                          ;\
{       .mib                                               ;\
        mov    msr[h26] = h27                              ;\
        nop.i  0                                           ;\
        br.sptk KiDumpHistoryBuffer                        ;\
}                                                          ;\
                                                           ;\
Name##ILogStart::                                          ;\
{       .mli                                               ;\
        mov    h27 = gp                                    ;\
        movl   h31 = Name##ILogEnd ;;                      ;\
}                                                          ;\
{       .mli                                               ;\
        nop.m  0                                           ;\
        movl   gp = _gp ;;                                 ;\
}                                                          ;\
{       .mmi                                               ;\
        add    h25 = @gprel(KiVectorLogMask), gp ;;        ;\
        ld8    h25 = [h25]                                 ;\
        mov    b0 = r31                                    ;\
}                                                          ;\
{       .mmi                                               ;\
        mov    h29 = (Offset >> 8)                         ;\
        mov    h31 = Extra0                                ;\
        mov    gp = h27 ;;                                 ;\
}                                                          ;\
{       .mib                                               ;\
        nop.m   0                                          ;\
        tbit.nz pt1 = h25, Name##Bit                       ;\
(pt1)   br.sptk KiLogInterruptEvent ;;                     ;\
}                                                          ;\
Name##ILogEnd::                                            ;\
{       .mii                                               ;\
        nop.m     0                                        ;\
        mov       b0 = h28                                 ;\
        mov       pr  = h30, -1                            ;\
}                                                          ;\
{       .mib                                               ;\
        nop.m     0                                        ;\
        nop.i     0                                        ;\
        br.sptk   Name ;;                                  ;\
}

        .section .drectve, "MI", "progbits"
        string "-section:.ivtilog,,align=0x8000"

        .section .ivtilog = "ax", "progbits"
KiIvtBaseILog::     // symbol for start of shadow IVT

        VECTOR_ENTRY(0x0000, KiVhptTransVector, cr.ifa)
        VECTOR_EXIT(KiVhptTransVector)

        VECTOR_ENTRY(0x0400, KiInstTlbVector, cr.iipa)
        VECTOR_EXIT(KiInstTlbVector)

        VECTOR_ENTRY(0x0800, KiDataTlbVector, cr.ifa)
        VECTOR_EXIT(KiDataTlbVector)

        VECTOR_ENTRY(0x0c00, KiAltInstTlbVector, cr.iipa)
        VECTOR_EXIT(KiAltInstTlbVector)

        VECTOR_ENTRY(0x1000, KiAltDataTlbVector, cr.ifa)
        VECTOR_EXIT(KiAltDataTlbVector)

        VECTOR_ENTRY(0x1400, KiNestedTlbVector, cr.ifa)
        VECTOR_EXIT(KiNestedTlbVector)

        VECTOR_ENTRY(0x1800, KiInstKeyMissVector, cr.iipa)
        VECTOR_EXIT(KiInstKeyMissVector)

        VECTOR_ENTRY(0x1c00, KiDataKeyMissVector, cr.ifa)
        VECTOR_EXIT(KiDataKeyMissVector)

        VECTOR_ENTRY(0x2000, KiDirtyBitVector, cr.ifa)
        VECTOR_EXIT(KiDirtyBitVector)

        VECTOR_ENTRY(0x2400, KiInstAccessBitVector, cr.iipa)
        VECTOR_EXIT(KiInstAccessBitVector)

        VECTOR_ENTRY(0x2800, KiDataAccessBitVector, cr.ifa)
        VECTOR_EXIT(KiDataAccessBitVector)

        VECTOR_ENTRY(0x2C00, KiBreakVector, cr.iim)
        VECTOR_EXIT(KiBreakVector)

        VECTOR_ENTRY(0x3000, KiExternalInterruptVector, r0)
        VECTOR_EXIT(KiExternalInterruptVector)

        VECTOR_ENTRY(0x5000, KiPageNotPresentVector, cr.ifa)
        VECTOR_EXIT(KiPageNotPresentVector)

        VECTOR_ENTRY(0x5100, KiKeyPermVector, cr.ifa)
        VECTOR_EXIT(KiKeyPermVector)

        VECTOR_ENTRY(0x5200, KiInstAccessRightsVector, cr.iipa)
        VECTOR_EXIT(KiInstAccessRightsVector)

        VECTOR_ENTRY(0x5300, KiDataAccessRightsVector, cr.ifa)
        VECTOR_EXIT(KiDataAccessRightsVector)

        VECTOR_ENTRY_HB_DUMP(0x5400, KiGeneralExceptionsVector, cr.isr)
//        VECTOR_ENTRY(0x5400, KiGeneralExceptionsVector, cr.isr)
        VECTOR_EXIT(KiGeneralExceptionsVector)

        VECTOR_ENTRY(0x5500, KiDisabledFpRegisterVector, cr.isr)
        VECTOR_EXIT(KiDisabledFpRegisterVector)

        VECTOR_ENTRY(0x5600, KiNatConsumptionVector, cr.isr)
        VECTOR_EXIT(KiNatConsumptionVector)

        VECTOR_ENTRY(0x5700, KiSpeculationVector, cr.iim)
        VECTOR_EXIT(KiSpeculationVector)

        VECTOR_ENTRY(0x5900, KiDebugFaultVector, cr.isr)
        VECTOR_EXIT(KiDebugFaultVector)

        VECTOR_ENTRY(0x5a00, KiUnalignedFaultVector, cr.ifa)
        VECTOR_EXIT(KiUnalignedFaultVector)

        VECTOR_ENTRY(0x5c00, KiFloatFaultVector, cr.isr)
        VECTOR_EXIT(KiFloatFaultVector)

        VECTOR_ENTRY(0x5d00, KiFloatTrapVector, cr.isr)
        VECTOR_EXIT(KiFloatTrapVector)

        VECTOR_ENTRY(0x5e00, KiLowerPrivilegeVector, cr.iipa)
        VECTOR_EXIT(KiLowerPrivilegeVector)

        VECTOR_ENTRY(0x5f00, KiTakenBranchVector, cr.iipa)
        VECTOR_EXIT(KiTakenBranchVector)

        VECTOR_ENTRY(0x6000, KiSingleStepVector, cr.iipa)
        VECTOR_EXIT(KiSingleStepVector)

        VECTOR_ENTRY(0x6900, KiIA32ExceptionVector, r0)
        VECTOR_EXIT(KiIA32ExceptionVector)

        VECTOR_ENTRY(0x6a00, KiIA32InterceptionVector, r0)
        VECTOR_EXIT(KiIA32InterceptionVector)

        VECTOR_ENTRY(0x6b00, KiIA32InterruptionVector, r0)
        VECTOR_EXIT(KiIA32InterruptionVector)

        .org 0x7ff0
        { .mii
            break.m 0
            break.i 0
            break.i 0}

        .text
        .global     KiIvtBaseILog

        LEAF_ENTRY (KiSwitchToLogVector)

        movl      t0 = KiIvtBaseILog
        ;;

        mov       cr.iva = t0             // switch IVT to no log IVT
        ;;

        srlz.i

        LEAF_RETURN
        LEAF_EXIT (KiSwitchToLogVector)

        LEAF_ENTRY (KiDumpHistoryBuffer)

        mov    h25 = 681                        
        movl   h31 = KiPcr+ProcessorControlRegisterLength + 8
        mov    h24 = 680                        
        movl   h29 = KiPcr+ProcessorControlRegisterLength ;
        ;;                                      

        .reg.val h24, 680                       
        mov    h26 = msr[h24]                   
        .reg.val h25, 681                       
        mov    h27 = msr[h25]                   
        add    h24 = 2, h24                     
        ;;                                      
        st8    [h29] = h26, 16                  
        st8    [h31] = h27, 16                  
        add    h25 = 2, h25                     
        ;;                                      
        .reg.val h24, 682                       
        mov    h26 = msr[h24]                   
        .reg.val h25, 683                       
        mov    h27 = msr[h25]                   
        add    h24 = 2, h24                     
        ;;                                      
        st8    [h29] = h26, 16                  
        st8    [h31] = h27, 16                  
        add    h25 = 2, h25                     
        ;;                                      
        .reg.val h24, 684                       
        mov    h26 = msr[h24]                   
        .reg.val h24, 685                       
        mov    h27 = msr[h25]                   
        add    h24 = 2, h24                     
        ;;                                      
        st8    [h29] = h26, 16                  
        st8    [h31] = h27, 16                  
        add    h25 = 2, h25                     
        ;;                                      
        .reg.val h24, 686                       
        mov    h26 = msr[h24]                   
        .reg.val h25, 687                       
        mov    h27 = msr[h25]
        mov    h24 = 674                   
        ;;                                      
        st8    [h29] = h26                      
        st8    [h31] = h27, 8                   
        ;;                                      
        mov    h25 = msr[h24]                   
        mov    h26 = 675
        ;;                                      
        st8    [h31] = h25                      
        mov    h27 =  msr[h26]                             
        ;;                                                 
        dep    h27 = 0, r27, 8, 1       // enable HB
        ;;                                                 
        mov    msr[h26] = h27                              
        br.sptk b0 

        LEAF_EXIT (KiDumpHistoryBuffer)

        //
        // save it to the IH buffer
        //

        LEAF_ENTRY (KiLogInterruptEvent)
        
        // h29 Offset
        // h31 Extra
        // h28,h30 should not be used

        movl      h25 = KiPcr+PcInterruptionCount          
        ;;                                                 
        ld4.nt1   h26 = [h25]                              
        mov       h24 = MAX_NUMBER_OF_IHISTORY_RECORDS - 1 
        ;;                                                 
        add       h27 = 1, h26                             
        and       h26 = h24, h26                           
        add       h24 = 0x1000-PcInterruptionCount, h25    
        ;;                                                 
        st4.nta   [h25] = h27                              
        shl       h26 = h26, 5    
        ;;                                                 
        add       h27 = h26, h24                           
        mov       h24 = cr.iip                             
        ;;                                                 
        mov       h25 = cr.ipsr                            
        st8       [h27] = h29, 8        // Log Offset with h29
        ;;                           
        st8       [h27] = h24, 8        // Log IIP
        ;;                                                 
        st8       [h27] = h25, 8        // Log IPSR
        ;;                                                 
        st8       [h27] = h31           // Log Extra with h31                   
        br.sptk   b0                     
                                                           
        LEAF_EXIT (KiLogInterruptEvent)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\ktrace.c ===
/*++

Module Name:

    ktrace.c

Abstract:

    This module implements a tracing facility for use by all kernel mode
    modules in Windows NT.

Author:

    Roy D'Souza (rdsouza@gomez) 22-May-1996

Environment:

    User or Kernel mode.

Revision History:

--*/

#include "ki.h"
#if DBG && IA64_KTRACE

#include "ktrace.h"
#include "ktracep.h"


/***********************************************************************
Format of KTrace record (144 bytes)
***********************************************************************/
typedef struct _KTRACE_RECORD_ {
    ULONG              ModuleID;
    USHORT         MessageType;
    USHORT         MessageIndex;
    LARGE_INTEGER  SystemTime;
    ULONGLONG      Arg1;
    ULONGLONG      Arg2;
    ULONGLONG      Arg3;
    ULONGLONG      Arg4;
    ULONGLONG      Arg5;
    LARGE_INTEGER   HiResTimeStamp;
} KTRACE_RECORD, *PKTRACE_RECORD;

/* IF YOU MAKE ANY CHANGE TO THE ABOVE TYPEDEF YOU
ALSO NEED TO UPDATE THE CONSTANT RECORD_SIZE_IN_BYTES
IN FILE KTRACEP.H, SO THAT THE SIMDB MACROS WILL CONTINUE
TO WORK CORRECTLY
*/

/***********************************************************************
KTrace Private Data
***********************************************************************/


KTRACE_RECORD KTrace[MAXIMUM_PROCESSORS][KTRACE_LOG_SIZE];

//
// Current queue head
//
static ULONG KTraceQueueHead = 0;

//
// By default the mask is on for all:
//
static ULONG ModuleIDMask = 0xFFFFFFFF;

/***********************************************************************
KeEnableKTrace - selectively enable/disable client's rights to trace
***********************************************************************/
VOID
NTAPI
KeEnableKTrace (
        ULONG IDMask
           )
/*++

Routine Description:

    Selectively enable or disable individual module's abilities to
    write to the KTrace.

    By default all modules are permitted to write traces.

    Any kernel mode modules can call this routine to toggle write
    write permissions.
    
Arguments:

    IDMask

       A bit pattern which specifies the modules that are to be enabled.

Return Value:

    None.

--*/

{
    ModuleIDMask = IDMask;

    return;

} // KeEnableKTrace

/***********************************************************************
CurrentKTraceEntry -- return address of current entry and update trace index
***********************************************************************/
PKTRACE_RECORD CurrentEntry = 0;

PKTRACE_RECORD
NTAPI
KiCurrentKTraceEntry (
    )
/*++

Routine Description:

    Provide pointer to next trace entry for use by assembly code that updates trace
    table. 

Arguments:

    None.

Return Value:

    Pointer to next entry.
    
--*/
{   
   ULONG          CurrentProcessor;

   CurrentProcessor = KeGetCurrentProcessorNumber();
   if (CurrentProcessor > MAXIMUM_PROCESSORS) {
      DbgPrint("KTrace:CurrentKTraceEntry:KeGetCurrentProcessorNumber invalid\n");
      return NULL;
   }

   CurrentEntry = &KTrace[CurrentProcessor][KTraceQueueHead];
   KTraceQueueHead = (KTraceQueueHead + 1) % KTRACE_LOG_SIZE;

   return CurrentEntry;

} // CurrentKTraceEntry

/***********************************************************************
AddTrace - add an entry into the trace.
***********************************************************************/

NTSTATUS
NTAPI
KeAddKTrace (
    ULONG     ModuleID,
    USHORT    MessageType,
    USHORT    MessageIndex,
    ULONGLONG Arg1,
    ULONGLONG Arg2,
    ULONGLONG Arg3,
    ULONGLONG Arg4
    )
/*++

Routine Description:

    Add a record to the KTrace log. Can be called by anybody in the
    kernel. (Need to figure out a way to export this through ntoskrnl.lib
    so that drivers can access it.)

Arguments:

    ModuleID    identifies the client making this call. See ktrace.h
                for definitions.

    MessageType specifies the type/severity of the message (i.e. warning,
                error, checkpoint...) See ktrace.h

    Arg1-4      for unrestricted use by the client.

Return Value:

    Status

               STATUS_SUCCESS if successful.
               STATUS_UNSUCCESSFUL if failure.
--*/
{   
   ULONG           CurrentProcessor;
   LARGE_INTEGER  PerfCtr;
   NTSTATUS       Status  = STATUS_SUCCESS;
   LARGE_INTEGER  SystemTime;

   if (!(ModuleID & ModuleIDMask))
    return STATUS_UNSUCCESSFUL;

   CurrentProcessor = KeGetCurrentProcessorNumber();
   if (CurrentProcessor > MAXIMUM_PROCESSORS) {
      DbgPrint("KTrace:AddTrace:KeGetCurrentProcessorNumber invalid\n");
      return STATUS_UNSUCCESSFUL;
   }

   KTrace[CurrentProcessor][KTraceQueueHead].ModuleID     = ModuleID;
   KTrace[CurrentProcessor][KTraceQueueHead].MessageType  = MessageType;
   KTrace[CurrentProcessor][KTraceQueueHead].MessageIndex = MessageIndex;
   KTrace[CurrentProcessor][KTraceQueueHead].Arg1         = Arg1;
   KTrace[CurrentProcessor][KTraceQueueHead].Arg2         = Arg2;
   KTrace[CurrentProcessor][KTraceQueueHead].Arg3         = Arg3;
   KTrace[CurrentProcessor][KTraceQueueHead].Arg4         = Arg4;

   KeQuerySystemTime(&SystemTime);
   KTrace[CurrentProcessor][KTraceQueueHead].SystemTime = SystemTime;
#if 0
   Status = NtQueryPerformanceCounter(&PerfCtr, NULL);
   if (!NT_SUCCESS(Status)) {
      DbgPrint("NtQueryPerformanceCounter failed with %x\n", Status);
      return Status;
   }

   KTrace[CurrentProcessor][KTraceQueueHead].HiResTimeStamp = PerfCtr;
#endif
   KTraceQueueHead = (KTraceQueueHead + 1) % KTRACE_LOG_SIZE;

   return Status;

} // AddTrace

/***********************************************************************
QueryDumpKTraceBuffer - API query: selectively dump trace
***********************************************************************/
LONG
NTAPI
KeQueryDumpKTrace (
    ULONG       Processor,
    ULONG       StartEntry,
    ULONG       NumberOfEntries,
    ULONG       ModuleFilter,
    ULONG       MessageFilter,
    BOOLEAN     Sort)

/*++

Routine Description:

Arguments:
    
    ProcessorMask

      Specify the particular processor of interest.

    StartEntry

      The offset from the start of the queue to start dumping records.
      If this entry is 0 then the dumping starts from the head of the
      queue.
      If this argument is specified to be larger than the size of the
      KTrace buffer, then the dump wraps around appropriately.

    NumberOfEntries

      The number of log entries to dump starting from StartEntry.

    ModuleFilter

      A bit pattern specifying the modules of interest. See ktrace.h
      for a definition of modules. Only the logs of these modules are
      included in the dump. Bits representing undefined modules are
      ignored.

    MessageFilter

      A bit pattern specifying the subset of message types to dump. See
      ktrace.h for definitions of all message types.

    Sort

      Sort the output before dumping. Base the sort on the global NT
      timestamp. Most recent entries are dumped first. (NOT IMPLEMENTED
      YET).

Return Value:

    The number of records that were dumped.
    Returns -1 if error.
    
--*/

{
   ULONG Index = StartEntry;
   ULONG RecordCount = 0;

   //
   // Verify that we have a valid processor number:
   //
#if !defined(NT_UP)
   if (Processor > KeRegisteredProcessors) {
      DbgPrint("KTrace error: attempt to access invalid processor"
               "%d on a system with %d processors\n",
               Processor,
               KeRegisteredProcessors);
      return 0L;
   }
#else
   if (Processor > 0) {
      DbgPrint("KTrace error: attempted to access invalid processor"
               "%d on a uni-processor system\n",
               Processor);
   }
#endif

   //
   // Loop through the entire KTrace
   //
   while (NumberOfEntries > 0) {

      //
      // See if the current record matches the query criteria
      //
      if ((ModuleFilter  & KTrace[Processor][Index].ModuleID) &&
          (MessageFilter & KTrace[Processor][Index].MessageType)) {

         DumpRecord(Processor, Index);
         RecordCount++;
      }

      NumberOfEntries = NumberOfEntries - 1;
      Index = Index > 0 ? Index - 1 : KTRACE_LOG_SIZE - 1;
   }
   return RecordCount;

} // QueryDumpKTraceBuffer

/***********************************************************************
KePurgeKTrace - delete all records from the trace.
***********************************************************************/

VOID
NTAPI
KePurgeKTrace (
            )
{

   ULONG Index1, Index2;

   for (Index1 = 0; Index1 < KTRACE_LOG_SIZE; Index1++) {
      for (Index2 = 0; Index2 < MAXIMUM_PROCESSORS; Index2++) {
         KTrace[Index2][Index1].ModuleID       = 0;
     KTrace[Index2][Index1].MessageType    = 0;
     KTrace[Index2][Index1].MessageIndex   = 0;
         KTrace[Index2][Index1].SystemTime.HighPart = 0;
         KTrace[Index2][Index1].SystemTime.LowPart  = 0;
     KTrace[Index2][Index1].Arg1           = 0;
     KTrace[Index2][Index1].Arg2           = 0;
     KTrace[Index2][Index1].Arg3           = 0;
     KTrace[Index2][Index1].Arg4           = 0;
     KTrace[Index2][Index1].HiResTimeStamp.HighPart = 0;
     KTrace[Index2][Index1].HiResTimeStamp.LowPart = 0;
      }
   }
}

/***********************************************************************
DumpRecord - dump a single record specified by processor number & index.
***********************************************************************/
VOID
NTAPI
DumpRecord (IN ULONG ProcessorNumber,
            IN ULONG Index)
/*++

Routine Description:

   Dumps out the specified record in the trace associated with the
   specified processor out to the remote debugger console.

Arguments:

   ProcessorNumber

      The processor whose associated trace log is to be accessed.

   Index

      The offset of the record in the trace to be dumped.

Return Value:

   None.

--*/
{

#if !defined(NT_UP)
   if (ProcessorNumber > KeRegisteredProcessors) {
      DbgPrint("KTrace:DumpRecord:"
               "illegal processor number %x in a %x-processor system\n",
               ProcessorNumber, KeRegisteredProcessors);
      return;
   }
#else
   if (ProcessorNumber > 0) {
      DbgPrint("KTrace:DumpRecord:"
               "illegal processor %x in a uni-processor system\n",
               ProcessorNumber);
   }
#endif

   DbgPrint("Dumping Record Index [%ld], Processor = [%ld]\n",
        Index);
   DbgPrint("\tModuleID = [%lx]\n",
        KTrace[ProcessorNumber][Index].ModuleID);
   DbgPrint("\tMessageType = [%lx]\n",
        KTrace[ProcessorNumber][Index].MessageType);
   DbgPrint("\tMessageIndex = [%lx]\n",
        KTrace[ProcessorNumber][Index].MessageIndex);
   DbgPrint("\tArg1= [%lx%LX]\n",
        KTrace[ProcessorNumber][Index].Arg1,
        KTrace[ProcessorNumber][Index].Arg1);
   DbgPrint("\tArg2= [%lx%LX]\n",
        KTrace[ProcessorNumber][Index].Arg2,
        KTrace[ProcessorNumber][Index].Arg2);
   DbgPrint("\tArg3= [%lx%LX]\n",
        KTrace[ProcessorNumber][Index].Arg3,
        KTrace[ProcessorNumber][Index].Arg3);
   DbgPrint("\tArg4= [%lx%LX]\n",
        KTrace[ProcessorNumber][Index].Arg4,
        KTrace[ProcessorNumber][Index].Arg4);
} // DumpRecord


#endif // DBG

// end ktrace.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\ktracep.h ===
/*++

Module Name:

    ktracep.h

Abstract:

	Private include for ktrace.c and ktrace.mac to use.

Author:

    Roy D'Souza (rdsouza@gomez.sc.intel.com) 22-April-1996

Environment:

    User or Kernel mode.

Revision History:

--*/

/* The number of slots in the trace */
#define KTRACE_LOG_SIZE 0x400

/* The record size in bytes
IF YOU MAKE A CHANGE TO THE KTRACE TYPEDEF IN KTRACE.C
YOU NEED TO RE-CALCULATE THE SIZE IN BYTES AND UPDATE THE
FOLLOWING: */
#define RECORD_SIZE_IN_BYTES 0x70

/* The maximum value a module ID can take */
#define MAX_MODULE_ID 0x80000000

/* The maximum value a message type can take */
#define MAX_MESSAGE_TYPE 0x10000

/* The maximum value a message index can take */
#define MAX_MESSAGE_INDEX 0x10000

/***********************************************************************
Message Types:
***********************************************************************/

#define MESSAGE_INFORMATION 0x1
#define MESSAGE_WARNING     0x2
#define MESSAGE_ERROR       0x4

/***********************************************************************
Module IDs:
***********************************************************************/

#define MODULE_INIT  0x1
#define MODULE_KE    0x2
#define MODULE_EX    0x4
#define MODULE_MM    0x8
#define MODULE_LPC   0x10
#define MODULE_SE    0x20
#define MODULE_TDI   0x40
#define MODULE_RTL   0x80
#define MODULE_PO    0x100
#define MODULE_PNP   0x200

#define DRIVER_1    0x10000000
#define DRIVER_2    0x20000000
#define DRIVER_3    0x40000000
#define DRIVER_4    0x80000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\mpipi.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    mpipi.c

Abstract:

    This module implements MIPS specific MP routine.

Author:

    Bernard Lint 26-Jun-1996

Environment:

    Kernel mode only.

Revision History:

    Based on version of David N. Cutler 24-Apr-1993

--*/

#include "ki.h"

VOID
KiSaveHigherFPVolatile (
    PFLOAT128 SaveArea
    );


VOID
KiRestoreProcessorState (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function moves processor register state from the current
    processor context structure in the processor block to the
    specified trap and exception frames.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)
    PKPRCB Prcb;

    //
    // Get the address of the current processor block and move the
    // specified register state from the processor context structure
    // to the specified trap and exception frames
    //

    Prcb = KeGetCurrentPrcb();
    KeContextToKframes(TrapFrame,
                       ExceptionFrame,
                       &Prcb->ProcessorState.ContextFrame,
                       CONTEXT_FULL,
                       (KPROCESSOR_MODE)TrapFrame->PreviousMode);

    KiRestoreProcessorControlState(&Prcb->ProcessorState);
#endif // !defined(NT_UP)

    return;
}

VOID
KiSaveProcessorState (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function moves processor register state from the specified trap
    and exception frames to the processor context structure in the current
    processor block.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)
    PKPRCB Prcb;

    //
    // Get the address of the current processor block and move the
    // specified register state from specified trap and exception
    // frames to the current processor context structure.
    //

    Prcb = KeGetCurrentPrcb();
    if (KeGetCurrentThread()->Teb) {
        KiSaveHigherFPVolatile((PFLOAT128)GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(KeGetCurrentThread()->StackBase));
    }
    Prcb->ProcessorState.ContextFrame.ContextFlags = CONTEXT_FULL;
    KeContextFromKframes(TrapFrame,
                         ExceptionFrame,
                         &Prcb->ProcessorState.ContextFrame);

    //
    // Save ISR in special registers
    //

    Prcb->ProcessorState.SpecialRegisters.StISR = TrapFrame->StISR;

    //
    // Save the current processor control state.
    //

    KiSaveProcessorControlState(&Prcb->ProcessorState);
#endif // !defined(NT_UP)

    return;
}

BOOLEAN
KiIpiServiceRoutine (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:


    This function is called at IPI_LEVEL to process any outstanding
    interprocess request for the current processor.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame

Return Value:

    A value of TRUE is returned, if one of more requests were service.
    Otherwise, FALSE is returned.

--*/

{
#if !defined(NT_UP)

    ULONG RequestSummary;

    //
    // Process any outstanding IPI requests
    //

    RequestSummary = KiIpiProcessRequests();

    //
    // If freeze is requested, then freeze target execution.
    //

    if ((RequestSummary & IPI_FREEZE) != 0) {
        KiFreezeTargetExecution(TrapFrame, ExceptionFrame);
    }

    return ((RequestSummary & ~IPI_FREEZE) != 0);

#else
    return TRUE;
#endif // !defined(NT_UP)
}

ULONG
KiIpiProcessRequests (
    VOID
    )

/*++

Routine Description:

    This routine processes interprocessor requests and returns a summary
    of the requests that were processed.

Arguments:

    None.

Return Value:

    The request summary is returned as the function value.

--*/
{

#if !defined(NT_UP)
    ULONG RequestSummary;
    PKPRCB SignalDone;
    PKPRCB Prcb = KeGetCurrentPrcb();

    RequestSummary = (ULONG)InterlockedExchange((PLONG)&Prcb->RequestSummary, 0);

    //
    // If a packet is ready, then get the address of the requested function
    // and call the function passing the address of the packet address as a
    // parameter.
    //

    SignalDone = (PKPRCB)( (ULONG_PTR)Prcb->SignalDone & ~(ULONG_PTR)1 );

    if (SignalDone != 0) {
     
        Prcb->SignalDone = 0;

        (*SignalDone->WorkerRoutine) ((PKIPI_CONTEXT)SignalDone,
                                      SignalDone->CurrentPacket[0], 
                                      SignalDone->CurrentPacket[1], 
                                      SignalDone->CurrentPacket[2]);

    } 

    if ((RequestSummary & IPI_APC) != 0) {
        KiRequestSoftwareInterrupt (APC_LEVEL);
    } else if ((RequestSummary & IPI_DPC) != 0) {
        KiRequestSoftwareInterrupt (DISPATCH_LEVEL);
    }

    return RequestSummary;
#else
    return 0;
#endif // !defined(NT_UP)
}


VOID
KiIpiSend (
    IN KAFFINITY TargetProcessors,
    IN KIPI_REQUEST IpiRequest
    )

/*++

Routine Description:

    This routine requests the specified operation on the target set of
    processors.

Arguments:

    TargetProcessors (a0) - Supplies the set of processors on which the
        specified operation is to be executed.

    IpiRequest (a1) - Supplies the request operation mask.

Return Value:

    None.

--*/

{
#if !defined(NT_UP)
    ULONG RequestSummary;
    KAFFINITY NextProcessors;
    ULONG Next;

    //
    // Loop through the target processors and send the packet to the specified
    // recipients.
    //

    NextProcessors = TargetProcessors;
    Next = 0;

    while (NextProcessors != 0) {

        if ((NextProcessors & 1) != 0) {

            do {
            
                RequestSummary = KiProcessorBlock[Next]->RequestSummary;

            } while(InterlockedCompareExchange(
                (PLONG) &KiProcessorBlock[Next]->RequestSummary, 
                (LONG) (RequestSummary | IpiRequest),
                (LONG) RequestSummary) != (LONG) RequestSummary);  
        }

        NextProcessors = NextProcessors >> 1;
        
        Next = Next + 1;

    }
    HalRequestIpi (TargetProcessors);
#endif

    return;
}


VOID
KiIpiSendPacket (
    IN KAFFINITY TargetProcessors,
    IN PKIPI_WORKER WorkerFunction,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This routine executes the specified worker function on the specified
    set of processors.

Arguments:

    TargetProcessors (a0) - Supplies the set of processors on which the
        specified operation is to be executed.

    WorkerFunction (a1) - Supplies the address of the worker function.

    Parameter1 - Parameter3 (a2, a3, 4 * 4(sp)) - Supplies worker
        function specific parameters.

Return Value:

    None.

--*/
{
#if !defined(NT_UP)
    PKPRCB Prcb;
    KAFFINITY NextProcessors;
    ULONG Next;

    Prcb = KeGetCurrentPrcb();
    Prcb->TargetSet = TargetProcessors;
    Prcb->WorkerRoutine = WorkerFunction;
    Prcb->CurrentPacket[0] = Parameter1;
    Prcb->CurrentPacket[1] = Parameter2;
    Prcb->CurrentPacket[2] = Parameter3;

    //
    // synchronize memory access
    // 

    __mf();
    
    //
    // The low order bit of the packet address is set if there is
    // exactly one target recipient. Otherwise, the low order bit
    // of the packet address is clear.
    //

    if (((TargetProcessors) & ((TargetProcessors) - 1)) == 0) {
        (ULONG_PTR) Prcb |= 0x1;
    } else {
        Prcb->PacketBarrier = 1;
    }

    //
    // Loop through the target processors and send the packet to the specified
    // recipients.
    //

    NextProcessors = TargetProcessors;
    Next = 0;

    while (NextProcessors != 0) {

        if ((NextProcessors & 1) != 0) {
            
            while(InterlockedCompareExchangePointer(
                (PVOID)&KiProcessorBlock[Next]->SignalDone, 
                (PVOID)Prcb,
                (PVOID)0) != (PVOID)0);

        }
            
        NextProcessors = NextProcessors >> 1;
        
        Next = Next + 1;

    }
    HalRequestIpi (TargetProcessors);
#endif    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\ktrace.h ===
/*++

Copyright (c) 1996  Intel Corporation

Module Name:

    ktrace.h

Abstract:

    This module is an include file for use by all clients of the
    KTrace utility.

    By default, all kernel modules which have this module automatically
    included since an include for this file will exist in kx<arch>.h

Author:

    Roy D'Souza (rdsouza@gomez) 22-April-1996

Environment:

    User or Kernel mode.

Revision History:

--*/

#ifndef _KTRACE_H_
#define _KTRACE_H_

/***********************************************************************
Message Types:
***********************************************************************/

#define MESSAGE_INFORMATION 0x1
#define MESSAGE_WARNING     0x2
#define MESSAGE_ERROR       0x4

/***********************************************************************
Module IDs:
***********************************************************************/

#define MODULE_INIT  0x1
#define MODULE_KE    0x2
#define MODULE_EX    0x4
#define MODULE_MM    0x8
#define MODULE_LPC   0x10
#define MODULE_SE    0x20
#define MODULE_TDI   0x40
#define MODULE_RTL   0x80
#define MODULE_PO    0x100
#define MODULE_PNP   0x200

#define DRIVER_1    0x10000000
#define DRIVER_2    0x20000000
#define DRIVER_3    0x40000000
#define DRIVER_4    0x80000000

/***********************************************************************
Prototypes:
***********************************************************************/

//
// Add an entry. Routine will determine current processor.
//

#if DBG
NTSTATUS
KeAddKTrace (
    ULONG  ModuleID,
    USHORT MessageType,
    USHORT MessageIndex,
    ULONGLONG Arg1,
    ULONGLONG Arg2,
    ULONGLONG Arg3,
    ULONGLONG Arg4
    );
#else
#define KeAddKTrace
#endif


//
// Selectively dump trace.
//
#if DBG
ULONG
__stdcall
KeDumpKTrace (
    ULONG ProcessorNumber,
    ULONG StartEntry,
    ULONG NumberOfEntries,
    ULONGLONG ModuleFilter,
    ULONGLONG MessageFilter,
    BOOLEAN Sort);
#else
#define KeDumpKTrace
#endif

//
// Selectively permit kernel modules to write to trace.
//
#if DBG
VOID
__stdcall
KeEnableKTrace (
        ULONG IDMask
    );
#else
#define KeEnableKTrace
#endif

#if DBG
VOID
NTAPI // __stdcall
DumpRecord (IN ULONG ProcessorNumber,
            IN ULONG Index);
#else
#define DumpRecord
#endif

#endif // _KTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\mpipis.s ===
#include "ksia64.h"

        .file "mpipis.s"
        SBTTL("Signal Packet Done")
//++
//
// VOID
// KiIpiSignalPacketDone (
//    IN PKIPI_CONTEXT SignalDone
//    );
//
// Routine Description:
//
//    This routine signals that a processor has completed a packet by
//    clearing the calling processor's set member of the requesting
//    processor's packet.
//
// Arguments:
//
//    SignalDone (a0) - Supplies a pointer to the processor block of the
//        sending processor.
//
//        N.B. The low order bit of signal done is set if the target set
//             has one and only one bit set.
//
// Return Value:
//
//    None.
//
//--

#if !defined(NT_UP)

        LEAF_ENTRY(KiIpiSignalPacketDone)

        tbit.nz pt0 = a0, 0
        dep     a0 = 0, a0, 0, 1
        ;;

        add     t1 = PbTargetSet, a0
        movl    t0 = KiPcr+PcSetMember
        ;;

 (pt0)  st4.rel [t1] = r0                    // clear target set
        add     t5 = PbPacketBarrier, a0
 (pt0)  br.ret.spnt brp

        ld4.nt1 v0 = [t1]
        ld4     t3 = [t0]
        ;;

Kispd10:
        mov     ar.ccv = v0
        xor     t4 = v0, t3
        ;;
        cmp.eq  pt3, pt4 = 0, t4
        ;;

 (pt3)  st4     [t1] = r0                    // last processor clears target set
        mov     t2 = v0

 (pt4)  cmpxchg4.acq v0 = [t1], t4
 (pt3)  st4.rel [t5] = r0                    // last processor clears barrier
 (pt3)  br.ret.spnt brp
        ;;

        cmp.ne  pt1, pt2 = v0, t2
 (pt2)  br.ret.sptk brp
 (pt1)  br.spnt Kispd10
        ;;

        LEAF_EXIT(KiIpiSignalPacketDone)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\ntfpia64.h ===
//
// Floating Point State Structure
//

typedef struct _FLOATING_POINT_STATE {
    PVOID TrapFrame;
    PVOID ExceptionFrame;
} FLOATING_POINT_STATE, *PFLOATING_POINT_STATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\qlock.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    qlock.c

Abstract:

    This module contains the code to emulate the operation of queued spin
    locks using ordinary spin locks interfaces.

Author:

    David N. Cutler 13-Feb-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#if defined(NT_UP)
#undef KeAcquireQueuedSpinLockRaiseToSynch
#undef KeAcquireQueuedSpinLock
#undef KeReleaseQueuedSpinLock
#undef KeTryToAcquireQueuedSpinLockRaiseToSynch
#undef KeTryToAcquireQueuedSpinLock
#undef KeAcquireQueuedSpinLockAtDpcLevel
#undef KeReleaseQueuedSpinLockFromDpcLevel
#endif


VOID
FASTCALL
KeAcquireQueuedSpinLockAtDpcLevel (
    IN PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    This function acquires a queued spin lock at DPC level.

Arguments:

    LockQueue - Supplies a pointer to a lock queue entry in the PRCB.

Return Value:

    None.

--*/

{

    KiAcquireSpinLock(LockQueue->Lock);
    return;
}

VOID
FASTCALL
KeReleaseQueuedSpinLockFromDpcLevel (
    IN PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    This function releases a queued spin lock at DPC level.

Arguments:

    LockQueue - Supplies a pointer to a lock queue entry in the PRCB.

Return Value:

    None.

--*/

{

    KiReleaseSpinLock(LockQueue->Lock);
    return;
}

KIRQL
FASTCALL
KeAcquireQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )

/*++

Routine Description:

    This function acquires a queued spin lock and raises IRQL to DPC
    level.

Arguments:

    Number - Supplies the lock queue number.

Return Value:

    The previous IRQL is returned as the function value.

--*/

{

    PKSPIN_LOCK Lock;
    KIRQL OldIrql;

    //
    // N.B. It is safe to use any PRCB address since the backpointer
    //      to the actual spinlock is always the same.
    //

    Lock = KeGetCurrentPrcb()->LockQueue[Number].Lock;
    KeAcquireSpinLock(Lock, &OldIrql);
    return OldIrql;
}

VOID
FASTCALL
KeReleaseQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function releases a queued spin lock and lowers IRQL to the
    previous level.

Arguments:

    LockQueue - Supplies a pointer to a lock queue entry in the PRCB.

    Irql - Supplies the previos IRQL level.

Return Value:

    None.

--*/

{

    PKSPIN_LOCK Lock;

    //
    // N.B. It is safe to use any PRCB address since the backpointer
    //      to the actual spinlock is always the same.
    //

    Lock = KeGetCurrentPrcb()->LockQueue[Number].Lock;
    KeReleaseSpinLock(Lock, OldIrql);
    return;
}

LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLock(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN PKIRQL OldIrql
    )

/*++

Routine Description:

    This function attempts to acquire a queued spin lock and raises IRQL
    to DPC level.

Arguments:

    Number - Supplies the lock queue number.

    OldIrql - Supplies a pointer to a variable that receives the previous
        IRQL value.

Return Value:

    A value of TRUE is returned if the spin lock is acquired. Otherwise,
    a value of FALSE is returned.

--*/

{

    PKSPIN_LOCK Lock;

    //
    // N.B. It is safe to use any PRCB address since the backpointer
    //      to the actual spinlock is always the same.
    //

    Lock = KeGetCurrentPrcb()->LockQueue[Number].Lock;
    return KeTryToAcquireSpinLock(Lock, OldIrql);
}

KIRQL
FASTCALL
KeAcquireQueuedSpinLockRaiseToSynch (
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )

/*++

Routine Description:

    This function acquires a queued spin lock and raises IRQL to synch
    level.

Arguments:

    Number - Supplies the lock queue number.

Return Value:

    The previous IRQL is returned as the function value.

--*/

{

    PKSPIN_LOCK Lock;

    //
    // N.B. It is safe to use any PRCB address since the backpointer
    //      to the actual spinlock is always the same.
    //

    Lock = KeGetCurrentPrcb()->LockQueue[Number].Lock;
    return KeAcquireSpinLockRaiseToSynch(Lock);
}

LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLockRaiseToSynch(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN PKIRQL OldIrql
    )

/*++

Routine Description:

    This function attempts to acquire a queued spin lock and raises IRQL
    to synch level.

Arguments:

    Number - Supplies the lock queue number.

    OldIrql - Supplies a pointer to a variable that receives the previous
        IRQL value.

Return Value:

    A value of TRUE is returned if the spin lock is acquired. Otherwise,
    a value of FALSE is returned.

--*/

{

    PKSPIN_LOCK Lock;

    //
    // N.B. It is safe to use any PRCB address since the backpointer
    //      to the actual spinlock is always the same.
    //

    Lock = KeGetCurrentPrcb()->LockQueue[Number].Lock;
    *OldIrql = KeAcquireSpinLockRaiseToSynch(Lock);
    return TRUE;
}

VOID
KeAcquireInStackQueuedSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

{

#if !defined(NT_UP)

    LockHandle->LockQueue.Next = NULL;
    LockHandle->LockQueue.Lock = SpinLock;

#endif

    LockHandle->OldIrql = KeRaiseIrqlToDpcLevel();

#if !defined(NT_UP)

    KeAcquireQueuedSpinLockAtDpcLevel(&LockHandle->LockQueue);

#endif

    return;
}

VOID
KeAcquireInStackQueuedSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

{

#if !defined(NT_UP)

    LockHandle->LockQueue.Next = NULL;
    LockHandle->LockQueue.Lock = SpinLock;

#endif

    LockHandle->OldIrql = KeRaiseIrqlToSynchLevel();

#if !defined(NT_UP)

    KeAcquireQueuedSpinLockAtDpcLevel(&LockHandle->LockQueue);

#endif

    return;
}

VOID
KeReleaseInStackQueuedSpinLock (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

{

#if !defined(NT_UP)

    KeReleaseQueuedSpinLockFromDpcLevel(&LockHandle->LockQueue);

#endif

    KeLowerIrql(LockHandle->OldIrql);
    return;
}

VOID
KeAcquireInStackQueuedSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

{

#if !defined(NT_UP)

    LockHandle->LockQueue.Next = NULL;
    LockHandle->LockQueue.Lock = SpinLock;
    KeAcquireQueuedSpinLockAtDpcLevel(&LockHandle->LockQueue);

#endif

    return;
}

VOID
KeReleaseInStackQueuedSpinLockFromDpcLevel (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

{

#if !defined(NT_UP)

    KeReleaseQueuedSpinLockFromDpcLevel(&LockHandle->LockQueue);

#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\miscs.s ===
//++
//
// Module Name:
//
//    miscs.s
//
// Abstract:
//
//    This module implements machine dependent miscellaneous kernel functions.
//    Functions are provided to request a software interrupt, continue thread
//    execution, flush TLBs and write buffers, and perform last chance
//    exception processing.
//
// Author:
//
//    William K. Cheung (wcheung) 3-Nov-1995
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//    7-Jul-1997   bl    Updated to EAS2.3
//
//    27-Feb-1996  wc    Updated to EAS2.1
//
//    11-Jan-1996  wc    Set up register sp to point to the exception frame
//                       on the stack before calling KiSaveExceptionFrame and
//                       branching directly to KiExceptionExit.
//
//--

#include "ksia64.h"

//
// Global symbols
//

        PublicFunction(KiContinue)
        PublicFunction(KiSaveExceptionFrame)
        PublicFunction(KeTestAlertThread)
        PublicFunction(KiExceptionExit)
        PublicFunction(KiRaiseException)
        PublicFunction(KiLoadKernelDebugRegisters)
        PublicFunction(KeIsExecutingDpc)



//
//++
//
// NTSTATUS
// NtContinue (
//    IN PCONTEXT ContextRecord,
//    IN BOOLEAN TestAlert
//    )
//
// Routine Description:
//
//    This routine is called as a system service to continue execution after
//    an exception has occurred. Its functions is to transfer information from
//    the specified context record into the trap frame that was built when the
//    system service was executed, and then exit the system as if an exception
//    had occurred.
//
// Arguments:
//
//    ContextRecord (a0) - Supplies a pointer to a context record.
//
//    TestAlert (a1) - Supplies a boolean value that specifies whether alert
//       should be tested for the previous processor mode.
//
//    N.B. Register t0 is assumed to contain the address of a trap frame.
//
// Return Value:
//
//    Normally there is no return from this routine. However, if the specified
//    context record is misaligned or is not accessible, then the appropriate
//    status code is returned.
//
//--

        NESTED_ENTRY(NtContinue)

        NESTED_SETUP(2,4,3,0)
        .fframe   ExceptionFrameLength
        add       sp = -ExceptionFrameLength, sp

        PROLOGUE_END

//
// Transfer information from the context record to the exception and trap
// frames.
//
// N.B. Must zero the loadrs bit-field of Context->RsRSC
//

        add       t1 = TrStIPSR, t0             // -> TrapFrame->StIPSR
        mov       loc2 = t0
        ;;

        ld8       loc3 = [t1]                   // load TrapFrame->StIPSR
        mov       out0 = a0                     // context frame address
        ;;

        add       out1 = STACK_SCRATCH_AREA, sp // -> exception frame
        mov       out2 = t0                     // trap frame address
        br.call.sptk.many brp = KiContinue
        ;;

//
// If KiContinue() returns success, then exit via the exception exit code.
// Otherwise, return to the system service dispatcher.
//
// Check to determine if alert should be tested for the previous processor
// mode and restore the previous mode in the thread object.
//
// Application that invokes the NtContinue() system service must have
// flushed all stacked registers to the backing store.  Sanitize the
// bspstore to be equal to bsp; otherwise, some stacked GRs will not be
// restored from the backing store.
//

        add       t0 = TrStIPSR, loc2
        movl      t7 = 1 << PSR_TB | 1 << PSR_DB | 1 << PSR_SS | 1 << PSR_PP
        ;;

        ld8       t8 = [t0]
        cmp.ne    pt0 = zero, v0                // if ne, transfer failed.
        ;;
 (pt0)  dep       t7 = 1, t7, PSR_LP, 1         // capture psr.lp if failed
        ;;
        add       t2 = TrTrapFrame, loc2
        andcm     t8 = t8, t7                   // Clear old values
        and       loc3 = t7, loc3               // capture psr.tb, db, ss, pp
        ;;
        or        t8 = loc3, t8
        ;;

        st8       [t0] = t8
        add       t3 = TrRsRSC, loc2
 (pt0)  br.cond.spnt Nc10                       // jump to Nc10 if pt0 is TRUE
        ;;

//
// Restore the nonvolatile machine state from the exception frame
// and exit the system via the exception exit code.
//

        ld8       t5 = [t2]                     // get old trap frame address
        movl      t1 = KiPcr + PcCurrentThread  // -> current thread
        ;;

        ld8       t0 = [t3], TrPreviousMode-TrRsRSC // load TrapFrame->RsRSC
        ld8       t4 = [t1]                     // get current thread address
        cmp4.ne   pt1 = zero, a1                // if ne, test for alert
        ;;

        ld4       t6 = [t3], TrRsRSC-TrPreviousMode // get old previous mode
        dep       t0 = r0, t0, RSC_MBZ1, RSC_LOADRS_LEN // zero preload field
        add       t7 = ThPreviousMode, t4
        ;;

 (pt1)  ld1       out0 = [t7]                   // get current previous mode
        st8       [t3] = t0                     // save TrapFrame->RsRSC
        add       t8 = ThTrapFrame, t4
        ;;

        st8       [t8] = t5                     // restore old trap frame addr
        st1       [t7] = t6                     // restore old previous mode
 (pt1)  br.call.spnt.many brp = KeTestAlertThread
        ;;

//
// sp -> stack scratch area/FP save area/exception frame/trap frame
//
// Set up for branch to KiExceptionExit
//
//      s0 = trap frame
//      s1 = exception frame
//
// N.B. predicate register alias pUstk & pKstk must be the same as trap.s
//      and they must be set up correctly upon entry into KiExceptionExit.
//
// N.B. The exception exit code will restore the exception frame & trap frame
//      and then rfi to user code. pUstk is set to 1 while pKstk is set to 0.
//

        pUstk     = ps3
        pKstk     = ps4

        //
        // Interrupts must be disabled before calling KiExceptionExit
        // because the unwind code cannot unwind from that point.
        //
        
        FAST_DISABLE_INTERRUPTS
        cmp.eq      pUstk, pKstk = zero, zero
        add         s1 = STACK_SCRATCH_AREA, sp
        mov         s0 = loc2
        br          KiExceptionExit

Nc10:

        .restore
        add         sp = ExceptionFrameLength, sp
        NESTED_RETURN

        NESTED_EXIT(NtContinue)

//++
//
// NTSTATUS
// NtRaiseException (
//    IN PEXCEPTION_RECORD ExceptionRecord,
//    IN PCONTEXT ContextRecord,
//    IN BOOLEAN FirstChance
//    )
//
// Routine Description:
//
//    This routine is called as a system service to raise an exception.
//    The exception can be raised as a first or second chance exception.
//
// Arguments:
//
//    ExceptionRecord (a0) - Supplies a pointer to an exception record.
//
//    ContextRecord (a1) - Supplies a pointer to a context record.
//
//    FirstChance (a2) - Supplies a boolean value that determines whether
//       this is the first (TRUE) or second (FALSE) chance for dispatching
//       the exception.
//
//    N.B. Register t0 is assumed to contain the address of a trap frame.
//
// Return Value:
//
//    Normally there is no return from this routine. However, if the specified
//    context record or exception record is misaligned or is not accessible,
//    then the appropriate status code is returned.
//
//--

        NESTED_ENTRY(NtRaiseException)

        NESTED_SETUP(3,3,5,0)
        .fframe   ExceptionFrameLength
        add       sp = -ExceptionFrameLength, sp
        ;;

        PROLOGUE_END

//
// Pop this trap frame off the thread list.
//

        add         t2 = TrTrapFrame, t0
        movl        t1 = KiPcr + PcCurrentThread     
        ;;
        
        ld8         t1 = [t1];          // Get current thread.
        ld8         t2 = [t2];          // Load previous trap frame
        ;;
        add         t1 = ThTrapFrame, t1
        
                
//
// Save nonvolatile states.
//

        add       out0 = STACK_SCRATCH_AREA, sp
        mov       loc2 = t0                   // save pointer to trap frame
        ;;
        st8       [t1] = t2
        br.call.sptk brp = KiSaveExceptionFrame

//
// Call the raise exception kernel routine wich will marshall the argments
// and then call the exception dispatcher.
//

        add       out2 = STACK_SCRATCH_AREA, sp // -> exception frame
        mov       out1 = a1
        mov       out0 = a0

        add       out4 = zero, a2
        mov       out3 = t0
        br.call.sptk.many brp = KiRaiseException

//
// If the raise exception routine returns success, then exit via the exception
// exit code.  Otherwise, return to the system service dispatcher.
//
// N.B. The exception exit code will restore the exception frame & trap frame
//      and then rfi to user code.
//
// Set up for branch to KiExceptionExit
//
//      s0 = trap frame
//      s1 = exception frame
//

        pUstk     = ps3
        pKstk     = ps4


        cmp4.ne   p0, pt1 = zero, v0            // if ne, dispatch failed.
        ;;

        //
        // Interrupts must be disabled before calling KiExceptionExit
        // because the unwind code cannot unwind from that point.
        //
        
(pt1)   FAST_DISABLE_INTERRUPTS        
(pt1)   mov       s0 = loc2                     // copy trap frame pointer
(pt1)   add       s1 = STACK_SCRATCH_AREA, sp

(pt1)   cmp.eq    pUstk, pKstk = zero, zero
(pt1)   br.cond.sptk.many KiExceptionExit

        .restore
        add         sp = ExceptionFrameLength, sp
        NESTED_RETURN

        NESTED_EXIT(NtRaiseException)


//++
//
// VOID
// KeFillLargeEntryTb (
//    IN HARDWARE_PTE Pte[],
//    IN PVOID Virtual,
//    IN ULONG PageSize
//    )
//
// Routine Description:
//
//    This function fills a large translation buffer entry.
//
//    N.B. It is assumed that the large entry is not in the TB and therefore
//      the TB is not probed.
//
// Arguments:
//
//    Pte (a0) - Supplies a pointer to the page table entries that are to be
//       written into the TB.
//
//    Virtual (a1) - Supplies the virtual address of the entry that is to
//       be filled in the translation buffer.
//
//    PageSize (a2) - Supplies the size of the large page table entry.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeFillLargeEntryTb)


        rPte    = t0
        rScnd   = t1
        ridtr   = t2
        rid     = t3
        rDtr    = t4

        rTb             = t6
        rTbPFN          = t7
        rpAttr          = t8
        rAttrOffset     = t9


        shr.u   rScnd = a2, 6           // mask off page size fields
        ;;
        shl     rScnd = rScnd, 6        //
        ;;
        and     rScnd = a1, rScnd       // examine the virtual address bit
        ;;
        cmp.eq  pt0, pt1 = r0, rScnd
        shl     ridtr = a2, PS_SHIFT
        mov     rDtr = DTR_VIDEO_INDEX
        ;;

        rsm     1 << PSR_I              // turn off interrupts
(pt0)   add     a0 = (1 << PTE_SHIFT), a0
        ;;

        ld8     rPte = [a0]             // load PTE
        rsm     1 << PSR_IC             // interrupt is off, now reset PSR.ic
        ;;

        srlz.d                          // serialize

        mov     cr.itir = ridtr         // idtr for insertion
        mov     cr.ifa = a1             // ifa for insertion
        ;;

        itr.d   dtr[rDtr] = rPte
        ssm     1 << PSR_IC             // set PSR.ic bit again
        ;;

        srlz.i                          // I serialize
        ssm     1 << PSR_I
        LEAF_RETURN

        LEAF_EXIT(KeFillLargeEntryTb)         // return


//++
//
// VOID
// KeFillFixedEntryTb (
//    IN HARDWARE_PTE Pte[],
//    IN PVOID Virtual,
//    IN ULONG PageSize,        
//    IN ULONG Index
//    )
//
// Routine Description:
//
//    This function fills a fixed translation buffer entry.
//
// Arguments:
//
//    Pte (a0) - Supplies a pointer to the page table entries that are to be
//       written into the TB.
//
//    Virtual (a1) - Supplies the virtual address of the entry that is to
//       be filled in the translation buffer.
//
//    Index (a2) - Supplies the index where the TB entry is to be written.
//
// Return Value:
//
//    None.
//
// Comments:
//
//
//
//--
        LEAF_ENTRY(KeFillFixedEntryTb)


        rPte    = t0
        rScnd   = t1
        ridtr   = t2
        rid     = t3
        rIndex  = t4

        rTb             = t6
        rTbPFN          = t7
        rpAttr          = t8
        rAttrOffset     = t9


        rsm     1 << PSR_I              // reset PSR.i
        ld8     rPte = [a0]             // load PTE
        shl     ridtr = a2, PS_SHIFT
        ;;

        rsm     1 << PSR_IC             // interrupt is off, now reset PSR.ic
        tbit.z  pt0, pt1 = a3, 31       // check the sign bit
                                        // if 1 ITR, otherwise DTR
        ;;
        srlz.d                          // serialize
        and     rIndex = 0xf, a3
        ;;

        mov     cr.itir = ridtr         // idtr for insertion
        mov     cr.ifa = a1             // ifa for insertion
        ;;

(pt0)   itr.d   dtr[rIndex] = rPte      // insert into DTR
(pt1)   itr.i   itr[rIndex] = rPte      // insert into ITR

        ssm     1 << PSR_IC             // set PSR.ic bit again
        ;;

        srlz.i                          // I serialize

#if DBG

        mov     t10 = PbProcessorState+KpsSpecialRegisters+KsTrD0
        movl    t13 = KiPcr + PcPrcb
        ;;

        ld8     t13 = [t13]
        mov     t14 = PbProcessorState+KpsSpecialRegisters+KsTrI0
        ;;

        add     t10 = t10, t13
        add     t14 = t14, t13
        ;;

(pt0)   shladd  t15 = rIndex, 3, t10
(pt1)   shladd  t15 = rIndex, 3, t14
        ;;

(pt0)   st8     [t15] = rPte
(pt1)   st8     [t15] = rPte
        ;;

#endif

        ssm     1 << PSR_I

        LEAF_RETURN

        LEAF_EXIT(KeFillFixedEntryTb)


//++
//
// VOID
// KeFillFixedLargeEntryTb (
//    IN HARDWARE_PTE Pte[],
//    IN PVOID Virtual,
//    IN ULONG PageSize,
//    IN ULONG Index
//    )
//
// Routine Description:
//
//    This function fills a fixed translation buffer entry with a large page
//    size.
//
// Arguments:
//
//    Pte (a0) - Supplies a pointer to the page table entries that are to be
//       written into the TB.
//
//    Virtual (a1) - Supplies the virtual address of the entry that is to
//       be filled in the translation buffer.
//
//    PageSize (a2) - Supplies the size of the large page table entry.
//
//    Index (a3) - Supplies the index where the TB entry is to be written.
//
// Return Value:
//
//    None.
//
// Comments:
//
//    Yet to be implemented.
//
//--
        LEAF_ENTRY(KeFillFixedLargeEntryTb)


        rPte    = t0
        rScnd   = t1
        ridtr   = t2
        rid     = t3
        rIndex  = t4

        rTb             = t6
        rTbPFN          = t7
        rpAttr          = t8
        rAttrOffset     = t9


        rsm     1 << PSR_I              // reset PSR.i
        ld8     rPte = [a0]             // load PTE
        shl     ridtr = a2, PS_SHIFT

        ;;

        rsm     1 << PSR_IC             // interrupt is off, now reset PSR.ic
        and     rIndex = 0xf, a3        // set the DTR index
        tbit.z  pt0, pt1 = a3, 31       // check the sign bit

        ;;

        srlz.d                          // serialize

        mov     cr.itir = ridtr         // idtr for insertion
        mov     cr.ifa = a1             // ifa for insertion
        ;;

(pt0)   itr.d   dtr[rIndex] = rPte      // insert into DTR
(pt1)   itr.i   itr[rIndex] = rPte      // insert into ITR

        ssm     1 << PSR_IC             // set PSR.ic bit again
        ;;

        srlz.i                          // I serialize
        ssm     1 << PSR_I
        LEAF_RETURN

        LEAF_EXIT(KeFillFixedLargeEntryTb)         // return

//++
//
// VOID
// KeFillInstEntryTb (
//    IN HARDWARE_PTE Pte[],
//    IN PVOID Virtual,
//    )
//
// Routine Description:
//
//    This function fills a large translation buffer entry.
//
//    N.B. It is assumed that the large entry is not in the TB and therefore
//      the TB is not probed.
//
// Arguments:
//
//    Pte (a0) - Supplies a page table entry that is to be
//       written into the Inst TB.
//
//    Virtual (a1) - Supplies the virtual address of the entry that is to
//       be filled in the translation buffer.
//
// Return Value:
//
//    None.
//
//--
        LEAF_ENTRY(KeFillInstEntryTb)

        riitr   = t2
        rid     = t3

        rsm     1 << PSR_I              // reset PSR.i
        ;;
        rsm     1 << PSR_IC             // interrupt is off, now reset PSR.ic
        mov     riitr = PAGE_SIZE << PS_LEN
        ;;

        srlz.d                          // serialize
        mov     cr.ifa = a1             // set va to install
        mov     cr.itir = riitr         // iitr for insertion
        ;;

        itc.i   a0
        ;;
        ssm     1 << PSR_IC             // set PSR.ic bit again
        ;;

        srlz.i                          // I serialize
        ssm     1 << PSR_I
        LEAF_RETURN

        LEAF_EXIT(KeFillInstEntryTb)         // return


//++
//
// VOID
// KeBreakinBreakpoint
//    VOID
//    )
//
// Routine Description:
//
//    This function causes a BREAKIN breakpoint.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--
         LEAF_ENTRY(KeBreakinBreakpoint)

         //
         // Flush the RSE or the kernel debugger is unable to do a stack unwind
         //

         flushrs
         ;;
         break.i   BREAKPOINT_BREAKIN
         LEAF_RETURN

         LEAF_EXIT(KeBreakinBreakpoint)


#ifdef WX86


//++
//
// VOID
// KiIA32RegistersInit
//    VOID
//    )
//
// Routine Description:
//
//    This function to Initialize per processor IA32 related registers
//    These registers do not saved/restored on context switch time
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--
        LEAF_ENTRY(KiIA32RegistersInit)

        mov         t0 = TeGdtDescriptor
        mov         iA32iobase = 0
        ;;
        mov         iA32index = t0

        LEAF_RETURN
        LEAF_EXIT(KiIA32RegistersInit)
#endif // WX86


//++
//
// PKTHREAD
// KeGetCurrentThread (VOID)
//
// Routine Description:
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    Returns a pointer to the executing thread object.
//
//--

        LEAF_ENTRY(KeGetCurrentThread)

        movl    v0 = KiPcr + PcCurrentThread  // -> current thread
        ;;

        ld8     v0 = [v0]
        br.ret.sptk brp

        LEAF_EXIT(KeGetCurrentThread)

//++
//
// BOOLEAN
// KeIsExecutingDpc (VOID)
//
// Routine Description:
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    Return a value which indicates if we are currently in a DPC.
//
//--

        LEAF_ENTRY(KeIsExecutingDpc)

        rsm     1 << PSR_I                  // disable interrupt
        movl    v0 = KiPcr + PcPrcb
        ;;
        ld8     v0 = [v0]
        ;;
        add     v0 = PbDpcRoutineActive, v0
        ;;
        ld4     v0 = [v0]
        ssm     1 << PSR_I                  // enable interrupt
        br.ret.sptk brp

        LEAF_EXIT(KeIsExecutingDpc)

//++
//
// Routine Description:
//
//     This routine saves the thread's current non-volatile NPX state,
//     and sets a new initial floating point state for the caller.
//
//     This is intended for use by kernel-mode code that needs to use
//     the floating point registers. Must be paired with
//     KeRestoreFloatingPointState
//
// Arguments:
//
//     a0 - Supplies pointer to KFLOATING_SAVE structure
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(KeSaveFloatingPointState)

        mov  v0 = zero
        LEAF_RETURN

        LEAF_EXIT(KeSaveFloatingPointState)

//++
//
// Routine Description:
//
//     This routine restores the thread's current non-volatile NPX state,
//     to the passed in state.
//
//     This is intended for use by kernel-mode code that needs to use
//     the floating point registers. Must be paired with
//     KeSaveFloatingPointState
//
// Arguments:
//
//     a0 - Supplies pointer to KFLOATING_SAVE structure
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(KeRestoreFloatingPointState)

        mov  v0 = zero
        LEAF_RETURN

        LEAF_EXIT(KeRestoreFloatingPointState)


//++
//
// Routine Description:
//
//     This routine flush all the dirty registers to the backing store
//     and invalidate them.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//--
        LEAF_ENTRY(KiFlushRse)

        flushrs
        mov       t1 = ar.rsc
        mov       t0 = RSC_KERNEL_DISABLED
        ;;

        mov       ar.rsc = t0
        ;;
        loadrs
        ;;
        mov       ar.rsc = t1
        ;;
        br.ret.sptk brp

        LEAF_EXIT(KiFlushRse)

#if 0

//++
//
// Routine Description:
//
//     This routine invalidate all the physical stacked registers.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//--
        LEAF_ENTRY(KiInvalidateStackedRegisters)

        mov       t1 = ar.rsc
        mov       t0 = RSC_KERNEL_DISABLED
        ;;
        mov       ar.rsc = t0
        ;;
        loadrs
        ;;
        mov       ar.rsc = t1
        ;;
        br.ret.sptk brp

        LEAF_EXIT(KiInvalidateStackedRegisters)
#endif // 0


//++
//
// VOID
// KeSetLowPsrBit (
//     UCHAR BitPosition,
//     BOOLEAN Value
//     )
//
// Routine Description:
//
//      This routine set one of the low psr bits to the specified value.
//
// Arguments:
//
//      a0 - bit position
//      a1 - 1 or 0
//
// Return Value:
//
//      None.
//
//--

        LEAF_ENTRY(KeSetLowPsrBit)

        mov         t1 = psr
        mov         t2 = 1
        cmp.ne      pt1, pt0 = r0, a1
        ;;

        shl         t2 = t2, a0
        ;;
(pt1)   or          t3 = t1, t2
(pt0)   andcm       t3 = t1, t2
        ;;

        mov         psr.l = t3
        ;;
        srlz.i
        br.ret.sptk brp

        LEAF_EXIT(KeSetLowPsrBit)


//++
//
// PVOID
// KiGetPhysicalAddress(
//     PVOID Virtual
//     )
//
// Routine Description:
//
//      This routine translates to physical address uing TPA instruction.
//
// Arguments:
//
//      a0 - virtual address to be translated to physical address.
//
// Return Value:
//
//      physical address
//
//--

        LEAF_ENTRY(KiGetPhysicalAddress)

        tpa     r8 = a0
        LEAF_RETURN

        LEAF_EXIT(KiGetPhysicalAddress)


//++
//
// VOID
// KiSetRegionRegister(
//     PVOID Region,
//     ULONGLONG Contents
//     )
//
// Routine Description:
//
//      This routine sets the value of a region register.
//
// Arguments:
//
//      a0 - Supplies the region register #
//
//      a1 - Supplies the value to be stored in the specified region register
//
// Return Value:
//
//      None.
//
//--


        LEAF_ENTRY(KiSetRegionRegister)

        mov       rr[a0] = a1
        ;;
        srlz.i
        LEAF_RETURN

        LEAF_EXIT(KiSetRegionId)



        LEAF_ENTRY(KiSaveProcessorControlState)

        //
        // save region registers
        //

        add     t2 = KpsSpecialRegisters+KsRr0, a0
        dep.z   t0 = 0, RR_INDEX, RR_INDEX_LEN
        ;;

        mov     t1 = rr[t0]
        dep.z   t3 = 1, RR_INDEX, RR_INDEX_LEN
        ;;

        mov     t4 = rr[t3]
        st8     [t2] = t1, KsRr1-KsRr0
        dep.z   t0 = 2, RR_INDEX, RR_INDEX_LEN
        ;;

        mov     t1 = rr[t0]
        st8     [t2] = t4, KsRr2-KsRr1
        dep.z   t3 = 3, RR_INDEX, RR_INDEX_LEN
        ;;

        mov     t4 = rr[t3]
        st8     [t2] = t1, KsRr3-KsRr2
        dep.z   t0 = 4, RR_INDEX, RR_INDEX_LEN
        ;;

        mov     t1 = rr[t0]
        st8     [t2] = t4, KsRr4-KsRr3
        dep.z   t3 = 5, RR_INDEX, RR_INDEX_LEN
        ;;
        mov     t4 = rr[t3]
        st8     [t2] = t1, KsRr5-KsRr4
        dep.z   t0 = 6, RR_INDEX, RR_INDEX_LEN
        ;;

        mov     t1 = rr[t0]
        st8     [t2] = t4, KsRr6-KsRr5
        dep.z   t3 = 7, RR_INDEX, RR_INDEX_LEN
        ;;

        mov     t4 = rr[t3]
        st8     [t2] = t1, KsRr7-KsRr6
        ;;

        st8     [t2] = t4

        //
        // save ITC, ITM, IVA, PTA and TPR
        //

        mov     t0 = ar.itc
        mov     t1 = cr.itm
        add     t3 = KpsSpecialRegisters+KsApITC, a0
        add     t4 = KpsSpecialRegisters+KsApITM, a0
        ;;

        mov     t5 = cr.iva
        mov     t6 = cr.pta
        st8     [t3] = t0, KsApIVA-KsApITC
        st8     [t4] = t1, KsApPTA-KsApITM
        ;;

        mov     t0 = cr.tpr
        mov     t1 = ar.k0
        st8     [t3] = t5, KsSaTPR-KsApIVA
        st8     [t4] = t6, KsApKR0-KsApPTA
        ;;

        mov     t5 = ar.k1
        mov     t6 = ar.k2
        st8     [t3] = t0, KsApKR1-KsSaTPR
        st8     [t4] = t1, KsApKR2-KsApKR0
        ;;

        mov     t0 = ar.k3
        mov     t1 = ar.k4
        st8     [t3] = t5, KsApKR3-KsApKR1
        st8     [t4] = t6, KsApKR4-KsApKR2
        ;;

        mov     t5 = ar.k5
        mov     t6 = ar.k6
        st8     [t3] = t0, KsApKR5-KsApKR3
        st8     [t4] = t1, KsApKR6-KsApKR4
        ;;

        mov     t0 = ar.k7
        mov     t1 = cr.lid
        st8     [t3] = t5, KsApKR7-KsApKR5
        st8     [t4] = t6, KsSaLID-KsApKR6
        ;;

        mov     t5 = cr.irr0
        mov     t6 = cr.irr1
        st8     [t3] = t0, KsSaIRR0-KsApKR7
        st8     [t4] = t1, KsSaIRR1-KsSaLID
        ;;

        mov     t0 = cr.irr2
        mov     t1 = cr.irr3
        st8     [t3] = t5, KsSaIRR2-KsSaIRR0
        st8     [t4] = t6, KsSaIRR3-KsSaIRR1
        ;;

        mov     t5 = cr.itv
        mov     t6 = cr.pmv
        st8     [t3] = t0, KsSaITV-KsSaIRR2
        st8     [t4] = t1, KsSaPMV-KsSaIRR3
        ;;

        mov     t0 = cr.cmcv
        mov     t1 = cr.lrr0
        st8     [t3] = t5, KsSaCMCV-KsSaITV
        st8     [t4] = t6, KsSaLRR0-KsSaPMV
        ;;

        mov     t5 = cr.lrr1
        mov     t6 = cr.gpta
        st8     [t3] = t0, KsSaLRR1-KsSaCMCV
        st8     [t4] = t1, KsApGPTA-KsSaLRR0

        mov     t7 = 0
        mov     t8 = 1
        ;;

        mov     t0 = cpuid[t7]
        mov     t1 = cpuid[t8]
        st8     [t3] = t5
        st8     [t4] = t6

        mov     t9 = 2
        mov     t10 = 3

        add     t3 = KpsSpecialRegisters+KsApCPUID0, a0
        add     t4 = KpsSpecialRegisters+KsApCPUID1, a0
        ;;

        mov     t5 = cpuid[t9]
        mov     t6 = cpuid[t10]
        st8     [t3] = t0, KsApCPUID2-KsApCPUID0
        st8     [t4] = t1, KsApCPUID3-KsApCPUID1

        mov     t7 = 4
        mov     t8 = 652
        ;;

        mov     t0 = cpuid[t7]
        st8     [t3] = t5, KsApCPUID4-KsApCPUID2
        st8     [t4] = t6
        ;;

        st8     [t3] = t0

        LEAF_RETURN

        LEAF_EXIT(KiSaveProcessorControlState)


        NESTED_ENTRY(KiRestoreProcessorControlState)

        NESTED_SETUP(0,2,0,0)
        ;;
        br.call.spnt brp = KiLoadKernelDebugRegisters
        ;;
        NESTED_RETURN

        NESTED_EXIT(KiRestoreProcessorControlState)



        PublicFunction(KiSaveExceptionFrame)
        PublicFunction(KiRestoreExceptionFrame)
        PublicFunction(KiIpiServiceRoutine)


        NESTED_ENTRY(KeIpiInterrupt)
        NESTED_SETUP(1, 2, 2, 0)
        .fframe ExceptionFrameLength
        add     sp = -ExceptionFrameLength, sp
        ;;

        PROLOGUE_END

        add     out0 = STACK_SCRATCH_AREA, sp       // -> exception frame
        br.call.sptk brp = KiSaveExceptionFrame
        ;;

        add     out1 = STACK_SCRATCH_AREA, sp       // -> exception frame
        mov     out0 = a0                           // -> trap frame
        br.call.sptk brp = KiIpiServiceRoutine
        ;;

        add     out0 = STACK_SCRATCH_AREA, sp       // -> exception frame
        br.call.sptk brp = KiRestoreExceptionFrame
        ;;

        add     sp = ExceptionFrameLength, sp
        NESTED_RETURN

        NESTED_EXIT(KeIpiInterrupt)



        LEAF_ENTRY(KiReadMsr)

        mov     v0 = msr[a0]
        LEAF_RETURN

        LEAF_EXIT(KiReadMsr)

        LEAF_ENTRY(KiWriteMsr)

        mov     msr[a0] = a1
        LEAF_RETURN

        LEAF_EXIT(KiWriteMsr)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\processr.s ===
//++
//
// Module Name:
//
//    proceessr.s
//
// Abstract:
//
//    Hardware workarounds.
//
// Author:
//
//    Allen M. Kay (allen.m.kay@intel.com) 4-April-2000
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksia64.h"

#if _MERCED_A0_
//
// Merced Processor ERRATA Workaround
//
        LEAF_ENTRY (KiProcessorWorkAround)


        mov     t0 = 3
        ;;
        mov     t1 = cpuid[t0]       // read cpuid3
        ;;
        extr.u  t1 = t1, 24, 8
        ;;
        cmp.ne  pt0 = 7, t1             // if the processor is not the Itanium processor
        ;;
(pt0)   br.ret.spnt  b0                 // then just return
        ;;

Disable_L1_Bypass:
        tbit.nz pt0, pt1 = a0, DISABLE_L1_BYPASS
(pt0)   br.sptk CPL_bug_workaround

        mov     t0 = 484
        mov     t1 = 4
        ;;
        mov     msr[t0] = t1

CPL_bug_workaround:
        tbit.nz pt0, pt1 = a0, DISABLE_CPL_FIX
(pt0)   br.sptk DisableFullDispersal
        mov     t0 = 66
        ;;
        mov     t1 = msr[t0]
        ;;
        dep     t1 = 1, t1, 0, 4
        ;;
        mov     msr[t0] = t1


DisableFullDispersal:
        tbit.z    pt0, pt1 = a0, ENABLE_FULL_DISPERSAL
        mov     t0 = 652
        ;;

        // Single Dispersal
(pt1)   mov     t1 = 0
(pt0)   mov     t1 = 1
        ;;
        mov     msr[t0] = t1
        ;;

DisableBtb:
        tbit.nz   pt0, pt1 = a0, DISABLE_BTB_FIX
(pt0)   br.sptk   DisableTar

        // This change is needed to make WOW64 run (disable BTB)
        mov     t1 = 224
        ;;
        mov     t0 = msr[t1]            // Get the old value
        ;;
        or      t0 = 0x40, t0           // Or in bit 6
        ;;
        mov     msr[t1] = t0            // Put it back

DisableTar:
        tbit.nz   pt0, pt1 = a0, DISABLE_TAR_FIX
(pt0)   br.sptk   DataBreakPoint

        // disable TAR to fix sighting 3739
        mov     t0 = 51
        mov     t1 = 1
        ;;
        mov     msr[t0] = t1

DataBreakPoint:
        tbit.nz   pt0, pt1 = a0, DISABLE_DATA_BP_FIX
(pt0)   br.sptk   DetStallFix

        // this change is needed to enable data debug
        mov     t0 = 387
        ;;
        mov     msr[t0] = r0
        ;;

DetStallFix:
        tbit.nz   pt0, pt1 = a0, DISABLE_DET_STALL_FIX
(pt0)   br.sptk   DisableIA32BranchFix

        //
        // BSB CADS spacing 7
        //

        mov     t0 = 514
        movl    t1 = 0x0930442325210445
        ;;
        mov     msr[t0] = t1;
        ;;

        // p1_disable()
        mov     t0 = 484
        mov     t1 = 0xc
        ;;
        mov     msr[t0] = t1

        // trickle()
        mov     t0 = 485
        mov     t1 = 1
        ;;
        mov     msr[t0] = t1

        // Throttle L1 access in L0D
        mov     t1 = 384
        ;;
        mov     t0 = msr[t1]            // Get the old value
        ;;

        dep     t2 = 1, t0, 44, 1
        ;;
        mov     msr[t1] = t2            // Put it back

        // rse_disable()
        mov     t1 = 258
        ;;
        mov     t0 = msr[t1]            // Get the old value
        movl    t2 = 0x4000
        ;;
        or      t0 = t2, t0             // Or in bit 44
        ;;
        mov     msr[t1] = t0            // Put it back
        ;;

DisableIA32BranchFix:
        tbit.nz   pt0, pt1 = a0, DISABLE_IA32BR_FIX
(pt0)   br.sptk   DisableIA32RsbFix

        // Occasionally the ia32 iVE gets confused between macro branches
        // and micro branches. This helps that confusion
        mov     t1 = 204
        ;;
        mov     t0 = msr[t1]            // Get the old value
        ;;
        or      t0 = 0x10, t0           // Or in bit 4
        ;;
        mov     msr[t1] = t0            // Put it back

DisableIA32RsbFix:
        tbit.nz   pt0, pt1 = a0, DISABLE_IA32RSB_FIX
(pt0)   br.sptk   DisablePrefetchUnsafeFill

        // More ia32 confusion. This time on the ReturnStackBuffer
        mov     t1 = 196
        movl    t0 = 0x40000008         // Turn off the RSB
        ;;
        mov     msr[t1] = t0

DisablePrefetchUnsafeFill:
        tbit.z pt0, pt1 = a0, DISABLE_UNSAFE_FILL
(pt0)   br.cond.sptk DisableStoreUpdate

        mov     t1 = 80
        mov     t0 = 8
        ;;

        mov     msr[t1] = t0

DisableStoreUpdate:
        tbit.nz pt0, pt1 = a0, DISABLE_STORE_UPDATE
(pt0)   br.cond.sptk ErrataDone

        mov     t1 = 384
        ;;
        mov     t0 = msr[t1]
        ;;
        dep     t0 = 1, t0, 18, 1
        ;;
        mov     msr[t1] = t0

ErrataDone:

#if 1
        tbit.nz pt0 = a0, DISABLE_INTERRUPTION_LOG
(pt0)   br.cond.sptk HistoryDone

        //
        // Configure the history buffer for capturing branches/interrupts
        //

        mov     t1 = 674                
        ;;
        mov     msr[t1] = r0            // HBC <- 0
        ;;

        mov     t0 = 675
        ;;
        mov     t1 = msr[t0]
        mov     t2 = 2
        ;;
        dep     t1 = t2, t1, 0, 9
        ;;
        mov     msr[t0] = t1           // HBCF <- 2
        ;;

        mov     t1 = 12
        mov     t0 = 0xfe8f
        ;;
        mov     pmc[t1] = t0
        ;;

        
        mov     t1 = 680
        mov     t2 = 681
        mov     t3 = 682
        mov     t4 = 683
        mov     t5 = 684
        mov     t6 = 685
        mov     t7 = 686
        mov     t8 = 687
        ;;
        .reg.val t1, 680
        mov     msr[t1] = r0
        .reg.val t2, 681
        mov     msr[t2] = r0     
        .reg.val t3, 682
        mov     msr[t3] = r0     
        .reg.val t4, 683
        mov     msr[t4] = r0     
        .reg.val t5, 684
        mov     msr[t5] = r0     
        .reg.val t6, 685
        mov     msr[t6] = r0     
        .reg.val t7, 686
        mov     msr[t7] = r0     
        .reg.val t8, 687
        mov     msr[t8] = r0     

HistoryDone:
#endif
        LEAF_RETURN
        LEAF_EXIT (KiProcessorWorkAround)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\region.c ===
/*++

Module Name:

    region.c

Abstract:

    This module implements the region space management code.

Author:

    Landy Wang (landyw) 18-Feb-1999
    Koichi Yamada (kyamada) 18-Feb-1999

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
KiSetRegionRegister (
    PVOID VirtualAddress,
    ULONGLONG Contents
    );


#define KiMakeValidRegionRegister(Rid, Ps) \
   (((ULONGLONG)Rid << RR_RID) | (Ps << RR_PS) | (1 << RR_VE))

ULONG KiMaximumRid = MAXIMUM_RID;
ULONG KiRegionFlushRequired = 0;


VOID
KiSyncNewRegionIdTarget (
    IN PULONG SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for synchronizing the region IDs.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Parameter1 - Not used.

    Parameter2 - Not used.

    Parameter3 - Not used.

Return Value:

    None.

--*/

{
#if !defined(NT_UP)

    PKPROCESS Process;
    PREGION_MAP_INFO ProcessRegion;
    PREGION_MAP_INFO MappedSession;
    ULONG NewRid;

    //
    // get KPROCESS from PCR for MP synchronization
    // 

    Process = (PKPROCESS)PCR->Pcb;

    ProcessRegion = &Process->ProcessRegion;
    MappedSession = Process->SessionMapInfo;

    KiAcquireSpinLock(&KiMasterRidLock);

    if (ProcessRegion->SequenceNumber != KiMasterSequence) {
        
        KiMasterRid += 1;

        ProcessRegion->RegionId = KiMasterRid;
        ProcessRegion->SequenceNumber = KiMasterSequence;

    }

    KiSetRegionRegister(MM_LOWEST_USER_ADDRESS,
                        KiMakeValidRegionRegister(ProcessRegion->RegionId, PAGE_SHIFT));

    KiFlushFixedDataTb(TRUE, PDE_UTBASE);

    KeFillFixedEntryTb((PHARDWARE_PTE)&Process->DirectoryTableBase[0], 
                       (PVOID)PDE_UTBASE,
                       PAGE_SHIFT,
                       DTR_UTBASE_INDEX);

    if (MappedSession->SequenceNumber != KiMasterSequence) {

        KiMasterRid += 1;
        
        MappedSession->RegionId = KiMasterRid;
        MappedSession->SequenceNumber = KiMasterSequence;

    }

    KiSetRegionRegister((PVOID)SADDRESS_BASE,
                        KiMakeValidRegionRegister(MappedSession->RegionId, PAGE_SHIFT));

    KiFlushFixedDataTb(TRUE, PDE_STBASE);

    KeFillFixedEntryTb((PHARDWARE_PTE)&Process->SessionParentBase, 
                       (PVOID)PDE_STBASE, 
                       PAGE_SHIFT,
                       DTR_STBASE_INDEX);

    KiReleaseSpinLock(&KiMasterRidLock);

    KiIpiSignalPacketDone(SignalDone);

    KeFlushCurrentTb();

#endif
    return;
}

BOOLEAN
KiSyncNewRegionId(
    IN PREGION_MAP_INFO ProcessRegion,
    IN PREGION_MAP_INFO SessionRegion
    )
/*++

 Routine Description:

    Generate a new region id and synchronize the region IDs on all the
    processors if necessary. If the region IDs wrap then flush all
    processor TBs.

 Arguments:

    ProcessRegion - Supplies a REGION_MAP_INFO user space pointer.

    SessionRegion - Supplies a REGION_MAP_INFO session space pointer.

 Return Value:

    TRUE - if the region id has been recycled.

    FALSE -- if the region id has not been recycled.

 Notes:

    This routine called by KiSwapProcess, KeAttachSessionSpace and 
    KeCreateSessionSpace.

 Environment:

    Kernel mode.

    KiLockDispatcherLock/LockQueuedDispatcherLock or 
    KiContextSwapLock (MP) is held.

--*/

{
    ULONG i;
    LOGICAL RidRecycled;
    KAFFINITY TargetProcessors;
    ULONGLONG PrSequence = ProcessRegion->SequenceNumber;
    ULONGLONG SeSequence = SessionRegion->SequenceNumber;

    RidRecycled = FALSE;

    //
    // copy the KPROCESS pointer for MP region synchronization
    //

    PCR->Pcb = (PVOID)KeGetCurrentThread()->ApcState.Process;

    //
    // Invalidx1ate the ForwardProgressTb buffer
    //

    for (i = 0; i < MAXIMUM_FWP_BUFFER_ENTRY; i += 1) {
        
        PCR->ForwardProgressBuffer[(i*2)+1] = 0;

    }
    
    if ((PrSequence == KiMasterSequence) && (SeSequence == KiMasterSequence)) {
        
not_recycled:

        KiSetRegionRegister(MM_LOWEST_USER_ADDRESS,
                            KiMakeValidRegionRegister(ProcessRegion->RegionId,
                                                      PAGE_SHIFT));
        
        KiSetRegionRegister((PVOID)SADDRESS_BASE,
                            KiMakeValidRegionRegister(SessionRegion->RegionId,
                                                      PAGE_SHIFT));
    
#if !defined(NT_UP)
        if (KiRegionFlushRequired) {
            KiRegionFlushRequired = 0;
            goto RegionFlush;
        }
#endif

        return FALSE;
    
    }

    if (PrSequence != KiMasterSequence) {

        if (KiMasterRid + 1 > KiMaximumRid) {

            RidRecycled = TRUE;

        } else {

            KiMasterRid += 1;
            ProcessRegion->RegionId = KiMasterRid;
            ProcessRegion->SequenceNumber = KiMasterSequence;
        }
                
    }

    if ((RidRecycled == FALSE) && (SeSequence != KiMasterSequence)) {
        
        if (KiMasterRid + 1 > KiMaximumRid) {

            RidRecycled = TRUE;

        } else {

            KiMasterRid += 1;
            SessionRegion->RegionId = KiMasterRid;
            SessionRegion->SequenceNumber = KiMasterSequence;
        }
    }

    if (RidRecycled == FALSE) {
    
        goto not_recycled;

    }

    //
    // The region ID must be recycled.
    //

    KiMasterRid = START_PROCESS_RID;

    //
    // Since KiMasterSequence is 64-bits wide, it will
    // not be recycled in your life time.
    //

    if (KiMasterSequence + 1 > MAXIMUM_SEQUENCE) {

        KiMasterSequence = START_SEQUENCE;

    } else {

        KiMasterSequence += 1;
    }
        
    //
    // Update the new process's ProcessRid and ProcessSequence.
    //

    ProcessRegion->RegionId = KiMasterRid;
    ProcessRegion->SequenceNumber = KiMasterSequence;

    KiSetRegionRegister(MM_LOWEST_USER_ADDRESS,
                        KiMakeValidRegionRegister(ProcessRegion->RegionId, PAGE_SHIFT));

    KiMasterRid += 1;

    SessionRegion->RegionId = KiMasterRid;
    SessionRegion->SequenceNumber = KiMasterSequence;

    KiSetRegionRegister((PVOID)SADDRESS_BASE,
                        KiMakeValidRegionRegister(SessionRegion->RegionId, PAGE_SHIFT));

#if !defined(NT_UP)

RegionFlush:

    //
    // Broadcast Region Id sync.
    //

    TargetProcessors = KeActiveProcessors;
    TargetProcessors &= PCR->NotMember;

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiSyncNewRegionIdTarget,
                        (PVOID)TRUE,
                        NULL,
                        NULL);
    }

#endif

    KeFlushCurrentTb();


#if !defined(NT_UP)

    //
    // Wait until all target processors have finished.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    return TRUE;
}

VOID
KeEnableSessionSharing(
    IN PREGION_MAP_INFO SessionMapInfo,
    IN PFN_NUMBER SessionParentPage
    )
/*++

 Routine Description:

    This routine initializes a session for use.  This includes :

    1.  Allocating a new region ID for the session.
    2.  Updating the current region register with this new RID.
    3.  Updating the SessionMapInfo fields so context switches will work.
    4.  Updating SessionParentBase fields so context switches will work.

    Upon return from this routine, the session will be available for
    sharing by the current and other processes.

 Arguments: 

    SessionMapInfo - Supplies a session map info to be shared.

    SessionParentPage - Supplies the top level parent page mapping the
                        argument session space.

 Return Value:

    None.

 Environment:

    Kernel mode.

--*/
{
    ULONG i;
    KAFFINITY TargetProcessors;
    PKPROCESS Process;
    PKTHREAD Thread;
    KIRQL OldIrql;

    Thread = KeGetCurrentThread();
    Process = Thread->ApcState.Process;

#if defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

#else

    KiLockContextSwap(&OldIrql);

#endif

    INITIALIZE_DIRECTORY_TABLE_BASE (&Process->SessionParentBase,
                                     SessionParentPage);

    //
    // Invalidate the ForwardProgressTb buffer.
    //

    for (i = 0; i < MAXIMUM_FWP_BUFFER_ENTRY; i += 1) {
        
        PCR->ForwardProgressBuffer[(i*2)+1] = 0;

    }
    
    if (KiMasterRid + 1 > KiMaximumRid) {

        //
        // The region ID must be recycled.
        //
    
        KiMasterRid = START_PROCESS_RID;
    
        //
        // Since KiMasterSequence is 64-bits wide, it will
        // not be recycled in your life time.
        //
    
        if (KiMasterSequence + 1 > MAXIMUM_SEQUENCE) {
    
            KiMasterSequence = START_SEQUENCE;
    
        } else {
    
            KiMasterSequence += 1;
        }
    }
            
    //
    // Update the newly created session's RegionId and SequenceNumber.
    //

    KiMasterRid += 1;

    Process->SessionMapInfo = SessionMapInfo;

    SessionMapInfo->RegionId = KiMasterRid;
    SessionMapInfo->SequenceNumber = KiMasterSequence;

    KiSetRegionRegister((PVOID)SADDRESS_BASE,
                        KiMakeValidRegionRegister(SessionMapInfo->RegionId,
                                                  PAGE_SHIFT));
    //
    // Note that all processors must be notified because this thread could
    // context switch onto another processor.  If that processor was already
    // running a thread from this same process, no region register update
    // would occur otherwise.
    //

#if !defined(NT_UP)

    //
    // Broadcast Region Id sync.
    //

    TargetProcessors = KeActiveProcessors;
    TargetProcessors &= PCR->NotMember;

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiSyncNewRegionIdTarget,
                        (PVOID)TRUE,
                        NULL,
                        NULL);
    }

#endif

    KeFlushCurrentTb();

    KeFillFixedEntryTb((PHARDWARE_PTE)&Process->SessionParentBase,
                       (PVOID)PDE_STBASE, 
                       PAGE_SHIFT,
                       DTR_STBASE_INDEX);

#if defined(NT_UP)

    KeLowerIrql(OldIrql);

#else

    //
    // Wait until all target processors have finished.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    KiUnlockContextSwap(OldIrql);

#endif
}

VOID
KeAttachSessionSpace(
    PREGION_MAP_INFO SessionMapInfo,
    IN PFN_NUMBER SessionParentPage
    )
/*++

 Routine Description:

    This routine attaches the current process to the specified session.

    This includes:

    1.  Updating the current region register with the target RID.
    2.  Updating the SessionMapInfo fields so context switches will work.
    3.  Updating SessionParentBase fields so context switches will work.

 Arguments: 

    SessionMapInfo - Supplies the target session map info.

    SessionParentPage - Supplies the top level parent page mapping the
                        argument session space.

 Return Value:

    None.

 Environment:

    Kernel mode.

--*/
{
    KIRQL OldIrql;
    PKTHREAD Thread;
    PKPROCESS Process;

    Thread = KeGetCurrentThread();
    Process = Thread->ApcState.Process;

#if defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

#else

    KiLockContextSwap(&OldIrql);

#endif

    ASSERT(SessionMapInfo != NULL);

    //
    // Attach to the specified session.
    //

    INITIALIZE_DIRECTORY_TABLE_BASE (&Process->SessionParentBase,
                                     SessionParentPage);

    Process->SessionMapInfo = SessionMapInfo;

    //
    // Note that all processors must be notified because this thread could
    // context switch onto another processor.  If that processor was already
    // running a thread from this same process, no region register update
    // would occur.  Hence KiRegionFlushRequired is set under ContextSwap lock
    // protection to signify this to KiSyncNewRegionId.
    //

    ASSERT (KiRegionFlushRequired == 0);
    KiRegionFlushRequired = 1;

    KiSyncNewRegionId(&Process->ProcessRegion, SessionMapInfo);

    KiFlushFixedDataTb(TRUE, PDE_STBASE);

    KeFillFixedEntryTb((PHARDWARE_PTE)&Process->SessionParentBase, 
                       (PVOID)PDE_STBASE,
                       PAGE_SHIFT,
                       DTR_STBASE_INDEX);

#if defined(NT_UP)

    KeLowerIrql(OldIrql);

#else

    KiUnlockContextSwap(OldIrql);

#endif

}

VOID
KiSyncSessionTarget(
    IN PULONG SignalDone,
    IN PKPROCESS Process,
    IN PVOID Parameter1,
    IN PVOID Parameter2
    )
/*++

 Routine Description:

    This is the target function for synchronizing the new session 
    region ID.  This routine is called when the session space is removed 
    and all the processors need to be notified.

 Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Process - Supplies a KPROCESS pointer which needs to be synchronized.

 Return Value:

    None.

 Environment:

    Kernel mode.

--*/
{
#if !defined(NT_UP)

    ULONG NewRid;

    //
    // Check to see if the current process is the process that needs to be 
    // synchronized.
    //

    if (Process == (PKPROCESS)PCR->Pcb) {
        
        KiAcquireSpinLock(&KiMasterRidLock);

        //
        // Disable the session region.
        //

        KiSetRegionRegister((PVOID)SADDRESS_BASE, 
                            KiMakeValidRegionRegister(Process->SessionMapInfo->RegionId, PAGE_SHIFT));

        KiFlushFixedDataTb(TRUE, (PVOID)PDE_STBASE);

        KeFillFixedEntryTb((PHARDWARE_PTE)&Process->SessionParentBase, 
                           (PVOID)PDE_STBASE, 
                           PAGE_SHIFT,
                           DTR_STBASE_INDEX);

        KiReleaseSpinLock(&KiMasterRidLock);

    }

    KiIpiSignalPacketDone(SignalDone);

#endif
    return;
}


VOID 
KeDetachSessionSpace(
    IN PREGION_MAP_INFO NullSessionMapInfo,
    IN PFN_NUMBER NullSessionPage
    )
/*++

 Routine Description:
    
    This routine detaches the current process from the current session
    space.

    This includes:

    1.  Updating the current region register.
    2.  Updating the SessionMapInfo fields so context switches will work.
    3.  Updating SessionParentBase fields so context switches will work.

 Arguments:
 
    SessionMapInfo - Supplies a new session map information to use (the
                     existing session map info is discarded).  This is usually
                     a NULL entry.

    NullSessionPage - Supplies the new top level parent page to use.

 Return Value:
  
    None.

 Environment:
 
    Kernel mode.

--*/
{
    KIRQL OldIrql;
    PKTHREAD Thread;
    PKPROCESS Process;
#if !defined(NT_UP)
    KAFFINITY TargetProcessors;
#endif

    //
    // Raise IRQL to DISPATCH_LEVEL and lock the dispatcher database.
    //

    Thread = KeGetCurrentThread();
    Process = Thread->ApcState.Process;

#if defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

#else

    KiLockContextSwap(&OldIrql);

#endif

    INITIALIZE_DIRECTORY_TABLE_BASE (&Process->SessionParentBase,
                                     NullSessionPage);

    Process->SessionMapInfo = NullSessionMapInfo;
    
#if !defined(NT_UP)

    //
    // Broadcast the region ID sync.
    //

    TargetProcessors = KeActiveProcessors;
    TargetProcessors &= PCR->NotMember;

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiSyncSessionTarget,
                        Process,
                        NULL,
                        NULL);
    }

#endif

    KiSetRegionRegister((PVOID)SADDRESS_BASE, 
                        KiMakeValidRegionRegister(NullSessionMapInfo->RegionId, PAGE_SHIFT));

    KiFlushFixedDataTb(TRUE, PDE_STBASE);

    KeFillFixedEntryTb((PHARDWARE_PTE)&Process->SessionParentBase, 
                       (PVOID)PDE_STBASE, 
                       PAGE_SHIFT,
                       DTR_STBASE_INDEX);

#if defined(NT_UP)

    KeLowerIrql(OldIrql);

#else

    //
    // Wait until all target processors have finished.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    KiUnlockContextSwap(OldIrql);

#endif

}    

VOID
KeAddSessionSpace(
    IN PKPROCESS Process,
    IN PREGION_MAP_INFO SessionMapInfo,
    IN PFN_NUMBER SessionParentPage
    )
/*++

Routine Description:
    
    Add the session map info to the KPROCESS of the new process.

    This includes:

    1.  Updating the SessionMapInfo fields so context switches will work.
    2.  Updating SessionParentBase fields so context switches will work.

    Note the dispatcher lock is not needed since the process can't run yet.

Arguments:

    Process - Supplies a pointer to the process being created.

    SessionMapInfo - Supplies a pointer to the SessionMapInfo.

Return Value: 

    None.

Environment:

    Kernel mode, APCs disabled.

--*/
{
    Process->SessionMapInfo = SessionMapInfo;

    INITIALIZE_DIRECTORY_TABLE_BASE (&Process->SessionParentBase,
                                     SessionParentPage);
}

VOID
KiAttachRegion(
    IN PKPROCESS Process
    )
/*++

Routine Description:
    
    Attaches the regions of the specified process

Arguments:

    Process - Supplies a pointer to the process 

Return Value: 

    None.

Environment:

    Kernel mode, KiContextSwapLock is held.

--*/
{
    PREGION_MAP_INFO ProcessRegion;
    PREGION_MAP_INFO MappedSession;

    ProcessRegion = &Process->ProcessRegion;
    MappedSession = Process->SessionMapInfo;

    //
    // attach the target user space
    //

    KiSetRegionRegister(MM_LOWEST_USER_ADDRESS,
                        KiMakeValidRegionRegister(ProcessRegion->RegionId, PAGE_SHIFT));

    //
    // attach the target session space
    //

    KiSetRegionRegister((PVOID)SADDRESS_BASE,
                        KiMakeValidRegionRegister(MappedSession->RegionId, PAGE_SHIFT));
}

VOID
KiDetachRegion(
    VOID
    )
/*++

Routine Description:
    
    Restores the origial regions

Arguments:

    VOID

Return Value: 

    None.

Environment:

    Kernel mode, KiContextSwapLock is held.

--*/
{
    PKPROCESS Process;
    PREGION_MAP_INFO ProcessRegion;
    PREGION_MAP_INFO MappedSession;

    //
    // use KPROCESS from PCR
    //

    Process = (PKPROCESS)PCR->Pcb;

    ProcessRegion = &Process->ProcessRegion;
    MappedSession = Process->SessionMapInfo;

    //
    // attach the original user space
    //

    KiSetRegionRegister(MM_LOWEST_USER_ADDRESS,
                        KiMakeValidRegionRegister(ProcessRegion->RegionId, PAGE_SHIFT));

    //
    // attach the original session space
    //

    KiSetRegionRegister((PVOID)SADDRESS_BASE,
                        KiMakeValidRegionRegister(MappedSession->RegionId, PAGE_SHIFT));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\tb.s ===
#include "ksia64.h"

#if 0
//++
//
// VOID
//++
//
// VOID
// KeFlushCurrentTb (
//    )
//
// Routine Description:
//
//    This function flushes the entire translation buffer.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
// Algorithm:
//
//--

        LEAF_ENTRY(KeFlushCurrentTb)

        ptc.e   r0
        ;;
        srlz.d
        LEAF_RETURN

        LEAF_EXIT(KeFlushCurrentTb)

#endif

//++
//
// VOID
// KiPurgeTranslationCache (
//    ULONGLONG Base,
//    ULONGLONG Stride1,
//    ULONGLONG Stride2,
//    ULONGLONG Count1,
//    ULONGLONG Count2
//    )
//
// Routine Description:
//
//    This function flushes the entire translation cache from the current processor.
//
// Arguments:
//
//    r32 - base
//    r33 - stride1
//    r34 - stride2
//    r35 - count1
//    r36 - count2
//      
// Return Value:
//
//    None.
//
// Algorithm:
//
//    for (i = 0; i < count1; i++) {
//        for (j = 0; j < count2; j++) {
//            ptc.e addr;
//            addr += stride2;
//        }
//        addr += stride1;
//    }
//
//--
        LEAF_ENTRY(KiPurgeTranslationCache)
        PROLOGUE_BEGIN
        
        alloc	r31 = 5, 0, 0, 0
        cmp.ge  p14,p15=r0, r35

        rsm     1 << PSR_I
        .save   ar.lc, r30
        mov.i   r30=ar.lc
  (p14)	br.cond.dpnt.few $L150#;;

        PROLOGUE_END

  $L148:
        cmp.ge  p14,p15=r0, r36
        adds    r31=-1, r36
 (p14)  br.cond.dpnt.few $L153#;;

        nop.m   0
        nop.f   0
        mov.i   ar.lc=r31
        ;;

$L151:
        ptc.e   r32
        add     r32=r32, r34
        br.cloop.dptk.many $L151#;;

$L153:
        adds    r35=-1, r35
        add     r32=r32, r33;;
        cmp.ltu	p14,p15=r0, r35

        nop.m   0
        nop.f   0
 (p14)  br.cond.dptk.few $L148#;;

$L150:
        srlz.i

        ssm     1 << PSR_I
        mov.i	ar.lc=r30
        br.ret.sptk.few b0;;

        LEAF_EXIT(KiPurgeTranslationCache)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\spinlock.s ===
//++
//
// Module Name:
//
//    spinlock.s
//
// Abstract:
//
//    This module implements the routines for acquiring and releasing
//    spin locks.
//
// Author:
//
//    William K. Cheung (wcheung) 29-Sep-1995
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//    31-Dec-1998  wc   Updated to use xchg8
//
//    07-Jul-1997  bl   Updated to EAS2.3
//
//    08-Feb-1996       Updated to EAS2.1
//
//--

#include "ksia64.h"

        .file       "spinlock.s"

//
// Define LOG2(x) for those values whose bit numbers are needed in
// order to test a single bit with the tbit instruction.
//

#define _LOG2_0x1   0
#define _LOG2_0x2   1
#define _LOG2_x(n)  _LOG2_##n
#define LOG2(n)     _LOG2_x(n)

//
// Globals
//

        PublicFunction(KiLowerIrqlSoftwareInterruptPending)


//++
//
// VOID
// KiAcquireSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function acquires a kernel spin lock.
//
//    N.B. This function assumes that the current IRQL is set properly.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a kernel spin lock.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiAcquireSpinLock)

        ALTERNATE_ENTRY(KeAcquireSpinLockAtDpcLevel)

#if !defined(NT_UP)

        ACQUIRE_SPINLOCK(a0,a0,Kiasl10)

#endif // !defined(NT_UP)

        LEAF_RETURN

        LEAF_EXIT(KiAcquireSpinLock)

//++
//
// BOOLEAN
// KeTryToAcquireSpinLockAtDpcLevel (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function attempts to acquires the specified kernel spinlock. If
//    the spinlock can be acquired, then TRUE is returned. Otherwise, FALSE
//    is returned.
//
//    N.B. This function assumes that the current IRQL is set properly.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a kernel spin lock.
//
// Return Value:
//
//    If the spin lock is acquired, then a value of TRUE is returned.
//    Otherwise, a value of FALSE is returned.
//
// N.B. The caller KeTryToAcquireSpinLock implicitly depends on the
//      contents of predicate registers pt1 & pt2.
//
//--

        LEAF_ENTRY(KeTryToAcquireSpinLockAtDpcLevel)

#if !defined(NT_UP)

        xchg8       t0 = [a0], a0
        ;;
        cmp.ne      pt0 = t0, zero              // if ne, lock acq failed
        mov         v0 = TRUE                   // acquire assumed succeed
        ;;

        nop.m       0
  (pt0) mov         v0 = FALSE                  // return FALSE

#else
        mov         v0 = TRUE
#endif

        LEAF_RETURN
        LEAF_EXIT(KeTryToAcquireSpinLockAtDpcLevel)


//++
//
// VOID
// KeInitializeSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function initialzies an executive spin lock.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a executive spinlock.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeInitializeSpinLock)

        st8         [a0] = zero                 // clear spin lock value

        LEAF_RETURN
        LEAF_EXIT(KeInitializeSpinLock)

//++
//
// VOID
// KeAcquireSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    OUT PKIRQL OldIrql
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to DISPATCH_LEVEL and acquires
//    the specified executive spinlock.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a executive spinlock.
//
//    OldIrql  (a1) - Supplies a pointer to a variable that receives the
//        the previous IRQL value.
//
//    N.B. The Old IRQL MUST be stored after the lock is acquired.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeAcquireSpinLock)

//
// Get original IRQL, raise IRQL to DISPATCH_LEVEL
// and then acquire the specified spinlock.
//

        mov         t0 = DISPATCH_LEVEL
        SWAP_IRQL(t0)

#if !defined(NT_UP)

        ACQUIRE_SPINLOCK(a0,a0,Kasl10)

#endif  // !defined(NT_UP)

        st1         [a1] = v0                   // save old IRQL
        LEAF_RETURN

        LEAF_EXIT(KeAcquireSpinLock)



//++
//
// KIRQL
// KeAcquireSpinLockRaiseToSynch (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to synchronization level and
//    acquires the specified spinlock.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to the spinlock that is to be
//        acquired.
//
// Return Value:
//
//    The previous IRQL is returned as the function value.
//
//--

        LEAF_ENTRY(KeAcquireSpinLockRaiseToSynch)

//
// Register aliases
//

        pHeld       = pt0
        pFree       = pt1

        mov         t1 = SYNCH_LEVEL

#if !defined(NT_UP)

        GET_IRQL    (v0)

KaslrtsRetry:

        SET_IRQL    (t1)
        xchg8       t0 = [a0], a0
        ;;
        cmp.eq      pFree, pHeld = 0, t0
        ;;
        PSET_IRQL   (pHeld, v0)
(pFree) LEAF_RETURN
        ;;

KaslrtsLoop:

        cmp.eq      pFree, pHeld = 0, t0
        ld8.nt1     t0 = [a0]
(pFree) br.cond.dpnt  KaslrtsRetry
(pHeld) br.cond.dptk  KaslrtsLoop


#else

        SWAP_IRQL   (t1)                        // Raise IRQL
        LEAF_RETURN

#endif // !defined(NT_UP)

        LEAF_EXIT(KeAcquireSpinLockRaiseToSynch)


//++
//
// KIRQL
// KeAcquireSpinLockRaiseToDpc (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to dispatcher level and acquires
//    the specified spinlock.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to the spinlock that is to be
//        acquired.
//
// Return Value:
//
//    The previous IRQL is returned as the function value.
//
//--


        LEAF_ENTRY(KeAcquireSpinLockRaiseToDpc)

        mov         t2 = DISPATCH_LEVEL
        ;;
        SWAP_IRQL   (t2)

#if !defined(NT_UP)

        cmp.eq      pt0, pt1 = zero, zero
        cmp.eq      pt2, pt3 = zero, zero
        ;;

Kaslrtp10:
.pred.rel "mutex",pt0,pt1
(pt0)   xchg8       t0 = [a0], a0
(pt1)   ld8.nt1     t0 = [a0]
        ;;
(pt0)   cmp.ne      pt2, pt3 = zero, t0
        cmp.eq      pt0, pt1 = zero, t0
        ;;
(pt2)   br.dpnt     Kaslrtp10
(pt3)   br.ret.dptk brp

#else

        LEAF_RETURN

#endif // !defined(NT_UP)

        LEAF_EXIT(KeAcquireSpinLockRaiseToDpc)



//++
//
// VOID
// KiReleaseSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function releases a kernel spin lock.
//
//    N.B. This function assumes that the current IRQL is set properly.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to an executive spin lock.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiReleaseSpinLock)
        ALTERNATE_ENTRY(KeReleaseSpinLockFromDpcLevel)

#if !defined(NT_UP)
        st8.rel     [a0] = zero             // set spin lock not owned
#endif

        LEAF_RETURN
        LEAF_EXIT(KiReleaseSpinLock)


//++
//
// VOID
// KeReleaseSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    IN KIRQL OldIrql
//    )
//
// Routine Description:
//
//    This function releases an executive spin lock and lowers the IRQL
//    to its previous value.  Called at DPC_LEVEL.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to an executive spin lock.
//
//    OldIrql (a1) - Supplies the previous IRQL value.
//
// Return Value:
//
//    None.
//
//--


        LEAF_ENTRY(KeReleaseSpinLock)

        zxt1        a1 = a1

#if !defined(NT_UP)
        st8.rel     [a0] = zero                 // set spinlock not owned
#endif

        ;;
        LEAF_LOWER_IRQL_AND_RETURN(a1)          // Lower IRQL and return

        LEAF_EXIT(KeReleaseSpinLock)

//++
//
// BOOLEAN
// KeTryToAcquireSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    OUT PKIRQL OldIrql
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to DISPATCH_LEVEL and attempts
//    to acquires the specified executive spinlock. If the spinlock can be
//    acquired, then TRUE is returned. Otherwise, the IRQL is restored to
//    its previous value and FALSE is returned. Called at IRQL <= DISPATCH_LEVEL.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a executive spinlock.
//
//    OldIrql  (a1) - Supplies a pointer to a variable that receives the
//        the previous IRQL value.
//
// Return Value:
//
//    If the spin lock is acquired, then a value of TRUE is returned.
//    Otherwise, a value of FALSE is returned.
//
// N.B. This routine assumes KeTryToAcquireSpinLockAtDpcLevel pt1 & pt2 will
//      be set to reflect the result of the attempt to acquire the spinlock.
//
//--

        LEAF_ENTRY(KeTryToAcquireSpinLock)

        rOldIrql    = t2

//
// Raise IRQL to DISPATCH_LEVEL and try to acquire the specified spinlock.
// Return FALSE if failed; otherwise, return TRUE.
//

        GET_IRQL    (rOldIrql)                  // get original IRQL
        mov         t0 = DISPATCH_LEVEL;;
        SET_IRQL    (t0)                        // raise to dispatch level

#if !defined(NT_UP)

        xchg8       t0 = [a0], a0
        ;;
        cmp.ne      pt2 = t0, zero              // if ne, lock acq failed
        ;;


//
// If successfully acquired, pt1 is set to TRUE while pt2 is set to FALSE.
// Otherwise, pt2 is set to TRUE while pt1 is set to FALSE.
//

  (pt2) mov         v0 = FALSE                  // return FALSE
        PSET_IRQL   (pt2, rOldIrql)             // restore old IRQL
  (pt2) LEAF_RETURN
        ;;

#endif // !defined(NT_UP)

        st1         [a1] = rOldIrql             // save old IRQL
        mov         v0 = TRUE                   // successfully acquired
        LEAF_RETURN

        LEAF_EXIT(KeTryToAcquireSpinLock)


#if !defined(NT_UP)
//++
//
// BOOLEAN
// KeTestSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function tests a kernel spin lock.  If the spinlock is
//    busy, FALSE is returned.  If not, TRUE is returned.  The spinlock
//    is never acquired.  This is provided to allow code to spin at low
//    IRQL, only raising the IRQL when there is a reasonable hope of
//    acquiring the lock.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a kernel spin lock.
//
// Return Value:
//
//    TRUE  - Spinlock appears available
//    FALSE - SpinLock is busy
//--

        LEAF_ENTRY(KeTestSpinLock)

        ld8.nt1    t0 = [a0]
        ;;
        cmp.ne     pt0 = 0, t0
        mov        v0 = TRUE                        // default TRUE
        ;;

 (pt0)  mov        v0 = FALSE                       // if t0 != 0 return FALSE
        LEAF_RETURN

        LEAF_EXIT(KeTestSpinLock)
#endif // !defined(NT_UP)



        SBTTL("Acquire Queued SpinLock and Raise IRQL")
//++
//
// VOID
// KeAcquireInStackQueuedSpinLock (
//    IN PKSPIN_LOCK SpinLock,
//    IN PKLOCK_QUEUE_HANDLE LockHandle
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to dispatch level and
//    acquires the specified queued spinlock.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a spin lock.
//
//    LockHandle (a1) - Supplies a pointer to a lock handle.
//
// Return Value:
//
//    None.
//
//--
        LEAF_ENTRY(KeAcquireInStackQueuedSpinLockRaiseToSynch)

        add        t5 = LqhNext, a1
        mov        t1 = SYNCH_LEVEL
        br.sptk    Kaisqsl10
        ;;


        ALTERNATE_ENTRY(KeAcquireInStackQueuedSpinLock)

        add        t5 = LqhNext, a1
        mov        t1 = DISPATCH_LEVEL
        ;;

Kaisqsl10:
#if !defined(NT_UP)

        st8        [t5] = zero               // set next link to NULL
        add        t4 = LqhLock, a1
        ;;

        st8.rel    [t4] = a0                 // set spin lock address

#endif // !defined(NT_UP)

        SWAP_IRQL (t1)                       // old IRQL in register v0
        add        t0 = LqhOldIrql, a1
        ;;

        st1        [t0] = v0                 // save old IRQL

#if !defined(NT_UP)

        //
        // Finish in common code.   The following register values
        // are assumed in that code.
        //
        // t4 = &LockEntry->ActualLock
        // t5 = LockEntry
        // a0 = *(&LockEntry->ActualLock)
        //
        // Note: LqhNext == 0, otherwise we would have to trim t5 here.
        //

        br         KxqAcquireQueuedSpinLock  // finish in common code

#else

        br.ret.sptk brp

#endif !defined(NT_UP)

        LEAF_EXIT(KeAcquireInStackQueuedSpinLock)


        SBTTL("Acquire Queued SpinLock and Raise IRQL")
//++
//
// KIRQL
// KeAcquireQueuedSpinLock (
//    IN KSPIN_LOCK_QUEUE_NUMBER Number
//    )
//
// KIRQL
// KeAcquireQueuedSpinLockRaiseToSynch (
//    IN KSPIN_LOCK_QUEUE_NUMBER Number
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to synchronization level and
//    acquires the specified queued spinlock.
//
// Arguments:
//
//    Number (a0) - Supplies the queued spinlock number.
//
// Return Value:
//
//    The previous IRQL is returned as the function value.
//
//--

        LEAF_ENTRY(KeAcquireQueuedSpinLock)

        add        t0 = a0, a0
        mov        t1 = DISPATCH_LEVEL
        br         Kaqsl10
        ;;

        ALTERNATE_ENTRY(KeAcquireQueuedSpinLockRaiseToSynch)

        add        t0 = a0, a0
        mov        t1 = SYNCH_LEVEL
        ;;

Kaqsl10:

        SWAP_IRQL (t1)                      // old IRQL in register v0

#if !defined(NT_UP)
        movl       t2 = KiPcr+PcPrcb
        ;;
        ld8        t2 = [t2]
        ;;
        shladd     t3 = t0, 3, t2           // get associated spinlock addr
        ;;
        add        t5 = PbLockQueue, t3
        ;;

        add        t4 = LqLock, t5
        ;;
        ld8        t6 = [t4]
        mov        t11 = 0x7
        ;;

        andcm      a0 = t6, t11             // mask the lower 3 bits
        ;;

        ALTERNATE_ENTRY(KxqAcquireQueuedSpinLock)

        mf         // Do a memory fence to ensure the write of LqhNext 
                   // occurs before the xchg8 on lock address.
                   
        //
        // t4 = &LockEntry->ActualLock
        // t5 = LockEntry
        // a0 = *(&LockEntry->ActualLock)
        //

        xchg8      t7 = [a0], t5
        ;;
        cmp.ne     pt0, pt1 = r0, t7        // if ne, lock already owned
        ;;
 (pt1)  or         t8 = LOCK_QUEUE_OWNER, a0
 (pt0)  or         t8 = LOCK_QUEUE_WAIT, a0
        ;;

        st8.rel    [t4] = t8
        add        t9 = LqNext, t7
 (pt1)  br.ret.sptk brp
        ;;

        //
        // The lock is already held by another processor.  Set the wait
        // bit in this processor's Lock Queue entry, then set the next
        // field in the Lock Queue entry of the last processor to attempt
        // to acquire the lock (this is the address returned by the xchg
        // above) to point to THIS processor's lock queue entry.
        //

        st8.rel    [t9] = t5

Kaqsl20:
        ld8        t10 = [t4]
        ;;
        tbit.z     pt1, pt0 = t10, LOG2(LOCK_QUEUE_WAIT)
 (pt0)  br.dptk.few Kaqsl20
 (pt1)  br.ret.dpnt brp                    // if zero, lock acquired

#else
        br.ret.sptk brp
#endif // !defined(NT_UP)
        ;;

        LEAF_EXIT(KeAcquireQueuedSpinLock)

        SBTTL("Release Queued SpinLock and Lower IRQL")
//++
//
// VOID
// KeReleaseInStackQueuedSpinLock (
//    IN PKLOCK_QUEUE_HANDLE LockHandle
//    )
//
// Routine Description:
//
//    This function releases a queued spinlock and lowers the IRQL to its
//    previous value.
//
// Arguments:
//
//    LockHandle (a0) - Supplies a pointer to a lock handle.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeReleaseInStackQueuedSpinLock)

        alloc      t22 = ar.pfs, 2, 2, 2, 0
        add        t9 = LqhOldIrql, a0
        add        t5 = LqhNext, a0              // set address of lock queue
        ;;

        ld1.nt1    a1 = [t9]                     // get old IRQL
        br         KxqReleaseQueuedSpinLock      // finish in common code

        LEAF_EXIT(KeReleaseInStackQueuedSpinLock)


        SBTTL("Release Queued SpinLock and Lower IRQL")
//++
//
// VOID
// KeReleaseQueuedSpinLock (
//    IN KSPIN_LOCK_QUEUE_NUMBER Number,
//    IN KIRQL OldIrql
//    )
//
// Routine Description:
//
//    This function releases a queued spinlock and lowers the IRQL to its
//    previous value.
//
// Arguments:
//
//    Number (a0) - Supplies the queued spinlock number.
//
//    OldIrql (a1) - Supplies the previous IRQL value.
//
// Return Value:
//
//    None.
//
//--


        LEAF_ENTRY(KeReleaseQueuedSpinLock)
        PROLOGUE_BEGIN

#if !defined(NT_UP)
        movl        v0 = KiPcr+PcPrcb
        ;;

        ld8         v0 = [v0]
        add         t0 = a0, a0
        ;;
        shladd      t1 = t0, 3, v0
        ;;

        add         t5 = PbLockQueue, t1
        ;;
#endif // !defined(NT_UP)

        ALTERNATE_ENTRY(KxqReleaseQueuedSpinLock)

#if !defined(NT_UP)
        add         v0 = LqNext, t5
        add         t2 = LqLock, t5
        ;;

        ld8.acq     t4 = [t2]
        mov         ar.ccv = t5

        ld8         t3 = [v0]
        ;;
        and         t4 = ~LOCK_QUEUE_OWNER, t4   // clear lock owner bit
        ;;
        add         t6 = LqLock, t3

        st8.rel     [t2] = t4
        cmp.ne      pt0, pt1 = r0, t3       // if ne, another processor waiting
(pt0)   br.sptk.few Krqsl30

        ld8         t7 = [t4]
        ;;
        cmp.ne      pt2 = t5, t7
(pt2)   br.spnt.few Krqsl20

        cmpxchg8.rel t8 = [t4], r0, ar.ccv
        ;;
        cmp.ne      pt0, pt1 = t8, t5       // if ne, another processor waiting
(pt0)   br.spnt.few Krqsl20
        ;;

Krqsl10:

#endif // !defined(NT_UP)

        LEAF_LOWER_IRQL_AND_RETURN(a1)      // lower IRQL to previous level
        ;;

#if !defined(NT_UP)

//
// Another processor has inserted its lock queue entry in the lock queue,
// but has not yet written its lock queue entry address in the current
// processor's next link. Spin until the lock queue address is written.
//

Krqsl20:
        ld8         t3 = [v0]               // get next lock queue entry addr
        ;;
        cmp.eq      pt0 = r0, t3            // if eq, addr not written yet
        add         t6 = LqLock, t3
 (pt0)  br.sptk     Krqsl20                 // try again
        ;;

//
// Grant the next process in the lock queue ownership of the spinlock.
// (Turn off the WAIT bit and on the OWNER bit in the next entries lock
// field).
//

Krqsl30:

        ld8.nt1     t2 = [t6]               // get spinlock addr and lock bit
        ;;
        st8         [v0] = r0               // clear next lock queue entry addr
        ;;
        xor         t2 = (LOCK_QUEUE_OWNER|LOCK_QUEUE_WAIT), t2
        ;;
        st8.rel     [t6] = t2
        br          Krqsl10
        ;;

#endif // !defined(NT_UP)

        LEAF_EXIT(KeReleaseQueuedSpinLock)



        SBTTL("Try to Acquire Queued SpinLock and Raise IRQL")
//++
//
// LOGICAL
// KeTryToAcquireQueuedSpinLock (
//    IN KSPIN_LOCK_QUEUE_NUMBER Number
//    OUT PKIRQL OldIrql
//    )
//
// LOGICAL
// KeTryToAcquireQueuedSpinLockRaiseToSynch (
//    IN KSPIN_LOCK_QUEUE_NUMBER Number
//    OUT PKIRQL OldIrql
//    )
//
// LOGICAL
// KeTryToAcquireQueuedSpinLockAtRaisedIrql (
//    IN PKSPIN_LOCK_QUEUE LockQueue
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to synchronization level and
//    attempts to acquire the specified queued spinlock. If the spinlock
//    cannot be acquired, then IRQL is restored and FALSE is returned as
//    the function value. Otherwise, TRUE is returned as the function
//    value.
//
// Arguments:
//
//    Number (a0) - Supplies the queued spinlock number.
//
//    OldIrql  (a1) - Supplies a pointer to a variable that receives the
//        the previous IRQL value.
//
// Return Value:
//
//    If the spin lock is acquired, then a value of TRUE is returned.
//    Otherwise, a value of FALSE is returned.
//
//--

        LEAF_ENTRY(KeTryToAcquireQueuedSpinLock)

        movl       t2 = KiPcr+PcPrcb

        mov        t1 = DISPATCH_LEVEL
        br         Kttaqsl10
        ;;

        ALTERNATE_ENTRY(KeTryToAcquireQueuedSpinLockRaiseToSynch)

        mov        t1 = SYNCH_LEVEL
        movl       t2 = KiPcr+PcPrcb
        ;;

Kttaqsl10:

#if !defined(NT_UP)

        rsm        1 << PSR_I               // disable interrupts
        ld8        t2 = [t2]                // get PRCB address
        ;;
        shladd     t3 = a0, 4, t2           // get address of lock queue entry
        ;;
        add        t5 = PbLockQueue, t3
        add        t6 = LqLock+PbLockQueue, t3
        ;;

        ld8        t4 = [t6]                // get associated spinlock addr
        mov        ar.ccv = r0              // cmpxchg oldvalue must be 0
        mov        t11 = 0x7
        ;;
        andcm      t12 = t4, t11
        ;;

//
// Try to acquire the specified spinlock.
//
// N.B. A noninterlocked test is done before the interlocked attempt. This
//      allows spinning without interlocked cycles.
//

        ld8        t8 = [t12]               // get current lock value
        ;;
        cmp.ne     pt0, pt1 = r0, t8        // if ne, lock owned
 (pt0)  br.spnt.few Kttaqs20
        ;;

        cmpxchg8.acq t8 = [t12], t5, ar.ccv // try to acquire the lock
        ;;

        cmp.ne     pt0, pt1 = r0, t8        // if ne, lock owned
        or         t4 = LOCK_QUEUE_OWNER, t4// set lock owner bit
 (pt0)  br.spnt.few Kttaqs20
        ;;

        st8        [t6] = t4

#endif

        SWAP_IRQL(t1)

#if !defined(NT_UP)

        ssm         1 << PSR_I              // enable interrupts

#endif

        st1        [a1] = v0                // save old IRQL value
        mov        v0 = TRUE                // set return value to TRUE
        LEAF_RETURN
        ;;

#if !defined(NT_UP)

//
// The attempt to acquire the specified spin lock failed. Lower IRQL to its
// previous value and return FALSE.
//

Kttaqs20:
        ssm         1 << PSR_I              // enable interrupts
        mov         v0 = FALSE              // set return value to FALSE
        LEAF_RETURN

#endif

        LEAF_EXIT(KeTryToAcquireQueuedSpinLock)

        SBTTL("Try to Acquire Queued SpinLock without raising IRQL")
//++
//
// LOGICAL
// KeTryToAcquireQueuedSpinLockAtRaisedIrql (
//    IN PKSPIN_LOCK_QUEUE LockQueue
//    )
//
// Routine Description:
//
//    This function attempts to acquire the specified queued spinlock.
//    If the spinlock cannot be acquired, then FALSE is returned as
//    the function value. Otherwise, TRUE is returned as the function
//    value.
//
// Arguments:
//
//    LockQueue (a0) - Supplies the address of the queued spinlock.
//
// Return Value:
//
//    If the spin lock is acquired, then a value of TRUE is returned.
//    Otherwise, a value of FALSE is returned.
//
//--

        LEAF_ENTRY(KeTryToAcquireQueuedSpinLockAtRaisedIrql)

#if !defined(NT_UP)

        add        t6 = LqLock, a0
        ;;

        ld8        t4 = [t6]                // get associated spinlock addr
        mov        ar.ccv = r0              // cmpxchg oldvalue must be 0
        mov        t11 = 0x7
        ;;
        andcm      t12 = t4, t11
        ;;

//
// Try to acquire the specified spinlock.
//
// N.B. A noninterlocked test is done before the interlocked attempt. This
//      allows spinning without interlocked cycles.
//

        ld8        t8 = [t12]               // get current lock value
        mov        v0 = FALSE               // assume failure
        ;;
        cmp.ne     pt0, pt1 = r0, t8        // if ne, lock owned
 (pt0)  br.ret.spnt.few.clr brp             // if owned, return failure
        ;;

        cmpxchg8.acq t8 = [t12], a0, ar.ccv // try to acquire the lock
        ;;

        cmp.ne     pt0, pt1 = r0, t8        // if ne, lock owned
        or         t4 = LOCK_QUEUE_OWNER, t4// set lock owner bit
 (pt0)  br.ret.spnt.few.clr brp             // if owned, return failure
        ;;

        st8        [t6] = t4

#endif

        mov        v0 = TRUE                // set return value to TRUE
        LEAF_RETURN
        ;;

        LEAF_EXIT(KeTryToAcquireQueuedSpinLockAtRaisedIrql)


        SBTTL("Acquire Queued SpinLock at Current IRQL")

//++
// VOID
// KeAcquireInStackQueuedSpinLockAtDpcLevel (
//    IN PKSPIN_LOCK SpinLock,
//    IN PKLOCK_QUEUE_HANDLE LockHandle
//    )
//
// Routine Description:
//
//    This function acquires the specified queued spinlock at the current
//    IRQL.
//
// Arguments:
//
//    SpinLock (a0) - Supplies the address of a spin lock.
//
//    LockHandle (a1) - Supplies the address of an in stack lock handle.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeAcquireInStackQueuedSpinLockAtDpcLevel)

#if !defined(NT_UP)

        add         t0 = LqhNext, a1
        add         t1 = LqhLock, a1
        ;;
        st8         [t0] = r0
        st8         [t1] = a0
        add         a0 = LqhNext, a1
        ;;

#endif // !defined(NT_UP)

//++
//
// VOID
// KeAcquireQueuedSpinLockAtDpcLevel (
//    IN PKSPIN_LOCK_QUEUE LockQueue
//    )
//
// Routine Description:
//
//    This function acquires the specified queued spinlock at the current
//    IRQL.
//
// Arguments:
//
//    LockQueue (a0) - Supplies the address of the lock queue entry.
//
// Return Value:
//
//    None.
//
//--

        ALTERNATE_ENTRY(KeAcquireQueuedSpinLockAtDpcLevel)

#if !defined(NT_UP)
        add         t0 = LqLock, a0
        add         t1 = LqNext, a0
        mov         t11 = 0x7
        ;;

        ld8         t4 = [t0]
        ;;
        mf
        andcm       t12 = t4, t11             // mask the lower 3 bits
        ;;

        xchg8       t3 = [t12], a0
        or          t5 = LOCK_QUEUE_OWNER, t4 // set lock owner bit
        ;;

        cmp.ne      pt0, pt1 = r0, t3         // if ne, lock already owned
        add         t2 = LqNext, t3
        ;;
 (pt0)  or          t5 = LOCK_QUEUE_WAIT, t4
        ;;

        st8.rel     [t0] = t5
 (pt0)  st8.rel     [t2] = a0                 // set addr of lock queue entry
 (pt1)  br.ret.sptk brp
        ;;

//
// The lock is owned by another processor. Set the lock bit in the current
// processor lock queue entry, set the next link in the previous lock queue
// entry, and spin on the current processor's lock bit.
//

Kiaqsl10:
        ld8         t4 = [t0]                 // get lock addr and lock wait bit
        ;;
        tbit.z      pt1, pt0 = t4, LOG2(LOCK_QUEUE_WAIT)
 (pt0)  br.dptk.few Kiaqsl10
 (pt1)  br.ret.dpnt brp                       // if zero, lock acquired

#else
        br.ret.sptk brp
#endif // !defined(NT_UP)
        ;;

        LEAF_EXIT(KeAcquireInStackQueuedSpinLockAtDpcLevel)


        SBTTL("Release Queued SpinLock at Current IRQL")

//++
//
// VOID
// KeReleaseInStackQueuedSpinLockFromDpcLevel (
//    IN PKLOCK_QUEUE_HANDLE LockHandle
//    )
//
// Routine Description:
//
//    This function releases a queued spinlock and preserves the current
//    IRQL.
//
// Arguments:
//
//    LockHandle (a0) - Supplies the address of a lock handle.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeReleaseInStackQueuedSpinLockFromDpcLevel)

#if !defined(NT_UP)
        add         a0 = LqhNext, a0
        ;;
#endif // !defined(NT_UP)

//++
//
// VOID
// KiReleaseQueuedSpinLock (
//    IN PKSPIN_LOCK_QUEUE LockQueue
//    )
//
// Routine Description:
//
//    This function releases a queued spinlock and preserves the current
//    IRQL.
//
// Arguments:
//
//    LockQueue (a0) - Supplies the address of the lock queue entry.
//
// Return Value:
//
//    None.
//
//--

        ALTERNATE_ENTRY(KeReleaseQueuedSpinLockFromDpcLevel)

#if !defined(NT_UP)
        mov         ar.ccv = a0
        add         t0 = LqNext, a0
        add         t1 = LqLock, a0
        ;;

        ld8         t3 = [t0]                  // get next lock queue entry addr
        ld8         t4 = [t1]                  // get associate spin lock addr
        ;;
        and         t4 = ~LOCK_QUEUE_OWNER, t4 // clear lock owner bit
        ;;

        st8.rel     [t1] = t4
        cmp.ne      pt0, pt1 = r0, t3    // if ne, another processor waiting
 (pt0)  br.spnt.few Kirqsl30

KiIrqsl10:

        ld8.nt1     t3 = [t4]            // get current lock ownership
        ;;
        cmp.ne      pt0, pt1 = a0, t3    // if ne, another processor waiting
 (pt0)  br.spnt.few Kirqsl20
        ;;

        cmpxchg8.rel t3 = [t4], r0, ar.ccv
        ;;
        cmp.ne      pt0, pt1 = a0, t3    // if ne, try again
 (pt1)  br.ret.sptk brp
        ;;

//
// Another processor has inserted its lock queue entry in the lock queue,
// but has not yet written its lock queue entry address in the current
// processor's next link. Spin until the lock queue address is written.
//

Kirqsl20:

        ld8         t3 = [t0]               // get next lock queue entry addr
        ;;
        cmp.eq      pt0 = r0, t3            // if eq, addr not written yet
 (pt0)  br.sptk     Kirqsl20                // try again

Kirqsl30:

        add         t6 = LqLock, t3
        ;;
        ld8.nt1     t2 = [t6]               // get spinlock addr and lock bit
        st8         [t0] = r0               // clear next lock queue entry addr
        ;;
        // Set owner bit, clear wait bit.
        xor         t2 = (LOCK_QUEUE_OWNER|LOCK_QUEUE_WAIT), t2
        ;;
        st8.rel     [t6] = t2
#endif // !defined(NT_UP)

        br.ret.sptk brp
        ;;

        LEAF_EXIT(KeReleaseInStackQueuedSpinLockFromDpcLevel)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\mp\makefile.inc ===
#
#  Currently the MP and UP files are the same.
#
!INCLUDE ..\up\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\threadbg.s ===
//      TITLE("Thread Startup")
//++
//
// Module Name:
//
//    threadbg.s
//
// Abstract:
//
//    This module implements the MIPS machine dependent code necessary to
//    startup a thread in kernel mode.
//
// Author:
//
//    Bernard Lint 19-Mar-1996
//
// Environment:
//
//    Kernel mode only, IRQL APC_LEVEL.
//
// Revision History:
//
//    Based on MIPS version (David N. Cutler (davec) 28-Mar-1990)
//
//--

#include "ksia64.h"

//
// Globals used
//

         PublicFunction(KeBugCheck)
         PublicFunction(KiRestoreExceptionFrame)
         PublicFunction(KiExceptionExit)

        SBTTL("Thread Startup")

//++
//
// Routine Description:
//
//    This routine is called at thread startup. Its function is to call the
//    initial thread procedure. If control returns from the initial thread
//    procedure and a user mode context was established when the thread
//    was initialized, then the user mode context is restored and control
//    is transfered to user mode. Otherwise a bug check will occur.
//
//    When this thread was created, a switch frame for SwapContext was pushed
//    onto the stack and initialized such that SwapContext will return to
//    the first instruction of this routine when this thread is first switched to.
//
// Arguments:
//
//    s0 (saved) - Supplies a boolean value that specified whether a user
//       mode thread context was established when the thread was initialized.
//
//    s1 (saved) - Supplies the starting context parameter for the initial
//       thread procedure.
//
//    s2 (saved) - Supplies the starting address of the initial thread routine.
//
//       N.B. This is a function pointer.
//
//    s3 - Supplies the starting address of the initial system routine.
//
//       N.B. This is an entry point.
//
// On entry:
//
//      Since SwapConext deallocates the switch frame sp points to either:
//            for system thread sp -> bottom of kernel stack;
//            for user thread sp -> exception frame (or higher fp savearea 
//            if not FPLAZY)
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(KiThreadDispatch)

//
// N.B. The following code is never executed.  Its purpose is to allow the
//      kernel debugger to walk call frames backwards through thread startup
//      and to support get/set user context.
//

        .regstk   0,2,2,0
        .prologue 0xC, loc0

        .fframe   ExceptionFrameLength
        add       sp = -ExceptionFrameLength, sp
        ;;
        add       t0 = ExFltS19+STACK_SCRATCH_AREA, sp
        add       t1 = ExFltS18+STACK_SCRATCH_AREA, sp
        ;;

        .save.gf  0x0, 0xC0000
        stf.spill [t0] = fs19, ExFltS17-ExFltS19
        stf.spill [t1] = fs18, ExFltS16-ExFltS18
        ;;

        .save.gf  0x0, 0x30000
        stf.spill [t0] = fs17, ExFltS15-ExFltS17
        stf.spill [t1] = fs16, ExFltS14-ExFltS16
        mov       t10 = bs4
        ;;

        .save.gf  0x0, 0xC000
        stf.spill [t0] = fs15, ExFltS13-ExFltS15
        stf.spill [t1] = fs14, ExFltS12-ExFltS14
        mov       t11 = bs3
        ;;

        .save.gf  0x0, 0x3000
        stf.spill [t0] = fs13, ExFltS11-ExFltS13
        stf.spill [t1] = fs12, ExFltS10-ExFltS12
        mov       t12 = bs2
        ;;

        .save.gf  0x0, 0xC00
        stf.spill [t0] = fs11, ExFltS9-ExFltS11
        stf.spill [t1] = fs10, ExFltS8-ExFltS10
        mov       t13 = bs1
        ;;

        .save.gf  0x0, 0x300
        stf.spill [t0] = fs9, ExFltS7-ExFltS9
        stf.spill [t1] = fs8, ExFltS6-ExFltS8
        mov       t14 = bs0
        ;;

        .save.gf  0x0, 0xC0
        stf.spill [t0] = fs7, ExFltS5-ExFltS7
        stf.spill [t1] = fs6, ExFltS4-ExFltS6
        mov       t15 = ar.lc
        ;;

        .save.gf  0x0, 0x30
        stf.spill [t0] = fs5, ExFltS3-ExFltS5
        stf.spill [t1] = fs4, ExFltS2-ExFltS4
        ;;

        .save.f   0xC
        stf.spill [t0] = fs3, ExFltS1-ExFltS3         // save fs3
        stf.spill [t1] = fs2, ExFltS0-ExFltS2         // save fs2
        ;;

        .save.f   0x3
        stf.spill [t0] = fs1, ExBrS4-ExFltS1          // save fs1
        stf.spill [t1] = fs0, ExBrS3-ExFltS0          // save fs0
        ;;

        .save.b   0x18
        st8       [t0] = t10, ExBrS2-ExBrS4           // save bs4
        st8       [t1] = t11, ExBrS1-ExBrS3           // save bs3
        ;;

        .save.b   0x6
        st8       [t0] = t12, ExBrS0-ExBrS2           // save bs2
        st8       [t1] = t13, ExIntS2-ExBrS1          // save bs1
        ;;

        .save.b   0x1
        st8       [t0] = t14, ExIntS3-ExBrS0          // save bs0
        ;;

        .save.gf  0xC, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s3, ExIntS1-ExIntS3          // save s3
        .mem.offset 8,0
        st8.spill [t1] = s2, ExIntS0-ExIntS2          // save s2
        ;;

        .save.gf  0x3, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s1, ExApLC-ExIntS1           // save s1
        .mem.offset 8,0
        st8.spill [t1] = s0, ExApEC-ExIntS0           // save s0
        ;;

        .savepsp  ar.pfs, ExceptionFrameLength-ExApEC-STACK_SCRATCH_AREA
        st8       [t1] = t16, ExIntNats-ExApEC
        mov       t4 = ar.unat                        // captured Nats of s0-s3
        ;;

        .savepsp  ar.lc, ExceptionFrameLength-ExApLC-STACK_SCRATCH_AREA
        st8       [t0] = t15
        .savepsp  @priunat, ExceptionFrameLength-ExIntNats-STACK_SCRATCH_AREA
        st8       [t1] = t4                           // save Nats of s0-s3
        ;;


        ALTERNATE_ENTRY(KiThreadStartup)
         
        alloc     t0 = 0,2,2,0                  // allocate call frame 
        mov       savedpfs = zero               // setup bogus brp and pfs
        mov       savedbrp = zero               // to stop stack unwind
                                                // by the debugger
        ;;

        PROLOGUE_END

//
// restore the preserved states from the switch frame and then deallocate it
//

        add       out0 = SwExFrame+STACK_SCRATCH_AREA,sp
        br.call.sptk brp = KiRestoreExceptionFrame
        ;;

//
// Lower IRQL to APC_LEVEL
//

        add       sp = SwitchFrameLength, sp
        mov       bt0 = s3                      // setup call to system routine
        mov       t0 = APC_LEVEL
        ;;

        SET_IRQL(t0)

        mov       out0 = s2                     // arg 1 = thread routine (a function pointer)
        mov       out1 = s1                     // arg 2 = thread context
        br.call.sptk brp = bt0                  // call system routine
        ;;

//
// Finish in common exception exit code which will restore the nonvolatile
// registers and exit to user mode.
//
// N.B. predicate register alias pUstk & pKstk must be the same as trap.s
//      and they must be set up correctly upon entry into KiExceptionExit.
//
//
// If pKstk is set, an attempt was made to enter user mode for a thread 
// that has no user mode context. Generate a bug check.
//

        pUstk     = ps3
        pKstk     = ps4

        cmp.eq      pKstk, pUstk = zero, s0      // if s0 is zero, no user context (system thread)
        mov         out0 = NO_USER_MODE_CONTEXT  // set bug check code
(pKstk) br.call.spnt brp = KeBugCheck

//
// Set up for branch to KiExceptionExit
//
//      s0 = trap frame
//      s1 = exception frame
//

        //
        // Interrupts must be disabled before calling KiExceptionExit
        // because the unwind code cannot unwind from that point.
        //
        
        FAST_DISABLE_INTERRUPTS
        add         s1 = STACK_SCRATCH_AREA, sp
        add         s0 = ExceptionFrameLength, sp
        br          KiExceptionExit
        ;;

        NESTED_EXIT(KiThreadDispatch)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\start.s ===
//      TITLE("System Initialization")
//++
//
// Module Name:
//
//       start.s
//
// Abstract:
//
//       This module implements the code necessary to initially startup the
//       NT system.
//
// Author:
//
//       Bernard Lint 8-Dec-1995
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//    Based on MIPS version (from David N. Cutler (davec) 5-Apr-1991)
//
//--

#include "ksia64.h"

         PublicFunction(SwapFromIdle)
         PublicFunction(KeBugCheck)
         PublicFunction(KiInitializeKernel)
         PublicFunction(KeLowerIrql)
         PublicFunction(KiNormalSystemCall)
         PublicFunction(KiRetireDpcList)
         PublicFunction(KeAcquireQueuedSpinLockAtDpcLevel)
         PublicFunction(KeReleaseQueuedSpinLockFromDpcLevel)
         PublicFunction(KeTryToAcquireQueuedSpinLockRaiseToSynch)

         .global    __imp_HalProcessorIdle
         .global    KiIvtBase
         .global    KiIA64PtaContents

#if !defined(NT_UP)
         .global    HalAllProcessorsStarted
         .global    KeNumberProcessors
         .global    KiBarrierWait
         .global    KiKernelPcrPage
#endif // !defined(NT_UP)

#if DBG
         PublicFunction(KdPollBreakIn)
         PublicFunction(DbgBreakPointWithStatus)
         .global    KdDebuggerEnabled
#endif // DBG

        SBTTL("System Initialization")
//++
// Routine:
//
//       VOID
//       KiSystemBegin (
//           PLOADER_PARAMETER_BLOCK)
//
// Routine Description:
//
//       This routine is called when the NT system begins execution.
//       Its function is to initialize system hardware state, call the
//       kernel initialization routine, and then fall into code that
//       represents the idle thread for all processors.
//
// Arguments:
//
//       a0 - Supplies a pointer to the loader parameter block.
//
// Return Value:
//
//       None.
//
// Note:
//
//       On entry the global pointer (gp) is initialized for this module (the
//       NTOS kernel) by the loader.
//
//--

         NESTED_ENTRY(KiSystemBegin)
         ALTERNATE_ENTRY(_start)
         NESTED_SETUP(1,2,6,0)                   // Also see "alloc" below

//
// Register aliases
//

         rpT1      = t0
         rpT2      = t1
         rpT3      = t2
         rT1       = t3
         rT2       = t4
         rT3       = t5
         rT4       = t6

         rpLpb     = t7
         rThread   = t8
         rPcrPfn   = t9
         rPrcb     = t10
         rPcr2Pfn  = t11
         rProcNum  = t12
         rPKR      = t13
         rPkrNum   = t14
         rRR       = t15
         rKstack   = t16
         rVa       = t17
         rPcrTr    = t18
         rpPcr     = t19

         FAST_DISABLE_INTERRUPTS                 // disable interrupts
//
// invalidate ITR used by SAL.
//

         mov       rT2 = 0x14 << 2
         movl      rT3 = 0x03f00000
         ;;

         ptr.i     rT3, rT2

         ALTERNATE_ENTRY(KiInitializeSystem)

         mov       ar.rsc = r0                   // put RSE in lazy mode
         movl      rT2 = KiIvtBase
         ;;

         rsm       1 << PSR_IC                   // PSR.ic = 0
         mov       cr.iva = rT2
#if !defined(NT_UP)
         add       rpT1 = @gprel(KiKernelPcrPage), gp
         ;;
         ld8       rPcrPfn = [rpT1]
#else
         mov       rPcrPfn = 0
#endif
         ;;

         srlz.d
         add       rpT2 = LpbPcrPage, a0         // -> PCR page number
         cmp.eq    pt0, pt1 = 0, rPcrPfn
         ;;

//
// Initialize fixed TLB entries that map the PCR into system and user space.
// N.B. These pages are per *processor* so we need a fixed mapping.
//

 (pt0)   ld8       rPcrPfn = [rpT2]              // set PCR page number
         movl      rVa = KiPcr                   // set virtual address of PCR
         ;;

         mov       cr.ifa = rVa                  // setup IFA for insert
         mov       rT1 = PAGE_SHIFT << IDTR_PS
         shl       rPcrPfn = rPcrPfn, PAGE_SHIFT // shift to PPN field
         ;;

         mov       cr.itir = rT1                 // setup IDTR
         movl      rPcrTr = KIPCR_TR_INITIAL     // PCR translation except for PPN

         mov       rT2 = DTR_KIPCR_INDEX
         ;;
         or        rPcrTr = rPcrPfn, rPcrTr      // form full TR
         ;;

         itr.d     dtr[rT2] = rPcrTr             // insert PCR TR to DTR
         ssm       1 << PSR_IC                   // PSR.ic = 1
         ;;

         srlz.i                                  // I serialize
         add       rpT1 = LpbKernelStack, a0     // -> idle thread stack
         mov       rpLpb = a0                    // save a0
         ;;

         LDPTR     (rKstack, rpT1)               // rKstack = idle thread stack
                                                 // N.B. This is also the base
                                                 //      of backing store
         ;;
         mov       ar.bspstore = rKstack         // setup BSP
         .fframe   STACK_SCRATCH_AREA
         add       sp = -STACK_SCRATCH_AREA, rKstack  // set sp
         ;;

         loadrs                                  // invalidate RSE
         invala
         ;;

         mov       ar.rsc = RSC_KERNEL           // put RSE in eager mode
         ;;

         alloc     rT4 = ar.pfs,1,2,6,0          // keep in sync with entry point alloc

         mov       savedbrp = zero               // setup bogus brp and pfs to
         mov       savedpfs = zero               // stop the debugger

         PROLOGUE_END

//
// Get page frame numbers for the PCR and PDR pages that were allocated by
// the OS loader. Page directory is 4 physically contiguous pages.
//

         add       rpT1 = LpbPrcb, rpLpb         // -> PRCB
         dep.z     rRR = UREGION_INDEX, RR_INDEX, RR_INDEX_LEN
         ;;

         LDPTR     (rPrcb, rpT1)                 // get processor block address
         movl      rT2 = (START_PROCESS_RID << RR_RID)| RR_PS_VE
         ;;

//
// set RR[0], Region ID (RID) = 1, Page Size (PS) = 8K, VHPT enabled (VE) = 1
//

         mov       rr[rRR] = rT2                 // initialize rr[0]
         movl      rT1 = (START_SESSION_RID << RR_RID) | RR_PS_VE
         ;;

//
// set RR[1]
//
         movl      rRR = SADDRESS_BASE           // initialize
         ;;
         mov       rr[rRR] = rT1                 //   hydra region rr[1]
         ;;

//
// set RR[4], Region ID (RID) = 0, Page Size (PS) = 64K, VHPT enabled (VE) = 0
//

//
// set RR[2] to RR[7], RID = KSEG3_RID, Page Size = 8K, VHPT disabled 
//

         movl      rRR = 2 << RR_INDEX
         movl      rT2 = (KSEG3_RID << RR_RID) | (PAGE_SHIFT << RR_PS)
         ;;

         mov       rr[rRR] = rT2                 // initialize rr[2]
         movl      rRR = 3 << RR_INDEX
         ;;
         
         mov       rr[rRR] = rT2                 // initialize rr[3]
         movl      rRR = 4 << RR_INDEX
         ;;

         mov       rr[rRR] = rT2                 // initialize rr[4]
         movl      rRR = 5 << RR_INDEX
         ;;

         mov       rr[rRR] = rT2                 // initialize rr[5]
         movl      rRR = 6 << RR_INDEX
         ;;

         mov       rr[rRR] = rT2                 // initialize rr[6]

//
// Protection Key Registers
//

         mov       rPKR = zero                   // pkr index = 0
         mov       rT1 = PKR_VALID               // rr[0].v=1, pkr[0].key=0
         mov       rT2 = START_GLOBAL_RID
         ;;

         mov       pkr[rPKR] = rT1
         add       rPKR = 1, rPKR                // increment PKR number
         shl       rT2 = rT2, RR_RID
         ;;

         or        rT2 = rT1, rT2
         ;;
         mov       pkr[rPKR] = rT2               // pkr[1].v=1, pkr[1].key=START_GLOBAL_RID
         add       rPKR = 1, rPKR                // increment PKR number
         movl      rT2 = START_PROCESS_RID
         ;;

         shl       rT2 = rT2, RR_RID
         ;;
         or        rT2 = rT1, rT2
         ;;
         mov       pkr[rPKR] = rT2               // pkr[1].v=1, pkr[1].key=START_GLOBAL_RID

         add       rPKR = 1, rPKR                // increment PKR number
         mov       rT2 = zero
         ;;

Ksb_PKRLoop:

         mov       pkr[rPKR] = rT2               // set PKR invalid
         add       rPKR = 1, rPKR                // increment PKR number
         ;;

         cmp.gtu   pt0 = PKRNUM, rPKR            // at end?
(pt0)    br.cond.sptk.few.clr Ksb_PKRLoop
         ;;

//
// Initialize debug registers
//

         mov       rT1 = 0
         ;;

Ksb_DbrLoop:

         mov       ibr[rT1] = r0
         mov       dbr[rT1] = r0
         ;;

#ifndef  NO_12241
         srlz.d
#endif
         cmp.ne    pt0 = 7, rT1

         add       rT1 = 1, rT1
 (pt0)   br.cond.sptk.few Ksb_DbrLoop
         ;;

//
// Initialize control registers:
//       DCR
//       PSR pk, it, dt enabled
//

         ssm       (1 << PSR_DI) | (1 << PSR_PP) | (1 << PSR_IC) | (1 << PSR_DFH) | (1 << PSR_AC)
         ;;

         rsm       (1 << PSR_PK) | (1 << PSR_MFH) // must clear the mfh bit
         ;;

         srlz.i
         movl      rT1 = DCR_INITIAL
         ;;

         mov       cr.dcr = rT1

//
// Clear TC
//
// Set up ITR entry 2 with EPC page for system call
//

         movl      rT4 = KiNormalSystemCall
         ptc.e     zero
         add       rpT1 = LpbKernelVirtualBase, rpLpb
         add       rpT2 = LpbKernelPhysicalBase, rpLpb
         ;;

         LDPTR     (rT2, rpT1)                   // virtual load point
         LDPTR     (rT3, rpT2)                   // physical load point
         shr       rT4 = rT4, PAGE_SHIFT         // page number for syscall page
         ;;

         shr       rT2 = rT2, PAGE_SHIFT         // page number
         shr       rT3 = rT3, PAGE_SHIFT         // page number
         ;;

         sub       rT2 = rT4, rT2                // page offset
         movl      rVa = MM_EPC_VA
         ;;

         add       rT3 = rT3, rT2                // compute pfn of syscall page

         movl      rT2 = TR_VALUE(1,0,7,0,1,1,0,1)
         ;;
         shl       rT3 = rT3, PAGE_SHIFT         // set page number in TR
         ;;
         or        rT2 = rT2, rT3
         mov       rT3 = ITR_EPC_INDEX
         ;;

//
// Clear PSR.IC bit
//

         add       rpT1 = LpbPcrPage2, a0
         ;;
         ld8       rPcr2Pfn = [rpT1]             // set second PCR page
         mov       rT1 = PAGE_SHIFT << IDTR_PS

         rsm       1 << PSR_IC                   // PSR.ic = 0
         ;;
         srlz.d

         mov       cr.ifa = rVa                  // virtual address of epc page
         mov       cr.itir = rT1
         ;;
         itr.i     itr[rT3] = rT2

         movl      rVa = KiPcr2                  // set virtual address of PCR
         ;;

         mov       cr.ifa = rVa                  // setup IFA for insert
         movl      rPcrTr = KIPCR_TR_INITIAL     // PCR translation except for PPN

         mov       cr.itir = rT1                 // setup IDTR
         mov       rT2 = DTR_KIPCR2_INDEX
         shl       rPcr2Pfn = rPcr2Pfn, PAGE_SHIFT // shift to PPN field
         ;;

         or        rPcrTr = rPcr2Pfn, rPcrTr     // form full TR
         ;;
         itr.d     dtr[rT2] = rPcrTr             // insert PCR TR to DTR

         ssm       1 << PSR_IC                   // PSR.ic = 1
         ;;
         srlz.i                                  // I serialize

//
// Set the cache policy for cached memory.
// **** TBD ****

//
// Set the first level data and instruction cache fill size and size.
//
// **** TBD

//
// Set the second level data and instruction cache fill size and size.
//
// ***** TBD

//
// Set the data cache fill size and alignment values.
//
// **** TBD

//
// Set the instruction cache fill size and alignment values.
//
// **** TBD

//
// Sweep the data and instruction caches.
//
// **** TBD

//
// Initialize the fixed entries that map the PDR pages.
// Setup page directory, pte's for page dir
// **** TBD ****
//

//
// Initialize the Processor Control Registers (PCR).
//

//
// Initialize the minor and major version numbers.
//

         mov       rT1 = PCR_MINOR_VERSION       // set minor version number
         movl      rpPcr = KiPcr                 // get PCR address
         ;;

         add       rpT1 = PcMinorVersion, rpPcr
         add       rpT2 = PcMajorVersion, rpPcr
         mov       rT2 = PCR_MAJOR_VERSION       // set major version number
         ;;

         st2       [rpT1] = rT1                  // store minor
         st2       [rpT2] = rT2                  // store major
         add       rpT3 = PcPrcb, rpPcr          // -> PCR.Prcb
         ;;

//
// Set address of processor block.
//

         st8       [rpT3] = rPrcb                // store Prcb address

//
// Initialize the addresses of various data structures that are referenced
// from the exception and interrupt handling code.
//
// N.B. The panic stack is a separate stack that is used when the current
//      kernel stack overlfows.
//

         add       rpT1 = PcInitialStack,rpPcr   // -> initial kernel stack address in PCR
         add       rpT2 = LpbPanicStack, rpLpb   // -> lpb panic stack address

         add       rpT3 = PcPanicStack, rpPcr    // -> panic stack address in PCR
         ;;

         LDPTRINC  (rT2, rpT2, LpbThread-LpbPanicStack)   // panic stack address

         st8       [rpT1] = rKstack, PcKernelGP-PcInitialStack
         ;;

         LDPTR     (rThread, rpT2)               // -> current (idle) thread
         st8       [rpT3] = rT2, PcCurrentThread-PcPanicStack  // set PCR panic stack address
         ;;

         st8       [rpT3] = rThread              // set PCR current thread
         st8       [rpT1] = gp                   // save GP
         mov       rT1 = HIGH_LEVEL
         ;;

         SET_IRQL(rT1)                           // Set to highest IRQL

//
// Clear floating status and zero the count and compare registers.
//

         mov       ar.ccv = zero
         movl      rT1 = FPSR_FOR_KERNEL
         ;;

         mov       ar.fpsr = rT1
         mov       ar.ec = zero
         mov       ar.lc = zero

//
// Set system dispatch address limits used by get and set context.
// ***** TBD ******

//
// Set the default cache error routine address.
// ****** TBD *******

//
// Sweep the data and instruction caches.
// **** TBD *******

//
// Setup arguments and call kernel initialization routine.
//

         add       rpT1 = LpbProcess, rpLpb      // -> idle process address
         add       rpT2 = PbNumber, rPrcb
         mov       out3 = rPrcb                  // arg 4 is current PRCB
         ;;

         LDPTR     (out0, rpT1)                  // arg 1 is process
         mov       out1 = rThread                // arg 2 is thread
         mov       out2 = rKstack                // arg 3 is kernel stack

         ld1       out4 = [rpT2]                 // get processor number
         mov       out5 = rpLpb                  // arg 6 is pointer to LPB
         br.call.sptk.many.clr brp = KiInitializeKernel
         ;;                                                // (C code)

         alloc     t0 = ar.pfs,0,0,0,0
         mov       brp = zero     // setup a bogus brp to stop debugger
         br        KiIdleLoop     // branch to KIIdleLoop()
         ;;
//
// Never get to this point!
//
         NESTED_EXIT(KiSystemBegin)
//
//++
//
// VOID
// KiIdleLoop (
//    VOID
//    )
//
// Routine Description:
//
//    This is the idle loop for NT.  This code runs in a thread for
//    each processor in the system.  The idle thread runs at IRQL
//    DISPATCH_LEVEL and polls for work.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.  (This routine never returns).
//
//  When another thread is selected to run, SwapContext is called.
//  Normally, SwapContext saves and restores the non-volatile context.
//  The idle loop never returns so the preserved registers of the caller
//  do not need to be saved.
//  In other architectures, the idle loop pre-initializes the storage area
//  (switch frame) where SwapContext would normally save the preserved
//  registers with values that the idle loop needs
//  in those registers upon return from SwapContext and skips over the
//  register save on the way into SwapContext (alternate entry point
//  SwapFromIdle).
//  In this design the idle loop registers are preserved in
//  the register stack which is saved in the kernel backing store for the
//  idle thread. This allows us to skip the restore in SwapContext (not yet
//  implemented).
//
//  All callers to SwapContext pass the following arguments:
//
//  -- s0 = Prcb
//  -- s1 = current (previous) thread
//  -- s2 = new (next) thread
//
//  Idle also enters SwapContext at SwapFromIdle with sp pointing to the switch
//  frame for preserved state.
//
//  Since all registers used by the idle are saved in the register stack,
//  no registers need be recomputed on return from SwapContext.
//
//--


        NESTED_ENTRY(KiIdleLoop)
        NESTED_SETUP(0,6,2,0)

//
// allocate and build switch frame
//

        .fframe   SwitchFrameLength
        add       sp = -SwitchFrameLength, sp
        ;;
        add       t0 = ExFltS3+SwExFrame+STACK_SCRATCH_AREA, sp
        add       t1 = ExFltS2+SwExFrame+STACK_SCRATCH_AREA, sp
        ;;

        .save.f   0xC
        stf.spill [t0] = fs3, ExFltS1-ExFltS3         // save fs3
        stf.spill [t1] = fs2, ExFltS0-ExFltS2         // save fs2
        mov       t10 = bs4
        ;;

        .save.f   0x3
        stf.spill [t0] = fs1, ExIntS3-ExFltS1         // save fs1
        stf.spill [t1] = fs0, ExIntS2-ExFltS0         // save fs0
        mov       t11 = bs3
        ;;

        .save.g   0xC
        .mem.offset 0,0
        st8.spill [t0] = s3, ExIntS1-ExIntS3          // save s3
        .mem.offset 8,0
        st8.spill [t1] = s2, ExIntS0-ExIntS2          // save s2
        mov       t12 = bs2
        ;;

        .save.g   0x3
        .mem.offset 0,0
        st8.spill [t0] = s1, ExBrS4-ExIntS1           // save s1
        .mem.offset 8,0
        st8.spill [t1] = s0, ExBrS3-ExIntS0           // save s0
        mov       t13 = bs1
        ;;

        .save.b   0x18
        st8       [t0] = t10, ExBrS2-ExBrS4           // save bs4
        st8       [t1] = t11, ExBrS1-ExBrS3           // save bs3
        mov       t4 = ar.unat                        // captured Nats of s0-s3
        ;;

        .save.b   0x6
        st8       [t0] = t12, ExBrS0-ExBrS2           // save bs2
        st8       [t1] = t13, ExApEC-ExBrS1           // save bs1
        mov       t14 = bs0
        ;;

        .save.b   0x1
        st8       [t0] = t14, ExApLC-ExBrS0           // save bs0
        .savepsp  ar.pfs, ExceptionFrameLength-ExApEC-STACK_SCRATCH_AREA
        st8       [t1] = t16, ExIntNats-ExApEC
        mov       t15 = ar.lc
        ;;

        .savepsp  ar.lc, ExceptionFrameLength-ExApLC-STACK_SCRATCH_AREA
        st8       [t0] = t15
        .savepsp  @priunat, ExceptionFrameLength-ExIntNats-STACK_SCRATCH_AREA
        st8       [t1] = t4                           // save Nats of s0-s3
        nop.i     0
        ;;

        PROLOGUE_END

//
// Register aliases
//

        rpT1      = t0
        rpT2      = t1
        rpT3      = t2
        rT1       = t3
        rT2       = t4
        rT3       = t5

#if !defined(NT_UP)
        rpNumProc = t7
        rpBWait   = t8
        rpDispLock = t9
#endif // !defined(NT_UP)

        rpNextTh  = t10

#if DBG
        rDbgCount = t11
        rKdEnable = t12
#endif //DBG

        pEmty     = pt1
        pIdle     = pt2

#if !defined(NT_UP)
        pLoop     = pt6
#endif // !defined(NT_UP)

#if DBG
        pBrk      = ps2
        pNotZero  = ps3
#endif // DBG


        rpHPI     = loc2
        rHalGP    = loc3
        rKerGP    = loc4

#if !defined(NT_UP)
        rProcNum  = loc5
#endif // !defined(NT_UP)

        //
        // Initialize SwitchFPSR, SwitchPFS, SwitchRp in the switch frame
        //

        mov       rT3 = ar.bsp
        movl      rT2 = KiIdleReturn

        add       rpT1 = SwPFS+STACK_SCRATCH_AREA, sp
        mov       rKerGP = gp                // save the kernel's gp
        mov       rT1 = 0x308                // must match the values specified
                                             // by the alloc instruction at
                                             // the entry of the KiIdleLoop
        ;;

        st8.nta   [rpT1] = rT1, SwRp-SwPFS   // set pfs in the switch frame
        add       rT3 = 0x30, rT3            // 6 local registers
        ;;

        st8.nta   [rpT1] = rT2, SwFPSR-SwRp  // set brp in the switch frame
        movl      rT1 = FPSR_FOR_KERNEL
        ;;
        extr.u    rpT3 = rT3, 0, 9
        st8.nta   [rpT1] = rT1, SwRnat-SwFPSR
        ;;
        cmp.gtu   pt1 = 0x30, rpT3           // Is there a slot for NAT bits?
        st8.nta   [rpT1] = zero, SwBsp-SwRnat
        ;;
(pt1)   add       rT3 = 8, rT3               // Adjust for NAT bits.        
        ;;
        st8.nta   [rpT1] = rT3
        movl      rpT1 = KiPcr + PcPrcb
        ;;

//
// In a multiprocessor system the boot processor proceeds directly into
// the idle loop. As other processors start executing, however, they do
// not directly enter the idle loop and spin until all processors have
// been started and the boot master allows them to proceed.
//

//
//  Setup initial idle loop register values
//

        LDPTRINC  (s0, rpT1, PcCurrentThread-PcPrcb)     // address of PRCB
        add       rpT2 = @gprel(__imp_HalProcessorIdle), gp
        ;;

        LDPTR     (s2, rpT1)                             // idle thread
        LDPTR     (rpT2, rpT2)                           // -> function pointer
        add       rpT3 = PbNumber, s0
        ;;

        ld1       rProcNum = [rpT3]
        ld8       rpHPI = [rpT2], PlGlobalPointer-PlEntryPoint  // entry point
        ;;

//
//  Control reaches here with IRQL at HIGH_LEVEL.  Lower IRQL to
//  DISPATCH_LEVEL and set wait IRQL of idle thread.
//

        ld8       rHalGP = [rpT2]                        // Hal GP
        add       rpT1 = ThWaitIrql, s2         // -> thread WaitIrql
        mov       out0 = DISPATCH_LEVEL         // get dispatch level IRQL
        ;;

        st1       [rpT1] = out0                 // set wait IRQL of idle thread
        br.call.sptk.few.clr brp = KeLowerIrql  // call KeLowerIrql(IRQL)
        ;;

        FAST_ENABLE_INTERRUPTS
        mov       gp = rKerGP
        ;;

//
//  In a multiprocessor system the boot processor proceeds directly into
//  the idle loop. As other processors start executing, however, they do
//  not directly enter the idle loop and spin until all processors have
//  been started and the boot master allows them to proceed.
//

#if !defined(NT_UP)

        add       rpBWait = @gprel(KiBarrierWait), gp
        ;;

Kil_WaitLoop:
        ld4       rT1 = [rpBWait]               // get barrier wait value
        ;;
        cmp.ne    pLoop = zero, rT1             // loop if not zero
(pLoop) br.dpnt.few.clr Kil_WaitLoop            // spin until allowed to proceed

#endif // !defined(NT_UP)


KiIdleReturn:

        mov       s1 = s2                       // s1 <- IdleThread

#if DBG

        mov       rDbgCount = 20 * 1000         // set breakin loop counter

#endif // DBG

        ;;

KiIdleSwitchBlocked:
        mov       rT1 = DISPATCH_LEVEL
        ;;
        SET_IRQL(rT1)

//
//  The following loop is executed for the life of the system.
//

Kil_TopOfIdleLoop::

        mov       gp = rKerGP                             // restore gp

//
// If processor 0, check for debugger breakin, otherwise just check for
// DPCs again.
//

#if DBG

#if !defined(NT_UP)

        cmp4.ne   pNotZero = zero, rProcNum     // pNotZero = not processor zero
(pNotZero) br.cond.dptk.few.clr Kil_CheckDpcList // br if not processor zero

#endif // !defined(NT_UP)

//
// Check if the debugger is enabled,  and whether it is time to poll
// for a debugger breakin.  (This check is only performed on cpu 0).
//

        sub       rDbgCount = rDbgCount,zero,1  // decrement poll counter
        ;;
        add       rKdEnable = @gprel(KdDebuggerEnabled), gp
        cmp.eq    pBrk = rDbgCount, zero        // zero yet?
        ;;

(pBrk)  ld1       rKdEnable = [rKdEnable]       // check if debugger enabled
(pBrk)  mov       rDbgCount = 20 * 1000         // set breakin loop counter
        ;;
(pBrk)  cmp.ne    pBrk = rKdEnable, zero        // pBrk = 1 if Kd enabled
(pBrk)  br.call.dpnt.few.clr brp=KdPollBreakIn  // check if breakin requested
        ;;
        mov       gp = rKerGP                             // restore gp
(pBrk)  cmp.ne    pBrk = v0, zero               // ne => break in requested
        mov       out0 = DBG_STATUS_CONTROL_C
(pBrk)  br.call.sptk brp = DbgBreakPointWithStatus
        ;;
        mov       gp = rKerGP                             // restore gp
#endif // DBG

//
// Disable interrupts and check if there is any work in the DPC list.
//

Kil_CheckDpcList:

//
// Process the deferred procedure call list for the current processor.
//

        FAST_ENABLE_INTERRUPTS                  // give interrupts a chance
        ;;
        srlz.d
        add       rpT1 = PbDpcQueueDepth, s0
        add       rpNextTh = PbNextThread, s0   // -> next thread
        ;;

        FAST_DISABLE_INTERRUPTS                 // disable interrupts
        ;;
        ld4.nta   rT1 = [rpT1]
        mov       out0 = s0                     // PRCB
        ;;

        cmp4.eq   pt0, pt1 = rT1, zero          // if eq, queue empty
        movl      rpT1 = KiPcr+PcDispatchInterrupt
        ;;

 (pt1)  st1       [rpT1] = zero                 // clear dispatch interrupt req
 (pt0)  br.cond.dpnt Kil_CheckNextThread
 (pt1)  br.call.sptk.few.clr brp = KiRetireDpcList
        ;;

        add       rpNextTh = PbNextThread, s0   // -> next thread
        mov       gp = rKerGP                   // restore gp
#if DBG
        mov       rDbgCount = 20 * 1000         // set breakin loop counter
#endif // DBG
        ;;

//
//  Check if a thread has been selected to run on this processor
//

Kil_CheckNextThread:

        ld8       s2 = [rpNextTh]               // next thread
        mov       rT1 = SYNCH_LEVEL
        ;;

        cmp.eq    pIdle = s2, zero              // if no thread to run
(pIdle) br.dpnt.few.clr Kil_Idle                // br to Idle

//
// A thread has been selected for execution on this processor. Acquire
// the context swap lock, get the thread address again (it may have
// changed), clear the address of the next thread in the processor block,
// and call swap context to start execution of the selected thread.
//

        SET_IRQL(rT1)

        FAST_ENABLE_INTERRUPTS

#if !defined(NT_UP)

        add       out0 = PbLockQueue + (LockQueueContextSwapLock * 2 * 8), s0
        add       s2 = PbNextThread, s0       // -> next thread
        br.call.sptk brp = KeAcquireQueuedSpinLockAtDpcLevel
        ;;

//
// Reread the next thread because it may be changed in a MP system.
//
// The selected thread may be blocked from switching at this time
// if it is being scheduled on this processor because it is being
// removed from another processor.   The switch is blocked until
// the thread is completely removed from the other processor.  In
// this case, drop the context swap lock and continue execution as
// if resuming from a context switch.  (The release below returns
// to KiIdleSwitchBlocked above).
//

        ld8       s2 = [s2]                   // reread next thread
        movl      rpT2 = KiIdleSwitchBlocked
        ;;

        add       rpT1 = ThIdleSwapBlock, s2  // &NewThread->IdleSwapBlock
        mov       brp = rpT2
        cmp.eq    pt0 = s2, s1                // check for swap idle to idle
        ;;

        ld1       rT1 = [rpT1], ThState-ThIdleSwapBlock
        add       out0 = PbLockQueue + (LockQueueContextSwapLock * 2 * 8), s0
(pt0)   br.dpnt.few.clr Kil_Idle2Idle         // rare case, idle to idle
        ;;

        cmp.ne    pIdle = rT1, zero
        add       rpT2 = PbCurrentThread, s0  // -> address of current thread
(pIdle) br.call.spnt bt0 = KeReleaseQueuedSpinLockFromDpcLevel
        ;;

#else

        add       rpT2 = PbCurrentThread, s0  // -> address of current thread
        add       rpT1 = ThState, s2
        ;;

#endif // !defined(NT_UP)

                                              // set new thread as current
        st8       [rpT2] = s2, PbNextThread-PbCurrentThread
        mov       rT1 = Running
        ;;

        st1       [rpT1] = rT1                // set new thread state to running
        st8.rel   [rpT2] = zero               // clear address of next thread

//
// Swap context to new thread
// (returns to KiIdleReturn above).
//

        br.call.sptk.few.clr brp = SwapFromIdle
        ;;

//
// There are no entries in the DPC list and a thread has not been selected
// for execution on this processor. Call the HAL so power managment can be
// performed.
//
// N.B. The HAL is called with interrupts disabled. The HAL will return
//      with interrupts enabled.
//

Kil_Idle:
        mov       bt0 = rpHPI
        movl      rT1 = Kil_TopOfIdleLoop
        ;;

        mov       gp = rHalGP                   // set Hal GP
        mov       brp = rT1
        br.call.dpnt.few.clr   bt1 = bt0        // call HalProcessorIdle
        ;;                                      // does not return here.


//
// In the event that a thread was scheduled to run on this processor
// but before the idle loop picked it up, it was made inelligible for
// this processor and there is no other thread to run, the idle thread
// will have been selected as the NextThread for this processor and
// this processor will have been marked idle in KiIdleSummary.
//
// It is then possible for another thread to be selected for this processor
// between the time the idle loop picks up the NextThread field and clears
// it.
//
// To avoid this rare case, if the switch is from the idle thread to the
// idle thread, we need to drop the context swap lock, acquire the 
// dispatcher lock and if the next thread field is still the idle thread,
// clear it and continue to idle.   If it is no longer the idle thread,
// switch to that thread.
//

Kil_Idle2Idle:
        add       s2 = PbNextThread, s0       // get &Prcb->NextThread
        br.call.sptk brp = KeReleaseQueuedSpinLockFromDpcLevel
        ;;

        add       out0 = PbLockQueue + (LockQueueDispatcherLock * 2 * 8), s0
        br.call.sptk brp = KeAcquireQueuedSpinLockAtDpcLevel
        ;;

        add       out0 = PbLockQueue + (LockQueueDispatcherLock * 2 * 8), s0
        ld8       rT1 = [s2]                 // get Prcb->NextThread
        ;;

        cmp.eq    pt0 = rT1, s2              // check if still Idle Thread
        ;;

(pt0)   st8       [s2] = zero                // clear Prcb->NextThread
        br.call.sptk brp = KeReleaseQueuedSpinLockFromDpcLevel
        ;;

        br          KiIdleSwitchBlocked      // loop.

        NESTED_EXIT(KiIdleLoop)

#if !defined(NT_UP)

//++
// Routine:
//
//      VOID
//      KiOSRendezvous (
//           )
//
// Routine Description:
//
//      OS rendezvous entry point called from SAL for MP boot.
//      Establish kernel mapping and rfi to KiInitializeSystem with
//      translation turned on.
//
// Arguments:
//
// Return Value:
//
//       None.
//
//--

        .global MmSystemParentTablePage
        .global MiNtoskrnlPhysicalBase
        .global MiNtoskrnlVirtualBase
        .global MiNtoskrnlPageShift

        LEAF_ENTRY(KiOSRendezvous)

        mov         t5 = ip                     // get the physical addr for KiOSRendezvous

        mov         psr.l = zero                // initialize psr.l
        movl        t0 = KSEG0_BASE
        ;;

        mov         ar.rsc = zero               // invalidate register stack
        mov         t1 = (START_GLOBAL_RID << RR_RID) | (PAGE_SHIFT << RR_PS) | (1 << RR_VE)
        ;;

//
// Initialize Region Register for kernel
//

        loadrs
        mov         rr[t0] = t1

//
// Setup translation for kernel/hal binary.
//
        movl    t0 = KSEG0_BASE;
        ;;
        movl    t2 = MiNtoskrnlPhysicalBase
        movl    t4 = MiNtoskrnlPageShift
        movl    t0 = MiNtoskrnlVirtualBase
        movl    t3 = KiOSRendezvous
        ;;

        sub     t6 = t2, t3
        sub     t7 = t4, t3
        sub     t0 = t0, t3
        ;;
        add     t6 = t5, t6     // get a physical addr for MiNtoskrnlPhysicalBase
        add     t7 = t5, t7     // get a physical addr for MiNtoskrnlPageShift
        add     t0 = t5, t0     // get a physical addr for MiNtoskrnlVirtualBase
        ;;
        ld8     t6 = [t6]
        ld4     t7 = [t7]
        ld8     t0 = [t0]
        movl    t8 = VALID_KERNEL_EXECUTE_PTE
        ;;
        mov     cr.ifa = t0
        or      t2 = t6, t8
        shl     t1 = t7, PS_SHIFT
        ;;
        mov     cr.itir = t1
        mov     t3 = DTR_KERNEL_INDEX
        ;;

        itr.d   dtr[t3] = t2
        ;;
        itr.i   itr[t3] = t2


//
// Setup VHPT
//

        movl        t0 = KiIA64PtaContents
        movl        t3 = KiOSRendezvous
        ;;
        sub         t6 = t0, t3
        ;;
        add         t6 = t5, t6
        ;;
        ld8         t6 = [t6]
        ;;
        mov         cr.pta = t6

//
// Turn on address translation
//
        movl        t1 = (1 << PSR_BN) | (1 << PSR_IT) | (1 << PSR_DA) | (1 << PSR_RT) | (1 << PSR_DT) | (1 << PSR_IC)
        ;;

        mov         cr.ipsr = t1

//
// Branch to KiInitializeSystem
//
//      Need to do a "rfi" in order set "it" bits in the PSR.
//      This is the only way to set them.
//
        movl        t0 = KiOSRendezvousStub
        ;;
        mov         cr.iip = t0
        ;;
        rfi
        ;;

        .global     KeLoaderBlock

KiOSRendezvousStub:

        alloc       t0 = 0,0,1,0
        movl        gp = _gp
        mov         t9 = PAGE_SHIFT << PS_SHIFT
        movl        t8 = KADDRESS_BASE
        ;;

//
// Set up the VHPT table
//

        thash       t8 = t8
        add         t7 = @gprel(MmSystemParentTablePage), gp
        ;;

        ld8         t7 = [t7]
        rsm         1 << PSR_IC                   // PSR.ic = 0
        ;;
        srlz.d

        thash       t8 = t8
        movl        t6 = PDR_TR_INITIAL
        ;;
//
// Install DTR for the kernel parent page table
//

        thash       t8 = t8
        mov         t10 = DTR_KTBASE_INDEX
        shl         t7 = t7, PAGE_SHIFT
        ;;

        mov         cr.ifa = t8
        or          t7 = t7, t6
        mov         cr.itir = t9
        ;;

        itr.d       dtr[t10] = t7

        ssm         1 << PSR_IC                  // PSR.ic = 1
        ;;
        srlz.i                                   // I serialize
        add         out0 = @gprel(KeLoaderBlock), gp
        ;;
        ld8         out0 = [out0]               // dereference pointer
        movl        t0 = KiInitializeSystem
        ;;

        mov         bt0 = t0
        br.call.sptk brp = bt0                  // branch to entry point

        LEAF_EXIT(KiOSRendezvous)

#endif // !defined(NT_UP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\timindex.s ===
//      TITLE("Compute Timer Table Index")
//++
//
// Module Name:
//
//    timindex.s
//
// Abstract:
//
//    This module implements the code necessary to compute the timer table
//    index for a timer.
//
// Author:
//
//    David N. Cutler (davec) 17-May-1993
//    Joe Notarangelo 20-Jul-1993  (Alpha AXP version)
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksia64.h"

        SBTTL("Compute Timer Table Index")
//++
//
// ULONG
// KiComputeTimerTableIndex (
//    IN LARGE_INTEGER Interval,
//    IN LARGE_INTEGER CurrentTime,
//    IN PKTIMER Timer
//    )
//
// Routine Description:
//
//    This function computes the timer table index for the specified timer
//    object and stores the due time in the timer object.
//
//    N.B. The interval parameter is guaranteed to be negative since it is
//         expressed as relative time.
//
//    The formula for due time calculation is:
//
//    Due Time = Current Time - Interval
//
//    The formula for the index calculation is:
//
//    Index = (Due Time / Maximum Time) & (Table Size - 1)
//
//    The index division is performed using reciprocal multiplication.
//
// Arguments:
//
//    Interval (a0) - Supplies the relative time at which the timer is
//        to expire.
//
//    CurrentTime (a1) - Supplies the current interrupt time.
//
//    Timer (a2) - Supplies a pointer to a dispatch object of type timer.
//
// Return Value:
//
//    The time table index is returned as the function value and the due
//    time is stored in the timer object.
//
//--

        .global  KiTimeIncrementReciprocal
        .global  KiTimeIncrementShiftCount

        LEAF_ENTRY(KiComputeTimerTableIndex)

        add      t2 = @gprel(KiTimeIncrementReciprocal), gp
        add      t3 = @gprel(KiTimeIncrementShiftCount), gp
        sub      t4 = a1, a0
        ;;

//
// Capture global values for magic divide, the reciprocal multiply value
// and the shift count.
//

        ld8.nta  t2 = [t2]
        ld1.nta  t3 = [t3] 
        add      t0 = TiDueTime, a2
        ;;

//
// Compute the due time and store in the timer object.
//

        setf.sig ft1 = t2
        setf.sig ft0 = t4
        ;;

//
// Do the reciprocal multiply and capture the upper 64 bits of the
// 128 bit product with xma.h instruction.
//

        st8      [t0] = t4
        xma.hu   ft2 = ft0, ft1, f0
        ;;

        getf.sig v0 = ft2
        movl     t4 = TIMER_TABLE_SIZE - 1
        ;;

//
// Right shift the result by the specified shift count and mask off extra
// bits.
//

        shr      v0 = v0, t3
        ;;
        and      v0 = v0, t4
 
        LEAF_RETURN

        LEAF_EXIT(KiComputeTimerTableIndex)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\pae\makefile.inc ===
#
#  Currently the MP and UP files are the same.
#
!INCLUDE ..\up\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\thredini.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    thredini.c

Abstract:

    This module implements the machine dependent functions to set the initial
    context and data alignment handling mode for a process or thread object.

Author:

    David N. Cutler (davec) 1-Apr-1990

Environment:

    Kernel mode only.

Revision History:

    3-19-96        Bernard Lint (blint)          Conversion to IA64 (from PPC and MIPS versions)

--*/

#include "ki.h"

VOID
KeContextToKframesSpecial (
    IN PKTHREAD Thread,
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextFrame,
    IN ULONG ContextFlags
    );

//
// The following assert macros are used to check that an input object is
// really the proper type.
//

#define ASSERT_PROCESS(E) {                    \
    ASSERT((E)->Header.Type == ProcessObject); \
}

#define ASSERT_THREAD(E) {                    \
    ASSERT((E)->Header.Type == ThreadObject); \
}



VOID
KiInitializeContextThread (
    IN PKTHREAD Thread,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PCONTEXT ContextRecord OPTIONAL
    )

/*++

Routine Description:

    This function initializes the machine dependent context of a thread object.

    Actually, what it does is to lay out the stack for the thread so that
    it contains a stack frame that will be picked up by SwapContext and
    returned thru, resulting in a transfer of control to KiThreadStartup.
    In otherwords, we lay out a stack with a stack frame that looks as if
    SwapContext had been called just before the first instruction in
    KiThreadStartup.

    N.B. This function does not check the accessibility of the context record.
         It is assumed the the caller of this routine is either prepared to
         handle access violations or has probed and copied the context record
         as appropriate.

    N.B. Arguments to the new thread are passed in the Swap Frame preserved registers
         s0 - s3 which are restored by Swap Context when thread execution begins.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

        N.B. This is the routine entry point, not a function pointer (plabel pointer).

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

        N.B. This is the routine function pointer (plabel pointer).

    StartContext - Supplies an optional pointer to an arbitrary data structure
        which will be passed to the StartRoutine as a parameter. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    ContextRecord - Supplies an optional pointer a context frame which contains
        the initial user mode state of the thread. This parameter is specified
        if the thread is a user thread and will execute in user mode. If this
        parameter is not specified, then the Teb parameter is ignored.

Return Value:

    None.

--*/

{

    PKSWITCH_FRAME SwFrame;
    PKEXCEPTION_FRAME ExFrame;
    ULONG_PTR InitialStack;
    PKTRAP_FRAME TrFrame;

    //
    // Set up the thread backing store pointers from the initial stack pointers.
    //

    InitialStack = (ULONG_PTR)Thread->InitialStack;
    Thread->InitialBStore = (PVOID)InitialStack;
    Thread->BStoreLimit = (PVOID)(InitialStack + KERNEL_BSTORE_SIZE);

    //
    // If a context frame is specified, then initialize a trap frame and
    // and an exception frame with the specified user mode context. Also
    // allocate the switch frame.
    //

    if (ARGUMENT_PRESENT(ContextRecord)) {

        TrFrame = (PKTRAP_FRAME)((InitialStack) 
                      - KTHREAD_STATE_SAVEAREA_LENGTH
                      - KTRAP_FRAME_LENGTH);

        ExFrame = (PKEXCEPTION_FRAME)(((ULONG_PTR)TrFrame + 
                      STACK_SCRATCH_AREA - 
                      sizeof(KEXCEPTION_FRAME)) & ~((ULONG_PTR)15));

        SwFrame = (PKSWITCH_FRAME)(((ULONG_PTR)ExFrame -
                      sizeof(KSWITCH_FRAME)) & ~((ULONG_PTR)15));

        KeContextToKframesSpecial(Thread, TrFrame, ExFrame,
                           ContextRecord,
                           ContextRecord->ContextFlags | CONTEXT_CONTROL);

        //
        // Set the saved previous processor mode in the trap frame and the
        // previous processor mode in the thread object to user mode.
        //

        TrFrame->PreviousMode = UserMode;
        Thread->PreviousMode = UserMode;

        //
        // Initialize the FPSR for user mode
        //

        TrFrame->StFPSR = USER_FPSR_INITIAL;

        //
        // Initialize the user TEB pointer in the trap frame
        //

        TrFrame->IntTeb = (ULONGLONG)Thread->Teb;

    } else {

        SwFrame = (PKSWITCH_FRAME)((InitialStack) - sizeof(KSWITCH_FRAME));

        //
        // Set the previous mode in thread object to kernel.
        //

        Thread->PreviousMode = KernelMode;
    }

    //
    // Initialize context switch frame and set thread start up parameters.
    // The Swap return pointer and SystemRoutine are entry points, not function pointers.
    //

    RtlZeroMemory((PVOID)SwFrame, sizeof(KSWITCH_FRAME));   // init all to 0

    SwFrame->SwitchRp = ((PPLABEL_DESCRIPTOR)KiThreadStartup)->EntryPoint;
    SwFrame->SwitchExceptionFrame.IntS0 = (ULONGLONG)ContextRecord;
    SwFrame->SwitchExceptionFrame.IntS1 = (ULONGLONG)StartContext;
    SwFrame->SwitchExceptionFrame.IntS2 = (ULONGLONG)StartRoutine;
    SwFrame->SwitchExceptionFrame.IntS3 = 
        ((PPLABEL_DESCRIPTOR)SystemRoutine)->EntryPoint;
    SwFrame->SwitchFPSR = FPSR_FOR_KERNEL;
    SwFrame->SwitchBsp = (ULONGLONG)Thread->InitialBStore;

    Thread->KernelBStore = Thread->InitialBStore;
    Thread->KernelStack = (PVOID)((ULONG_PTR)SwFrame-STACK_SCRATCH_AREA);

    if (Thread->Teb) {
        PKAPPLICATION_REGISTERS AppRegs;

        AppRegs = GET_APPLICATION_REGISTER_SAVEAREA(Thread->StackBase);

        AppRegs->Ar21 = 0; // ContextRecord->StFCR;

        //
        // Ar24 is EFlags. Need to set up a value that is good for iVE
        // Based on i386 eflags SANITIZE_FLAGS
        // This is simplier, though since never running i386 in kernel
        // mode
        AppRegs->Ar24 = EFLAGS_INTERRUPT_MASK | (((ULONG) ContextRecord->Eflag) &  EFLAGS_USER_SANITIZE);

        AppRegs->Ar25 = USER_CODE_DESCRIPTOR;
        AppRegs->Ar26 = USER_DATA_DESCRIPTOR;
        AppRegs->Ar27 = (((ULONGLONG) CR4_VME | CR4_FXSR | CR4_XMMEXCPT) << 32)
                      | (CR0_PE | CFLG_II);
        AppRegs->Ar28 = SANITIZE_AR28_FSR (ContextRecord->StFSR, UserMode);
        AppRegs->Ar29 = SANITIZE_AR29_FIR (ContextRecord->StFIR, UserMode);
        AppRegs->Ar30 = SANITIZE_AR30_FDR (ContextRecord->StFDR, UserMode);
        
    }

    return;
}

BOOLEAN
KeSetAutoAlignmentProcess (
    IN PRKPROCESS Process,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function sets the data alignment handling mode for the specified
    process and returns the previous data alignment handling mode.

Arguments:

    Process  - Supplies a pointer to a dispatcher object of type process.

    Enable - Supplies a boolean value that determines the handling of data
        alignment exceptions for the process. A value of TRUE causes all
        data alignment exceptions to be automatically handled by the kernel.
        A value of FALSE causes all data alignment exceptions to be actually
        raised as exceptions.

Return Value:

    A value of TRUE is returned if data alignment exceptions were
    previously automatically handled by the kernel. Otherwise, a value
    of FALSE is returned.

--*/

{

    KIRQL OldIrql;
    BOOLEAN Previous;

    ASSERT_PROCESS(Process);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the previous data alignment handling mode and set the
    // specified data alignment mode.
    //

    Previous = Process->AutoAlignment;
    Process->AutoAlignment = Enable;

    //
    // Unlock dispatcher database, lower IRQL to its previous value, and
    // return the previous data alignment mode.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Previous;
}

BOOLEAN
KeSetAutoAlignmentThread (
    IN PKTHREAD Thread,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function sets the data alignment handling mode for the specified
    thread and returns the previous data alignment handling mode.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Enable - Supplies a boolean value that determines the handling of data
        alignment exceptions for the thread. A value of TRUE causes all
        data alignment exceptions to be automatically handled by the kernel.
        A value of FALSE causes all data alignment exceptions to be actually
        raised as exceptions.

Return Value:

    A value of TRUE is returned if data alignment exceptions were
    previously automatically handled by the kernel. Otherwise, a value
    of FALSE is returned.

--*/

{

    KIRQL OldIrql;
    BOOLEAN Previous;

    ASSERT_THREAD(Thread);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the previous data alignment handling mode and set the
    // specified data alignment mode.
    //

    Previous = Thread->AutoAlignment;
    Thread->AutoAlignment = Enable;

    //
    // Unlock dispatcher database, lower IRQL to its previous value, and
    // return the previous data alignment mode.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Previous;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\paemp\makefile.inc ===
#
#  Currently the MP and UP files are the same.
#
!INCLUDE ..\up\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\zeropag.s ===
#include "ksia64.h"

        LEAF_ENTRY(KiZeroPage)

        .prologue
        .save       ar.lc, t22
        mov         t22 = ar.lc
        mov         ar.lc = (PAGE_SIZE >> 6) - 1
        add         t1 = 16, a0
        ;;

        PROLOGUE_END

Mizp10:
        stf.spill.nta [a0] = f0, 32
        stf.spill.nta [t1] = f0, 32
        ;;
        stf.spill.nta [a0] = f0, 32
        stf.spill.nta [t1] = f0, 32
        br.cloop.dptk.few Mizp10
        ;;

        nop.m       0
        mov         ar.lc = t22
        br.ret.sptk brp
        ;;

        LEAF_EXIT(KiZeroPage)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\trapc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    trapc.c

Abstract:

    This module implements the specific exception handlers for EM
    exceptions. Called by the KiGenericExceptionHandler.

Author:

    Bernard Lint 4-Apr-96

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#include "ps.h"
#include <inbv.h>

extern BOOLEAN PsWatchEnabled;
extern VOID ExpInterlockedPopEntrySListResume();


BOOLEAN
KiMemoryFault (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function processes memory faults.

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

    TRUE on success, FALSE on failure.

--*/

{
    PEXCEPTION_RECORD ExceptionRecord;
    BOOLEAN StoreInstruction;
    PVOID VirtualAddress;
    NTSTATUS Status;

    VirtualAddress = (PVOID)TrapFrame->StIFA;

    if (TrapFrame->StISR & (1i64 << ISR_X))  {

#if _MERCED_A0_
        if ((TrapFrame->StIPSR & (1i64 << PSR_IS)) == 0) {
            VirtualAddress = (PVOID)TrapFrame->StIIP;
        }
#endif
        //
        // Indicate execution fault.
        //

        StoreInstruction = 2;
    }
    else if (TrapFrame->StISR & (1i64 << ISR_W)) {

        //
        // Indicate store.
        //

        StoreInstruction = 1;
    } else {

        //
        // Indicate read.
        //

        StoreInstruction = 0;
    }


    if (((ULONG_PTR)VirtualAddress < MM_MAX_WOW64_ADDRESS) &&
        (PsGetCurrentProcess()->Wow64Process != NULL)) {

        Status = MmX86Fault(StoreInstruction, VirtualAddress,
                           (KPROCESSOR_MODE)TrapFrame->PreviousMode, TrapFrame);

    } else {

        Status = MmAccessFault(StoreInstruction, VirtualAddress,
                           (KPROCESSOR_MODE)TrapFrame->PreviousMode, TrapFrame);
    }

    //
    // Check if working set watch is enabled.
    //

    if (NT_SUCCESS(Status)) {

        if (PsWatchEnabled) {
            PsWatchWorkingSet(Status,
                              (PVOID)TrapFrame->StIIP,
                              (PVOID)VirtualAddress);
        }

        //
        // Check if debugger has any breakpoints that should be inserted
        //

        KdSetOwedBreakpoints();

        return FALSE;

    }

    if (KeInvalidAccessAllowed(TrapFrame)) {

        TrapFrame->StIIP = ((PPLABEL_DESCRIPTOR)ExpInterlockedPopEntrySListResume)->EntryPoint;

        return FALSE;

    }

    if (TrapFrame->StISR & (1i64 << ISR_SP)) {

        //
        // Set IPSR.ed bit if it was a fault on a speculative load.
        //

        TrapFrame->StIPSR |= (1i64 << PSR_ED);

        return FALSE;

    }

    //
    // Failure returned from MmAccessFault.
    // Initialize Exception record.
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;
    ExceptionRecord->ExceptionCode = Status;
    ExceptionRecord->ExceptionAddress =
        (PVOID)RtlIa64InsertIPSlotNumber(TrapFrame->StIIP,
                   ((TrapFrame->StISR & ISR_EI_MASK) >> ISR_EI));

    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->NumberParameters = 5;
    if (StoreInstruction == 2) {
        PSR Psr;
        Psr.ull = TrapFrame->StIPSR;

        //
        // instruction access fault
        //
        ExceptionRecord->ExceptionInformation[0] = TrapFrame->StIIPA;

    } else {
        //
        // data access fault
        //
        ExceptionRecord->ExceptionInformation[0] = (ULONG_PTR)StoreInstruction;
    }
    ExceptionRecord->ExceptionInformation[1] = (ULONG_PTR)VirtualAddress;
    ExceptionRecord->ExceptionInformation[2] = (ULONG_PTR)Status;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;

    //
    // Status = STATUS_IN_PAGE_ERROR | 0x10000000
    //      is a special status that indicates a page fault at Irql > APC
    //
    // The following statuses can be forwarded:
    //      STATUS_ACCESS_VIOLATION
    //      STATUS_GUARD_PAGE_VIOLATION
    //      STATUS_STACK_OVERFLOW
    //
    // All other status will be set to:
    //      STATUS_IN_PAGE_ERROR
    //

    switch (Status) {

    case STATUS_ACCESS_VIOLATION:
    case STATUS_GUARD_PAGE_VIOLATION:
    case STATUS_STACK_OVERFLOW:
    case STATUS_IN_PAGE_ERROR:

        break;

    default:

        ExceptionRecord->ExceptionCode = STATUS_IN_PAGE_ERROR;
        break;

    case STATUS_IN_PAGE_ERROR | 0x10000000:

        //
        // Handle the special case status returned from MmAccessFault,
        // we have taken a page fault at Irql > APC_LEVEL.
        //

        KeBugCheckEx(IRQL_NOT_LESS_OR_EQUAL,
                     (ULONG_PTR)VirtualAddress,
                     (ULONG_PTR)KeGetCurrentIrql(),
                     (ULONG_PTR)StoreInstruction,
                     (ULONG_PTR)TrapFrame->StIIP);
        //
        // should not get here
        //

        break;
    }

    return TRUE;
}

typedef struct _BREAK_INST {
    union {
        struct {
            ULONGLONG qp:    6;
            ULONGLONG imm20: 20;
            ULONGLONG x:     1;
            ULONGLONG x6:    6;
            ULONGLONG x3:    3;
            ULONGLONG i:     1;
            ULONGLONG Op:    4;
            ULONGLONG Rsv:   23;
        } i_field;
        ULONGLONG Ulong64;
    } u;
} BREAK_INST;


ULONG
KiExtractImmediate (
    IN ULONGLONG Iip,
    IN ULONG SlotNumber
    )

/*++

Routine Description:

    Extract immediate operand from break instruction.

Arguments:

    Iip - Bundle address of instruction

    SlotNumber - Slot of break instruction within bundle

Return Value:

    Value of immediate operand.

--*/

{
    PULONGLONG BundleAddress;
    ULONGLONG BundleLow;
    ULONGLONG BundleHigh;
    BREAK_INST BreakInst;
    ULONG Imm21;

    BundleAddress = (PULONGLONG)Iip;

    BundleLow = *BundleAddress;
    BundleHigh = *(BundleAddress+1);

    //
    // Align instruction
    //

    switch (SlotNumber) {
        case 0:
            BreakInst.u.Ulong64 = BundleLow >> 5;
            break;

        case 1:
            BreakInst.u.Ulong64 = (BundleLow >> 46) | (BundleHigh << 18);
            break;

        case 2:
            BreakInst.u.Ulong64 = (BundleHigh >> 23);
            break;
    }

    //
    // Extract immediate value
    //

    Imm21 = (ULONG)(BreakInst.u.i_field.i<<20) | (ULONG)(BreakInst.u.i_field.imm20);

    return Imm21;
}

BOOLEAN
KiDebugFault (
    IN PKTRAP_FRAME TrapFrame
    )

{
    PEXCEPTION_RECORD ExceptionRecord;
    KEXCEPTION_FRAME Dummy;
    PKPRCB Prcb;

    TrapFrame->StIPSR |= (1i64 << PSR_DD);

    if (((TrapFrame->StIPSR >> PSR_CPL) & (PSR_CPL_LEN - 1)) == IA64_KERNEL_PL) {

        //
        // Disable all hardware breakpoints 
        //
        
        KeSetLowPsrBit(PSR_DB, 0);
            
    }
    
    //
    // Initialize exception record
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;

    ExceptionRecord->ExceptionCode = STATUS_SINGLE_STEP;
    ExceptionRecord->ExceptionAddress =
        (PVOID) RtlIa64InsertIPSlotNumber(TrapFrame->StIIP,
                                 ((TrapFrame->StISR & ISR_EI_MASK) >> ISR_EI));

    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = 0;
    ExceptionRecord->ExceptionInformation[1] = TrapFrame->StIFA;
    ExceptionRecord->ExceptionInformation[2] = 0;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;

    return TRUE;
}

BOOLEAN
KiOtherBreakException (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    Handler for break exception other than the ones for fast and
    normal system calls. This includes debug break points.

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

    NT status code.

--*/

{
    PEXCEPTION_RECORD ExceptionRecord;
    ULONG BreakImmediate;
    ISR Isr;

    BreakImmediate = (ULONG)(TrapFrame->StIIM);

    //
    // Handle break.b case
    //

    try {

        if (BreakImmediate == 0) {
            Isr.ull = TrapFrame->StISR;
            BreakImmediate = KiExtractImmediate(TrapFrame->StIIP,
                                                (ULONG)Isr.sb.isr_ei);
            TrapFrame->StIIM = BreakImmediate;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // if an exception (memory fault) occurs, then let it re-execute break.b.
        //
        return FALSE;
    }

    //
    // Initialize exception record
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;
    ExceptionRecord->ExceptionAddress =
        (PVOID) RtlIa64InsertIPSlotNumber(TrapFrame->StIIP,
                                 ((TrapFrame->StISR & ISR_EI_MASK) >> ISR_EI));

    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = 0;
    ExceptionRecord->ExceptionInformation[1] = 0;
    ExceptionRecord->ExceptionInformation[2] = 0;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;

    switch (BreakImmediate) {

    case KERNEL_BREAKPOINT:
    case USER_BREAKPOINT:
    case BREAKPOINT_PRINT:
    case BREAKPOINT_PROMPT:
    case BREAKPOINT_STOP:
    case BREAKPOINT_LOAD_SYMBOLS:
    case BREAKPOINT_UNLOAD_SYMBOLS:
    case BREAKPOINT_BREAKIN:
        ExceptionRecord->ExceptionCode = STATUS_BREAKPOINT;
        ExceptionRecord->ExceptionInformation[0] = BreakImmediate;
        break;

    case INTEGER_DIVIDE_BY_ZERO_BREAK:
        ExceptionRecord->ExceptionCode = STATUS_INTEGER_DIVIDE_BY_ZERO;
        break;

    case INTEGER_OVERFLOW_BREAK:
        ExceptionRecord->ExceptionCode = STATUS_INTEGER_OVERFLOW;
        break;

    case MISALIGNED_DATA_BREAK:
        ExceptionRecord->ExceptionCode = STATUS_DATATYPE_MISALIGNMENT;
        break;

    case RANGE_CHECK_BREAK:
    case NULL_POINTER_DEFERENCE_BREAK:
    case DECIMAL_OVERFLOW_BREAK:
    case DECIMAL_DIVIDE_BY_ZERO_BREAK:
    case PACKED_DECIMAL_ERROR_BREAK:
    case INVALID_ASCII_DIGIT_BREAK:
    case INVALID_DECIMAL_DIGIT_BREAK:
    case PARAGRAPH_STACK_OVERFLOW_BREAK:

    default:
#if DBG
        InbvDisplayString ("KiOtherBreakException: Unknown break code.\n");
#endif // DBG
        ExceptionRecord->ExceptionCode = STATUS_ILLEGAL_INSTRUCTION;
        break;
    }

    return TRUE;
}

BOOLEAN
KiGeneralExceptions (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    Handler for general exception faults: attempt to execute an illegal
    operation, privileged instruction, access a privileged register,
    unimplemented field, unimplemented register, or take an inter-ISA
    branch when disabled.

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

    None.

Notes:

    ISR.ei bits indicate which instruction caused the exception.

    ISR.code{3:0} Non-access instruction (ISR.na = 1)
                  = 0 tpa
                  = 1 fc
                  = 2 probe
                  = 3 tak
                  = 4 lfetch

    ISR.code{7:4} = 0: Illegal operation fault: All reported as STATUS_ILLEGAL_INSTRUCTION.

            ISR.rs = 0: An attempt to execute an illegal operation:
                 -- unassigned major opcodes
                 -- unassigned sub-opcodes
                 -- reserved instruction fields
                 -- writing a read-only register
                 -- accessing a reserved register

            ISR.rs = 1:
                 -- attempt to write outside the current register stack frame
                 -- INVALRS operation with RCS.en = 1
                 -- write to BSP with RCS.en = 1
                 -- write to RNATRC with RCS.en = 1
                 -- read from RNATRC with RCS.en = 1

    ISR.code{7:4} = 1: Privileged operation fault: Reported as STATUS_PRIVILEGED_INSTRUCTION.
    ISR.code{7:4} = 2: Privileged register fault: Reported as STATUS_PRIVILEGED_INSTRUCTION.
    ISR.code{7:4} = 3: Reserved register fault: Reported as STATUS_ILLEGAL_INSTRUCTION.
    ISR.code{7:4} = 4: Illegal ISA transition fault: Reported as STATUS_ILLEGAL_INSTRUCTION.

--*/

{
    BOOLEAN StoreInstruction = FALSE;
    ULONG IsrCode;
    PEXCEPTION_RECORD ExceptionRecord;

    //
    // Initialize the exception record
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;
    ExceptionRecord->ExceptionAddress =
           (PVOID) RtlIa64InsertIPSlotNumber(TrapFrame->StIIP,
                                 ((TrapFrame->StISR & ISR_EI_MASK) >> ISR_EI));

    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = 0;
    ExceptionRecord->ExceptionInformation[1] = 0;
    ExceptionRecord->ExceptionInformation[2] = 0;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;

    IsrCode = (LONG)((TrapFrame->StISR >> ISR_CODE) & ISR_CODE_MASK);

    //
    // Look at ISR code bits {7:4}
    //

    switch (IsrCode >> 4) {

    case ISR_PRIV_OP:
    case ISR_PRIV_REG:

        ExceptionRecord->ExceptionCode = STATUS_PRIVILEGED_INSTRUCTION;

        break;

    case ISR_RESVD_REG:

        //
        // Indicate store or not
        //

        if (TrapFrame->StISR & (1i64 << ISR_W)) {

            StoreInstruction = TRUE;

        } else if (TrapFrame->StISR & (1i64 << ISR_X)) {

            //
            // Indicate execution fault or not
            //

            StoreInstruction = 2;
        }

        ExceptionRecord->ExceptionCode = STATUS_ACCESS_VIOLATION;
        ExceptionRecord->ExceptionInformation[0] = (ULONG_PTR)StoreInstruction;
        ExceptionRecord->ExceptionInformation[1] = 0x1ff8000000000000;
        ExceptionRecord->ExceptionInformation[2] = (ULONG_PTR)STATUS_ACCESS_VIOLATION;
        break;

    case ISR_ILLEGAL_OP:
    case ISR_ILLEGAL_ISA:

        ExceptionRecord->ExceptionCode = STATUS_ILLEGAL_INSTRUCTION;
        break;

    case ISR_ILLEGAL_HAZARD:

        //
        // a new status code will be introduced for hazard faults.
        //

        ExceptionRecord->ExceptionCode = STATUS_ILLEGAL_INSTRUCTION;
        break;

    default:

        if (TrapFrame->PreviousMode == KernelMode) {
            KeBugCheckEx(0xFFFFFFFF,
                        (ULONG_PTR)TrapFrame->StISR,
                        (ULONG_PTR)TrapFrame->StIIP,
                        (ULONG_PTR)TrapFrame,
                        0
                        );
        }

        break;
    }

    return TRUE;
}


BOOLEAN
KiUnimplementedAddressTrap (
    IN PKTRAP_FRAME TrapFrame
    )
/*++

Routine Description:

    Handler for unimplemented instruction faults: an attempt is made
    to execute an instruction at an unimplemented address.

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

--*/
{
    PEXCEPTION_RECORD ExceptionRecord;

    //
    // Initialize the exception record
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;
    ExceptionRecord->ExceptionAddress =
           (PVOID) RtlIa64InsertIPSlotNumber(TrapFrame->StIIP,
                                 ((TrapFrame->StISR & ISR_EI_MASK) >> ISR_EI));

    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[1] = TrapFrame->StIIP;
    ExceptionRecord->ExceptionInformation[2] = STATUS_ACCESS_VIOLATION;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;

    ExceptionRecord->ExceptionCode = STATUS_ACCESS_VIOLATION;

    return TRUE;
}


BOOLEAN
KiNatExceptions (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    Handler for NaT consumption exception faults

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

    None.

Notes:

    ISR.ei bits indicate which instruction caused the exception.

    ISR.code{3:0} Non-access instruction (ISR.na = 1)
                  = 0 tpa
                  = 1 fc
                  = 2 probe
                  = 3 tak
                  = 4 lfetch

    ISR.code{7:4} = 1: Register NaT consumption fault
    ISR.code{7:4} = 2: NaT page consumption fault

--*/

{
    BOOLEAN StoreInstruction = FALSE;
    ULONG IsrCode;
    PEXCEPTION_RECORD ExceptionRecord;

    //
    // Initialize the exception record
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;
    ExceptionRecord->ExceptionAddress =
           (PVOID) RtlIa64InsertIPSlotNumber(TrapFrame->StIIP,
                                 ((TrapFrame->StISR & ISR_EI_MASK) >> ISR_EI));

    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = 0;
    ExceptionRecord->ExceptionInformation[1] = 0;
    ExceptionRecord->ExceptionInformation[2] = 0;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;

    IsrCode = (LONG)((TrapFrame->StISR >> ISR_CODE) & ISR_CODE_MASK);

    //
    // Look at ISR code bits {7:4}
    //

    switch (IsrCode >> 4) {

    case ISR_NAT_REG:

#if 0
        if (TrapFrame->PreviousMode == KernelMode) {

            DbgPrint("FATAL ERROR: Kernel hit a Nat Consumpation Fault!\n");
            KeBugCheckEx(0xFFFFFFFF,
                        (ULONG_PTR)TrapFrame->StISR,
                        (ULONG_PTR)TrapFrame->StIIP,
                        (ULONG_PTR)TrapFrame,
                        0
                        );

            // Do not return from KeBugCheckEx
        }
#endif // 0

        ExceptionRecord->ExceptionCode = STATUS_REG_NAT_CONSUMPTION;
        break;

    case ISR_NAT_PAGE:

        //
        // If we start using a NaT page, we should treat this as a page fault and
        // should call KiMemoryFault().
        //

        ExceptionRecord->ExceptionCode = STATUS_ACCESS_VIOLATION;
        break;

    default:

        if (TrapFrame->PreviousMode == KernelMode) {
            KeBugCheckEx(0xFFFFFFFF,
                        (ULONG_PTR)TrapFrame->StISR,
                        (ULONG_PTR)TrapFrame->StIIP,
                        (ULONG_PTR)TrapFrame,
                        0
                        );
        }

        break;
    }

    return TRUE;
}


BOOLEAN
KiSingleStep (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    Handler for single step trap. An instruction was successfully
    executed and the PSR.ss bit is 1.

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

    None.

Notes:

    ISR.ei bits indicate which instruction caused the exception.

    ISR.code{3:0} = 1000

--*/

{
    PEXCEPTION_RECORD ExceptionRecord;
    ULONG IpsrRi;

    //
    // Initialize the exception record
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;

    //
    // We only want the low order 2 bits so typecast to ULONG
    //
    IpsrRi = (ULONG)(TrapFrame->StIPSR >> PSR_RI) & 0x3;

    ExceptionRecord->ExceptionAddress =
           (PVOID) RtlIa64InsertIPSlotNumber(TrapFrame->StIIP, IpsrRi);

    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = 0;
    ExceptionRecord->ExceptionInformation[1] = 0; // 0 for traps
    ExceptionRecord->ExceptionInformation[2] = 0;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;

    ExceptionRecord->ExceptionCode = STATUS_SINGLE_STEP;

    return TRUE;
}

BOOLEAN
KiFloatFault (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    Handler for EM floating point fault.

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

    None.

Notes:

    IIP contains address of bundle causing the fault.

    ISR.ei bits indicate which instruction caused the exception.

    ISR.code{7:0} =

      ISR.code{0} = 1: IEEE V (invalid) exception (Normal or SIMD-HI)
      ISR.code{1} = 1: Denormal/Unnormal operand exception (Normal or SIMD-HI)
      ISR.code{2} = 1: IEEE Z (divide by zero) exception (Normal or SIMD-HI)
      ISR.code{3} = 1: Software assist (Normal or SIMD-HI)
      ISR.code{4} = 1: IEEE V (invalid) exception (SIMD-LO)
      ISR.code{5} = 1: Denormal/Unnormal operand exception (SIMD-LO)
      ISR.code{6} = 1: IEEE Z (divide by zero) exception (SIMD-LO)
      ISR.code{7} = 1: Software assist (SIMD-LO)

--*/

{
    PEXCEPTION_RECORD ExceptionRecord;

    //
    // Initialize the exception record
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;
    ExceptionRecord->ExceptionAddress =
           (PVOID) RtlIa64InsertIPSlotNumber(TrapFrame->StIIP,
                                 ((TrapFrame->StISR & ISR_EI_MASK) >> ISR_EI));

    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = 0;
    ExceptionRecord->ExceptionInformation[1] = 0;
    ExceptionRecord->ExceptionInformation[2] = 0;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;

    ExceptionRecord->ExceptionCode = STATUS_FLOAT_MULTIPLE_FAULTS;

    return TRUE;
}

BOOLEAN
KiFloatTrap (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    Handler for EM floating point trap.

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

    None.

Notes:

    IIP contains address of bundle with the instruction to be
    executed next.

    ISR.ei bits indicate which instruction caused the exception.

    The fp trap may occur simultaneously with single-step traps. The
    fp trap is reported by the hardware. The singel step trap must
    be detected by software.

    ISR.code{3:0} = ss 0 0 1 (ss = single step)

    ISR{15:7} = fp trap code.

--*/

{
    PEXCEPTION_RECORD ExceptionRecord;
    ULONGLONG SavedISR = TrapFrame->StISR;

    //
    // Initialize the exception record
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;
    ExceptionRecord->ExceptionAddress =
           (PVOID) RtlIa64InsertIPSlotNumber(TrapFrame->StIIPA,
                                 ((TrapFrame->StISR & ISR_EI_MASK) >> ISR_EI));

    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = 0;
    ExceptionRecord->ExceptionInformation[1] = 0;
    ExceptionRecord->ExceptionInformation[2] = 0;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;

    ExceptionRecord->ExceptionCode = STATUS_FLOAT_MULTIPLE_TRAPS;

    //
    // check for single-step trap
    //

    if (SavedISR & (1i64 << ISR_SS_TRAP)) {
        return KiSingleStep(TrapFrame);
    }

    return TRUE;
}


#pragma warning( disable : 4715 ) // not all control paths return a value

EXCEPTION_DISPOSITION
KiSystemServiceHandler (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN FRAME_POINTERS EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext
    )

/*++

Routine Description:

    Control reaches here when a exception is raised in a system service
    or the system service dispatcher, and for an unwind during a kernel
    exception.

    If an unwind is being performed and the system service dispatcher is
    the target of the unwind, then an exception occured while attempting
    to copy the user's in-memory argument list. Control is transfered to
    the system service exit by return a continue execution disposition
    value.

    If an unwind is being performed and the previous mode is user, then
    bug check is called to crash the system. It is not valid to unwind
    out of a system service into user mode.

    If an unwind is being performed, the previous mode is kernel, the
    system service dispatcher is not the target of the unwind, and the
    thread does not own any mutexes, then the previous mode field from
    the trap frame is restored to the thread object. Otherwise, bug
    check is called to crash the system. It is invalid to unwind out of
    a system service while owning a mutex.

    If an exception is being raised and the exception PC is within the
    range of the system service dispatcher in-memory argument copy code,
    then an unwind to the system service exit code is initiated.

    If an exception is being raised and the exception PC is not within
    the range of the system service dispatcher, and the previous mode is
    not user, then a continue searh disposition value is returned. Otherwise,
    a system service has failed to handle an exception and bug check is
    called. It is invalid for a system service not to handle all exceptions
    that can be raised in the service.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    EstablisherFrame - Supplies the frame pointer of the establisher
        of this exception handler.

        N.B. This is not actually the frame pointer of the establisher of
             this handler. It is actually the stack pointer of the caller
             of the system service. Therefore, the establisher frame pointer
             is not used and the address of the trap frame is determined by
             examining the saved s8 register in the context record.

    ContextRecord - Supplies a pointer to a context record.

    DispatcherContext - Supplies a pointer to  the dispatcher context
        record.

Return Value:

    If bug check is called, there is no return from this routine and the
    system is crashed. If an exception occured while attempting to copy
    the user in-memory argument list, then there is no return from this
    routine, and unwind is called. Otherwise, ExceptionContinueSearch is
    returned as the function value.

--*/
{
    CONTEXT Context;
    PKTHREAD Thread;
    PKTRAP_FRAME TrapFrame;
    ULONG_PTR ExceptionAddress;

    extern ULONG KiSystemServiceStartOffset;
    extern ULONG KiSystemServiceEndOffset;
    extern ULONG KiSystemServiceExitOffset;

    if (IS_UNWINDING(ExceptionRecord->ExceptionFlags)) {

        //
        // An unwind is in progress.
        // If a target unwind is being performed, then continue execution
        // is returned to transfer control to the system service exit
        // code.  Otherwise, restore the previous mode if the previous
        // mode is not user and there is no mutex owned by the current
        // thread.
        //

        if (ExceptionRecord->ExceptionFlags & EXCEPTION_TARGET_UNWIND) {
            return ExceptionContinueSearch;
        } else {

            Thread = KeGetCurrentThread();
            if (Thread->PreviousMode == KernelMode) {

                //
                // Previous mode is kernel and no mutex owned.
                //
                // N.B. System convention: unwinder puts the trap frame
                //                         address in IntT0 field of
                //                         context record when it
                //                         encounters an interrupt region.
                //

                TrapFrame = (PKTRAP_FRAME) ContextRecord->IntT0;
                Thread->PreviousMode = (KPROCESSOR_MODE)TrapFrame->PreviousMode;
                return ExceptionContinueSearch;

            } else {

                //
                // Previous mode is user, call bug check.
                //

                KeBugCheck(SYSTEM_UNWIND_PREVIOUS_USER);
            }
        }
    } else {

        ULONG IsrCode;

        //
        // An exception dispatching is in progress.
        // If the exception PC is within the in-memory argument copy code
        // of the system service dispatcher, then call unwind to transfer
        // control to the system service exit code.  Otherwise, check if
        // the previous mode is user or kernel mode.
        //

        ExceptionAddress = (ULONG_PTR)ExceptionRecord->ExceptionAddress;
        if ((ExceptionAddress < MM_EPC_VA+KiSystemServiceStartOffset) ||
            (ExceptionAddress >= MM_EPC_VA+KiSystemServiceEndOffset))
        {
            if (KeGetCurrentThread()->PreviousMode == UserMode) {

                //
                // Previous mode is user, call bug check.
                //

                KeBugCheck(SYSTEM_SERVICE_EXCEPTION);

            } else {

                //
                // Previous mode is kernel, continue to search
                //

                return ExceptionContinueSearch;
            }
        } else {
            IsrCode = (ULONG)((ExceptionRecord->ExceptionInformation[4] >> ISR_CODE) & ISR_CODE_MASK) >> 4;
            if ( (IsrCode == ISR_NAT_REG) || (IsrCode == ISR_NAT_PAGE) ) {
                DbgPrint("WARNING: Kernel hit a Nat Consumpation Fault\n");
                DbgPrint("WARNING: At %p\n", ExceptionRecord->ExceptionAddress);
            }
#pragma warning( disable : 4312 ) // disabling warning on PVOID casting for the ExceptionCode
            RtlUnwind2(EstablisherFrame,
                       (PVOID)(MM_EPC_VA+KiSystemServiceExitOffset),
                       NULL, (PVOID)ExceptionRecord->ExceptionCode, &Context);
#pragma warning ( default: 4312 )
        }
    }


} // KiSystemServiceHandler( )

#pragma warning( default : 4715 )


BOOLEAN
KiUnalignedFault (
    IN PKTRAP_FRAME TrapFrame
    )
/*++

Routine Description:

    Handler for unaligned data reference.

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

    None.

Notes:

    ISR.ei bits indicate which instruction caused the exception.

--*/

{
    PEXCEPTION_RECORD ExceptionRecord;
    PVOID VirtualAddress;

    VirtualAddress = (PVOID)TrapFrame->StIFA;

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;
    ExceptionRecord->ExceptionAddress =
        (PVOID)RtlIa64InsertIPSlotNumber(TrapFrame->StIIP,
                   ((TrapFrame->StISR & ISR_EI_MASK) >> ISR_EI));

    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = (ULONG_PTR)0;
    ExceptionRecord->ExceptionInformation[1] = (ULONG_PTR)VirtualAddress;
    ExceptionRecord->ExceptionInformation[2] = (ULONG_PTR)0;
    ExceptionRecord->ExceptionInformation[3] = (ULONG_PTR)TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = (ULONG_PTR)TrapFrame->StISR;

    ExceptionRecord->ExceptionCode = STATUS_DATATYPE_MISALIGNMENT;

    return TRUE;
}


VOID
KiAdvanceInstPointer(
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to advance the instruction pointer in the trap frame.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    The intruction pointer in the trap frame has been advanced.

--*/

{

    ULONGLONG PsrRi;

    PsrRi = ((TrapFrame->StIPSR >> PSR_RI) & 3i64) + 1;

    if (PsrRi == 3) {

        PsrRi = 0;
        TrapFrame->StIIP += 16;

    }

    TrapFrame->StIPSR &= ~(3i64 << PSR_RI);
    TrapFrame->StIPSR |= (PsrRi << PSR_RI);

    return;
}

#if 0  // obsolete; may be used for debug purposes

typedef struct _CHECK_INST {
    union {
        struct {
            ULONGLONG qp:    6;
            ULONGLONG imm7:  7;
            ULONGLONG r2:    7;
            ULONGLONG imm13:13;
            ULONGLONG x3:    3;
            ULONGLONG s:     1;
            ULONGLONG Op:    4;
            ULONGLONG Rsv:   23;
        } i;
        ULONGLONG Ulong64;
    } u;
} CHECK_INST;

BOOLEAN
KiEmulateSpeculationFault(
    IN PKTRAP_FRAME TrapFrame
    )
{
    PULONGLONG BundleAddress;
    ULONGLONG BundleLow;
    ULONGLONG BundleHigh;
    ULONG SlotNumber;
    CHECK_INST CheckInst;
    ISR Isr;
    ULONGLONG Imm24;

    BundleAddress = (PULONGLONG)TrapFrame->StIIP;

    try {

        BundleLow = *BundleAddress;
        BundleHigh = *(BundleAddress+1);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // if an exception (memory fault) occurs, then let it re-execute chk.s again
        //
        return FALSE;
    }

    Isr.ull = TrapFrame->StISR;
    SlotNumber = (ULONG)Isr.sb.isr_ei;

    //
    // Align instruction
    //

    switch (SlotNumber) {
        case 0:
            CheckInst.u.Ulong64 = BundleLow >> 5;
            break;

        case 1:
            CheckInst.u.Ulong64 = (BundleLow >> 46) | (BundleHigh << 18);
            break;

        case 2:
            CheckInst.u.Ulong64 = (BundleHigh >> 23);
            break;
    }

    //
    // Extract immediate value
    //

    Imm24 = ((CheckInst.u.i.imm13 << 7)|(CheckInst.u.i.imm7)) << 4;

    if (CheckInst.u.i.s == 1) {

        Imm24 = 0xFFFFFFFFFF000000|Imm24;

    }

    TrapFrame->StIIP += Imm24;

    TrapFrame->StIPSR &= ~(3i64 << PSR_RI);

    return FALSE;
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ia64\trap.s ===
//++
//
// Module Name:
//       trap.s
//
// Abstract:
//       Low level interruption handlers
//
// Author:
//       Bernard Lint      12-Jun-1995
//
// Environment:
//       Kernel mode only
//
// Revision History:
//
//
// Open Design Issues:
//
//--

#if 1 // interruption logging is enabled in checked and free builds
#define INTERRUPTION_LOGGING 1
#endif // DBG

#include "ksia64.h"

         .file "trap.s"
         .explicit

//
// Globals imported:
//

        PublicFunction(KeBugCheckEx)
        PublicFunction(KiApcInterrupt)
        PublicFunction(KiCheckForSoftwareInterrupt)
        PublicFunction(KiDispatchException)
        PublicFunction(KiExternalInterruptHandler)
        PublicFunction(KiFloatTrap)
        PublicFunction(KiFloatFault)
        PublicFunction(KiGeneralExceptions)
        PublicFunction(KiUnimplementedAddressTrap)
        PublicFunction(KiNatExceptions)
        PublicFunction(KiMemoryFault)
        PublicFunction(KiOtherBreakException)
        PublicFunction(KiPanicHandler)
        PublicFunction(KiSingleStep)
        PublicFunction(KiUnalignedFault)
        PublicFunction(PsConvertToGuiThread)
        PublicFunction(ExpInterlockedPopEntrySListFault)
        PublicFunction(KiDebugFault)
        PublicFunction(KeSetLowPsrBit)
        PublicFunction(KiTestGdiBatchCount)        
        PublicFunction(KeCopySafe)                
        PublicFunction(KiIA32ExceptionVectorHandler)
        PublicFunction(KiIA32InterruptionVectorHandler)
        PublicFunction(KiIA32InterceptionVectorHandler)


        .global     KiSystemServiceHandler
        .global     KeServiceDescriptorTableShadow
        .global     KeGdiFlushUserBatch
        .global     KdDebuggerEnabled
        .global     MiDefaultPpe

// For Conditional Interrupt Logging
#define UserSystemcallBit 61
#define ExternalInterruptBit 62

        .global     KiVectorLogMask



//
// Register aliases used throughout the entire module
//

//
// Banked general registers
//
// h16-h23 can only be used when psr.ic=1.
//
// h24-h31 can only be used when psr.ic=0 (these are reserved for tlb
// and pal/machine check handlers when psr.ic=1).
//

//
// Shown below are aliases of bank 0 registers used in the low level handlers
// by macros ALLOCATE_TRAP_FRAME, SAVE_INTERRUPTION_RESOURCES, and
// RETURN_FROM_INTERRUPTION.  When the code in the macros are changes, these
// register aliases must be reviewed.
//

        rHIPSR      = h16
        rHpT2       = h16

        rHIIPA      = h17
        rHRSC       = h17
        rHDfhPFS    = h17  // used to preserve pfs in KiDisabledFpRegisterVector

        rHIIP       = h18
        rHFPSR      = h18

        rHOldPreds  = h19
        rHBrp       = h19
        rHRNAT      = h19

        rHIFS       = h20
        rHPFS       = h20
        rHBSP       = h20

        rHISR       = h21
        rHUNAT      = h21
        rHBSPSTORE  = h21
        rHpT3       = h21

        rHSp        = h22
        rHDfhBrp    = h22  // used to preserve brp in KiDisabledFpRegisterVector
        rHpT4       = h22

        rHpT1       = h23

        rTH3        = h24

        rHHandler   = h25
        rTH1        = h26
        rTH2        = h27

        rHIIM       = h28
        rHIFA       = h28

        rHEPCVa     = h29
        rHEPCVa2    = h30
        rPanicCode  = h30

        rTH4        = h31

//
// General registers used through out module
//

        pApc      = ps0                         // User Apc Pending
        pUser     = ps1                         // mode on entry was user
        pKrnl     = ps2                         // mode on entry was kernel
        pUstk     = ps3
        pKstk     = ps4
        pEM       = ps5                         // EM ISA on kernel entry
        pIA       = ps6                         // X86 ISA on kernel entry
        pKDbg     = ps7                         // Kernel debug Active
        pUDbg     = ps8                         // Kernel debug Active

//
// Kernel registers used through out module
//
        rkHandler = k6                          // specific exception handler




//
// Macro definitions for this module only
//

//
// Define vector/exception entry/exit macros.
// N.B. All HANDLER_ENTRY functions go into .nsc section with
//      KiNormalSystemCall being the first.
//

#define HANDLER_ENTRY(Name)                     \
        .##global Name;                         \
        .##proc   Name;                         \
Name::

#define HANDLER_ENTRY_EX(Name, Handler)         \
        .##global Name;                         \
        .##proc   Name;                         \
        .##type   Handler, @function;           \
        .##personality Handler;                 \
Name::

#define  VECTOR_ENTRY(Offset, Name, Extra0)     \
        .##org Offset;                          \
        .##global Name;                         \
        .##proc   Name;                         \
Name::


#define VECTOR_EXIT(Name)                       \
        .##endp Name

#define HANDLER_EXIT(Name)                      \
        .##endp Name


//++
// Routine:
//
//       IO_END_OF_INTERRUPT(rVector,rT1,rT2,pEOI)
//
// Routine Description:
//
//       HalEOITable Entry corresponding to the vectorNo is tested.
//       If the entry is nonzero, then vectorNo is stored to the location
//       specified in the entry. If the entry is zero, return.
//
// Arguements:
//
//
// Notes:
//
//       MS preprocessor requires /*   */ style comments
//
//--

#define IO_END_OF_INTERRUPT(rVector,rT1,rT2,pEOI)                             ;\
        movl        rT1 = KiPcr+PcEOITable                                    ;\
        ;;                                                                    ;\
        ld8         rT1 = [rT1]                                               ;\
        ;;                                                                    ;\
        shladd      rT2 = rVector,3,rT1                                       ;\
        ;;                                                                    ;\
        ld8         rT1 = [rT2]                                               ;\
        ;;                                                                    ;\
        cmp.ne      pEOI = zero, rT1                                          ;\
        ;;                                                                    ;\
(pEOI)  st4.rel     [rT1] = rVector


//++
// Routine:
//
//       VECTOR_CALL_HANDLER(Handler, SpecificHandler)
//
// Routine Description:
//
//       Common code for transfer to heavyweight handlers from
//       interruption vectors. Put RSE in store intensive mode,
//       cover current frame and call handler.
//
// Arguments:
//
//       Handler: First level handler for this vector
//       SpecificHandler: Specific handler to be called by the generic
//                        exception handler.
//
// Return Value:
//
//       None
//
// Notes:
//      Uses just the kernel banked registers (h16-h31)
//
//      MS preprocessor requires /* */ style comments
//--


#define VECTOR_CALL_HANDLER(Handler,SpecificHandler)                          ;\
        mov         rHIFA = cr##.##ifa                                        ;\
        movl        rHHandler = SpecificHandler                               ;\
        br##.##sptk Handler                                                   ;\
        ;;


//++
// Routine:
//
//       ALLOCATE_TRAP_FRAME
//
// Routine Description:
//
//       Common code for allocating trap frame on kernel entry for heavyweight
//       handler.
//
// On entry:
//
// On exit: sp -> trap frame; any instruction that depends on sp must be
//          placed in the new instruction group.  Interruption resources
//          ipsr, iipa, iip, predicates, isr, sp, ifs are captured in
//          seven of the banked registers h16-23.  The last one is used
//          by SAVE_INTERRUPTION_STATE as a pointer to save these resources
//          in the trap frame.
//
// Return Value:
//
//       None
//
// Notes:
//      Uses just the kernel banked registers (h16-h31)
//
//      MS preprocessor requires /* */ style comments below
//--

#define ALLOCATE_TRAP_FRAME                                                   ;\
                                                                              ;\
        pOverflow1  = pt2                                                     ;\
        pOverflow2  = pt3                                                     ;\
        pOverflow3  = pt4                                                     ;\
                                                                              ;\
        mov         rHIPSR = cr##.##ipsr                                      ;\
        movl        rTH1 = KiPcr+PcInitialStack                               ;\
                                                                              ;\
        mov         rHIIP = cr##.##iip                                        ;\
        mov         rHOldPreds = pr                                           ;\
        cover                                   /* cover and save IFS       */;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rTH4 = [rTH1], PcBStoreLimit-PcInitialStack               ;\
        mov         rTH3 = ar##.##bsp                                         ;\
        tbit##.##z  pt1, pt0 = sp, 63                                         ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHIIPA = cr##.##iipa                                      ;\
        ld8         rTH2 = [rTH1], PcStackLimit-PcBStoreLimit                 ;\
                                                                              ;\
        mov         rHIFS = cr##.##ifs                                        ;\
        mov         rHSp = sp                                                 ;\
        extr##.##u  rHpT1 = rHIPSR, PSR_CPL, PSR_CPL_LEN /* get mode        */;\
        ;;                                                                    ;\
                                                                              ;\
        cmp4##.##eq pKrnl, pUser = PL_KERNEL, rHpT1  /* set mode pred       */;\
        cmp4##.##eq pKstk, pUstk = PL_KERNEL, rHpT1  /* set stack pred      */;\
        add         rHpT1 = PcKernelDebugActive-PcStackLimit, rTH1            ;\
        ;;                                                                    ;\
                                                                              ;\
(pKstk) ld8         rTH1 = [rTH1]                                             ;\
(pKstk) cmp##.##geu##.##unc  pOverflow2 = rTH3, rTH2                          ;\
(pKstk) add         sp = -TrapFrameLength, sp           /* allocate TF      */;\
        ;;                                                                    ;\
                                                                              ;\
        ld1         rHpT1 = [rHpT1]         /* load kernel db state         */;\
(pKstk) cmp##.##leu##.##unc  pOverflow1 = sp, rTH1                            ;\
(pKstk) cmp##.##geu##.##unc  pOverflow3 = sp, rTH3                            ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHISR = cr##.##isr                                        ;\
        cmp##.##ne##.##or pKDbg = r0, rHpT1 /* kernel debug active?         */;\
        mov         rPanicCode = PANIC_STACK_SWITCH                           ;\
                                                                              ;\
(pUstk) add         sp = -ThreadStateSaveAreaLength-TrapFrameLength, rTH4     ;\
(pOverflow1) br.spnt.few KiPanicHandler                                       ;\
(pOverflow2) br.spnt.few KiPanicHandler                                       ;\
(pOverflow3) br.spnt.few KiPanicHandler 



//++
// Routine:
//
//       SAVE_INTERRUPTION_STATE(Label)
//
// Routine Description:
//
//       Common code for saving interruption state on entry to a heavyweight
//       handler.
//
// Arguments:
//
//       Label: label for branching around BSP switch
//
// On entry:
//
//       sp -> trap frame
//
// On exit:
//
//       Static registers gp, teb, sp, fpsr spilled into the trap frame.
//       Registers gp, teb, fpsr are set up for kernel mode execution.
//
// Return Value:
//
//       None
//
// Notes:
//
//      Interruption resources already captured in bank 0 registers h16-h23.
//      It's safe to take data TLB fault when saving them into the trap
//      frame because kernel stack is always resident in memory.  This macro
//      is carefully constructed to save the bank registers' contents in
//      the trap frame and reuse them to capture other register states as
//      soon as they are available.  Until we have a virtual register
//      allocation scheme in place, the bank 0 register aliases defined at
//      the beginning of the file must be updated when this macro is modified.
//
//      MS preprocessor requires /* */ style comments below
//--


#define SAVE_INTERRUPTION_STATE(Label)                                        ;\
                                                                              ;\
/* Save interruption resources in trap frame */                               ;\
                                                                              ;\
                                                                              ;\
        ssm         (1 << PSR_IC) | (1 << PSR_DFH) | (1 << PSR_AC)            ;\
        add         rHpT1 = TrStIPSR, sp          /* -> IPSR                */;\
        ;;                                                                    ;\
        srlz##.##d                                                            ;\
        st8         [rHpT1] = rHIPSR, TrStISR-TrStIPSR /* save IPSR         */;\
        add         rHpT2 = TrPreds, sp               /* -> Preds           */;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT1] = rHISR, TrStIIP-TrStISR  /* save ISR           */;\
        st8         [rHpT2] = rHOldPreds, TrBrRp-TrPreds                      ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHUNAT = ar##.##unat                                      ;\
        st8         [rHpT1] = rHIIP, TrStIFS-TrStIIP  /* save IIP           */;\
        mov         rHBrp = brp                                               ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHFPSR = ar##.##fpsr                                      ;\
        st8         [rHpT1] = rHIFS, TrStIIPA-TrStIFS /* save IFS           */;\
        mov         rHPFS = ar##.##pfs                                        ;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT1] = rHIIPA, TrStFPSR-TrStIIPA /* save IIPA        */;\
        st8         [rHpT2] = rHBrp, TrRsPFS-TrBrRp                           ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHRSC = ar##.##rsc                                        ;\
        st8         [rHpT2] = rHPFS                   /* save PFS           */;\
        add         rHpT2 = TrApUNAT, sp                                      ;\
                                                                              ;\
        mov         rHBSP = ar##.##bsp                                        ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         ar##.##rsc = r0                 /* put RSE in lazy mode */;\
        st8         [rHpT2] = rHUNAT, TrIntGp-TrApUNAT /* save UNAT         */;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHBSPSTORE = ar##.##bspstore /* get user bspstore point */;\
        st8         [rHpT1] = rHFPSR, TrRsBSP-TrStFPSR /* save FPSR         */;\
        ;;                                                                    ;\
                                                                              ;\
        st8##.##spill [rHpT2] = gp, TrIntTeb-TrIntGp  /* spill GP           */;\
        st8         [rHpT1] = rHBSP                   /* save BSP           */;\
        ;;                                                                    ;\
                                                                              ;\
        st8##.##spill [rHpT2] = teb, TrIntSp-TrIntTeb /* spill TEB (r13)    */;\
(pUstk) mov         teb = kteb                        /* sanitize teb       */;\
        sub         rHBSP = rHBSP, rHBSPSTORE       /* size of dirty region */;\
        ;;                                                                    ;\
                                                                              ;\
        st8##.##spill [rHpT2] = rHSp, TrApDCR-TrIntSp /* spill SP           */;\
        movl        rHpT1 = KiPcr + PcKernelGP                                ;\
        ;;                                                                    ;\
                                                                              ;\
(pUstk) mov         rHRNAT = ar##.##rnat          /* get RNAT               */;\
        movl        rHFPSR = FPSR_FOR_KERNEL      /* initial fpsr value     */;\
        ;;                                                                    ;\
                                                                              ;\
        mov         ar##.##fpsr = rHFPSR          /* set fpsr               */;\
        add         rHpT2 = TrRsRSC, sp                                       ;\
        dep         rHRSC = rHBSP, rHRSC, RSC_MBZ1, RSC_LOADRS_LEN            ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         gp = [rHpT1], PcInitialBStore-PcKernelGP /* load GP     */;\
        st8         [rHpT2] = rHRSC, TrRsBSPSTORE-TrRsRSC                     ;\
(pKstk) br##.##dpnt Label                       /* br if on kernel stack    */;\
        ;;                                                                    ;\
                                                                              ;\
/*                                                                          */;\
/* If previous mode is user, switch to kernel backing store                 */;\
/* -- uses the "loadrs" approach. Note that we do not save the              */;\
/* BSP/BSPSTORE in the trap frame if prvious mode was kernel                */;\
/*                                                                          */;\
                                                                              ;\
        ld8       rHpT4 = [rHpT1]               /* load kernel bstore       */;\
        st8       [rHpT2] = rHBSPSTORE, TrRsRNAT-TrRsBSPSTORE                 ;\
        ;;                                                                    ;\
                                                                              ;\
        st8       [rHpT2] = rHRNAT              /* save user RNAT           */;\
        dep       rHpT4 = rHBSPSTORE, rHpT4, 0, 9                             ;\
                                                /* adjust kernel BSPSTORE   */;\
                                                /* for NAT collection       */;\
        ;;                                                                    ;\
                                                                              ;\
/*                                                                          */;\
/* Now running on kernel backing store                                      */;\
/*                                                                          */;\
                                                                              ;\
Label:                                                                        ;\
(pUstk) mov       ar##.##bspstore = rHpT4       /* switch to kernel BSP     */;\
(pUstk) mov       ar##.##rsc = RSC_KERNEL       /* turn rse on, kernel mode */;\
        bsw##.##1                               /* switch back to user bank */;\
        ;;                                      /* stop bit required        */;\



//++
// Routine:
//
//       RETURN_FROM_INTERRUPTION
//
// Routine Description:
//
//       Common handler code to restore trap frame and resume execution
//       at the interruption address.
//
// Arguments:
//
//       Label
//
// Return Value:
//
//       None
//
// Note:
//
//       On entry: interrrupts disabled, sp -> trap frame
//       On exit:
//       MS preprocessor requires /* */ style comments below
//--

#define RETURN_FROM_INTERRUPTION(Label)                                       ;\
                                                                              ;\
        .##regstk 0,4,2,0       /* must match the alloc instruction below */  ;\
                                                                              ;\
        rBSP      = loc0                                                      ;\
        rRnat     = loc1                                                      ;\
                                                                              ;\
        rpT1      = t1                                                        ;\
        rpT2      = t2                                                        ;\
        rpT3      = t3                                                        ;\
        rpT4      = t4                                                        ;\
        rThread   = t6                                                        ;\
        rApcFlag  = t7                                                        ;\
        rT1       = t8                                                        ;\
        rT2       = t9                                                        ;\
                                                                              ;\
                                                                              ;\
        alloc       rT1 = 0,4,2,0                                             ;\
        movl        rpT1 = KiPcr + PcCurrentThread     /* ->PcCurrentThread */;\
        ;;                                                                    ;\
                                                                              ;\
        invala                                                                ;\
(pUstk) ld8         rThread = [rpT1], PcDebugActive-PcCurrentThread           ;\
(pKstk) br##.##call##.##spnt brp = KiRestoreTrapFrame                         ;\
        ;;                                                                    ;\
                                                                              ;\
(pUstk) ld1         rT1 = [rpT1]         /* load user debug active state    */;\
(pUstk) add         rpT1 = ThApcState+AsUserApcPending, rThread               ;\
(pKstk) br##.##spnt Label##CriticalExitCode                                   ;\
        ;;                                                                    ;\
                                                                              ;\
        ld1         rApcFlag = [rpT1], ThAlerted-ThApcState-AsUserApcPending  ;\
        add         rBSP = TrRsBSP, sp                                        ;\
        add         rRnat = TrRsRNAT, sp               /* -> user RNAT      */;\
        ;;                                                                    ;\
                                                                              ;\
        st1.nta     [rpT1] = zero                                             ;\
        cmp##.##ne  pApc = zero, rApcFlag                                     ;\
        cmp##.##ne  pUDbg = zero, rT1    /* if ne, user debug active        */;\
        ;;                                                                    ;\
                                                                              ;\
        PSET_IRQL   (pApc, APC_LEVEL)                                         ;\
        movl        gp = _gp             /* restore to kernel gp value      */;\
                                                                              ;\
 (pApc) FAST_ENABLE_INTERRUPTS                                                ;\
 (pApc) mov         out1 = sp                                                 ;\
 (pApc) br##.##call##.##sptk brp = KiApcInterrupt                             ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rBSP = [rBSP]                      /* user BSP          */;\
        ld8         rRnat = [rRnat]                    /* user RNAT         */;\
                                                                              ;\
 (pApc) FAST_DISABLE_INTERRUPTS                                               ;\
        PSET_IRQL   (pApc, zero)                                              ;\
(pUDbg) br##.##call##.##spnt brp = KiLoadUserDebugRegisters                   ;\
        ;;                                                                    ;\
                                                                              ;\
        br##.##call##.##sptk brp = KiRestoreTrapFrame                         ;\
        ;;                                                                    ;\
                                                                              ;\
                                                                              ;\
Label##CriticalExitCode:                                                      ;\
                                                                              ;\
        add         loc2  = TrBrRp, sp                                        ;\
        add         loc3  = TrRsRSC, sp                                       ;\
        bsw##.##0                                                             ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHBrp = [loc2], TrStIPSR-TrBrRp                           ;\
        ld8         rHRSC = [loc3]                                            ;\
        mov         loc3 = RSC_KERNEL_DISABLED                                ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHIPSR = [loc2], TrRsPFS-TrStIPSR                         ;\
        movl        rHpT1 = KiPcr+PcHighFpOwner                               ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHPFS = [loc2]                                            ;\
        ld8         rHpT4 = [rHpT1], PcCurrentThread-PcHighFpOwner            ;\
        extr.u      loc2 = rHRSC, RSC_MBZ1, RSC_LOADRS_LEN                    ;\
        ;;                                                                    ;\
                                                                              ;\
        sub         rHBSPSTORE = rBSP, loc2                                   ;\
        dep         loc3 = loc2, loc3, RSC_LOADRS, RSC_LOADRS_LEN             ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         ar##.##rsc = loc3                 /* RSE off       */     ;\
        mov         brp = rHBrp                                               ;\
        mov         rHRNAT  = rRnat                                           ;\
        ;;                                                                    ;\
                                                                              ;\
        alloc       rTH1 = 0,0,0,0                                            ;\
        ;;                                                                    ;\
                                                                              ;\
        loadrs                                         /* pull in user regs */;\
                                                       /* up to tear point */ ;\
        dep         rHRSC = r0, rHRSC, RSC_MBZ1, RSC_LOADRS_LEN               ;\
        ;;                                                                    ;\
                                                                              ;\
(pUstk) mov         ar##.##bspstore = rHBSPSTORE       /* restore user BSP */ ;\
        ld8         rHpT3 = [rHpT1], PcKernelDebugActive-PcCurrentThread      ;\
        mov         ar##.##pfs = rHPFS              /* restore PFS          */;\
        ;;                                                                    ;\
                                                                              ;\
(pUstk) mov         ar##.##rnat = rHRNAT               /* restore user RNAT */;\
        ld1         rHpT1 = [rHpT1]                                           ;\
        add         rHIFS = TrStIFS, sp                                       ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHIFS = [rHIFS]                 /* load IFS             */;\
        cmp##.##ne  pt0, pt1 = rHpT4, rHpT3                                   ;\
        dep         rHpT4 = 0, rHIPSR, PSR_MFH, 1                             ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         ar.rsc = rHRSC                     /* restore user RSC  */;\
(pKstk) cmp##.##ne##.##unc pKDbg, pt2 = rHpT1, r0   /* hardware debug? */     ;\
(pUstk) dep         rHpT4 = 1, rHpT4, PSR_DFH, 1                              ;\
        ;;                                                                    ;\
                                                                              ;\
 (pt0)  mov         rHIPSR = rHpT4                                            ;\
        add         rHpT4 = TrApUNAT, sp            /* -> previous UNAT     */;\
        add         rHpT1 = TrStIIPA, sp                                      ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHUNAT = [rHpT4],TrPreds-TrApUNAT                         ;\
        ld8         rHIIPA = [rHpT1], TrStIIP-TrStIIPA                        ;\
(pKDbg) dep         rHIPSR = 1, rHIPSR, PSR_DB, 1                             ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHOldPreds = [rHpT4], TrIntSp-TrPreds                     ;\
        ld8         rHIIP = [rHpT1], TrStIFS-TrStIIP  /* load IIP           */;\
 (pt2)  dep         rHIPSR = 0, rHIPSR, PSR_DB, 1                             ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8##.##fill sp = [rHpT4], TrStIFS-TrIntSp                            ;\
        rsm         1 << PSR_IC                     /* reset ic bit         */;\
        ;;                                                                    ;\
                                                                              ;\
        srlz##.##d                                  /* must serialize       */;\
                                                                              ;\
/*                                                                          */;\
/* Restore status registers                                                 */;\
/*                                                                          */;\
                                                                              ;\
        mov         cr##.##ipsr = rHIPSR        /* restore previous IPSR    */;\
        mov         cr##.##iipa = rHIIPA        /* restore previous IIPA    */;\
                                                                              ;\
        mov         cr##.##ifs = rHIFS          /* restore previous IFS     */;\
        mov         cr##.##iip = rHIIP          /* restore previous IIP     */;\
        mov         pr = rHOldPreds, -1             /* restore preds        */;\
        ;;                                                                    ;\
                                                                              ;\
/*                                                                          */;\
/* Resume at point of interruption (rfi must be at end of instruction group)*/;\
/*                                                                          */;\
        mov         ar##.##unat = rHUNAT            /* restore UNAT         */;\
        mov         h17 = r0                    /* clear TB loop count      */;\
        rfi                                                                   ;\
        ;;


//
// Interruption Vector Table. First level interruption vectors.
// This section must be 32K aligned. The special section ".drectve"
// is used to pass the align command to the linker.
//
        .section .drectve, "MI", "progbits"
        string "-section:.ivt,,align=0x8000"

        .section .ivt = "ax", "progbits"
KiIvtBase::                                     // symbol for start of IVT

//++
//
// KiVhptTransVector
//
// Cause:       The hardware VHPT walker encountered a TLB miss while attempting to
//              reference the virtuall addressed VHPT linear table.
//
// Parameters:  cr.iip  - address of bundle for which the hardware VHPT walker was
//              trying to resolve the TLB miss
//
//              cr.ipsr - copy of PSR at the time of the fault
//
//              cr.idtr - default translation inforamtion for the address that caused
//              a VHPT translation fault
//
//              cr.ifa  - original faulting address
//
//              cr.isr  - original faulting status information
//
// Handle:      Extracts the PDE index from cr.iha (PTE address in VHPT) and
//              generates a PDE address by adding to VHPT_DIRBASE. When accesses
//              a page directory entry (PDE), there might be a TLB miss on the
//              page directory table and returns a NaT on ld8.s. If so, branches
//              to KiPageDirectoryTableFault. If the page-not-present bit of the
//              PDE is not set, branches to KiPageNotPresentFault. Otherwise,
//              inserts the PDE entry into the data TC (translation cache).
//
//--

        VECTOR_ENTRY(0x0000, KiVhptTransVector, cr.ifa)

#if 1
        rva     = h24
        riha    = h25
        rpr     = h26
        rPte    = h27
        rPte2   = h28
        rps     = h29
        risr    = h30
        riha2   = h31
        rCache  = h28

        mov             rva = cr.ifa            // M0
        mov             riha = cr.iha           // M0
        mov             rpr = pr                // I

        mov             risr = cr.isr           // M0
        ;;


#ifndef NO_IHA_CHECK
        thash           riha2 = rva             // M0, for extra IHA checking
#endif
        ld8.s           rPte = [riha]           // M
        tbit.z          pt3, pt4 = risr, ISR_X  // I

        ;;
        tnat.nz         pt0 = rPte              // I
        tbit.z          pt1 = rPte, PTE_VALID           // I

(pt0)   br.cond.spnt    KiPageTableFault        // B
(pt1)   br.cond.spnt    KiPteNotPresentFault    // B
        extr.u          rCache = rPte, 2, 3     // I
        ;;

        cmp.eq          pt5 = 1, rCache         // A
(pt5)   br.cond.spnt    KiPageTableFault        // B
        ;;

.pred.rel "mutex",pt3,pt4
(pt4)   itc.i           rPte                    // M
        ;;
(pt3)   itc.d           rPte                    // M
        ;;

#if !defined(NT_UP)

        ld8.s           rPte2 = [riha]          // M
        mov             rps = PAGE_SHIFT << PS_SHIFT // I
        cmp.ne          pt0 = zero, zero             // I
        ;;

        cmp.ne.or       pt0 = rPte2, rPte       // M
#ifndef NO_IHA_CHECK
        cmp.ne.or       pt0 = riha, riha2       // M, check if IHA is correct
#endif
        tnat.nz.or      pt0 = rPte2             // I

        ;;
(pt0)   ptc.l           rva, rps                // M
#else 
#ifndef NO_IHA_CHECK
        cmp.ne          pt0 = riha, riha2       // M, check if IHA is correct
        mov             rps = PAGE_SHIFT << PS_SHIFT // I
        ;;
(pt0)   ptc.l           rva, rps                // M
#endif
#endif
        mov             pr = rpr, -1            // I
        rfi;;                                   // B

#else
        rva     =       h24
        riha    =       h25
        rpr     =       h26
        rpPde   =       h27
        rPde    =       h28
        rPde2   =       h29
        rps     =       h30

        mov             riha = cr.iha           // M
        mov             rva = cr.ifa            // M
        mov             rpr = pr                // I
        ;;

        thash           rpPde = riha            // M
        ;;

        ld8.s           rPde = [rpPde]          // M, load PDE
        ;;

        tnat.nz         pt0, p0 = rPde          // I
        tbit.z          pt1, p0 = rPde, PTE_VALID       // I, if non-present page fault

(pt0)   br.cond.spnt    KiPageDirectoryFault    // B
(pt1)   br.cond.spnt    KiPdeNotPresentFault    // B

        mov             cr.ifa = riha           // M
        ;;
        itc.d           rPde                    // M
        ;;

#if !defined(NT_UP)
        ld8.s           rPde2 = [rpPde]         // M
        mov             rps = PAGE_SHIFT << PS_SHIFT // I
        cmp.ne          pt0 = zero, zero             // I
        ;;

        cmp.ne.or       pt0 = rPde2, rPde     // M, if PTEs are different
        tnat.nz.or      pt0 = rPde2           // I

        ;;
(pt0)   ptc.l           riha, rps              // M, purge it
#endif
        mov             pr = rpr, -1            // I
        rfi                                     // B
        ;;
#endif

        VECTOR_EXIT(KiVhptTransVector)


//++
//
// KiInstTlbVector
//
// Cause:       The VHPT walker aborted the search for the instruction translation.
//
// Parameters:  cr.iip  - address of bundle for which the hardware VHPT walker was
//              trying to resolve the TLB miss
//
//              cr.ipsr - copy of PSR at the time of the fault
//
//              cr.iha  - PTE address in the VHPT which the VHPT walker was attempting to
//              reference
//
//              cr.iitr - default translation inforamtion for the address that caused
//              a instruction TLB miss
//
//              cr.isr  - faulting status information
//
// Handle:      As the VHPT has aborted the search or the implemenation does not
//              support the h/w page table walk, the handler needs to emulates the
//              function. Since the offending PTE address is already available
//              with cr.iha, the handler can access the PTE without performing THASH.
//              Accessing a PTE with ld8.s may return a NaT. If so, it branches to
//              KiPageTableFault. If the page-not-present bit of the PTE is not set,
//              it branches to KiPageFault.
//
// Comments:    Merced never casues this fault since it never abort the search on the
//              VHPT.
//
//--

        VECTOR_ENTRY(0x0400, KiInstTlbVector, cr.iipa)

        rva     = h24
        riha    = h25
        rpr     = h26
        rPte    = h27
        rPte2   = h28
        rps     = h29
        rCache  = h28

KiInstTlbVector0:
        mov             riha = cr.iha           // M
        mov             rva = cr.ifa            // M
        mov             rpr = pr                // I
        ;;

        ld8.s           rPte = [riha]           // M
        ;;

        tnat.nz         pt0, p0 = rPte          // I
        tbit.z          pt1, p0 = rPte, PTE_VALID       // I

(pt0)   br.cond.spnt    KiPageTableFault        // B
(pt1)   br.cond.spnt    KiPteNotPresentFault    // B

        extr.u          rCache = rPte, 2, 3     // I
        ;;

        cmp.eq          pt3 = 1, rCache         // A
(pt3)   br.cond.spnt    Ki4KInstTlbFault        // B

        itc.i           rPte                    // M
        ;;

#if !defined(NT_UP)

        ld8.s           rPte2 = [riha]          // M
        mov             rps = PAGE_SHIFT << PS_SHIFT // I
        cmp.ne          pt0 = zero, zero             // I
        ;;

        cmp.ne.or       pt0 = rPte2, rPte       // M
        tnat.nz.or      pt0 = rPte2             // I

        ;;
(pt0)   ptc.l           rva, rps                // M
#endif
        mov             pr = rpr, -1            // I
        rfi;;                                   // B

        VECTOR_EXIT(KiInstTlbVector)


//++
//
// KiDataTlbVector
//
// Cause:       The VHPT walker aborted the search for the data translation.
//
// Parameters:  cr.iip  - address of bundle for which the hardware VHPT walker was
//              trying to resolve the TLB miss
//
//              cr.ipsr - copy of PSR at the time of the fault
//
//              cr.iha  - PTE address in the VHPT which the VHPT walker was attempting to
//              reference
//
//              cr.idtr - default translation inforamtion for the address that caused
//              a data TLB miss
//
//              cr.ifa  - address that caused a data TLB miss
//
//              cr.isr  - faulting status information
//
// Handle:      As the VHPT has aborted the search or the implemenation does not
//              support the h/w page table walk, the handler needs to emulates the
//              function. Since the offending PTE address is already available
//              with cr.iha, the handler can access the PTE without performing THASH.
//              Accessing a PTE with ld8.s may return a NaT. If so, it branches to
//              KiPageTableFault. If the page-not-present bit of the PTE is not set,
//              it branches to KiPageFault.
//
// Comments:    Merced never casues instruction TLB faults since the VHPT search always
//              sucesses.
//
//--

        VECTOR_ENTRY(0x0800, KiDataTlbVector, cr.ifa)

        rva     = h24
        riha    = h25
        rpr     = h26
        rPte    = h27
        rPte2   = h28
        rps     = h29
        rCache  = h28

KiDataTlbVector0:
        mov             riha = cr.iha           // M
        mov             rva = cr.ifa            // M
        mov             rpr = pr                // I
        ;;

        ld8.s           rPte = [riha]           // M
        ;;

        extr.u          rCache = rPte, 2, 3     // I
        ;;

        cmp.eq          pt3 = 1, rCache         // A
(pt3)   br.cond.spnt    Ki4KDataTlbFault        // B

        tnat.nz         pt0, p0 = rPte          // I
        tbit.z          pt1, p0 = rPte, PTE_VALID       // I

(pt0)   br.cond.spnt    KiPageTableFault        // B
(pt1)   br.cond.spnt    KiPteNotPresentFault    // B

        itc.d           rPte                    // M
        ;;

#if !defined(NT_UP)
        ld8.s           rPte2 = [riha]          // M
        mov             rps = PAGE_SHIFT << PS_SHIFT // I
        cmp.ne          pt0 = zero, zero             // I
        ;;

        cmp.ne.or       pt0 = rPte2, rPte       // M
        tnat.nz.or      pt0 = rPte2             // I
        ;;

(pt0)   ptc.l           rva, rps                // M
#endif
        mov             pr = rpr, -1            // I
        rfi;;                                   // B

        VECTOR_EXIT(KiDataTlbVector)


//++
//
// KiAltTlbVector
//
// Cause:       There was a TLB miss for instruction execution and the VHPT
//              walker was not enabled for the referenced region.
//
// Parameters:  cr.iip  - address of bundle that caused a TLB miss
//
//              cr.ipsr - copy of PSR at the time of the fault
//
//              cr.idtr - default translation inforamtion for the address that caused
//              the fault.
//
//              cr.isr  - faulting status information
//
// Handle:      Currently, NT does not have any use of this vector.
//
//--

        VECTOR_ENTRY(0x0c00, KiAltInstTlbVector, cr.iipa)

        rva = h24
        riha = h25

        mov     rva = cr.ifa
        ;;
        thash   riha = rva
        ;;
        mov     cr.iha = riha
        ;;
        srlz.d
        br.sptk KiInstTlbVector0

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiMemoryFault)

        VECTOR_EXIT(KiAltInstTlbVector)



//++
//
// KiAltDataTlbVector
//
// Cause:       There was a data TLB miss and the VHPT walker was not enabled for
//              the referenced region.
//
// Parameters:  cr.iip  - address of bundle that caused a TLB miss
//
//              cr.ipsr - copy of PSR at the time of the fault
//
//              cr.idtr - default translation inforamtion for the address that caused
//              the fault.
//
//              cr.isr  - faulting status information
//
// Handle:      Currently, NT does not have any use of this vector.
//
//--

        VECTOR_ENTRY(0x1000, KiAltDataTlbVector, cr.ifa)

        rva     =       h24
        riha    =       h25
        rpr     =       h26
        rPte    =       h27
        rKseglimit =    h28
        rIPSR   =       h30
        rISR    =       h29
        rVrn    =       h31

#if NO_VHPT_WALKER

        rRR     =       h30

        mov             rva = cr.ifa                    // M
        mov             rpr = pr                        // I
        ;;

        mov             rRR = rr[rva]
        movl            rKseglimit = KSEG3_LIMIT
        ;;

        thash           riha = rva
        tbit.z          pt4 = rRR, 0

        mov             rIPSR = cr.ipsr
        shr.u           rVrn = rva, VRN_SHIFT           // I, get VPN
(pt4)   br.cond.spnt    AltFault
        ;;

        mov             cr.iha = riha
        ;;
        srlz.d
        mov             pr = rpr, -1
        br.sptk         KiDataTlbVector0
        ;;

AltFault:

#else

        mov             rva = cr.ifa                    // M
        movl            rKseglimit = KSEG3_LIMIT
        ;;

        
        mov             rIPSR = cr.ipsr
        mov             rpr = pr                        // I
        shr.u           rVrn = rva, VRN_SHIFT           // I, get VPN
        ;;

#endif
        extr.u  rIPSR = rIPSR, PSR_CPL, PSR_CPL_LEN 
        ;;

        
        cmp.ne          pt1 = PL_KERNEL, rIPSR
        cmp.ne          pt2 = KSEG3_VRN, rVrn           // M/I
        cmp.eq          pt4 = KSEG4_VRN, rVrn

(pt1)   br.cond.spnt    KiCallMemoryFault               // if it  was User
(pt4)   br.cond.spnt    KiKseg4Fault
(pt2)   br.cond.spnt    NoKsegFault                     // B

        cmp.leu         pt0 = rKseglimit, rva
(pt0)   br.cond.spnt    NoKsegFault

        mov             rISR = cr.isr                   // M
        movl            rPte = VALID_KERNEL_PTE         // L

        mov             rIPSR = cr.ipsr                 // M
        shr.u           rva = rva, PAGE_SHIFT           // I
        ;;
        tbit.z          pt2, pt3 = rISR, ISR_SP         // I
        dep.z           rva = rva, PAGE_SHIFT, 32       // I
        ;;
        or              rPte = rPte, rva                // I
        dep             rIPSR = 1, rIPSR, PSR_ED, 1     // I
        ;;

(pt2)   itc.d           rPte                            // M
        ;;
(pt3)   mov             cr.ipsr = rIPSR                 // M
        ;;

        mov             pr = rpr, -1                    // I
        rfi                                             // B
        ;;

NoKsegFault:

        rPdeUtbase =    h27
        rva0    =       h29
        rPpe    =       h30
        oldgp   =       h31

        shr.u           rva0 = rva, PAGE_SHIFT
        movl            rPdeUtbase = KiPcr+PcPdeUtbase
        mov             oldgp = gp
        movl            gp = _gp
        ;;

        ld8             rPdeUtbase = [rPdeUtbase]
        add             rPpe = @gprel(MiDefaultPpe), gp
        dep.z           rva0 = rva0, PAGE_SHIFT, VRN_SHIFT-PAGE_SHIFT
        ;;

        ld8             rPpe = [rPpe]
        cmp.ne          pt3, p0 = rva0, rPdeUtbase
        mov             gp = oldgp
(pt3)   br.cond.spnt    KiPageFault
        ;;

        itc.d           rPpe
        ;;
        mov             pr = rpr, -1
        rfi;;

        VECTOR_EXIT(KiAltDataTlbVector)



//++
//
// KiNestedTlbVector
//
// Cause:       Instruction/Data TLB miss handler encountered a TLB miss while
//              attempting to reference the PTE in the virtuall addressed
//              VHPT linear table.
//
// Parameters:  cr.iip  - address of bundle for which the hardware VHPT walker was
//              trying to resolve the TLB miss
//
//              cr.ipsr - copy of PSR at the time of VHPT translation fault
//
//              cr.iha  - address in VHPT which the VHPT walker was attempting to
//              reference
//
//              cr.idtr - default translation inforamtion for the virtual address
//              contained in cr.iha
//
//              cr.ifa  - original faulting address
//
//              cr.isr  - faulting status information
//
//              h16(riha) - PTE address in the VHPT which caused the Nested miss
//
// Handle:      Currently, there is no use for Nested TLB vector. This should be
//              a bug fault. Call KiPanicHandler.
//
//--

        VECTOR_ENTRY(0x1400, KiNestedTlbVector, cr.ifa)

        ALLOCATE_TRAP_FRAME
        br.sptk     KiPanicHandler

        VECTOR_EXIT(KiNestedTlbVector)

//++
//
// KiInstKeyMissVector
//
// Cause:       There was a instruction key miss in the translation. Since the
//              architecture allows an implementation to choose a unified TC
//              structure, the hyper space translation brought by the data
//              access-bit may cause a instruction key miss fault.  Only erroneous
//              user code tries to execute the NT page table and hyper space.
//
// Parameters:  cr.iip  - address of bundle which caused a instruction key miss fault
//
//              cr.ipsr - copy of PSR at the time of the data key miss fault
//
//              cr.idtr - default translation inforamtion of the address that caused
//              the fault.
//
//              cr.isr  - faulting status information
//
// Handle:      Save the whole register state and call MmAccessFault().
//
//--

        VECTOR_ENTRY(0x1800, KiInstKeyMissVector, cr.iipa)

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiMemoryFault)

        VECTOR_EXIT(KiInstKeyMissVector)



//++
//
// KiDataKeyMissVector
//
// Cause:       The referenced translation had the different key ID from the one
//              specified the key permission register. This is an indication of
//              TLB miss on the NT page table and hyperspace.
//
// Parameters:  cr.iip  - address of bundle which caused the fault
//
//              cr.ipsr - copy of PSR at the time of the data key miss fault
//
//              cr.idtr - default translation inforamtion of the address that caused
//              the fault.
//
//              cr.ifa  - address that caused a data key miss
//
//              cr.isr  - faulting status information
//
// Handle:      The handler needs to purge the faulting translation and install
//              a new PTE by loading it from the VHPT.  The key ID of the IDTR
//              for the installing translation should be modified to be the same
//              ID as the local region ID.  This effectively creates a local
//              space within the global kernel space.
//
//--

        VECTOR_ENTRY(0x1c00, KiDataKeyMissVector, cr.ifa)

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiMemoryFault)

        VECTOR_EXIT(KiDataKeyMissVector)

//++
//
// KiDirtyBitVector
//
// Cause:       The refereced data translation did not have the dirty-bit set and
//              a write operation was made to this page.
//
// Parameters:  cr.iip  - address of bundle which caused a dirty bit fault
//
//              cr.ipsr - copy of PSR at the time of a data access fault
//
//              cr.idtr - default translation inforamtion for the address that
//              caused the fault
//
//              cr.ifa  - referenced data address that caused the dirty-bit fault
//
//              cr.isr  - faulting status information
//
// Handle:      Save the whole register state and call MmAccessFault().
//
// Comments:    There is always a TLB coherency problem on a multiprocessor
//              system. Rather than implementing an atomic operation of setting
//              dirty-bit within this handler, the handler instead calls the high
//              level C routine, MmAccessFault(), to perform locking the page table
//              and setting the dirty-bit of the PTE.
//
//              It is too much effort to implement the atomic operation of setting
//              the dirty-bit using cmpxchg; a potential nested TLB miss on load/store
//              and restoring ar.ccv complicate the design of the handler.
//
//--

        VECTOR_ENTRY(0x2000, KiDirtyBitVector, cr.ifa)

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiMemoryFault)

        VECTOR_EXIT(KiDirtyBitVector)

//++
//
// KiInstAccessBitVector
//
// Cause:       There is a access-bit fault on the instruction translation. This only
//              happens if the erroneous user mistakenly accesses the NT page table and
//              hyper space.
//
// Parameters:  cr.iip  - address of bundle which caused a instruction access bit fault
//
//              cr.ipsr - copy of PSR at the time of a data access fault
//
//              cr.idtr - default translation inforamtion for the address that
//              caused the fault
//
//              cr.ifa  - referenced data address that caused the data access-bit fault
//
//              cr.isr  - faulting status information
//
// Handle:      Save the whole register state and call MmAccessFault().
//
//--

        VECTOR_ENTRY(0x2400, KiInstAccessBitVector, cr.iipa)

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiMemoryFault)

        VECTOR_EXIT(KiInstAccessBitVector)

//++
//
// KiDataBitAccessVector
//
// Cause:       The reference-bit in the the referenced translation was zero,
//              indicating there was a TLB miss on the NT page table or hyperspace.
//
// Parameters:  cr.iip  - address of bundle which caused a data access bit fault
//
//              cr.ipsr - copy of PSR at the time of a data access fault
//
//              cr.idtr - default translation inforamtion for the address that
//              caused the fault
//
//              cr.ifa  - referenced data address that caused the data access-bit fault
//
//              cr.isr  - faulting status information
//
// Handle:      The reference-bit is used to fault on PTEs for the NT page table and
//              hyperspace. On a data access-bit fault, the handler needs to change the
//              the default key ID of the IDTR to be the local key ID. This effectively
//              creates the local space within the global kernel space.
//
//--

        VECTOR_ENTRY(0x2800, KiDataAccessBitVector, cr.ifa)

        rva     = h24
        rpr     = h26
        rIPSR   = h27
        rISR    = h31

        //
        // check to see if non-present fault occurred on a speculative load.
        // if so, set IPSR.ed bit. This forces to generate a NaT on ld.s after
        // rfi
        //

        mov             rpr = pr
        mov             rISR = cr.isr           // M
        mov             rIPSR = cr.ipsr         // M
        ;;

        tbit.z          pt0, p0 = rISR, ISR_SP  // I
        dep             rIPSR = 1, rIPSR, PSR_ED, 1 // I

(pt0)   br.cond.spnt    KiCallMemoryFault          // B
        ;;

        mov             cr.ipsr = rIPSR         // M
        ;;
        mov             pr = rpr, -1            // I
        rfi                                     // B
        ;;

        VECTOR_EXIT(KiDataBitAccessVector)

//--------------------------------------------------------------------
// Routine:
//
//       KiBreakVector
//
// Description:
//
//       Interruption vector for break instruction.
//
// On entry:
//
//       IIM contains break immediate value:
//                 -- BREAK_SYSCALL -> standard system call
//       interrupts disabled
//       r16-r31 switched to kernel bank
//       r16-r31 all available since no TLB faults at this point
//
// Return value:
//
//       if system call, sys call return value in v0.
//
// Process:
//--------------------------------------------------------------------

        VECTOR_ENTRY(0x2C00, KiBreakVector, cr.iim)

        mov       rHIIM = cr.iim               // get break value
        movl      rTH1 = KiPcr+PcSavedIIM
        ;;
        st8       [rTH1] = rHIIM

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiOtherBreakException)

//
// Do not return from handler
//

        VECTOR_EXIT(KiBreakVector)

//--------------------------------------------------------------------
// Routine:
//
//       KiExternalInterruptVector
//
// Routine Description:
//
//       Interruption vector for External Interrrupt
//
// On entry:
//
//       interrupts disabled
//       r16-r31 switched to kernel bank
//
// Return value:
//
//       none
//
// Process:
//--------------------------------------------------------------------

        VECTOR_ENTRY(0x3000, KiExternalInterruptVector, r0)

        mov     h24 = cr.iip
        movl    h25 = MM_EPC_VA+0x20
        ;;
        mov     h26 = pr
        cmp.ne  pt0 = h25, h24
        add     h25 = 0x10, h25
        ;;
        mov     h27 = cr.ipsr
(pt0)   cmp.ne  pt0 = h25, h24    
        ;;
        
        dep     h27 = 0, h27, PSR_I, 1
(pt0)   br.cond.sptk    kei_taken           
        ;;
        mov     cr.ipsr = h27
        ;;
        mov     pr = h26, -1
        rfi
        ;;

kei_taken:
        mov     pr = h26, -1 
        ;;
        ALLOCATE_TRAP_FRAME
        ;;
        SAVE_INTERRUPTION_STATE(Keih_SaveTrapFrame)
        br.many     KiExternalInterruptHandler
        ;;

//
// Do not return (rfi from handler)
//

        VECTOR_EXIT(KiExternalInterruptVector)

//++
//
// KiPageNotPresentVector
//
// Cause:       The translation for the referenced page did not have a present-bit
//              set.
//
// Parameters:  cr.iip  - address of bundle which caused a page not present fault
//
//              cr.ipsr - copy of PSR at the time of a page not present ault
//
//              cr.idtr - default translation inforamtion for the address that
//              caused the fault
//
//              cr.ifa  - referenced data address if the fault occurred on the data
//              reference
//
//              cr.isr  - faulting status information
//
// Handle:      This is the page fault. The handler saves the register context and
//              calls MmAccessFault().
//
//--

        VECTOR_ENTRY(0x5000, KiPageNotPresentVector, cr.ifa)

        rva     = h24
        riha    = h25
        rpr     = h26
        rPte    = h27
        rps     = h29

        mov             rva = cr.ifa            // M
        mov             rpr = pr                // I
        ;;

        thash           riha = rva              // M
        cmp.ne          pt1 = r0, r0
        mov             rps = PAGE_SHIFT << PS_SHIFT // I
        ;;

        ld8.s           rPte = [riha]           // M
        ;;

        tnat.nz         pt0, p0 = rPte          // I
        tbit.z.or       pt1, p0 = rPte, PTE_ACCESS
        tbit.z.or       pt1, p0 = rPte, PTE_VALID       // I, if non-present page fault

(pt0)   br.cond.spnt    KiPageTableFault        // B
(pt1)   br.cond.spnt    KiPteNotPresentFault    // B

        //
        // if we find a valid PTE that is speculatively fetched into the TLB
        // then, purge it and return.
        //

        ptc.l           rva, rps                // M
        ;;

        mov             pr = rpr, -1            // I
        rfi;;                                   // B

        VECTOR_EXIT(KiPageNotPresentVector)



//++
//
// KiKeyPermVector
//
// Cause:       Read, write or execution key permissions were violated.
//
// Parameters:  cr.iip  - address of bundle which caused a key permission fault
//
//              cr.ipsr - copy of PSR at the time of a key permission fault
//
//              cr.idtr - default translation inforamtion for the address that
//              caused the fault
//
//              cr.ifa  - referenced data address if the key permission occurred on
//              the data reference
//
//              cr.isr  - faulting status information
//
// Handle:      This should not happen.  The EM/NT does not utilize the key permissions.
//              The handler saves the register state and calls the bug check.
//
//--

        VECTOR_ENTRY(0x5100, KiKeyPermVector, cr.ifa)

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiMemoryFault)

        VECTOR_EXIT(KiKeyPermVector)



//++
//
// KiInstAccessRightsVector
//
// Cause:       The referenced page had a access rights violation.
//
// Parameters:  cr.iip  - address of bundle which caused a data access bit fault
//
//              cr.ipsr - copy of PSR at the time of a data access fault
//
//              cr.idtr - default translation inforamtion for the address that
//              caused the fault
//
//              cr.ifa  - referenced data address that caused the data ccess-bit fault
//
//              cr.isr  - faulting status information
//
// Handle:      The handler saves the register context and calls MmAccessFault().
//
//--

        VECTOR_ENTRY(0x5200, KiInstAccessRightsVector, cr.iipa)

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiMemoryFault)

        VECTOR_EXIT(KiInstAccessRightsVector)



//++
//
// KiDataAccessRightsVector
//
// Cause:       The referenced page had a data access rights violation.
//
// Parameters:  cr.iip  - address of bundle which caused a data access rights fault
//
//              cr.ipsr - copy of PSR at the time of a data access rights fault
//
//              cr.idtr - default translation inforamtion for the address that
//              caused the fault
//
//              cr.ifa  - referenced data address that caused the data access rights
//              fault
//
//              cr.isr  - faulting status information
//
// Handle:      The handler saves the register context and calls MmAccessFault().
//
//--

        VECTOR_ENTRY(0x5300, KiDataAccessRightsVector, cr.ifa)

        rva     = h24
        rpr     = h26
        rIPSR   = h27
        rISR    = h31

        //
        // check to see if non-present fault occurred on a speculative load.
        // if so, set IPSR.ed bit. This forces to generate a NaT on ld.s after
        // rfi
        //

        mov             rpr = pr
        mov             rISR = cr.isr           // M
        mov             rIPSR = cr.ipsr         // M
        ;;

        tbit.z          pt0, p0 = rISR, ISR_SP  // I
        dep             rIPSR = 1, rIPSR, PSR_ED, 1 // I

(pt0)   br.cond.spnt    KiCallMemoryFault          // B
        ;;

        mov             cr.ipsr = rIPSR         // M
        ;;
        mov             pr = rpr, -1            // I
        rfi                                     // B
        ;;

        VECTOR_EXIT(KiDataAccessRightsVector)

//--------------------------------------------------------------------
// Routine:
//
//       KiGeneralExceptionsVector
//
// Description:
//
//       Interruption vector for General Exceptions
//
// On entry:
//       interrupts disabled
//       r16-r31 switched to kernel bank
//
// Return value:
//
//       none
//
// Process:
//--------------------------------------------------------------------

        VECTOR_ENTRY(0x5400, KiGeneralExceptionsVector, cr.isr)

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiGeneralExceptions)

//
// Do not return (rfi from handler)
//

        VECTOR_EXIT(KiGeneralExceptionsVector)

//--------------------------------------------------------------------
// Routine:
//
//       KiDisabledFpRegisterVector
//
// Description:
//
//       Interruption vector for Disabled FP-register vector
//
// On entry:
//       interrupts disabled
//       r16-r31 switched to kernel bank
//
// Return value:
//
//       none
//
// Process:
//--------------------------------------------------------------------

        VECTOR_ENTRY(0x5500, KiDisabledFpRegisterVector, cr.isr)

        mov      rHIPSR = cr.ipsr
        mov      rHIIP = cr.iip
        cover
        ;;

        mov      rHIFS = cr.ifs
        extr.u   rTH1 = rHIPSR, PSR_CPL, PSR_CPL_LEN
        mov      rHOldPreds = pr
        ;;

        cmp4.eq  pKrnl, pUser = PL_KERNEL, rTH1
        ;;
(pUser) tbit.z.unc pt0, pt1 = rHIPSR, PSR_DFH    // if dfh not set,
                                                 //     dfl must be set
(pKrnl) br.spnt.few Kdfrv10                      // Kernel mode should never get here.
        ;;

 (pt1)  ssm      1 << PSR_IC                     // set ic bit
 (pt1)  mov      rHDfhPFS = ar.pfs
 (pt1)  mov      rHDfhBrp = brp
        ;;

 (pt1)  srlz.d
 (pt1)  br.call.sptk.many brp = KiRestoreHigherFPVolatile
 (pt0)  br.spnt.few Kdfrv10
        ;;

        rsm      1 << PSR_IC                     // reset ic bit
        dep      rHIPSR = 0, rHIPSR, PSR_DFH, 1  // reset dfh bit
        mov      brp = rHDfhBrp
        ;;

        srlz.d
        mov      cr.ifs = rHIFS
        mov      ar.pfs = rHDfhPFS

        mov      cr.ipsr = rHIPSR
        mov      cr.iip = rHIIP
        mov      pr = rHOldPreds, -1
        ;;

        rfi
        ;;

Kdfrv10:
        mov      pr = rHOldPreds, -1
        movl     rHHandler = KiGeneralExceptions

        br.sptk     KiGenericExceptionHandler
        ;;

        VECTOR_EXIT(KiDisabledFpRegisterVector)

//--------------------------------------------------------------------
// Routine:
//
//       KiNatConsumptionVector
//
// Description:
//
//       Interruption vector for Nat Consumption Vector
//
// On entry:
//       interrupts disabled
//       r16-r31 switched to kernel bank
//
// Return value:
//
//       none
//
// Process:
//--------------------------------------------------------------------

        VECTOR_ENTRY(0x5600, KiNatConsumptionVector, cr.isr)

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiNatExceptions)

//
// Do not return (rfi from handler)
//

        VECTOR_EXIT(KiNatConsumptionVector)

//++
//
// KiSpeculationVector
//
// Cause:       CHK.S, CHK.A, FCHK detected an exception condition.
//
// Parameters:  cr.iip  - address of bundle which caused a speculation fault
//
//              cr.ipsr - copy of PSR at the time of a speculation fault
//
//              cr.iipa - address of bundle containing the last
//                      successfully executed instruction
//
//              cr.iim  - contains the immediate value in either
//                         CHK.S, CHK.A, or FCHK opecode
//
//              cr.isr  - faulting status information
//
// Handle:      The handler implements a branch operation to the
//              recovery code specified by the IIM IP-offset.
//
// Note:        This code will not be exercised until the compiler
//              generates the speculation code.
//
// TBD:         Need to check for taken branch trap.
//
//--

        VECTOR_ENTRY(0x5700, KiSpeculationVector, cr.iim)

        mov             h16 = cr.iim            // get imm offset
        mov             h17 = cr.iip            // get IIP
        ;;
        extr            h16 = h16, 0, 21        // get sign-extended
        mov             h18 = cr.ipsr
        ;;
        shladd          h16 = h16, 4, h17       // get addr for recovery handler
        dep             h18 = 0, h18, PSR_RI, 2 // zero target slot number
        ;;
        mov             cr.ipsr = h18
        mov             cr.iip = h16
        ;;
        rfi
        ;;

        VECTOR_EXIT(KiSpeculationVector)

//++
//
// KiDebugFaultVector
//
// Cause:       A unaligned data access fault has occured
//
// Parameters:  cr.iip  - address of bundle causing the fault.
//
//              cr.ipsr - copy of PSR at the time of interruption.
//
//              cr.iipa - address of bundle containing the last
//                        successfully executed instruction
//
//              cr.isr  - faulting status information. ISR.ei bits are
//                        set to indicate which instruction caused the
//                        exception.
//                        The ISR.code contains information about the
//                        FP exception fault. See trapc.c and the EAS
//
//--

        VECTOR_ENTRY(0x5900, KiDebugFaultVector, cr.isr)

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiDebugFault)

//
// Do not return (rfi from handler)
//

        VECTOR_EXIT(KiDebugFaultVector)

//++
//
// KiUnalignedFaultVector
//
// Cause:       A unaligned data access fault has occured
//
// Parameters:  cr.iip  - address of bundle causing the fault.
//
//              cr.ipsr - copy of PSR at the time of interruption.
//
//              cr.iipa - address of bundle containing the last
//                        successfully executed instruction
//
//              cr.isr  - faulting status information. ISR.ei bits are
//                        set to indicate which instruction caused the
//                        exception.
//                        The ISR.code contains information about the
//                        FP exception fault. See trapc.c and the EAS
//
//--

        VECTOR_ENTRY(0x5a00, KiUnalignedFaultVector, cr.ifa)

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiUnalignedFault)

//
// Do not return (rfi from handler)
//

        VECTOR_EXIT(KiUnalignedFaultVector)


//++
//
// KiFloatFaultVector
//
// Cause:       A floating point fault has occured
//
// Parameters:  cr.iip  - address of bundle causing the fault.
//
//              cr.ipsr - copy of PSR at the time of interruption.
//
//              cr.iipa - address of bundle containing the last
//                        successfully executed instruction
//
//              cr.isr  - faulting status information. ISR.ei bits are
//                        set to indicate which instruction caused the
//                        exception.
//                        The ISR.code contains information about the
//                        FP exception fault. See trapc.c and the EAS
//
//--

        VECTOR_ENTRY(0x5c00, KiFloatFaultVector, cr.isr)

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiFloatFault)

//
// Do not return (rfi from handler)
//

        VECTOR_EXIT(KiFloatFaultVector)

//++
//
// KiFloatTrapVector
//
// Cause:       A floating point trap has occured
//
// Parameters:  cr.iip  - address of bundle with the instruction to be
//                        executed next.
//
//              cr.ipsr - copy of PSR at the time of interruption.
//
//              cr.iipa - address of bundle containing the last
//                        successfully executed instruction
//
//              cr.isr  - faulting status information. ISR.ei bits are
//                        set to indicate which instruction caused the
//                        exception.
//                        The ISR.code contains information about the
//                        FP trap. See trapc.c and the EAS
//
//--

        VECTOR_ENTRY(0x5d00, KiFloatTrapVector, cr.isr)

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiFloatTrap)

//
// Do not return (rfi from handler)
//

        VECTOR_EXIT(KiFloatTrapVector)

//++
//
// KiLowerPrivilegeVector
//
// Cause:       A branch lowers the privilege level and PSR.lp is 1.
//              Or an attempt made to execute an instruction
//              in the unimplemented address space.
//              This trap is higher priority than taken branch
//              or single step traps.
//
// Parameters:  cr.iip  - address of bundle containing the instruction to
//                        be executed next.
//
//              cr.ipsr - copy of PSR at the time of interruption.
//
//              cr.iipa - address of bundle containing the last
//                        successfully executed instruction
//
//              cr.isr  - faulting status information. The ISR.code
//                        contains a bit vector for all traps which
//                        occurred in the trapping bundle.
//
//--

        VECTOR_ENTRY(0x5e00, KiLowerPrivilegeVector, cr.iipa)

        mov       rHISR = cr.isr
        mov       rHOldPreds = pr

        mov       rHIIPA = cr.iipa
        mov       rHIPSR = cr.ipsr
        ;;


        tbit.z    pt1, pt0 = rHISR, ISR_UI_TRAP
(pt1)   br.cond.spnt Klpv10
        ;;

        mov       rHIFA = cr.iip
        movl      rHHandler = KiUnimplementedAddressTrap

        mov       pr = rHOldPreds, -2        // must restore predicates
        br.sptk   KiGenericExceptionHandler
        ;;

Klpv10:
        mov       rPanicCode = UNEXPECTED_KERNEL_MODE_TRAP
        br.sptk   KiPanicHandler

        VECTOR_EXIT(KiLowerPrivilegeVector)

//++
//
// KiTakenBranchVector
//
// Cause:       A taken branch was successfully execcuted and the PSR.tb
//              bit is 1. This trap is higher priority than single step trap.
//
// Parameters:  cr.iip  - address of bundle containing the instruction to
//                        be executed next.
//
//              cr.ipsr - copy of PSR at the time of interruption.
//
//              cr.iipa - address of bundle containing the last
//                        successfully executed instruction
//
//              cr.isr  - faulting status information. The ISR.code
//                        contains a bit vector for all traps which
//                        occurred in the trapping bundle.
//
//--

        VECTOR_ENTRY(0x5f00, KiTakenBranchVector, cr.iipa)

        mov       rHIPSR = cr.ipsr
        movl      rHEPCVa = MM_EPC_VA+0x20     // user system call entry point

        mov       rHIIP = cr.iip
        movl      rHpT1 = KiPcr+PcInitialStack
        ;;

        ld8       rHpT1 = [rHpT1]
        extr.u    rTH1 = rHIPSR, PSR_CPL, PSR_CPL_LEN
        mov       rHOldPreds = pr
        ;;

        cmp.eq    pt0 = rHEPCVa, rHIIP
        movl      rHHandler = KiSingleStep
        ;;
 (pt0)  ssm       1 << PSR_IC
 (pt0)  movl      rHpT3 = 1 << PSR_LP
        ;;

 (pt0)  or        rHpT3 = rHIPSR, rHpT3

 (pt0)  srlz.d
        add       rHpT1=-ThreadStateSaveAreaLength-TrapFrameLength+TrStIPSR,rHpT1
 (pt0)  br.spnt.few Ktbv10

        mov       pr = rHOldPreds, -2
        br.sptk   KiGenericExceptionHandler
        ;;


Ktbv10:

        st8       [rHpT1] = rHpT3
        movl      rHpT3 = 1 << PSR_SS | 1 << PSR_TB | 1 << PSR_DB
        ;;

        rsm       1 << PSR_IC
        mov       pr = rHOldPreds, -2
        andcm     rHIPSR = rHIPSR, rHpT3   // clear ss, tb, db bits
        ;;

        srlz.d
        mov       cr.ipsr = rHIPSR
        ;;
        rfi
        ;;


        VECTOR_EXIT(KiTakenBranchVector)

//++
//
// KiSingleStepVector
//
// Cause:       An instruction was successfully execcuted and the PSR.ss
//              bit is 1.
//
// Parameters:  cr.iip  - address of bundle containing the instruction to
//                        be executed next.
//
//              cr.ipsr - copy of PSR at the time of interruption.
//
//              cr.iipa - address of bundle containing the last
//                        successfully executed instruction
//
//              cr.isr  - faulting status information. The ISR.code
//                        contains a bit vector for all traps which
//                        occurred in the trapping bundle.
//
//--

        VECTOR_ENTRY(0x6000, KiSingleStepVector, cr.iipa)

        mov       rHIPSR = cr.ipsr
        movl      rHEPCVa = MM_EPC_VA+0x20     // user system call entry point

        mov       rHIIP = cr.iip
        movl      rHpT1 = KiPcr+PcInitialStack
        ;;

        ld8       rHpT1 = [rHpT1]
        extr.u    rTH1 = rHIPSR, PSR_CPL, PSR_CPL_LEN
        mov       rHOldPreds = pr
        ;;

        cmp.eq    pt0 = rHEPCVa, rHIIP
        movl      rHHandler = KiSingleStep
        ;;

 (pt0)  ssm       1 << PSR_IC
 (pt0)  movl      rHpT3 = 1 << PSR_LP
        ;;

 (pt0)  or        rHpT3 = rHIPSR, rHpT3

 (pt0)  srlz.d
        add       rHpT1=-ThreadStateSaveAreaLength-TrapFrameLength+TrStIPSR,rHpT1
 (pt0)  br.spnt.few Kssv10

        mov       pr = rHOldPreds, -2
        br.sptk   KiGenericExceptionHandler
        ;;


Kssv10:

        st8       [rHpT1] = rHpT3
        movl      rHpT3 = 1 << PSR_SS | 1 << PSR_DB
        ;;

        rsm       1 << PSR_IC
        mov       pr = rHOldPreds, -2
        andcm     rHIPSR = rHIPSR, rHpT3   // clear ss, db bits
        ;;

        srlz.d
        mov       cr.ipsr = rHIPSR
        ;;
        rfi
        ;;

        VECTOR_EXIT(KiSingleStepVector)

//++
//
// KiIA32ExceptionVector
//
// Cause:       A fault or trap was generated while executing from the
//              iA-32 instruction set.
//
// Parameters:  cr.iip  - address of the iA-32 instruction causing interruption
//
//              cr.ipsr - copy of PSR at the time of the instruction
//
//              cr.iipa - Address of the last successfully executed
//                        iA-32 or EM instruction
//
//              cr.isr  - The ISR.ei exception indicator is cleared.
//                        ISR.iA_vector contains the iA-32 interruption vector
//                        number.  ISR.code contains the iA-32 16-bit error cod
//
// Handle:      Save the whole register state and
//                        call KiIA32ExceptionVectorHandler()().
//
//--

        VECTOR_ENTRY(0x6900, KiIA32ExceptionVector, r0)

        mov       rHIIM = cr.iim               // save info from IIM
        movl      rTH1 = KiPcr+PcSavedIIM
        ;;
        st8       [rTH1] = rHIIM

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler,
                               KiIA32ExceptionVectorHandler)

        VECTOR_EXIT(KiIA32ExceptionVector)

//++
//
// KiIA32InterceptionVector
//
// Cause:       A interception fault or trap was generated while executing
//              from the iA-32 instruction set.
//
// Parameters:  cr.iip  - address of the iA-32 instruction causing interruption
//
//              cr.ipsr - copy of PSR at the time of the instruction
//
//              cr.iipa - Address of the last successfully executed
//                        iA-32 or EM instruction
//
//              cr.isr  - The ISR.ei exception indicator is cleared.
//                        ISR.iA_vector contains the iA-32 interruption vector
//                        number.  ISR.code contains the iA-32specific
//                        interception information
//
// Handle:      Save the whole register state and
//                        call KiIA32InterceptionVectorHandler()().
//
//--

        VECTOR_ENTRY(0x6a00, KiIA32InterceptionVector, r0)


        mov       rHIIM = cr.iim               // save info from IIM
        movl      rTH1 = KiPcr+PcSavedIIM
        ;;
        st8       [rTH1] = rHIIM

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler,
                                KiIA32InterceptionVectorHandler)

         VECTOR_EXIT(KiIA32InterceptionVector)

//++
//
// KiIA32InterruptionVector
//
// Cause:       An iA software interrupt was executed
//
// Parameters:  cr.iip  - address of the iA-32 instruction causing interruption
//
//              cr.ipsr - copy of PSR at the time of the instruction
//
//              cr.iipa - Address of the last successfully executed
//                        iA-32 or EM instruction
//
//              cr.isr  - ISR.iA_vector contains the iA-32 defined vector
//                        number.  ISR.code contains 0
//                        ISR.ei excepting instruction indicator is cleared.
//                        ISR.iA_vector contains the iA-32 instruction vector.
//                        ISR.code contains iA-32 specific information.
//
// Handle:      Save the whole register state and
//                        call KiIA32InterruptionVectorHandler()().
//
//--

        VECTOR_ENTRY(0x6b00, KiIA32InterruptionVector, r0)

        // This one doesn't need IIM, so we won't bother to save it

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler,
                                KiIA32InterruptionVectorHandler)


        VECTOR_EXIT(KiIA32InterruptionVector)

//
// All non-VECTOR_ENTRY functions must follow KiNormalSystemCall.
//
// N.B. KiNormalSystemCall must be the first function body in the .nsc
//      section.
//


//--------------------------------------------------------------------
// Routine:
//
//       KiNormalSystemCall
//
// Description:
//
//       Handler for normal (not fast) system calls
//
// On entry:
//
//       ic off
//       interrupts disabled
//       v0: contains sys call #
//       cover done by call
//       r32-r39: sys call arguments
//       CFM: sof = # args, ins = 0, outs = # args
//       clear mfh bit (high fp registers are scratch per s/w convention)
//
// Return value:
//
//       v0: system call return value
//
// Process:
//
//--------------------------------------------------------------------

        .section .drectve, "MI", "progbits"
        string " -section:.nsc,,align=0x2000"

        .section .nsc = "ax", "progbits"

        HANDLER_ENTRY_EX(KiNormalSystemCall, KiSystemServiceHandler)

        .prologue
        .unwabi     @nt,  EXCEPTION_FRAME

        rPFS        = t0
        rThread     = t1                  // current thread
        rIFS        = t1
        rIIP        = t2
        rPreds      = t3
        rIPSR       = t4
        rUNAT       = t5

        rSp         = t6

        rpT1        = t7
        rpT2        = t8
        rpT3        = t9
        rpT4        = t10
        rT0         = t11
        rT1         = t12
        rT2         = t13
        rT3         = t14
        rT4         = t15

        rKDbgActive = t16
        rIntNats    = t17

        rpSd        = t16                  /* -> service descriptor entry   */
        rSdOffset   = t17                  /* service descriptor offset     */
        rArgTable   = t18                  /* pointer to argument table     */
        rArgNum     = t20                  /* number of arguments     */

        rRscD       = t16
        rRNAT       = t17
        rRscE       = t18
        rKBSPStore  = t18
        rBSPStore   = t19
        rRscDelta   = t20

        rBSP        = t21
        rPreviousMode = t22

        pInvl       = ps9                  /* pInvl = not GUI service       */
        pVal        = pt1
        pGui        = pt2                  /* true if GUI call              */
        pNoGui      = pt3                  /* true if no GUI call           */
        pNatedArg   = pt4                  /* true if any input argument    */
                                           /* register is Nat'ed            */
        pNoCopy     = pt5                  /* no in-memory arguments to copy */
        pCopy       = pt6
        pNatedSp    = pt7


        mov       rUNAT = ar.unat
        tnat.nz   pNatedSp = sp
        mov       rPreviousMode = KernelMode

        mov       rIPSR = psr
        rsm       1 << PSR_I | 1 << PSR_MFH
        br.sptk   Knsc_Allocate
        ;;

//
// N.B. KiUserSystemCall is at an offset of 0x20 from KiNormalSystemCall.
// Whenever this offset is changed, the definition of kernel system call
// stub in services.stb must be updated to reflect the new value.
//

        ALTERNATE_ENTRY(KiUserSystemCall)

        mov       rUNAT = ar.unat
        mov       rPreviousMode = UserMode
        epc
        ;;

        mov       rIPSR = psr
        rsm       (1 << PSR_I) | (1 << PSR_BE)
        tnat.nz   pNatedSp = sp
        ;;                        // stop bit needed to ensure interrupt is off

Knsc_Allocate::

#if defined(INTERRUPTION_LOGGING)

         // For Conditional Interrupt Logging
         mov       rT3 = gp
         movl      gp = _gp
         ;;
         add       rpT1 = @gprel(KiVectorLogMask), gp
         ;;
         ld8       rT1 = [rpT1]
         mov       gp = rT3
         ;;
         tbit.z    pt1 = rT1, UserSystemcallBit
 (pt1)   br.cond.sptk   EndOfLogging1

        mov       rT1 = 0x80                    // dummy offset for sys call
        movl      rpT1 = KiPcr+PcInterruptionCount
        mov       rT2 = b0
        mov       rT3 = MAX_NUMBER_OF_IHISTORY_RECORDS - 1
        ;;

        ld4.nt1   rT4 = [rpT1]                   // get current count
        or        rT1 = rT1, rPreviousMode       // kernel/user
        ;;

        add       rT0 = 1, rT4                  // incr count
        and       rT4 = rT3, rT4                // index of current entry
        add       rpT2 = 0x1000-PcInterruptionCount, rpT1 // base of history
        ;;

        st4.nta   [rpT1] = rT0                  // save count
        shl       rT4 = rT4, 5                  // offset of current entry
        ;;
        add       rpT2 = rpT2, rT4              // address of current entry
        ;;
        st8       [rpT2] = rT1, 8               // save sys call offset
        ;;
        st8       [rpT2] = rT2, 8               // save return address
        ;;
        st8       [rpT2] = rIPSR, 8             // save psr
        ;;
        st8       [rpT2] = v0;                  // save sys call number
        ;;


// For Conditional Interrupt Logging
EndOfLogging1:

#endif // INTERRUPTION_LOGGING

//
// if sp is Nat'ed return to caller with an error status
// N.B. sp is not spilled and a value of zero is saved in the IntNats field
//

        mov       rT1 = cr.dcr
        movl      rpT4 = KiPcr+PcInitialStack

        mov       rSp = sp
(pNatedSp)  movl      rT4 = Knsc_ErrorReturn
        ;;

        mov       rPreds = pr
        nop.f     0
        cmp.eq    pUser, pKrnl = UserMode, rPreviousMode

        mov       rBSP = ar.bsp
(pNatedSp)  movl      v0 = STATUS_IA64_INVALID_STACK
        ;;

(pUser) ld8       sp = [rpT4], PcInitialBStore-PcInitialStack   // set new sp
        mov       rIIP = brp
        mov       rPFS = ar.pfs
        ;;

        mov       rT2 = ar.rsc
(pUser) ld8       rKBSPStore = [rpT4], PcKernelDebugActive-PcInitialBStore
(pNatedSp)  mov       bt0 = rT4
        ;;

(pUser) ld1       rKDbgActive = [rpT4], PcCurrentThread-PcKernelDebugActive
(pKrnl) add       rpT4 = PcCurrentThread-PcInitialStack, rpT4
        extr      rIFS = rPFS, 0, 38

        mov       rT0 = ar.fpsr
(pUser) movl      rT3 = 1 << PSR_SS | 1 << PSR_DB | 1 << PSR_TB | 1 << PSR_LP

(pUser) mov       ar.rsc = r0                    // put RSE in lazy mode
(pUser) add       sp = -ThreadStateSaveAreaLength-TrapFrameLength, sp
(pKrnl) add       sp = -TrapFrameLength, sp      // allocate TF
        ;;

(pUser) mov       rBSPStore = ar.bspstore        // get user bsp store point
        add       rpT1 = TrStIPSR, sp            // -> IPSR
        add       rpT2 = TrIntSp, sp             // -> IntSp
        ;;

(pUser) ld8       rT4 = [rpT1]
        st8       [rpT2] = rSp, TrApUNAT-TrIntSp // sp is not Nat'ed

        add       rpT3 = TrStIFS, sp             // -> IFS
        dep        rIFS = 1, rIFS, 63, 1             // set IFS.v
        ;;

        st8       [rpT2] = rUNAT, TrApDCR-TrApUNAT
        st8       [rpT3] = rIFS, TrRsPFS-TrStIFS // save IFS
(pUser) and       rT4 = rT3, rT4                 // capture psr.db, tb, ss
        ;;

        st8       [rpT2] = rT1, TrPreds-TrApDCR
        st8.nta   [rpT3] = rPFS, TrStFPSR-TrRsPFS // save PFS
(pUser) mov       rT3 = rIPSR

        rBspOff = t5

        extr.u  rBspOff = rBSP, 0, 9
        extr.u  t0 = rIFS, 0, 7
        extr.u  rIFS = rIFS, 7, 7
        ;;

(pUser) mov       rRNAT = ar.rnat
        movl      rT1 = 1 << PSR_I | 1 << PSR_MFH | 1 << PSR_BE

        sub       rIFS = t0, rIFS        
        movl      t0 = 1 << PSR_I | 1 << PSR_BN 
        ;;

        st8       [rpT2] = rPreds, TrIntNats-TrPreds
(pUser) or        rIPSR = rIPSR, rT4
(pUser) cmp.ne.unc pKDbg, pt2 = zero, rKDbgActive // kernel debug active?

        shladd     rBspOff = rIFS, 3, rBspOff
        shladd     rBSP = rIFS, 3, rBSP

        mov     rIFS = 0x1F8
(pUser) dep     t0 = 1, t0, PSR_CPL, 2
        ;;

        st8       [rpT2] = zero,TrIntGp-TrIntNats // all integer Nats are 0
        st8       [rpT3] = rT0, TrStIIP-TrStFPSR // save FPSR
(pUser) andcm     rT3 = rT3, rT1                 // clear i, mfh, be

        cmp.ge    pt0 = rBspOff, rIFS
        or      rIPSR = t0, rIPSR                // set i, cpl, bn for the saved IPSR
        ;;

        st8       [rpT1] = rIPSR                 // save IPSR
        st8       [rpT3] = rIIP, TrBrRp-TrStIIP  // save IIP
 (pt2)  dep       rT3 = 0, rT3, PSR_DB, 1        // disable db in kernel
        ;;

        st8.nta   [rpT3] = rIIP, TrRsBSP-TrBrRp  // save BRP
        st8       [rpT2] = gp                    // Save GP even though it is a temporary
                                                 // If someone does a get/set context and GP
                                                 // is zero in the trap fram then set context
                                                 // will think IIP is a plabel and dereference
                                                 // it.
(pUser) dep       rT3 = 1, rT3, PSR_AC, 1        // enable alignment check
        ;;

        add       rpT2 = TrRsRSC, sp
(pt0)   add       rBSP = 8, rBSP        
(pUser) mov       psr.l = rT3
        ;;
        st8       [rpT3] = rBSP, TrRsBSPSTORE-TrRsBSP
(pUser) sub       rBSP = rBSP, rBSPStore
        ;;

(pUser) st8       [rpT3] = rBSPStore            // save user BSP Store
(pUser) dep       rT2 = rBSP, rT2, RSC_MBZ1, RSC_LOADRS_LEN

(pUser) mov       teb = kteb                     // get Teb pointer
        movl      rT1 = Knsc10                   //  Leave the EPC page
        ;;

        st8       [rpT2] = rT2, TrRsRNAT-TrRsRSC // save RSC
(pUser) dep       rKBSPStore = rBSPStore, rKBSPStore, 0, 9
        mov       b6 = rT1                       // Addres of Knsc10 in KSEG0.
        ;;

(pUser) mov       ar.bspstore = rKBSPStore       // switch to kernel BSP
        movl      gp = _gp                       // set up kernel gp
        ;;

(pUser) mov       ar.rsc = RSC_KERNEL            // turn rse on, in kernel mode
(pUser) st8       [rpT2] = rRNAT                 // save RNAT in trap frame
                                                 // for user backing store
(pNatedSp) br.spnt bt0
        br.sptk   b6
        ;;

Knsc10:

//
// Now running with user banked registers and on kernel backing store
//
// Can now take TLB faults
//
// Preserve the output args (as in's) in the local frame until it's ready to
// call the specified system service because other calls may have to be made
// before that. Also allocate locals and one out.
//


//
// Register aliases for rest of procedure
//

        .regstk    8, 9, 3, 0

        rScallGp    = loc0
        rpThObj     = loc1                      // pointer to thread object
        rSavedV0    = loc2                      // saved v0 for GUI thread
        rpEntry     = loc3                      // syscall routine entry point
        rSnumber    = loc4                      // service number
        rArgEntry   = loc5
        rCount      = loc6      /* index of the first Nat'ed input register  */
        rUserSp     = loc7
        rUserPFS    = loc8
        rArgBytes   = out2


        //
        // the following code uses the predicates to determine the first of
        // the 8 input argument register whose Nat bit is set.  The result
        // is saved in register rCount and used to determine whether to fail
        // the system call in Knsc_CheckArguments.
        //

        alloc     rUserPFS = 8, 9, 3, 0
        ld8       rpThObj = [rpT4]
        mov       rUserSp = rSp

        add       rpT1 = TrEOFMarker, sp
        movl      rT1 = FPSR_FOR_KERNEL          // initial fpsr value
        ;;

        mov       ar.fpsr = rT1                  // set fpsr
        movl      rT3 = KTRAP_FRAME_EOF | EXCEPTION_FRAME
        ;;

        st8       [rpT1] = rT3
        mov       loc0 = pr                     // save local predicates
        ;;

        mov       pr = zero, -1
        add       rpT2 = ThServiceTable, rpThObj
        add       rpT3 = ThTrapFrame, rpThObj
        ;;

        lfetch    [rpT2]
        ld8       rT4 = [rpT3], ThPreviousMode-ThTrapFrame

        cmp.eq    p1 = r32, r32
        cmp.eq    p9 = r33, r33
        cmp.eq    p17 = r34, r34
        cmp.eq    p25 = r35, r35
        cmp.eq    p33 = r36, r36
        cmp.eq    p41 = r37, r37
        cmp.eq    p49 = r38, r38
        cmp.eq    p57 = r39, r39
        mov       rSavedV0 = v0                 // save syscall # across call
        ;;

        ld1       rT0 = [rpT3]                  // rT0 = thread's previous mode
        mov       rT1 = pr
        add       rpT1 = TrTrapFrame, sp        // -> TrTrapFrame
        ;;

        st1       [rpT3] = rPreviousMode        // set new thread previous mode
        mov       pr = loc0, -1                 // restore local predicates
        dep       rT1 = 0, rT1, 0, 1            // clear bit 0
        ;;

        st8       [rpT1] = rT4, TrPreviousMode-TrTrapFrame
        czx1.r    rCount = rT1                  // determine which arg is Nat'ed
        ;;

        st4       [rpT1] = rT0
        FAST_ENABLE_INTERRUPTS
(pKDbg) br.call.spnt brp = KiLoadKernelDebugRegisters
        ;;

        PROLOGUE_END

//
// If the specified system service number is not within range, then
// attempt to convert the thread to a GUI thread and retry the service
// dispatch.
//
// N.B. The system call arguments, the system service entry point (rpEntry),
//      the service number (Snumber)
//      are implicitly preserved in the register stack while attempting to
//      convert the thread to a GUI thread. v0 and the gp must be preserved
//      explicitly.
//
// Validate sys call number
//

        ALTERNATE_ENTRY(KiSystemServiceRepeat)

        add       rpT1 = ThTrapFrame, rpThObj   // rpT1 -> ThTrapFrame
        add       rpT2 = ThServiceTable,rpThObj // rpT2 -> ThServiceTable
        shr.u     rT2 = rSavedV0, SERVICE_TABLE_SHIFT // isolate service descriptor offset
        ;;

        st8       [rpT1] = sp                   // set trap frame address
        ld8       rT3 = [rpT2]                  // -> service descriptor table
        and       rSdOffset = SERVICE_TABLE_MASK, rT2
        ;;

        cmp4.ne   pNoGui, pGui = SERVICE_TABLE_TEST, rSdOffset // check if GUI system service
        add       rpT1 = TeGdiBatchCount, teb
        mov       rSnumber = SERVICE_NUMBER_MASK
        ;;

 (pGui) lfetch    [rpT1]
        add       rT2 = rSdOffset, rT3          // rT2 -> service descriptor
        ;;
        add       rpSd = SdLimit, rT2           // rpSd -> table limit
        ;;

        ld4       rT1 = [rpSd], SdTableBaseGpOffset-SdLimit // rT1 = table limit
        ;;
        ld4       rScallGp = [rpSd], SdBase-SdTableBaseGpOffset
        and       rSnumber = rSnumber, rSavedV0 // rSnumber = service number
        ;;

        ld8       rT4 = [rpSd], SdNumber-SdBase // rT4 = table base
        ;;
        ld8       rArgTable =  [rpSd]           // -> arg table
        sxt4      rScallGp = rScallGp           // sign-extend offset
        ;;

        cmp4.ltu  pt1, pt0 = rSnumber, rT1      // pt1 = number < limit
        shladd    rpT3 = rSnumber, 3, rT4       // -> entry point address
        add       rScallGp = rT4, rScallGp      // compute syscall gp
        ;;

(pt1)   ld8       rpEntry = [rpT3]              // -> sys call routine plabel
        add       rArgEntry = rSnumber, rArgTable    // -> # arg bytes

(pt1)   cmp4.ne.unc pNoGui, pGui = SERVICE_TABLE_TEST, rSdOffset
(pNoGui) br.dptk   Knsc_NotGUI                  // Not a GUI thread
(pGui)   br.dpnt   Knsc_GUI                     // GUI thread
        ;;

//
// If rSdOffset == SERVICE_TABLE_TEST then service number is GUI service
//

        cmp.ne    pInvl, pVal = SERVICE_TABLE_TEST, rSdOffset
        mov       v0 = 1
(pVal)  br.call.sptk brp = PsConvertToGuiThread
        ;;

        cmp4.eq   pVal, p0 = 0, v0              // pVal = 1, if successful
        movl      v0 = STATUS_INVALID_SYSTEM_SERVICE  // invalid, if not successful
        ;;

        add         rpT1 = @gprel(KeServiceDescriptorTableShadow),gp  // Load address of table of shadow table
(pVal)  br.sptk   KiSystemServiceRepeat         // br if successful
(pInvl) br.spnt   Knsc_ErrorReturn              // br to KiSystemServiceExit if
        ;;                                      // system call out of range

//
// The conversion to a Gui thread failed. The correct return value is encoded
// in a byte table indexed by the service number that is at the end of the
// service address table. The encoding is as follows:
//
//     0 - return 0.
//    -1 - return -1.
//     1 - return status code.
//
        add         rpT1 = SERVICE_TABLE_TEST, rpT1 // Get addr of the GUI table
        ;;
        ld8         rpT2 = [rpT1], SdLimit - SdBase // Get the table base.
        ;;
        ld4         rT1 = [rpT1]                    // Get the limit.
        add         rpT2 = rpT2, rSnumber           // Index by the server number to the correct byte.
        ;;
        shladd      rpT2 = rT1, 3, rpT2             // Calculate the end of the table.
        cmp4.ltu    pt1, pt0 = rSnumber, rT1        // pt1 = number < limit
        ;;                                          // pt1 == 0 implies return an ntstatus.
(pt1)   ld1         rT1 = [rpT2]                    // Load the flag byte if within table
        ;;
        sxt1        rT2 = rT1                       // Sign extend the result
(pt1)   cmp.eq      pt0, pt1 = 1, rT1               // Test for 1 which means return STATUS_INVALID_SYSTEM_SERVICE
        ;;
(pt1)   mov         v0 = rT2                        // Use the flag value if needed.
        br.sptk     Knsc_ErrorReturn                // br to KiSystemServiceExit
        ;;

Knsc_GUI:

//
// If the system service is a GUI service and the GDI user batch queue is
// not empty, then call the appropriate service to flush the user batch.
//

        add       rpT1 = TeGdiBatchCount, teb   // get number of batched calls
        mov       rSavedV0 = rpSd               // save service descriptor
        ;;
        ld4.s     rT1 = [rpT1]
        add       rpT3 = @gprel(KeGdiFlushUserBatch), gp
        ;;

        cmp4.ne   pGui = rT1, zero              // skip if no calls  
        tnat.nz   pNoGui = rT1                  // pGui will be zero if rT1 is Nat
        ;;
(pGui)  ld8       rpT1 = [rpT3]                 // get KeGdiFlushUserBatch()
        movl      rpT2 = Knsc_GUI_Return
        ;;

(pGui)  ld8       rT1 = [rpT1], PlGlobalPointer-PlEntryPoint // get entry point
        mov       brp = rpT2
(pNoGui)br.call.spnt  bt0=KiTestGdiBatchCount   // This will return to Knsc_GUI_Return
        ;;

(pGui)  ld8       gp = [rpT1]                   // set global pointer
(pGui)  mov       bt0 = rT1
(pGui)  br.call.sptk brp = bt0                  // call to KeGdiFlushUserBatch
        ;;

Knsc_GUI_Return:
#if DBG
        mov       rpSd = rSavedV0               // restore service descriptor
        ;;
#endif

//
// Check for Nat'ed input argument register and
// Copy in-memory arguments from caller stack to kernel stack
//

Knsc_NotGUI:

#if DBG // checked build code

        add       rpT1 = SdCount-SdNumber, rpSd // rpT1 -> count table address
        ;;
        ld8       rpT2 = [rpT1]                 // service count table address
        ;;

        cmp.ne    pt0 = rpT2, zero              // if zero, no table defined
        shladd    rpT3 = rSnumber, 2, rpT2      // compute service count address
        ;;

(pt0)   ld4       rT1 = [rpT3]                  // increment count
        ;;
(pt0)   add       rT1 = 1, rT1
        ;;
(pt0)   st4       [rpT3] = rT1                  // store result

#endif // DBG

        tbit.z    pt0, pt1 = rpEntry, 0
        extr.u    rArgNum = rpEntry, 1, 3       // extract # of arguments
        dep       rpEntry = 0, rpEntry, 0, 4    // clear least significant 4 bit
        ;;

 (pt1)  ld1.nt1   rArgBytes = [rArgEntry]       // get # arg bytes
        movl      v0 = STATUS_INVALID_PARAMETER_1
        ;;
        cmp.ne    pNatedArg = zero, zero        // assume no Nat'ed argument
 (pt1)  shr       rArgNum = rArgBytes, 2
        ;;


        dep       rPFS = 0, rUserPFS, 62, 2
        add       v0 = rCount, v0               // set return status
(pt1)   add       rArgNum = 7, rArgNum          // number of in arguments
        ;;
        cmp.geu   pNoCopy, pCopy = 8, rArgNum   // any in-memory arguments ?
 (pt1)  shl       rArgBytes = rArgNum, 3        // x2 since args are 8 bytes each, not 4
        ;;

(pNoCopy) cmp.gt  pNatedArg = rArgNum, rCount   // any Nat'ed argument ?
  (pCopy) cmp.gt  pNatedArg = 8, rCount
  (pCopy) add     rArgBytes = -64, rArgBytes    // size of in-memory arguments
        ;;

(pNatedArg) br.spnt Knsc_ErrorReturn            // exit if Nat'ed arg found
(pNoCopy) br.sptk KiSystemServiceEndAddress     // skip copy if no memory args
        ;;

//
// Get the caller's sp. If caller was user mode, validate the stack pointer
// ar.unat contains Nat for previous sp (in TrIntSp)
//

(pUser) tnat.nz.unc pt1, pt2 = rUserSp              // test user sp for Nat
(pUser) movl      rpT2 = MI_USER_PROBE_ADDRESS  // User sp limit
        ;;

(pt2)   cmp.geu   pt1 = rUserSp, rpT2               // user sp >= PROBE ADDRESS ?
        mov       rpT1 = rUserSp                    // previous sp
        ;;

(pt1)   add       rpT1 = -STACK_SCRATCH_AREA,rpT2 // set out of range (includes Nat case)
        ;;
        add       out1 = STACK_SCRATCH_AREA, rpT1 // adjust for scratch area
        add       out0 = STACK_SCRATCH_AREA, sp // adjust for scratch area
        ;;

        ALTERNATE_ENTRY(KiSystemServiceStartAddress)

//
// Call out to C-code so the exception handling works corrrectly.  
// The byte count is in out3 which is rArgBytes.
//
        br.call.sptk  brp=KeCopySafe
        ;;
        dep       rPFS = 0, rUserPFS, 62, 2       // rPFS is a temp, recalculate it
        cmp4.ne   pt2 = STATUS_SUCCESS, r8        // See if the copy worked.
(pt2)   br.spnt   Knsc_ErrorReturn               
        ;;

        ALTERNATE_ENTRY(KiSystemServiceEndAddress)


        mov       gp = rScallGp
        mov       bt0 = rpEntry
        mov       rSp = rUserSp
        ;;

        //
        // N.B. t0 is reserved to pass trap frame address to NtContinue()
        //

        alloc     rT2 = 0,0,8,0                 // output regs are ready
        mov     ar.pfs =  rPFS
        movl    rT1 = KiSystemServiceExit
        ;;

        mov     t0 = sp                       // for NtContinue()
        mov     brp = rT1        
        br.sptk   bt0                        // call routine(args)
        ;;

        ALTERNATE_ENTRY(KiSystemServiceExit)

        //
        // make the current bsp the same as the saved BSP in the trap frame
        //

        cover
        ;;

//
// At this point:
//      ar.unat contains Nat for previous sp (ar.unat is preserved register)
//      sp -> trap frame
//
// Returning from "call": no need to restore volatile state
// *** TBD *** : zero volatile state for security? PPC does zero, mips does not.
//
//
// Update PbSystemCalls
//
//
// Restore thread previous mode and trap frame address from the trap frame
//

        add       rpT2 = TrStIPSR, sp
        movl      rpT1 = KiPcr + PcPrcb         // rpT1 -> Prcb
        ;;

        ld8       rpT3 = [rpT1], PcCurrentThread-PcPrcb
        lfetch    [rpT2], TrTrapFrame-TrStIPSR
        ;;

        ld8       rThread = [rpT1]              // rpT1 -> current thread
        ld8       rT2 = [rpT2], TrPreviousMode-TrTrapFrame
        add       rpT3 = PbSystemCalls, rpT3    // pointer to sys call counter
        ;;

        FAST_DISABLE_INTERRUPTS
        ;;
        ld4       rT1 = [rpT3]                  // rT1.4 = counter value

        ld4       rT3 = [rpT2], TrRsRSC-TrPreviousMode
        add       rpT4 = ThTrapFrame, rThread   // -> thread trap frame
        add       rpT1 = ThApcState+AsUserApcPending, rThread
        ;;

(pKrnl) ld8       rRscE = [rpT2]                // load user RSC
(pUser) ld1       rT4 = [rpT1], ThAlerted-ThApcState-AsUserApcPending
        add       rT1 = 1, rT1                  // increment
        ;;

        st8       [rpT4] = rT2, ThPreviousMode-ThTrapFrame
        st4       [rpT3] = rT1                  // store
        ;;

        st1       [rpT4] = rT3                  // restore prevmode in thread
        mov       t0 = sp                       // set t0 to trap frame
(pKrnl) br.spnt   Knsc_CommonExit               // br if returning to kernel
        ;;

        st1       [rpT1] = zero
        cmp4.eq   pt0 = zero, rT4
(pt0)   br.sptk   KiUserServiceExit
        ;;

        alloc     rT1 = ar.pfs, 0, 1, 2, 0
        add       loc0 = TrIntV0, sp
        add       rpT1 = TrIntTeb, sp

//
// v0 is saved in the trap frame so the return status can be restored
// by NtContinue after the user APC has been dispatched.
//

        ssm       1 << PSR_I             // enable interrupts
        mov       rT3 = APC_LEVEL
        ;;
        SET_IRQL  (rT3)
        ;;

        st8.nta   [loc0] = v0            // save return status in trap frame
        movl      gp = _gp               // restore to kernel gp value

        st8.nta   [rpT1] = teb
        mov       out1 = sp
        br.call.sptk brp = KiApcInterrupt
        ;;

        rsm       1 << PSR_I             // disable interrupt
        ld8.nta   v0 = [loc0]            // restore system call return status
        SET_IRQL (zero)

        HANDLER_EXIT(KiNormalSystemCall)

//
// KiServiceExit is carefully constructed as a continuation of
// KiNormalSystemCall.  From now on, t0 must be preserved because it is
// used to hold the trap frame address. v0 must be preserved because it
// is holding the return status.
//

        HANDLER_ENTRY_EX(KiServiceExit, KiSystemServiceHandler)

        .prologue
        .unwabi   @nt,  EXCEPTION_FRAME

        .vframe   t0
        mov       t0 = sp
        ;;

        ALTERNATE_ENTRY(KiUserServiceExit)

(pUser) add       rpT3 = TrStIPSR, t0
        ;;
(pUser) ld8       rpT3 = [rpT3]
        invala
        ;;

(pUser) tbit.nz.unc pUDbg = rpT3, PSR_DB  // if user psr.db set, load user DRs
(pUDbg) br.call.spnt brp = KiLoadUserDebugRegisters
        ;;

        add       rpT1 = TrRsRSC, t0                   // -> user RSC
        add       rpT2 = TrRsBSP, t0              // -> user BSP Store
        ;;

        PROLOGUE_END

        ld8       rRscE = [rpT1], TrRsRNAT-TrRsRSC     // load user RSC
        ld8       rBSP = [rpT2]
        mov       rRscD = RSC_KERNEL_DISABLED
        ;;

//
// Switch to user BSP -- put in load intensive mode to overlap RS restore
// with volatile state restore.
//

        ld8       rRNAT = [rpT1]                       // user RNAT

        extr.u    rRscDelta = rRscE, RSC_MBZ1, RSC_LOADRS_LEN
        dep       rRscE = r0, rRscE, RSC_MBZ1, RSC_LOADRS_LEN
        ;;

        alloc     rT2 = 0,0,0,0
        dep       rRscD = rRscDelta, rRscD, RSC_LOADRS, RSC_LOADRS_LEN
        sub       rBSPStore = rBSP, rRscDelta
        ;;

        mov       ar.rsc = rRscD                       // turn off RSE
        ;;
        loadrs                                         // pull in user regs
        ;;

        mov       ar.bspstore = rBSPStore              // restore user BSP
        ;;
        mov       ar.rnat = rRNAT                      // restore user RNAT

Knsc_CommonExit:

        add       rpT1 = TrIntNats, t0
        movl      rpT2 = KiPcr+PcCurrentThread

        add       rpT4 = TrStIPSR, t0
        add       rpT3 = TrRsPFS, t0
//        mov       rT0 = (1 << PSR_I) | (1 << PSR_MFH)
        ;;

        ld8       rIntNats = [rpT1], TrIntSp-TrIntNats
.pred.rel "mutex",pUser,pKrnl
(pUser) ld8       rT1 = [rpT2], PcHighFpOwner-PcCurrentThread
(pKrnl) add       rpT2 = PcKernelDebugActive-PcCurrentThread, rpT2
        ;;

        ld8       rIPSR = [rpT4]
(pUser) ld8       rT2 = [rpT2]
(pKrnl) mov       rPreviousMode = KernelMode
        ;;

        ld8       rPFS = [rpT3], TrStIIP-TrRsPFS  // get previous PFS
(pKrnl) ld1       rT2 = [rpT2]
(pUser) mov       rPreviousMode = UserMode
        ;;

        mov       ar.rsc = rRscE              // restore RSC
        ld8       rIIP = [rpT3], TrStFPSR-TrStIIP
(pUser) cmp.ne.unc pt0 = rT1, rT2
        ;;

        mov       ar.unat = rIntNats
        ld8       rT3 = [rpT3], TrStIFS-TrStFPSR          // load fpsr
 (pt0)  dep       rIPSR = 1, rIPSR, PSR_DFH, 1
        ;;

        ld8.fill  rSp = [rpT1], TrPreds-TrIntSp // fill sp
        ld8       rIFS = [rpT3]               // load IFS
// (pUser) dep       rIPSR = 0, rIPSR, PSR_TB, 1 // ensure psr.tb is clear
        ;;

(pKrnl) cmp.ne.unc pKDbg, pt2 = rT2, r0       // hardware debug active?
        dep       rIPSR = 0, rIPSR, PSR_MFH, 1  // psr.mfh
        ;;

        ld8       rPreds = [rpT1], TrApUNAT-TrPreds
 (pt2)  dep       rIPSR = 0, rIPSR, PSR_DB, 1 // disable db in kernel
(pKDbg) dep       rIPSR = 1, rIPSR, PSR_DB, 1 // enable db in kernel
        ;;

        ld8       rUNAT = [rpT1], TrApDCR-TrApUNAT
        mov       ar.pfs = rPFS               // restore PFS
        ;;

        ld8       rT4 = [rpT1]                // load dcr
//        mov       psr.l = rIPSR             // restore psr settings
        mov       pr = rPreds                 // restore preds
        ;;

        mov       cr.dcr = rT4                // restore DCR
        rsm       1 << PSR_IC                 // disable PSR.ic
        mov       ar.unat = rUNAT             // restore UNAT
        
//        mov       brp = rIIP                  // restore brp
        ;;

        srlz.d                                // must serialize
        mov       ar.fpsr = rT3               // restore FPSR
        ;;

//
// The system return case must be handle separately from the user return
// case, so we can determine which stack we are currently using in case
// a trap is take before we can return.
//

        mov       sp = rSp


//                                                                          
// Restore status registers                                                 
//                                                                          
        bsw.0
        ;;
                                                                            
        mov         cr.ipsr = rIPSR        // restore previous IPSR    
        mov         cr.ifs = rIFS         // restore previous IFS     
        mov         cr.iip = rIIP         // restore previous IIP     
        ;;                                                                  
                                                                            
//                                                                          
// Resume at point of interruption (rfi must be at end of instruction group)
//                                                                          

        rfi                                                                 
        ;;

Knsc_ErrorReturn:

        //
        // N.B. t0 is reserved to pass trap frame address to NtContinue()
        //

        add     rPFS = TrRsPFS, sp
        ;;
        ld8     rPFS = [rPFS]
        ;;
        dep       rPFS = 0, rPFS, 62, 2
        ;;

        mov     ar.pfs =  rPFS
        movl    rT1 = KiSystemServiceExit
        ;;

        mov     brp = rT1        
        br.ret.sptk   brp
        ;;

        HANDLER_EXIT(KiServiceExit)

        .sdata
KiSystemServiceExitOffset::
        data4  @secrel(KiSystemServiceExit)
KiSystemServiceStartOffset::
        data4  @secrel(KiSystemServiceStartAddress)
KiSystemServiceEndOffset::
        data4  @secrel(KiSystemServiceEndAddress)


        .text
//++
//--------------------------------------------------------------------
// Routine:
//
//       KiGenericExceptionHandler
//
// Description:
//
//       First level handler for heavyweight exceptions.
//
// On entry:
//
//       ic off
//       interrupts disabled
//       current frame covered
//
// Process:
//
// Notes:
//
//       PCR page mapped with TR
//--------------------------------------------------------------------

        HANDLER_ENTRY(KiGenericExceptionHandler)

        .prologue
        .unwabi     @nt,  EXCEPTION_FRAME

        ALLOCATE_TRAP_FRAME

//
// sp points to trap frame
//
// Save exception handler routine in kernel register
//

        mov       rkHandler = rHHandler
        movl      rTH3 = KiPcr+PcSavedIFA
        ;;

        st8       [rTH3] = rHIFA

//
// Save interruption state in trap frame and switch to user bank registers
// and switch to kernel backing store.
//

        SAVE_INTERRUPTION_STATE(Kgeh_SaveTrapFrame)

//
// Now running with user banked registers and on kernel stack.
//
// Can now take TLB faults
//
// sp -> trap frame
//

        br.call.sptk brp = KiSaveTrapFrame
        ;;

//
// Register aliases
//

        rpT1        = t0
        rpT2        = t1
        rpT3        = t2
        rT1         = t3
        rT2         = t4
        rT3         = t5
        rPreviousMode = t6                      // previous mode
        rT4         = t7


        mov       rT1 = rkHandler               // restore address of interruption routine
        movl      rpT1 = KiPcr+PcSavedIIM
        ;;

        ld8       rT2 = [rpT1], PcSavedIFA-PcSavedIIM  // load saved IIM
        add       rpT2 = TrEOFMarker, sp
        add       rpT3 = TrStIIM, sp
        ;;

        ld8       rT4 = [rpT1]                  // load saved IFA
        movl      rT3 = KTRAP_FRAME_EOF | EXCEPTION_FRAME
        ;;

        st8       [rpT2] = rT3, TrHandler-TrEOFMarker
        st8       [rpT3] = rT2, TrStIFA-TrStIIM // save IIM in trap frame
        mov       bt0 = rT1                     // set destination address
        ;;

        .regstk   0, 1, 2, 0                    // must match KiExceptionExit
        alloc     out1 = 0,1,2,0
        st8       [rpT3] = rT4                  // save IFA in trap frame

        PROLOGUE_END

//
// Dispatch the exception via call to address in rkHandler
//
.pred.rel "mutex",pUser,pKrnl
        add       rpT1 = TrPreviousMode, sp     // -> previous mode
(pUser) mov       rPreviousMode = UserMode      // set previous mode
(pKrnl) mov       rPreviousMode = KernelMode
        ;;

        st4       [rpT1] = rPreviousMode        // save in trap frame
(pKDbg) br.call.spnt brp = KiLoadKernelDebugRegisters
        ;;

        FAST_ENABLE_INTERRUPTS                  // enable interrupt
        mov       out0 = sp                     // trap frame pointer
        br.call.sptk brp = bt0                  // call handler(tf) (C code)
        ;;

.pred.rel "mutex",pUser,pKrnl
        cmp.ne    pt0, pt1 = v0, zero
(pUser) mov       out1 = UserMode
(pKrnl) mov       out1 = KernelMode

        //
        // does not return
        //

        mov       out0 = sp
(pt1)   br.cond.sptk KiAlternateExit
(pt0)   br.call.spnt brp = KiExceptionDispatch
        ;;

//
// Interrupts need to be disable be for mess up the stack such that
// the unwind code does not work.
//

        FAST_DISABLE_INTERRUPTS
        ;;
        ALTERNATE_ENTRY(KiExceptionExit)

//++
//
// Routine Description:
//
//     This routine is called to exit from an exception.
//
//     N.B. This transfer of control occurs from:
//
//         1. fall-through from above
//         2. exit from continue system service
//         3. exit from raise exception system service
//         4. exit into user mode from thread startup
//
// Arguments:
//
//     loc0 - pointer to trap frame
//     sp - pointer to high preserved float save area + STACK_SCRATCH_AREA
//
// Return Value:
//
//      Does not return.
//
//--

//
// upon entry of this block, s0 and s1 must be set to the address of
// the trap and the exception frames respectively.
//
// preserved state is restored here because they may have been modified
// by SetContext
//


        LEAF_SETUP(0, 1, 2, 0)                        // must be in sync with
                                                  // KiGenericExceptionHandler
        mov       loc0 = s0                       // -> trap frame
        mov       out0 = s1                       // -> exception frame
        ;;

        br.call.sptk brp = KiRestoreExceptionFrame
        ;;

        mov       sp = loc0                       // deallocate exception
                                                  // frame by restoring sp

        ALTERNATE_ENTRY(KiAlternateExit)

//
// sp -> trap frame addres
//
// Interrupts disabled from here to rfi
//

        FAST_DISABLE_INTERRUPTS
        ;;

        RETURN_FROM_INTERRUPTION(Ked)

        HANDLER_EXIT(KiGenericExceptionHandler)


//--------------------------------------------------------------------
// Routine:
//
//       KiExternalInterruptHandler
//
// Description:
//
//       First level external interrupt handler. Dispatch highest priority
//       pending interrupt.
//
// On entry:
//
//       ic off
//       interrupts disabled
//       current frame covered
//
// Process:
//--------------------------------------------------------------------

        HANDLER_ENTRY(KiExternalInterruptHandler)

//
// Now running with user banked registers and on kernel backing store.
// N.B. sp -> trap frame
//
// Can now take TLB faults
//

        .prologue
        .unwabi     @nt,  INTERRUPT_FRAME
        .regstk     0, 4, 2, 0
        alloc       loc0 = 0, 4, 2, 0

//
// Register aliases
//

        rVector     = loc0
        rSaveGP     = loc1
        rpSaveIrql  = loc2                      // -> old irql in trap frame
        rOldIrql    = loc3

        rpT1        = t0
        rpT2        = t1
        rpT3        = t2
        rT1         = t3
        rT2         = t4
        rT3         = t5
        rPreviousMode = t6                      // previous mode
        rNewIrql    = t7

        pEOI        = pt1

//
// Save kernel gp
//

        mov         rSaveGP = gp
        ;;

//
// Get the vector number
//
        mov         rVector = cr.ivr // for A0 2173 workaround
        mov         rOldIrql = cr.tpr           // get actual tpr value
        br.call.sptk brp = KiSaveTrapFrame
        ;;

#if defined(INTERRUPTION_LOGGING)

         // For Conditional Interrupt Logging
         mov       t2 = gp
         ;;
         movl      gp = _gp
         ;;
         add       t0 = @gprel(KiVectorLogMask), gp
         ;;
         ld8       t1 = [t0]
         mov       gp = t2
         ;;
         tbit.z   pt1 = t1, ExternalInterruptBit
  (pt1)  br.cond.sptk   EndOfLogging2


        movl        t0 = KiPcr+PcInterruptionCount
        ;;
        ld4.nt1     t0 = [t0]
        mov         t1 = MAX_NUMBER_OF_IHISTORY_RECORDS - 1
        ;;
        add         t0 = -1, t0
        movl        t2 = KiPcr+0x1000
        ;;
        and         t1 = t0, t1
        ;;
        shl         t1 = t1, 5
        ;;
        add         t0 = t2, t1
        ;;
        add         t0 = 24, t0
        ;;
        st8.nta     [t0] = rVector     // save ivr in the Extra0 field

// For Conditional Interrupt Logging
EndOfLogging2:

#endif // defined(INTERRUPTION_LOGGING)

//
// Exit if spurious interrupt vector
//

        cmp.eq    pt0, pt1 = 0xF, rVector
        extr.u    rOldIrql = rOldIrql, TPR_MIC, TPR_MIC_LEN
(pt0)   br.spnt   Keih_Exit
        ;;

//
// sp -> trap frame
//

        add       rpSaveIrql = TrEOFMarker, sp
        movl      rT3 = KTRAP_FRAME_EOF | INTERRUPT_FRAME
        ;;

        st8       [rpSaveIrql] = rT3, TrPreviousMode - TrEOFMarker
.pred.rel "mutex",pUser,pKrnl
(pUser) mov       rPreviousMode = UserMode             // set previous mode
(pKrnl) mov       rPreviousMode = KernelMode
        ;;

        st4       [rpSaveIrql] = rPreviousMode, TrOldIrql-TrPreviousMode
        movl      rpT3 = KiPcr+PcCurrentIrql
        ;;

        st4       [rpSaveIrql] = rOldIrql       // save irql in trap frame
        st1       [rpT3] = rOldIrql             // sanitize the shadow copy
(pKDbg) br.call.spnt brp = KiLoadKernelDebugRegisters
        ;;

        PROLOGUE_END

Keih_InterruptLoop:
//
// Dispatch the interrupt: first raise the IRQL to the level of the new
// interrupt and enable interrupts.
//

        GET_IRQL_FOR_VECTOR(p0, rNewIrql, rVector)
        movl      rpT3 = KiPcr+PcInterruptRoutine // -> interrupt routine table
        ;;

        shladd    rpT3 = rVector, INT_ROUTINES_SHIFT, rpT3    // base + offset
        SET_IRQL  (rNewIrql)                    // raise to new level
        movl      rpT1 = KiPcr + PcPrcb         // pointer to prcb
        ;;

        ld8       out0 = [rpT3]                 // out0 -> interrupt dispatcher
        ld8       rpT1 = [rpT1]
        mov       out1 = sp                     // out1 -> trap frame
        ;;

        FAST_ENABLE_INTERRUPTS
        add       rpT1 = PbInterruptCount, rpT1 // -> interrupt counter
        ;;

        ld4.nta   rT1 = [rpT1]                  // counter value
        ld8.nta   rT2 = [out0], PlGlobalPointer-PlEntryPoint  // get entry point
        ;;
        add       rT1 = 1, rT1                  // increment
        ;;

//
// Call the interrupt dispatch routine via a function pointer
//

        st4.nta   [rpT1] = rT1                  // store, ignore overflow
        ;;

        ld8.nta   gp = [out0], PlEntryPoint-PlGlobalPointer
        mov       bt0 = rT2
        br.call.sptk brp = bt0                  // call ISR
        ;;

        ld4       rOldIrql = [rpSaveIrql]
        mov       gp = rSaveGP
        END_OF_INTERRUPT                        // end of interrupt processing
        IO_END_OF_INTERRUPT(rVector,rT1,rT2,pEOI)
        ;;
        srlz.d

//
// Disable interrupts and restore IRQL level
//

        FAST_DISABLE_INTERRUPTS

        cmp.gt     pt0 = APC_LEVEL, rOldIrql
        mov        t0 = APC_LEVEL
        ;;
(pt0)   br.spnt    ke_call_apc

ke_call_apc_resume:

        LOWER_IRQL (rOldIrql)

//
// Get the next vector number
//

        mov         rVector = cr.ivr // for A0 2173 workaround
        ;;
//
// Loop if more interrupts pending (spurious vector == 0xF)
//

        cmp.ne      pt0 = 0xF, rVector
        ;;
(pt0)   br.spnt     Keih_InterruptLoop
        br.sptk     Keih_Exit
        ;;

ke_call_apc:
        LOWER_IRQL (t0)

ke_call_apc1:
        movl         t0 = KiPcr+PcApcInterrupt
        ;;
        ld1          t1 = [t0]
        st1          [t0] = r0
        ;;
        cmp.eq       pt0 = r0, t1
        ;;
(pt0)   br.sptk      ke_call_apc_resume
        FAST_ENABLE_INTERRUPTS                                  
        mov          out1 = sp
        br.call.sptk brp = KiApcInterrupt
        FAST_DISABLE_INTERRUPTS
        br.sptk      ke_call_apc1

Keih_Exit:

        RETURN_FROM_INTERRUPTION(Keih)

        HANDLER_EXIT(KiExternalInterruptHandler)

//--------------------------------------------------------------------
// Routine:
//
//       KiPanicHandler
//
// Description:
//
//       Handler for panic. Call the bug check routine. A place
//       holder for now.
//
// On entry:
//
//       running on kernel memory stack and kernel backing store
//       sp: top of stack -- points to trap frame
//       interrupts enabled
//
//       IIP: address of bundle causing fault
//
//       IPSR: copy of PSR at time of interruption
//
// Output:
//
//       sp: top of stack -- points to trap frame
//
// Return value:
//
//       none
//
// Notes:
//
//       If ISR code out of bounds, this code will inovke the panic handler
//
//--------------------------------------------------------------------

        HANDLER_ENTRY(KiPanicHandler)

        .prologue
        .unwabi     @nt,  EXCEPTION_FRAME

        mov       rHpT1 = KERNEL_STACK_SIZE
        movl      rTH1 = KiPcr+PcPanicStack
        ;;

        ld8       sp = [rTH1], PcInitialStack-PcPanicStack
        movl      rTH2 = KiPcr+PcSystemReserved
        ;;

        st4       [rTH2] = rPanicCode
        st8       [rTH1] = sp, PcStackLimit-PcInitialStack
        sub       rTH2 = sp, rHpT1
        ;;

        st8       [rTH1] = rTH2, PcInitialBStore-PcStackLimit
        mov       rHpT1 = KERNEL_BSTORE_SIZE
        ;;

        st8       [rTH1] = sp, PcBStoreLimit-PcInitialBStore
        add       rTH2 = rHpT1, sp
        add       sp = -TrapFrameLength, sp
        ;;

        st8       [rTH1] = rTH2

        SAVE_INTERRUPTION_STATE(Kph_SaveTrapFrame)

        //
        // switch to kernel back
        //
        bsw.0
        ;;

        rpRNAT    = h16
        rpBSPStore= h17
        rBSPStore = h18
        rKBSPStore= h19
        rRNAT     = h20
        rKrnlFPSR = h21

        mov       ar.rsc = r0                  // put RSE in lazy mode
        movl      rKBSPStore = KiPcr+PcInitialBStore
        ;;

        mov       rBSPStore = ar.bspstore
        mov       rRNAT = ar.rnat
        ;;

        ld8       rKBSPStore = [rKBSPStore]
        add       rpRNAT = TrRsRNAT, sp
        add       rpBSPStore = TrRsBSPSTORE, sp
        ;;

        st8       [rpRNAT] = rRNAT
        st8       [rpBSPStore] = rBSPStore
        dep       rKBSPStore = rBSPStore, rKBSPStore, 0, 9
        ;;

        mov       ar.bspstore = rKBSPStore
        mov       ar.rsc = RSC_KERNEL
        ;;

        //
        // switch to user bank
        //
        bsw.1
        ;;
        alloc     out0 = ar.pfs, 0, 0, 5, 0
        ;;

        PROLOGUE_END

        br.call.sptk brp = KiSaveTrapFrame
        ;;

        movl      out0 = KiPcr+PcSystemReserved
        ;;

        ld4       out0 = [out0]                // 1st argument: panic code
        mov       out1 = sp                    // 2nd argument: trap frame
        br.call.sptk.many brp = KeBugCheckEx
        ;;

        nop.m     0
        nop.m     0
        nop.i     0
        ;;

        HANDLER_EXIT(KiPanicHandler)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      KiSaveTrapFrame(PKTRAP_FRAME)
//
// Description:
//
//       Save volatile application state in trap frame.
//       Note: sp, brp, UNAT, RSC, predicates, BSP, BSP Store,
//       PFS, DCR, and FPSR saved elsewhere.
//
// Input:
//
//       sp: points to trap frame
//       ar.unat: contains the Nats of sp, gp, teb, which have already
//                been spilled into the trap frame.
//
// Output:
//
//       None
//
// Return value:
//
//       none
//
//--------------------------------------------------------------------

        LEAF_ENTRY(KiSaveTrapFrame)

        .regstk    0, 3, 0, 0

//
// Local register aliases
//

        rpTF1     = loc0
        rpTF2     = loc1
        rL1       = t0
        rL2       = t1
        rL3       = t2
        rL4       = t3
        rL5       = t4


//
// (ar.unat unchanged from point of save)
// Spill temporary (volatile) integer registers
//

        alloc       loc2 = 0,3,0,0              // don't destroy static register
        add         rpTF1 = TrIntT0, sp         // -> t0 save area
        add         rpTF2 = TrIntT1, sp         // -> t1 save area
        ;;

        .mem.offset 0,0
        st8.spill [rpTF1] = t0, TrIntT2-TrIntT0 // spill t0 - t22
        .mem.offset 8,0
        st8.spill [rpTF2] = t1, TrIntT3-TrIntT1
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t2, TrIntT4-TrIntT2
        .mem.offset 8,0
        st8.spill [rpTF2] = t3, TrIntT5-TrIntT3
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t4, TrIntT6-TrIntT4
        .mem.offset 8,0
        st8.spill [rpTF2] = t5, TrIntT7-TrIntT5
        mov       rL2 = bt0
        ;;

        mov       rL1 = cr.dcr
        mov       rL4 = ar.ccv
        mov       rL3 = bt1
        ;;

        .mem.offset 0,0
        st8.spill [rpTF1] = t6, TrIntT8-TrIntT6
        .mem.offset 8,0
        st8.spill [rpTF2] = t7, TrIntT9-TrIntT7
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t8, TrIntT10-TrIntT8
        .mem.offset 8,0
        st8.spill [rpTF2] = t9, TrIntT11-TrIntT9
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t10, TrIntT12-TrIntT10
        .mem.offset 8,0
        st8.spill [rpTF2] = t11, TrIntT13-TrIntT11
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t12, TrIntT14-TrIntT12
        .mem.offset 8,0
        st8.spill [rpTF2] = t13, TrIntT15-TrIntT13
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t14, TrIntT16-TrIntT14
        .mem.offset 8,0
        st8.spill [rpTF2] = t15, TrIntT17-TrIntT15
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t16, TrIntT18-TrIntT16
        .mem.offset 8,0
        st8.spill [rpTF2] = t17, TrIntT19-TrIntT17
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t18, TrIntT20-TrIntT18
        .mem.offset 8,0
        st8.spill [rpTF2] = t19, TrIntT21-TrIntT19
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t20, TrIntT22-TrIntT20
        .mem.offset 8,0
        st8.spill [rpTF2] = t21, TrIntV0-TrIntT21
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t22, TrBrT0-TrIntT22
        .mem.offset 8,0
        st8.spill [rpTF2] = v0, TrBrT1-TrIntV0       // spill old V0
        ;;

        st8       [rpTF1] = rL2, TrApCCV-TrBrT0      // save old bt0 - bt1
        st8       [rpTF2] = rL3
        ;;

        mov       rL5 = ar.unat
        st8       [rpTF1] = rL4, TrApDCR-TrApCCV     // save ar.ccv
        ;;

        st8       [rpTF1] = rL1                      // save cr.dcr
        add       rpTF1 = TrFltT0, sp                // point to FltT0
        add       rpTF2 = TrFltT1, sp                // point to FltT1
        ;;

//
// Spill temporary (volatile) floating point registers
//

        stf.spill [rpTF1] = ft0, TrFltT2-TrFltT0     // spill float tmp 0 - 9
        stf.spill [rpTF2] = ft1, TrFltT3-TrFltT1
        ;;
        stf.spill [rpTF1] = ft2, TrFltT4-TrFltT2
        stf.spill [rpTF2] = ft3, TrFltT5-TrFltT3
        ;;
        stf.spill [rpTF1] = ft4, TrFltT6-TrFltT4
        stf.spill [rpTF2] = ft5, TrFltT7-TrFltT5
        ;;
        stf.spill [rpTF1] = ft6, TrFltT8-TrFltT6
        stf.spill [rpTF2] = ft7, TrFltT9-TrFltT7
        add       t20 = TrIntNats, sp
        ;;
        stf.spill [rpTF1] = ft8
        stf.spill [rpTF2] = ft9
        ;;

        st8       [t20] = rL5                        // save volatile iNats
        LEAF_RETURN
        ;;

        LEAF_EXIT(KiSaveTrapFrame)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      KiRestoreTrapFrame(PKTRAP_FRAME)
//
// Description:
//
//       Restore volatile application state from trap frame. Restore DCR
//       Note: sp, brp, RSC, UNAT, predicates, BSP, BSP Store, PFS,
//       DCR and FPSR not restored here.
//
// Input:
//
//      sp: points to trap frame
//      RSE frame size is zero
//
// Output:
//
//      None
//
// Return value:
//
//       none
//
//--------------------------------------------------------------------

        LEAF_ENTRY(KiRestoreTrapFrame)

        LEAF_SETUP(0,2,0,0)

        rpTF1     = loc0
        rpTF2     = loc1

        mov       t21 = psr
        add       t12 = TrIntNats, sp
        add       rpTF2 = TrApCCV, sp
        ;;

        ld8       t0 = [t12], TrBrT0-TrIntNats
        ld8       t1 = [rpTF2], TrBrT1-TrApCCV
        add       rpTF1 = TrFltT0, sp
        ;;

        ld8       t2 = [t12], TrStFPSR-TrBrT0
        ld8       t3 = [rpTF2], TrApDCR-TrBrT1
        ;;

        ld8       t10 = [t12]
        ld8       t11 = [rpTF2], TrFltT1-TrApDCR
        ;;

        ldf.fill  ft0 = [rpTF1], TrFltT2-TrFltT0
        ldf.fill  ft1 = [rpTF2], TrFltT3-TrFltT1
        ;;

        mov       ar.unat = t0

        ldf.fill  ft2 = [rpTF1], TrFltT4-TrFltT2
        ldf.fill  ft3 = [rpTF2], TrFltT5-TrFltT3
        ;;

        ldf.fill  ft4 = [rpTF1], TrFltT6-TrFltT4
        ldf.fill  ft5 = [rpTF2], TrFltT7-TrFltT5
        ;;

        ldf.fill  ft6 = [rpTF1], TrFltT8-TrFltT6
        ldf.fill  ft7 = [rpTF2], TrFltT9-TrFltT7
        ;;

        ldf.fill  ft8 = [rpTF1], TrIntGp-TrFltT8
        ldf.fill  ft9 = [rpTF2], TrIntT0-TrFltT9
        ;;

        mov       ar.ccv = t1
        ld8.fill  gp = [rpTF1], TrIntT1-TrIntGp
        ;;

        ld8.fill  t0 = [rpTF2], TrIntT2-TrIntT0
        ld8.fill  t1 = [rpTF1], TrIntT3-TrIntT1
        mov       bt0 = t2
        ;;

        mov       cr.dcr = t11
        ld8.fill  t2 = [rpTF2], TrIntT4-TrIntT2
        mov       bt1 = t3
        ;;

        ld8.fill  t3 = [rpTF1], TrIntT5-TrIntT3
        tbit.z    pt1 = t21, PSR_MFL

        mov       ar.fpsr = t10
        ld8.fill  t4 = [rpTF2], TrIntT6-TrIntT4
        ;;

        ld8.fill  t5 = [rpTF1], TrIntT7-TrIntT5
        ld8.fill  t6 = [rpTF2], TrIntT8-TrIntT6
        ;;

        ld8.fill  t7 = [rpTF1], TrIntT9-TrIntT7
        ld8.fill  t8 = [rpTF2], TrIntT10-TrIntT8
        ;;

        ld8.fill  t9 = [rpTF1], TrIntT11-TrIntT9
        ld8.fill  t10 = [rpTF2], TrIntT12-TrIntT10
        ;;

        ld8.fill  t11 = [rpTF1], TrIntT13-TrIntT11
        ld8.fill  t12 = [rpTF2], TrIntT14-TrIntT12
        ;;

        ld8.fill  t13 = [rpTF1], TrIntT15-TrIntT13
        ld8.fill  t14 = [rpTF2], TrIntT16-TrIntT14
        ;;

        ld8.fill  t15 = [rpTF1], TrIntT17-TrIntT15
        ld8.fill  t16 = [rpTF2], TrIntT18-TrIntT16
        ;;

        ld8.fill  t17 = [rpTF1], TrIntT19-TrIntT17
        ld8.fill  t18 = [rpTF2], TrIntT20-TrIntT18
        ;;

        ld8.fill  t19 = [rpTF1], TrIntT21-TrIntT19
        ld8.fill  t20 = [rpTF2], TrIntT22-TrIntT20
        ;;

        ld8.fill  t21 = [rpTF1], TrIntTeb-TrIntT21
        ld8.fill  t22 = [rpTF2], TrIntV0-TrIntT22
        ;;

        ld8.fill  teb = [rpTF1]
        ld8.fill  v0 = [rpTF2]
        br.ret.sptk.many brp
        ;;

        LEAF_EXIT(KiRestoreTrapFrame)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      KiLoadKernelDebugRegisters
//
// Description:
//
//      We maintain two debug register flags:
//         1. Thread DebugActive: Debug registers active for current thread
//         2. PCR KernelDebugActive: Debug registers active in kernel mode
//            (setup by kernel debugger)
//
//      On user -> kernel transitions there are four possibilities:
//
//               Thread        Kernel
//               DebugActive   DebugActive   Action
//
//      1.       0             0             None
//
//      2.       1             0             None (kernel PSR.db = 0 by default)
//
//      3.       0             1             Set PSR.db = 1 for kernel
//
//      4.       1             1             Set PSR.db = 1 for kernel and
//                                           load kernel debug registers
//
//      Note we never save the user debug registers:
//      the user cannot change the DRs so the values in the DR save area are
//      always up-to-date (set by SetContext).
//
// Input:
//
//       None (Previous mode is USER)
//
// Output:
//
//       None
//
// Return value:
//
//       none
//
//--------------------------------------------------------------------

        NESTED_ENTRY(KiLoadKernelDebugRegisters)
        PROLOGUE_BEGIN

        movl        t10 = KiPcr+PcPrcb
        ;;

        ld8         t10 = [t10]           // load prcb address
        cmp.eq      pt3, pt2 = r0, r0
        ;;

        add         t11 = PbProcessorState+KpsSpecialRegisters+KsKernelDbI0,t10
        add         t12 = PbProcessorState+KpsSpecialRegisters+KsKernelDbI1,t10
        add         t13 = PbProcessorState+KpsSpecialRegisters+KsKernelDbD0,t10
        add         t14 = PbProcessorState+KpsSpecialRegisters+KsKernelDbD1,t10
        br          Krdr_Common
        ;;

        ALTERNATE_ENTRY(KiLoadUserDebugRegisters)

//
// Restore debug registers, if debug active
//

        cmp.ne      pt3, pt2 = r0, r0
        movl        t10 = KiPcr+PcCurrentThread
        ;;

        ld8         t10 = [t10]             // get current thread pointer
        ;;
        add         t10 = ThStackBase, t10
        ;;

        ld8.nta     t10 = [t10]             // get stack base
        ;;
        add         t11 = -ThreadStateSaveAreaLength+TsDebugRegisters+DrDbI0,t10
        add         t12 = -ThreadStateSaveAreaLength+TsDebugRegisters+DrDbI1,t10

        add         t13 = -ThreadStateSaveAreaLength+TsDebugRegisters+DrDbD0,t10
        add         t14 = -ThreadStateSaveAreaLength+TsDebugRegisters+DrDbD1,t10
        ;;


Krdr_Common:

        .regstk     0, 2, 2, 0
        .save       ar.pfs, savedpfs
        alloc       savedpfs = ar.pfs, 0, 2, 2, 0
        .save       b0, savedbrp
        mov         savedbrp = brp

        .save       ar.lc, t22
        mov         t22 = ar.lc             // save ar.lc
        mov         t7 = 0
        mov         t8 = 1

        PROLOGUE_END

        mov         ar.lc = 1               // 2 pairs of debug registers
        ;;

Krdr_Loop:

        ld8         t1 = [t11], 16          // get dbr pair
        ld8         t2 = [t12], 16          // step by 16 = 1 pair of DRs

        ld8         t3 = [t13], 16          // get dbr pair
        ld8         t4 = [t14], 16          // step by 16 = 1 pair of DRs
        ;;

        .auto
        mov         ibr[t7] = t1            // restore ibr pair
        mov         ibr[t8] = t2

        .auto
        mov         dbr[t7] = t3            // restore dbr pair
        mov         dbr[t8] = t4
        ;;

#ifndef NO_12241
        srlz.d
#endif

        .default
        add         t7 = 2, t7              // next pair
        add         t8 = 2, t8
        br.cloop.sptk Krdr_Loop
        ;;

        mov         ar.lc = t22             // restore ar.lc
 (pt2)  br.ret.sptk brp                     // return if loading user

        mov         out0 = PSR_DB
        mov         out1 = 1
 (pt3)  br.call.spnt brp = KeSetLowPsrBit   // set psr.db if loading kernel
        ;;

        NESTED_RETURN
        ;;

        NESTED_EXIT(KiLoadKernelDebugRegisters)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      KiSaveExceptionFrame(PKEXCEPTION_FRAME)
//
// Description:
//
//      Save preserved context in exception frame.
//
// Input:
//
//      a0: points to exception frame
//
// Output:
//
//      None
//
// Return value:
//
//      none
//
// Note: t0 may contain the trap frame address; don't touch it.
//
//--------------------------------------------------------------------

        LEAF_ENTRY(KiSaveExceptionFrame)

//
// Local register aliases
//

        rpEF1     = t10
        rpEF2     = t11

        add       rpEF1 = ExIntS0, a0            // -> ExIntS0
        movl      t12 = PFS_EC_MASK << PFS_EC_SHIFT
        ;;

        add       rpEF2 = ExIntS1, a0            // -> ExIntS1
        mov       t3 = ar.pfs
        ;;
        and       t3 = t3, t12

        .mem.offset 0,0
        st8.spill [rpEF1] = s0, ExIntS2-ExIntS0
        .mem.offset 8,0
        st8.spill [rpEF2] = s1, ExIntS3-ExIntS1
        mov       t4 = ar.lc
        ;;

        .mem.offset 0,0
        st8.spill [rpEF1] = s2, ExApEC-ExIntS2
        .mem.offset 8,0
        st8.spill [rpEF2] = s3, ExApLC-ExIntS3
        mov       t5 = bs0
        ;;

        st8       [rpEF1] = t3, ExBrS0-ExApEC
        st8       [rpEF2] = t4, ExBrS1-ExApLC
        mov       t6 = bs1
        ;;

        mov       t2 = ar.unat                   // save user nat register for
        mov       t7 = bs2
        mov       t8 = bs3

        st8       [rpEF1] = t5, ExBrS2-ExBrS0
        st8       [rpEF2] = t6, ExBrS3-ExBrS1
        mov       t9 = bs4
        ;;

        st8       [rpEF1] = t7, ExBrS4-ExBrS2
        st8       [rpEF2] = t8, ExIntNats-ExBrS3
        ;;

        st8       [rpEF1] = t9, ExFltS0-ExBrS4
        st8       [rpEF2] = t2, ExFltS1-ExIntNats
        ;;

        stf.spill [rpEF1] = fs0, ExFltS2-ExFltS0
        stf.spill [rpEF2] = fs1, ExFltS3-ExFltS1
        ;;

        stf.spill [rpEF1] = fs2, ExFltS4-ExFltS2
        stf.spill [rpEF2] = fs3, ExFltS5-ExFltS3
        ;;

        stf.spill [rpEF1] = fs4, ExFltS6-ExFltS4
        stf.spill [rpEF2] = fs5, ExFltS7-ExFltS5
        ;;

        stf.spill [rpEF1] = fs6, ExFltS8-ExFltS6
        stf.spill [rpEF2] = fs7, ExFltS9-ExFltS7
        ;;

        stf.spill [rpEF1] = fs8, ExFltS10-ExFltS8
        stf.spill [rpEF2] = fs9, ExFltS11-ExFltS9
        ;;

        stf.spill [rpEF1] = fs10, ExFltS12-ExFltS10
        stf.spill [rpEF2] = fs11, ExFltS13-ExFltS11
        ;;

        stf.spill [rpEF1] = fs12, ExFltS14-ExFltS12
        stf.spill [rpEF2] = fs13, ExFltS15-ExFltS13
        ;;

        stf.spill [rpEF1] = fs14, ExFltS16-ExFltS14
        stf.spill [rpEF2] = fs15, ExFltS17-ExFltS15
        ;;

        stf.spill [rpEF1] = fs16, ExFltS18-ExFltS16
        stf.spill [rpEF2] = fs17, ExFltS19-ExFltS17
        ;;

        stf.spill [rpEF1] = fs18
        stf.spill [rpEF2] = fs19
        LEAF_RETURN
        ;;

        LEAF_EXIT(KiSaveExceptionFrame)

//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      KiRestoreExceptionFrame(PKEXCEPTION_FRAME)
//
// Description:
//
//       Restores preserved context from the exception frame. Also
//       restore volatile part of floating point context not restored with
//       rest of volatile context.
//
//       Note: This routine does not use v0, t21 or t22.   This routine's
//             caller may be dependent on these registers (for performance
//             in the context switch path).
//
// Input:
//
//      a0: points to exception frame
//
// Output:
//
//      None
//
// Return value:
//
//      none
//
//--------------------------------------------------------------------

        LEAF_ENTRY(KiRestoreExceptionFrame)


        add       t16 = ExIntNats, a0
        movl      t12 = PFS_EC_MASK << PFS_EC_SHIFT

        add       t17 = ExApEC, a0
        nop.f     0
        mov       t13 = ar.pfs
        ;;

        ld8.nta   t2 = [t16], ExBrS0-ExIntNats
        ld8.nta   t3 = [t17], ExApLC-ExApEC
        ;;

        ld8.nta   t5 = [t16], ExBrS1-ExBrS0
        ld8.nta   t4 = [t17], ExBrS2-ExApLC
        ;;

        ld8.nta   t6 = [t16], ExBrS3-ExBrS1
        ld8.nta   t7 = [t17], ExBrS4-ExBrS2
        ;;

        ld8.nta   t8 = [t16], ExFltS0-ExBrS3
        ld8.nta   t9 = [t17], ExFltS1-ExBrS4
        ;;

        ldf.fill.nta  fs0 = [t16], ExFltS2-ExFltS0
        ldf.fill.nta  fs1 = [t17], ExFltS3-ExFltS1
        add       t18 = ExIntS0, a0
        ;;

        ldf.fill.nta  fs2 = [t16], ExFltS4-ExFltS2
        ldf.fill.nta  fs3 = [t17], ExFltS5-ExFltS3
        add       t19 = ExIntS1, a0
        ;;

        ldf.fill.nta  fs4 = [t16], ExFltS6-ExFltS4
        ldf.fill.nta  fs5 = [t17], ExFltS7-ExFltS5
        andcm     t13 = t13, t12               // zero out EC field
        ;;

        ldf.fill.nta  fs6 = [t16], ExFltS8-ExFltS6
        ldf.fill.nta  fs7 = [t17], ExFltS9-ExFltS7
        and       t3 = t3, t12                 // capture EC value
        ;;

        mov       ar.unat = t2
        or        t13 = t3, t13                // deposit into PFS.EC field
        ;;

        ldf.fill.nta  fs8 = [t16], ExFltS10-ExFltS8
        ldf.fill.nta  fs9 = [t17], ExFltS11-ExFltS9
        mov       ar.pfs = t13
        ;;

        ldf.fill.nta  fs10 = [t16], ExFltS12-ExFltS10
        ldf.fill.nta  fs11 = [t17], ExFltS13-ExFltS11
        mov       ar.lc = t4
        ;;

        ldf.fill.nta  fs12 = [t16], ExFltS14-ExFltS12
        ldf.fill.nta  fs13 = [t17], ExFltS15-ExFltS13
        mov       bs0 = t5
        ;;

        ldf.fill.nta  fs14 = [t16], ExFltS16-ExFltS14
        ldf.fill.nta  fs15 = [t17], ExFltS17-ExFltS15
        mov       bs1 = t6
        ;;

        ldf.fill.nta  fs16 = [t16], ExFltS18-ExFltS16
        ldf.fill.nta  fs17 = [t17], ExFltS19-ExFltS17
        mov       bs2 = t7
        ;;

        ldf.fill.nta  fs18 = [t16]
        ldf.fill.nta  fs19 = [t17]
        mov       bs3 = t8

        ld8.fill.nta  s0 = [t18], ExIntS2-ExIntS0
        ld8.fill.nta  s1 = [t19], ExIntS3-ExIntS1
        mov       bs4 = t9
        ;;

        ld8.fill.nta  s2 = [t18]
        ld8.fill.nta  s3 = [t19]
        LEAF_RETURN
        ;;
        LEAF_EXIT(KiRestoreExceptionFrame)

//++
//--------------------------------------------------------------------
// Routine:
//
//      KiSaveHigherFPVolatile(PKHIGHER_FP_SAVEAREA)
//
// Description:
//
//       Save higher FP volatile context in higher FP save area
//
// Input:
//
//       a0: pointer to higher FP save area
//       brp: return address
//
// Output:
//
//       None
//
// Return value:
//
//       None
//
//--------------------------------------------------------------------

        NESTED_ENTRY(KiSaveHigherFPVolatile)
        NESTED_SETUP(1, 3, 1, 0)
        PROLOGUE_END

//
// Local register aliases
//

        rpSA1     = t0
        rpSA2     = t1

//
// Clear DFH bit so the high floating point set may be saved by the kernel
// Disable interrupts so that save is atomic
//

        GET_IRQL  (loc2)
        mov       t2 = psr.um
        movl      t3 = KiPcr+PcCurrentThread
        ;;

        cmp.ge    pt2, pt3 = APC_LEVEL, loc2
        ;;
        PSET_IRQL (pt2, DISPATCH_LEVEL)

        ld8       t4 = [t3], PcHighFpOwner-PcCurrentThread
        ;;
        ld8       t5 = [t3]
        ;;

        cmp.ne    pt1 = t4, t5
 (pt1)  br.cond.spnt Kshfpv20
        ;;

        tbit.z    pt0 = t2, PSR_MFH
 (pt0)  br.cond.spnt Kshfpv20
        br        Kshfpv10
        ;;

        ALTERNATE_ENTRY(KiSaveHigherFPVolatileAtDispatchLevel)

        NESTED_SETUP(1, 3, 1, 0)
        cmp.ne    pt2, pt3 = r0, r0         // set pt2 to FALSE, pt3 to TRUE

        PROLOGUE_END

        movl      t3 = KiPcr+PcCurrentThread
        ;;
        ld8       t4 = [t3], PcHighFpOwner-PcCurrentThread
        ;;
        ld8       t5 = [t3]
        ;;
        cmp.ne    pt1 = t4, t5
        ;;
 (pt1)  break.i   BREAKPOINT_STOP

Kshfpv10:

        rsm       (1 << PSR_DFH)
        add       rpSA1 = HiFltF32, a0      // -> HiFltF32
        add       rpSA2 = HiFltF33, a0      // -> HiFltF33
        ;;
        srlz.d

        stf.spill.nta [rpSA1] = f32, HiFltF34-HiFltF32
        stf.spill.nta [rpSA2] = f33, HiFltF35-HiFltF33
        ;;
        stf.spill.nta [rpSA1] = f34, HiFltF36-HiFltF34
        stf.spill.nta [rpSA2] = f35, HiFltF37-HiFltF35
        ;;
        stf.spill.nta [rpSA1] = f36, HiFltF38-HiFltF36
        stf.spill.nta [rpSA2] = f37, HiFltF39-HiFltF37
        ;;
        stf.spill.nta [rpSA1] = f38, HiFltF40-HiFltF38
        stf.spill.nta [rpSA2] = f39, HiFltF41-HiFltF39
        ;;

        stf.spill.nta [rpSA1] = f40, HiFltF42-HiFltF40
        stf.spill.nta [rpSA2] = f41, HiFltF43-HiFltF41
        ;;
        stf.spill.nta [rpSA1] = f42, HiFltF44-HiFltF42
        stf.spill.nta [rpSA2] = f43, HiFltF45-HiFltF43
        ;;
        stf.spill.nta [rpSA1] = f44, HiFltF46-HiFltF44
        stf.spill.nta [rpSA2] = f45, HiFltF47-HiFltF45
        ;;
        stf.spill.nta [rpSA1] = f46, HiFltF48-HiFltF46
        stf.spill.nta [rpSA2] = f47, HiFltF49-HiFltF47
        ;;
        stf.spill.nta [rpSA1] = f48, HiFltF50-HiFltF48
        stf.spill.nta [rpSA2] = f49, HiFltF51-HiFltF49
        ;;

        stf.spill.nta [rpSA1] = f50, HiFltF52-HiFltF50
        stf.spill.nta [rpSA2] = f51, HiFltF53-HiFltF51
        ;;
        stf.spill.nta [rpSA1] = f52, HiFltF54-HiFltF52
        stf.spill.nta [rpSA2] = f53, HiFltF55-HiFltF53
        ;;
        stf.spill.nta [rpSA1] = f54, HiFltF56-HiFltF54
        stf.spill.nta [rpSA2] = f55, HiFltF57-HiFltF55
        ;;
        stf.spill.nta [rpSA1] = f56, HiFltF58-HiFltF56
        stf.spill.nta [rpSA2] = f57, HiFltF59-HiFltF57
        ;;
        stf.spill.nta [rpSA1] = f58, HiFltF60-HiFltF58
        stf.spill.nta [rpSA2] = f59, HiFltF61-HiFltF59
        ;;

        stf.spill.nta [rpSA1] = f60, HiFltF62-HiFltF60
        stf.spill.nta [rpSA2] = f61, HiFltF63-HiFltF61
        ;;
        stf.spill.nta [rpSA1] = f62, HiFltF64-HiFltF62
        stf.spill.nta [rpSA2] = f63, HiFltF65-HiFltF63
        ;;
        stf.spill.nta [rpSA1] = f64, HiFltF66-HiFltF64
        stf.spill.nta [rpSA2] = f65, HiFltF67-HiFltF65
        ;;
        stf.spill.nta [rpSA1] = f66, HiFltF68-HiFltF66
        stf.spill.nta [rpSA2] = f67, HiFltF69-HiFltF67
        ;;
        stf.spill.nta [rpSA1] = f68, HiFltF70-HiFltF68
        stf.spill.nta [rpSA2] = f69, HiFltF71-HiFltF69
        ;;

        stf.spill.nta [rpSA1] = f70, HiFltF72-HiFltF70
        stf.spill.nta [rpSA2] = f71, HiFltF73-HiFltF71
        ;;
        stf.spill.nta [rpSA1] = f72, HiFltF74-HiFltF72
        stf.spill.nta [rpSA2] = f73, HiFltF75-HiFltF73
        ;;
        stf.spill.nta [rpSA1] = f74, HiFltF76-HiFltF74
        stf.spill.nta [rpSA2] = f75, HiFltF77-HiFltF75
        ;;
        stf.spill.nta [rpSA1] = f76, HiFltF78-HiFltF76
        stf.spill.nta [rpSA2] = f77, HiFltF79-HiFltF77
        ;;
        stf.spill.nta [rpSA1] = f78, HiFltF80-HiFltF78
        stf.spill.nta [rpSA2] = f79, HiFltF81-HiFltF79
        ;;

        stf.spill.nta [rpSA1] = f80, HiFltF82-HiFltF80
        stf.spill.nta [rpSA2] = f81, HiFltF83-HiFltF81
        ;;
        stf.spill.nta [rpSA1] = f82, HiFltF84-HiFltF82
        stf.spill.nta [rpSA2] = f83, HiFltF85-HiFltF83
        ;;
        stf.spill.nta [rpSA1] = f84, HiFltF86-HiFltF84
        stf.spill.nta [rpSA2] = f85, HiFltF87-HiFltF85
        ;;
        stf.spill.nta [rpSA1] = f86, HiFltF88-HiFltF86
        stf.spill.nta [rpSA2] = f87, HiFltF89-HiFltF87
        ;;
        stf.spill.nta [rpSA1] = f88, HiFltF90-HiFltF88
        stf.spill.nta [rpSA2] = f89, HiFltF91-HiFltF89
        ;;

        stf.spill.nta [rpSA1] = f90, HiFltF92-HiFltF90
        stf.spill.nta [rpSA2] = f91, HiFltF93-HiFltF91
        ;;
        stf.spill.nta [rpSA1] = f92, HiFltF94-HiFltF92
        stf.spill.nta [rpSA2] = f93, HiFltF95-HiFltF93
        ;;
        stf.spill.nta [rpSA1] = f94, HiFltF96-HiFltF94
        stf.spill.nta [rpSA2] = f95, HiFltF97-HiFltF95
        ;;
        stf.spill.nta [rpSA1] = f96, HiFltF98-HiFltF96
        stf.spill.nta [rpSA2] = f97, HiFltF99-HiFltF97
        ;;
        stf.spill.nta [rpSA1] = f98, HiFltF100-HiFltF98
        stf.spill.nta [rpSA2] = f99, HiFltF101-HiFltF99
        ;;

        stf.spill.nta [rpSA1] = f100, HiFltF102-HiFltF100
        stf.spill.nta [rpSA2] = f101, HiFltF103-HiFltF101
        ;;
        stf.spill.nta [rpSA1] = f102, HiFltF104-HiFltF102
        stf.spill.nta [rpSA2] = f103, HiFltF105-HiFltF103
        ;;
        stf.spill.nta [rpSA1] = f104, HiFltF106-HiFltF104
        stf.spill.nta [rpSA2] = f105, HiFltF107-HiFltF105
        ;;
        stf.spill.nta [rpSA1] = f106, HiFltF108-HiFltF106
        stf.spill.nta [rpSA2] = f107, HiFltF109-HiFltF107
        ;;
        stf.spill.nta [rpSA1] = f108, HiFltF110-HiFltF108
        stf.spill.nta [rpSA2] = f109, HiFltF111-HiFltF109
        ;;

        stf.spill.nta [rpSA1] = f110, HiFltF112-HiFltF110
        stf.spill.nta [rpSA2] = f111, HiFltF113-HiFltF111
        ;;
        stf.spill.nta [rpSA1] = f112, HiFltF114-HiFltF112
        stf.spill.nta [rpSA2] = f113, HiFltF115-HiFltF113
        ;;
        stf.spill.nta [rpSA1] = f114, HiFltF116-HiFltF114
        stf.spill.nta [rpSA2] = f115, HiFltF117-HiFltF115
        ;;
        stf.spill.nta [rpSA1] = f116, HiFltF118-HiFltF116
        stf.spill.nta [rpSA2] = f117, HiFltF119-HiFltF117
        ;;
        stf.spill.nta [rpSA1] = f118, HiFltF120-HiFltF118
        stf.spill.nta [rpSA2] = f119, HiFltF121-HiFltF119
        ;;

        stf.spill.nta [rpSA1] = f120, HiFltF122-HiFltF120
        stf.spill.nta [rpSA2] = f121, HiFltF123-HiFltF121
        ;;
        stf.spill.nta [rpSA1] = f122, HiFltF124-HiFltF122
        stf.spill.nta [rpSA2] = f123, HiFltF125-HiFltF123
        ;;
        stf.spill.nta [rpSA1] = f124, HiFltF126-HiFltF124
        stf.spill.nta [rpSA2] = f125, HiFltF127-HiFltF125
        ;;
        stf.spill.nta [rpSA1] = f126
        stf.spill.nta [rpSA2] = f127

//
// Set DFH bit so the high floating point set may not be used by the kernel
// Must clear mfh after fp registers saved
//

Kshfpv20:
        ssm       1 << PSR_DFH
        ;;
        rum       1 << PSR_MFH
 (pt3)  br.ret.sptk brp

        LOWER_IRQL(loc2)

        NESTED_RETURN
        ;;

        LEAF_EXIT(KiSaveHigherFPVolatile)

//++
//--------------------------------------------------------------------
// Routine:
//
//      KiRestoreHigherFPVolatile()
//
// Description:
//
//       Restore higher FP volatile context from higher FP save area
//
//       N.B. This function is carefully constructed to use only scratch
//            registers rHpT1, rHpT3, and rTH2.  This function may be
//            called by C code and the disabled fp vector when user
//            and kernel bank is used respectively.
//       N.B. Caller must ensure higher fp enabled (psr.dfh=0)
//       N.B. Caller must ensure no interrupt during restore
//
// Input:
//
//       None.
//
// Output:
//
//       None
//
// Return value:
//
//       None
//
//--------------------------------------------------------------------

        LEAF_ENTRY(KiRestoreHigherFPVolatile)

        movl      rHpT1 = KiPcr+PcCurrentThread
        ;;

        ld8       rHpT3 = [rHpT1], PcHighFpOwner-PcCurrentThread
        ;;
        st8       [rHpT1] = rHpT3, PcNumber-PcHighFpOwner
        add       rHpT3 = ThNumber, rHpT3
        ;;

        ld1       rHpT1 = [rHpT1]               // load processor #
        ;;
        st1       [rHpT3] = rHpT1               // save it in Thread->Number
        add       rHpT3 = ThStackBase-ThNumber, rHpT3
        ;;

        ld8       rHpT3 = [rHpT3]               // load kernel stack base
        ;;

        add       rHpT1 = -ThreadStateSaveAreaLength+TsHigherFPVolatile+HiFltF32, rHpT3
        add       rHpT3 = -ThreadStateSaveAreaLength+TsHigherFPVolatile+HiFltF33, rHpT3
        ;;

        ldf.fill.nta  f32 = [rHpT1], HiFltF34-HiFltF32
        ldf.fill.nta  f33 = [rHpT3], HiFltF35-HiFltF33
        ;;

        ldf.fill.nta  f34 = [rHpT1], HiFltF36-HiFltF34
        ldf.fill.nta  f35 = [rHpT3], HiFltF37-HiFltF35
        ;;
        ldf.fill.nta  f36 = [rHpT1], HiFltF38-HiFltF36
        ldf.fill.nta  f37 = [rHpT3], HiFltF39-HiFltF37
        ;;
        ldf.fill.nta  f38 = [rHpT1], HiFltF40-HiFltF38
        ldf.fill.nta  f39 = [rHpT3], HiFltF41-HiFltF39
        ;;

        ldf.fill.nta  f40 = [rHpT1], HiFltF42-HiFltF40
        ldf.fill.nta  f41 = [rHpT3], HiFltF43-HiFltF41
        ;;
        ldf.fill.nta  f42 = [rHpT1], HiFltF44-HiFltF42
        ldf.fill.nta  f43 = [rHpT3], HiFltF45-HiFltF43
        ;;
        ldf.fill.nta  f44 = [rHpT1], HiFltF46-HiFltF44
        ldf.fill.nta  f45 = [rHpT3], HiFltF47-HiFltF45
        ;;
        ldf.fill.nta  f46 = [rHpT1], HiFltF48-HiFltF46
        ldf.fill.nta  f47 = [rHpT3], HiFltF49-HiFltF47
        ;;
        ldf.fill.nta  f48 = [rHpT1], HiFltF50-HiFltF48
        ldf.fill.nta  f49 = [rHpT3], HiFltF51-HiFltF49
        ;;

        ldf.fill.nta  f50 = [rHpT1], HiFltF52-HiFltF50
        ldf.fill.nta  f51 = [rHpT3], HiFltF53-HiFltF51
        ;;
        ldf.fill.nta  f52 = [rHpT1], HiFltF54-HiFltF52
        ldf.fill.nta  f53 = [rHpT3], HiFltF55-HiFltF53
        ;;
        ldf.fill.nta  f54 = [rHpT1], HiFltF56-HiFltF54
        ldf.fill.nta  f55 = [rHpT3], HiFltF57-HiFltF55
        ;;
        ldf.fill.nta  f56 = [rHpT1], HiFltF58-HiFltF56
        ldf.fill.nta  f57 = [rHpT3], HiFltF59-HiFltF57
        ;;
        ldf.fill.nta  f58 = [rHpT1], HiFltF60-HiFltF58
        ldf.fill.nta  f59 = [rHpT3], HiFltF61-HiFltF59
        ;;

        ldf.fill.nta  f60 = [rHpT1], HiFltF62-HiFltF60
        ldf.fill.nta  f61 = [rHpT3], HiFltF63-HiFltF61
        ;;
        ldf.fill.nta  f62 = [rHpT1], HiFltF64-HiFltF62
        ldf.fill.nta  f63 = [rHpT3], HiFltF65-HiFltF63
        ;;
        ldf.fill.nta  f64 = [rHpT1], HiFltF66-HiFltF64
        ldf.fill.nta  f65 = [rHpT3], HiFltF67-HiFltF65
        ;;
        ldf.fill.nta  f66 = [rHpT1], HiFltF68-HiFltF66
        ldf.fill.nta  f67 = [rHpT3], HiFltF69-HiFltF67
        ;;
        ldf.fill.nta  f68 = [rHpT1], HiFltF70-HiFltF68
        ldf.fill.nta  f69 = [rHpT3], HiFltF71-HiFltF69
        ;;

        ldf.fill.nta  f70 = [rHpT1], HiFltF72-HiFltF70
        ldf.fill.nta  f71 = [rHpT3], HiFltF73-HiFltF71
        ;;
        ldf.fill.nta  f72 = [rHpT1], HiFltF74-HiFltF72
        ldf.fill.nta  f73 = [rHpT3], HiFltF75-HiFltF73
        ;;
        ldf.fill.nta  f74 = [rHpT1], HiFltF76-HiFltF74
        ldf.fill.nta  f75 = [rHpT3], HiFltF77-HiFltF75
        ;;
        ldf.fill.nta  f76 = [rHpT1], HiFltF78-HiFltF76
        ldf.fill.nta  f77 = [rHpT3], HiFltF79-HiFltF77
        ;;
        ldf.fill.nta  f78 = [rHpT1], HiFltF80-HiFltF78
        ldf.fill.nta  f79 = [rHpT3], HiFltF81-HiFltF79
        ;;

        ldf.fill.nta  f80 = [rHpT1], HiFltF82-HiFltF80
        ldf.fill.nta  f81 = [rHpT3], HiFltF83-HiFltF81
        ;;
        ldf.fill.nta  f82 = [rHpT1], HiFltF84-HiFltF82
        ldf.fill.nta  f83 = [rHpT3], HiFltF85-HiFltF83
        ;;
        ldf.fill.nta  f84 = [rHpT1], HiFltF86-HiFltF84
        ldf.fill.nta  f85 = [rHpT3], HiFltF87-HiFltF85
        ;;
        ldf.fill.nta  f86 = [rHpT1], HiFltF88-HiFltF86
        ldf.fill.nta  f87 = [rHpT3], HiFltF89-HiFltF87
        ;;
        ldf.fill.nta  f88 = [rHpT1], HiFltF90-HiFltF88
        ldf.fill.nta  f89 = [rHpT3], HiFltF91-HiFltF89
        ;;

        ldf.fill.nta  f90 = [rHpT1], HiFltF92-HiFltF90
        ldf.fill.nta  f91 = [rHpT3], HiFltF93-HiFltF91
        ;;
        ldf.fill.nta  f92 = [rHpT1], HiFltF94-HiFltF92
        ldf.fill.nta  f93 = [rHpT3], HiFltF95-HiFltF93
        ;;
        ldf.fill.nta  f94 = [rHpT1], HiFltF96-HiFltF94
        ldf.fill.nta  f95 = [rHpT3], HiFltF97-HiFltF95
        ;;
        ldf.fill.nta  f96 = [rHpT1], HiFltF98-HiFltF96
        ldf.fill.nta  f97 = [rHpT3], HiFltF99-HiFltF97
        ;;
        ldf.fill.nta  f98 = [rHpT1], HiFltF100-HiFltF98
        ldf.fill.nta  f99 = [rHpT3], HiFltF101-HiFltF99
        ;;

        ldf.fill.nta  f100 = [rHpT1], HiFltF102-HiFltF100
        ldf.fill.nta  f101 = [rHpT3], HiFltF103-HiFltF101
        ;;
        ldf.fill.nta  f102 = [rHpT1], HiFltF104-HiFltF102
        ldf.fill.nta  f103 = [rHpT3], HiFltF105-HiFltF103
        ;;
        ldf.fill.nta  f104 = [rHpT1], HiFltF106-HiFltF104
        ldf.fill.nta  f105 = [rHpT3], HiFltF107-HiFltF105
        ;;
        ldf.fill.nta  f106 = [rHpT1], HiFltF108-HiFltF106
        ldf.fill.nta  f107 = [rHpT3], HiFltF109-HiFltF107
        ;;
        ldf.fill.nta  f108 = [rHpT1], HiFltF110-HiFltF108
        ldf.fill.nta  f109 = [rHpT3], HiFltF111-HiFltF109
        ;;

        ldf.fill.nta  f110 = [rHpT1], HiFltF112-HiFltF110
        ldf.fill.nta  f111 = [rHpT3], HiFltF113-HiFltF111
        ;;
        ldf.fill.nta  f112 = [rHpT1], HiFltF114-HiFltF112
        ldf.fill.nta  f113 = [rHpT3], HiFltF115-HiFltF113
        ;;
        ldf.fill.nta  f114 = [rHpT1], HiFltF116-HiFltF114
        ldf.fill.nta  f115 = [rHpT3], HiFltF117-HiFltF115
        ;;
        ldf.fill.nta  f116 = [rHpT1], HiFltF118-HiFltF116
        ldf.fill.nta  f117 = [rHpT3], HiFltF119-HiFltF117
        ;;
        ldf.fill.nta  f118 = [rHpT1], HiFltF120-HiFltF118
        ldf.fill.nta  f119 = [rHpT3], HiFltF121-HiFltF119
        ;;

        ldf.fill.nta  f120 = [rHpT1], HiFltF122-HiFltF120
        ldf.fill.nta  f121 = [rHpT3], HiFltF123-HiFltF121
        ;;
        ldf.fill.nta  f122 = [rHpT1], HiFltF124-HiFltF122
        ldf.fill.nta  f123 = [rHpT3], HiFltF125-HiFltF123
        ;;
        ldf.fill.nta  f124 = [rHpT1], HiFltF126-HiFltF124
        ldf.fill.nta  f125 = [rHpT3], HiFltF127-HiFltF125
        ;;
        ldf.fill.nta  f126 = [rHpT1]
        ldf.fill.nta  f127 = [rHpT3]
        ;;

        rsm       1 << PSR_MFH                 // clear psr.mfh bit
        br.ret.sptk brp
        ;;

        LEAF_EXIT(KiRestoreHigherFPVolatile)

//
// ++
//
// Routine:
//
//       KiPageTableFault
//
// Description:
//
//       Branched from Inst/DataTlbVector
//       Inserts a missing PDE translation for VHPT mapping
//       If PageNotPresent-bit of PDE is not set,
//                      branchs out to KiPdeNotPresentFault
//
// On entry:
//
//       rva  (h24) : offending virtual address
//       riha (h25) : a offending PTE address
//       rpr: (h26) : saved predicate
//
// Handle:
//
//       Extracts the PDE index from riha (PTE address in VHPT) and
//       generates a PDE address by adding to VHPT_DIRBASE. When accesses
//       a page directory entry (PDE), there might be a TLB miss on the
//       page directory table and returns a NaT on ld8.s. If so, branches
//       to KiPageDirectoryTableFault. If the page-not-present bit of the
//       PDE is not set, branches to KiPageNotPresentFault. Otherwise,
//       inserts the PDE entry into the data TC (translation cache).
//
// Notes:
//
//
// --

        HANDLER_ENTRY(KiPageTableFault)

        rva             = h24
        riha            = h25
        rpr             = h26
        rpPde           = h27
        rPde            = h28
        rPde2           = h29
        rps             = h30

        thash           rpPde = riha            // M
        cmp.ne          pt1 = r0, r0
        mov             rps = PAGE_SHIFT << PS_SHIFT    // I
        ;;

        mov             cr.itir = rps           // M
        ld8.s           rPde = [rpPde]          // M, load PDE
        ;;

        tnat.nz         pt0, p0 = rPde          // I
        tbit.z.or       pt1, p0 = rPde, PTE_ACCESS
        tbit.z.or       pt1, p0 = rPde, PTE_VALID       // I, if non-present page fault

(pt0)   br.cond.spnt    KiPageDirectoryFault    // B, tb miss on PDE access
(pt1)   br.cond.spnt    KiPdeNotPresentFault    // B, page fault
        ;;

        mov             cr.ifa = riha           // M
        ;;
        itc.d           rPde                    // M
        ;;

#if !defined(NT_UP)
        ld8.s           rPde2 = [rpPde]         // M
        cmp.ne          pt0 = zero, zero        // I
        ;;

        cmp.ne.or       pt0, p0 = rPde2, rPde   // I, if PTEs are different
        tnat.nz.or      pt0, p0 = rPde2         // I

        ;;
(pt0)   ptc.l           riha, rps               // M, purge it

#endif
        mov             pr = rpr, -1            // I
        rfi;;                                   // B

        HANDLER_EXIT(KiPageTableFault)



//++
//
// KiPageDirectoryFault
//
// Cause:
//
// Parameters:
//              rpPde (h28) : pointer to PDE entry
//              rpr   (h26) : saved predicate
//
//
// Handle:
//
//--
        HANDLER_ENTRY(KiPageDirectoryFault)

        rva             = h24
        rpPpe           = h25
        rpr             = h26
        rpPde           = h27
        rPpe            = h28
        rPpe2           = h29
        rps             = h30

        thash           rpPpe = rpPde           // M
        cmp.ne          pt1 = r0, r0
        ;;

        ld8.s           rPpe = [rpPpe]          // M
        ;;

        tnat.nz         pt0, p0 = rPpe          // I
        tbit.z.or       pt1, p0 = rPpe, PTE_ACCESS
        tbit.z.or       pt1, p0 = rPpe, PTE_VALID       // I, if non-present page fault

(pt0)   br.cond.spnt    KiPageFault             // B
(pt1)   br.cond.spnt    KiPdeNotPresentFault    // B
        ;;

        mov             cr.ifa = rpPde          // M, set tva for vhpt translation
        ;;
        itc.d           rPpe                    // M
        ;;

#if !defined(NT_UP)
        ld8.s           rPpe2 = [rpPpe]         // M
        mov             rps = PAGE_SHIFT << PS_SHIFT // I
        cmp.ne          pt0 = zero, zero        // I
        ;;

        cmp.ne.or       pt0, p0 = rPpe2, rPpe   // I, if PTEs are different
        tnat.nz.or      pt0, p0 = rPpe2         // I

        ;;
(pt0)   ptc.l           rpPde, rps              // M, purge it

#endif
        mov             pr = rpr, -1            // I
        rfi;;                                   // B


        HANDLER_EXIT(KiPageDirectoryFault)


//
// ++
//
// Routine:
//
//       KiPteNotPresentFault
//
// Description:
//
//       Branched from KiVhptTransVector and KiPageTableFault.
//       Inserts a missing PDE translation for VHPT mapping
//       If no PDE for it, branchs out to KiPageFault
//
// On entry:
//
//       rva  (h24)     : offending virtual address
//       rpr  (h26)     : saved predicate
//       rPde (h28)     : PDE entry
//
// Handle:
//
//       Check to see if PDE is marked as LARGE_PAGE. If so,
//       make it valid and install the large page size PTE.
//       If not, branch to KiPageFault.
//
//
// Notes:
//
//       PCR page mapped with TR
// --

        HANDLER_ENTRY(KiPteNotPresentFault)

        rva     =       h24    // passed
        riha    =       h25    // passed
        rpr     =       h26    // passed
        rps     =       h27

        rPfn    =       h28
        rpAte   =       h28
        rAte    =       h29
        rAteEnd =       h30
        rAteBase =      h31
        rAteMask =      h22

        rK0Base =       h31
        rK2Base =       h30

        pIndr = pt1

        mov             rps  = PS_4K << PS_SHIFT // M
        movl            rK0Base = KSEG0_BASE     // L
        ;;

        cmp.geu         pt3, p0 = rva, rK0Base  // M
        movl            rK2Base = KSEG2_BASE    // L
        ;;

(pt3)   cmp.ltu         pt3, p0 = rva, rK2Base    // M
        movl            rAteBase = ALT4KB_BASE    // L
        ;;

        shr.u           rPfn = rva, PAGE4K_SHIFT  // I
(pt3)   br.cond.spnt    KiKseg0Fault              // B
        ;;

        mov             rAteMask = ATE_MASK0      // I

        shladd  rpAte = rPfn, PTE_SHIFT, rAteBase // M
        movl    rAteEnd = ALT4KB_END              // L
        ;;

        ld8.s           rAte = [rpAte]            // M
        andcm           rAteMask = -1, rAteMask   // I
        cmp.ltu         pIndr = rpAte, rAteEnd    // I
        ;;
        tnat.z.and      pIndr = rAte              // I
        tbit.nz.and     pIndr = rAte, PTE_VALID   // I

        or              rAteMask = rAte, rAteMask // M
        tbit.nz.and     pIndr = rAte, PTE_ACCESS  // I
        tbit.nz.and     pIndr = rAte, ATE_INDIRECT // I


(pIndr) br.cond.spnt    KiPteIndirectFault
        ;;
        ptc.l           rva, rps                // M

        br.sptk         KiPageFault             // B

        HANDLER_EXIT(KiPteNotPresentFault)

//
// ++
//
// Routine:
//
//       KiPdeNotPresentFault
//
// Description:
//
//       Branched from KiVhptTransVector and KiPageTableFault.
//       Inserts a missing PDE translation for VHPT mapping
//       If no PDE for it, branchs out to KiPageFault
//
// On entry:
//
//       rva  (h24)     : offending virtual address
//       rpr  (h26)     : saved predicate
//       rPde (h28)     : PDE entry
//
// Handle:
//
//       Check to see if PDE is marked as LARGE_PAGE. If so,
//       make it valid and install the large page size PTE.
//       If not, branch to KiPageFault.
//
//
// Notes:
//
//       PCR page mapped with TR
// --

        HANDLER_ENTRY(KiPdeNotPresentFault)

        br.sptk         KiPageFault

#if 0
        rva             = h24
        rK0Base         = h25
        rpr             = h26
        rK2Base         = h27
        rPde            = h28
        ridtr           = h29
        rps             = h30
        rPte            = h25

        movl            rK0Base = KSEG0_BASE
        ;;

        cmp.ltu         pt3, pt4 = rva, rK0Base
        movl            rK2Base = KSEG2_BASE
        ;;

(pt4)   cmp.geu         pt3, p0 = rva, rK2Base
(pt3)   br.cond.spnt    KiPageFault

        mov             ridtr = cr.itir
        shr.u           rPde = rva, PAGE_SHIFT
        mov             rps = 24
        ;;

        movl            rPte = VALID_KERNEL_PTE
        dep.z           rPde = rPde, PAGE_SHIFT, 28 - PAGE_SHIFT
        dep             ridtr = rps, ridtr, PS_SHIFT, PS_LEN
        ;;

        mov             cr.itir = ridtr
        or              rPde = rPte, rPde
        ;;

        itc.d           rPde
        ;;
        mov             pr = rpr, -1
        rfi;;
#endif

        HANDLER_EXIT(KiPdeNotPresentFault)


//
// ++
//
// Routine:
//
//       KiKseg0Fault
//
// Description:
//
//       TLB miss on KSEG0 space
//
//
// On entry:
//
//       rva  (h24)     : faulting virtual address
//       riha (h25)     : IHA address
//       rpr  (h26)     : saved predicate
//
// Process:
//
//
// Notes:
//
//       PCR page mapped with TR
// --

        HANDLER_ENTRY(KiKseg0Fault)

        rISR    =       h30
        rva     =       h24     // passed
        riha    =       h25     // passed
        rpr     =       h26     // passed
        rps     =       h27
        rPte    =       h29
        rITIR   =       h28
        rPs     =       h30
        rPte0   =       h31

        mov     rISR = cr.isr                   // M
        ld8.s   rPte = [riha]                   // M
        cmp.ne  pt1 = r0, r0                    // I, pt1 = 0
        ;;

        or      rPte0 = PTE_VALID_MASK, rPte    // M
        tbit.z  pt2, pt3 = rISR, ISR_SP         // I
        tbit.z.or   pt1 = rPte, PTE_LARGE_PAGE  // I
        tbit.nz.or  pt1 = rPte, PTE_VALID       // I

        tnat.nz pt4 = rPte                      // I
(pt4)   br.cond.spnt      KiPageTableFault      // B, tb miss on PTE access
        ;;

        rIPSR   =       h25

        mov     rIPSR = cr.ipsr                 // M
        extr    rPs = rPte, PTE_PS, PS_LEN      // I
(pt1)   br.cond.spnt      KiPageFault           // B, invalid access
        ;;
        dep.z   rITIR = rPs, PS_SHIFT, PS_LEN   // I
        ;;
(pt2)   mov     cr.itir = rITIR                 // M
        dep     rIPSR = 1, rIPSR, PSR_ED, 1     // I
        ;;
(pt2)   itc.d   rPte0                           // M
        ;;
(pt3)   mov     cr.ipsr = rIPSR                 // M
        ;;
        mov     pr = rpr, -1                    // I
        rfi                                     // B
        ;;

        HANDLER_EXIT(KiKseg0Fault)

//
// ++
//
// Routine:
//
//       KiKseg4Fault
//
// Description:
//
//       TLB miss on KSEG4 space
//
//
// On entry:
//
//       rva  (h24)     : faulting virtual address
//       riha (h25)     : IHA address
//       rpr  (h26)     : saved predicate
//
// Process:
//
//
// Notes:
//
//       PCR page mapped with TR
// --

        HANDLER_ENTRY(KiKseg4Fault)

        rIPSR   =       h22
        rISR    =       h23
        rva     =       h24     // passed
        riha    =       h25
        rpr     =       h26     // passed
        rPte    =       h27

        mov     rISR = cr.isr                   // M
        movl    rPte = VALID_KERNEL_PTE | PTE_NOCACHE  // L

        mov     rIPSR = cr.ipsr                 // M
        shr.u   rva = rva, PAGE_SHIFT           // I
        ;;
        tbit.z  pt2, pt3 = rISR, ISR_SP         // I
        dep.z   rva = rva, PAGE_SHIFT, 32       // I
        ;;
        or      rPte = rPte, rva                // I
        dep     rIPSR = 1, rIPSR, PSR_ED, 1     // I
        ;;

(pt2)   itc.d   rPte                            // M
        ;;
(pt3)   mov     cr.ipsr = rIPSR                 // M
        ;;

        mov     pr = rpr, -1                    // I
        rfi                                     // B
        ;;

        HANDLER_EXIT(KiKseg4Fault)


//
// ++
//
// Routine:
//
//       KiPageFault
//
// Description:
//
//       This must be a genuine page fault. Call KiMemoryFault().
//
//
// On entry:
//
//       rva (h24)     : offending virtual address
//       rpr (h26)     : PDE contents
//
// Process:
//
//       Restores the save predicate (pr), and branches to
//       KiGenericExceptionHandler with the argument KiMemoryFault with
//       macro VECTOR_CALL_HANDLER().
//
// Notes:
//
//       PCR page mapped with TR
// --

        HANDLER_ENTRY(KiPageFault)

        rva     = h24
        rpr     = h26
        rIPSR   = h27
        rISR    = h31

        //
        // check to see if non-present fault occurred on a speculative load.
        // if so, set IPSR.ed bit. This forces to generate a NaT on ld.s after
        // rfi
        //

        mov             rISR = cr.isr           // M
        mov             rIPSR = cr.ipsr         // M
        ;;

        tbit.z          pt0, p0 = rISR, ISR_SP  // I
        dep             rIPSR = 1, rIPSR, PSR_ED, 1 // I

(pt0)   br.cond.spnt    KiCallMemoryFault          // B
        ;;

        mov             cr.ipsr = rIPSR         // M
        ;;
        mov             pr = rpr, -1            // I
        rfi                                     // B
        ;;

KiCallMemoryFault:

        mov             pr = rpr, -1            // I

        VECTOR_CALL_HANDLER(KiGenericExceptionHandler, KiMemoryFault)

        HANDLER_EXIT(KiPageFault)

//
// ++
//
// Routine:
//
//       KiPteIndirectFault
//
// Description:
//
//       The PTE itself indicates a PteIndirect fault. The target PTE address
//       should be generated by extracting PteOffset from PTE and adding it to
//       PTE_UBASE.  The owner field of the target PTE must be 1. Otherwise,
//       Call MmX86Fault().
//
// On entry:
//
//       rva (h24)     : offending virtual address
//       rpr (h26)     : PDE contents
//
// Process:
//
//       Restores the save predicate (pr), and branches to
//       KiGenericExceptionHandler with the argument KiMemoryFault with
//       macro VECTOR_CALL_HANDLER().
//
// Notes:
//
//       PCR page mapped with TR
// --

        HANDLER_ENTRY(KiPteIndirectFault)

        rpr     =       h26  // passed
        rps     =       h27  // passed
        rpAte   =       h28  // passed
        rAte    =       h29  // passed
        rPte    =       h30
        rPte0   =       h31
        rAteMask =      h22  // passed
        rVa12   =       h23

        rPteOffset = h23
        rpNewPte = h21

        rOldIIP =       h17  // preserved
        rIA32IIP =      h18
        rpVa    =       h19  // preserved
        rIndex  =       h20  // preserved
        rpBuffer=       h16
        rpPte   =       h22

        pBr = pt0
        pPrg = pt3
        pLoop = pt4
        pClear = pt5

        mov             cr.itir = rps                           // M
        thash           rpNewPte = r0                           // M

        mov             rIA32IIP = cr.iip                       // M
        extr.u          rPteOffset = rAte, PAGE4K_SHIFT, 32     // I

        ;;
        add             rpNewPte = rPteOffset, rpNewPte         // M/I
        cmp.eq          pLoop, pClear = rIA32IIP, rOldIIP       // I

        ;;
        ld8.s           rPte = [rpNewPte]                       // M
        shr             rVa12 = rpAte, PTE_SHIFT                // I
        ;;
        tnat.nz.or      pBr = rPte                              // I
        tbit.z.or       pBr = rPte, PTE_VALID                   // I
        tbit.z.or       pBr = rPte, PTE_ACCESS                  // I        
(pBr)   br.cond.spnt    KiPageFault

        ;;
(pClear)mov           rIndex = 0                               // M
        and              rPte0 = rPte, rAteMask                // I
        ;;

        //
        // deposit extra PFN bits for 4k page
        //
        dep     rPte0 = rVa12, rPte0, PAGE4K_SHIFT, PAGE_SHIFT-PAGE4K_SHIFT // I
        ;;
(pClear)itc.d   rPte0                                           // M
        ;;

        and          rIndex = 7, rIndex          // A
        movl         rpBuffer = KiPcr + PcForwardProgressBuffer   // L
        ;;

        shladd       rpVa = rIndex, 4, rpBuffer  // M
        add          rIndex = 1, rIndex          // I
        ;;

        st8          [rpVa] = rva                // M
        add          rpPte = 8, rpVa             // I
        ;;

        st8          [rpPte] = rPte0             // M
        mf                                       // M

        mov            rOldIIP = rIA32IIP        // I


#if !defined(NT_UP)
        rAte2   =       h28
        rPte2   =       h31

        ld8.s   rPte2 = [rpNewPte]              // M
        ld8.s   rAte2 = [rpAte]                 // M
        cmp.ne  pPrg = zero, zero               // I
        ;;

        cmp.ne.or       pPrg = rPte, rPte2      // I
        tnat.nz.or      pPrg = rPte2            // I

        cmp.ne.or       pPrg = rAte, rAte2      // I
        tnat.nz.or      pPrg = rAte2            // I
        ;;

(pPrg)  ptc.l           rva, rps                // M
(pPrg)  st8             [rpPte] = r0            // M

#endif
(pLoop) br.cond.spnt    KiFillForwardProgressTb // B
        mov             pr = rpr, -1            // I
        rfi;;                                   // B

        HANDLER_EXIT(KiPteIndirectFault)

//
// ++
//
// Routine:
//
//       Ki4KDataTlbFault
//
// Description:
//
//       Branched from KiDataTlbVector if PTE.Cache indicates the reserved
//       encoding. Reads the corresponding ATE and creates a 4kb TB on the
//       fly inserts it to the TLB. If a looping condition at IIP is
//       detected, it branches to KiFillForwardProgressTb and insert the TBs
//       from the forward progress TB queue.
//
// On entry:
//
//       rva (h24)     : offending virtual address
//       riha(h25)     : IHA address
//       rpr (h26)     : PDE contents
//
// Notes:
//
// --

        HANDLER_ENTRY(Ki4KDataTlbFault)

        rva     =       h24  // passed
        riha    =       h25  // passed
        rpr     =       h26  // passed
        rps     =       h27
        rPfn    =       h28
        rpAte   =       h28
        rAte    =       h29
        rPte    =       h30
        rAltBase =      h31
        rPte0   =       h31
        rAteMask =      h22
        rVa12   =       h23

        rOldIIP =       h17 // preserved
        rIA32IIP =      h18
        rpVa    =       h19
        rIndex  =       h20 // preserved

        rpBuffer=       h16
        rpPte   =       h21

        pBr = pt0
        pIndr = pt1
        pMiss = pt2
        pPrg = pt3
        pLoop = pt4
        pClear = pt5
        pMiss2 = pt6

        mov     rIA32IIP = cr.iip               // M
        mov     rps = PS_4K << PS_SHIFT         // I
        shr.u   rPfn = rva, PAGE4K_SHIFT        // I

        cmp.ne  pBr = zero, zero                // M/I, initialize to 0
        movl    rAltBase = ALT4KB_BASE          // L
        ;;

        ld8.s   rPte = [riha]                   // M
        shladd  rpAte = rPfn, PTE_SHIFT, rAltBase  // I
        ;;

        ld8.s   rAte = [rpAte]                  // M
        movl     rAteMask = ATE_MASK            // L
        ;;

        cmp.eq         pLoop, pClear = rIA32IIP, rOldIIP// M
        tnat.nz        pMiss = rPte             // I
(pMiss) br.cond.spnt   KiPageTableFault         // B

        tnat.nz        pMiss2 = rAte            // I
(pMiss2)br.cond.spnt   KiAltTableFault          // B

        tbit.z.or      pBr = rPte, PTE_VALID    // I
        tbit.z.or      pBr = rAte, PTE_VALID    // I
        tbit.z.or      pBr = rAte, PTE_ACCESS   // I

        or             rAteMask = rAte, rAteMask // M
        tbit.nz        pIndr, p0 = rAte, ATE_INDIRECT // I
(pBr)   br.cond.spnt   KiPageFault              // B

        dep            rPte0 = 0, rPte, 2, 3   // I, make it WB
        shr            rVa12 = rpAte, PTE_SHIFT // I
(pIndr) br.cond.spnt   KiPteIndirectFault       // B
        ;;
(pClear)mov           rIndex = 0                // M
        mov           cr.itir = rps             // M
        and           rPte0 = rPte0, rAteMask   // I
        ;;
        //
        // deposit extra PFN bits for 4k page
        //

        dep           rPte0 = rVa12, rPte0, PAGE4K_SHIFT, PAGE_SHIFT-PAGE4K_SHIFT // I
        ;;

(pClear)itc.d         rPte0                     // M, install PTE
        ;;

        and          rIndex = 7, rIndex          // A
        movl         rpBuffer = KiPcr + PcForwardProgressBuffer   // L

        ;;

        shladd       rpVa = rIndex, 4, rpBuffer  // M
        add          rIndex = 1, rIndex          // I
        ;;

        st8          [rpVa] = rva                // M
        add          rpPte = 8, rpVa             // I
        ;;

        st8          [rpPte] = rPte0             // M
        mf                                       // M

        mov            rOldIIP = rIA32IIP        // I

#if !defined(NT_UP)
        rps     =       h27
        rAte2   =       h28
        rPte2   =       h31

        ld8.s   rPte2 = [riha]                  // M
        ld8.s   rAte2 = [rpAte]                 // M
        cmp.ne  pPrg = zero, zero               // I
        ;;

        cmp.ne.or       pPrg = rPte, rPte2      // M
        tnat.nz.or      pPrg = rPte2            // I

        cmp.ne.or       pPrg = rAte, rAte2      // M
        tnat.nz.or      pPrg = rAte2            // I
        ;;

(pPrg)  ptc.l           rva, rps                // M
(pPrg)  st8             [rpPte] = r0            // M
#endif
(pLoop) br.cond.spnt    KiFillForwardProgressTb // B

        mov             pr = rpr, -1            // I
        rfi;;                                   // B

        HANDLER_EXIT(Ki4KDataTlbFault)

//
// ++
//
// Routine:
//
//       Ki4KInstTlbFault
//
// Description:
//
//       Branched from KiInstTlbVector if PTE.Cache indicates the reserved
//       encoding. Reads the corresponding ATE and creates a 4kb TB on the
//       fly inserts it to the TLB.
//
// On entry:
//
//       rva (h24)     : offending virtual address
//       riha(h25)     : IHA address
//       rpr (h26)     : PDE contents
//
// Notes:
//
// --

        HANDLER_ENTRY(Ki4KInstTlbFault)

        rva     =       h24  // passed
        riha    =       h25  // passed
        rpr     =       h26  // passed
        rps     =       h27
        rPfn    =       h28
        rpAte   =       h28
        rAte    =       h29
        rPte    =       h30
        rAltBase =      h31
        rPte0   =       h31
        rAteMask =      h22
        rVa12   =       h23

        pBr = pt0
        pIndr = pt1
        pMiss = pt2
        pPrg = pt3
        pMiss2 = pt6


        mov     rps = PS_4K << PS_SHIFT         // M
        movl    rAltBase = ALT4KB_BASE          // L
        shr.u   rPfn = rva, PAGE4K_SHIFT        // I
        ;;

        ld8.s   rPte = [riha]                   // M
        cmp.ne  pBr = zero, zero                // M/I, initialize to 0
        shladd  rpAte = rPfn, PTE_SHIFT, rAltBase  // I
        ;;

        ld8.s   rAte = [rpAte]                  // M
        movl     rAteMask = ATE_MASK            // L
        ;;

        tnat.nz        pMiss = rPte             // I
(pMiss) br.cond.spnt   KiPageTableFault         // B

        tnat.nz        pMiss2 = rAte            // I
(pMiss2)br.cond.spnt   KiAltTableFault          // B

        tbit.z.or      pBr = rPte, PTE_VALID    // I
        tbit.z.or      pBr = rAte, PTE_VALID    // I
        tbit.z.or      pBr = rAte, PTE_ACCESS   // I

        or             rAteMask = rAte, rAteMask // M
        tbit.nz        pIndr, p0 = rAte, ATE_INDIRECT // I
(pBr)   br.cond.spnt   KiPageFault              // B

        dep            rPte0 = 0, rPte, 2, 3   // I, make it WB
        shr            rVa12 = rpAte, PTE_SHIFT // I
(pIndr) br.cond.spnt   KiPteIndirectFault       // B
        ;;
        mov     cr.itir = rps                   // M
        and            rPte0 = rPte0, rAteMask  // I
        ;;
        //
        // deposit extra PFN bits for 4k page
        //

        dep          rPte0 = rVa12, rPte0, PAGE4K_SHIFT, PAGE_SHIFT-PAGE4K_SHIFT // I
        ;;

        itc.i        rPte0                     // M, install PTE
        ;;

#if !defined(NT_UP)
        rps     =       h27
        rAte2   =       h28
        rPte2   =       h31

        ld8.s   rPte2 = [riha]                  // M
        ld8.s   rAte2 = [rpAte]                 // M
        cmp.ne  pPrg = zero, zero               // I
        ;;

        cmp.ne.or       pPrg = rPte, rPte2      // M
        tnat.nz.or      pPrg = rPte2            // I

        cmp.ne.or       pPrg = rAte, rAte2      // M
        tnat.nz.or      pPrg = rAte2            // I
        ;;

(pPrg)  ptc.l           rva, rps                // M

#endif

        mov             pr = rpr, -1            // I
        rfi;;                                   // B

        HANDLER_EXIT(Ki4KInstTlbFault)

//
// ++
//
// Routine:
//
//       KiAltTableFault
//
// Description:
//
//       Branched from Inst/DataAccessBitVector
//       Inserts a missing PTE translation for the alt table.
//
// On entry:
//
//       rva  (h24) : offending virtual address
//       riha (h25) : a offending PTE address
//       rpr: (h26) : saved predicate
//
// Handle:
//
// --

        HANDLER_ENTRY(KiAltTableFault)

        rpAte   = h28   // passed

        rva     = h24
        riha    = h25
        rpr     = h26   // passed
        rPte    = h27
        rPte2   = h28
        rps     = h29

        thash           riha = rpAte            // M
        cmp.ne          pt1 = r0, r0
        mov             rva  = rpAte            // I
        ;;

        ld8.s           rPte = [riha]           // M
        ;;

        tnat.nz         pt0, p0 = rPte          // I
        tbit.z.or       pt1, p0 = rPte, PTE_ACCESS
        tbit.z.or       pt1, p0 = rPte, PTE_VALID       // I, if non-present page fault

(pt0)   br.cond.spnt    KiPageTableFault        // B
(pt1)   br.cond.spnt    KiPteNotPresentFault    // B
        ;;

        mov             cr.ifa = rva
        ;;
        itc.d           rPte                    // M
        ;;

#if !defined(NT_UP)
        ld8.s           rPte2 = [riha]          // M
        mov             rps = PAGE_SHIFT << PS_SHIFT // I
        cmp.ne          pt0 = zero, zero             // I
        ;;

        cmp.ne.or       pt0 = rPte2, rPte       // M
        tnat.nz.or      pt0 = rPte2             // I
        ;;

(pt0)   ptc.l           rva, rps                // M
#endif
        mov             pr = rpr, -1            // I
        rfi;;                                   // B

        HANDLER_EXIT(KiAltTableFault)


//
// ++
//
// Routine:
//
//       KiFillForwardProgressTb
//
// Description:
//
//       Fill TB from TLB forward progress buffer.
//
// On entry:
//
//       rpBuffer (h16) : forward progress buffer address
//       rpr: (h26) : saved predicate
//
// Handle:
//
// --

        HANDLER_ENTRY(KiFillForwardProgressTb)

        rLc     =       h29
        rT0     =       h28
        rps     =       h27
        rpr     =       h26
        rVa     =       h22
        rPte    =       h21
        rpVa    =       h19
        rpPte   =       h17
        rpBuffer=       h16

        mov     rpVa = rpBuffer                         // A
        mov.i   rLc = ar.lc                             // I
        mov     rT0 = NUMBER_OF_FWP_ENTRIES - 1         //
        ;;
        add     rpPte = 8, rpBuffer                     // A
        mov.i   ar.lc = rT0                             // I
        ;;

fpb_loop:

        //
        // use ALAT to see if somebody modify the PTE entry
        //

        ld8     rVa = [rpVa], 16                        // M
        ld8.a   rPte = [rpPte]                          // M
        ;;

        mov     cr.ifa = rVa                            // M
        cmp.ne  pt0, pt1 = rPte, r0                     // I
        ;;

(pt0)   itc.d   rPte                                    // M
        ;;
(pt0)   ld8.c.clr rPte = [rpPte]                        // M
        add     rpPte = 16, rpPte                       // I
        ;;
(pt1)   invala.e rPte                                   // M, invalidate ALAT entry
(pt0)   cmp.eq.and pt0 = rPte, r0                       // I
        ;;
(pt0)   ptc.l   rVa, rps                                // M
        br.cloop.dptk.many fpb_loop;;                   // B

        mov.i  ar.lc = rLc

        mov     pr = rpr, -1                            // I
        rfi                                             // B
        ;;

        HANDLER_EXIT(KiFillForwardProgressTb)


//++
//
// Routine Description:
//
//     This routine begins the common code for raising an exception.
//     The routine saves the non-volatile state and dispatches to the
//     next level exception dispatcher.
//
// Arguments:
//
//      a0 - pointer to trap frame
//      a1 - previous mode
//
// Return Value:
//
//      None.
//
//--

        NESTED_ENTRY(KiExceptionDispatch)

//
// Build exception frame
//

        .regstk   2, 3, 5, 0
        .prologue 0xA, loc0
        alloc     t16 = ar.pfs, 2, 3, 5, 0
        mov       loc0 = sp
        cmp4.eq   pt0 = UserMode, a1                  // previous mode is user?

        mov       loc1 = brp
        .fframe    ExceptionFrameLength
        add       sp = -ExceptionFrameLength, sp
        ;;

        .save     ar.unat, loc2
        mov       loc2 = ar.unat
        add       t0 = ExFltS19+STACK_SCRATCH_AREA, sp
        add       t1 = ExFltS18+STACK_SCRATCH_AREA, sp
        ;;

        .save.gf  0x0, 0xC0000
        stf.spill [t0] = fs19, ExFltS17-ExFltS19
        stf.spill [t1] = fs18, ExFltS16-ExFltS18
        ;;

        .save.gf  0x0, 0x30000
        stf.spill [t0] = fs17, ExFltS15-ExFltS17
        stf.spill [t1] = fs16, ExFltS14-ExFltS16
        mov       t10 = bs4
        ;;

        .save.gf  0x0, 0xC000
        stf.spill [t0] = fs15, ExFltS13-ExFltS15
        stf.spill [t1] = fs14, ExFltS12-ExFltS14
        mov       t11 = bs3
        ;;

        .save.gf  0x0, 0x3000
        stf.spill [t0] = fs13, ExFltS11-ExFltS13
        stf.spill [t1] = fs12, ExFltS10-ExFltS12
        mov       t12 = bs2
        ;;

        .save.gf  0x0, 0xC00
        stf.spill [t0] = fs11, ExFltS9-ExFltS11
        stf.spill [t1] = fs10, ExFltS8-ExFltS10
        mov       t13 = bs1
        ;;

        .save.gf  0x0, 0x300
        stf.spill [t0] = fs9, ExFltS7-ExFltS9
        stf.spill [t1] = fs8, ExFltS6-ExFltS8
        mov       t14 = bs0
        ;;

        .save.gf  0x0, 0xC0
        stf.spill [t0] = fs7, ExFltS5-ExFltS7
        stf.spill [t1] = fs6, ExFltS4-ExFltS6
        mov       t15 = ar.lc
        ;;

        .save.gf  0x0, 0x30
        stf.spill [t0] = fs5, ExFltS3-ExFltS5
        stf.spill [t1] = fs4, ExFltS2-ExFltS4
        ;;

        .save.f   0xC
        stf.spill [t0] = fs3, ExFltS1-ExFltS3         // save fs3
        stf.spill [t1] = fs2, ExFltS0-ExFltS2         // save fs2
        ;;

        .save.f   0x3
        stf.spill [t0] = fs1, ExBrS4-ExFltS1          // save fs1
        stf.spill [t1] = fs0, ExBrS3-ExFltS0          // save fs0
        ;;

        .save.b   0x18
        st8       [t0] = t10, ExBrS2-ExBrS4           // save bs4
        st8       [t1] = t11, ExBrS1-ExBrS3           // save bs3
        ;;

        .save.b   0x6
        st8       [t0] = t12, ExBrS0-ExBrS2           // save bs2
        st8       [t1] = t13, ExIntS2-ExBrS1          // save bs1
        ;;

        .save.b   0x1
        st8       [t0] = t14, ExIntS3-ExBrS0          // save bs0
        movl      out0 = KiPcr+PcCurrentThread
        ;;

        .save.gf  0xC, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s3, ExIntS1-ExIntS3          // save s3
        .mem.offset 8,0
        st8.spill [t1] = s2, ExIntS0-ExIntS2          // save s2
        ;;

        .save.gf  0x3, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s1, ExApLC-ExIntS1           // save s1
        .mem.offset 8,0
        st8.spill [t1] = s0, ExApEC-ExIntS0           // save s0
        ;;

        .savepsp  ar.pfs, ExceptionFrameLength-ExApEC-STACK_SCRATCH_AREA
        st8       [t1] = t16, ExIntNats-ExApEC
        mov       t4 = ar.unat                        // captured Nats of s0-s3
        ;;

 (pt0)  ld8       out0 = [out0]
        ;;
 (pt0)  add       out0 = ThStackBase, out0

        .savepsp  ar.lc, ExceptionFrameLength-ExApLC-STACK_SCRATCH_AREA
        st8       [t0] = t15
        .savepsp  @priunat, ExceptionFrameLength-ExIntNats-STACK_SCRATCH_AREA
        st8       [t1] = t4                           // save Nats of s0-s3
        ;;


        PROLOGUE_END

 (pt0)  ld8       out0 = [out0]
        ;;
 (pt0)  add       out0 = -ThreadStateSaveAreaLength+TsHigherFPVolatile, out0
 (pt0)  br.call.sptk brp = KiSaveHigherFPVolatile
        ;;

        add       out0 = TrExceptionRecord, a0        // -> exception record
        add       out1 = STACK_SCRATCH_AREA, sp       // -> exception frame
        mov       out2 = a0                           // -> trap frame

        mov       out3 = a1                           // previous mode
        mov       out4 = 1                            // first chance
        br.call.sptk.many brp = KiDispatchException
        ;;

        add       t1 = ExApEC+STACK_SCRATCH_AREA, sp
        movl      t0 = KiExceptionExit
        ;;

        //
        // Interrupts must be disabled before calling KiExceptionExit
        // because the unwind code cannot unwind from that point.
        //

        FAST_DISABLE_INTERRUPTS
        ld8       t1 = [t1]
        mov       brp = t0
        ;;

        mov       ar.unat = loc2
        mov       ar.pfs = t1

        add       s1 = STACK_SCRATCH_AREA, sp         // s1 -> exception frame
        mov       s0 = a0                             // s0 -> trap frame
        br.ret.sptk brp
        ;;

        NESTED_EXIT(KiExceptionDispatch)


//++
//
// BOOLEAN
// KeInvalidAccessAllowed (
//    IN PVOID TrapInformation
//    )
//
// Routine Description:
//
//    Mm will pass a pointer to a trap frame prior to issuing a bug check on
//    a pagefault.  This routine lets Mm know if it is ok to bugcheck.  The
//    specific case we must protect are the interlocked pop sequences which can
//    blindly access memory that may have been freed and/or reused prior to the
//    access.  We don't want to bugcheck the system in these cases, so we check
//    the instruction pointer here.
//
// Arguments:
//
//    TrapFrame (a0) - Supplies a  trap frame pointer.  NULL means return False.
//
// Return Value:
//
//    True if the invalid access should be ignored.
//    False which will usually trigger a bugcheck.
//
//--

        LEAF_ENTRY(KeInvalidAccessAllowed)

        .regstk    1, 0, 0, 0

        cmp.eq     pt0 = 0, a0
        movl       t1 = ExpInterlockedPopEntrySListFault

        add        t0 = TrStIIP, a0
        mov        v0 = zero              // assume access not allowed
 (pt0)  br.ret.spnt brp
        ;;

        ld8        t0 = [t0]
        ;;
        cmp.eq     pt2 = t0, t1
        ;;

        nop.m      0
 (pt2)  mov        v0 = 1
        br.ret.sptk brp

        LEAF_EXIT(KeInvalidAccessAllowed)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\tests\npxstres\i386\fpexception.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    fpexception.h

Abstract:

    This header contains prototypes for testing i386 floating point exceptions.

Author:

Environment:

    User mode only.

Revision History:

--*/

//
// Public things
//
typedef VOID (*PFN_FPX_CALLBACK_FUNC)(IN PVOID Context);

typedef ULONG FPXERR;

#define stOK                        1
#define stMISSING_EXCEPTION         2
#define stBAD_EIP                   3
#define stBAD_TAG                   4
#define stSPURIOUS_EXCEPTION        5
#define stMISSING_EXCEPTION_FOUND   6
#define stEXCEPTION_IN_HANDLER      7

typedef struct {

    double  Ftag;
    double  FtagBad;
    UINT    ExpectedExceptionEIP;
    UINT    ExceptionEIP;
    UINT    BadEip;
    FPXERR  status;

} FP_THREAD_DATA, *PFP_THREAD_DATA;

VOID
FPxInit(
    OUT  PFP_THREAD_DATA FpThreadData
    );

FPXERR
FPxTestExceptions(
    IN      UINT                    Tag,
    IN      PFN_FPX_CALLBACK_FUNC   CallbackFunction,
    IN OUT  PFP_THREAD_DATA         FpThreadData,
    IN OUT  PVOID                   Context
    );

//
// Private things
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\tests\npxstres\i386\kmode.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    kmode.c

Abstract:

    This module contains code to cause KMode NPx accesses

Author:

Environment:

    User mode only.

Revision History:

--*/

#include "pch.h"

VOID
KModeTouchNpx(
    VOID
    )
{
    BOOLEAN bSuccess;

    bSuccess = KModeTouchNpxViaDSound();

    if (bSuccess == FALSE) {

        exit(1);
    }
}


BOOLEAN
KModeTouchNpxViaDSound(
    VOID
    )
{
    LPDIRECTSOUND ds;
    LPDIRECTSOUNDBUFFER dsc;
    DSBUFFERDESC dsbc;
    WAVEFORMATEX wfx;
    HRESULT hr;
    BYTE    x[1024];
    PBYTE   y;
    int i;

    ZeroMemory(&wfx, sizeof(wfx));

    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nBlockAlign = 4;
    wfx.wBitsPerSample = 4;
    wfx.nSamplesPerSec = 44100;
    wfx.nAvgBytesPerSec = 44100 * 4;
    wfx.nChannels = 2;
    wfx.cbSize = 0;

    ds = NULL;
    dsc = NULL;

    memcpy(x, &wfx, sizeof(wfx));
    y = x + sizeof(wfx);

    for(i=0; i<200; i++) {
        *y = (BYTE) i;
        y++;
    }

    hr = DirectSoundCreate(NULL, &ds, NULL);

    if (ds == NULL) {
        fprintf(stderr, "DirectSoundCreate failed?!\n");
        return FALSE;
    }

    hr = ds->lpVtbl->SetCooperativeLevel(ds, GetDesktopWindow(), DSSCL_NORMAL);

    ZeroMemory(&dsbc, sizeof(dsbc));
    dsbc.dwBufferBytes = 10000;
    dsbc.dwFlags = 0;
    dsbc.dwSize = sizeof(dsbc);
    dsbc.lpwfxFormat = (LPWAVEFORMATEX) x;

    hr = ds->lpVtbl->CreateSoundBuffer(ds, &dsbc, &dsc, NULL);

    if (dsc) {

        hr = dsc->lpVtbl->Play(dsc, 0, 0, 0);
        dsc->lpVtbl->Release(dsc);
    }

    if (ds) {

        ds->lpVtbl->Release(ds);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\tests\npxstres\i386\fpexception.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    fpexception.c

Abstract:

    This module contains code to test i386 floating point exceptions.

Author:

Environment:

    User mode only.

Revision History:

--*/

#include "pch.h"

VOID
FPxInit(
    OUT  PFP_THREAD_DATA FpThreadData
    )
/*++

Routine Description:

    Initializes FPU state to known values.

Arguments:

    FpThreadData - FP thread data.

Return Value:

    None.

--*/
{
    USHORT cw = 0x27B;

    //
    // Fill in the initial thread values.
    //
    FpThreadData->FtagBad = 99.999;
    FpThreadData->ExpectedExceptionEIP = 0xbad;
    FpThreadData->ExceptionEIP = 0xbad;
    FpThreadData->BadEip = 1;
    FpThreadData->status = stOK;

    // unmask zero divide exception

    _asm {
        fninit
        fldcw   [cw]
    }
}


VOID
FPxLoadTag(
    IN OUT  PFP_THREAD_DATA FpThreadData,
    IN      UINT            Tag
    )
/*++

Routine Description:

    Loads a semi-unique tag value into the Npx for later validation.

Arguments:

    FpThreadData - FP thread data.

    Tag - Tag to load.

Return Value:

    None.

--*/
{
    double localCopy;

    FpThreadData->Ftag = localCopy = Tag * 1.41415926e3;

    _asm fld    [localCopy]
}


VOID
FPxPendDivideByZero(
    VOID
    )
/*++

Routine Description:

    Loads a divide-by-zero pending exception into the Npx.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _asm {

        fld1
        fldz
        fdiv
    }
}


VOID
FPxDrain(
    IN OUT  PFP_THREAD_DATA FpThreadData
    )
/*++

Routine Description:

    Drains any pending exceptions in the Npx.

Arguments:

    FpThreadData - Updated with what should be the address of the pending
                   exception.

Return Value:

    None.

--*/
{
    UINT localExceptionEIP;

    _asm {
        mov localExceptionEIP, offset ExcAddr
    }

    FpThreadData->ExpectedExceptionEIP = localExceptionEIP;

    _asm {

      ExcAddr:
        fldpi
    }
}


FPXERR
FPxCheckTag(
    IN OUT  PFP_THREAD_DATA FpThreadData
    )
/*++

Routine Description:

    Makes sure the tag value that we loaded earlier is still present.

Arguments:

    FpThreadData - Used to retrieve expected tag, updated with current Npx tag.

Return Value:

    stOK if the tag is good, stBadTag if there's a mismatch.

--*/
{
    FPXERR rc = stOK;
    double localTagCopy, localBadTagCopy;

    //
    // We don't do an assignment here as we don't want to touch the FPU
    //
    memcpy(&localTagCopy, &FpThreadData->Ftag, sizeof(double));

    _asm {

        fnclex
        ffree   st(0)               ; move the tag to the top of stack
        ffree   st(1)
        fincstp
        fincstp
        fcomp   [localTagCopy]      ; is it our tag?
        fnstsw  ax
        sahf
        je  Ex

        mov     [rc], stBAD_TAG     ; not our tag!
        fst     [localBadTagCopy]
        fwait
      Ex:
    }

    //
    // We don't do an assignment here as we don't want to touch the FPU
    //
    memcpy(&FpThreadData->FtagBad, &localBadTagCopy, sizeof(double));

    return rc;
}


EXCEPTION_DISPOSITION
FPxUnexpectedExceptionFilter(
    IN      LPEXCEPTION_POINTERS    ExcInfo,
    IN OUT  PFP_THREAD_DATA         FpThreadData
    )
/*++

Routine Description:

    This handler is called when an Npx exception we *don't* expect occurs.

Arguments:

    ExcInfo - Exception record info.

    FpThreadData - Used to retrieve expected tag, updated with current Npx tag.

Return Value:

    How to handle the exception.

--*/
{
    FpThreadData->ExceptionEIP = ExcInfo->ContextRecord->Eip;
    return EXCEPTION_EXECUTE_HANDLER;
}


EXCEPTION_DISPOSITION
FPxExpectedExceptionFilter(
    IN      LPEXCEPTION_POINTERS    ExcInfo,
    IN OUT  PFP_THREAD_DATA         FpThreadData
    )
/*++

Routine Description:

    This handler is called when an Npx exception we *do* expect occurs.

Arguments:

    ExcInfo - Exception record info.

    FpThreadData - Used to retrieve expected tag, updated with current Npx tag.

Return Value:

    How to handle the exception.

--*/
{
    if (ExcInfo->ContextRecord->Eip != FpThreadData->ExpectedExceptionEIP) {

        FpThreadData->BadEip = ExcInfo->ContextRecord->Eip;
        FpThreadData->status = stBAD_EIP;

    } else {

        FpThreadData->status = stOK;

    }

    return EXCEPTION_EXECUTE_HANDLER;
}


FPXERR
FPxTestExceptions(
    IN      UINT                    Tag,
    IN      PFN_FPX_CALLBACK_FUNC   CallbackFunction,
    IN OUT  PFP_THREAD_DATA         FpThreadData,
    IN OUT  PVOID                   Context
    )
/*++

Routine Description:

    This handler tests NPX exceptions.

Arguments:

    Tag - Tag to test the FPU with.

    CallbackFunction - Called back between exception load and exception drains.
                       Must *not* access FPU in user mode as this will trash
                       loaded FPU state.

    FpThreadData - Cache of FPU information. Should be preinitialized with
                   FPxInit before the first call to this function. Does not
                   need to be preinited before subsequent invocations.

    Context - Context for callback func.

Return Value:

    FPXERR result.

--*/
{
    __try {

        //
        // Tag the Npx
        //
        FPxLoadTag(FpThreadData, Tag);

        __try {

            //
            // generate pending exception
            //
            FPxPendDivideByZero();

        } __except(FPxUnexpectedExceptionFilter(GetExceptionInformation(),
                                                FpThreadData)) {

            FpThreadData->status = stSPURIOUS_EXCEPTION;
        }

        if (FpThreadData->status == stOK) {

            //
            // Invoke the callback function.
            //
            CallbackFunction(Context);

            //
            // Drain the exception that should still be pending.
            //
            FPxDrain(FpThreadData);

            //
            // We shouldn't get here.
            //
            FpThreadData->status = stMISSING_EXCEPTION;
        }

    } __except(FPxExpectedExceptionFilter(GetExceptionInformation(),
                                          FpThreadData)) {

        if (FpThreadData->status == stOK) {

            __try {

                //
                // ST(2) should still have our tag value
                //
                FpThreadData->status = FPxCheckTag(FpThreadData);

            } __except(FPxUnexpectedExceptionFilter(GetExceptionInformation(),
                                                    FpThreadData)) {

                FpThreadData->status = stEXCEPTION_IN_HANDLER;
            }
        }
    }

    if (FpThreadData->status == stMISSING_EXCEPTION) {

        __try {

            FPxDrain(FpThreadData);
            FPxDrain(FpThreadData);

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            FpThreadData->status = stMISSING_EXCEPTION_FOUND;
        }
    }

    return FpThreadData->status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\tests\npxstres\i386\npxstres.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    npxstres.c

Abstract:

    This test validates Npx state management and Npx exception handling.

Author:

Environment:

    User mode only.

Revision History:

--*/

#include "pch.h"

int
_cdecl
main(
    int     argc,
    char    **argv
    )
/*++

Routine Description:

    Main function for npxstres.exe

Arguments:

    argc - Argument count

    argv - Argument array

Return Value:

    zero for success, nonzero for non low resource failures.

--*/
{
    HANDLE *hThreadArray;
    DWORD dwThreadId, i, threadCount;
    TEST_INFO testInfo;
    FILE *handle;

    printf("Npxstres.exe <threads>\n  (returns errmask, zero if none)\n\n");

    if (argc > 1) {

        threadCount = atoi(argv[1]);

    } else {

        threadCount = DEF_NUM_THREADS;
    }

    hThreadArray = (HANDLE *) malloc(sizeof(HANDLE)*threadCount);

    if (hThreadArray == NULL) {

        printf("Insufficient memory to test\n");
        return 0;
    }

    __try {

        InitializeCriticalSection(&testInfo.Crit);

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        printf("Insufficient memory to test\n");
        return 0;
    }

    printf("Running FPU tests using %d threads", threadCount);

    testInfo.FailureFlags = 0;

    DoFpPreinitTest(&testInfo, 0);

    for(i=0; i<threadCount; i++) {

        hThreadArray[i] = CreateThread(
            NULL,
            0,
            FpThread,
            (LPVOID) &testInfo,
            0,
            &dwThreadId
            );
    }

    WaitForMultipleObjects(threadCount, hThreadArray, TRUE, INFINITE);

    DeleteCriticalSection(&testInfo.Crit);

    for (i=0; i<threadCount; i++) {

        CloseHandle(hThreadArray[i]);
    }

    handle = testInfo.FailureFlags ? stderr : stdout;

    fprintf(handle, "\n\n\n");
    fprintf(handle, "Test Summary:\n");
    fprintf(handle, "-------------\n");
    PrintResult(handle, "Dirty preinit test:", &testInfo, FAILURECASE_DIRTY_PREINIT);
    PrintResult(handle, "Clean preinit test:", &testInfo, FAILURECASE_CLEAN_PREINIT);
    PrintResult(handle, "Control test:", &testInfo, FAILURECASE_CONTROL_CORRUPTION);
    PrintResult(handle, "Status test:", &testInfo, FAILURECASE_STATUS_CORRUPTION);
    PrintResult(handle, "STx test:", &testInfo, FAILURECASE_STX_CORRUPTION);
    PrintResult(handle, "Pending thrash test:", &testInfo, FAILURECASE_SPIN_PEND);
    PrintResult(handle, "Pending sleep test:", &testInfo, FAILURECASE_SLEEP_PEND);
    PrintResult(handle, "Pending API test:", &testInfo, FAILURECASE_API_PEND);

    free(hThreadArray);

    exit(testInfo.FailureFlags);
}


VOID
PrintResult(
    IN  FILE        *Handle,
    IN  LPTSTR      TestText,
    IN  PTEST_INFO  TestInfo,
    IN  ULONG       FailureFlags
    )
{
    fprintf(Handle, "%20s", TestText);

    if (TestInfo->FailureFlags & FailureFlags) {

        fprintf(Handle, "FAILED\n");

    } else {

        fprintf(Handle, "Pass\n");
    }
}


VOID
SetFailureFlag(
    IN OUT  PTEST_INFO  TestInfo,
    IN      ULONG       FailureFlags
    )
{
    EnterCriticalSection(&TestInfo->Crit);
    TestInfo->FailureFlags |= FailureFlags;
    LeaveCriticalSection(&TestInfo->Crit);
}


DWORD
WINAPI
FpThread(
    LPVOID  Parameter
    )
{
    DWORD i;
    PTEST_INFO pTestInfo;

    pTestInfo = (PTEST_INFO) Parameter;

    printf(".");
    DoFpPreinitTest(pTestInfo, PREINIT_FLAG_CLEANTHREAD);
    printf(".");
    DoFpControlCorruptionTest(pTestInfo);
    printf(".");
    DoFpStatusCorruptionTest(pTestInfo);
    printf(".");
    DoFpSt0CorruptionTest(pTestInfo);
    printf(".");
    DoPendingExceptionTest(pTestInfo, EXCEPTIONTEST_FLAG_SPIN, FAILURECASE_SPIN_PEND);
    printf(".");
    DoPendingExceptionTest(pTestInfo, EXCEPTIONTEST_FLAG_SLEEP, FAILURECASE_SLEEP_PEND);
    printf(".");
    DoPendingExceptionTest(pTestInfo, EXCEPTIONTEST_FLAG_CALL_KERNEL_FP, FAILURECASE_API_PEND);

    return 0;
}


VOID
DoPendingExceptionTest(
    IN  PTEST_INFO  TestInfo,
    IN  ULONG       ExceptionTestFlags,
    IN  ULONG       FailureCode
    )
{
    unsigned int i, count;
    FPXERR status;
    FP_THREAD_DATA fpThreadData;

    count = (ExceptionTestFlags & EXCEPTIONTEST_FLAG_SPIN) ? 200000 : 20000;

    FPxInit(&fpThreadData);

    for (i = 0; i < count; ++i) {

        status = FPxTestExceptions(i,
                                   FPxTestCallback,
                                   &fpThreadData,
                                   &ExceptionTestFlags);

        if (status != stOK) {

            fprintf(stderr, "\n\nNpx Exception Test Failed:\n");

            switch (status) {
                case stMISSING_EXCEPTION:
                    fprintf(stderr, "Missing exception\n");
                    break;

                case stMISSING_EXCEPTION_FOUND:
                    fprintf(stderr, "Exception delayed unexpectedly\n");
                    break;

                case stBAD_EIP:
                    fprintf(stderr, "Unexpected exception at %08x (expected: %08x)\n", fpThreadData.BadEip, fpThreadData.ExpectedExceptionEIP);
                    break;

                case stBAD_TAG:
                    fprintf(stderr, "Bad tag value. Expected: %e  Received: %e\n", fpThreadData.Ftag, fpThreadData.FtagBad);
                    break;

                case stSPURIOUS_EXCEPTION:
                    fprintf(stderr, "Unexpected Exception at: %08x\n", fpThreadData.ExceptionEIP);
                    break;

                case stEXCEPTION_IN_HANDLER:
                    fprintf(stderr, "Exception in exception handler at: %08x\n", fpThreadData.ExceptionEIP);
                    break;

                default:
                    fprintf(stderr, "Unknown status\n");
                    break;
            }

            SetFailureFlag(TestInfo, FailureCode);
            return;
        }
    }
}


VOID
DoFpControlCorruptionTest(
    IN OUT  PTEST_INFO  TestInfo
    )
{
    int i;
    unsigned short cw1, cw2;
    int troubledetected;

    troubledetected = 0;

    for(i = 0; i < 250; i++) {

        // unmask zero divide exception
        _asm {

            fnstcw  [cw1]
            xor [cw1], 4
            fldcw   [cw1]
        }

        KModeTouchNpx();

        _asm {

            fnstcw  [cw2]
        }

        if (cw1 != cw2) {

            troubledetected = 1;
            break;
        }

        //fprintf(stderr, "Control pass %d.\n", i);
    }

    if (troubledetected) {

        fprintf(stderr, "\n\nFP control corruption detected.\n");
        SetFailureFlag(TestInfo, FAILURECASE_CONTROL_CORRUPTION);
    }
}


VOID
DoFpStatusCorruptionTest(
    IN OUT  PTEST_INFO  TestInfo
    )
{
    int i;
    unsigned short sw1, sw2;
    int troubledetected;

    troubledetected = 0;

    for(i = 0; i < 250; i++) {

        _asm {

            fnstsw  [sw1]
        }

        KModeTouchNpx();

        _asm {

            fnstsw  [sw2]
        }

        if (sw1 != sw2) {

            troubledetected = 1;
            break;
        }

        //fprintf(stderr, "Status pass %d.\n", i);
    }

    if (troubledetected) {

        fprintf(stderr, "\n\nFP status corruption detected.\n");
        SetFailureFlag(TestInfo, FAILURECASE_STATUS_CORRUPTION);
    }
}


VOID
DoFpSt0CorruptionTest(
    IN OUT  PTEST_INFO  TestInfo
    )
{
    int i;
    unsigned short sw;
    int troubledetected;

    troubledetected = 0;

    //
    // This particular test is somewhat hoaky is in theory ST0 isn't callee
    // save. However, we know exactly what the below API does, so in this case
    // it's valid.
    //
    for(i = 0; i < 250; i++) {

        switch(i%3) {
            case 0:
                _asm {

                    fld1
                    fld1
                }
                break;

            case 1:
                _asm {

                    fldpi
                    fldpi
                }
                break;

            case 2:
                _asm {

                    fldz
                    fldz
                }
                break;
        }

        KModeTouchNpx();

        _asm {

            fucom
            fstsw   [sw]
        }

        if (!(sw & 0x4000)) {

            troubledetected = 1;
        }

        switch(i%3) {
            case 0:
                _asm fld1
                break;

            case 1:
                _asm fldpi
                break;

            case 2:
                _asm fldz
                break;
        }

        _asm {

            fucom
            fstsw   [sw]
        }

        if (!(sw & 0x4000)) {

            troubledetected = 1;
        }

        if (troubledetected) {

            break;
        }

        //fprintf(stderr, "STx pass %d.\n", i);
    }

    if (troubledetected) {
        fprintf(stderr, "\n\nFP register corruption detected.\n");
        SetFailureFlag(TestInfo, FAILURECASE_STX_CORRUPTION);
    }
}


VOID
DoFpPreinitTest(
    IN OUT  PTEST_INFO  TestInfo,
    IN      ULONG       PreInitTestFlags
    )
{
    unsigned short cw, sw;
    ULONG failureCode;

    failureCode = (PreInitTestFlags & PREINIT_FLAG_CLEANTHREAD) ?
        FAILURECASE_CLEAN_PREINIT : FAILURECASE_DIRTY_PREINIT;

    //
    // No FP should be used at this point.
    //
    KModeTouchNpx();

    _asm {

        fnstcw  [cw]
        fnstsw  [sw]
    }

    if (cw != 0x27F) {

        fprintf(
            stderr,
            "\n\nPre-init corruption detected, incorrect precision in control word (cw = %x)\n",
            cw
            );

        SetFailureFlag(TestInfo, failureCode);
        return;
    }

    if ((PreInitTestFlags&PREINIT_FLAG_CLEANTHREAD) && (sw != 0)) {

        fprintf(
            stderr,
            "\n\nPre-init corruption detected, status word should be zero on a clean thread (sw = %x)\n",
            sw
            );

        SetFailureFlag(TestInfo, failureCode);
        return;
    }
}


VOID
FPxTestCallback(
    IN  PVOID   Context
    )
{
    ULONG exceptionTestFlags;
    unsigned int j;

    exceptionTestFlags = *((PULONG) Context);

    if (exceptionTestFlags & EXCEPTIONTEST_FLAG_SLEEP) {

        //
        // Release time slice
        //
        Sleep(0);
    }

    if (exceptionTestFlags & EXCEPTIONTEST_FLAG_CALL_KERNEL_FP) {

        //
        // Use FP in K-Mode
        //
        KModeTouchNpx();
    }

    if (exceptionTestFlags & EXCEPTIONTEST_FLAG_SPIN) {

        j=0x1000;
        while(j) j--;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\tests\npxstres\i386\npxstres.h ===
#ifndef _NPXSTRES_H_
#define _NPXSTRES_H_

//
// Default number of threads to create
//
#define DEF_NUM_THREADS     10

//
// This flag is set when it is known the thread has never done FP. In all cases
// the control word should be set properly (0x27F). If the thread is clean the
// status word should be zero.
//
#define PREINIT_FLAG_CLEANTHREAD            0x00000001

#define EXCEPTIONTEST_FLAG_SLEEP            0x00000001
#define EXCEPTIONTEST_FLAG_CALL_KERNEL_FP   0x00000002
#define EXCEPTIONTEST_FLAG_SPIN             0x00000004

typedef struct {

    CRITICAL_SECTION    Crit;
    ULONG               FailureFlags;

} TEST_INFO, *PTEST_INFO;

#define FAILURECASE_DIRTY_PREINIT           0x00000001
#define FAILURECASE_CLEAN_PREINIT           0x00000002
#define FAILURECASE_CONTROL_CORRUPTION      0x00000004
#define FAILURECASE_STATUS_CORRUPTION       0x00000008
#define FAILURECASE_STX_CORRUPTION          0x00000010
#define FAILURECASE_SPIN_PEND               0x00000020
#define FAILURECASE_SLEEP_PEND              0x00000040
#define FAILURECASE_API_PEND                0x00000080

VOID
DoFpPreinitTest(
    IN OUT  PTEST_INFO  TestInfo,
    IN      ULONG       PreInitTestFlags
    );

VOID
DoFpControlCorruptionTest(
    IN OUT  PTEST_INFO  TestInfo
    );

VOID
DoFpStatusCorruptionTest(
    IN OUT  PTEST_INFO  TestInfo
    );

VOID
DoPendingExceptionTest(
    IN  PTEST_INFO  TestInfo,
    IN  ULONG       ExceptionTestFlags,
    IN  ULONG       FailureCode
    );

VOID
DoFpSt0CorruptionTest(
    IN OUT  PTEST_INFO  TestInfo
    );

DWORD
WINAPI
FpThread(
    LPVOID  Parameter
    );

VOID
PrintResult(
    IN  FILE        *Handle,
    IN  LPTSTR      TestText,
    IN  PTEST_INFO  TestInfo,
    IN  ULONG       FailureFlags
    );

VOID
SetFailureFlag(
    IN OUT  PTEST_INFO  TestInfo,
    IN      ULONG       FailureFlags
    );

VOID
FPxTestCallback(
    IN  PVOID   Context
    );

#endif // _NPXSTRESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\tests\npxstres\i386\kmode.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    kmode.c

Abstract:

    This header exposes prototypes that cause KMode NPx access

Author:

Environment:

    User mode only.

Revision History:

--*/

//
// Public things
//

VOID
KModeTouchNpx(
    VOID
    );

//
// Private things
//

BOOLEAN
KModeTouchNpxViaDSound(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\tests\npxstres\i386\pch.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\tests\x86div\i386\test.c ===
/*****************************************************************/ 
/**		     Microsoft LAN Manager			**/ 
/**	       Copyright(c) Microsoft Corp., 1988-1991		**/ 
/*****************************************************************/ 

#include <stdio.h>
#include <process.h>
#include <setjmp.h>

#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

// declare a BSS value - see what the assemble looks like

CONTEXT     RegContext;
ULONG       DefaultValue;
ULONG       TestCount;
ULONG       ExpectedException;

extern  ULONG   DivOperand;
extern  ULONG   DivRegPointer;
extern  LONG    DivRegScaler;
extern  ULONG   ExceptEip;
extern  ULONG   ExceptEsp;
extern  ULONG   TestTable[];
extern  ULONG   TestTableCenter[];
#define TESTTABLESIZE    (128*sizeof(ULONG))

extern  TestDiv();

BOOLEAN vInitialized;
ULONG   vZero = 0;
ULONG   vTwo  = 0;
ULONG   vDivOk = 0x7f7f7f7f;


VOID __cdecl
main (argc, argv)
int     argc;
char    *argv[];
{

    /***
     *  This program tests the kernel's MOD/RM & SIB decoding of
     *  a processor trap 0.  The kernel needs to crack the MOD/RM & SIB
     *  on a div to determine if the exception is a divide_by_zero
     *  or an overflow execption.
     */

    try {
        //
        // Setup for divide by zero test
        //

        DivOperand = 0;
        DivRegScaler = 0;
        DivRegPointer = TestTableCenter;
        DefaultValue = 0x01010101;
        ExpectedException = STATUS_INTEGER_DIVIDE_BY_ZERO;

        printf ("Begin divide by zero test\n");

        for (DivRegScaler = -7; DivRegScaler <  7; DivRegScaler++) {
            vInitialized = FALSE;
            TestDiv ();
        }

        printf ("End divide by zero test\n\n");

        //
        // Setup for divide overflow test
        //

        DivOperand = 2;
        DivRegPointer = TestTableCenter;
        DefaultValue = 0;
        ExpectedException = STATUS_INTEGER_OVERFLOW;

        printf ("Begin divide overflow test\n");

        for (DivRegScaler = -7; DivRegScaler < 7; DivRegScaler++) {
            vInitialized = FALSE;
            TestDiv ();
        }
        printf ("End divide overflow test\n\n");

    } except (HandleException(GetExceptionInformation())) {
        printf ("FAIL: in divide by zero exception handler");
    }

    printf ("%ld varations run ", TestCount);
}

HandleException (
    IN PEXCEPTION_POINTERS ExceptionPointers
    )
{
    ULONG       i;
    PUCHAR      p;
    PCONTEXT    Context;
    ULONG       def;

    switch (i = ExceptionPointers->ExceptionRecord->ExceptionCode) {
        case 1:
            Context = ExceptionPointers->ContextRecord;
            Context->Eip = ExceptEip;
            Context->Esp = ExceptEsp;

            if (vInitialized) {
                printf ("Divide failed - div instruction completed\n");
                return EXCEPTION_CONTINUE_SEARCH;   // to debugger
            }
            vInitialized = TRUE;
            TestCount--;
            // fall through...

        case STATUS_INTEGER_OVERFLOW:
        case STATUS_INTEGER_DIVIDE_BY_ZERO:
            if (i != ExpectedException  &&  i != 1) {
                break;
            }

            TestCount++;

            // set context
            def = DefaultValue;
            Context = ExceptionPointers->ContextRecord;
            Context->Eax = def;
            Context->Ebx = def;
            Context->Ecx = def;
            Context->Edx = def;
            Context->Esi = def;
            Context->Edi = def;
            Context->Ebp = def;

            // find next test
            for (p = (PUCHAR) Context->Eip; ((PULONG) p)[0] != 0xCCCCCCCC; p++) ;
            Context->Eip = (ULONG) (p + 4);

            // clear global testable
            RtlFillMemoryUlong (TestTable, TESTTABLESIZE, def);
            return EXCEPTION_CONTINUE_EXECUTION;
    }

    printf ("\nFailed - unexpected exception code %lx  (expected %lx)\n",
        ExceptionPointers->ExceptionRecord->ExceptionCode,
        ExpectedException
        );

    return EXCEPTION_CONTINUE_SEARCH;
}




DivMarker()
{
    EXCEPTION_RECORD ExceptionRecord;

    //
    // Construct an exception record.
    //

    ExceptionRecord.ExceptionCode    = 1;
    ExceptionRecord.ExceptionRecord  = (PEXCEPTION_RECORD)NULL;
    ExceptionRecord.NumberParameters = 0;
    ExceptionRecord.ExceptionFlags   = 0;
    RtlRaiseException(&ExceptionRecord);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\tests\npxstres\i386\pch.h ===
#include <windows.h>
#include <stdio.h>
#include <mmsystem.h>
#include <dsound.h>
#include "npxstres.h"
#include "fpexception.h"
#include "kmode.h"

//#define  WAVE_FORMAT_PCM                        0x0001 /* Microsoft Corporation */
#define  WAVE_FORMAT_ALAW                       0x0006 /* Microsoft Corporation */
#define  WAVE_FORMAT_ADPCM                      0x0002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\tests\xcphnd\xcpt4.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    xcpt4.c

Abstract:

    This module implements user mode exception tests.

Author:

    David N. Cutler (davec) 18-Sep-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "stdio.h"
#include "nt.h"
#include "ntrtl.h"
#include "setjmpex.h"

#include "float.h"

#pragma warning(disable:4532)

//
// Define switch constants.
//

#define BLUE 0
#define RED 1

//
// Define function prototypes.
//

VOID
addtwo (
    IN LONG First,
    IN LONG Second,
    IN PLONG Place
    );

VOID
bar1 (
    IN NTSTATUS Status,
    IN PLONG Counter
    );

VOID
bar2 (
    IN PLONG BlackHole,
    IN PLONG BadAddress,
    IN PLONG Counter
    );

VOID
dojump (
    IN jmp_buf JumpBuffer,
    IN PLONG Counter
    );

LONG
Echo(
    IN LONG Value
    );

VOID
eret (
    IN NTSTATUS Status,
    IN PLONG Counter
    );

VOID
except1 (
    IN PLONG Counter
    );

ULONG
except2 (
    IN PEXCEPTION_POINTERS ExceptionPointers,
    IN PLONG Counter
    );

ULONG
except3 (
    IN PEXCEPTION_POINTERS ExceptionPointers,
    IN PLONG Counter
    );

VOID
foo1 (
    IN NTSTATUS Status
    );

VOID
foo2 (
    IN PLONG BlackHole,
    IN PLONG BadAddress
    );

VOID
fret (
    IN PLONG Counter
    );

BOOLEAN
Tkm (
    VOID
    );

VOID
Test61Part2 (
    IN OUT PULONG Counter
    );

VOID
PerformFpTest(
    VOID
    );

double
SquareDouble (
    IN double   op
    );

VOID
SquareDouble17E300 (
    OUT PVOID   ans
    );


VOID
__cdecl
main(
    int argc,
    char *argv[]
    )

{

    PLONG BadAddress;
    PCHAR BadByte;
    PLONG BlackHole;
    ULONG Index1;
    ULONG Index2 = RED;
    jmp_buf JumpBuffer;
    LONG Counter;
    EXCEPTION_RECORD ExceptionRecord;
    double  doubleresult;

    //
    // Announce start of exception test.
    //

    printf("Start of exception test\n");

    //
    // Initialize exception record.
    //

    ExceptionRecord.ExceptionCode = STATUS_INTEGER_OVERFLOW;
    ExceptionRecord.ExceptionFlags = 0;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.NumberParameters = 0;

    //
    // Initialize pointers.
    //

    BadAddress = (PLONG)NULL;
    BadByte = (PCHAR)NULL;
    BadByte += 1;
    BlackHole = &Counter;

    //
    // Simply try statement with a finally clause that is entered sequentially.
    //

    printf("    test1...");
    Counter = 0;
    try {
        Counter += 1;

    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 1;
        }
    }

    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Simple try statement with an exception clause that is never executed
    // because there is no exception raised in the try clause.
    //

    printf("    test2...");
    Counter = 0;
    try {
        Counter += 1;

    } except (Counter) {
        Counter += 1;
    }

    if (Counter != 1) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Simple try statement with an exception handler that is never executed
    // because the exception expression continues execution.
    //

    printf("    test3...");
    Counter = 0;
    try {
        Counter -= 1;
        RtlRaiseException(&ExceptionRecord);

    } except (Counter) {
        Counter -= 1;
    }

    if (Counter != - 1) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Simple try statement with an exception clause that is always executed.
    //

    printf("    test4...");
    Counter = 0;
    try {
        Counter += 1;
        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

    } except (Counter) {
        Counter += 1;
    }

    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Simple try statement with an exception clause that is always executed.
    //

    printf("    test5...");
    Counter = 0;
    try {
        Counter += 1;
        *BlackHole += *BadAddress;

    } except (Counter) {
        Counter += 1;
    }

    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Simply try statement with a finally clause that is entered as the
    // result of an exception.
    //

    printf("    test6...");
    Counter = 0;
    try {
        try {
            Counter += 1;
            RtlRaiseException(&ExceptionRecord);

        } finally {
            if (abnormal_termination() != FALSE) {
                Counter += 1;
            }
        }

    } except (Counter) {
        if (Counter == 2) {
            Counter += 1;
        }
    }

    if (Counter != 3) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Simply try statement with a finally clause that is entered as the
    // result of an exception.
    //

    printf("    test7...");
    Counter = 0;
    try {
        try {
            Counter += 1;
            *BlackHole += *BadAddress;

        } finally {
            if (abnormal_termination() != FALSE) {
                Counter += 1;
            }
        }

    } except (Counter) {
        if (Counter == 2) {
            Counter += 1;
        }
    }

    if (Counter != 3) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Simple try that calls a function which raises an exception.
    //

    printf("    test8...");
    Counter = 0;
    try {
        Counter += 1;
        foo1(STATUS_ACCESS_VIOLATION);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
    }

    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Simple try that calls a function which raises an exception.
    //

    printf("    test9...");
    Counter = 0;
    try {
        Counter += 1;
        foo2(BlackHole, BadAddress);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
    }

    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Simple try that calls a function which calls a function that
    // raises an exception. The first function has a finally clause
    // that must be executed for this test to work.
    //

    printf("    test10...");
    Counter = 0;
    try {
        bar1(STATUS_ACCESS_VIOLATION, &Counter);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter -= 1;
    }

    if (Counter != 98) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Simple try that calls a function which calls a function that
    // raises an exception. The first function has a finally clause
    // that must be executed for this test to work.
    //

    printf("    test11...");
    Counter = 0;
    try {
        bar2(BlackHole, BadAddress, &Counter);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter -= 1;
    }

    if (Counter != 98) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A try within an except
    //

    printf("    test12...");
    Counter = 0;
    try {
        foo1(STATUS_ACCESS_VIOLATION);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
        try {
            foo1(STATUS_SUCCESS);

        } except ((GetExceptionCode() == STATUS_SUCCESS) ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            if (Counter != 1) {
                printf("failed, count = %d\n", Counter);

            } else {
                printf("succeeded...");
            }

            Counter += 1;
        }
    }

    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A try within an except
    //

    printf("    test13...");
    Counter = 0;
    try {
        foo2(BlackHole, BadAddress);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
        try {
            foo1(STATUS_SUCCESS);

        } except ((GetExceptionCode() == STATUS_SUCCESS) ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            if (Counter != 1) {
                printf("failed, count = %d\n", Counter);

            } else {
                printf("succeeded...");
            }

            Counter += 1;
        }
    }

    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A goto from an exception clause that needs to pass
    // through a finally
    //

    printf("    test14...");
    Counter = 0;
    try {
        try {
            foo1(STATUS_ACCESS_VIOLATION);

        } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            Counter += 1;
            goto t9;
        }

    } finally {
        Counter += 1;
    }

t9:;
    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A goto from an finally clause that needs to pass
    // through a finally
    //

    printf("    test15...");
    Counter = 0;
    try {
        try {
            Counter += 1;

        } finally {
            Counter += 1;
            goto t10;
        }

    } finally {
        Counter += 1;
    }

t10:;
    if (Counter != 3) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A goto from an exception clause that needs to pass
    // through a finally into the outer finally clause.
    //

    printf("    test16...");
    Counter = 0;
    try {
        try {
            try {
                Counter += 1;
                foo1(STATUS_INTEGER_OVERFLOW);

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Counter += 1;
                goto t11;
            }

        } finally {
            Counter += 1;
        }
t11:;
    } finally {
        Counter += 1;
    }

    if (Counter != 4) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A goto from an finally clause that needs to pass
    // through a finally into the outer finally clause.
    //

    printf("    test17...");
    Counter = 0;
    try {
        try {
            Counter += 1;

        } finally {
            Counter += 1;
            goto t12;
        }
t12:;
    } finally {
        Counter += 1;
    }

    if (Counter != 3) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A return from an except clause
    //

    printf("    test18...");
    Counter = 0;
    try {
        Counter += 1;
        eret(STATUS_ACCESS_VIOLATION, &Counter);

    } finally {
        Counter += 1;
    }

    if (Counter != 4) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A return from a finally clause
    //

    printf("    test19...");
    Counter = 0;
    try {
        Counter += 1;
        fret(&Counter);

    } finally {
        Counter += 1;
    }

    if (Counter != 5) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A simple set jump followed by a long jump.
    //

    printf("    test20...");
    Counter = 0;
    if (setjmp(JumpBuffer) == 0) {
        Counter += 1;
        longjmp(JumpBuffer, 1);

    } else {
        Counter += 1;
    }

    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A set jump followed by a long jump out of a finally clause that is
    // sequentially executed.
    //

    printf("    test21...");
    Counter = 0;
    if (setjmp(JumpBuffer) == 0) {
        try {
            Counter += 1;

        } finally {
            Counter += 1;
            longjmp(JumpBuffer, 1);
        }

    } else {
        Counter += 1;
    }

    if (Counter != 3) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A set jump within a try clause followed by a long jump out of a
    // finally clause that is sequentially executed.
    //

    printf("    test22...");
    Counter = 0;
    try {
        if (setjmp(JumpBuffer) == 0) {
            Counter += 1;

        } else {
            Counter += 1;
        }

    } finally {
        Counter += 1;
        if (Counter == 2) {
            Counter += 1;
            longjmp(JumpBuffer, 1);
        }
    }

    if (Counter != 5) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A set jump followed by a try/except, followed by a try/finally where
    // the try body of the try/finally raises an exception that is handled
    // by the try/excecpt which causes the try/finally to do a long jump out
    // of a finally clause. This will create a collided unwind.
    //

    printf("    test23...");
    Counter = 0;
    if (setjmp(JumpBuffer) == 0) {
        try {
            try {
                Counter += 1;
                RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

            } finally {
                Counter += 1;
                longjmp(JumpBuffer, 1);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Counter += 1;
        }

    } else {
        Counter += 1;
    }

    if (Counter != 3) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A set jump followed by a try/except, followed by a several nested
    // try/finally's where the inner try body of the try/finally raises an
    // exception that is handled by the try/except which causes the
    // try/finally to do a long jump out of a finally clause. This will
    // create a collided unwind.
    //

    printf("    test24...");
    Counter = 0;
    if (setjmp(JumpBuffer) == 0) {
        try {
            try {
                try {
                    try {
                        Counter += 1;
                        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

                    } finally {
                        Counter += 1;
                    }

                } finally {
                    Counter += 1;
                    longjmp(JumpBuffer, 1);
                }

            } finally {
                Counter += 1;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Counter += 1;
        }

    } else {
        Counter += 1;
    }

    if (Counter != 5) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A set jump followed by a try/except, followed by a try/finally which
    // calls a subroutine which contains a try finally that raises an
    // exception that is handled to the try/except.
    //

    printf("    test25...");
    Counter = 0;
    if (setjmp(JumpBuffer) == 0) {
        try {
            try {
                try {
                    Counter += 1;
                    dojump(JumpBuffer, &Counter);

                } finally {
                    Counter += 1;
                }

            } finally {
                Counter += 1;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Counter += 1;
        }

    } else {
        Counter += 1;
    }

    if (Counter != 7) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // A set jump followed by a try/except, followed by a try/finally which
    // calls a subroutine which contains a try finally that raises an
    // exception that is handled to the try/except.
    //

    printf("    test26...");
    Counter = 0;
    if (setjmp(JumpBuffer) == 0) {
        try {
            try {
                try {
                    try {
                        Counter += 1;
                        dojump(JumpBuffer, &Counter);

                    } finally {
                        Counter += 1;
                    }

                } finally {
                    Counter += 1;
                    longjmp(JumpBuffer, 1);
                }

            } finally {
                Counter += 1;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Counter += 1;
        }

    } else {
        Counter += 1;
    }

    if (Counter != 8) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Test nested exceptions.
    //

    printf("    test27...");
    Counter = 0;
    try {
        try {
            Counter += 1;
            except1(&Counter);

        } except(except2(GetExceptionInformation(), &Counter)) {
            Counter += 2;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Counter += 3;
    }

    if (Counter != 55) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Simple try that causes an integer overflow exception.
    //

    printf("    test28...");
    Counter = 0;
    try {
        Counter += 1;
        addtwo(0x7fff0000, 0x10000, &Counter);

    } except ((GetExceptionCode() == STATUS_INTEGER_OVERFLOW) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
    }

    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Simple try that raises an misaligned data exception.
    //

#ifndef i386
    printf("    test29...");
    Counter = 0;
    try {
        Counter += 1;
        foo2(BlackHole, (PLONG)BadByte);

    } except ((GetExceptionCode() == STATUS_DATATYPE_MISALIGNMENT) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
    }

    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

#endif

    //
    // Continue from a try body with an exception clause in a loop.
    //

    printf("    test30...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            if ((Index1 & 0x1) == 0) {
                continue;

            } else {
                Counter += 1;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 40;
        }

        Counter += 2;
    }

    if (Counter != 15) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Continue from a try body with an finally clause in a loop.
    //

    printf("    test31...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            if ((Index1 & 0x1) == 0) {
                continue;

            } else {
                Counter += 1;
            }

        } finally {
            Counter += 2;
        }

        Counter += 3;
    }

    if (Counter != 40) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Continue from doubly nested try body with an exception clause in a
    // loop.
    //

    printf("    test32...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 0) {
                    continue;

                } else {
                    Counter += 1;
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Counter += 10;
            }

            Counter += 2;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 20;
        }

        Counter += 3;
    }

    if (Counter != 30) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Continue from doubly nested try body with an finally clause in a loop.
    //

    printf("    test33...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 0) {
                    continue;

                } else {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
            }

            Counter += 3;

        } finally {
            Counter += 4;
        }

        Counter += 5;
    }

    if (Counter != 105) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Continue from a finally clause in a loop.
    //

    printf("    test34...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            if ((Index1 & 0x1) == 0) {
                Counter += 1;
            }

        } finally {
            Counter += 2;
            continue;
        }

        Counter += 4;
    }

    if (Counter != 25) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Continue from a doubly nested finally clause in a loop.
    //

    printf("    test35...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 0) {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
                continue;
            }

            Counter += 4;

        } finally {
            Counter += 5;
        }

        Counter += 6;
    }

    if (Counter != 75) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Continue from a doubly nested finally clause in a loop.
    //

    printf("    test36...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 0) {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
            }

            Counter += 4;

        } finally {
            Counter += 5;
            continue;
        }

        Counter += 6;
    }

    if (Counter != 115) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from a try body with an exception clause in a loop.
    //

    printf("    test37...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            if ((Index1 & 0x1) == 1) {
                break;

            } else {
                Counter += 1;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 40;
        }

        Counter += 2;
    }

    if (Counter != 3) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from a try body with an finally clause in a loop.
    //

    printf("    test38...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            if ((Index1 & 0x1) == 1) {
                break;

            } else {
                Counter += 1;
            }

        } finally {
            Counter += 2;
        }

        Counter += 3;
    }

    if (Counter != 8) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from doubly nested try body with an exception clause in a
    // loop.
    //

    printf("    test39...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    break;

                } else {
                    Counter += 1;
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Counter += 10;
            }

            Counter += 2;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 20;
        }

        Counter += 3;
    }

    if (Counter != 6) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from doubly nested try body with an finally clause in a loop.
    //

    printf("    test40...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    break;

                } else {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
            }

            Counter += 3;

        } finally {
            Counter += 4;
        }

        Counter += 5;
    }

    if (Counter != 21) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from a finally clause in a loop.
    //

    printf("    test41...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            if ((Index1 & 0x1) == 1) {
                Counter += 1;
            }

        } finally {
            Counter += 2;
            break;
        }

        Counter += 4;
    }

    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from a doubly nested finally clause in a loop.
    //

    printf("    test42...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
                break;
            }

            Counter += 4;

        } finally {
            Counter += 5;
        }

        Counter += 6;
    }

    if (Counter != 7) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from a doubly nested finally clause in a loop.
    //

    printf("    test43...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
            }

            Counter += 4;

        } finally {
            Counter += 5;
            break;
        }

        Counter += 6;
    }

    if (Counter != 11) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from a try body with an exception clause in a switch.
    //

    printf("    test44...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            if ((Index1 & 0x1) == 1) {
                break;

            } else {
                Counter += 1;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 40;
        }

        Counter += 2;
        break;
    }

    if (Counter != 0) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from a try body with an finally clause in a switch.
    //

    printf("    test45...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            if ((Index1 & 0x1) == 1) {
                break;

            } else {
                Counter += 1;
            }

        } finally {
            Counter += 2;
        }

        Counter += 3;
    }

    if (Counter != 2) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from doubly nested try body with an exception clause in a
    // switch.
    //

    printf("    test46...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    break;

                } else {
                    Counter += 1;
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Counter += 10;
            }

            Counter += 2;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 20;
        }

        Counter += 3;
    }

    if (Counter != 0) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from doubly nested try body with an finally clause in a switch.
    //

    printf("    test47...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    break;

                } else {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
            }

            Counter += 3;

        } finally {
            Counter += 4;
        }

        Counter += 5;
    }

    if (Counter != 6) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from a finally clause in a switch.
    //

    printf("    test48...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            if ((Index1 & 0x1) == 1) {
                Counter += 1;
            }

        } finally {
            Counter += 2;
            break;
        }

        Counter += 4;
    }

    if (Counter != 3) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from a doubly nested finally clause in a switch.
    //

    printf("    test49...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
                break;
            }

            Counter += 4;

        } finally {
            Counter += 5;
        }

        Counter += 6;
    }

    if (Counter != 8) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Break from a doubly nested finally clause in a switch.
    //

    printf("    test50...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
            }

            Counter += 4;

        } finally {
            Counter += 5;
            break;
        }

        Counter += 6;
    }

    if (Counter != 12) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Leave from an if in a simple try/finally.
    //

    printf("    test51...");
    Counter = 0;
    try {
        if (Echo(Counter) == Counter) {
            Counter += 3;
            leave;

        } else {
            Counter += 100;
        }

    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 5;
        }
    }

    if (Counter != 8) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Leave from a loop in a simple try/finally.
    //

    printf("    test52...");
    Counter = 0;
    try {
        for (Index1 = 0; Index1 < 10; Index1 += 1) {
            if (Echo(Index1) == Index1) {
                Counter += 3;
                leave;
            }

            Counter += 100;
        }

    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 5;
        }
    }

    if (Counter != 8) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Leave from a switch in a simple try/finally.
    //

    printf("    test53...");
    Counter = 0;
    try {
        switch (Index2) {
        case BLUE:
            break;

        case RED:
            Counter += 3;
            leave;
        }

        Counter += 100;

    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 5;
        }
    }

    if (Counter != 8) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Leave from an if in doubly nested try/finally followed by a leave
    // from an if in the outer try/finally.
    //

    printf("    test54...");
    Counter = 0;
    try {
        try {
            if (Echo(Counter) == Counter) {
                Counter += 3;
                leave;

            } else {
                Counter += 100;
            }

        } finally {
            if (abnormal_termination() == FALSE) {
                Counter += 5;
            }
        }

        if (Echo(Counter) == Counter) {
            Counter += 3;
            leave;

         } else {
            Counter += 100;
         }


    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 5;
        }
    }

    if (Counter != 16) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Leave from an if in doubly nested try/finally followed by a leave
    // from the finally of the outer try/finally.
    //

    printf("    test55...");
    Counter = 0;
    try {
        try {
            if (Echo(Counter) == Counter) {
                Counter += 3;
                leave;

            } else {
                Counter += 100;
            }

        } finally {
            if (abnormal_termination() == FALSE) {
                Counter += 5;
                leave;
            }
        }

        Counter += 100;

    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 5;
        }
    }

    if (Counter != 13) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Try/finally within the except clause of a try/except that is always
    // executed.
    //

    printf("    test56...");
    Counter = 0;
    try {
        Counter += 1;
        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

    } except (Counter) {
        try {
            Counter += 3;

        } finally {
            if (abnormal_termination() == FALSE) {
                Counter += 5;
            }
        }
    }

    if (Counter != 9) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Try/finally within the finally clause of a try/finally.
    //

    printf("    test57...");
    Counter = 0;
    try {
        Counter += 1;

    } finally {
        if (abnormal_termination() == FALSE) {
            try {
                Counter += 3;

            } finally {
                if (abnormal_termination() == FALSE) {
                    Counter += 5;
                }
            }
        }
    }

    if (Counter != 9) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Try/except within the finally clause of a try/finally.
    //
/*
    printf("    test58...");
    Counter = 0;
    try {
        Counter -= 1;

    } finally {
        try {
            Counter += 2;
            RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

        } except (Counter) {
            try {
                Counter += 3;

            } finally {
                if (abnormal_termination() == FALSE) {
                    Counter += 5;
                }
            }
        }
    }

    if (Counter != 9) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }
*/
    //
    // Try/except within the except clause of a try/except that is always
    // executed.
    //

    printf("    test59...");
    Counter = 0;
    try {
        Counter += 1;
        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

    } except (Counter) {
        try {
            Counter += 3;
            RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

        } except(Counter - 3) {
            Counter += 5;
        }
    }

    if (Counter != 9) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Try with a Try which exits the scope with a goto
    //

    printf("    test60...");
    Counter = 0;
    try {
        try {
            goto outside;

        } except(1) {
            Counter += 1;
        }

outside:
    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

    } except(1) {
        Counter += 3;
    }

    if (Counter != 3) {
        printf("failed, count = %d\n", Counter);
    } else {
        printf("succeeded\n");
    }

    //
    // Try/except which gets an exception from a subfunction within
    // a try/finally which has a try/except in the finally clause
    //

    printf("    test61...");
    Counter = 0;
    try {
        Test61Part2 (&Counter);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Counter += 11;
    }

    if (Counter != 24) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    //
    // Check for precision of floating point exception
    //

    printf("    test62...");

    /* enable floating point overflow */
    _controlfp(_controlfp(0,0) & ~EM_OVERFLOW, _MCW_EM);

    Counter = 0;
    try {
        doubleresult = SquareDouble (1.7e300);

        try {
            doubleresult = SquareDouble (1.0);

        } except (1) {
            Counter += 3;
        }

    } except (1) {
        Counter += 1;
    }

    if (Counter != 1) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    _clearfp ();

    //
    // Callout for test #63 due to bogus compiler behaviour caused by test #62.
    //

    PerformFpTest ();

    //
    // Announce end of exception test.
    //

    printf("End of exception test\n");
    return;
}

VOID
PerformFpTest()
{
    LONG Counter;
    double doubleresult;

    //
    // Check for precision of floating point exception in subfunction
    //

    printf("    test63...");

    Counter = 0;
    try {
        SquareDouble17E300 ((PVOID) &doubleresult);

        try {
            SquareDouble17E300 ((PVOID) &doubleresult);

        } except (1) {
            Counter += 3;
        }

    } except (1) {
        Counter += 1;
    }

    if (Counter != 1) {
        printf("failed, count = %d\n", Counter);

    } else {
        printf("succeeded\n");
    }

    _clearfp ();

}

VOID
addtwo (
    long First,
    long Second,
    long *Place
    )

{

    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);
    *Place = First + Second;
    return;
}

VOID
bar1 (
    IN NTSTATUS Status,
    IN PLONG Counter
    )
{

    try {
        foo1(Status);

    } finally {
        if (abnormal_termination() != FALSE) {
            *Counter = 99;

        } else {
            *Counter = 100;
        }
    }

    return;
}

VOID
bar2 (
    IN PLONG BlackHole,
    IN PLONG BadAddress,
    IN PLONG Counter
    )
{

    try {
        foo2(BlackHole, BadAddress);

    } finally {
        if (abnormal_termination() != FALSE) {
            *Counter = 99;

        } else {
            *Counter = 100;
        }
    }

    return;
}

VOID
dojump (
    IN jmp_buf JumpBuffer,
    IN PLONG Counter
    )

{

    try {
        try {
            *Counter += 1;
            RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

        } finally {
            *Counter += 1;
        }

    } finally {
        *Counter += 1;
        longjmp(JumpBuffer, 1);
    }
}

VOID
eret(
    IN NTSTATUS Status,
    IN PLONG Counter
    )

{

    try {
        try {
            foo1(Status);

        } except ((GetExceptionCode() == Status) ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            *Counter += 1;
            return;
        }

    } finally {
        *Counter += 1;
    }

    return;
}

VOID
except1 (
    IN PLONG Counter
    )

{

    try {
        *Counter += 5;
        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

    } except (except3(GetExceptionInformation(), Counter)) {
        *Counter += 7;
    }

    *Counter += 9;
    return;
}

ULONG
except2 (
    IN PEXCEPTION_POINTERS ExceptionPointers,
    IN PLONG Counter
    )

{

    PEXCEPTION_RECORD ExceptionRecord;

    ExceptionRecord = ExceptionPointers->ExceptionRecord;
    if ((ExceptionRecord->ExceptionCode == STATUS_UNSUCCESSFUL) &&
       ((ExceptionRecord->ExceptionFlags & EXCEPTION_NESTED_CALL) == 0)) {
        *Counter += 11;
        return EXCEPTION_EXECUTE_HANDLER;

    } else {
        *Counter += 13;
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

ULONG
except3 (
    IN PEXCEPTION_POINTERS ExceptionPointers,
    IN PLONG Counter
    )

{

    PEXCEPTION_RECORD ExceptionRecord;

    ExceptionRecord = ExceptionPointers->ExceptionRecord;
    if ((ExceptionRecord->ExceptionCode == STATUS_INTEGER_OVERFLOW) &&
       ((ExceptionRecord->ExceptionFlags & EXCEPTION_NESTED_CALL) == 0)) {
        *Counter += 17;
        RtlRaiseStatus(STATUS_UNSUCCESSFUL);

    } else if ((ExceptionRecord->ExceptionCode == STATUS_UNSUCCESSFUL) &&
        ((ExceptionRecord->ExceptionFlags & EXCEPTION_NESTED_CALL) != 0)) {
        *Counter += 19;
        return EXCEPTION_CONTINUE_SEARCH;
    }

    *Counter += 23;
    return EXCEPTION_EXECUTE_HANDLER;
}

VOID
foo1 (
    IN NTSTATUS Status
    )

{

    //
    // Raise exception.
    //

    RtlRaiseStatus(Status);
    return;
}

VOID
foo2 (
    IN PLONG BlackHole,
    IN PLONG BadAddress
    )

{

    //
    // Raise exception.
    //

    *BlackHole += *BadAddress;
    return;
}

VOID
fret(
    IN PLONG Counter
    )

{

    try {
        try {
            *Counter += 1;

        } finally {
            *Counter += 1;
            return;
        }
    } finally {
        *Counter += 1;
    }

    return;
}

LONG
Echo(
    IN LONG Value
    )

{
    return Value;
}

VOID
Test61Part2 (
    IN OUT PULONG Counter
    )
{

    try {
        *Counter -= 1;
        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);
    } finally {
        *Counter += 2;
        *Counter += 5;
        *Counter += 7;
    }
}


double
SquareDouble (
    IN double   op
    )
{
    return op * op;
}

VOID
SquareDouble17E300 (
    OUT PVOID   output
    )
{
    double  ans;

    ans = SquareDouble (1.7e300);
    *(double *) output = ans;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\tests\x86div\i386\testa.asm ===
;       Static Name Aliases
;
        TITLE   testa.asm
        NAME    testa

        .386p
        include callconv.inc

            EXTRNP      _DivMarker,0

_DATA   SEGMENT DWORD USE32 PUBLIC 'DATA'

        public  _DivOperand, _DivRegPointer, _DivRegScaler, _ExceptEip, _ExceptEsp
_DivOperand         dd      ?
_DivRegPointer      dd      ?
_DivRegScaler       dd      ?
_ExceptEip          dd      ?
_ExceptEsp          dd      ?

        public  _TestTable, _TestTableCenter
_TestTable          dd      64 dup (?)
_TestTableCenter    dd      64 dup (?)
_DATA   ENDS

DivTest   macro  div,reg,type,labelmod
    ;   public  &div&_&type&_&reg&labelmod      - too many labels
&div&_&type&_&reg&labelmod:
endm

endtest   macro
        call    Marker
        dd      0CCCCCCCCh              ; marker for expcetion
                                        ; handler to find next test
endm

REGDiv  macro  type, reglist
    irp reg,<reglist>
    DivTest div, reg, type, _reg
        mov     eax, 7f7f7f7fh
        mov     edx, eax
        mov     reg, type ptr _DivOperand
        div     reg
        endtest

    DivTest idiv, reg, type, _reg
        mov     eax, 7f7f7f7fh
        mov     edx, eax
        mov     reg, type ptr _DivOperand
        idiv    reg
        endtest
    endm
endm

PTRDiv  macro  typelist
    irp type,<typelist>

    DivTest div, reg, type, _ptr
        mov     edx, _DivOperand
ifidni <type>,<byte>
        mov     byte ptr _TestTableCenter, dl
else
ifidni <type>,<word>
        mov     word ptr _TestTableCenter, dx
else
        mov     dword ptr _TestTableCenter, edx
endif
endif
        mov     eax, 7f7f7f7fh
        mov     edx, eax
        div     type ptr _TestTableCenter
        endtest

    DivTest idiv, reg, type, _ptr
        mov     edx, _DivOperand
ifidni <type>,<byte>
        mov     byte ptr _TestTableCenter, dl
else
ifidni <type>,<word>
        mov     word ptr _TestTableCenter, dx
else
        mov     dword ptr _TestTableCenter, edx
endif
endif
        mov     eax, 7f7f7f7fh
        mov     edx, eax
        idiv    type ptr _TestTableCenter
        endtest
    endm
endm

REGDivP1  macro  type, offset, divpointer, labelmod, reglist
    irp reg,<reglist>
    DivTest div, reg, type, labelmod
        mov     eax, divpointer
        mov     edx, _DivOperand
ifidni <type>,<byte>
        mov     byte ptr [eax + offset], dl
else
ifidni <type>,<word>
        mov     word ptr [eax + offset], dx
else
        mov     dword ptr [eax + offset], edx
endif
endif
        mov     eax, 7f7f7f7fh
        mov     edx, eax
        mov     reg, divpointer
        div     type ptr [reg + offset]
        endtest

    DivTest idiv, reg, type, labelmod
        mov     eax, divpointer
        mov     edx, _DivOperand
ifidni <type>,<byte>
        mov     byte ptr [eax + offset], dl
else
ifidni <type>,<word>
        mov     word ptr [eax + offset], dx
else
        mov     dword ptr [eax + offset], edx
endif
endif
        mov     eax, 7f7f7f7fh
        mov     edx, eax
        mov     reg, divpointer
        idiv    type ptr [reg + offset]
        endtest
    endm
endm

REGDivSIB1  macro  type, offset, divpointer, labelmod, toscale, scaler, reglist
    irp reg,<reglist>
    DivTest div, reg, type, labelmod
        push    ebx
        mov     eax, divpointer
        mov     edx, _DivOperand
        mov     ebx, _DivRegScaler
ifidni <type>,<byte>
        mov     byte ptr [ebx * toscale + eax + offset], dl
else
ifidni <type>,<word>
        mov     word ptr [ebx * toscale + eax + offset], dx
else
        mov     dword ptr [ebx * toscale + eax + offset], edx
endif
endif
        pop     ebx
        mov     eax, 7f7f7f7fh
        mov     edx, eax
        mov     reg, divpointer
        mov     scaler, _DivRegScaler
        div     type ptr [scaler * toscale + reg + offset]
        endtest

    DivTest idiv, reg, type, labelmod
        push    ebx
        mov     eax, divpointer
        mov     edx, _DivOperand
        mov     ebx, _DivRegScaler
ifidni <type>,<byte>
        mov     byte ptr [ebx * toscale + eax + offset], dl
else
ifidni <type>,<word>
        mov     word ptr [ebx * toscale + eax + offset], dx
else
        mov     dword ptr [ebx * toscale + eax + offset], edx
endif
endif
        pop     ebx
        mov     eax, 7f7f7f7fh
        mov     edx, eax
        mov     reg, divpointer
        mov     scaler, _DivRegScaler
        idiv    type ptr [scaler * toscale + reg + offset]
        endtest
    endm
endm


REGDivP  macro  typelist, reglist
    irp type, <typelist>
        REGDivP1 type,  0, _DivRegPointer, _d, <reglist>
        REGDivP1 type,  1, _DivRegPointer, _p, <reglist>
        REGDivP1 type, -1, _DivRegPointer, _m, <reglist>
        REGDivP1 type, _TestTableCenter,  0, _rd, <reglist>
        REGDivP1 type, _TestTableCenter,  1, _rp, <reglist>
        REGDivP1 type, _TestTableCenter, -1, _rm, <reglist>
    endm
endm

REGDivSIB  macro  typelist, scaler, reglist
    irp type, <typelist>
        REGDivSIB1 type,  0, _DivRegPointer, _&scaler&_d,  1, scaler, <reglist>
        REGDivSIB1 type,  1, _DivRegPointer, _&scaler&_p,  1, scaler, <reglist>
        REGDivSIB1 type, -1, _DivRegPointer, _&scaler&_m,  1, scaler, <reglist>
        REGDivSIB1 type, _TestTableCenter,  0, _&scaler&_rd, 1, scaler, <reglist>
        REGDivSIB1 type, _TestTableCenter,  1, _&scaler&_rp, 1, scaler, <reglist>
        REGDivSIB1 type, _TestTableCenter, -1, _&scaler&_rm, 1, scaler, <reglist>
    ;---
        REGDivSIB1 type,  0, _DivRegPointer, _&scaler&_d2,  2, scaler, <reglist>
        REGDivSIB1 type,  1, _DivRegPointer, _&scaler&_p2,  2, scaler, <reglist>
        REGDivSIB1 type, -1, _DivRegPointer, _&scaler&_m2,  2, scaler, <reglist>
        REGDivSIB1 type, _TestTableCenter,  0, _&scaler&_r2d, 2, scaler, <reglist>
        REGDivSIB1 type, _TestTableCenter,  1, _&scaler&_r2p, 2, scaler, <reglist>
        REGDivSIB1 type, _TestTableCenter, -1, _&scaler&_r2m, 2, scaler, <reglist>
    ;---
        REGDivSIB1 type,  0, _DivRegPointer, _&scaler&_d4,  4, scaler, <reglist>
        REGDivSIB1 type,  1, _DivRegPointer, _&scaler&_p4,  4, scaler, <reglist>
        REGDivSIB1 type, -1, _DivRegPointer, _&scaler&_m4,  4, scaler, <reglist>
        REGDivSIB1 type, _TestTableCenter,  0, _&scaler&_r4d, 4, scaler, <reglist>
        REGDivSIB1 type, _TestTableCenter,  1, _&scaler&_r4p, 4, scaler, <reglist>
        REGDivSIB1 type, _TestTableCenter, -1, _&scaler&_r4m, 4, scaler, <reglist>
    ;---
        REGDivSIB1 type,  0, _DivRegPointer, _&scaler&_d8,  8, scaler, <reglist>
        REGDivSIB1 type,  1, _DivRegPointer, _&scaler&_p8,  8, scaler, <reglist>
        REGDivSIB1 type, -1, _DivRegPointer, _&scaler&_m8,  8, scaler, <reglist>
        REGDivSIB1 type, _TestTableCenter,  0, _&scaler&_r8d, 8, scaler, <reglist>
        REGDivSIB1 type, _TestTableCenter,  1, _&scaler&_r8p, 8, scaler, <reglist>
        REGDivSIB1 type, _TestTableCenter, -1, _&scaler&_r8m, 8, scaler, <reglist>
    endm
endm


_TEXT   SEGMENT DWORD PUBLIC USE32 'CODE'       ; Start 32 bit code
        ASSUME  CS:FLAT, DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


cPublicProc     _TestDiv

    ; save c runtime registers

            push    ebp
            push    ebx
            push    esi
            push    edi

    ; prime outer loop with initial exception
            endtest

    ; start of div test

             PTRDiv      <byte, word, dword>

             REGDiv      <byte>,  <bl,bh,cl,ch,dl,dh>
             REGDiv      <word>,  <ax,bx,cx,si,di,bp>
             REGDiv      <dword>, <ebx,ecx,edx,esi,edi,ebp>

             REGDivP     <byte>, <ebx,ecx,edx,esi,edi,ebp>
             REGDivP     <word, dword>, <eax,ebx,ecx,esi,edi,ebp>

             REGDivSIB   <byte>, <ebx>, <ecx,edx,esi,edi,ebp>
             REGDivSIB   <byte>, <ecx>, <ebx,edx,esi,edi,ebp>
             REGDivSIB   <byte>, <edx>, <ebx,ecx,esi,edi,ebp>
             REGDivSIB   <byte>, <esi>, <ebx,ecx,edx,edi,ebp>
             REGDivSIB   <byte>, <edi>, <ebx,ecx,edx,esi,ebp>
             REGDivSIB   <byte>, <ebp>, <ebx,ecx,edx,edi,esi>

             REGDivSIB   <word, dword>, <eax>, <ebx,ecx,esi,edi,ebp>
             REGDivSIB   <word, dword>, <ebx>, <eax,ecx,esi,edi,ebp>
             REGDivSIB   <word, dword>, <ecx>, <eax,ebx,esi,edi,ebp>
             REGDivSIB   <word, dword>, <esi>, <eax,ebx,ecx,edi,ebp>
             REGDivSIB   <word, dword>, <edi>, <eax,ebx,ecx,esi,ebp>
             REGDivSIB   <word, dword>, <ebp>, <eax,ebx,ecx,edi,esi>

    ; end of test

            pop     edi
            pop     esi
            pop     ebx
            pop     ebp

            stdRET  _TestDiv
stdENDP _TestDiv

cPublicProc     Marker
        pop     eax
        mov     _ExceptEip, eax
        mov     _ExceptEsp, esp
        stdCall _DivMarker
    int 3
stdENDP Marker

_TEXT   ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\up\makefile.inc ===
SERVICES_DIR=$(O)
SERVICES_TAB=$(SERVICES_DIR)\services.tab

$(SERVICES_TAB): ..\services.tab
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\sysstubs.obj: $(O)\sysstubs.$(ASM_SUFFIX)

$(O)\systable.obj: $(O)\systable.$(ASM_SUFFIX)

$(O)\sysstubs.$(ASM_SUFFIX) $(O)\systable.$(ASM_SUFFIX): $(SERVICES_TAB) ..\$(TARGET_DIRECTORY)\table.stb ..\$(TARGET_DIRECTORY)\services.stb
    gensrv -d $(O) -e $(ASM_SUFFIX) -g $(SERVICES_DIR) $(TARGET_BRACES) -s ..\$(TARGET_DIRECTORY)

#
# "nmake genxx" will generate platform-dependent include files
#

!if "$(TARGET_DIRECTORY)"=="i386"
HAL_NAME=hal386
KS_NAME=ks386

!else
HAL_NAME=hal$(TARGET_DIRECTORY)
KS_NAME=ks$(TARGET_DIRECTORY)
!endif

KS_TARGET =$(SDK_INC_PATH)\$(KS_NAME).$(ASM_INCLUDE_SUFFIX)
HAL_TARGET_PATH=$(PROJECT_INC_PATH)
HAL_TARGET=$(HAL_TARGET_PATH)\$(HAL_NAME).$(ASM_INCLUDE_SUFFIX)
HAL_TARGET_PATH_ALT=$(HALKIT_INC_PATH)
HAL_TARGET_ALT=$(HAL_TARGET_PATH_ALT)\$(HAL_NAME).$(ASM_INCLUDE_SUFFIX)
PROCESSOR_TARGET_PATH_ALT=$(PROCESSOR_INC_PATH)
PROCESSOR_TARGET_ALT=$(PROCESSOR_TARGET_PATH_ALT)\$(HAL_NAME).$(ASM_INCLUDE_SUFFIX)

KS_TARGET_OBJ=$(O)\$(KS_NAME).$(ASM_INCLUDE_SUFFIX)
HAL_TARGET_OBJ=$(O)\$(HAL_NAME).$(ASM_INCLUDE_SUFFIX)

genxx: $(KS_TARGET) $(HAL_TARGET)

#
# If the following invocation of genxx fails, make sure you have a
# current version of genxx.
#

$(KS_TARGET_OBJ) $(HAL_TARGET_OBJ): \
	..\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).m4 \
        ..\genxx.h \
        ..\genxx.inc \
        $(DDK_INC_PATH)\ntddk.h
    set PASS0ONLY=
    -mkdir $(HAL_TARGET_PATH) >nul 2>nul
    -mkdir $(O) >nul 2>nul
    -erase $(O)\gen$(TARGET_DIRECTORY).obj >nul 2>nul
    -erase $(O)\gen$(TARGET_DIRECTORY).c >nul 2>nul
    m4 < ..\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).m4 \
       > $(O)\gen$(TARGET_DIRECTORY).c
    nmake -l $(O)\gen$(TARGET_DIRECTORY).obj NTNOPCH=1 FORCENATIVEOBJECT=1
    genxx -k$(KS_TARGET_OBJ) -h$(HAL_TARGET_OBJ) -$(TARGET_DIRECTORY)

$(KS_TARGET): $(KS_TARGET_OBJ)
    $(PUBLISH_CMD) {$**=$@}

$(HAL_TARGET): $(HAL_TARGET_OBJ)
    $(PUBLISH_CMD) {$**=$@;$(HAL_TARGET_ALT);$(PROCESSOR_TARGET_ALT)}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpcclose.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpcclose.c

Abstract:

    Local Inter-Process Communication close procedures that are called when
    a connection port or a communications port is closed.

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#include "lpcp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,LpcpClosePort)
#pragma alloc_text(PAGE,LpcpDeletePort)
#pragma alloc_text(PAGE,LpcExitThread)
#endif


VOID
LpcpClosePort (
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG ProcessHandleCount,
    IN ULONG SystemHandleCount
    )

/*++

Routine Description:

    This routine is the callback used for closing a port object.

Arguments:

    Process - Supplies an optional pointer to the process whose port is being
        closed

    Object - Supplies a pointer to the port object being closed

    GrantedAccess - Supplies the access granted to the handle closing port
        object

    ProcessHandleCount - Supplies the number of process handles remaining to
        the object

    SystemHandleCount - Supplies the number of system handles remaining to
        the object

Return Value:

    None.

--*/

{
    //
    //  Translate the object to what it really is, an LPCP port object
    //

    PLPCP_PORT_OBJECT Port = Object;

    UNREFERENCED_PARAMETER (Process);
    UNREFERENCED_PARAMETER (GrantedAccess);
    UNREFERENCED_PARAMETER (ProcessHandleCount);

    //
    //  We only have work to do if the object is a server communication port
    //

    if ( (Port->Flags & PORT_TYPE) == SERVER_CONNECTION_PORT ) {

        //
        //  If this is a server communication port without any system handles
        //  then we can completely destroy the communication queue for the
        //  port
        //

        if ( SystemHandleCount == 0 ) {

            LpcpDestroyPortQueue( Port, TRUE );

        //
        //  If there is only one system handle left then we'll reset the
        //  communication queue for the port
        //

        } else if ( SystemHandleCount == 1 ) {

            LpcpDestroyPortQueue( Port, FALSE );
        }

        //
        //  Otherwise we do nothing
        //
    }

    return;
}


VOID
LpcpDeletePort (
    IN PVOID Object
    )

/*++

Routine Description:

    This routine is the callback used for deleting a port object.

Arguments:

    Object - Supplies a pointer to the port object being deleted

Return Value:

    None.

--*/

{
    PETHREAD CurrentThread;
    PLPCP_PORT_OBJECT Port = Object;
    PLPCP_PORT_OBJECT ConnectionPort;
    LPC_CLIENT_DIED_MSG ClientPortClosedDatagram;
    PLPCP_MESSAGE Msg;
    PLIST_ENTRY Head, Next;
    HANDLE CurrentProcessId;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    //
    //  If the port is a server communication port then make sure that if
    //  there is a dangling client thread that we get rid of it.  This
    //  handles the case of someone calling NtAcceptConnectPort and not
    //  calling NtCompleteConnectPort
    //

    if ((Port->Flags & PORT_TYPE) == SERVER_COMMUNICATION_PORT) {

        PETHREAD ClientThread;

        LpcpAcquireLpcpLockByThread(CurrentThread);

        if ((ClientThread = Port->ClientThread) != NULL) {

            Port->ClientThread = NULL;

            LpcpReleaseLpcpLock();

            ObDereferenceObject( ClientThread );

        } else {

            LpcpReleaseLpcpLock();
        }
    }

    //
    //  Send an LPC_PORT_CLOSED datagram to whoever is connected
    //  to this port so they know they are no longer connected.
    //

    if ((Port->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

        ClientPortClosedDatagram.PortMsg.u1.s1.TotalLength = sizeof( ClientPortClosedDatagram );
        ClientPortClosedDatagram.PortMsg.u1.s1.DataLength = sizeof( ClientPortClosedDatagram.CreateTime );

        ClientPortClosedDatagram.PortMsg.u2.s2.Type = LPC_PORT_CLOSED;
        ClientPortClosedDatagram.PortMsg.u2.s2.DataInfoOffset = 0;

        ClientPortClosedDatagram.CreateTime = PsGetCurrentProcess()->CreateTime;

        LpcRequestPort( Port, (PPORT_MESSAGE)&ClientPortClosedDatagram );
    }

    //
    //  If connected, disconnect the port, and then scan the message queue
    //  for this port and dereference any messages in the queue.
    //

    LpcpDestroyPortQueue( Port, TRUE );

    //
    //  If we had mapped sections into the server or client communication ports,
    //  we need to unmap them in the context of that process.
    //

    if ( (Port->ClientSectionBase != NULL) ||
         (Port->ServerSectionBase != NULL) ) {

        //
        //  If the client has a port memory view, then unmap it
        //

        if (Port->ClientSectionBase != NULL) {

            MmUnmapViewOfSection( Port->MappingProcess,
                                  Port->ClientSectionBase );

        }

        //
        //  If the server has a port memory view, then unmap it
        //

        if (Port->ServerSectionBase != NULL) {

            MmUnmapViewOfSection( Port->MappingProcess,
                                  Port->ServerSectionBase  );

        }

        //
        //  Removing the reference added while mapping the section
        //

        ObDereferenceObject( Port->MappingProcess );

        Port->MappingProcess = NULL;
    }

    //
    //  Dereference the pointer to the connection port if it is not
    //  this port.
    //

    LpcpAcquireLpcpLockByThread(CurrentThread);

    ConnectionPort = Port->ConnectionPort;

    if (ConnectionPort) {

        CurrentProcessId = CurrentThread->Cid.UniqueProcess;

        Head = &ConnectionPort->LpcDataInfoChainHead;
        Next = Head->Flink;

        while (Next != Head) {

            Msg = CONTAINING_RECORD( Next, LPCP_MESSAGE, Entry );
            Next = Next->Flink;

            //
            //  Test whether the message come from the same port and process
            //

            if ((Msg->Request.ClientId.UniqueProcess == CurrentProcessId)
                    &&
                ((Msg->SenderPort == Port) 
                        || 
                 (Msg->SenderPort == Port->ConnectedPort) 
                        || 
                 (Msg->SenderPort == ConnectionPort))) {

                LpcpTrace(( "%s Freeing DataInfo Message %lx (%u.%u)  Port: %lx\n",
                            PsGetCurrentProcess()->ImageFileName,
                            Msg,
                            Msg->Request.MessageId,
                            Msg->Request.CallbackId,
                            ConnectionPort ));

                RemoveEntryList( &Msg->Entry );

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED );

                //
                //  In LpcpFreeToPortZone the LPC lock is released and reacquired.
                //  Another thread might free the LPC message captured above
                //  in Next. We need to restart the search at the list head.
                //

                Next = Head->Flink;
            }
        }

        LpcpReleaseLpcpLock();

        if (ConnectionPort != Port) {

            ObDereferenceObject( ConnectionPort );
        }

    } else {

        LpcpReleaseLpcpLock();
    }

    if (((Port->Flags & PORT_TYPE) == SERVER_CONNECTION_PORT) &&
        (ConnectionPort->ServerProcess != NULL)) {

        ObDereferenceObject( ConnectionPort->ServerProcess );

        ConnectionPort->ServerProcess = NULL;
    }

    //
    //  Free any static client security context
    //

    LpcpFreePortClientSecurity( Port );

    //
    //  And return to our caller
    //

    return;
}


VOID
LpcExitThread (
    PETHREAD Thread
    )

/*++

Routine Description:

    This routine is called whenever a thread is exiting and need to cleanup the
    lpc port for the thread.

Arguments:

    Thread - Supplies the thread being terminated

Return Value:

    None.

--*/

{
    PLPCP_MESSAGE Msg;

    //
    //  Acquire the mutex that protects the LpcReplyMessage field of
    //  the thread.  Zero the field so nobody else tries to process it
    //  when we release the lock.
    //

    ASSERT (Thread == PsGetCurrentThread());

    LpcpAcquireLpcpLockByThread(Thread);

    if (!IsListEmpty( &Thread->LpcReplyChain )) {

        RemoveEntryList( &Thread->LpcReplyChain );
    }

    //
    //  Indicate that this thread is exiting
    //

    Thread->LpcExitThreadCalled = TRUE;
    Thread->LpcReplyMessageId = 0;

    //
    //  If we need to reply to a message then if the thread that we need to reply
    //  to is still around we want to dereference the thread and free the message
    //

    Msg = LpcpGetThreadMessage(Thread);

    if (Msg != NULL) {

        Thread->LpcReplyMessage = NULL;

        if (Msg->RepliedToThread != NULL) {

            ObDereferenceObject( Msg->RepliedToThread );

            Msg->RepliedToThread = NULL;
        }

        LpcpTrace(( "Cleanup Msg %lx (%d) for Thread %lx allocated\n", Msg, IsListEmpty( &Msg->Entry ), Thread ));

        LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );
    }
    else {

        //
        //  Free the global lpc mutex.
        //

        LpcpReleaseLpcpLock();
    }

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpcconn.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpcconn.c

Abstract:

    Local Inter-Process Communication (LPC) connection system services.

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#include "lpcp.h"

//
//  Local procedure prototypes
//

PVOID
LpcpFreeConMsg(
    IN PLPCP_MESSAGE *Msg,
    PLPCP_CONNECTION_MESSAGE *ConnectMsg,
    IN PETHREAD CurrentThread
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtConnectPort)
#pragma alloc_text(PAGE,NtSecureConnectPort)
#pragma alloc_text(PAGE,LpcpFreeConMsg)
#endif


NTSYSAPI
NTSTATUS
NTAPI
NtConnectPort (
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PPORT_VIEW ClientView OPTIONAL,
    IN OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    )

/*++

Routine Description:

    See NtSecureConnectPort

Arguments:

    See NtSecureConnectPort

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    return NtSecureConnectPort( PortHandle,
                                PortName,
                                SecurityQos,
                                ClientView,
                                NULL,
                                ServerView,
                                MaxMessageLength,
                                ConnectionInformation,
                                ConnectionInformationLength );
}


NTSTATUS
NtSecureConnectPort (
    OUT PHANDLE PortHandle,
    IN PUNICODE_STRING PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PPORT_VIEW ClientView OPTIONAL,
    IN PSID RequiredServerSid,
    IN OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    )

/*++

Routine Description:

    A client process can connect to a server process by name using the
    NtConnectPort service.

    The PortName parameter specifies the name of the server port to
    connect to.  It must correspond to an object name specified on a
    call to NtCreatePort.  The service sends a connection request to the
    server thread that is listening for them with the NtListenPort
    service.  The client thread then blocks until a server thread
    receives the connection request and responds with a call to the
    NtCompleteConnectPort service.  The server thread receives the ID of
    the client thread, along with any information passed via the
    ConnectionInformation parameter.  The server thread then decides to
    either accept or reject the connection request.

    The server communicates the acceptance or rejection with the
    NtCompleteConnectPort service.  The server can pass back data to the
    client about the acceptance or rejection via the
    ConnectionInformation data block.

    If the server accepts the connection request, then the client
    receives a communication port object in the location pointed to by
    the PortHandle parameter.  This object handle has no name associated
    with it and is private to the client process (i.e.  it cannot be
    inherited by a child process).  The client uses the handle to send
    and receive messages to/from the server process using the
    NtRequestWaitReplyPort service.

    If the ClientView parameter was specified, then the section handle
    is examined.  If it is a valid section handle, then the portion of
    the section described by the SectionOffset and ViewSize fields will
    be mapped into both the client and server process' address spaces.
    The address in client address space will be returned in the ViewBase
    field.  The address in the server address space will be returned in
    the ViewRemoteBase field.  The actual offset and size used to map
    the section will be returned in the SectionOffset and ViewSize
    fields.

    If the server rejects the connection request, then no communication
    port object handle is returned, and the return status indicates an
    error occurred.  The server may optionally return information in the
    ConnectionInformation data block giving the reason the connection
    requests was rejected.

    If the PortName does not exist, or the client process does not have
    sufficient access rights then the returned status will indicate that
    the port was not found.

Arguments:

    PortHandle - A pointer to a variable that will receive the client
        communication port object handle value.

    PortName - A pointer to a port name string.  The form of the name
        is [\name...\name]\port_name.

    SecurityQos - A pointer to security quality of service information
        to be applied to the server on the client's behalf.

    ClientView - An optional pointer to a structure that specifies the
        section that all client threads will use to send messages to the
        server.

    ClientView Structure

        ULONG Length - Specifies the size of this data structure in
            bytes.

        HANDLE SectionHandle - Specifies an open handle to a section
            object.

        ULONG SectionOffset - Specifies a field that will receive the
            actual offset, in bytes, from the start of the section.  The
            initial value of this parameter specifies the byte offset
            within the section that the client's view is based.  The
            value is rounded down to the next host page size boundary.

        ULONG ViewSize - Specifies a field that will receive the
            actual size, in bytes, of the view.  If the value of this
            parameter is zero, then the client's view of the section
            will be mapped starting at the specified section offset and
            continuing to the end of the section.  Otherwise, the
            initial value of this parameter specifies the size, in
            bytes, of the client's view and is rounded up to the next
            host page size boundary.

        PVOID ViewBase - Specifies a field that will receive the base
            address of the section in the client's address space.

        PVOID ViewRemoteBase - Specifies a field that will receive
            the base address of the client's section in the server's
            address space.  Used to generate pointers that are
            meaningful to the server.

    RequiredServerSid - Optionally specifies the SID that we expect the
        server side of the port to possess.  If not specified then we'll
        connect to any server SID.

    ServerView - An optional pointer to a structure that will receive
        information about the server process' view in the client's
        address space.  The client process can use this information
        to validate pointers it receives from the server process.

        ServerView Structure

        ULONG Length - Specifies the size of this data structure in
            bytes.

        PVOID ViewBase - Specifies a field that will receive the base
            address of the server's section in the client's address
            space.

        ULONG ViewSize - Specifies a field that will receive the
            size, in bytes, of the server's view in the client's address
            space.  If this field is zero, then server has no view in
            the client's address space.

    MaxMessageLength - An optional pointer to a variable that will
        receive maximum length of messages that can be sent to the
        server.  The value of this parameter will not exceed
        MAX_PORTMSG_LENGTH bytes.

    ConnectionInformation - An optional pointer to uninterpreted data.
        This data is intended for clients to pass package, version and
        protocol identification information to the server to allow the
        server to determine if it can satisify the client before
        accepting the connection.  Upon return to the client, the
        ConnectionInformation data block contains any information passed
        back from the server by its call to the NtCompleteConnectPort
        service.  The output data overwrites the input data.

    ConnectionInformationLength - Pointer to the length of the
        ConnectionInformation data block.  The output value is the
        length of the data stored in the ConnectionInformation data
        block by the server's call to the NtCompleteConnectPort
        service.  This parameter is OPTIONAL only if the
        ConnectionInformation parameter is null, otherwise it is
        required.

Return Value:

    NTSTATUS - An appropriate status value.

--*/

{
    PLPCP_PORT_OBJECT ConnectionPort;
    PLPCP_PORT_OBJECT ClientPort;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    ULONG ConnectionInfoLength;
    PVOID SectionToMap;
    PLPCP_MESSAGE Msg;
    PLPCP_CONNECTION_MESSAGE ConnectMsg;
    PEPROCESS CurrentProcess;
    PETHREAD CurrentThread = PsGetCurrentThread();
    LARGE_INTEGER SectionOffset;
    PORT_VIEW CapturedClientView;
    SECURITY_QUALITY_OF_SERVICE CapturedQos;
    PSID CapturedRequiredServerSid;

    PAGED_CODE();

    //
    //  Get previous processor mode and probe input and output arguments if
    //  necessary.
    //

    PreviousMode = KeGetPreviousMode();
    ConnectionInfoLength = 0;

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteHandle( PortHandle );

            if (ARGUMENT_PRESENT( ClientView )) {

                CapturedClientView = ProbeAndReadStructure( ClientView, PORT_VIEW );

                if (CapturedClientView.Length != sizeof( *ClientView )) {

                    return( STATUS_INVALID_PARAMETER );
                }

                ProbeForWriteSmallStructure( ClientView,
                                             sizeof( *ClientView ),
                                             sizeof( ULONG ));
            }

            if (ARGUMENT_PRESENT( ServerView )) {

                if (ProbeAndReadUlong( &ServerView->Length ) != sizeof( *ServerView )) {

                    return( STATUS_INVALID_PARAMETER );
                }

                ProbeForWriteSmallStructure( ServerView,
                                             sizeof( *ServerView ),
                                             sizeof( ULONG ));
            }

            if (ARGUMENT_PRESENT( MaxMessageLength )) {

                ProbeForWriteUlong( MaxMessageLength );
            }

            if (ARGUMENT_PRESENT( ConnectionInformationLength )) {

                ConnectionInfoLength = ProbeAndReadUlong( ConnectionInformationLength );
                ProbeForWriteUlong( ConnectionInformationLength );
            }

            if (ARGUMENT_PRESENT( ConnectionInformation )) {

                ProbeForWrite( ConnectionInformation,
                               ConnectionInfoLength,
                               sizeof( UCHAR ));
            }

            CapturedQos = ProbeAndReadStructure( SecurityQos, SECURITY_QUALITY_OF_SERVICE );

            CapturedRequiredServerSid = RequiredServerSid;

            if (ARGUMENT_PRESENT( RequiredServerSid )) {

                Status = SeCaptureSid( RequiredServerSid,
                                       PreviousMode,
                                       NULL,
                                       0,
                                       PagedPool,
                                       TRUE,
                                       &CapturedRequiredServerSid );

                if (!NT_SUCCESS(Status)) {

                    return Status;
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }

    //
    //  Otherwise this is a kernel mode operation
    //

    } else {

        if (ARGUMENT_PRESENT( ClientView )) {

            if (ClientView->Length != sizeof( *ClientView )) {

                return( STATUS_INVALID_PARAMETER );
            }

            CapturedClientView = *ClientView;
        }

        if (ARGUMENT_PRESENT( ServerView )) {

            if (ServerView->Length != sizeof( *ServerView )) {

                return( STATUS_INVALID_PARAMETER );
            }
        }

        if (ARGUMENT_PRESENT( ConnectionInformationLength )) {

            ConnectionInfoLength = *ConnectionInformationLength;
        }

        CapturedQos = *SecurityQos;
        CapturedRequiredServerSid = RequiredServerSid;
    }

    //
    //  Reference the connection port object by name.  Return status if
    //  unsuccessful.
    //

    Status = ObReferenceObjectByName( PortName,
                                      0,
                                      NULL,
                                      PORT_CONNECT,
                                      LpcPortObjectType,
                                      PreviousMode,
                                      NULL,
                                      (PVOID *)&ConnectionPort );

    //
    //  If the port type object didn't work then try for a waitable port type
    //  object
    //

    if ( Status == STATUS_OBJECT_TYPE_MISMATCH ) {

        Status = ObReferenceObjectByName( PortName,
                                          0,
                                          NULL,
                                          PORT_CONNECT,
                                          LpcWaitablePortObjectType,
                                          PreviousMode,
                                          NULL,
                                          (PVOID *)&ConnectionPort );
    }

    //
    //  We can't locate the name so release the sid if we captured one and
    //  return error status back to our caller
    //

    if (!NT_SUCCESS( Status )) {

        if (CapturedRequiredServerSid != RequiredServerSid) {

            SeReleaseSid( CapturedRequiredServerSid, PreviousMode, TRUE);
        }

        return Status;
    }

    LpcpTrace(("Connecting to port %wZ\n", PortName ));

    //
    //  Error if user didn't give us a server communication port
    //

    if ((ConnectionPort->Flags & PORT_TYPE) != SERVER_CONNECTION_PORT) {

        ObDereferenceObject( ConnectionPort );

        if (CapturedRequiredServerSid != RequiredServerSid) {

            SeReleaseSid( CapturedRequiredServerSid, PreviousMode, TRUE);
        }

        return STATUS_INVALID_PORT_HANDLE;
    }

    //
    //  If this is NtSecureConnectPort, validated the required SID against
    //  the SID of the server process.  Fail if not equal.
    //

    if (ARGUMENT_PRESENT( RequiredServerSid )) {

        PTOKEN_USER TokenInfo;

        if (ConnectionPort->ServerProcess != NULL) {

            PACCESS_TOKEN Token ;

            Token = PsReferencePrimaryToken( ConnectionPort->ServerProcess );

    
            Status = SeQueryInformationToken( Token,
                                              TokenUser,
                                              &TokenInfo );
            
            PsDereferencePrimaryTokenEx( ConnectionPort->ServerProcess, Token );

            if (NT_SUCCESS( Status )) {

                if (!RtlEqualSid( CapturedRequiredServerSid, TokenInfo->User.Sid )) {

                    Status = STATUS_SERVER_SID_MISMATCH;
                }

                ExFreePool( TokenInfo );
            }

        } else {

            Status = STATUS_SERVER_SID_MISMATCH;
        }

        //
        //  We are all done with the required server sid if specified so
        //  now release one if we had to capture it
        //

        if (CapturedRequiredServerSid != RequiredServerSid) {

            SeReleaseSid( CapturedRequiredServerSid, PreviousMode, TRUE);
        }

        //
        //  If the se information token query didn't work then return the
        //  error to our caller
        //

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( ConnectionPort );

            return Status;
        }
    }

    //
    //  Allocate and initialize a client communication port object.  Give
    //  the port a request message queue for lost reply datagrams.  If
    //  unable to initialize the port, then deference the port object which
    //  will cause it to be deleted and return the system service status.
    //

    Status = ObCreateObject( PreviousMode,
                             LpcPortObjectType,
                             NULL,
                             PreviousMode,
                             NULL,
                             FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent ),
                             0,
                             0,
                             (PVOID *)&ClientPort );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( ConnectionPort );

        return Status;
    }

    //
    //  Note, that from here on, none of the error paths dereference the
    //  connection port pointer, just the newly created client port pointer.
    //  The port delete routine will get called when the client port is
    //  deleted and it will dereference the connection port pointer stored
    //  in the client port object.
    //

    //
    //  Initialize the client port object to zeros and then fill in the
    //  fields.
    //

    RtlZeroMemory( ClientPort, FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent ));

    ClientPort->Flags = CLIENT_COMMUNICATION_PORT;
    ClientPort->ConnectionPort = ConnectionPort;
    ClientPort->MaxMessageLength = ConnectionPort->MaxMessageLength;
    ClientPort->SecurityQos = CapturedQos;

    InitializeListHead( &ClientPort->LpcReplyChainHead );
    InitializeListHead( &ClientPort->LpcDataInfoChainHead );

    //
    //  Set the security tracking mode, and initialize the client security
    //  context if it is static tracking.
    //

    if (CapturedQos.ContextTrackingMode == SECURITY_DYNAMIC_TRACKING) {

        ClientPort->Flags |= PORT_DYNAMIC_SECURITY;

    } else {

        Status = SeCreateClientSecurity( CurrentThread,
                                         &CapturedQos,
                                         FALSE,
                                         &ClientPort->StaticSecurity );

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( ClientPort );

            return Status;
        }
    }

    //
    //  Client communication ports get a request message queue for lost
    //  replies.
    //

    Status = LpcpInitializePortQueue( ClientPort );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( ClientPort );

        return Status;
    }

    //
    //  If client has allocated a port memory section, then map a view of
    //  that section into the client's address space.  Also reference the
    //  section object so we can pass a pointer to the section object in
    //  connection request message.  If the server accepts the connection,
    //  then it will map a corresponding view of the section in the server's
    //  address space, using the referenced pointer passed in the connection
    //  request message.
    //

    if (ARGUMENT_PRESENT( ClientView )) {

        Status = ObReferenceObjectByHandle( CapturedClientView.SectionHandle,
                                            SECTION_MAP_READ |
                                            SECTION_MAP_WRITE,
                                            MmSectionObjectType,
                                            PreviousMode,
                                            (PVOID *)&SectionToMap,
                                            NULL );

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( ClientPort );

            return Status;
        }

        SectionOffset.LowPart = CapturedClientView.SectionOffset,
        SectionOffset.HighPart = 0;

        CurrentProcess = PsGetCurrentProcess();

        //
        //  Now map a view of the section using the reference we just captured
        //  and not the section handle itself, because the handle may have changed
        //

        Status = MmMapViewOfSection( SectionToMap,
                                     CurrentProcess,
                                     &ClientPort->ClientSectionBase,
                                     0,
                                     0,
                                     &SectionOffset,
                                     &CapturedClientView.ViewSize,
                                     ViewUnmap,
                                     0,
                                     PAGE_READWRITE );

        CapturedClientView.SectionOffset = SectionOffset.LowPart;

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( SectionToMap );
            ObDereferenceObject( ClientPort );

            return Status;
        }

        CapturedClientView.ViewBase = ClientPort->ClientSectionBase;

        //
        //  We'll add an extra-reference to the current process, when we have 
        //  a section mapped in that process. 
        //

        ClientPort->MappingProcess = CurrentProcess;

        ObReferenceObject( ClientPort->MappingProcess );

    } else {

        SectionToMap = NULL;
    }

    //
    //  Adjust the size of the connection info length that the client supplied
    //  to be the no longer than one the connection port will accept
    //

    if (ConnectionInfoLength > ConnectionPort->MaxConnectionInfoLength) {

        ConnectionInfoLength = ConnectionPort->MaxConnectionInfoLength;
    }

    //
    //  At this point the client port is all setup and now we have to
    //  allocate a request connection message for the server and send it off
    //
    //  Allocate a connection request message.  It holds the LPCP message,
    //  the LPCP connection message, and the user supplied connection
    //  information
    //

    Msg = LpcpAllocateFromPortZone( sizeof( *Msg ) +
                                    sizeof( *ConnectMsg ) +
                                    ConnectionInfoLength );

    //
    //  If we didn't get memory for the message then tell our caller we failed
    //

    if (Msg == NULL) {

        if (SectionToMap != NULL) {

            ObDereferenceObject( SectionToMap );
        }

        ObDereferenceObject( ClientPort );

        return STATUS_NO_MEMORY;
    }

    //
    //  Msg points to the LPCP message, followed by ConnectMsg which points to
    //  the LPCP connection message, followed by client specified information.
    //  We'll now fill it all in.
    //

    ConnectMsg = (PLPCP_CONNECTION_MESSAGE)(Msg + 1);

    //
    //  This thread originated the message
    //

    Msg->Request.ClientId = CurrentThread->Cid;

    //
    //  If we have a client view then copy over the client view information
    //  otherwise we'll zero out all of the view information
    //

    if (ARGUMENT_PRESENT( ClientView )) {

        Msg->Request.ClientViewSize = CapturedClientView.ViewSize;

        RtlCopyMemory( &ConnectMsg->ClientView,
                       &CapturedClientView,
                       sizeof( CapturedClientView ));

        RtlZeroMemory( &ConnectMsg->ServerView, sizeof( ConnectMsg->ServerView ));

    } else {

        Msg->Request.ClientViewSize = 0;
        RtlZeroMemory( ConnectMsg, sizeof( *ConnectMsg ));
    }

    ConnectMsg->ClientPort = NULL;              // Set below
    ConnectMsg->SectionToMap = SectionToMap;

    //
    //  The data length is everything after the port message within the lpcp
    //  message.  In other words the connection message and the user supplied
    //  information
    //

    Msg->Request.u1.s1.DataLength = (CSHORT)(sizeof( *ConnectMsg ) +
                                             ConnectionInfoLength);

    //
    //  The total length add on the LPCP message
    //

    Msg->Request.u1.s1.TotalLength = (CSHORT)(sizeof( *Msg ) +
                                              Msg->Request.u1.s1.DataLength);

    //
    //  This will be a connection request message
    //

    Msg->Request.u2.s2.Type = LPC_CONNECTION_REQUEST;

    //
    //  If the caller supplied some connection information then copy
    //  that into place right now
    //

    if (ARGUMENT_PRESENT( ConnectionInformation )) {

        try {

            RtlCopyMemory( ConnectMsg + 1,
                           ConnectionInformation,
                           ConnectionInfoLength );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            //  If we fail then cleanup after ourselves and return the
            //  error to our caller
            //

            LpcpFreeToPortZone( Msg, 0 );

            if (SectionToMap != NULL) {

                ObDereferenceObject( SectionToMap );
            }

            ObDereferenceObject( ClientPort );

            return GetExceptionCode();
        }
    }

    //
    //  The message is mostly ready to go now put it on the servers queue.
    //
    //  Acquire the mutex that guards the LpcReplyMessage field of the
    //  thread.  Also acquire the semaphore that guards the connection
    //  request message queue.  Stamp the connection request message with
    //  a serial number, insert the message at the tail of the connection
    //  request message queue and remember the address of the message in
    //  the LpcReplyMessage field for the current thread.
    //

    Status = STATUS_SUCCESS;

    LpcpAcquireLpcpLockByThread(CurrentThread);

    //
    //  See if the port name has been deleted from under us.  If so, then
    //  don't queue the message and don't wait for a reply
    //

    if (ConnectionPort->Flags & PORT_NAME_DELETED) {

        Status = STATUS_OBJECT_NAME_NOT_FOUND;

    } else {

        LpcpTrace(( "Send Connect Msg %lx to Port %wZ (%lx)\n", Msg, PortName, ConnectionPort ));

        //
        //  Stamp the request message with a serial number, insert the message
        //  at the tail of the request message queue
        //

        Msg->RepliedToThread = NULL;
        Msg->Request.MessageId = LpcpGenerateMessageId();

        CurrentThread->LpcReplyMessageId = Msg->Request.MessageId;

        InsertTailList( &ConnectionPort->MsgQueue.ReceiveHead, &Msg->Entry );

        InsertTailList( &ConnectionPort->LpcReplyChainHead, &CurrentThread->LpcReplyChain );

        CurrentThread->LpcReplyMessage = Msg;

        //
        //  Reference the port we are passing in the connect msg so if we die
        //  it will still be valid for the server in NtAcceptConnectPort.  The
        //  reference will be released when the message is freed.
        //

        ObReferenceObject( ClientPort );

        ConnectMsg->ClientPort = ClientPort;

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    }
    
    LpcpReleaseLpcpLock();

    //
    //  At this point the client's communication port is all set up and the
    //  connection request message is in the server's queue.  So now we have
    //  to single the server and wait for a reply
    //

    if (NT_SUCCESS( Status )) {

        //
        //  If this is a waitable port then set the event that they might be
        //  waiting on
        //

        if ( ConnectionPort->Flags & PORT_WAITABLE ) {

            KeSetEvent( &ConnectionPort->WaitEvent, 1, FALSE );
        }

        //
        //  Increment the connection request message queue semaphore by one for
        //  the newly inserted connection request message.  Release the spin
        //  locks, while remaining at the dispatcher IRQL.  Then wait for the
        //  reply to this connection request by waiting on the LpcReplySemaphore
        //  for the current thread.
        //

        KeReleaseSemaphore( ConnectionPort->MsgQueue.Semaphore,
                            1,
                            1,
                            FALSE );
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        Status = KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                        Executive,
                                        PreviousMode,
                                        FALSE,
                                        NULL );

    }

    if (Status == STATUS_USER_APC) {

        //
        //  if the semaphore is signaled, then clear it
        //

        if (KeReadStateSemaphore( &CurrentThread->LpcReplySemaphore )) {

            KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                   WrExecutive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            Status = STATUS_SUCCESS;
        }
    }

    //
    //  A connection request is accepted if the ConnectedPort of the client's
    //  communication port has been filled in.
    //

    if (Status == STATUS_SUCCESS) {

        SectionToMap = LpcpFreeConMsg( &Msg, &ConnectMsg, CurrentThread );

        //
        //  Check that we got a reply message
        //

        if (Msg != NULL) {

            //
            //  Copy any connection information back to the caller, but first
            //  calculate the new connection data length for the reply and
            //  don't let it grow beyond what we probed originally
            //

            if ((Msg->Request.u1.s1.DataLength - sizeof( *ConnectMsg )) < ConnectionInfoLength) {

                ConnectionInfoLength = Msg->Request.u1.s1.DataLength - sizeof( *ConnectMsg );
            }

            if (ARGUMENT_PRESENT( ConnectionInformation )) {

                try {

                    if (ARGUMENT_PRESENT( ConnectionInformationLength )) {

                        *ConnectionInformationLength = ConnectionInfoLength;
                    }

                    RtlCopyMemory( ConnectionInformation,
                                   ConnectMsg + 1,
                                   ConnectionInfoLength );

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    Status = GetExceptionCode();
                }
            }

            //
            //  Insert client communication port object in specified object
            //  table.  Set port handle value if successful.  If not
            //  successful, then the port will have been dereferenced, which
            //  will cause it to be freed, after our delete procedure is
            //  called.  The delete procedure will undo the work done to
            //  initialize the port.
            //

            if (ClientPort->ConnectedPort != NULL) {

                ULONG CapturedMaxMessageLength;

                //
                //  Before we do the object insert we need to get the max
                //  message length because right after the call the object
                //  could be dereferenced and gone away
                //

                CapturedMaxMessageLength = ConnectionPort->MaxMessageLength;

                //
                //  Now create a handle for the new client port object.
                //

                Status = ObInsertObject( ClientPort,
                                         NULL,
                                         PORT_ALL_ACCESS,
                                         0,
                                         (PVOID *)NULL,
                                         &Handle );

                if (NT_SUCCESS( Status )) {

                    //
                    //  This is the only successful path through this routine.
                    //  Set the output variables, later we'll free the msg
                    //  back to the port zone and return to our caller
                    //

                    try {

                        *PortHandle = Handle;

                        if (ARGUMENT_PRESENT( MaxMessageLength )) {

                            *MaxMessageLength = CapturedMaxMessageLength;
                        }

                        if (ARGUMENT_PRESENT( ClientView )) {

                            RtlCopyMemory( ClientView,
                                           &ConnectMsg->ClientView,
                                           sizeof( *ClientView ));
                        }

                        if (ARGUMENT_PRESENT( ServerView )) {

                            RtlCopyMemory( ServerView,
                                           &ConnectMsg->ServerView,
                                           sizeof( *ServerView ));
                        }

                    } except( EXCEPTION_EXECUTE_HANDLER ) {

                        Status = GetExceptionCode();
                        NtClose( Handle );
                    }
                }

            } else {

                //
                //  Otherwise we did not get a connect port from the server so
                //  the connection was refused
                //

                LpcpTrace(( "Connection request refused.\n" ));

                if ( SectionToMap != NULL ) {

                    ObDereferenceObject( SectionToMap );
                }

                //
                //  Synchronize with the deletion path for the port object
                //  If the server accepted the connection and immediately 
                //  closed the server handle, the ConnectionPort field will be NULL.
                //  If the server closed the connection port as well, the captured
                //  value for the connection port will be invalid.
                //

                LpcpAcquireLpcpLockByThread(CurrentThread);

                if ((ClientPort->ConnectionPort == NULL)
                        ||
                    (ConnectionPort->Flags & PORT_NAME_DELETED)) {

                    Status = STATUS_OBJECT_NAME_NOT_FOUND;

                } else {

                    Status = STATUS_PORT_CONNECTION_REFUSED;
                }
                
                LpcpReleaseLpcpLock();

                ObDereferenceObject( ClientPort );
            }

            //
            //  Free the reply message back to the port zone
            //

            LpcpFreeToPortZone( Msg, 0 );

        } else {

            //
            //  We did not get a reply message so the connection must have
            //  been refused
            //

            if (SectionToMap != NULL) {

                ObDereferenceObject( SectionToMap );
            }

            ObDereferenceObject( ClientPort );

            Status = STATUS_PORT_CONNECTION_REFUSED;
        }

    } else {

        //
        //  Our wait was not successful
        //

        //
        //  Remove the connection request message from the received
        //  queue and free the message back to the connection
        //  port's zone.
        //

        SectionToMap = LpcpFreeConMsg( &Msg, &ConnectMsg, CurrentThread );
        
        //
        //  The wait was not successful, but in the meantime the server could
        //  replied, so it signaled the lpc semaphore. We have to clear the
        //  semaphore state right now.
        //

        if (KeReadStateSemaphore( &CurrentThread->LpcReplySemaphore )) {

            KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                   WrExecutive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
        }

        if (Msg != NULL) {

            LpcpFreeToPortZone( Msg, 0 );
        }

        //
        //  If a client section was specified, then dereference the section
        //  object.
        //

        if ( SectionToMap != NULL ) {

            ObDereferenceObject( SectionToMap );
        }

        //
        //  If the connection was rejected or the wait failed, then
        //  dereference the client port object, which will cause it to
        //  be deleted.
        //

        ObDereferenceObject( ClientPort );
    }

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Local support routine
//

PVOID
LpcpFreeConMsg (
    IN PLPCP_MESSAGE *Msg,
    PLPCP_CONNECTION_MESSAGE *ConnectMsg,
    IN PETHREAD CurrentThread
    )

/*++

Routine Description:

    This routine returns a connection reply message for the specified thread

Arguments:

    Msg - Receives a pointer to the LPCP message if there is a reply

    ConnectMsg - Receives a pointer to the LPCP connection message if there
        is a reply

    CurrentThread - Specifies the thread we're to be examining

Return Value:

    PVOID - Returns a pointer to the section to map in the connection message

--*/

{
    PVOID SectionToMap;
    PLPCP_MESSAGE LpcMessage;

    //
    //  Acquire the LPC mutex, remove the connection request message
    //  from the received queue and free the message back to the connection
    //  port's zone.
    //

    LpcpAcquireLpcpLock();

    //
    //  Remove the thread from the reply rundown list in case we did not wakeup due to
    //  a reply
    //

    if (!IsListEmpty( &CurrentThread->LpcReplyChain )) {

        RemoveEntryList( &CurrentThread->LpcReplyChain );

        InitializeListHead( &CurrentThread->LpcReplyChain );
    }

    //
    //  Check if the thread has an LPC reply message waiting to be handled
    //
    
    LpcMessage = LpcpGetThreadMessage(CurrentThread);

    if (LpcMessage != NULL) {

        //
        //  Take the message off the threads list
        //

        *Msg = LpcMessage;

        if (!IsListEmpty( &LpcMessage->Entry )) {

            RemoveEntryList( &LpcMessage->Entry );
            InitializeListHead( &LpcMessage->Entry );
        }
        
        CurrentThread->LpcReplyMessage = NULL;

        CurrentThread->LpcReplyMessageId = 0;

        //
        //  Set the connection message pointer, and copy over the section
        //  to map location before zeroing it out
        //

        *ConnectMsg = (PLPCP_CONNECTION_MESSAGE)(LpcMessage + 1);

        SectionToMap = (*ConnectMsg)->SectionToMap;
        (*ConnectMsg)->SectionToMap = NULL;

    } else {

        //
        //  Otherwise there is no LPC message to be handle so we'll return
        //  null's to our caller
        //

        *Msg = NULL;
        SectionToMap = NULL;
    }

    //
    //  Release the global lock and return to our caller
    //

    LpcpReleaseLpcpLock();

    return SectionToMap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpccompl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpccompl.c

Abstract:

    Local Inter-Process Communication (LPC) connection system services.

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#include "lpcp.h"

//
//  Local procedure prototypes
//

VOID
LpcpPrepareToWakeClient (
    IN PETHREAD ClientThread
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtAcceptConnectPort)
#pragma alloc_text(PAGE,NtCompleteConnectPort)
#pragma alloc_text(PAGE,LpcpPrepareToWakeClient)
#endif


NTSTATUS
NtAcceptConnectPort (
    OUT PHANDLE PortHandle,
    IN PVOID PortContext OPTIONAL,
    IN PPORT_MESSAGE ConnectionRequest,
    IN BOOLEAN AcceptConnection,
    IN OUT PPORT_VIEW ServerView OPTIONAL,
    OUT PREMOTE_PORT_VIEW ClientView OPTIONAL
    )

/*++

Routine Description:

    A server process can accept or reject a client connection request
    using the NtAcceptConnectPort service.

    The ConnectionRequest parameter must specify a connection request
    returned by a previous call to the NtListenPort service.  This
    service will either complete the connection if the AcceptConnection
    parameter is TRUE, or reject the connection request if the
    AcceptConnection parameter is FALSE.

    In either case, the contents of the data portion of the connection
    request is the data to return to the caller of NtConnectPort.

    If the connection request is accepted, then two communication port
    objects will be created and connected together.  One will be
    inserted in the client process' handle table and returned to the
    client via the PortHandle parameter it specified on the
    NtConnectPort service.  The other will be inserted in the server
    process' handle table and returned via the PortHandle parameter
    specified on the NtCompleteConnectPort service.  In addition the
    two communication ports (client and server) will be linked together.

    If the connection request is accepted, and the ServerView parameter
    was specified, then the section handle is examined.  If it is valid,
    then the portion of the section described by the SectionOffset and
    ViewSize fields will be mapped into both the client and server
    process address spaces.  The address in server's address space will
    be returned in the ViewBase field.  The address in the client's
    address space will be returned in the ViewRemoteBase field.  The
    actual offset and size used to map the section will be returned in
    the SectionOffset and ViewSize fields.

    Communication port objects are temporary objects that have no names
    and cannot be inherited.  When either the client or server process
    calls the !f NtClose service for a communication port, the port will
    be deleted since there can never be more than one outstanding handle
    for each communication port.  The port object type specific delete
    procedure will then be invoked.  This delete procedure will examine
    the communication port, and if it is connected to another
    communication port, it will queue an LPC_PORT_CLOSED datagram to
    that port's message queue.  This will allow both the client and
    server processes to notice when a port becomes disconnected, either
    because of an explicit call to NtClose or an implicit call due to
    process termination.  In addition, the delete procedure will scan
    the message queue of the port being closed and for each message
    still in the queue, it will return an ERROR_PORT_CLOSED status to
    any thread that is waiting for a reply to the message.

Arguments:

    PortHandle - A pointer to a variable that will receive the server
        communication port object handle value.

    PortContext - An uninterpreted pointer that is stored in the
        server communication port.  This pointer is returned whenever
        a message is received for this port.

    ConnectionRequest - A pointer to a structure that describes the
        connection request being accepted or rejected:

        The ConnectionRequest structure

        ULONG Length - Specifies the size of this data structure in
            bytes.

        CLIENT_ID ClientId - Specifies a structure that contains the
            client identifier (CLIENT_ID) of the thread that sent the
            request.

        The ClientId Structure

            ULONG UniqueProcessId - A unique value for each process
                in the system.

            ULONG UniqueThreadId - A unique value for each thread in the
                system.

        ULONG MessageId - A unique value that identifies the connection
            request being completed.

        ULONG PortAttributes - This field has no meaning for this service.

        ULONG ClientViewSize - This field has no meaning for this service.

    AcceptConnection - Specifies a boolean value which indicates where
        the connection request is being accepted or rejected.  A value
        of TRUE means that the connection request is accepted and a
        server communication port handle will be created and connected
        to the client's communication port handle.  A value of FALSE
        means that the connection request is not accepted.

    ServerView - A pointer to a structure that specifies the section that
        the server process will use to send messages back to the client
        process connected to this port.

        The ServerView Structure

        ULONG Length - Specifies the size of this data structure in
            bytes.

        HANDLE SectionHandle - Specifies an open handle to a section
            object.

        ULONG SectionOffset - Specifies a field that will receive the
            actual offset, in bytes, from the start of the section.  The
            initial value of this parameter specifies the byte offset
            within the section that the client's view is based.  The
            value is rounded down to the next host page size boundary.

        ULONG ViewSize - Specifies the size of the view, in bytes.

        PVOID ViewBase - Specifies a field that will receive the base
            address of the port memory in the server's address space.

        PVOID ViewRemoteBase - Specifies a field that will receive
            the base address of the server port's memory in the client's
            address space.  Used to generate pointers that are
            meaningful to the client.

    ClientView - An optional pointer to a structure that will receive
        information about the client process' view in the server's
        address space.  The server process can use this information
        to validate pointers it receives from the client process.

        The ClientView Structure

        ULONG Length - Specifies the size of this data structure in
            bytes.

        PVOID ViewBase - Specifies a field that will receive the base
            address of the client port's memory in the server's address
            space.

        ULONG ViewSize - Specifies a field that will receive the
            size, in bytes, of the client's view in the server's address
            space.  If this field is zero, then client has no view in
            the server's address space.

Return Value:

    NTSTATUS - An appropriate status value.

--*/

{
    PLPCP_PORT_OBJECT ConnectionPort;
    PLPCP_PORT_OBJECT ServerPort;
    PLPCP_PORT_OBJECT ClientPort;
    PVOID ClientSectionToMap;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    ULONG ConnectionInfoLength;
    PLPCP_MESSAGE Msg;
    PLPCP_CONNECTION_MESSAGE ConnectMsg;
    PORT_MESSAGE CapturedReplyMessage;
    PVOID SectionToMap;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    PEPROCESS ClientProcess;
    PETHREAD ClientThread;
    PORT_VIEW CapturedServerView;

    PAGED_CODE();

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteHandle( PortHandle );

            ProbeForReadSmallStructure( ConnectionRequest,
                                        sizeof( *ConnectionRequest ),
                                        sizeof( ULONG ));

            CapturedReplyMessage = *ConnectionRequest;

            if (ARGUMENT_PRESENT( ServerView )) {

                CapturedServerView = ProbeAndReadStructure( ServerView, PORT_VIEW );

                if (CapturedServerView.Length != sizeof( *ServerView )) {

                    return STATUS_INVALID_PARAMETER;
                }

                ProbeForWriteSmallStructure( ServerView,
                                             sizeof( *ServerView ),
                                             sizeof( ULONG ));
            }

            if (ARGUMENT_PRESENT( ClientView )) {

                if (ProbeAndReadUlong( &ClientView->Length ) != sizeof( *ClientView )) {

                    return STATUS_INVALID_PARAMETER;
                }

                ProbeForWriteSmallStructure( ClientView,
                                             sizeof( *ClientView ),
                                             sizeof( ULONG ));
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

    } else {

        //
        //  Otherwise the previous mode is kernel mode
        //

        CapturedReplyMessage = *ConnectionRequest;

        if (ARGUMENT_PRESENT( ServerView )) {

            if (ServerView->Length != sizeof( *ServerView )) {

                return STATUS_INVALID_PARAMETER;
            }

            CapturedServerView = *ServerView;
        }

        if (ARGUMENT_PRESENT( ClientView )) {

            if (ClientView->Length != sizeof( *ClientView )) {

                return STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    //  Translate the ClientId from the connection request into a
    //  thread pointer.  This is a referenced pointer to keep the thread
    //  from evaporating out from under us.
    //

    Status = PsLookupProcessThreadByCid( &CapturedReplyMessage.ClientId,
                                         &ClientProcess,
                                         &ClientThread );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Acquire the mutex that guards the LpcReplyMessage field of
    //  the thread and get the pointer to the message that the thread
    //  is waiting for a reply to.
    //

    LpcpAcquireLpcpLock();

    //
    //  See if the thread is waiting for a reply to the connection request
    //  specified on this call.  If not then a bogus connection request
    //  has been specified, so release the mutex, dereference the thread
    //  and return failure.
    //
    //  The check is that the client is waiting for a reply to a connection
    //  request and that the message id is both valid and lines up correctly
    //

    if (( LpcpGetThreadMessage( ClientThread ) == NULL ) ||
        (CapturedReplyMessage.MessageId == 0) ||
        (ClientThread->LpcReplyMessageId != CapturedReplyMessage.MessageId) ||
        ((LpcpGetThreadMessage(ClientThread)->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_CONNECTION_REQUEST)) {

        Msg = NULL;

    } else {

        //
        //  Remember the LPCP message from the thread
        //

        Msg = LpcpGetThreadMessage(ClientThread);

        //
        //  Get connection message immediately following the LPCP message
        //

        ConnectMsg = (PLPCP_CONNECTION_MESSAGE)(Msg + 1);

        //
        //  Remember the client port from the connection message
        //

        ClientPort = ConnectMsg->ClientPort;
        
        //
        //  Get a pointer to the connection port from the client port.
        //

        ConnectionPort = ClientPort->ConnectionPort;
        
        //
        //  Check if the server process accept the connection
        //
        
        if ( ConnectionPort->ServerProcess != PsGetCurrentProcess() ) {
            
            //
            //  Release the LPC mutex
            //
            
            LpcpReleaseLpcpLock();
            
            ObDereferenceObject( ClientProcess );
            ObDereferenceObject( ClientThread );

            return (STATUS_REPLY_MESSAGE_MISMATCH);
        }
        
        //
        //  Remove the LPC message from the thread
        //
                
        ClientThread->LpcReplyMessage = NULL;
        
        //
        //  Remove the client port from the connection message
        //

        ConnectMsg->ClientPort = NULL;

        //
        //  Clean up the rest of the client thread.  This cleanup use to be
        //  done unconditionally right before releasing the mutex however
        //  this causes trouble if our caller supplied a bad reply message
        //  and we clobber an arbitrary threads state
        //

        ClientThread->LpcReplyMessageId = 0;
    }

    //
    //  Release the mutex that guards the field.
    //

    LpcpReleaseLpcpLock();

    //
    //  Now if we did not get an LPCP message from a client thread then this
    //  isn't a good call and we'll dereference what we thought was the
    //  client thread/process and tell our caller their mistake
    //

    if ( !Msg ) {

        LpcpPrint(( "%s Attempted AcceptConnectPort to Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    ClientThread,
                    THREAD_TO_PROCESS( ClientThread )->ImageFileName ));
        LpcpPrint(( "failed.  MessageId == %u\n", CapturedReplyMessage.MessageId ));
        LpcpPrint(( "         Thread MessageId == %u\n", ClientThread->LpcReplyMessageId ));
        LpcpPrint(( "         Thread Msg == %x\n", ClientThread->LpcReplyMessage ));

        ObDereferenceObject( ClientProcess );
        ObDereferenceObject( ClientThread );

        return (STATUS_REPLY_MESSAGE_MISMATCH);
    }

    //
    //  At this point we have a good matching client for this accept connect
    //  call.
    //
    
    LpcpTrace(("Replying to Connect Msg %lx to Port %lx\n",
               Msg, ClientPort->ConnectionPort ));

    //
    //  Regardless of whether we are accepting or rejecting the connection,
    //  return the connection information to the waiting thread.
    //

    ConnectionInfoLength = CapturedReplyMessage.u1.s1.DataLength;

    if (ConnectionInfoLength > ConnectionPort->MaxConnectionInfoLength) {

        ConnectionInfoLength = ConnectionPort->MaxConnectionInfoLength;
    }

    Msg->Request.u1.s1.DataLength = (CSHORT)(sizeof( *ConnectMsg ) +
                                             ConnectionInfoLength);

    Msg->Request.u1.s1.TotalLength = (CSHORT)(sizeof( *Msg ) +
                                              Msg->Request.u1.s1.DataLength);

    Msg->Request.u2.s2.Type = LPC_REPLY;
    Msg->Request.u2.s2.DataInfoOffset = 0;
    Msg->Request.ClientId = CapturedReplyMessage.ClientId;
    Msg->Request.MessageId = CapturedReplyMessage.MessageId;
    Msg->Request.ClientViewSize = 0;

    try {

        RtlCopyMemory( ConnectMsg + 1,
                       (PCHAR)(ConnectionRequest + 1),
                       ConnectionInfoLength );

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();
    }

    //
    //  Now it is time to process a positive accept request
    //

    ClientSectionToMap = NULL;

    if (AcceptConnection) {

        //
        //  Allocate and initialize a server communication port object.
        //  Communication ports have no names, can not be inherited and
        //  are process private handles.
        //

        Status = ObCreateObject( PreviousMode,
                                 LpcPortObjectType,
                                 NULL,
                                 PreviousMode,
                                 NULL,
                                 FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent ),
                                 0,
                                 0,
                                 (PVOID *)&ServerPort );

        if (!NT_SUCCESS( Status )) {

            goto bailout;
        }

        RtlZeroMemory( ServerPort, FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent ));

        ServerPort->PortContext = PortContext;
        ServerPort->Flags = SERVER_COMMUNICATION_PORT;

        InitializeListHead( &ServerPort->LpcReplyChainHead );
        InitializeListHead( &ServerPort->LpcDataInfoChainHead );

        //
        //  Connect the newly created server communication port to the
        //  connection port with a referenced pointer.  Prevents the
        //  connection port from going away until all of the communication
        //  ports have been closed.
        //

        ObReferenceObject( ConnectionPort );

        ServerPort->ConnectionPort = ConnectionPort;
        ServerPort->MaxMessageLength = ConnectionPort->MaxMessageLength;

        //
        //  Connect the client and server communication ports together
        //  with unreferenced pointers.  They are unreferenced so that
        //  the PortObjectType delete procedure will get called when a
        //  communication port is closed.  If this were not the case then
        //  we would need a special NtClosePort system service in order
        //  to tear down a pair of connected communication ports.
        //

        ServerPort->ConnectedPort = ClientPort;
        ClientPort->ConnectedPort = ServerPort;

        ServerPort->Creator = PsGetCurrentThread()->Cid;
        ClientPort->Creator = Msg->Request.ClientId;
        
        //
        //  If the client has allocated a port memory section that is mapped
        //  into the client's address space, then map a view of the same
        //  section for the server process to see.
        //

        LpcpAcquireLpcpLock();

        ClientSectionToMap = ConnectMsg->SectionToMap;
        ConnectMsg->SectionToMap = NULL;

        LpcpReleaseLpcpLock();

        if (ClientSectionToMap) {

            LARGE_INTEGER LargeSectionOffset;

            LargeSectionOffset.LowPart = ConnectMsg->ClientView.SectionOffset;
            LargeSectionOffset.HighPart = 0;

            Status = MmMapViewOfSection( ClientSectionToMap,
                                         PsGetCurrentProcess(),
                                         &ServerPort->ClientSectionBase,
                                         0,
                                         0,
                                         &LargeSectionOffset,
                                         &ConnectMsg->ClientView.ViewSize,
                                         ViewUnmap,
                                         0,
                                         PAGE_READWRITE );

            ConnectMsg->ClientView.SectionOffset = LargeSectionOffset.LowPart;

            if (NT_SUCCESS( Status )) {

                ConnectMsg->ClientView.ViewRemoteBase = ServerPort->ClientSectionBase;

                //
                //  The client section was mapped. We'll add an extra reference to 
                //  server process. This reference will be removed on port cleanup.
                //

                ServerPort->MappingProcess = PsGetCurrentProcess();

                ObReferenceObject( ServerPort->MappingProcess );

            } else {

                //
                //  At this point we're really going to drop all the way
                //  out to the label bailout: because everything else is
                //  protected with a test against Status.  But first we have
                //  to release the server port that we've just created
                //

                ObDereferenceObject( ServerPort );
            }
        }

        //
        //  If the server process has allocated a port memory section for
        //  send data to the client on call back requests, map two views
        //  of that section, the first for the server process and the
        //  second view for the client process.  Return the location of the
        //  server's view to the caller of this function.  Return the
        //  client's view to the client process via the reply to the
        //  connection request.
        //

        if (NT_SUCCESS( Status ) && ARGUMENT_PRESENT( ServerView )) {

            LARGE_INTEGER LargeSectionOffset;

            LargeSectionOffset.LowPart = CapturedServerView.SectionOffset;
            LargeSectionOffset.HighPart = 0;

            //
            //  Map in the section into the servers address space
            //

            //
            //  Does this call need to verify that the section handle
            //  is still valid.
            //

            Status = ObReferenceObjectByHandle( CapturedServerView.SectionHandle,
                                                SECTION_MAP_READ |
                                                SECTION_MAP_WRITE,
                                                MmSectionObjectType,
                                                PreviousMode,
                                                (PVOID *)&SectionToMap,
                                                NULL );

            if (NT_SUCCESS( Status )) {

                Status = MmMapViewOfSection( SectionToMap,
                                             PsGetCurrentProcess(),
                                             &ServerPort->ServerSectionBase,
                                             0,
                                             0,
                                             &LargeSectionOffset,
                                             &CapturedServerView.ViewSize,
                                             ViewUnmap,
                                             0,
                                             PAGE_READWRITE );

                if (NT_SUCCESS( Status )) {

                    //
                    //  The section was mapped into the server process. We'll add a
                    //  reference to the server process only if we didn't before.
                    //

                    if ( ServerPort->MappingProcess == NULL ) {

                        ServerPort->MappingProcess = PsGetCurrentProcess();
                        ObReferenceObject( ServerPort->MappingProcess );
                    }

                    CapturedServerView.SectionOffset = LargeSectionOffset.LowPart;

                    CapturedServerView.ViewBase = ServerPort->ServerSectionBase;


                    SectionOffset.LowPart = CapturedServerView.SectionOffset;
                    SectionOffset.HighPart = 0;

                    ViewSize = CapturedServerView.ViewSize;

                    Status = MmMapViewOfSection( SectionToMap,
                                                 ClientProcess,
                                                 &ClientPort->ServerSectionBase,
                                                 0,
                                                 0,
                                                 &SectionOffset,
                                                 &ViewSize,
                                                 ViewUnmap,
                                                 0,
                                                 PAGE_READWRITE );

                    if (NT_SUCCESS( Status )) {

                        //
                        //  The section was mapped into the client process. We'll add a
                        //  reference to the client process only we didn't before.
                        //  (we don't have also a client section)
                        //

                        if ( ClientPort->MappingProcess == NULL ) {

                            ClientPort->MappingProcess = ClientProcess;
                            ObReferenceObject( ClientProcess );
                        }

                        //
                        //  Let the server know where the client's view of the
                        //  section got mapped
                        //

                        CapturedServerView.ViewRemoteBase = ClientPort->ServerSectionBase;

                        //
                        //  Let the client know where the server's view of the
                        //  section got mapped
                        //

                        ConnectMsg->ServerView.ViewBase = ClientPort->ServerSectionBase;
                        ConnectMsg->ServerView.ViewSize = ViewSize;

                    } else {

                        ObDereferenceObject( ServerPort );
                    }

                } else {

                    ObDereferenceObject( ServerPort );
                }

                ObDereferenceObject( SectionToMap );

            } else {

                ObDereferenceObject( ServerPort );
            }
        }

        //
        //  Insert the server communication port object in specified object
        //  table.  Set port handle value if successful.  If not
        //  successful, then the port will have been dereferenced, which
        //  will cause it to be freed, after our delete procedure is
        //  called.  The delete procedure will undo the work done to
        //  initialize the port.
        //

        if (NT_SUCCESS( Status )) {

            //
            //  Add an extra reference to the object otherwise right when we
            //  create the handle a rouge caller might close and destroy the
            //  port.
            //

            ObReferenceObject( ServerPort );

            //
            //  Now add the handle
            //

            Status = ObInsertObject( ServerPort,
                                     NULL,
                                     PORT_ALL_ACCESS,
                                     0,
                                     (PVOID *)NULL,
                                     &Handle );

            if (NT_SUCCESS( Status )) {

                try {

                    if (ARGUMENT_PRESENT( ServerView )) {

                        *ServerView = CapturedServerView;
                    }

                    if (ARGUMENT_PRESENT( ClientView )) {

                        ClientView->ViewBase = ConnectMsg->ClientView.ViewRemoteBase;
                        ClientView->ViewSize = ConnectMsg->ClientView.ViewSize;
                    }

                    *PortHandle = Handle;

                    if (!ARGUMENT_PRESENT( PortContext )) {

                        ServerPort->PortContext = Handle;
                    }

                    ServerPort->ClientThread = ClientThread;

                    LpcpAcquireLpcpLock();
                    ClientThread->LpcReplyMessage = Msg;
                    LpcpReleaseLpcpLock();

                    ClientThread = NULL;

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    NtClose( Handle );
                    Status = GetExceptionCode();
                }
            }

            //
            //  Now we can remove the extra object reference
            //

            ObDereferenceObject( ServerPort );
        }

    } else {

        //
        //  Otherwise the server has not accepted the connection request
        //

        LpcpPrint(( "Refusing connection from %x.%x\n",
                    Msg->Request.ClientId.UniqueProcess,
                    Msg->Request.ClientId.UniqueThread ));
    }

bailout:

    if ( ClientSectionToMap ) {

        ObDereferenceObject( ClientSectionToMap );
    }

    //
    //  If the client is not null then this is an error condition and we need
    //  to cleanup and wake the client thread.  In success cases the client
    //  thread is woken up with a call to Complete Connect Request
    //

    if (ClientThread != NULL) {

        LpcpAcquireLpcpLock();

        ClientThread->LpcReplyMessage = Msg;

        if (AcceptConnection) {

            LpcpPrint(( "LPC: Failing AcceptConnection with Status == %x\n", Status ));
        }

        LpcpPrepareToWakeClient( ClientThread );

        LpcpReleaseLpcpLock();

        //
        //  Wake up the thread that is waiting for an answer to its connection
        //  request inside of NtConnectPort.
        //

        KeReleaseSemaphore( &ClientThread->LpcReplySemaphore,
                            0,
                            1L,
                            FALSE );

        //
        //  Dereference client thread and return the system service status.
        //

        ObDereferenceObject( ClientThread );
    }

    if (ClientPort) {

        ObDereferenceObject( ClientPort );
    }

    ObDereferenceObject( ClientProcess );

    //
    //  And return to our caller
    //

    return Status;
}


NTSTATUS
NtCompleteConnectPort (
    IN HANDLE PortHandle
    )

/*++

Routine Description:

    This routine is called by the server after it calls NtAcceptConnectPort to
    wake up the client thread.  Between calling NtAcceptConnectPort and
    NtCompleteConnectPort the server can do whatever work is necessary before
    waking up the client

Arguments:

    PortHandle - Supplies a handle to the server communication port

Return Value:

    NTSTATUS - An appropriate status value.

--*/

{
    PLPCP_PORT_OBJECT PortObject;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PETHREAD ClientThread;

    PAGED_CODE();

    //
    //  Get previous processor mode
    //

    PreviousMode = KeGetPreviousMode();

    //
    //  Reference the port object by handle
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Error if a port type is invalid.
    //

    if ((PortObject->Flags & PORT_TYPE) != SERVER_COMMUNICATION_PORT) {

        ObDereferenceObject( PortObject );

        return STATUS_INVALID_PORT_HANDLE;
    }

    //
    //  Under the LPC lock we need to check for a client thread and if there
    //  is one we'll remember and remove the client thread, and then prepare
    //  to wake the client
    //

    LpcpAcquireLpcpLock();

    if (PortObject->ClientThread == NULL) {

        LpcpReleaseLpcpLock();

        ObDereferenceObject( PortObject );

        return STATUS_INVALID_PARAMETER;
    }

    ClientThread = PortObject->ClientThread;

    //
    //  Double check that the thread is still waiting for a reply message
    //

    if (LpcpGetThreadMessage(ClientThread) == NULL) {

        LpcpReleaseLpcpLock();

        ObDereferenceObject( PortObject );
        //
        // At this point the client has already been woken. We will get a client died message
        //
        return STATUS_SUCCESS;
    }

    //
    //  The check needs to ensure that the client thread is really on the
    //  reply chain for the sever's connection port.  This is a quick and
    //  dirty fix for NT 5.0.  We zoom down the connection port lpc reply
    //  chain looking for an entry that contains the client threads.  If
    //  we find a match it's okay if we don't it's bad.
    //

    if (PortObject->ConnectionPort) {
        
        PLIST_ENTRY Entry;

        for (Entry = PortObject->ConnectionPort->LpcReplyChainHead.Flink;
             Entry != (PLIST_ENTRY)(&PortObject->ConnectionPort->LpcReplyChainHead.Flink);
             Entry = Entry->Flink) {

            if (Entry == ((PLIST_ENTRY)(&ClientThread->LpcReplyChain.Flink))) {

                break;
            }
        }

        if (Entry != ((PLIST_ENTRY)(&ClientThread->LpcReplyChain.Flink))) {

            LpcpReleaseLpcpLock();

            ObDereferenceObject( PortObject );

            //
            // At this point the client has already been woken. We will get a client died message
            //
            return STATUS_SUCCESS;
        }
    }

    //
    //  Now do the wakeup
    //

    PortObject->ClientThread = NULL;

    LpcpPrepareToWakeClient( ClientThread );

    LpcpReleaseLpcpLock();

    //
    //  Wake up the thread that is waiting for an answer to its connection
    //  request inside of NtConnectPort.
    //

    KeReleaseSemaphore( &ClientThread->LpcReplySemaphore,
                        0,
                        1L,
                        FALSE );

    //
    //  Dereference client thread
    //

    ObDereferenceObject( ClientThread );
    ObDereferenceObject( PortObject );

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Local support routine
//

VOID
LpcpPrepareToWakeClient (
    IN PETHREAD ClientThread
    )

/*++

Routine Description:

    This routine is used to prepare the client thread to receive a reply to
    its connection request

Arguments:

    ClientThread - Specifies the thread we are preparing to wake up

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Remove the thread from the rundown list the connection port as we are
    //  sending a reply.  The operation only needs to take place if the
    //  thread isn't exiting and it's in the lpc reply chain for a connection
    //  port
    //

    if ((!ClientThread->LpcExitThreadCalled) &&
        (!IsListEmpty( &ClientThread->LpcReplyChain ))) {

        RemoveEntryList( &ClientThread->LpcReplyChain );
        InitializeListHead( &ClientThread->LpcReplyChain );
    }

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpccreat.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpccreat.c

Abstract:

    Local Inter-Process Communication (LPC) connection system services.

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#include "lpcp.h"

//
//  Local procedure prototype
//

NTSTATUS
LpcpCreatePort (
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage,
    IN BOOLEAN Waitable
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtCreatePort)
#pragma alloc_text(PAGE,NtCreateWaitablePort)
#pragma alloc_text(PAGE,LpcpCreatePort)
#endif


NTSTATUS
NtCreatePort (
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage
    )

/*++

Routine Description:

    See LpcpCreatePort.

Arguments:

    See LpcpCreatePort.

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    Status = LpcpCreatePort( PortHandle,
                             ObjectAttributes,
                             MaxConnectionInfoLength,
                             MaxMessageLength,
                             MaxPoolUsage,
                             FALSE );

    return Status ;

}


NTSTATUS
NtCreateWaitablePort (
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage
    )

/*++

Routine Description:

    Same as NtCreatePort.

    The only difference between this call and NtCreatePort is that the
    working KEVENT that can be used to wait for LPC messages to arrive
    asynchronously.

Arguments:

    See LpcpCreatePort.

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status ;

    PAGED_CODE();

    Status = LpcpCreatePort( PortHandle,
                             ObjectAttributes,
                             MaxConnectionInfoLength,
                             MaxMessageLength,
                             MaxPoolUsage,
                             TRUE );

    return Status ;
}


//
//  Local support routine
//

NTSTATUS
LpcpCreatePort (
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage,
    IN BOOLEAN Waitable
    )

/*++

Routine Description:

    A server process can create a named connection port with the NtCreatePort
    service.

    A connection port is created with the name and SECURITY_DESCRIPTOR
    specified in the ObjectAttributes structure.  A handle to the connection
    port object is returned in the location pointed to by the PortHandle
    parameter.  The returned handle can then be used to listen for connection
    requests to that port name, using the NtListenPort service.

    The standard object architecture defined desired access parameter is not
    necessary since this service can only create a new port, not access an
    existing port.

    Connection ports cannot be used to send and receive messages.  They are
    only valid as a parameter to the NtListenPort service.

Arguments:

    PortHandle - A pointer to a variable that will receive the connection port
        object handle value.

    ObjectAttributes - A pointer to a structure that specifies the name of the
        object, an access control list (SECURITY_DESCRIPTOR) to be applied to
        the object, and a set of object attribute flags.

        PUNICODE_STRING ObjectName - An optional pointer to a null terminated
            port name string.  The form of the name is
            [\name...\name]\port_name.  If no name is specified then an
            unconnected communication port is created rather than a connection
            port.  This is useful for sending and receiving messages between
            threads of a single process.

        ULONG Attributes - A set of flags that control the port object
            attributes.

            None of the standard values are relevant for this call.
            Connection ports cannot be inherited, are always placed in the
            system handle table and are exclusive to the creating process.
            This field must be zero.  Future implementations might support
            specifying the OBJ_PERMANENT attribute.

    MaxMessageLength - Specifies the maximum length of messages sent or
        received on communication ports created from this connection
        port.  The value of this parameter cannot exceed
        MAX_PORTMSG_LENGTH bytes.

    MaxPoolUsage - Specifies the maximum amount of NonPaged pool used for
        message storage.

    Waitable - Specifies if the event used by the port can be use to wait
        for LPC messages to arrive asynchronously.

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    PLPCP_PORT_OBJECT ConnectionPort;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PUNICODE_STRING NamePtr;
    UNICODE_STRING CapturedObjectName;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (MaxPoolUsage);

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    RtlInitUnicodeString( &CapturedObjectName, NULL );

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteHandle( PortHandle );

            ProbeForReadSmallStructure( ObjectAttributes,
                                        sizeof( OBJECT_ATTRIBUTES ),
                                        sizeof( ULONG ));

            NamePtr = ObjectAttributes->ObjectName;

            if (NamePtr != NULL) {

                CapturedObjectName = ProbeAndReadStructure( NamePtr,
                                                            UNICODE_STRING );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }

    } else {

        if (ObjectAttributes->ObjectName != NULL) {

            CapturedObjectName = *(ObjectAttributes->ObjectName);
        }
    }

    //
    //  Make the null buffer indicate an unspecified port name
    //

    if (CapturedObjectName.Length == 0) {

        CapturedObjectName.Buffer = NULL;
    }

    //
    //  Allocate and initialize a port object.  If an object name was
    //  specified, then this is a connection port.  Otherwise this is an
    //  unconnected communication port that a process can use to communicate
    //  between threads.
    //

    Status = ObCreateObject( PreviousMode,
                             (Waitable ? LpcWaitablePortObjectType
                                       : LpcPortObjectType),
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             (Waitable ? sizeof( LPCP_PORT_OBJECT )
                                       : FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent )),
                             0,
                             0,
                             (PVOID *)&ConnectionPort );

    if (!NT_SUCCESS( Status )) {

        return( Status );
    }

    //
    //  Zero out the connection port object and then initialize its fields
    //

    RtlZeroMemory( ConnectionPort, (Waitable ? sizeof( LPCP_PORT_OBJECT )
                                             : FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent )));

    ConnectionPort->ConnectionPort = ConnectionPort;
    ConnectionPort->Creator = PsGetCurrentThread()->Cid;

    InitializeListHead( &ConnectionPort->LpcReplyChainHead );

    InitializeListHead( &ConnectionPort->LpcDataInfoChainHead );

    //
    //  Named ports get a connection message queue.
    //

    if (CapturedObjectName.Buffer == NULL) {

        ConnectionPort->Flags = UNCONNECTED_COMMUNICATION_PORT;
        ConnectionPort->ConnectedPort = ConnectionPort;
        ConnectionPort->ServerProcess = NULL;

    } else {

        ConnectionPort->Flags = SERVER_CONNECTION_PORT;

        ObReferenceObject( PsGetCurrentProcess() );
        ConnectionPort->ServerProcess = PsGetCurrentProcess();
    }
    
    if ( Waitable ) {

        ConnectionPort->Flags |= PORT_WAITABLE;
    }
    
    //
    //  All ports get a request message queue.
    //

    Status = LpcpInitializePortQueue( ConnectionPort );

    if (!NT_SUCCESS(Status)) {

        ObDereferenceObject( ConnectionPort );

        return(Status);
    }

    //
    //  For a waitable port, create the KEVENT that will
    //  be used to signal clients
    //

    if (ConnectionPort->Flags & PORT_WAITABLE) {

        KeInitializeEvent( &ConnectionPort->WaitEvent,
                           NotificationEvent,
                           FALSE );
    }

    //
    //  Set the maximum message length and connection info length based on the
    //  zone block size less the structs overhead.
    //

    ConnectionPort->MaxMessageLength = (USHORT) (LpcpGetMaxMessageLength() -
                                                 FIELD_OFFSET( LPCP_MESSAGE, Request ));

    ConnectionPort->MaxConnectionInfoLength = (USHORT) (ConnectionPort->MaxMessageLength -
                                                        sizeof( PORT_MESSAGE ) -
                                                        sizeof( LPCP_CONNECTION_MESSAGE ));

#if DBG
    LpcpTrace(( "Created port %ws (%x) - MaxMsgLen == %x  MaxConnectInfoLen == %x\n",
                CapturedObjectName.Buffer == NULL ? L"** UnNamed **" : ObjectAttributes->ObjectName->Buffer,
                ConnectionPort,
                ConnectionPort->MaxMessageLength,
                ConnectionPort->MaxConnectionInfoLength ));
#endif

    //
    //  Sanity check that the max message length being asked for is not
    //  greater than the max message length possible in the system
    //

    if (ConnectionPort->MaxMessageLength < MaxMessageLength) {

#if DBG
        LpcpPrint(( "MaxMessageLength granted is %x but requested %x\n",
                    ConnectionPort->MaxMessageLength,
                    MaxMessageLength ));
        DbgBreakPoint();
#endif

        ObDereferenceObject( ConnectionPort );

        return STATUS_INVALID_PARAMETER_4;
    }
    
    //
    //  Save the MaxMessageLength to the connection port
    //

    ConnectionPort->MaxMessageLength = (USHORT) MaxMessageLength;

    //
    //  Sanity check that the max connection info length being asked for is
    //  not greater than the maximum possible in the system
    //

    if (ConnectionPort->MaxConnectionInfoLength < MaxConnectionInfoLength) {

#if DBG
        LpcpPrint(( "MaxConnectionInfoLength granted is %x but requested %x\n",
                    ConnectionPort->MaxConnectionInfoLength,
                    MaxConnectionInfoLength ));
        DbgBreakPoint();
#endif

        ObDereferenceObject( ConnectionPort );

        return STATUS_INVALID_PARAMETER_3;
    }

    //
    //  Insert connection port object in specified object table.  Set port
    //  handle value if successful.  If not successful, then the port will
    //  have been dereferenced, which will cause it to be freed, after our
    //  delete procedure is called.  The delete procedure will undo the work
    //  done to initialize the port.  Finally, return the system server status.
    //

    Status = ObInsertObject( ConnectionPort,
                             NULL,
                             PORT_ALL_ACCESS,
                             0,
                             (PVOID *)NULL,
                             &Handle );

    if (NT_SUCCESS( Status )) {

        //
        //  Set the output variable protected against access faults
        //

        try {

            *PortHandle = Handle;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            NtClose( Handle );

            Status = GetExceptionCode();
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpclistn.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpclistn.c

Abstract:

    Local Inter-Process Communication (LPC) connection system services.

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#include "lpcp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtListenPort)
#endif


NTSTATUS
NtListenPort (
    IN HANDLE PortHandle,
    OUT PPORT_MESSAGE ConnectionRequest
    )

/*++

Routine Description:

    A server thread can listen for connection requests from client threads
    using the NtReplyWaitReceivePort service and looking for an
    LPC_CONNECTION_REQUEST message type.

    This call will loop, calling the NtReplyWaitReceivePort service, and
    return when it sees a message of type LPC_CONNECTION_REQUEST

Arguments:

    PortHandle - Specifies the connection port to listen for connection
        requests to.

    ConnectionRequest - Pointer to a structure that describes the
        connection request the client is making:

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Keep on looping until we get a connection request on the lpc port
    //

    while (TRUE) {

        Status = NtReplyWaitReceivePort( PortHandle,
                                         NULL,
                                         NULL,
                                         ConnectionRequest );

        //
        //  We'll return from this procedure if ever we get back non success
        //  or the message is a connection request.  We still need to protect
        //  the testing of ConnectionRequest because it is a user supplied
        //  buffer.
        //

        try {

            if ((Status != STATUS_SUCCESS) ||
                ((ConnectionRequest->u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_CONNECTION_REQUEST)) {

                break;
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();

            break;
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpcp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpcp.h

Abstract:

    Private include file for the LPC subcomponent of the NTOS project

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4310)   // cast truncates constant value

#include "ntos.h"
#include <zwapi.h>


//
//  Global Mutex to guard the following fields:
//
//      ETHREAD.LpcReplyMsg
//      LPCP_PORT_QUEUE.ReceiveHead
//
//  Mutex is never held longer than is necessary to modify or read the field.
//  Contains an additional field to track the owner of the mutex.
//

typedef struct _LPC_MUTEX {

    FAST_MUTEX  Lock;

    //
    //  field that holds the thread that owns the lock
    //

    PETHREAD    Owner;

} LPC_MUTEX, *PLPC_MUTEX;


extern LPC_MUTEX LpcpLock;

extern ULONG LpcpMaxMessageSize;

#define LpcpGetMaxMessageLength() (LpcpMaxMessageSize)

extern ULONG LpcpNextMessageId;

extern ULONG LpcpNextCallbackId;

#define LpcpGenerateMessageId() \
    LpcpNextMessageId++;    if (LpcpNextMessageId == 0) LpcpNextMessageId = 1;

#define LpcpGenerateCallbackId() \
    LpcpNextCallbackId++;    if (LpcpNextCallbackId == 0) LpcpNextCallbackId = 1;

extern ULONG LpcpTotalNumberOfMessages;

//
//  Global macrodefinitions to acquire and release the LPC_MUTEX
//  in order to track the owner and allow recursive calls
//

#define LpcpInitializeLpcpLock()                             \
{                                                            \
    ExInitializeFastMutex( &LpcpLock.Lock );                 \
    LpcpLock.Owner = NULL;                                   \
}

#define LpcpAcquireLpcpLock()                                       \
{                                                                   \
    ASSERT ( LpcpLock.Owner != PsGetCurrentThread() );              \
                                                                    \
    ExAcquireFastMutex( &LpcpLock.Lock );                           \
    LpcpLock.Owner = PsGetCurrentThread();                          \
}

#define LpcpAcquireLpcpLockByThread(Thread)                         \
{                                                                   \
    ASSERT ( LpcpLock.Owner != PsGetCurrentThread() );              \
                                                                    \
    ExAcquireFastMutex( &LpcpLock.Lock );                           \
    LpcpLock.Owner = Thread;                                        \
}

#define LpcpReleaseLpcpLock()                                       \
{                                                                   \
    ASSERT( LpcpLock.Owner == PsGetCurrentThread() );               \
                                                                    \
    LpcpLock.Owner = NULL;                                          \
    ExReleaseFastMutex( &LpcpLock.Lock );                           \
}


//
//  Internal Entry Points defined in lpcclose.c
//

VOID
LpcpClosePort (
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG ProcessHandleCount,
    IN ULONG SystemHandleCount
    );

VOID
LpcpDeletePort (
    IN PVOID Object
    );


//
//  Entry points defined in lpcqueue.c
//

NTSTATUS
LpcpInitializePortQueue (
    IN PLPCP_PORT_OBJECT Port
    );

VOID
LpcpDestroyPortQueue (
    IN PLPCP_PORT_OBJECT Port,
    IN BOOLEAN CleanupAndDestroy
    );

VOID
LpcpInitializePortZone (
    IN ULONG MaxEntrySize
    );

NTSTATUS
LpcpExtendPortZone (
    VOID
    );

VOID
LpcpSaveDataInfoMessage (
    IN PLPCP_PORT_OBJECT Port,
    IN PLPCP_MESSAGE Msg,
    IN ULONG MutexFlags
    );

VOID
LpcpFreeDataInfoMessage (
    IN PLPCP_PORT_OBJECT Port,
    IN ULONG MessageId,
    IN ULONG CallbackId
    );

PLPCP_MESSAGE
LpcpFindDataInfoMessage (
    IN PLPCP_PORT_OBJECT Port,
    IN ULONG MessageId,
    IN ULONG CallbackId
    );


//
//  Entry points defined in lpcquery.c
//


//
//  Entry points defined in lpcmove.s and lpcmove.asm
//

VOID
LpcpMoveMessage (
    OUT PPORT_MESSAGE DstMsg,
    IN PPORT_MESSAGE SrcMsg,
    IN PVOID SrcMsgData,
    IN ULONG MsgType OPTIONAL,
    IN PCLIENT_ID ClientId OPTIONAL
    );


//
//  Internal Entry Points defined in lpcpriv.c
//

VOID
LpcpFreePortClientSecurity (
    IN PLPCP_PORT_OBJECT Port
    );


//
//  Macro Procedures used by RequestWaitReply, Reply, ReplyWaitReceive,
//  and ReplyWaitReply services
//

#define LpcpGetDynamicClientSecurity(Thread,Port,DynamicSecurity) \
    SeCreateClientSecurity((Thread),&(Port)->SecurityQos,FALSE,(DynamicSecurity))

#define LpcpFreeDynamicClientSecurity(DynamicSecurity) \
    SeDeleteClientSecurity( DynamicSecurity )

#define LpcpReferencePortObject(PortHandle,PortAccess,PreviousMode,PortObject) \
    ObReferenceObjectByHandle((PortHandle),(PortAccess),LpcPortObjectType,(PreviousMode),(PVOID *)(PortObject),NULL)

#define LPC_PORT_MASK_BIT 1

#define LpcpGetThreadMessage(T)                                                  \
    (                                                                            \
        (((ULONG_PTR)(T)->LpcReplyMessage) & LPC_PORT_MASK_BIT) ? NULL : (PLPCP_MESSAGE)(T)->LpcReplyMessage \
    )

#define LpcpGetThreadPort(T)                                                     \
    (                                                                            \
        (((ULONG_PTR)(T)->LpcReplyMessage) & LPC_PORT_MASK_BIT) ?                             \
            (PLPCP_PORT_OBJECT)(((ULONG_PTR)(T)->LpcWaitingOnPort) & ~LPC_PORT_MASK_BIT):     \
            NULL                                                                 \
    )

#define LpcpSetPortToThread(T,P) \
    (T)->LpcWaitingOnPort = (PVOID)(((ULONG_PTR)P) | LPC_PORT_MASK_BIT);

#define LPCP_VALIDATE_REASON_IMPERSONATION  1
#define LPCP_VALIDATE_REASON_REPLY          2
#define LPCP_VALIDATE_REASON_WRONG_DATA     3

BOOLEAN
FASTCALL
LpcpValidateClientPort(
    IN PETHREAD Thread,
    IN PLPCP_PORT_OBJECT ReplyPort,
    IN ULONG Reason
    );


//
//  Entry Points defined in lpcinit.c
//

#if DBG
#define ENABLE_LPC_TRACING 1
#else
#define ENABLE_LPC_TRACING 0
#endif

#if ENABLE_LPC_TRACING
BOOLEAN LpcpStopOnReplyMismatch;
BOOLEAN LpcpTraceMessages;

char *LpcpMessageTypeName[];

char *
LpcpGetCreatorName (
    PLPCP_PORT_OBJECT PortObject
    );

#define LpcpPrint( _x_ ) {                              \
    DbgPrint( "LPC[ %02x.%02x ]: ",                     \
              PsGetCurrentThread()->Cid.UniqueProcess,  \
              PsGetCurrentThread()->Cid.UniqueThread ); \
    DbgPrint _x_ ;                                      \
}

#define LpcpTrace( _x_ ) if (LpcpTraceMessages) { LpcpPrint( _x_ ); }

#else

#define LpcpPrint( _x_ )
#define LpcpTrace( _x_ )

#endif // ENABLE_LPC_TRACING

extern PAGED_LOOKASIDE_LIST LpcpMessagesLookaside;

__forceinline
PLPCP_MESSAGE
LpcpAllocateFromPortZone (
    ULONG Size
    )
{
    PLPCP_MESSAGE Msg;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Size);

    Msg = ExAllocateFromPagedLookasideList( &LpcpMessagesLookaside );

    if (Msg != NULL) {

        LpcpTrace(( "Allocate Msg %lx\n", Msg ));

        InitializeListHead( &Msg->Entry );

        Msg->RepliedToThread = NULL;

        //
        //  Clear the message type field. In some failure paths this message get freed
        //  w/o having it initialized.
        //

        Msg->Request.u2.s2.Type = 0;

        return Msg;
    }

    return NULL;
}


#define LPCP_MUTEX_OWNED                0x1
#define LPCP_MUTEX_RELEASE_ON_RETURN    0x2

VOID
FASTCALL
LpcpFreeToPortZone (
    IN PLPCP_MESSAGE Msg,
    IN ULONG MutexFlags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpcpriv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpcpriv.c

Abstract:

    Local Inter-Process Communication priviledged procedures that implement
    client impersonation.

Author:

    Steve Wood (stevewo) 15-Nov-1989


Revision History:

--*/

#include "lpcp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,LpcpFreePortClientSecurity)
#pragma alloc_text(PAGE,NtImpersonateClientOfPort)
#endif


NTSTATUS
NtImpersonateClientOfPort (
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message
    )

/*++

Routine Description:

    This procedure is used by the server thread to temporarily acquire the
    identifier set of a client thread.

    This service establishes an impersonation token for the calling thread.
    The impersonation token corresponds to the context provided by the port
    client.  The client must currently be waiting for a reply to the
    specified message.

    This service returns an error status code if the client thread is not
    waiting for a reply to the message.  The security quality of service
    parameters specified by the client upon connection dictate what use the
    server will have of the client's security context.

    For complicated or extended impersonation needs, the server may open a
    copy of the client's token (using NtOpenThreadToken()).  This must be
    done while impersonating the client.

Arguments:

    PortHandle - Specifies the handle of the communication port that the
        message was received from.

    Message - Specifies an address of a message that was received from the
        client that is to be impersonated.  The ClientId field of the message
        identifies the client thread that is to be impersonated.  The client
        thread must be waiting for a reply to the message in order to
        impersonate the client.

Return Value:

    NTSTATUS - Status code that indicates whether or not the operation was
    successful.

--*/

{
    PLPCP_PORT_OBJECT PortObject;
    PLPCP_PORT_OBJECT ConnectedPort;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PETHREAD ClientThread;
    CLIENT_ID CapturedClientId;
    ULONG CapturedMessageId;
    SECURITY_CLIENT_CONTEXT DynamicSecurity;

    PAGED_CODE();

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForReadSmallStructure( Message, sizeof( PORT_MESSAGE ), sizeof( ULONG ));

            CapturedClientId = Message->ClientId;
            CapturedMessageId = Message->MessageId;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }

    } else {

        CapturedClientId = Message->ClientId;
        CapturedMessageId = Message->MessageId;
    }

    //
    //  Reference the communication port object by handle.  Return status if
    //  unsuccessful.
    //

    Status = LpcpReferencePortObject( PortHandle, 0,
                                      PreviousMode, &PortObject );
    if (!NT_SUCCESS( Status )) {

        return( Status );
    }

    //
    //  It is an error to try this on any port other than a server
    //  communication port
    //

    if ((PortObject->Flags & PORT_TYPE) != SERVER_COMMUNICATION_PORT) {

        ObDereferenceObject( PortObject );

        return( STATUS_INVALID_PORT_HANDLE );
    }

    //
    //  Translate the ClientId from the connection request into a
    //  thread pointer.  This is a referenced pointer to keep the thread
    //  from evaporating out from under us.
    //

    Status = PsLookupProcessThreadByCid( &CapturedClientId,
                                         NULL,
                                         &ClientThread );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( PortObject );

        return( Status );
    }

    //
    //  Acquire the mutex that guards the LpcReplyMessage field of
    //  the thread and get the pointer to the message that the thread
    //  is waiting for a reply to.
    //

    LpcpAcquireLpcpLock();

    //
    //  The connected port can be in a state with 0 references in a deletion process.
    //  We need to test this case while referencing it.
    //

    ConnectedPort = PortObject->ConnectedPort;
    
    if ( ( ConnectedPort == NULL ) || 
         ( !ObReferenceObjectSafe( ConnectedPort ) ) ) {

        //
        //  The port is being deleted. Quit this function with 
        //  appropriate return status. 
        //  We don't need to dereference the connected port because 
        //  it is anyway about to be deleted
        //

        LpcpReleaseLpcpLock();

        ObDereferenceObject( PortObject );
        ObDereferenceObject( ClientThread );

        return( STATUS_PORT_DISCONNECTED );
    }

    //
    //  See if the thread is waiting for a reply to the message
    //  specified on this call, if the user gave us a bad
    //  message id.  If not then a bogus message
    //  has been specified, so return failure.
    //

    //
    //  The W2k fix searched the client thread in the rundown queue, to make sure
    //  we are not impersonating a port from a different connection. Ones we added the port
    //  to the thread structure to fix other security issues for reply os accessing data
    //  we can use that easy test for the impersonation too, w/o searching the rundown queue
    //

    if ((ClientThread->LpcReplyMessageId != CapturedMessageId) 
            ||
        (CapturedMessageId == 0) 
            ||
        (!LpcpValidateClientPort( ClientThread, 
                                  PortObject, 
                                  LPCP_VALIDATE_REASON_IMPERSONATION)) ) {

        LpcpReleaseLpcpLock();

        ObDereferenceObject( PortObject );
        ObDereferenceObject( ClientThread );
        ObDereferenceObject( ConnectedPort );

        return (STATUS_REPLY_MESSAGE_MISMATCH);
    }

    LpcpReleaseLpcpLock();

    //
    //  If the client requested dynamic security tracking, then the client
    //  security needs to be referenced.  Otherwise, (static case)
    //  it is already in the client's port.
    //

    if (ConnectedPort->Flags & PORT_DYNAMIC_SECURITY) {

        //
        //  Impersonate the client with information from the queued message
        //

        Status = LpcpGetDynamicClientSecurity( ClientThread,
                                               PortObject->ConnectedPort,
                                               &DynamicSecurity );

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( PortObject );
            ObDereferenceObject( ClientThread );
            ObDereferenceObject( ConnectedPort );

            return( Status );
        }

        Status = SeImpersonateClientEx( &DynamicSecurity, NULL );

        LpcpFreeDynamicClientSecurity( &DynamicSecurity );

    } else {

        //
        //  Impersonate the client with information from the client's port
        //

        Status = SeImpersonateClientEx( &ConnectedPort->StaticSecurity, NULL );

    }

    ObDereferenceObject( PortObject );
    ObDereferenceObject( ClientThread );
    ObDereferenceObject( ConnectedPort );

    //
    //  And return to our caller
    //

    return Status;
}


VOID
LpcpFreePortClientSecurity (
    IN PLPCP_PORT_OBJECT Port
    )

/*++

Routine Description:

    This routine cleans up the captured security context for a client port.
    The cleanup is typically done when we are deleting a port

Arguments:

    Port - Supplies the client port being deleted

Return Value:

    None.

--*/

{
    //
    //  We only do this action if supplied with a client communication port
    //

    if ((Port->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

        //
        //  We only do this action if the port has static security tracking,
        //  and we have a captured client token.  The action is to simply
        //  delete the client token.
        //

        if (!(Port->Flags & PORT_DYNAMIC_SECURITY)) {

            if ( Port->StaticSecurity.ClientToken ) {

                SeDeleteClientSecurity( &(Port)->StaticSecurity );
            }
        }
    }

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpcinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpcinit.c

Abstract:

    Initialization module for the LPC subcomponent of NTOS

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#include "lpcp.h"

//
//  The following two object types are defined system wide to handle lpc ports
//

POBJECT_TYPE LpcPortObjectType;
POBJECT_TYPE LpcWaitablePortObjectType;

//
//  This is the default access mask mapping for lpc port objects
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#pragma data_seg("PAGEDATA")
#endif // ALLOC_DATA_PRAGMA
const GENERIC_MAPPING LpcpPortMapping = {
    READ_CONTROL | PORT_CONNECT,
    DELETE | PORT_CONNECT,
    0,
    PORT_ALL_ACCESS
};
ULONG LpcpNextMessageId = 1;
ULONG LpcpNextCallbackId = 1;
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#pragma data_seg()
#endif // ALLOC_DATA_PRAGMA

//
//  This lock is used to protect practically everything in lpc
//

LPC_MUTEX LpcpLock;

//
//  The following array of strings is used to debugger purposes and the
//  values correspond to the Port message types defined in ntlpcapi.h
//

#if ENABLE_LPC_TRACING

char *LpcpMessageTypeName[] = {
    "UNUSED_MSG_TYPE",
    "LPC_REQUEST",
    "LPC_REPLY",
    "LPC_DATAGRAM",
    "LPC_LOST_REPLY",
    "LPC_PORT_CLOSED",
    "LPC_CLIENT_DIED",
    "LPC_EXCEPTION",
    "LPC_DEBUG_EVENT",
    "LPC_ERROR_EVENT",
    "LPC_CONNECTION_REQUEST"
};

#endif // ENABLE_LPC_TRACING

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,LpcInitSystem)

#if ENABLE_LPC_TRACING
#pragma alloc_text(PAGE,LpcpGetCreatorName)
#endif // ENABLE_LPC_TRACING

#endif // ALLOC_PRAGMA


BOOLEAN
LpcInitSystem (
    VOID
)

/*++

Routine Description:

    This function performs the system initialization for the LPC package.
    LPC stands for Local Inter-Process Communication.

Arguments:

    None.

Return Value:

    TRUE if successful and FALSE if an error occurred.

    The following errors can occur:

    - insufficient memory

--*/

{
    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    UNICODE_STRING PortTypeName;
    ULONG ZoneElementSize;

    //
    //  Initialize our global lpc lock
    //

    LpcpInitializeLpcpLock();

    //
    //  Create the object type for the port object
    //

    RtlInitUnicodeString( &PortTypeName, L"Port" );

    RtlZeroMemory( &ObjectTypeInitializer, sizeof( ObjectTypeInitializer ));

    ObjectTypeInitializer.Length = sizeof( ObjectTypeInitializer );
    ObjectTypeInitializer.GenericMapping = LpcpPortMapping;
    ObjectTypeInitializer.MaintainTypeList = FALSE;
    ObjectTypeInitializer.PoolType = PagedPool;
    ObjectTypeInitializer.DefaultPagedPoolCharge = FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent );
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof( LPCP_NONPAGED_PORT_QUEUE );
    ObjectTypeInitializer.InvalidAttributes = OBJ_VALID_ATTRIBUTES ^ PORT_VALID_OBJECT_ATTRIBUTES;
    ObjectTypeInitializer.ValidAccessMask = PORT_ALL_ACCESS;
    ObjectTypeInitializer.CloseProcedure = LpcpClosePort;
    ObjectTypeInitializer.DeleteProcedure = LpcpDeletePort;
    ObjectTypeInitializer.UseDefaultObject = TRUE ;

    ObCreateObjectType( &PortTypeName,
                        &ObjectTypeInitializer,
                        (PSECURITY_DESCRIPTOR)NULL,
                        &LpcPortObjectType );

    //
    //  Create the object type for the waitable port object
    //

    RtlInitUnicodeString( &PortTypeName, L"WaitablePort" );
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge += sizeof( LPCP_PORT_OBJECT );
    ObjectTypeInitializer.DefaultPagedPoolCharge = 0;
    ObjectTypeInitializer.UseDefaultObject = FALSE;

    ObCreateObjectType( &PortTypeName,
                        &ObjectTypeInitializer,
                        (PSECURITY_DESCRIPTOR)NULL,
                        &LpcWaitablePortObjectType );

    //
    //  Initialize the lpc port zone.  Each element can contain a max
    //  message, plus an LPCP message structure, plus an LPCP connection
    //  message
    //

    ZoneElementSize = PORT_MAXIMUM_MESSAGE_LENGTH +
                      sizeof( LPCP_MESSAGE ) +
                      sizeof( LPCP_CONNECTION_MESSAGE );

    //
    //  Round up the size to the next 16 byte alignment
    //

    ZoneElementSize = (ZoneElementSize + LPCP_ZONE_ALIGNMENT - 1) &
                      LPCP_ZONE_ALIGNMENT_MASK;

    //
    //  Initialize the zone
    //

    LpcpInitializePortZone( ZoneElementSize );

    return( TRUE );
}

#if ENABLE_LPC_TRACING

char *
LpcpGetCreatorName (
    PLPCP_PORT_OBJECT PortObject
    )

/*++

Routine Description:

    This routine returns the name of the process that created the specified
    port object

Arguments:

    PortObject - Supplies the port object being queried

Return Value:

    char * - The image name of the process that created the port process

--*/

{
    NTSTATUS Status;
    PEPROCESS Process;

    //
    //  First find the process that created the port object
    //

    Status = PsLookupProcessByProcessId( PortObject->Creator.UniqueProcess, &Process );

    //
    //  If we were able to get the process then return the name of the process
    //  to our caller
    //

    if (NT_SUCCESS( Status )) {

        return (char *)Process->ImageFileName;

    } else {

        //
        //  Otherwise tell our caller we don't know the name
        //

        return "Unknown";
    }
}
#endif // ENABLE_LPC_TRACING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpcquery.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpcquery.c

Abstract:

    Local Inter-Process Communication (LPC) query services

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#include "lpcp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtQueryInformationPort)
#endif


NTSTATUS
NTAPI
NtQueryInformationPort (
    IN HANDLE PortHandle OPTIONAL,
    IN PORT_INFORMATION_CLASS PortInformationClass,
    OUT PVOID PortInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This routine should be used to query an lpc port, but is pretty much a
    noop.  Currently it can only indicate if the input handle is for a port
    object.

Arguments:

    PortHandle - Supplies the handle for the port being queried

    PortInformationClass - Specifies the type information class being asked
        for.  Currently ignored.

    PortInformation - Supplies a pointer to the buffer to receive the
        information.  Currently just probed and then ignored.

    Length - Specifies, in bytes, the size of the port information buffer.

    ReturnLength  - Optionally receives the size, in bytes, of the information
        being returned.  Currently just probed and then ignored.

Return Value:

    NTSTATUS - An appropriate status value.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PLPCP_PORT_OBJECT PortObject;

    PAGED_CODE();

    UNREFERENCED_PARAMETER ( PortInformationClass );

    //
    //  Get previous processor mode and probe output argument if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWrite( PortInformation,
                           Length,
                           sizeof( ULONG ));

            if (ARGUMENT_PRESENT( ReturnLength )) {

                ProbeForWriteUlong( ReturnLength );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }
    }

    //
    //  If the user gave us a handle then reference the object.  And return
    //  success if we got a good reference and an error otherwise.
    //

    if (ARGUMENT_PRESENT( PortHandle )) {

        Status = ObReferenceObjectByHandle( PortHandle,
                                            GENERIC_READ,
                                            LpcPortObjectType,
                                            PreviousMode,
                                            &PortObject,
                                            NULL );

        if (!NT_SUCCESS( Status )) {

            //
            //  It might be a waitable port object. 
            //  Let's try again as this object type
            //

            Status = ObReferenceObjectByHandle( PortHandle,
                                                GENERIC_READ,
                                                LpcWaitablePortObjectType,
                                                PreviousMode,
                                                &PortObject,
                                                NULL );

            //
            //  If this one fails too we'll return that status
            //

            if (!NT_SUCCESS( Status )) {

                return( Status );
            }
        }

        ObDereferenceObject( PortObject );

        return STATUS_SUCCESS;

    } else {

        return STATUS_INVALID_INFO_CLASS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=lpc

TARGETNAME=lpc
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..;..\..\inc

SOURCES=..\lpcinit.c  \
        ..\lpccreat.c \
        ..\lpclistn.c \
        ..\lpcconn.c  \
        ..\lpccompl.c \
        ..\lpcsend.c  \
        ..\lpcrecv.c  \
        ..\lpcreply.c \
        ..\lpcquery.c \
        ..\lpcqueue.c \
        ..\lpcclose.c \
        ..\lpcpriv.c

PRECOMPILED_INCLUDE=..\lpcp.h
PRECOMPILED_PCH=lpcp.pch
PRECOMPILED_OBJ=lpcp.obj

UMTYPE=console
UMTEST=userver*uclient

NTTARGETFILES=

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpcreply.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpcreply.c

Abstract:

    Local Inter-Process Communication (LPC) reply system services.

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#include "lpcp.h"

NTSTATUS
LpcpCopyRequestData (
    IN BOOLEAN WriteToMessageData,
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    IN PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesCopied OPTIONAL
    );

#if 0
VOID
LpcpAuditInvalidUse (
    IN PVOID Context
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtReplyPort)
#pragma alloc_text(PAGE,NtReplyWaitReplyPort)
#pragma alloc_text(PAGE,NtReadRequestData)
#pragma alloc_text(PAGE,NtWriteRequestData)
#pragma alloc_text(PAGE,LpcpCopyRequestData)
#pragma alloc_text(PAGE,LpcpValidateClientPort)
#if 0
#pragma alloc_text(PAGE,LpcpAuditInvalidUse)
#endif

ULONG LpcMaxEventLogs = 10;

#define LPCP_PORT_NAME_MAX      256

typedef struct _LPC_WORK_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    PVOID Buffer;
} LPC_WORK_CONTEXT, *PLPC_WORK_CONTEXT;

#endif

//
//  The current number of events registered
//

ULONG LpcpEventCounts = 0;


NTSTATUS
NtReplyPort (
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    A client and server process can send a reply to a previous request
    message with the NtReplyPort service:

    The Type field of the message is set to LPC_REPLY by the service.  If the
    MapInfoOffset field of the reply message is non-zero, then the
    PORT_MAP_INFORMATION structure it points to will be processed and the
    relevant pages in the caller's address space will be unmapped.

    The ClientId and MessageId fields of the ReplyMessage structure are used
    to identify the thread waiting for this reply.  If the target thread is
    in fact waiting for this reply message, then the reply message is copied
    into the thread's message buffer and the thread's wait is satisfied.

    If the thread is not waiting for a reply or is waiting for a reply to
    some other MessageId, then the message is placed in the message queue of
    the port that is connected to the communication port specified by the
    PortHandle parameter and the Type field of the message is set to
    LPC_LOST_REPLY.

Arguments:

    PortHandle - Specifies the handle of the communication port that the
        original message was received from.

    ReplyMessage - Specifies a pointer to the reply message to be sent.
        The ClientId and MessageId fields determine which thread will
        get the reply.

Return Value:

    Status code that indicates whether or not the operation was
    successful.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    PLPCP_PORT_OBJECT PortObject;
    PORT_MESSAGE CapturedReplyMessage;
    NTSTATUS Status;
    PLPCP_MESSAGE Msg;
    PETHREAD CurrentThread;
    PETHREAD WakeupThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread();

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForReadSmallStructure( ReplyMessage,
                                        sizeof( *ReplyMessage ),
                                        sizeof( ULONG ));

            CapturedReplyMessage = *ReplyMessage;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

    } else {

        CapturedReplyMessage = *ReplyMessage;
    }

    //
    //  Make sure DataLength is valid with respect to header size and total
    //  length
    //

    if ((((CLONG)CapturedReplyMessage.u1.s1.DataLength) + sizeof( PORT_MESSAGE )) >
        ((CLONG)CapturedReplyMessage.u1.s1.TotalLength)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make sure the user didn't give us a bogus reply message id
    //

    if (CapturedReplyMessage.MessageId == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the port object by handle
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        Status = ObReferenceObjectByHandle( PortHandle,
                                            0,
                                            LpcWaitablePortObjectType,
                                            PreviousMode,
                                            &PortObject,
                                            NULL );

        if ( !NT_SUCCESS( Status ) ) {

            return Status;
        }
    }

    //
    //  Validate the message length
    //

    if (((ULONG)CapturedReplyMessage.u1.s1.TotalLength > PortObject->MaxMessageLength) ||
        ((ULONG)CapturedReplyMessage.u1.s1.TotalLength <= (ULONG)CapturedReplyMessage.u1.s1.DataLength)) {

        ObDereferenceObject( PortObject );

        return STATUS_PORT_MESSAGE_TOO_LONG;
    }

    //
    //  Translate the ClientId from the connection request into a thread
    //  pointer.  This is a referenced pointer to keep the thread from
    //  evaporating out from under us.
    //

    Status = PsLookupProcessThreadByCid( &CapturedReplyMessage.ClientId,
                                         NULL,
                                         &WakeupThread );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( PortObject );

        return Status;
    }

    //
    //  Acquire the mutex that guards the LpcReplyMessage field of the thread
    //  and get the pointer to the message that the thread is waiting for a
    //  reply to.
    //


    Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( CapturedReplyMessage.u1.s1.TotalLength );

    if (Msg == NULL) {


        ObDereferenceObject( WakeupThread );
        ObDereferenceObject( PortObject );

        return STATUS_NO_MEMORY;
    }
    LpcpAcquireLpcpLockByThread(CurrentThread);

    //
    //  See if the thread is waiting for a reply to the message specified on
    //  this call.  If not then a bogus message has been specified, so
    //  release the mutex, dereference the thread and return failure.
    //
    //  We also fail this request if the caller isn't replying to a request
    //  message.  For example, if the caller is replying to a connection
    //  request
    //
    
    if ((WakeupThread->LpcReplyMessageId != CapturedReplyMessage.MessageId)

            ||

        ((LpcpGetThreadMessage(WakeupThread) != NULL) &&
         (LpcpGetThreadMessage(WakeupThread)->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_REQUEST)
            
            ||

        (!LpcpValidateClientPort(WakeupThread, PortObject, LPCP_VALIDATE_REASON_REPLY)) ) {

        LpcpPrint(( "%s Attempted reply to Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    WakeupThread,
                    THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

        LpcpPrint(( "failed.  MessageId == %u  Client Id: %x.%x\n",
                    CapturedReplyMessage.MessageId,
                    CapturedReplyMessage.ClientId.UniqueProcess,
                    CapturedReplyMessage.ClientId.UniqueThread ));

        LpcpPrint(( "         Thread MessageId == %u  Client Id: %x.%x\n",
                    WakeupThread->LpcReplyMessageId,
                    WakeupThread->Cid.UniqueProcess,
                    WakeupThread->Cid.UniqueThread ));

#if DBG
        if (LpcpStopOnReplyMismatch) {

            DbgBreakPoint();
        }
#endif

        LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

        ObDereferenceObject( WakeupThread );
        ObDereferenceObject( PortObject );

        return STATUS_REPLY_MESSAGE_MISMATCH;
    }

    //
    //  Copy the reply message to the request message buffer.  Do this before
    //  we actually fiddle with the wakeup threads fields.  Otherwise we
    //  could mess up its state
    //

    try {

        LpcpMoveMessage( &Msg->Request,
                         &CapturedReplyMessage,
                         (ReplyMessage + 1),
                         LPC_REPLY,
                         NULL );

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

        ObDereferenceObject( WakeupThread );
        ObDereferenceObject( PortObject );

        return GetExceptionCode();
    }

    //
    //  At this point we know the thread is waiting for our reply
    //

    LpcpTrace(( "%s Sending Reply Msg %lx (%u, %x) [%08x %08x %08x %08x] to Thread %lx (%s)\n",
                PsGetCurrentProcess()->ImageFileName,
                Msg,
                CapturedReplyMessage.MessageId,
                CapturedReplyMessage.u2.s2.DataInfoOffset,
                *((PULONG)(Msg+1)+0),
                *((PULONG)(Msg+1)+1),
                *((PULONG)(Msg+1)+2),
                *((PULONG)(Msg+1)+3),
                WakeupThread,
                THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

    //
    //  Locate and free the message from the port.  This call use to
    //  test for (CapturedReplyMessage.u2.s2.DataInfoOffset != 0) as a
    //  prerequisite for doing the call.
    //

    LpcpFreeDataInfoMessage( PortObject,
                             CapturedReplyMessage.MessageId,
                             CapturedReplyMessage.CallbackId );

    //
    //  Add an extra reference so LpcExitThread does not evaporate the
    //  pointer before we get to the wait below
    //

    ObReferenceObject( WakeupThread );

    //
    //  Release the mutex that guards the LpcReplyMessage field after marking
    //  message as being replied to.
    //

    Msg->RepliedToThread = WakeupThread;

    WakeupThread->LpcReplyMessageId = 0;
    WakeupThread->LpcReplyMessage = (PVOID)Msg;

    //
    //  Remove the thread from the reply rundown list as we are sending the
    //  reply.
    //

    if (!WakeupThread->LpcExitThreadCalled && !IsListEmpty( &WakeupThread->LpcReplyChain )) {

        RemoveEntryList( &WakeupThread->LpcReplyChain );

        InitializeListHead( &WakeupThread->LpcReplyChain );
    }

    if ((CurrentThread->LpcReceivedMsgIdValid) &&
        (CurrentThread->LpcReceivedMessageId == CapturedReplyMessage.MessageId)) {

        CurrentThread->LpcReceivedMessageId = 0;
        CurrentThread->LpcReceivedMsgIdValid = FALSE;
    }

    LpcpReleaseLpcpLock();

    //
    //  Wake up the thread that is waiting for an answer to its request
    //  inside of NtRequestWaitReplyPort or NtReplyWaitReplyPort.  That
    //  will dereference itself when it wakes up.
    //

    KeReleaseSemaphore( &WakeupThread->LpcReplySemaphore,
                        0,
                        1L,
                        FALSE );

    ObDereferenceObject( WakeupThread );

    //
    //  Dereference port object and return the system service status.
    //

    ObDereferenceObject( PortObject );

    return Status;
}


NTSTATUS
NtReplyWaitReplyPort (
    IN HANDLE PortHandle,
    IN OUT PPORT_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    A client and server process can send a reply to a previous message and
    block waiting for a reply using the NtReplyWaitReplyPort service:

    This service works the same as NtReplyPort, except that after delivering
    the reply message, it blocks waiting for a reply to a previous message.
    When the reply is received, it will be placed in the location specified
    by the ReplyMessage parameter.

Arguments:

    PortHandle - Specifies the handle of the communication port that the
        original message was received from.

    ReplyMessage - Specifies a pointer to the reply message to be sent.
        The ClientId and MessageId fields determine which thread will
        get the reply.  This buffer also receives any reply that comes
        back from the wait.

Return Value:

    Status code that indicates whether or not the operation was
    successful.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PLPCP_PORT_OBJECT PortObject;
    PORT_MESSAGE CapturedReplyMessage;
    PLPCP_MESSAGE Msg;
    PETHREAD CurrentThread;
    PETHREAD WakeupThread;
    PLPCP_PORT_OBJECT RundownPort;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread();

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteSmallStructure( ReplyMessage,
                                         sizeof( *ReplyMessage ),
                                         sizeof( ULONG ));

            CapturedReplyMessage = *ReplyMessage;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

    } else {

        CapturedReplyMessage = *ReplyMessage;
    }

    //
    //  Make sure DataLength is valid with respect to header size and total length
    //

    if ((((CLONG)CapturedReplyMessage.u1.s1.DataLength) + sizeof( PORT_MESSAGE )) >
        ((CLONG)CapturedReplyMessage.u1.s1.TotalLength)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make sure the user didn't give us a bogus reply message id
    //

    if (CapturedReplyMessage.MessageId == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the communication port object by handle.  Return status if
    //  unsuccessful.
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Validate the message length
    //

    if (((ULONG)CapturedReplyMessage.u1.s1.TotalLength > PortObject->MaxMessageLength) ||
        ((ULONG)CapturedReplyMessage.u1.s1.TotalLength <= (ULONG)CapturedReplyMessage.u1.s1.DataLength)) {

        ObDereferenceObject( PortObject );

        return STATUS_PORT_MESSAGE_TOO_LONG;
    }

    //
    //  Translate the ClientId from the connection request into a
    //  thread pointer.  This is a referenced pointer to keep the thread
    //  from evaporating out from under us.
    //

    Status = PsLookupProcessThreadByCid( &CapturedReplyMessage.ClientId,
                                         NULL,
                                         &WakeupThread );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( PortObject );

        return Status;
    }

    //
    //  Acquire the mutex that guards the LpcReplyMessage field of
    //  the thread and get the pointer to the message that the thread
    //  is waiting for a reply to.
    //


    Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( CapturedReplyMessage.u1.s1.TotalLength );

    if (Msg == NULL) {

        ObDereferenceObject( WakeupThread );
        ObDereferenceObject( PortObject );

        return STATUS_NO_MEMORY;
    }
    LpcpAcquireLpcpLockByThread(CurrentThread);

    //
    //  See if the thread is waiting for a reply to the message
    //  specified on this call.  If not then a bogus message
    //  has been specified, so release the mutex, dereference the thread
    //  and return failure.
    //
    //  We also fail this request if the caller isn't replying to a request
    //  message.  For example, if the caller is replying to a connection
    //  request
    //

    if ((WakeupThread->LpcReplyMessageId != CapturedReplyMessage.MessageId)

            ||

        ((LpcpGetThreadMessage(WakeupThread) != NULL) &&
         (LpcpGetThreadMessage(WakeupThread)->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_REQUEST)

            ||

        (!LpcpValidateClientPort(WakeupThread, PortObject, LPCP_VALIDATE_REASON_REPLY)) ) {

        LpcpPrint(( "%s Attempted reply wait reply to Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    WakeupThread,
                    THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

        LpcpPrint(( "failed.  MessageId == %u  Client Id: %x.%x\n",
                    CapturedReplyMessage.MessageId,
                    CapturedReplyMessage.ClientId.UniqueProcess,
                    CapturedReplyMessage.ClientId.UniqueThread ));

        LpcpPrint(( "         Thread MessageId == %u  Client Id: %x.%x\n",
                    WakeupThread->LpcReplyMessageId,
                    WakeupThread->Cid.UniqueProcess,
                    WakeupThread->Cid.UniqueThread ));

#if DBG
        if (LpcpStopOnReplyMismatch) {

            DbgBreakPoint();
        }
#endif

        LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

        ObDereferenceObject( WakeupThread );
        ObDereferenceObject( PortObject );

        return STATUS_REPLY_MESSAGE_MISMATCH;
    }

    //
    //  Copy the reply message to the request message buffer.  Do this before
    //  we actually fiddle with the wakeup threads fields.  Otherwise we
    //  could mess up its state
    //

    try {

        LpcpMoveMessage( &Msg->Request,
                         &CapturedReplyMessage,
                         (ReplyMessage + 1),
                         LPC_REPLY,
                         NULL );

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

        ObDereferenceObject( WakeupThread );
        ObDereferenceObject( PortObject );

        return (Status = GetExceptionCode());
    }

    //
    //  At this point we know the thread is waiting for our reply
    //

    LpcpTrace(( "%s Sending Reply Wait Reply Msg %lx (%u, %x) [%08x %08x %08x %08x] to Thread %lx (%s)\n",
                PsGetCurrentProcess()->ImageFileName,
                Msg,
                CapturedReplyMessage.MessageId,
                CapturedReplyMessage.u2.s2.DataInfoOffset,
                *((PULONG)(Msg+1)+0),
                *((PULONG)(Msg+1)+1),
                *((PULONG)(Msg+1)+2),
                *((PULONG)(Msg+1)+3),
                WakeupThread,
                THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

    //
    //  Locate and free the message from the port.  This call use to
    //  test for (CapturedReplyMessage.u2.s2.DataInfoOffset != 0) as a
    //  prerequisite for doing the call.
    //

    LpcpFreeDataInfoMessage( PortObject,
                             CapturedReplyMessage.MessageId,
                             CapturedReplyMessage.CallbackId );

    //
    //  Add an extra reference so LpcExitThread does not evaporate
    //  the pointer before we get to the wait below
    //

    ObReferenceObject( WakeupThread );

    //
    //  Release the mutex that guards the LpcReplyMessage field
    //  after marking message as being replied to.
    //

    Msg->RepliedToThread = WakeupThread;

    WakeupThread->LpcReplyMessageId = 0;
    WakeupThread->LpcReplyMessage = (PVOID)Msg;

    //
    //  Remove the thread from the reply rundown list as we are sending the reply.
    //

    if (!WakeupThread->LpcExitThreadCalled && !IsListEmpty( &WakeupThread->LpcReplyChain )) {

        RemoveEntryList( &WakeupThread->LpcReplyChain );

        InitializeListHead( &WakeupThread->LpcReplyChain );
    }

    //
    //  Set ourselves up to get the following reply
    //

    CurrentThread->LpcReplyMessageId = CapturedReplyMessage.MessageId;
    CurrentThread->LpcReplyMessage = NULL;
    
    if ((CurrentThread->LpcReceivedMsgIdValid) &&
        (CurrentThread->LpcReceivedMessageId == CapturedReplyMessage.MessageId)) {

        CurrentThread->LpcReceivedMessageId = 0;
        CurrentThread->LpcReceivedMsgIdValid = FALSE;
    }

    //
    //  Insert the current thread into the rundown queue
    //

    if ((PortObject->Flags & PORT_TYPE) != SERVER_CONNECTION_PORT) {

        RundownPort = PortObject->ConnectedPort;
    
    } else {
        
        RundownPort = PortObject;
    }
    
    InsertTailList( &RundownPort->LpcReplyChainHead, &CurrentThread->LpcReplyChain );
    
    //
    //  Save the port context in the current thread, because
    //  it waits a reply from the same message
    //
    
    LpcpSetPortToThread(CurrentThread, PortObject);

    LpcpReleaseLpcpLock();

    //
    //  Wake up the thread that is waiting for an answer to its request
    //  inside of NtRequestWaitReplyPort or NtReplyWaitReplyPort.  That
    //  will dereference itself when it wakes up.
    //

    KeReleaseSemaphore( &WakeupThread->LpcReplySemaphore,
                        1,
                        1,
                        FALSE );

    ObDereferenceObject( WakeupThread );

    //
    //  And wait for a reply
    //

    Status = KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                    Executive,
                                    PreviousMode,
                                    FALSE,
                                    NULL );

    if (Status == STATUS_USER_APC) {

        //
        //  if the semaphore is signaled, then clear it
        //

        if (KeReadStateSemaphore( &CurrentThread->LpcReplySemaphore )) {

            KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                   WrExecutive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            Status = STATUS_SUCCESS;
        }
    }

    //
    //  Remove the thread from the reply rundown list in case we did not wakeup due to
    //  a reply
    //
    
    LpcpAcquireLpcpLockByThread(CurrentThread);

    if (!IsListEmpty( &CurrentThread->LpcReplyChain )) {

        RemoveEntryList( &CurrentThread->LpcReplyChain );

        InitializeListHead( &CurrentThread->LpcReplyChain );
    }
    
    //
    //  If the wait succeeded, copy the reply to the reply buffer.
    //

    if (Status == STATUS_SUCCESS) {

        //
        //  Acquire the mutex that guards the request message queue.  Remove
        //  the request message from the list of messages being processed and
        //  free the message back to the queue's zone.  If the zone's free
        //  list was zero before freeing this message then pulse the free
        //  event after free the message so that threads waiting to allocate
        //  a request message buffer will wake up.  Finally, release the mutex
        //  and return the system service status.
        //

        Msg = LpcpGetThreadMessage(CurrentThread);
        CurrentThread->LpcReplyMessage = NULL;

#if DBG
        if (Msg != NULL) {

            LpcpTrace(( "%s Got Reply Msg %lx (%u) [%08x %08x %08x %08x] for Thread %lx (%s)\n",
                        PsGetCurrentProcess()->ImageFileName,
                        Msg,
                        Msg->Request.MessageId,
                        *((PULONG)(Msg+1)+0),
                        *((PULONG)(Msg+1)+1),
                        *((PULONG)(Msg+1)+2),
                        *((PULONG)(Msg+1)+3),
                        CurrentThread,
                        THREAD_TO_PROCESS( CurrentThread )->ImageFileName ));

            if (!IsListEmpty( &Msg->Entry )) {

                LpcpTrace(( "Reply Msg %lx has non-empty list entry\n", Msg ));
            }
        }
#endif

        LpcpReleaseLpcpLock();

        if (Msg != NULL) {

            try {

                LpcpMoveMessage( ReplyMessage,
                                 &Msg->Request,
                                 (&Msg->Request) + 1,
                                 0,
                                 NULL );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                Status = GetExceptionCode();
            }

            //
            //  Acquire the LPC mutex and decrement the reference count for the
            //  message.  If the reference count goes to zero the message will be
            //  deleted.
            //

            LpcpAcquireLpcpLockByThread(CurrentThread);

            if (Msg->RepliedToThread != NULL) {

                ObDereferenceObject( Msg->RepliedToThread );

                Msg->RepliedToThread = NULL;
            }

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

        } else {

            Status = STATUS_LPC_REPLY_LOST;
        }
    }
    else {
        LpcpReleaseLpcpLock();
    }

    ObDereferenceObject( PortObject );

    return Status;
}


NTSTATUS
NtReadRequestData (
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    OUT PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesRead OPTIONAL
    )

/*++

Routine Description:

    This routine is used to copy data from a port message into the user
    supplied buffer.

Arguments:

    PortHandle - Supplies the port from which the message is being read

    Message - Supplies the message that we are trying to read

    DataEntryIndex - Supplies the index of the port data entry in the
        preceeding message that we are reading

    Buffer - Supplies the location into which the data is to be read

    BufferSize - Supplies the size, in bytes, of the preceeding buffer

    NumberOfBytesRead - Optionally returns the number of bytes read into
        the buffer

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS status;

    PAGED_CODE();


    status = LpcpCopyRequestData( FALSE,
                                PortHandle,
                                Message,
                                DataEntryIndex,
                                Buffer,
                                BufferSize,
                                NumberOfBytesRead );
    
    return status;
}


NTSTATUS
NtWriteRequestData (
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    IN PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesWritten OPTIONAL
    )

/*++

Routine Description:

    This routine is used to copy data from the user supplied buffer into the
    port message

Arguments:

    PortHandle - Supplies the port into which the message is being written

    Message - Supplies the message that we are trying to write

    DataEntryIndex - Supplies the index of the port data entry in the
        preceeding message that we are writing

    Buffer - Supplies the location into which the data is to be written

    BufferSize - Supplies the size, in bytes, of the preceeding buffer

    NumberOfBytesWritten - Optionally returns the number of bytes written from
        the buffer

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    status = LpcpCopyRequestData( TRUE,
                                PortHandle,
                                Message,
                                DataEntryIndex,
                                Buffer,
                                BufferSize,
                                NumberOfBytesWritten );

    return status;
}


//
//  Local support routine
//

NTSTATUS
LpcpCopyRequestData (
    IN BOOLEAN WriteToMessageData,
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    IN PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesCopied OPTIONAL
    )

/*++

Routine Description:

    This routine will copy data to or from the user supplied buffer and the
    port message data information buffer

Arguments:

    WriteToMessageData - TRUE if the data is to be copied from the user buffer
        to the message and FALSE otherwise

    PortHandle - Supplies the port into which the message is being manipulated

    Message - Supplies the message that we are trying to manipulate

    DataEntryIndex - Supplies the index of the port data entry in the
        preceeding message that we are transferring

    Buffer - Supplies the location into which the data is to be transfered

    BufferSize - Supplies the size, in bytes, of the preceeding buffer

    NumberOfBytesRead - Optionally returns the number of bytes transfered from
        the buffer

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    KPROCESSOR_MODE PreviousMode;
    PLPCP_PORT_OBJECT PortObject;
    PLPCP_MESSAGE Msg;
    NTSTATUS Status;
    PETHREAD ClientThread;
    PPORT_DATA_INFORMATION DataInfo;
    PPORT_DATA_ENTRY DataEntry;
    PORT_MESSAGE CapturedMessage;
    PORT_DATA_ENTRY CapturedDataEntry;
    SIZE_T BytesCopied;

    PAGED_CODE();

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            //
            //  We are either reading or writing the user buffer
            //

            if (WriteToMessageData) {

                ProbeForRead( Buffer,
                              BufferSize,
                              1 );

            } else {

                ProbeForWrite( Buffer,
                               BufferSize,
                               1 );
            }

            ProbeForReadSmallStructure( Message,
                                        sizeof( *Message ),
                                        sizeof( ULONG ));

            CapturedMessage = *Message;

            if (ARGUMENT_PRESENT( NumberOfBytesCopied )) {

                ProbeForWriteUlong_ptr( NumberOfBytesCopied );
            } 

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

    } else {

        CapturedMessage = *Message;
    }

    //
    //  The message better have at least one data entry
    //

    if (CapturedMessage.u2.s2.DataInfoOffset == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the port object by handle
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Translate the ClientId from the connection request into a
    //  thread pointer.  This is a referenced pointer to keep the thread
    //  from evaporating out from under us.
    //

    Status = PsLookupProcessThreadByCid( &CapturedMessage.ClientId,
                                         NULL,
                                         &ClientThread );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( PortObject );

        return Status;
    }

    //
    //  Acquire the mutex that guards the LpcReplyMessage field of
    //  the thread and get the pointer to the message that the thread
    //  is waiting for a reply to.
    //

    LpcpAcquireLpcpLock();

    //
    //  See if the thread is waiting for a reply to the message
    //  specified on this call.  If not then a bogus message
    //  has been specified, so release the mutex, dereference the thread
    //  and return failure.
    //
    
    if ( (ClientThread->LpcReplyMessageId != CapturedMessage.MessageId) ||
         !LpcpValidateClientPort(ClientThread, PortObject, LPCP_VALIDATE_REASON_WRONG_DATA) ) {

        Status = STATUS_REPLY_MESSAGE_MISMATCH;

    } else {

        Status = STATUS_INVALID_PARAMETER;

        Msg = LpcpFindDataInfoMessage( PortObject,
                                       CapturedMessage.MessageId,
                                       CapturedMessage.CallbackId );

        if (Msg != NULL) {

            DataInfo = (PPORT_DATA_INFORMATION)((PUCHAR)&Msg->Request +
                                                Msg->Request.u2.s2.DataInfoOffset);

            //
            //  Make sure the caller isn't asking for an index beyond what's
            //  in the message
            //

            if (DataInfo->CountDataEntries > DataEntryIndex) {

                DataEntry = &DataInfo->DataEntries[ DataEntryIndex ];
                CapturedDataEntry = *DataEntry;

                if (CapturedDataEntry.Size >= BufferSize) {

                    Status = STATUS_SUCCESS;
                }
            }
        }
    }

    //
    //  Release the mutex that guards the LpcReplyMessage field
    //

    LpcpReleaseLpcpLock();

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( ClientThread );
        ObDereferenceObject( PortObject );

        return Status;
    }

    //
    //  Copy the message data
    //

    if (WriteToMessageData) {

        Status = MmCopyVirtualMemory( PsGetCurrentProcess(),
                                      Buffer,
                                      THREAD_TO_PROCESS( ClientThread ),
                                      CapturedDataEntry.Base,
                                      BufferSize,
                                      PreviousMode,
                                      &BytesCopied );

    } else {

        Status = MmCopyVirtualMemory( THREAD_TO_PROCESS( ClientThread ),
                                      CapturedDataEntry.Base,
                                      PsGetCurrentProcess(),
                                      Buffer,
                                      BufferSize,
                                      PreviousMode,
                                      &BytesCopied );
    }

    if (ARGUMENT_PRESENT( NumberOfBytesCopied )) {

        try {

            *NumberOfBytesCopied = BytesCopied;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            NOTHING;
        }
    }

    //
    //  Dereference client thread and return the system service status.
    //

    ObDereferenceObject( ClientThread );
    ObDereferenceObject( PortObject );

    return Status;
}


BOOLEAN
FASTCALL
LpcpValidateClientPort(
    IN PETHREAD Thread, 
    IN PLPCP_PORT_OBJECT ReplyPort,
    IN ULONG Reason
    )

/*++

Routine Description:

    This routine validates whether the reply for a request come from
    an appropriate port
    
Arguments:

    Thread - The thread waiting for a reply
    
    ReplyPort - The port object that is replying 

Return Value:

    BOOLEAN - TRUE if the reply come from a valid port

Environment:

    This is called holding the global LPC mutex.

--*/

{
    PLPCP_PORT_OBJECT PortThread;

    PortThread = LpcpGetThreadPort(Thread);

    //
    //  The thread must have a port set
    //

    if (PortThread == NULL) {

        return FALSE;
    }
    
    //
    //  We only allow a port connected with the requestor.
    //  Also csrss is giving the server connection port to clients
    //  and we can have a client sending a request from a server connection port
    //  and csrss can reply with a server communication port
    //

    if ( ( ReplyPort == PortThread->ConnectionPort ) 
            ||                      
         ( ReplyPort == PortThread->ConnectedPort ) 
            ||
         ( ReplyPort == PortThread ) 
            ||
         ( 
            ((ReplyPort->Flags & PORT_TYPE) == SERVER_COMMUNICATION_PORT) 
                &&
            (ReplyPort->ConnectionPort == PortThread)
         )
       ) {
        
        return TRUE;
    }
    
#if 0
    if (LpcpEventCounts < LpcMaxEventLogs) {

        PUNICODE_STRING StrReason;
        POBJECT_NAME_INFORMATION ObjectNameInfo;
        NTSTATUS Status;
        ULONG Length;
        PLPC_WORK_CONTEXT AuditItem;

        if (PortThread->ConnectionPort) {

            ObjectNameInfo = ExAllocatePoolWithTag(PagedPool, LPCP_PORT_NAME_MAX + sizeof (UNICODE_STRING), 'ScpL');
            if (ObjectNameInfo != NULL) {

                Status = ObQueryNameString( PortThread->ConnectionPort, 
                                            ObjectNameInfo,
                                            LPCP_PORT_NAME_MAX,
                                            &Length
                                          );
                if (NT_SUCCESS(Status)) {

                    //
                    //  Audit the event.  Use a worker thread to avoid burning
                    //  up a bunch of cycles since the global mutex is held.
                    //

                    StrReason = (PUNICODE_STRING)((ULONG_PTR) ObjectNameInfo + LPCP_PORT_NAME_MAX);
                    switch (Reason) {
                    case LPCP_VALIDATE_REASON_IMPERSONATION:
                        RtlInitUnicodeString( StrReason, L"impersonation" );
                        break;

                    case LPCP_VALIDATE_REASON_REPLY:
                        RtlInitUnicodeString( StrReason, L"reply" );
                        break;

                    case LPCP_VALIDATE_REASON_WRONG_DATA:
                        RtlInitUnicodeString( StrReason, L"data access" );
                        break;
                    }

                    AuditItem = ExAllocatePoolWithTag (NonPagedPool,
                                                       sizeof(LPC_WORK_CONTEXT),
                                                       'wcpL');

                    if (AuditItem != NULL) {
                        AuditItem->Buffer = (PVOID) ObjectNameInfo;
                        ExInitializeWorkItem (&AuditItem->WorkItem,
                                              LpcpAuditInvalidUse,
                                              (PVOID) AuditItem);

                        ExQueueWorkItem (&AuditItem->WorkItem, DelayedWorkQueue);
                        LpcpEventCounts += 1;
                    }
                    else {
                        ExFreePool (ObjectNameInfo);
                    }
                }
                else {
                    ExFreePool (ObjectNameInfo);
                }
            }
        }

#if DBG
        if (LpcpStopOnReplyMismatch) {

            DbgBreakPoint();
        }
#endif

    }
#endif

    return FALSE;
}

#if 0

VOID
LpcpAuditInvalidUse (
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is the worker routine which logs security items.

Arguments:

    Context - Supplies a pointer to the LPC_WORK_CONTEXT for the audit event.

Return Value:

    None.

Environment:

    Kernel mode, PASSIVE_LEVEL.

--*/

{
    PUNICODE_STRING StrReason;
    POBJECT_NAME_INFORMATION ObjectNameInfo;
    PLPC_WORK_CONTEXT AuditItem;

    PAGED_CODE();

    AuditItem = (PLPC_WORK_CONTEXT) Context;

    ObjectNameInfo = (POBJECT_NAME_INFORMATION) AuditItem->Buffer;

    StrReason = (PUNICODE_STRING)((ULONG_PTR) ObjectNameInfo + LPCP_PORT_NAME_MAX);

    SeAuditLPCInvalidUse (StrReason, &ObjectNameInfo->Name);

    ExFreePool (ObjectNameInfo);

    ExFreePool (AuditItem);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpcsend.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpcsend.c

Abstract:

    Local Inter-Process Communication (LPC) request system services.

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#include "lpcp.h"

NTSTATUS
LpcpRequestWaitReplyPort (
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage,
    IN KPROCESSOR_MODE AccessMode
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtRequestPort)
#pragma alloc_text(PAGE,NtRequestWaitReplyPort)
#pragma alloc_text(PAGE,LpcRequestPort)
#pragma alloc_text(PAGE,LpcRequestWaitReplyPort)
#pragma alloc_text(PAGE,LpcpRequestWaitReplyPort)
#pragma alloc_text(PAGE,LpcRequestWaitReplyPortEx)
#endif


NTSTATUS
NtRequestPort (
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage
    )

/*++

Routine Description:

    A client and server process send datagram messages using this procedure.

    The message pointed to by the RequestMessage parameter is placed in the
    message queue of the port connected to the communication port specified
    by the PortHandle parameter.  This service returns an error if PortHandle
    is invalid or if the MessageId field of the PortMessage structure is
    non-zero.

Arguments:

    PortHandle - Specifies the handle of the communication port to send
        the request message to.

    RequestMessage - Specifies a pointer to the request message.  The Type
        field of the message is set to LPC_DATAGRAM by the service.

Return Value:

    NTSTATUS - A status code that indicates whether or not the operation was
        successful.

--*/

{
    PETHREAD CurrentThread;
    PLPCP_PORT_OBJECT PortObject;
    PLPCP_PORT_OBJECT QueuePort;
    PORT_MESSAGE CapturedRequestMessage;
    ULONG MsgType;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PLPCP_MESSAGE Msg;
    PLPCP_PORT_OBJECT ConnectionPort = NULL;

    PAGED_CODE();

    //
    //  Get previous processor mode and validate parameters
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForReadSmallStructure( RequestMessage,
                                        sizeof( *RequestMessage ),
                                        PROBE_ALIGNMENT (PORT_MESSAGE));

            CapturedRequestMessage = *RequestMessage;
            CapturedRequestMessage.u2.s2.Type &= ~LPC_KERNELMODE_MESSAGE;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

        if (CapturedRequestMessage.u2.s2.Type != 0) {

            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        //  This is a kernel mode caller
        //

        CapturedRequestMessage = *RequestMessage;

        if ((CapturedRequestMessage.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != 0) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Make sure that the caller has given us some data to send
    //

    if (CapturedRequestMessage.u2.s2.DataInfoOffset != 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make sure DataLength is valid with respect to header size and total length
    //

    if ((((CLONG)CapturedRequestMessage.u1.s1.DataLength) + sizeof( PORT_MESSAGE )) >
        ((CLONG)CapturedRequestMessage.u1.s1.TotalLength)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the communication port object by handle.  Return status if
    //  unsuccessful.
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Validate the message length
    //

    if (((ULONG)CapturedRequestMessage.u1.s1.TotalLength > PortObject->MaxMessageLength) ||
        ((ULONG)CapturedRequestMessage.u1.s1.TotalLength <= (ULONG)CapturedRequestMessage.u1.s1.DataLength)) {

        ObDereferenceObject( PortObject );

        return STATUS_PORT_MESSAGE_TOO_LONG;
    }

    //
    //  Determine which port to queue the message to and get client
    //  port context if client sending to server.  Also validate
    //  length of message being sent.
    //

    //
    //  Allocate and initialize the LPC message to send off
    //

    Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( CapturedRequestMessage.u1.s1.TotalLength );

    if (Msg == NULL) {

        ObDereferenceObject( PortObject );

        return STATUS_NO_MEMORY;
    }

    Msg->RepliedToThread = NULL;
    Msg->PortContext = NULL;
    MsgType = CapturedRequestMessage.u2.s2.Type | LPC_DATAGRAM;

    CurrentThread = PsGetCurrentThread();

    if (PreviousMode != KernelMode) {

        try {

            LpcpMoveMessage( &Msg->Request,
                            &CapturedRequestMessage,
                            (RequestMessage + 1),
                            MsgType,
                            &CurrentThread->Cid );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();

            LpcpFreeToPortZone( Msg, 0 );

            ObDereferenceObject( PortObject );

            return Status;
        }

    }
    else {

        LpcpMoveMessage( &Msg->Request,
                         &CapturedRequestMessage,
                         (RequestMessage + 1),
                         MsgType,
                         &CurrentThread->Cid );
    }

    //
    //  Acquire the global Lpc mutex that guards the LpcReplyMessage
    //  field of the thread and the request message queue.  Stamp the
    //  request message with a serial number, insert the message at
    //  the tail of the request message queue and remember the address
    //  of the message in the LpcReplyMessage field for the current thread.
    //

    LpcpAcquireLpcpLockByThread(CurrentThread);

    //
    //  Based on what type of port the caller gave us we'll need to get
    //  the port to actually queue the message off to.
    //

    if ((PortObject->Flags & PORT_TYPE) != SERVER_CONNECTION_PORT) {

        //
        //  The caller didn't give us a connection port so find the
        //  connection port for this port.  If it is null then we'll
        //  fall through without sending a message
        //

        QueuePort = PortObject->ConnectedPort;

        //
        //  Check if the queue port is in process of going away
        //

        if ( QueuePort != NULL) {

            //
            //  If the port is a client communication port then give the
            //  message the proper port context
            //

            if ((PortObject->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

                Msg->PortContext = QueuePort->PortContext;
                ConnectionPort = QueuePort = PortObject->ConnectionPort;

                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );
                    
                    ObDereferenceObject( PortObject );

                    return STATUS_PORT_DISCONNECTED;
                }

            //
            //  In the case we don't have a CLIENT_COMMUNICATION_PORT nor 
            //  SERVER_COMMUNICATION_PORT we'll use the connection port
            //  to queue messages. 
            //    

            } else if ((PortObject->Flags & PORT_TYPE) != SERVER_COMMUNICATION_PORT) {

                ConnectionPort = QueuePort = PortObject->ConnectionPort;
                
                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );
                    
                    ObDereferenceObject( PortObject );
                    
                    return STATUS_PORT_DISCONNECTED;
                }
            }

            if (ConnectionPort) {

                ObReferenceObject( ConnectionPort );
            }
        }

    } else {

        //
        //  The caller supplied a server connection port so that is the port
        //  we queue off to
        //

        QueuePort = PortObject;
    }

    //
    //  At this point we have an LPC message ready to send and if queue port is
    //  not null then we have a port to actually send the message off to
    //

    if (QueuePort != NULL) {

        //
        //  Reference the QueuePort to prevent this port evaporating under us
        //  Test if the QueuePort isn't in the process of going away 
        //  (i.e. we need to have at least 2 references for this object when 
        //  ObReferenceObject returns). Note the LPC lock is still held.
        //

        if ( ObReferenceObjectSafe( QueuePort ) ) {

            //
            //  Finish filling in the message and then insert it in the queue
            //

            Msg->Request.MessageId = LpcpGenerateMessageId();
            Msg->Request.CallbackId = 0;
            Msg->SenderPort = PortObject;

            CurrentThread->LpcReplyMessageId = 0;

            InsertTailList( &QueuePort->MsgQueue.ReceiveHead, &Msg->Entry );

            LpcpTrace(( "%s Send DataGram (%s) Msg %lx [%08x %08x %08x %08x] to Port %lx (%s)\n",
                        PsGetCurrentProcess()->ImageFileName,
                        LpcpMessageTypeName[ Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE ],
                        Msg,
                        *((PULONG)(Msg+1)+0),
                        *((PULONG)(Msg+1)+1),
                        *((PULONG)(Msg+1)+2),
                        *((PULONG)(Msg+1)+3),
                        QueuePort,
                        LpcpGetCreatorName( QueuePort )));

            //
            //  Release the mutex, increment the request message queue
            //  semaphore by one for the newly inserted request message
            //  then exit the critical region.
            //
            //  Disable APCs to prevent this thread from being suspended
            //  before being able to release the semaphore.
            //

            KeEnterCriticalRegionThread(&CurrentThread->Tcb);

            LpcpReleaseLpcpLock();

            KeReleaseSemaphore( QueuePort->MsgQueue.Semaphore,
                                LPC_RELEASE_WAIT_INCREMENT,
                                1L,
                                FALSE );

            //
            //  If this is a waitable port then we'll need to set the event for
            //  anyone that was waiting on the port
            //

            if ( QueuePort->Flags & PORT_WAITABLE ) {

                KeSetEvent( &QueuePort->WaitEvent,
                            LPC_RELEASE_WAIT_INCREMENT,
                            FALSE );
            }

            //
            //  Exit the critical region and release the port object
            //

            KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

            if (ConnectionPort) {

                ObDereferenceObject( ConnectionPort );
            }
            
            ObDereferenceObject( QueuePort );
            ObDereferenceObject( PortObject );

            //
            //  And return to our caller.  This is the only successful way out
            //  of this routine
            //

            return Status;
        }
    }

    //
    //  At this point we have a message but not a valid port to queue it off
    //  to so we'll free up the port object and release the unused message.
    //

    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

    ObDereferenceObject( PortObject );
    
    if (ConnectionPort) {

        ObDereferenceObject( ConnectionPort );
    }

    //
    //  And return the error status to our caller
    //

    return STATUS_PORT_DISCONNECTED;
}


NTSTATUS
NtRequestWaitReplyPort (
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    A client and server process can send a request and wait for a reply using
    the NtRequestWaitReplyPort service.

    If the Type field of the RequestMessage structure is euqal to LPC_REQUEST,
    then this is identified as a callback request.  The ClientId and MessageId
    fields are used to identify the thread that is waiting for a reply.  This
    thread is unblocked and the current thread that called this service then
    blocks waiting for a reply.

    The Type field of the message is set to LPC_REQUEST by the service.
    Otherwise the Type field of the message must be zero and it will be set to
    LPC_REQUEST by the service.  The message pointed to by the RequestMessage
    parameter is placed in the message queue of the port connected to the
    communication port specified by the PortHandle parameter.  This service
    returns an error if PortHandle is invalid.  The calling thread then blocks
    waiting for a reply.

    The reply message is stored in the location pointed to by the ReplyMessage
    parameter.  The ClientId, MessageId and message type fields will be filled
    in by the service.

Arguments:

    PortHandle - Specifies the handle of the communication port to send the
        request message to.

    RequestMessage - Specifies a pointer to a request message to send.

    ReplyMessage - Specifies the address of a variable that will receive the
        reply message.  This parameter may point to the same buffer as the
        RequestMessage parameter.

Return Value:

    NTSTATUS - A status code that indicates whether or not the operation was
        successful.

--*/

{
    PLPCP_PORT_OBJECT PortObject;
    PLPCP_PORT_OBJECT QueuePort;
    PLPCP_PORT_OBJECT RundownPort;
    PORT_MESSAGE CapturedRequestMessage;
    ULONG MsgType;
    PKSEMAPHORE ReleaseSemaphore;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PLPCP_MESSAGE Msg;
    PETHREAD CurrentThread;
    PETHREAD WakeupThread;
    BOOLEAN CallbackRequest;
    PORT_DATA_INFORMATION CapturedDataInfo;
    PLPCP_PORT_OBJECT ConnectionPort = NULL;

    PAGED_CODE();

    //
    //  We cannot wait for a reply if the current thread is exiting
    //

    CurrentThread = PsGetCurrentThread();

    if (CurrentThread->LpcExitThreadCalled) {

        return STATUS_THREAD_IS_TERMINATING;
    }

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForReadSmallStructure( RequestMessage,
                                        sizeof( *RequestMessage ),
                                        PROBE_ALIGNMENT (PORT_MESSAGE));

            CapturedRequestMessage = *RequestMessage;
            CapturedRequestMessage.u2.s2.Type &= ~LPC_KERNELMODE_MESSAGE;

            ProbeForWriteSmallStructure( ReplyMessage,
                                         sizeof( *ReplyMessage ),
                                         PROBE_ALIGNMENT (PORT_MESSAGE));

            //
            //  Make sure that if this message has a data info offset that
            //  the port data information actually fits in the message.
            //
            //  We first check that the DataInfoOffset doesn't put us beyond
            //  the end of the message.
            //
            //  Then we capture the data info record and compute a pointer to
            //  the first unused data entry based on the supplied count.  If
            //  the start of the message plus its total length doesn't come
            //  up to the first unused data entry then the last valid data
            //  entry doesn't fit in the message buffer.  Also if the data
            //  entry pointer that we compute is less than the data info
            //  pointer then we must have wrapped.
            //

            if (CapturedRequestMessage.u2.s2.DataInfoOffset != 0) {

                PPORT_DATA_INFORMATION DataInfo;
                PPORT_DATA_ENTRY DataEntry;

                if (((ULONG)CapturedRequestMessage.u2.s2.DataInfoOffset) > (CapturedRequestMessage.u1.s1.TotalLength - sizeof(PORT_DATA_INFORMATION))) {

                    return STATUS_INVALID_PARAMETER;
                }

                if ((ULONG)CapturedRequestMessage.u2.s2.DataInfoOffset < sizeof(PORT_MESSAGE)) {

                    return STATUS_INVALID_PARAMETER;
                }

                DataInfo = (PPORT_DATA_INFORMATION)(((PUCHAR)RequestMessage) + CapturedRequestMessage.u2.s2.DataInfoOffset);

                ProbeForReadSmallStructure( DataInfo,
                                            sizeof( *DataInfo ),
                                            PROBE_ALIGNMENT (PORT_DATA_INFORMATION));

                CapturedDataInfo = *DataInfo;

                DataEntry = &(DataInfo->DataEntries[CapturedDataInfo.CountDataEntries]);


                //
                //  The computation of above address, could overflow. So we have to return STATUS_INVALID_PARAMETER if :
                //      CountDataEntries * sizeof(DataEntries) < CountDataEntries
                //
                //  But CountDataEntries * sizeof(DataEntries) = DataEntry - DataInfo - sizeof(CountDataEntries)
                //  and the final condition will be:
                //
                //      DataEntry - DataInfo - sizeof(CountDataEntries) < CountDataEntries
                //
                //  That is equivalent with:
                //      DataEntry < DataInfo + sizeof(CountDataEntries) + CountDataEntries
                //
                //  ( The condition (DataEntry < DataInfo) used in the previous versions
                //    is always verified by this one )
                //


                if (((PUCHAR)DataEntry < (PUCHAR)DataInfo + sizeof(CapturedDataInfo.CountDataEntries) + CapturedDataInfo.CountDataEntries) ||
                    ((((PUCHAR)RequestMessage) + CapturedRequestMessage.u1.s1.TotalLength) < (PUCHAR)DataEntry)) {

                    return STATUS_INVALID_PARAMETER;
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

    } else {

        CapturedRequestMessage = *RequestMessage;

        if (CapturedRequestMessage.u2.s2.DataInfoOffset != 0) {

            PPORT_DATA_INFORMATION DataInfo;

            DataInfo = (PPORT_DATA_INFORMATION)(((PUCHAR)RequestMessage) + CapturedRequestMessage.u2.s2.DataInfoOffset);

            CapturedDataInfo = *DataInfo;
        }
    }

    //
    //  If the message type is an lpc request then say we need a callback.
    //  Otherwise if it not an lpc request and it is not a kernel mode message
    //  then it is an illegal parameter.  A third case is if the type is
    //  a kernel mode message in which case we make it look like an lpc request
    //  but without the callback.
    //

    if ((CapturedRequestMessage.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_REQUEST) {

        CallbackRequest = TRUE;

    } else if ((CapturedRequestMessage.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != 0) {

        return STATUS_INVALID_PARAMETER;

    } else {

        CapturedRequestMessage.u2.s2.Type |= LPC_REQUEST;
        CallbackRequest = FALSE;
    }

    //
    //  Make sure DataLength is valid with respect to header size and total length
    //

    if ((((CLONG)CapturedRequestMessage.u1.s1.DataLength) + sizeof( PORT_MESSAGE )) >
        ((CLONG)CapturedRequestMessage.u1.s1.TotalLength)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the communication port object by handle.  Return status if
    //  unsuccessful.
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Validate the message length
    //

    if (((ULONG)CapturedRequestMessage.u1.s1.TotalLength > PortObject->MaxMessageLength) ||
        ((ULONG)CapturedRequestMessage.u1.s1.TotalLength <= (ULONG)CapturedRequestMessage.u1.s1.DataLength)) {

        ObDereferenceObject( PortObject );

        return STATUS_PORT_MESSAGE_TOO_LONG;
    }

    //
    //  Determine which port to queue the message to and get client
    //  port context if client sending to server.  Also validate
    //  length of message being sent.
    //

    //
    //  Allocate and initialize the LPC message to send off
    //


    Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( CapturedRequestMessage.u1.s1.TotalLength );

    if (Msg == NULL) {

        ObDereferenceObject( PortObject );

        return STATUS_NO_MEMORY;
    }

    MsgType = CapturedRequestMessage.u2.s2.Type;

    //
    //  Check if we need to do a callback
    //

    if (CallbackRequest) {

        //
        //  Check for a valid request message id
        //

        if (CapturedRequestMessage.MessageId == 0) {

            LpcpFreeToPortZone( Msg, 0 );

            ObDereferenceObject( PortObject );

            return STATUS_INVALID_PARAMETER;
        }

        //
        //  Translate the ClientId from the request into a
        //  thread pointer.  This is a referenced pointer to keep the thread
        //  from evaporating out from under us.
        //

        Status = PsLookupProcessThreadByCid( &CapturedRequestMessage.ClientId,
                                             NULL,
                                             &WakeupThread );

        if (!NT_SUCCESS( Status )) {

            LpcpFreeToPortZone( Msg, 0 );

            ObDereferenceObject( PortObject );

            return Status;
        }

        //
        //  Acquire the mutex that guards the LpcReplyMessage field of
        //  the thread and get the pointer to the message that the thread
        //  is waiting for a reply to.
        //

        LpcpAcquireLpcpLockByThread(CurrentThread);

        //
        //  See if the thread is waiting for a reply to the message
        //  specified on this call.  If not then a bogus message has been
        //  specified, so release the mutex, dereference the thread
        //  and return failure.
        //

        if ((WakeupThread->LpcReplyMessageId != CapturedRequestMessage.MessageId)

                ||

            ((LpcpGetThreadMessage(WakeupThread) != NULL) &&
             (LpcpGetThreadMessage(WakeupThread)->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_REQUEST)
                
                ||

            (!LpcpValidateClientPort(WakeupThread, PortObject, LPCP_VALIDATE_REASON_REPLY)) ) {

            LpcpPrint(( "%s Attempted CallBack Request to Thread %lx (%s)\n",
                        PsGetCurrentProcess()->ImageFileName,
                        WakeupThread,
                        THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

            LpcpPrint(( "failed.  MessageId == %u  Client Id: %x.%x\n",
                        CapturedRequestMessage.MessageId,
                        CapturedRequestMessage.ClientId.UniqueProcess,
                        CapturedRequestMessage.ClientId.UniqueThread ));

            LpcpPrint(( "         Thread MessageId == %u  Client Id: %x.%x\n",
                        WakeupThread->LpcReplyMessageId,
                        WakeupThread->Cid.UniqueProcess,
                        WakeupThread->Cid.UniqueThread ));

#if DBG
            if (LpcpStopOnReplyMismatch) {

                DbgBreakPoint();
            }
#endif

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

            ObDereferenceObject( WakeupThread );
            ObDereferenceObject( PortObject );

            return STATUS_REPLY_MESSAGE_MISMATCH;
        }

        //
        //  Copy over the text of the message
        //

        try {

            LpcpMoveMessage( &Msg->Request,
                             &CapturedRequestMessage,
                             (RequestMessage + 1),
                             MsgType,
                             &CurrentThread->Cid );

            if (CapturedRequestMessage.u2.s2.DataInfoOffset != 0) {

                PPORT_DATA_INFORMATION DataInfo;

                DataInfo = (PPORT_DATA_INFORMATION)(((PUCHAR)RequestMessage) + CapturedRequestMessage.u2.s2.DataInfoOffset);

                if ( DataInfo->CountDataEntries != CapturedDataInfo.CountDataEntries ) {

                    Status = STATUS_INVALID_PARAMETER;
                }
            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

        if (!NT_SUCCESS( Status )) {

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

            ObDereferenceObject( WakeupThread );
            ObDereferenceObject( PortObject );

            return Status;
        }

        //
        //  Under the protect of the global lock we'll get everything
        //  ready for the callback
        //

        QueuePort = NULL;
        Msg->PortContext = NULL;

        if ((PortObject->Flags & PORT_TYPE) == SERVER_CONNECTION_PORT) {

            RundownPort = PortObject;

        } else {

            RundownPort = PortObject->ConnectedPort;

            if (RundownPort == NULL) {

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                ObDereferenceObject( WakeupThread );
                ObDereferenceObject( PortObject );

                return STATUS_PORT_DISCONNECTED;
            }

            if ((PortObject->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

                Msg->PortContext = RundownPort->PortContext;
            }
        }

        Msg->Request.CallbackId = LpcpGenerateCallbackId();

        LpcpTrace(( "%s CallBack Request (%s) Msg %lx (%u.%u) [%08x %08x %08x %08x] to Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    LpcpMessageTypeName[ Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE ],
                    Msg,
                    Msg->Request.MessageId,
                    Msg->Request.CallbackId,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    WakeupThread,
                    THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

        //
        //  Add an extra reference so LpcExitThread does not evaporate
        //  the pointer before we get to the wait below
        //

        ObReferenceObject( WakeupThread );

        Msg->RepliedToThread = WakeupThread;

        WakeupThread->LpcReplyMessageId = 0;
        WakeupThread->LpcReplyMessage = (PVOID)Msg;

        //
        //  Remove the thread from the reply rundown list as we are sending a callback
        //

        if (!IsListEmpty( &WakeupThread->LpcReplyChain )) {

            RemoveEntryList( &WakeupThread->LpcReplyChain );

            InitializeListHead( &WakeupThread->LpcReplyChain );
        }

        CurrentThread->LpcReplyMessageId = Msg->Request.MessageId;
        CurrentThread->LpcReplyMessage = NULL;

        InsertTailList( &RundownPort->LpcReplyChainHead, &CurrentThread->LpcReplyChain );

        LpcpSetPortToThread( CurrentThread, PortObject );

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        LpcpReleaseLpcpLock();

        //
        //  Wake up the thread that is waiting for an answer to its request
        //  inside of NtRequestWaitReplyPort or NtReplyWaitReplyPort
        //

        ReleaseSemaphore = &WakeupThread->LpcReplySemaphore;

    } else {

        //
        //  A callback is not required, so continue setting up the
        //  lpc message
        //

        try {

            LpcpMoveMessage( &Msg->Request,
                             &CapturedRequestMessage,
                             (RequestMessage + 1),
                             MsgType,
                             &CurrentThread->Cid );

            if (CapturedRequestMessage.u2.s2.DataInfoOffset != 0) {

                PPORT_DATA_INFORMATION DataInfo;

                DataInfo = (PPORT_DATA_INFORMATION)(((PUCHAR)RequestMessage) + CapturedRequestMessage.u2.s2.DataInfoOffset);

                if ( DataInfo->CountDataEntries != CapturedDataInfo.CountDataEntries ) {

                    LpcpFreeToPortZone( Msg, 0 );

                    ObDereferenceObject( PortObject );

                    return STATUS_INVALID_PARAMETER;
                }
            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {

            LpcpFreeToPortZone( Msg, 0 );

            ObDereferenceObject( PortObject );

            return GetExceptionCode();
        }

        //
        //  Acquire the global Lpc mutex that guards the LpcReplyMessage
        //  field of the thread and the request message queue.  Stamp the
        //  request message with a serial number, insert the message at
        //  the tail of the request message queue and remember the address
        //  of the message in the LpcReplyMessage field for the current thread.
        //

        LpcpAcquireLpcpLockByThread(CurrentThread);

        Msg->PortContext = NULL;

        if ((PortObject->Flags & PORT_TYPE) != SERVER_CONNECTION_PORT) {

            QueuePort = PortObject->ConnectedPort;

            if (QueuePort == NULL) {

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                ObDereferenceObject( PortObject );

                return STATUS_PORT_DISCONNECTED;
            }

            RundownPort = QueuePort;

            if ((PortObject->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

                Msg->PortContext = QueuePort->PortContext;
                ConnectionPort = QueuePort = PortObject->ConnectionPort;
                
                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                    ObDereferenceObject( PortObject );

                    return STATUS_PORT_DISCONNECTED;
                }

            } else if ((PortObject->Flags & PORT_TYPE) != SERVER_COMMUNICATION_PORT) {

                ConnectionPort = QueuePort = PortObject->ConnectionPort;
                
                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                    ObDereferenceObject( PortObject );

                    return STATUS_PORT_DISCONNECTED;
                }
            }

            if (ConnectionPort) {

                ObReferenceObject( ConnectionPort );
            }

        } else {

            QueuePort = PortObject;
            RundownPort = PortObject;
        }

        //
        //  Stamp the request message with a serial number, insert the message
        //  at the tail of the request message queue
        //

        Msg->RepliedToThread = NULL;
        Msg->Request.MessageId = LpcpGenerateMessageId();
        Msg->Request.CallbackId = 0;
        Msg->SenderPort = PortObject;

        CurrentThread->LpcReplyMessageId = Msg->Request.MessageId;
        CurrentThread->LpcReplyMessage = NULL;
        
        InsertTailList( &QueuePort->MsgQueue.ReceiveHead, &Msg->Entry );
        InsertTailList( &RundownPort->LpcReplyChainHead, &CurrentThread->LpcReplyChain );
        
        LpcpSetPortToThread(CurrentThread, PortObject);


        LpcpTrace(( "%s Send Request (%s) Msg %lx (%u) [%08x %08x %08x %08x] to Port %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    LpcpMessageTypeName[ Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE ],
                    Msg,
                    Msg->Request.MessageId,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    QueuePort,
                    LpcpGetCreatorName( QueuePort )));

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        LpcpReleaseLpcpLock();

        //
        //  Increment the request message queue semaphore by one for
        //  the newly inserted request message.
        //

        ReleaseSemaphore = QueuePort->MsgQueue.Semaphore;

        //
        //  If port is waitable then set the event that someone could
        //  be waiting on
        //

        if ( QueuePort->Flags & PORT_WAITABLE ) {

            KeSetEvent( &QueuePort->WaitEvent,
                        LPC_RELEASE_WAIT_INCREMENT,
                        FALSE );
        }
    }

    //
    //  At this point we've enqueued our request and if necessary
    //  set ourselves up for the callback or reply.
    //
    //  So now wake up the other end
    //

    Status = KeReleaseSemaphore( ReleaseSemaphore,
                                 1,
                                 1,
                                 FALSE );

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    if (CallbackRequest) {

        ObDereferenceObject( WakeupThread );
    }

    //
    //  And wait for a reply
    //

    Status = KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                    WrLpcReply,
                                    PreviousMode,
                                    FALSE,
                                    NULL );

    if (Status == STATUS_USER_APC) {

        //
        //  if the semaphore is signaled, then clear it
        //

        if (KeReadStateSemaphore( &CurrentThread->LpcReplySemaphore )) {

            KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                   WrExecutive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            Status = STATUS_SUCCESS;
        }
    }

    //
    //  Acquire the LPC mutex.  Remove the reply message from the current thread
    //

    LpcpAcquireLpcpLockByThread(CurrentThread);

    Msg = LpcpGetThreadMessage(CurrentThread);

    CurrentThread->LpcReplyMessage = NULL;
    CurrentThread->LpcReplyMessageId = 0;

    //
    //  Remove the thread from the reply rundown list in case we did not wakeup due to
    //  a reply
    //

    if (!IsListEmpty( &CurrentThread->LpcReplyChain )) {

        RemoveEntryList( &CurrentThread->LpcReplyChain );

        InitializeListHead( &CurrentThread->LpcReplyChain );
    }

#if DBG
    if (Status == STATUS_SUCCESS && Msg != NULL) {

        LpcpTrace(( "%s Got Reply Msg %lx (%u) [%08x %08x %08x %08x] for Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    Msg,
                    Msg->Request.MessageId,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    CurrentThread,
                    THREAD_TO_PROCESS( CurrentThread )->ImageFileName ));

        if (!IsListEmpty( &Msg->Entry )) {

            LpcpTrace(( "Reply Msg %lx has non-empty list entry\n", Msg ));
        }
    }
#endif

    LpcpReleaseLpcpLock();

    //
    //  If the wait succeeded, copy the reply to the reply buffer.
    //

    if (Status == STATUS_SUCCESS) {

        if (Msg != NULL) {

            try {

                LpcpMoveMessage( ReplyMessage,
                                 &Msg->Request,
                                 (&Msg->Request) + 1,
                                 0,
                                 NULL );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                Status = GetExceptionCode();
            }

            //
            //  Acquire the LPC mutex and decrement the reference count for the
            //  message.  If the reference count goes to zero the message will be
            //  deleted.
            //

            if (((Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_REQUEST) &&
                (Msg->Request.u2.s2.DataInfoOffset != 0)) {

                LpcpSaveDataInfoMessage( PortObject, Msg, 0 );

            } else {

                LpcpFreeToPortZone( Msg, 0 );
            }

        } else {

            Status = STATUS_LPC_REPLY_LOST;
        }

    } else {

        //
        //  Wait failed, free the message if any.
        //

        LpcpTrace(( "%s NtRequestWaitReply wait failed - Status == %lx\n",
                    PsGetCurrentProcess()->ImageFileName,
                    Status ));

        if (Msg != NULL) {

            LpcpFreeToPortZone( Msg, 0);
        }
    }

    ObDereferenceObject( PortObject );
    
    if (ConnectionPort) {

        ObDereferenceObject( ConnectionPort );
    }

    //
    //  And return to our caller
    //

    return Status;
}


NTSTATUS
LpcRequestPort (
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage
    )

/*++

Routine Description:

    This procedure is similar to NtRequestPort but without the Handle based
    interface.

Arguments:

    PortAddress - Supplies a pointer to the communication port to send
        the request message to.

    RequestMessage - Specifies a pointer to the request message.  The Type
        field of the message is set to LPC_DATAGRAM by the service.

Return Value:

    NTSTATUS - A status code that indicates whether or not the operation was
        successful.

--*/

{
    PETHREAD CurrentThread;
    PLPCP_PORT_OBJECT PortObject = (PLPCP_PORT_OBJECT)PortAddress;
    PLPCP_PORT_OBJECT QueuePort;
    ULONG MsgType;
    PLPCP_MESSAGE Msg;
    KPROCESSOR_MODE PreviousMode;
    PLPCP_PORT_OBJECT ConnectionPort = NULL;

    PAGED_CODE();

    //
    //  Get previous processor mode and validate parameters
    //

    PreviousMode = KeGetPreviousMode();

    if (RequestMessage->u2.s2.Type != 0) {

        MsgType = RequestMessage->u2.s2.Type & ~LPC_KERNELMODE_MESSAGE;

        if ((MsgType < LPC_DATAGRAM) ||
            (MsgType > LPC_CLIENT_DIED)) {

            return STATUS_INVALID_PARAMETER;
        }

        //
        //  If previous mode is kernel, allow the LPC_KERNELMODE_MESSAGE
        //  bit to be passed in message type field.
        //

        if ((PreviousMode == KernelMode) &&
            (RequestMessage->u2.s2.Type & LPC_KERNELMODE_MESSAGE)) {

            MsgType |= LPC_KERNELMODE_MESSAGE;
        }

    } else {

        MsgType = LPC_DATAGRAM;
    }

    if (RequestMessage->u2.s2.DataInfoOffset != 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Validate the message length
    //

    if (((ULONG)RequestMessage->u1.s1.TotalLength > PortObject->MaxMessageLength) ||
        ((ULONG)RequestMessage->u1.s1.TotalLength <= (ULONG)RequestMessage->u1.s1.DataLength)) {

        return STATUS_PORT_MESSAGE_TOO_LONG;
    }

    //
    //  Allocate a message block
    //


    Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( RequestMessage->u1.s1.TotalLength );

    if (Msg == NULL) {

        return STATUS_NO_MEMORY;
    }

    //
    //  Fill in the message block.
    //

    Msg->RepliedToThread = NULL;
    Msg->PortContext = NULL;

    CurrentThread = PsGetCurrentThread();

    LpcpMoveMessage( &Msg->Request,
                     RequestMessage,
                     (RequestMessage + 1),
                     MsgType,
                     &CurrentThread->Cid );

    //
    //  Acquire the global Lpc mutex that guards the LpcReplyMessage
    //  field of the thread and the request message queue.  Stamp the
    //  request message with a serial number, insert the message at
    //  the tail of the request message queue
    //

    LpcpAcquireLpcpLockByThread(CurrentThread);

    if ((PortObject->Flags & PORT_TYPE) != SERVER_CONNECTION_PORT) {

        QueuePort = PortObject->ConnectedPort;

        if (QueuePort != NULL) {

            if ((PortObject->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

                Msg->PortContext = QueuePort->PortContext;
                ConnectionPort = QueuePort = PortObject->ConnectionPort;

                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                    return STATUS_PORT_DISCONNECTED;
                }

            //
            //  In the case we don't have a CLIENT_COMMUNICATION_PORT nor 
            //  SERVER_COMMUNICATION_PORT we'll use the connection port
            //  to queue messages. 
            //    

            } else if ((PortObject->Flags & PORT_TYPE) != SERVER_COMMUNICATION_PORT) {

                QueuePort = PortObject->ConnectionPort;
                
                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                    return STATUS_PORT_DISCONNECTED;
                }
            }

            if (ConnectionPort) {

                ObReferenceObject( ConnectionPort );
            }
        }

    } else {

        QueuePort = PortObject;
    }

    //
    //  At this point we have an LPC message ready to send and if queue port is
    //  not null then we have a port to actually send the message off to
    //

    if (QueuePort != NULL) {

        Msg->Request.MessageId = LpcpGenerateMessageId();
        Msg->Request.CallbackId = 0;
        Msg->SenderPort = PortObject;

        CurrentThread->LpcReplyMessageId = 0;

        InsertTailList( &QueuePort->MsgQueue.ReceiveHead, &Msg->Entry );

        LpcpTrace(( "%s Send DataGram (%s) Msg %lx [%08x %08x %08x %08x] to Port %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    LpcpMessageTypeName[ Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE ],
                    Msg,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    QueuePort,
                    LpcpGetCreatorName( QueuePort )));

        //
        //  Release the mutex, increment the request message queue
        //  semaphore by one for the newly inserted request message,
        //  then exit the critical region.
        //
        //  Disable APCs to prevent this thread from being suspended
        //  before being able to release the semaphore.
        //

        KeEnterCriticalRegionThread(&CurrentThread->Tcb);

        LpcpReleaseLpcpLock();

        KeReleaseSemaphore( QueuePort->MsgQueue.Semaphore,
                            LPC_RELEASE_WAIT_INCREMENT,
                            1L,
                            FALSE );


        if ( QueuePort->Flags & PORT_WAITABLE ) {

            KeSetEvent( &QueuePort->WaitEvent,
                        LPC_RELEASE_WAIT_INCREMENT,
                        FALSE );
        }

        KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

        if (ConnectionPort) {

            ObDereferenceObject( ConnectionPort );
        }

        return STATUS_SUCCESS;

    }

    //
    //  At this point we have a message but not a valid port to queue it off
    //  to so we'll release the unused message and release our mutex.
    //

    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

    if (ConnectionPort) {

        ObDereferenceObject( ConnectionPort );
    }

    //
    //  And return the error status to our caller
    //

    return STATUS_PORT_DISCONNECTED;
}


NTSTATUS
LpcpRequestWaitReplyPort (
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage,
    IN KPROCESSOR_MODE AccessMode
    )

/*++

Routine Description:

    This procedure is similar to NtRequestWaitReplyPort but without the
    handle based interface

Arguments:

    PortAddress - Supplies the communication port object to send the
        request message to.

    RequestMessage - Specifies a pointer to a request message to send.

    ReplyMessage - Specifies the address of a variable that will receive the
        reply message.  This parameter may point to the same buffer as the
        RequestMessage parameter.

Return Value:

    NTSTATUS - A status code that indicates whether or not the operation was
        successful.

--*/

{
    PLPCP_PORT_OBJECT PortObject = (PLPCP_PORT_OBJECT)PortAddress;
    PLPCP_PORT_OBJECT QueuePort;
    PLPCP_PORT_OBJECT RundownPort;
    PKSEMAPHORE ReleaseSemaphore;
    NTSTATUS Status;
    ULONG MsgType;
    PLPCP_MESSAGE Msg;
    PETHREAD CurrentThread;
    PETHREAD WakeupThread;
    BOOLEAN CallbackRequest;
    KPROCESSOR_MODE PreviousMode;
    PLPCP_PORT_OBJECT ConnectionPort = NULL;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread();

    if (CurrentThread->LpcExitThreadCalled) {

        return STATUS_THREAD_IS_TERMINATING;
    }

    //
    //  Get previous processor mode and validate parameters
    //

    PreviousMode = KeGetPreviousMode();
    MsgType = RequestMessage->u2.s2.Type & ~LPC_KERNELMODE_MESSAGE;
    CallbackRequest = FALSE;

    switch (MsgType) {

    case 0:

        MsgType = LPC_REQUEST;
        break;

    case LPC_REQUEST:

        CallbackRequest = TRUE;
        break;

    case LPC_CLIENT_DIED:
    case LPC_PORT_CLOSED:
    case LPC_EXCEPTION:
    case LPC_DEBUG_EVENT:
    case LPC_ERROR_EVENT:

        break;

    default :

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Allow the LPC_KERNELMODE_MESSAGE
    //  bit to be passed in message type field. Don't check the previous mode !!!
    //

    if ( RequestMessage->u2.s2.Type & LPC_KERNELMODE_MESSAGE) {

        MsgType |= LPC_KERNELMODE_MESSAGE;
    }

    RequestMessage->u2.s2.Type = (CSHORT)MsgType;

    //
    //  Validate the message length
    //

    if (((ULONG)RequestMessage->u1.s1.TotalLength > PortObject->MaxMessageLength) ||
        ((ULONG)RequestMessage->u1.s1.TotalLength <= (ULONG)RequestMessage->u1.s1.DataLength)) {

        return STATUS_PORT_MESSAGE_TOO_LONG;
    }

    //
    //  Determine which port to queue the message to and get client
    //  port context if client sending to server.  Also validate
    //  length of message being sent.
    //


    Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( RequestMessage->u1.s1.TotalLength );


    if (Msg == NULL) {

        return STATUS_NO_MEMORY;
    }

    if (CallbackRequest) {

        //
        //  Check for a valid request message id
        //

        if (RequestMessage->MessageId == 0) {

            LpcpFreeToPortZone( Msg, 0 );

            return STATUS_INVALID_PARAMETER;
        }

        //
        //  Translate the ClientId from the request into a
        //  thread pointer.  This is a referenced pointer to keep the thread
        //  from evaporating out from under us.
        //

        Status = PsLookupProcessThreadByCid( &RequestMessage->ClientId,
                                             NULL,
                                             &WakeupThread );

        if (!NT_SUCCESS( Status )) {

            LpcpFreeToPortZone( Msg, 0 );

            return Status;
        }

        //
        //  Acquire the mutex that guards the LpcReplyMessage field of
        //  the thread and get the pointer to the message that the thread
        //  is waiting for a reply to.
        //

        LpcpAcquireLpcpLockByThread(CurrentThread);

        //
        //  See if the thread is waiting for a reply to the message
        //  specified on this call.  If not then a bogus message
        //  has been specified, so release the mutex, dereference the thread
        //  and return failure.
        //

        if ((WakeupThread->LpcReplyMessageId != RequestMessage->MessageId)

                ||

            ((LpcpGetThreadMessage(WakeupThread) != NULL) &&
             (LpcpGetThreadMessage(WakeupThread)->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_REQUEST)

                ||

            (!LpcpValidateClientPort(WakeupThread, PortObject, LPCP_VALIDATE_REASON_REPLY)) ) {

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

            ObDereferenceObject( WakeupThread );

            return STATUS_REPLY_MESSAGE_MISMATCH;
        }

        QueuePort = NULL;
        Msg->PortContext = NULL;

        if ((PortObject->Flags & PORT_TYPE) == SERVER_CONNECTION_PORT) {

            RundownPort = PortObject;

        } else {

            RundownPort = PortObject->ConnectedPort;

            if (RundownPort == NULL) {

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                ObDereferenceObject( WakeupThread );

                return STATUS_PORT_DISCONNECTED;
            }

            if ((PortObject->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

                Msg->PortContext = RundownPort->PortContext;
            }
        }
        
        //
        //  Allocate and initialize a request message
        //

        LpcpMoveMessage( &Msg->Request,
                         RequestMessage,
                         (RequestMessage + 1),
                         0,
                         &CurrentThread->Cid );

        Msg->Request.CallbackId = LpcpGenerateCallbackId();

        LpcpTrace(( "%s CallBack Request (%s) Msg %lx (%u.%u) [%08x %08x %08x %08x] to Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    LpcpMessageTypeName[ Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE ],
                    Msg,
                    Msg->Request.MessageId,
                    Msg->Request.CallbackId,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    WakeupThread,
                    THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

        //
        //  Add an extra reference so LpcExitThread does not evaporate
        //  the pointer before we get to the wait below
        //

        ObReferenceObject( WakeupThread );

        Msg->RepliedToThread = WakeupThread;

        WakeupThread->LpcReplyMessageId = 0;
        WakeupThread->LpcReplyMessage = (PVOID)Msg;

        //
        //  Remove the thread from the reply rundown list as we are sending a callback
        //

        if (!IsListEmpty( &WakeupThread->LpcReplyChain )) {

            RemoveEntryList( &WakeupThread->LpcReplyChain );

            InitializeListHead( &WakeupThread->LpcReplyChain );
        }

        CurrentThread->LpcReplyMessageId = Msg->Request.MessageId;
        CurrentThread->LpcReplyMessage = NULL;
        
        InsertTailList( &RundownPort->LpcReplyChainHead, &CurrentThread->LpcReplyChain );
        
        LpcpSetPortToThread(CurrentThread, PortObject);

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        LpcpReleaseLpcpLock();

        //
        //  Wake up the thread that is waiting for an answer to its request
        //  inside of NtRequestWaitReplyPort or NtReplyWaitReplyPort
        //

        ReleaseSemaphore = &WakeupThread->LpcReplySemaphore;

    } else {

        //
        //  There is no callback requested
        //

        LpcpMoveMessage( &Msg->Request,
                         RequestMessage,
                         (RequestMessage + 1),
                         0,
                         &CurrentThread->Cid );

        //
        //  Acquire the global Lpc mutex that guards the LpcReplyMessage
        //  field of the thread and the request message queue.  Stamp the
        //  request message with a serial number, insert the message at
        //  the tail of the request message queue and remember the address
        //  of the message in the LpcReplyMessage field for the current thread.
        //

        LpcpAcquireLpcpLockByThread(CurrentThread);

        Msg->PortContext = NULL;

        if ((PortObject->Flags & PORT_TYPE) != SERVER_CONNECTION_PORT) {

            QueuePort = PortObject->ConnectedPort;

            if (QueuePort == NULL) {

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                return STATUS_PORT_DISCONNECTED;
            }

            RundownPort = QueuePort;

            if ((PortObject->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

                Msg->PortContext = QueuePort->PortContext;
                ConnectionPort = QueuePort = PortObject->ConnectionPort;

                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                    return STATUS_PORT_DISCONNECTED;
                }

            } else if ((PortObject->Flags & PORT_TYPE) != SERVER_COMMUNICATION_PORT) {

                ConnectionPort = QueuePort = PortObject->ConnectionPort;
                
                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                    return STATUS_PORT_DISCONNECTED;
                }
            }

            if (ConnectionPort) {

                ObReferenceObject( ConnectionPort );
            }

        } else {

            if ((PortObject->Flags & PORT_NAME_DELETED) != 0) {
                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                return STATUS_PORT_DISCONNECTED;
            }

            QueuePort = PortObject;
            RundownPort = PortObject;
        }

        Msg->RepliedToThread = NULL;
        Msg->Request.MessageId = LpcpGenerateMessageId();
        Msg->Request.CallbackId = 0;
        Msg->SenderPort = PortObject;

        CurrentThread->LpcReplyMessageId = Msg->Request.MessageId;
        CurrentThread->LpcReplyMessage = NULL;

        InsertTailList( &QueuePort->MsgQueue.ReceiveHead, &Msg->Entry );
        InsertTailList( &RundownPort->LpcReplyChainHead, &CurrentThread->LpcReplyChain );
        
        LpcpSetPortToThread(CurrentThread, PortObject);

        LpcpTrace(( "%s Send Request (%s) Msg %lx (%u) [%08x %08x %08x %08x] to Port %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    LpcpMessageTypeName[ Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE ],
                    Msg,
                    Msg->Request.MessageId,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    QueuePort,
                    LpcpGetCreatorName( QueuePort )));

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        LpcpReleaseLpcpLock();

        //
        //  Increment the request message queue semaphore by one for
        //  the newly inserted request message.  Release the spin
        //  lock, while remaining at the dispatcher IRQL.  Then wait for the
        //  reply to this request by waiting on the LpcReplySemaphore
        //  for the current thread.
        //

        ReleaseSemaphore = QueuePort->MsgQueue.Semaphore;

        if ( QueuePort->Flags & PORT_WAITABLE ) {

            KeSetEvent( &QueuePort->WaitEvent,
                        LPC_RELEASE_WAIT_INCREMENT,
                        FALSE );
        }
    }

    //
    //  At this point we've enqueued our request and if necessary
    //  set ourselves up for the callback or reply.
    //
    //  So now wake up the other end
    //

    Status = KeReleaseSemaphore( ReleaseSemaphore,
                                 1,
                                 1,
                                 FALSE );
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    if (CallbackRequest) {

        ObDereferenceObject( WakeupThread );
    }

    //
    //  And wait for a reply
    //

    Status = KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                    WrLpcReply,
                                    AccessMode,
                                    FALSE,
                                    NULL );

    if (Status == STATUS_USER_APC) {

        //
        //  if the semaphore is signaled, then clear it
        //

        if (KeReadStateSemaphore( &CurrentThread->LpcReplySemaphore )) {

            KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                   WrExecutive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            Status = STATUS_SUCCESS;
        }
    }

    //
    //  Acquire the LPC mutex.  Remove the reply message from the current thread
    //

    LpcpAcquireLpcpLockByThread(CurrentThread);

    Msg = LpcpGetThreadMessage(CurrentThread);

    CurrentThread->LpcReplyMessage = NULL;
    CurrentThread->LpcReplyMessageId = 0;

    //
    //  Remove the thread from the reply rundown list in case we did not wakeup due to
    //  a reply
    //

    if (!IsListEmpty( &CurrentThread->LpcReplyChain )) {

        RemoveEntryList( &CurrentThread->LpcReplyChain );

        InitializeListHead( &CurrentThread->LpcReplyChain );
    }

#if DBG
    if (Msg != NULL) {

        LpcpTrace(( "%s Got Reply Msg %lx (%u) [%08x %08x %08x %08x] for Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    Msg,
                    Msg->Request.MessageId,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    CurrentThread,
                    THREAD_TO_PROCESS( CurrentThread )->ImageFileName ));
    }
#endif

    LpcpReleaseLpcpLock();

    //
    //  If the wait succeeded, copy the reply to the reply buffer.
    //

    if (Status == STATUS_SUCCESS) {

        if (Msg != NULL) {

            LpcpMoveMessage( ReplyMessage,
                             &Msg->Request,
                             (&Msg->Request) + 1,
                             0,
                             NULL );

            //
            //  Acquire the LPC mutex and decrement the reference count for the
            //  message.  If the reference count goes to zero the message will be
            //  deleted.
            //

            LpcpAcquireLpcpLockByThread(CurrentThread);

            if (Msg->RepliedToThread != NULL) {

                ObDereferenceObject( Msg->RepliedToThread );

                Msg->RepliedToThread = NULL;
            }

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

        } else {

            Status = STATUS_LPC_REPLY_LOST;
        }

    } else {

        //
        //  Wait failed, free the message if any.
        //

        if (Msg != NULL) {

            LpcpFreeToPortZone( Msg, 0 );
        }
    }

    if (ConnectionPort) {

        ObDereferenceObject( ConnectionPort );
    }
    
    //
    //  And return to our caller
    //

    return Status;
}


NTSTATUS
LpcRequestWaitReplyPort (
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    )
{
    return LpcpRequestWaitReplyPort( PortAddress,
                                     RequestMessage,
                                     ReplyMessage,
                                     KernelMode
                                   );
}


NTSTATUS
LpcRequestWaitReplyPortEx (
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    )
{
    return LpcpRequestWaitReplyPort( PortAddress,
                                     RequestMessage,
                                     ReplyMessage,
                                     KeGetPreviousMode()
                                   );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpcqueue.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpcqueue.c

Abstract:

    Local Inter-Process Communication (LPC) queue support routines.

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#include "lpcp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,LpcpInitializePortZone)
#pragma alloc_text(PAGE,LpcpInitializePortQueue)
#pragma alloc_text(PAGE,LpcpDestroyPortQueue)
#pragma alloc_text(PAGE,LpcpExtendPortZone)
#pragma alloc_text(PAGE,LpcpFreeToPortZone)
#pragma alloc_text(PAGE,LpcpSaveDataInfoMessage)
#pragma alloc_text(PAGE,LpcpFreeDataInfoMessage)
#pragma alloc_text(PAGE,LpcpFindDataInfoMessage)
#pragma alloc_text(PAGE,LpcDisconnectPort)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif // ALLOC_DATA_PRAGMA

ULONG LpcpTotalNumberOfMessages = 0;
ULONG LpcpMaxMessageSize = 0;
PAGED_LOOKASIDE_LIST LpcpMessagesLookaside;


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif // ALLOC_DATA_PRAGMA


NTSTATUS
LpcpInitializePortQueue (
    IN PLPCP_PORT_OBJECT Port
    )

/*++

Routine Description:

    This routine is used to initialize the message queue for a port object.

Arguments:

    Port - Supplies the port object being initialized

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    PLPCP_NONPAGED_PORT_QUEUE NonPagedPortQueue;

    PAGED_CODE();

    //
    //  Allocate space for the port queue
    //

    NonPagedPortQueue = ExAllocatePoolWithTag( NonPagedPool,
                                               sizeof(LPCP_NONPAGED_PORT_QUEUE),
                                               'troP' );

    if (NonPagedPortQueue == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Initialize the fields in the non paged port queue
    //

    KeInitializeSemaphore( &NonPagedPortQueue->Semaphore, 0, 0x7FFFFFFF );

    NonPagedPortQueue->BackPointer = Port;

    //
    //  Have the port msg queue point to the non nonpaged port queue
    //

    Port->MsgQueue.Semaphore = &NonPagedPortQueue->Semaphore;

    //
    //  Initialize the port msg queue to be empty
    //

    InitializeListHead( &Port->MsgQueue.ReceiveHead );

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


VOID
LpcpDestroyPortQueue (
    IN PLPCP_PORT_OBJECT Port,
    IN BOOLEAN CleanupAndDestroy
    )

/*++

Routine Description:

    This routine is used to teardown the message queue of a port object.
    After running this message will either be empty (like it was just
    initialized) or completely gone (needs to be initialized)

Arguments:

    Port - Supplies the port containing the message queue being modified

    CleanupAndDestroy - Specifies if the message queue should be set back
        to the freshly initialized state (value of FALSE) or completely
        torn down (value of TRUE)

Return Value:

    None.

--*/

{
    PLIST_ENTRY Next, Head;
    PETHREAD ThreadWaitingForReply;
    PLPCP_MESSAGE Msg;
    PLPCP_PORT_OBJECT ConnectionPort = NULL;

    PAGED_CODE();

    //
    //  If this port is connected to another port, then disconnect it.
    //  Protect this with a lock in case the other side is going away
    //  at the same time.
    //

    LpcpAcquireLpcpLock();

    if ( ((Port->Flags & PORT_TYPE) != UNCONNECTED_COMMUNICATION_PORT)
            &&
         (Port->ConnectedPort != NULL) ) {

        Port->ConnectedPort->ConnectedPort = NULL;
        
        //
        //  Disconnect the connection port
        //

        if (Port->ConnectedPort->ConnectionPort) {

            ConnectionPort = Port->ConnectedPort->ConnectionPort;

            Port->ConnectedPort->ConnectionPort = NULL;
        }
    }

    //
    //  If connection port, then mark name as deleted
    //

    if ((Port->Flags & PORT_TYPE) == SERVER_CONNECTION_PORT) {

        Port->Flags |= PORT_NAME_DELETED;
    }

    //
    //  Walk list of threads waiting for a reply to a message sent to this
    //  port.  Signal each thread's LpcReplySemaphore to wake them up.  They
    //  will notice that there was no reply and return
    //  STATUS_PORT_DISCONNECTED
    //

    Head = &Port->LpcReplyChainHead;
    Next = Head->Flink;

    while ((Next != NULL) && (Next != Head)) {

        ThreadWaitingForReply = CONTAINING_RECORD( Next, ETHREAD, LpcReplyChain );

        //
        //  If the thread is exiting, in the location of LpcReplyChain is stored the ExitTime
        //  We'll stop to search through the list.

        if ( ThreadWaitingForReply->LpcExitThreadCalled ) {
            
            break;
        }

        Next = Next->Flink;

        RemoveEntryList( &ThreadWaitingForReply->LpcReplyChain );

        InitializeListHead( &ThreadWaitingForReply->LpcReplyChain );

        if (!KeReadStateSemaphore( &ThreadWaitingForReply->LpcReplySemaphore )) {

            //
            //  Thread is waiting on a message.  Signal the semaphore and free
            //  the message
            //

            Msg = LpcpGetThreadMessage(ThreadWaitingForReply);

            if ( Msg ) {

                //
                //  If the message is a connection request and has a section object
                //  attached, then dereference that section object
                //

                if ((Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_CONNECTION_REQUEST) {

                    PLPCP_CONNECTION_MESSAGE ConnectMsg;
                
                    ConnectMsg = (PLPCP_CONNECTION_MESSAGE)(Msg + 1);

                    if ( ConnectMsg->SectionToMap != NULL ) {

                        ObDereferenceObject( ConnectMsg->SectionToMap );
                    }
                }

                ThreadWaitingForReply->LpcReplyMessage = NULL;

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED );
                Next = Port->LpcReplyChainHead.Flink; // Lock has been dropped
            }

            ThreadWaitingForReply->LpcReplyMessageId = 0;

            KeReleaseSemaphore( &ThreadWaitingForReply->LpcReplySemaphore,
                                0,
                                1L,
                                FALSE );
        }
    }

    InitializeListHead( &Port->LpcReplyChainHead );

    //
    //  Walk list of messages queued to this port.  Remove each message from
    //  the list and free it.
    //

    while (Port->MsgQueue.ReceiveHead.Flink && !IsListEmpty (&Port->MsgQueue.ReceiveHead)) {

        Msg  = CONTAINING_RECORD( Port->MsgQueue.ReceiveHead.Flink, LPCP_MESSAGE, Entry );

        RemoveEntryList (&Msg->Entry);

        InitializeListHead( &Msg->Entry );

        LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED );
        
    }

    LpcpReleaseLpcpLock();

    if ( ConnectionPort ) {

        ObDereferenceObject( ConnectionPort );
    }

    //
    //  Check if the caller wants it all to go away
    //

    if ( CleanupAndDestroy ) {

        //
        //  Free semaphore associated with the queue.
        //

        if (Port->MsgQueue.Semaphore != NULL) {

            ExFreePool( CONTAINING_RECORD( Port->MsgQueue.Semaphore,
                                           LPCP_NONPAGED_PORT_QUEUE,
                                           Semaphore ));
        }
    }

    //
    //  And return to our caller
    //

    return;
}


NTSTATUS
LpcDisconnectPort (
    IN PVOID Port
    )

/*++

Routine Description:

    This routine is used to disconnect an LPC port so no more messages can be sent and anybody waiting for a message
    is woken up with an error.

Arguments:

    Port - Supplies the port to be disconnected

Return Value:

    NTSTATUS - Status of operation

--*/
{
    LpcpDestroyPortQueue (Port, FALSE);
    return STATUS_SUCCESS;
}


VOID
LpcpInitializePortZone (
    IN ULONG MaxEntrySize
    )
{
    LpcpMaxMessageSize = MaxEntrySize;

    ExInitializePagedLookasideList( &LpcpMessagesLookaside,
                                    NULL,
                                    NULL,
                                    0,
                                    MaxEntrySize,
                                    'McpL',
                                    32 
                                    );
}


VOID
FASTCALL
LpcpFreeToPortZone (
    IN PLPCP_MESSAGE Msg,
    IN ULONG MutexFlags
    )
{
    PLPCP_CONNECTION_MESSAGE ConnectMsg;
    PETHREAD RepliedToThread = NULL;
    PLPCP_PORT_OBJECT ClientPort = NULL;

    PAGED_CODE();

    //
    //  Acquire the global lock if necessary
    //

    if ((MutexFlags & LPCP_MUTEX_OWNED) == 0) {

        LpcpAcquireLpcpLock();
    }

    //
    //  A entry field connects the message to the message queue of the
    //  owning port object.  If not already removed then remove this
    //  message
    //

    if (!IsListEmpty( &Msg->Entry )) {
        RemoveEntryList( &Msg->Entry );
        InitializeListHead( &Msg->Entry );
    }

    //
    //  If the replied to thread is not null then we have a reference
    //  to the thread that we should now remove
    //

    if (Msg->RepliedToThread != NULL) {
        RepliedToThread = Msg->RepliedToThread;
        Msg->RepliedToThread = NULL;
    }

    //
    //  If the msg was for a connection request then we know that
    //  right after the lpcp message is a connection message whose
    //  client port field might need to be dereferenced
    //

    if ((Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_CONNECTION_REQUEST) {

        ConnectMsg = (PLPCP_CONNECTION_MESSAGE)(Msg + 1);

        if (ConnectMsg->ClientPort) {

            //
            //  Capture a pointer to the client port then null it
            //  out so that no one else can use it, then release
            //  lpcp lock before we dereference the client port
            //

            ClientPort = ConnectMsg->ClientPort;

            ConnectMsg->ClientPort = NULL;
        }
    }

    LpcpReleaseLpcpLock();

    if ( ClientPort ) {
        
        ObDereferenceObject( ClientPort );
    }

    if ( RepliedToThread ) {

        ObDereferenceObject( RepliedToThread );
    }

    ExFreeToPagedLookasideList(&LpcpMessagesLookaside, Msg);

    if ((MutexFlags & LPCP_MUTEX_OWNED) &&
        ((MutexFlags & LPCP_MUTEX_RELEASE_ON_RETURN) == 0)) {

        LpcpAcquireLpcpLock();
    }

}



VOID
LpcpSaveDataInfoMessage (
    IN PLPCP_PORT_OBJECT Port,
    IN PLPCP_MESSAGE Msg,
    IN ULONG MutexFlags
    )

/*++

Routine Description:

    This routine is used in place of freeing a message and instead saves the
    message off a separate queue from the port.

Arguments:

    Port - Specifies the port object under which to save this message

    Msg - Supplies the message being saved

    MutexFlags - Supplies whether the mutex is owned.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Take out the global lock if our caller didn't already.
    //

    if ((MutexFlags & LPCP_MUTEX_OWNED) == 0) {
        LpcpAcquireLpcpLock();
    }

    //
    //  Make sure we get to the connection port object of this port
    //

    if ((Port->Flags & PORT_TYPE) > UNCONNECTED_COMMUNICATION_PORT) {

        Port = Port->ConnectionPort;

        if (Port == NULL) {

            if ((MutexFlags & LPCP_MUTEX_OWNED) == 0) {
                LpcpReleaseLpcpLock();
            }

            return;
        }
    }

    LpcpTrace(( "%s Saving DataInfo Message %lx (%u.%u)  Port: %lx\n",
                PsGetCurrentProcess()->ImageFileName,
                Msg,
                Msg->Request.MessageId,
                Msg->Request.CallbackId,
                Port ));

    //
    //  Enqueue this message onto the data info chain for the port
    //

    InsertTailList( &Port->LpcDataInfoChainHead, &Msg->Entry );

    //
    //  Free the global lock
    //

    if ((MutexFlags & LPCP_MUTEX_OWNED) == 0) {
        LpcpReleaseLpcpLock();
    }

    //
    //  And return to our caller
    //

    return;
}


VOID
LpcpFreeDataInfoMessage (
    IN PLPCP_PORT_OBJECT Port,
    IN ULONG MessageId,
    IN ULONG CallbackId
    )

/*++

Routine Description:

    This routine is used to free up a saved message in a port

Arguments:

    Port - Supplies the port being manipulated

    MessageId - Supplies the id of the message being freed

    CallbackId - Supplies the callback id of the message being freed

Return Value:

    None.

--*/

{
    PLPCP_MESSAGE Msg;
    PLIST_ENTRY Head, Next;

    PAGED_CODE();

    //
    //  Make sure we get to the connection port object of this port
    //

    if ((Port->Flags & PORT_TYPE) > UNCONNECTED_COMMUNICATION_PORT) {

        Port = Port->ConnectionPort;

        if (Port == NULL) {

            return;
        }
    }

    //
    //  Zoom down the data info chain for the connection port object
    //

    Head = &Port->LpcDataInfoChainHead;
    Next = Head->Flink;

    while (Next != Head) {

        Msg = CONTAINING_RECORD( Next, LPCP_MESSAGE, Entry );

        //
        //  If this message matches the callers specification then remove
        //  this message, free it back to the port zone, and return back
        //  to our caller
        //

        if ((Msg->Request.MessageId == MessageId) &&
            (Msg->Request.CallbackId == CallbackId)) {

            LpcpTrace(( "%s Removing DataInfo Message %lx (%u.%u) Port: %lx\n",
                        PsGetCurrentProcess()->ImageFileName,
                        Msg,
                        Msg->Request.MessageId,
                        Msg->Request.CallbackId,
                        Port ));

            RemoveEntryList( &Msg->Entry );

            InitializeListHead( &Msg->Entry );

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED );

            return;

        } else {

            //
            //  Keep on going down the data info chain
            //

            Next = Next->Flink;
        }
    }

    //
    //  We didn't find a match so just return to our caller
    //

    LpcpTrace(( "%s Unable to find DataInfo Message (%u.%u)  Port: %lx\n",
                PsGetCurrentProcess()->ImageFileName,
                MessageId,
                CallbackId,
                Port ));

    return;
}


PLPCP_MESSAGE
LpcpFindDataInfoMessage (
    IN PLPCP_PORT_OBJECT Port,
    IN ULONG MessageId,
    IN ULONG CallbackId
    )

/*++

Routine Description:

    This routine is used to locate a specific message stored off the
    data info chain of a port

Arguments:

    Port - Supplies the port being examined

    MessageId - Supplies the ID of the message being searched for

    CallbackId - Supplies the callback ID being searched for

Return Value:

    PLPCP_MESSAGE - returns a pointer to the message satisfying the
        search criteria or NULL of none was found

--*/

{
    PLPCP_MESSAGE Msg;
    PLIST_ENTRY Head, Next;

    PAGED_CODE();

    //
    //  Make sure we get to the connection port object of this port
    //

    if ((Port->Flags & PORT_TYPE) > UNCONNECTED_COMMUNICATION_PORT) {

        Port = Port->ConnectionPort;

        if (Port == NULL) {

            return NULL;
        }
    }

    //
    //  Zoom down the data info chain for the connection port object looking
    //  for a match
    //

    Head = &Port->LpcDataInfoChainHead;
    Next = Head->Flink;

    while (Next != Head) {

        Msg = CONTAINING_RECORD( Next, LPCP_MESSAGE, Entry );

        if ((Msg->Request.MessageId == MessageId) &&
            (Msg->Request.CallbackId == CallbackId)) {

            LpcpTrace(( "%s Found DataInfo Message %lx (%u.%u)  Port: %lx\n",
                        PsGetCurrentProcess()->ImageFileName,
                        Msg,
                        Msg->Request.MessageId,
                        Msg->Request.CallbackId,
                        Port ));

            return Msg;

        } else {

            Next = Next->Flink;
        }
    }

    //
    //  We did not find a match so return null to our caller
    //

    LpcpTrace(( "%s Unable to find DataInfo Message (%u.%u)  Port: %lx\n",
                PsGetCurrentProcess()->ImageFileName,
                MessageId,
                CallbackId,
                Port ));

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\uclient.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    uclient.c

Abstract:

    User Mode Client Test program for the LPC subcomponent of the NTOS project

Author:

    Steve Wood (stevewo) 28-Aug-1989

Revision History:

--*/

#include "ulpc.h"

#define MAX_CLIENT_PROCESSES 9
#define MAX_CLIENT_THREADS 9

CHAR ProcessName[ 32 ];
HANDLE PortHandle = NULL;

HANDLE ClientThreadHandles[ MAX_CLIENT_THREADS ] = {NULL};
DWORD  ClientThreadClientIds[ MAX_CLIENT_THREADS ];

DWORD
ClientThread(
    LPVOID Context
    )
{
    CHAR ThreadName[ 64 ];
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG MsgLength;
    PTEB Teb = NtCurrentTeb();

    Teb->ActiveRpcHandle = NULL;

    strcpy( ThreadName, "Client Thread Id: " );
    RtlIntegerToChar( (ULONG)Teb->ClientId.UniqueProcess, 16, 9,
                    ThreadName + strlen( ThreadName )
                  );
    strcat( ThreadName, "." );
    RtlIntegerToChar( (ULONG)Teb->ClientId.UniqueThread,  16, 9,
                    ThreadName + strlen( ThreadName )
                  );

    EnterThread( ThreadName, (ULONG)Context );

    MsgLength = 0;
    while (NT_SUCCESS( Status )) {
        Status = SendRequest( 1,
                              ThreadName,
                              PortHandle,
                              Context,
                              MsgLength,
                              NULL,
                              FALSE
                            );
        MsgLength += sizeof( ULONG );
        if (MsgLength >= (TLPC_MAX_MSG_DATA_LENGTH * sizeof( ULONG ))) {
            break;
            }
        }

    if (PortHandle != NULL) {
        if (!CloseHandle( PortHandle )) {
            fprintf( stderr, "CloseHandle( 0x%lx ) failed - %u\n", PortHandle, GetLastError() );
            }
        else {
            PortHandle = NULL;
            }
        }

    fprintf( stderr, "%s %s\n",
              NT_SUCCESS( Status ) ? "Exiting" : "ABORTING",
              ThreadName
            );

    return RtlNtStatusToDosError( Status );
}


VOID
Usage( VOID )
{
    fprintf( stderr, "usage: UCLIENT ClientNumber [#threads]\n" );
    ExitProcess( 1 );
}


int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS Status;
    DWORD rc;
    PORT_VIEW ClientView;
    REMOTE_PORT_VIEW ServerView;
    ULONG ClientNumber;
    ULONG NumberOfThreads;
    ULONG MaxMessageLength;
    ULONG ConnectionInformationLength;
    UCHAR ConnectionInformation[ 64 ];
    ULONG i;
    PULONG p;
    PTEB Teb = NtCurrentTeb();
    LARGE_INTEGER MaximumSize;

    Status = STATUS_SUCCESS;

    fprintf( stderr, "Entering UCLIENT User Mode LPC Test Program\n" );

    if (argc < 2) {
        Usage();
        }

    ClientNumber = atoi( argv[ 1 ] );
    if (argc < 3) {
        NumberOfThreads = 1;
        }
    else {
        NumberOfThreads = atoi( argv[ 2 ] );
        }

    if (ClientNumber > MAX_CLIENT_PROCESSES ||
        NumberOfThreads > MAX_CLIENT_THREADS
       ) {
        Usage();
        }

    sprintf( ProcessName, "Client Process %08x", Teb->ClientId.UniqueProcess );
    strcpy( ConnectionInformation, ProcessName );
    ConnectionInformationLength = strlen( ProcessName ) + 1;

    RtlInitUnicodeString( &PortName, PORT_NAME );
    fprintf( stderr, "Creating Port Memory Section" );

    MaximumSize.QuadPart = 0x4000 * NumberOfThreads;
    Status = NtCreateSection( &ClientView.SectionHandle,
                              SECTION_MAP_READ | SECTION_MAP_WRITE,
                              NULL,
                              &MaximumSize,
                              PAGE_READWRITE,
                              SEC_COMMIT,
                              NULL
                            );

    if (ShowHandleOrStatus( Status, ClientView.SectionHandle )) {
        ClientView.Length = sizeof( ClientView );
        ClientView.SectionOffset = 0;
        ClientView.ViewSize = 0x2000;
        ClientView.ViewBase = 0;
        ClientView.ViewRemoteBase = 0;
        ServerView.Length = sizeof( ServerView );
        ServerView.ViewSize = 0;
        ServerView.ViewBase = 0;

        fprintf( stderr, "%s calling NtConnectPort( %wZ )\n", ProcessName, &PortName );
        Status = NtConnectPort( &PortHandle,
                                &PortName,
                                &DynamicQos,
                                &ClientView,
                                &ServerView,
                                (PULONG)&MaxMessageLength,
                                (PVOID)ConnectionInformation,
                                (PULONG)&ConnectionInformationLength
                              );



        if (ShowHandleOrStatus( Status, PortHandle )) {
            fprintf( stderr, "    MaxMessageLength: %ld\n", MaxMessageLength );
            fprintf( stderr, "    ConnectionInfo: (%ld) '%.*s'\n",
                      ConnectionInformationLength,
                      ConnectionInformationLength,
                      (PSZ)&ConnectionInformation[0]
                    );
            fprintf( stderr, "    ClientView: Base=%lx, Size=%lx, RemoteBase: %lx\n",
                      ClientView.ViewBase,
                      ClientView.ViewSize,
                      ClientView.ViewRemoteBase
                    );
            fprintf( stderr, "    ServerView: Base=%lx, Size=%lx\n",
                      ServerView.ViewBase,
                      ServerView.ViewSize
                    );
            ClientMemoryBase = ClientView.ViewBase;
            ClientMemorySize = ClientView.ViewSize;
            ServerMemoryBase = ClientView.ViewRemoteBase;
            ServerMemoryDelta = (ULONG)ServerMemoryBase -
                                (ULONG)ClientMemoryBase;

            p = (PULONG)ClientMemoryBase;
            i = ClientMemorySize;
            while (i) {
                fprintf( stderr, "ClientView[%lx] == %lx (%lx)\n",
                          p,
                          *p,
                          *p - ServerMemoryDelta
                        );
                p += (0x1000/sizeof( ULONG ));
                i -= 0x1000;
                }
            p = (PULONG)ServerView.ViewBase;
            i = ServerView.ViewSize;
            while (i) {
                fprintf( stderr, "ServerView[%lx] == %lx\n", p, *p );
                p += (0x1000/sizeof( ULONG ));
                i -= 0x1000;
                }
            }
        }

    rc = RtlNtStatusToDosError( Status );
    if (rc == NO_ERROR) {
        ClientThreadHandles[ 0 ] = GetCurrentThread();
        ClientThreadClientIds[ 0 ] = GetCurrentThreadId();
        for (i=1; i< NumberOfThreads; i++) {
            fprintf( stderr, "Creating %s, Thread %ld\n", ProcessName, i+1 );
            rc = NO_ERROR;
            ClientThreadHandles[ i ] = CreateThread( NULL,
                                                     0,
                                                     (LPTHREAD_START_ROUTINE)ClientThread,
                                                     (LPVOID)((ClientNumber << 4) | (i+1)),
                                                     CREATE_SUSPENDED,
                                                     &ClientThreadClientIds[ i ]
                                                   );
            if (ClientThreadHandles[ i ] == NULL) {
                rc = GetLastError();
                break;
                }
            }

        if (rc == NO_ERROR) {
            for (i=1; i<NumberOfThreads; i++) {
                ResumeThread( ClientThreadHandles[ i ] );
                }

            ClientThread( (LPVOID)((ClientNumber << 4) | 1) );
            }
        }

    if (rc == NO_ERROR) {
        }
    else {
        fprintf( stderr, "UCLIENT: Initialization Failed - %u\n", rc );
        ExitProcess( rc );
        }

    return( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\ulpc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ulpc.h

Abstract:

    User Mode Test header file for common definitions shared by userver.c
    and uclient.c

Author:

    Steve Wood (stevewo) 28-Aug-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define PORT_NAME L"\\RPC Control\\LpcTestPort"

UNICODE_STRING PortName;

char * LpcMsgTypes[] = {
    "** INVALID **",
    "LPC_REQUEST",
    "LPC_REPLY",
    "LPC_DATAGRAM",
    "LPC_LOST_REPLY",
    "LPC_PORT_CLOSED",
    "LPC_CLIENT_DIED",
    "LPC_EXCEPTION",
    "LPC_DEBUG_EVENT",
    "LPC_ERROR_EVENT",
    "LPC_CONNECTION_REQUEST",
    NULL
};

SECURITY_QUALITY_OF_SERVICE DynamicQos = {
    SecurityImpersonation,
    SECURITY_DYNAMIC_TRACKING,
    TRUE
    };

#define TLPC_MAX_MSG_DATA_LENGTH 16

typedef struct _TLPC_PORTMSG {
    PORT_MESSAGE h;
    ULONG Data[ TLPC_MAX_MSG_DATA_LENGTH ];
} TLPC_PORTMSG, *PTLPC_PORTMSG;

PCH   ClientMemoryBase = 0;
ULONG ClientMemorySize = 0;
PCH   ServerMemoryBase = 0;
ULONG ServerMemoryDelta = 0;

typedef struct _PAGE {
    CHAR Data[ 4096 ];
} PAGE, *PPAGE;

PPORT_MESSAGE
InitTlpcMsg(
    PTLPC_PORTMSG Msg,
    PVOID Context,
    ULONG MsgLength
    )
{
    ULONG i;
    ULONG ClientIndex;
    ULONG cbData = MsgLength % (TLPC_MAX_MSG_DATA_LENGTH * sizeof( ULONG ));
    PULONG ClientMemoryPtr;

    Msg->h.u1.Length = ((sizeof( Msg->h ) + cbData) << 16) | cbData;
    Msg->h.u2.ZeroInit = 0;
    ClientIndex = (ULONG)Context & 0xF;
    ClientIndex -= 1;
    if (cbData) {
        Msg->Data[ 0 ] = (ULONG)Context;
        ClientMemoryPtr = (PULONG)(ClientMemoryBase + (ClientIndex * 0x1000));
        for (i=1; i<(cbData/sizeof(ULONG)); i++) {
            *ClientMemoryPtr = (ULONG)Context;
            Msg->Data[ i ] = (ULONG)ClientMemoryPtr + ServerMemoryDelta;
            ClientMemoryPtr++;
            }
        }

    return( (PPORT_MESSAGE)Msg );
}

BOOLEAN
CheckTlpcMsg(
    NTSTATUS Status,
    PTLPC_PORTMSG Msg
    )
{
    ULONG i;
    ULONG ClientIndex;
    ULONG cbData = Msg->h.u1.s1.DataLength;
    ULONG Context;
    PULONG ServerMemoryPtr;
    PULONG ClientMemoryPtr;
    ULONG ExpectedContext;
    BOOLEAN Result;

    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, " - FAILED.  Status == %X\n", Status );
        return( FALSE );
        }

    if (Msg->h.u2.s2.Type == LPC_CONNECTION_REQUEST) {
        fprintf( stderr, " connection request" );
        }
    else
    if (cbData) {
        Context = Msg->Data[ 0 ];
        ClientIndex = Context & 0xF;
        ClientIndex -= 1;
        ClientMemoryPtr = (PULONG)(ClientMemoryBase + (ClientIndex * 0x1000));
        for (i=1; i<(cbData/sizeof( ULONG )); i++) {
            if (Msg->h.u2.s2.Type == LPC_REPLY) {
                if (Msg->Data[ i ] != ((ULONG)ClientMemoryPtr + ServerMemoryDelta) ||
                    *ClientMemoryPtr != (ULONG)Context
                   ) {
                    fprintf( stderr, " incorrectly\n" );
                    fprintf( stderr, "    Msg->Data[ %ld ] == %lx != %lx || %lx -> %lx != %lx\n",
                             i, Msg->Data[ i ], (ULONG)ClientMemoryPtr + ServerMemoryDelta,
                             ClientMemoryPtr, *ClientMemoryPtr, Context
                           );
                    return( FALSE );
                    }

                ClientMemoryPtr++;
                }
            else {
                ServerMemoryPtr = (PULONG)(Msg->Data[ i ]);
                try {
                    ExpectedContext = *ServerMemoryPtr;
                    Result = (ExpectedContext != Context) ? FALSE : TRUE;
                    }
                except( EXCEPTION_EXECUTE_HANDLER ) {
                    ExpectedContext = 0xFEFEFEFE;
                    Result = FALSE;
                    }

                if (!Result) {
                    fprintf( stderr, " incorrectly\n" );
                    fprintf( stderr, "    Msg->Data[ %ld ] == %lx -> %lx != %lx\n",
                             i, Msg->Data[ i ], ExpectedContext, Context
                           );
                    return( FALSE );
                }
                }
            }
        }

    fprintf( stderr, " correctly\n" );
    return( TRUE );
}


BOOLEAN
ShowHandleOrStatus(
    NTSTATUS Status,
    HANDLE Handle
    )
{
    if (NT_SUCCESS( Status )) {
        fprintf( stderr, " - Handle = 0x%lx\n", Handle );
        return( TRUE );
        }
    else {
        fprintf( stderr, " - *** FAILED *** Status == %X\n", Status );
        return( FALSE );
        }
}


BOOLEAN
ShowStatus(
    NTSTATUS Status
    )
{
    if (NT_SUCCESS( Status )) {
        fprintf( stderr, " - success\n" );
        return( TRUE );
        }
    else {
        fprintf( stderr, " - *** FAILED *** Status == %X\n", Status );
        return( FALSE );
        }
}

PCH EnterString = ">>>>>>>>>>";
PCH InnerString = "||||||||||";
PCH LeaveString = "<<<<<<<<<<";

NTSTATUS
SendRequest(
    ULONG Level,
    PSZ ThreadName,
    HANDLE PortHandle,
    PVOID Context,
    ULONG MsgLength,
    PTLPC_PORTMSG CallBackTarget,
    BOOLEAN ServerCallingClient
    )
{
    NTSTATUS Status;
    TLPC_PORTMSG Request, Reply;
    PTEB Teb = NtCurrentTeb();

    fprintf( stderr, "%.*sEnter SendRequest, %lx.%lx",
             Level, EnterString,
             Teb->ClientId.UniqueProcess,
             Teb->ClientId.UniqueThread
           );

    InitTlpcMsg( &Request, Context, MsgLength );
    if (CallBackTarget == NULL) {
        fprintf( stderr, " - Request");
        }
    else {
        Request.h.u2.s2.Type = LPC_REQUEST;
        Request.h.ClientId = CallBackTarget->h.ClientId;
        Request.h.MessageId = CallBackTarget->h.MessageId;
        fprintf( stderr, " - Callback to %lx.%lx, ID: %ld",
                 Request.h.ClientId.UniqueProcess,
                 Request.h.ClientId.UniqueThread,
                 Request.h.MessageId
               );
        }

    fprintf( stderr, " (%ld bytes)...\n", Request.h.u1.s1.DataLength );
    Status = NtRequestWaitReplyPort( PortHandle,
                                     (PPORT_MESSAGE)&Request,
                                     (PPORT_MESSAGE)&Reply
                                   );
    fprintf( stderr, "%.*s %lx.%lx, ID: %u received ",
             Level, InnerString,
             Teb->ClientId.UniqueProcess,
             Teb->ClientId.UniqueThread,
             Reply.h.MessageId
           );

    if (Reply.h.u2.s2.Type == LPC_REPLY) {
        if (!CheckTlpcMsg( Status, &Reply )) {
            Status = STATUS_UNSUCCESSFUL;
            fprintf( stderr, "SendRequest got invalid reply message at %x\n", &Reply );
            DbgBreakPoint();
            }
        }
    else {
        fprintf( stderr, "callback from %lx.%lx, ID: %ld",
                 Reply.h.ClientId.UniqueProcess,
                 Reply.h.ClientId.UniqueThread,
                 Reply.h.MessageId
               );
        if (!CheckTlpcMsg( Status, &Reply )) {
            Status = STATUS_UNSUCCESSFUL;
            fprintf( stderr, "SendRequest got invalid callback message at %x\n", &Reply );
            DbgBreakPoint();
            }
        else {
            MsgLength = Reply.h.u1.s1.DataLength / 2;
            if (MsgLength) {
                Status = SendRequest( Level+1,
                                      ThreadName,
                                      PortHandle,
                                      Context,
                                      MsgLength,
                                      &Reply,
                                      ServerCallingClient
                                    );
                }

            if (!ServerCallingClient || Level > 1) {
                fprintf( stderr, "%.*s %lx.%lx sending ",
                         Level, InnerString,
                         Teb->ClientId.UniqueProcess,
                         Teb->ClientId.UniqueThread
                       );
                fprintf( stderr, " callback (%u) reply to %lx.%lx, ID: %u (%ld bytes)...\n",
                         Level,
                         Reply.h.ClientId.UniqueProcess,
                         Reply.h.ClientId.UniqueThread,
                         Reply.h.MessageId,
                         Reply.h.u1.s1.DataLength
                       );
                if (Level > 1) {
                    Status = NtReplyWaitReplyPort( PortHandle,
                                                   (PPORT_MESSAGE)&Reply
                                                 );
                    }
                }
            }
        }

    fprintf( stderr, "%.*sLeave SendRequest, %lx.%lx - Status == %X\n",
             Level, LeaveString,
             Teb->ClientId.UniqueProcess,
             Teb->ClientId.UniqueThread,
             Status
           );
    return( Status );
}

VOID
EnterThread(
    PSZ ThreadName,
    ULONG Context
    )
{
    fprintf( stderr, "Entering %s thread, Context = 0x%lx\n",
             ThreadName,
             Context
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\lpcrecv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lpcrecv.c

Abstract:

    Local Inter-Process Communication (LPC) receive system services.

Author:

    Steve Wood (stevewo) 15-May-1989

Revision History:

--*/

#include "lpcp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtReplyWaitReceivePort)
#pragma alloc_text(PAGE,NtReplyWaitReceivePortEx)
#endif


NTSTATUS
NtReplyWaitReceivePort (
    IN HANDLE PortHandle,
    OUT PVOID *PortContext OPTIONAL,
    IN PPORT_MESSAGE ReplyMessage OPTIONAL,
    OUT PPORT_MESSAGE ReceiveMessage
    )

/*++

Routine Description:

    This procedure is used by the server process to wait for a message from a
    client process

    A client and server process can receive messages using the
    NtReplyWaitReceivePort service:

    If the ReplyMessage parameter is specified, then the reply will be sent
    using NtReplyPort.

    If the PortHandle parameter specifies a connection port, then the receive
    will return whenever a message is sent to a server communication port that
    does not have its own receive queue and the message is therefore queued to
    the receive queue of the connection port.

    If the PortHandle parameter specifies a server communication port that
    does not have a receive queue, then behaves as if the associated
    connection port handle was specified.  Otherwise the receive will return
    whenever message is placed in the receive queue associated with the
    server communication port.

    The received message will be returned in the variable specified by the
    ReceiveMessage parameter.  If the MapInfoOffset field of the reply message
    is non-zero, then the PORT_MAP_INFORMATION structure it points to will be
    processed and the relevant pages will be mapped into the caller's address
    space.  The service returns an error if there is not enough room in the
    caller's address space to accomodate the mappings.

Arguments:

    PortHandle - Specifies the handle of the connection or communication port
        to do the receive from.

    PortContext - Specifies an optional pointer to a variable that is to
        receive the context value associated with the communication port that
        the message is being received from.  This context variable was
        specified on the call to the NtAcceptConnectPort service.

    ReplyMessage - This optional parameter specifies the address of a reply
        message to be sent.  The ClientId and MessageId fields determine which
        thread will get the reply.  See description of NtReplyPort for how the
        reply is sent.  The reply is sent before blocking for the receive.

    ReceiveMessage - Specifies the address of a variable to receive the
        message.

Return Value:

    Status code that indicates whether or not the operation was successful.

--*/

{
    PAGED_CODE();

    return NtReplyWaitReceivePortEx (PortHandle,
                                     PortContext,
                                     ReplyMessage,
                                     ReceiveMessage,
                                     NULL);
}

NTSTATUS
NtReplyWaitReceivePortEx(
    IN HANDLE PortHandle,
    OUT PVOID *PortContext OPTIONAL,
    IN PPORT_MESSAGE ReplyMessage OPTIONAL,
    OUT PPORT_MESSAGE ReceiveMessage,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    See NtReplyWaitReceivePort.

Arguments:

    See NtReplyWaitReceivePort.

    Timeout - Supplies an optional timeout value to use when waiting for a
        receive.

Return Value:

    See NtReplyWaitReceivePort.

--*/

{
    PLPCP_PORT_OBJECT PortObject;
    PLPCP_PORT_OBJECT ReceivePort;
    PORT_MESSAGE CapturedReplyMessage;
    KPROCESSOR_MODE PreviousMode;
    KPROCESSOR_MODE WaitMode;
    NTSTATUS Status;
    PLPCP_MESSAGE Msg;
    PETHREAD CurrentThread;
    PETHREAD WakeupThread;
    LARGE_INTEGER TimeoutValue ;
    PLPCP_PORT_OBJECT ConnectionPort = NULL;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread();

    TimeoutValue.QuadPart = 0 ;

    //
    //  Get previous processor mode
    //

    PreviousMode = KeGetPreviousMode();
    WaitMode = PreviousMode;

    if (PreviousMode != KernelMode) {

        try {

            if (ARGUMENT_PRESENT( PortContext )) {

                ProbeForWriteUlong( (PULONG)PortContext );
            }

            if (ARGUMENT_PRESENT( ReplyMessage)) {

                ProbeForReadSmallStructure( ReplyMessage,
                                            sizeof( *ReplyMessage ),
                                            sizeof( ULONG ));

                CapturedReplyMessage = *ReplyMessage;
            }

            if (ARGUMENT_PRESENT( Timeout )) {

                TimeoutValue = ProbeAndReadLargeInteger( Timeout );

                Timeout = &TimeoutValue ;
            }

            ProbeForWriteSmallStructure( ReceiveMessage,
                                         sizeof( *ReceiveMessage ),
                                         sizeof( ULONG ));

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

    } else {

        //
        //  Kernel mode threads call with wait mode of user so that their
        //  kernel // stacks are swappable. Main consumer of this is
        //  SepRmCommandThread
        //

        if ( IS_SYSTEM_THREAD(CurrentThread) ) {

            WaitMode = UserMode;
        }

        if (ARGUMENT_PRESENT( ReplyMessage)) {

            CapturedReplyMessage = *ReplyMessage;
        }
    }

    if (ARGUMENT_PRESENT( ReplyMessage)) {

        //
        //  Make sure DataLength is valid with respect to header size and total
        //  length
        //

        if ((((CLONG)CapturedReplyMessage.u1.s1.DataLength) + sizeof( PORT_MESSAGE )) >
            ((CLONG)CapturedReplyMessage.u1.s1.TotalLength)) {

            return STATUS_INVALID_PARAMETER;
        }

        //
        //  Make sure the user didn't give us a bogus reply message id
        //

        if (CapturedReplyMessage.MessageId == 0) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Reference the port object by handle and if that doesn't work try
    //  a waitable port object type
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        Status = ObReferenceObjectByHandle( PortHandle,
                                            0,
                                            LpcWaitablePortObjectType,
                                            PreviousMode,
                                            &PortObject,
                                            NULL );

        if ( !NT_SUCCESS( Status ) ) {

            return Status;
        }
    }

    //
    //  Validate the message length
    //

    if (ARGUMENT_PRESENT( ReplyMessage )) {

        if (((ULONG)CapturedReplyMessage.u1.s1.TotalLength > PortObject->MaxMessageLength) ||
            ((ULONG)CapturedReplyMessage.u1.s1.TotalLength <= (ULONG)CapturedReplyMessage.u1.s1.DataLength)) {

            ObDereferenceObject( PortObject );

            return STATUS_PORT_MESSAGE_TOO_LONG;
        }
    }

    //
    //  The receive port we use is either the connection port for the port
    //  object we were given if we were given a client communication port then
    //  we expect to receive the reply on the communication port itself.
    //

    if ((PortObject->Flags & PORT_TYPE) != CLIENT_COMMUNICATION_PORT) {

        LpcpAcquireLpcpLockByThread(CurrentThread);
        
        ConnectionPort = ReceivePort = PortObject->ConnectionPort;
        
        if (ConnectionPort == NULL) {
            
            LpcpReleaseLpcpLock();
            ObDereferenceObject( PortObject );

            return STATUS_PORT_DISCONNECTED;
        }

        ObReferenceObject( ConnectionPort );
        LpcpReleaseLpcpLock();
        
    } else {

        ReceivePort = PortObject;
    }

    //
    //  If ReplyMessage argument present, then send reply
    //

    if (ARGUMENT_PRESENT( ReplyMessage )) {

        //
        //  Translate the ClientId from the connection request into a
        //  thread pointer.  This is a referenced pointer to keep the thread
        //  from evaporating out from under us.
        //

        Status = PsLookupProcessThreadByCid( &CapturedReplyMessage.ClientId,
                                             NULL,
                                             &WakeupThread );

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( PortObject );

            if (ConnectionPort) {

                ObDereferenceObject(ConnectionPort);
            }

            return Status;
        }

        //
        //  Acquire the global Lpc mutex that guards the LpcReplyMessage
        //  field of the thread and get the pointer to the message that
        //  the thread is waiting for a reply to.
        //


        Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( CapturedReplyMessage.u1.s1.TotalLength );

        if (Msg == NULL) {
            
            if (ConnectionPort) {

                ObDereferenceObject(ConnectionPort);
            }

            ObDereferenceObject( WakeupThread );
            ObDereferenceObject( PortObject );

            return STATUS_NO_MEMORY;
        }
        LpcpAcquireLpcpLockByThread(CurrentThread);

        //
        //  See if the thread is waiting for a reply to the message
        //  specified on this call.  If not then a bogus message
        //  has been specified, so release the mutex, dereference the thread
        //  and return failure.
        //
        //  We also fail this request if the caller isn't replying to a request
        //  message.  For example, if the caller is replying to a connection
        //  request
        //

        if ((WakeupThread->LpcReplyMessageId != CapturedReplyMessage.MessageId)

                ||

            ((LpcpGetThreadMessage(WakeupThread) != NULL) &&
             (LpcpGetThreadMessage(WakeupThread)->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_REQUEST)
                
                ||
            
            (!LpcpValidateClientPort(WakeupThread, PortObject, LPCP_VALIDATE_REASON_REPLY))) {

            LpcpPrint(( "%s Attempted ReplyWaitReceive to Thread %lx (%s)\n",
                        PsGetCurrentProcess()->ImageFileName,
                        WakeupThread,
                        THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

            LpcpPrint(( "failed.  MessageId == %u  Client Id: %x.%x\n",
                        CapturedReplyMessage.MessageId,
                        CapturedReplyMessage.ClientId.UniqueProcess,
                        CapturedReplyMessage.ClientId.UniqueThread ));

            LpcpPrint(( "         Thread MessageId == %u  Client Id: %x.%x\n",
                        WakeupThread->LpcReplyMessageId,
                        WakeupThread->Cid.UniqueProcess,
                        WakeupThread->Cid.UniqueThread ));

#if DBG
            if (LpcpStopOnReplyMismatch) {

                DbgBreakPoint();
            }
#endif

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

            if (ConnectionPort) {

                ObDereferenceObject(ConnectionPort);
            }

            ObDereferenceObject( WakeupThread );
            ObDereferenceObject( PortObject );

            return STATUS_REPLY_MESSAGE_MISMATCH;
        }

        //
        //  Copy the reply message to the request message buffer.  Do this before
        //  we actually fiddle with the wakeup threads fields.  Otherwise we
        //  could mess up its state
        //

        try {

            LpcpMoveMessage( &Msg->Request,
                             &CapturedReplyMessage,
                             (ReplyMessage + 1),
                             LPC_REPLY,
                             NULL );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

            if (ConnectionPort) {

                ObDereferenceObject(ConnectionPort);
            }

            ObDereferenceObject( WakeupThread );
            ObDereferenceObject( PortObject );

            return (Status = GetExceptionCode());
        }

        LpcpTrace(( "%s Sending Reply Msg %lx (%u.%u, %x) [%08x %08x %08x %08x] to Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    Msg,
                    CapturedReplyMessage.MessageId,
                    CapturedReplyMessage.CallbackId,
                    CapturedReplyMessage.u2.s2.DataInfoOffset,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    WakeupThread,
                    THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

        //
        //  Locate and free the messsage from the port.  This call use to
        //  test for (CapturedReplyMessage.u2.s2.DataInfoOffset != 0) as a
        //  prerequisite for doing the call.
        //

        LpcpFreeDataInfoMessage( PortObject,
                                 CapturedReplyMessage.MessageId,
                                 CapturedReplyMessage.CallbackId );

        //
        //  Add an extra reference so LpcExitThread does not evaporate
        //  the pointer before we get to the wait below
        //

        ObReferenceObject( WakeupThread );

        //
        //  Release the mutex that guards the LpcReplyMessage field
        //  after marking message as being replied to.
        //

        Msg->RepliedToThread = WakeupThread;

        WakeupThread->LpcReplyMessageId = 0;
        WakeupThread->LpcReplyMessage = (PVOID)Msg;

        //
        //  Remove the thread from the reply rundown list as we are sending the reply.
        //

        if ((!WakeupThread->LpcExitThreadCalled) && (!IsListEmpty( &WakeupThread->LpcReplyChain ))) {

            RemoveEntryList( &WakeupThread->LpcReplyChain );

            InitializeListHead( &WakeupThread->LpcReplyChain );
        }

        if ((CurrentThread->LpcReceivedMsgIdValid) &&
            (CurrentThread->LpcReceivedMessageId == CapturedReplyMessage.MessageId)) {

            CurrentThread->LpcReceivedMessageId = 0;

            CurrentThread->LpcReceivedMsgIdValid = FALSE;
        }

        LpcpReleaseLpcpLock();

        //
        //  Wake up the thread that is waiting for an answer to its request
        //  inside of NtRequestWaitReplyPort or NtReplyWaitReplyPort
        //

        KeReleaseSemaphore( &WakeupThread->LpcReplySemaphore,
                            1,
                            1,
                            FALSE );

        ObDereferenceObject( WakeupThread );

    }

    LpcpTrace(( "%s Waiting for message to Port %x (%s)\n",
                PsGetCurrentProcess()->ImageFileName,
                ReceivePort,
                LpcpGetCreatorName( ReceivePort )));

    //
    //  The timeout on this wait and the next wait appear to be the
    //  only substantial difference between NtReplyWaitReceivePort
    //  and NtReplyWaitReceivePortEx

    Status = KeWaitForSingleObject( ReceivePort->MsgQueue.Semaphore,
                                    WrLpcReceive,
                                    WaitMode,
                                    FALSE,
                                    Timeout );

    //
    //  Fall into receive code.  Client thread reference will be
    //  returned by the client when it wakes up.
    //
    
    //
    //  At this point we've awoke from our wait for a receive
    //

    if (Status == STATUS_SUCCESS) {

        LpcpAcquireLpcpLockByThread(CurrentThread);

        //
        //  See if we awoke without a message in our receive port
        //

        if (IsListEmpty( &ReceivePort->MsgQueue.ReceiveHead )) {

            if ( ReceivePort->Flags & PORT_WAITABLE ) {

                KeResetEvent( &ReceivePort->WaitEvent );
            }

            LpcpReleaseLpcpLock();

            if (ConnectionPort) {

                ObDereferenceObject(ConnectionPort);
            }

            ObDereferenceObject( PortObject );

            return STATUS_UNSUCCESSFUL;
        }

        //
        //  We have a message in our receive port.  So let's pull it out
        //

        Msg = (PLPCP_MESSAGE)RemoveHeadList( &ReceivePort->MsgQueue.ReceiveHead );

        if ( IsListEmpty( &ReceivePort->MsgQueue.ReceiveHead ) ) {

            if ( ReceivePort->Flags & PORT_WAITABLE ) {

                KeResetEvent( &ReceivePort->WaitEvent );
            }
        }

        InitializeListHead( &Msg->Entry );

        LpcpTrace(( "%s Receive Msg %lx (%u) from Port %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    Msg,
                    Msg->Request.MessageId,
                    ReceivePort,
                    LpcpGetCreatorName( ReceivePort )));

        //
        //  Now make the thread state to be the message we're currently
        //  working on
        //

        // NOTICE-2002/03/19-ScottMa -- The valid flag is set to TRUE before
        //   filling in the actual Id, so that the Process/Thread rundown code
        //   will not accidentally read the Id field as a Win32StartAddress.
        //   This if safe, since the only code that reads this value is in one
        //   of three places:
        //   1)  LPC files           -- All are protected by LpcpLock.
        //   2)  ExpCopyThreadInfo   -- This fix makes the refernce safe.
        //   3)  Debugger extensions -- Both !lpc and !process can still
        //                              experience a bug displaying the
        //                              correct value of this union.
        //   Note that checking the ownership of the LpcpLock would allow
        //   both the debugger extensions and ExpCopyThreadInfo to determine
        //   if the values are in a state of flux.

        CurrentThread->LpcReceivedMsgIdValid = TRUE;
        CurrentThread->LpcReceivedMessageId = Msg->Request.MessageId;

        try {

            //
            //  Check if the message is a connection request
            //

            if ((Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_CONNECTION_REQUEST) {

                PLPCP_CONNECTION_MESSAGE ConnectMsg;
                ULONG ConnectionInfoLength;
                PLPCP_MESSAGE TempMsg;

                ConnectMsg = (PLPCP_CONNECTION_MESSAGE)(Msg + 1);

                ConnectionInfoLength = Msg->Request.u1.s1.DataLength - sizeof( *ConnectMsg );

                //
                //  Don't free message until NtAcceptConnectPort called, and if it's never called
                //  then we'll keep the message until the client exits.
                //

                TempMsg = Msg;
                Msg = NULL;

                *ReceiveMessage = TempMsg->Request;

                ReceiveMessage->u1.s1.TotalLength = (CSHORT)(sizeof( *ReceiveMessage ) + ConnectionInfoLength);
                ReceiveMessage->u1.s1.DataLength = (CSHORT)ConnectionInfoLength;

                RtlCopyMemory( ReceiveMessage+1,
                               ConnectMsg + 1,
                               ConnectionInfoLength );

                if (ARGUMENT_PRESENT( PortContext )) {

                    *PortContext = NULL;
                }

            //
            //  Check if the message is not a reply
            //

            } else if ((Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_REPLY) {

                LpcpMoveMessage( ReceiveMessage,
                                 &Msg->Request,
                                 (&Msg->Request) + 1,
                                 0,
                                 NULL );

                if (ARGUMENT_PRESENT( PortContext )) {

                    *PortContext = Msg->PortContext;
                }

                //
                //  If message contains DataInfo for access via NtRead/WriteRequestData
                //  then put the message on a list in the communication port and don't
                //  free it.  It will be freed when the server replies to the message.
                //

                if (Msg->Request.u2.s2.DataInfoOffset != 0) {

                    LpcpSaveDataInfoMessage( PortObject, Msg, LPCP_MUTEX_OWNED );
                    Msg = NULL;
                }

            //
            //  Otherwise this is a reply message we just received
            //

            } else {

                LpcpPrint(( "LPC: Bogus reply message (%08x) in receive queue of connection port %08x\n",
                            Msg, ReceivePort ));

                KdBreakPoint();
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();    
        }

        //
        //  Acquire the LPC mutex and decrement the reference count for the
        //  message.  If the reference count goes to zero the message will be
        //  deleted.
        //

        if (Msg != NULL) {

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );
        }
        else {
        
            LpcpReleaseLpcpLock();
        }
    }

    if (ConnectionPort) {

        ObDereferenceObject(ConnectionPort);
    }

    ObDereferenceObject( PortObject );

    //
    //  And return to our caller
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\lpc\userver.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    userver.c

Abstract:

    User Mode Server Test program for the LPC subcomponent of the NTOS project

Author:

    Steve Wood (stevewo) 28-Aug-1989

Revision History:

--*/

#include "ulpc.h"

#define MAX_REQUEST_THREADS 9
#define MAX_CONNECTIONS 4

HANDLE ServerConnectionPortHandle;
HANDLE ServerThreadHandles[ MAX_REQUEST_THREADS ];
DWORD  ServerThreadClientIds[ MAX_REQUEST_THREADS ];

HANDLE ServerClientPortHandles[ MAX_CONNECTIONS ];
ULONG CountServerClientPortHandles = 0;
ULONG CountClosedServerClientPortHandles = 0;

BOOLEAN TestCallBacks;

VOID
ServerHandleConnectionRequest(
    IN PTLPC_PORTMSG Msg
    )
{
    BOOLEAN AcceptConnection;
    LPSTR ConnectionInformation;
    ULONG ConnectionInformationLength;
    NTSTATUS Status;
    PORT_VIEW ServerView;
    REMOTE_PORT_VIEW ClientView;
    ULONG i;
    PULONG p;

    ConnectionInformation = (LPSTR)&Msg->Data[ 0 ];
    ConnectionInformationLength = Msg->h.u1.s1.DataLength;
    AcceptConnection = FALSE;
    fprintf( stderr, "\nConnection Request Received from CLIENT_ID 0x%08lx.0x%08lx:\n",
              Msg->h.ClientId.UniqueProcess,
              Msg->h.ClientId.UniqueThread
            );
    fprintf( stderr, "    MessageId: %ld\n",
              Msg->h.MessageId
            );
    fprintf( stderr, "    ClientViewSize: 0x%08lx\n",
              Msg->h.ClientViewSize
            );
    fprintf( stderr, "    ConnectionInfo: (%ld) '%.*s'\n",
              ConnectionInformationLength,
              ConnectionInformationLength,
              (PSZ)&ConnectionInformation[0]
            );

    ClientView.Length = sizeof( ClientView );
    ClientView.ViewSize = 0;
    ClientView.ViewBase = 0;
    if (CountServerClientPortHandles >= MAX_CONNECTIONS) {
        AcceptConnection = FALSE;
        }
    else {
        AcceptConnection = TRUE;
        }

    if (AcceptConnection) {
        LARGE_INTEGER MaximumSize;

        fprintf( stderr, "Creating Port Memory Section" );
        MaximumSize.QuadPart = 0x4000;
        Status = NtCreateSection( &ServerView.SectionHandle,
                                  SECTION_MAP_READ | SECTION_MAP_WRITE,
                                  NULL,
                                  &MaximumSize,
                                  PAGE_READWRITE,
                                  SEC_COMMIT,
                                  NULL
                                );

        if (ShowHandleOrStatus( Status, ServerView.SectionHandle )) {
            ServerView.Length = sizeof( ServerView );
            ServerView.SectionOffset = 0;
            ServerView.ViewSize = 0x4000;
            ServerView.ViewBase = 0;
            ServerView.ViewRemoteBase = 0;
            }
        else {
            AcceptConnection = FALSE;
            }
        }

    fprintf( stderr, "Server calling NtAcceptConnectPort( AcceptConnection = %ld )",
              AcceptConnection
            );

    if (AcceptConne